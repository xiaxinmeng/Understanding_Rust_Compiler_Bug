{"sha": "6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ODU5MTdkN2NhODMyZWU4ODY3YzZhN2E1NWFmM2VkMWU5ZDMwNGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-21T22:18:39Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-24T17:51:39Z"}, "message": "Move extra::json to libserialize\n\nThis also inverts the dependency between libserialize and libcollections.\n\ncc #8784", "tree": {"sha": "b5c5ce62644376eae2ebb150c5d14a8eb34fe5fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5c5ce62644376eae2ebb150c5d14a8eb34fe5fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "html_url": "https://github.com/rust-lang/rust/commit/6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "672097753a217d4990129cbdfab16ef8c9b08b21", "url": "https://api.github.com/repos/rust-lang/rust/commits/672097753a217d4990129cbdfab16ef8c9b08b21", "html_url": "https://github.com/rust-lang/rust/commit/672097753a217d4990129cbdfab16ef8c9b08b21"}], "stats": {"total": 671, "additions": 340, "deletions": 331}, "files": [{"sha": "fadbaf5a6c8461bb8da1151072963f7a3afe0bb3", "filename": "mk/crates.mk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -68,15 +68,15 @@ DEPS_rustdoc := rustc native:sundown serialize sync getopts collections \\\n DEPS_flate := std native:miniz\n DEPS_arena := std collections\n DEPS_glob := std\n-DEPS_serialize := std\n+DEPS_serialize := std collections\n DEPS_term := std collections\n DEPS_semver := std\n DEPS_uuid := std serialize\n DEPS_sync := std\n DEPS_getopts := std\n-DEPS_collections := std serialize\n+DEPS_collections := std\n DEPS_fourcc := syntax std\n-DEPS_num := std extra\n+DEPS_num := std\n DEPS_test := std extra collections getopts serialize term\n DEPS_time := std serialize\n "}, {"sha": "9bc394abf5e5cdb383fa97e15f4ab61ee5f881a8", "filename": "src/doc/rust.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -875,16 +875,16 @@ An example of what will and will not work for `use` items:\n \n ~~~~\n # #[allow(unused_imports)];\n-use foo::extra::json;    // good: foo is at the root of the crate\n+use foo::native::start;  // good: foo is at the root of the crate\n use foo::baz::foobaz;    // good: foo is at the root of the crate\n \n mod foo {\n-    extern crate extra;\n+    extern crate native;\n \n-    use foo::extra::json;  // good: foo is at crate root\n-//  use extra::json::*;    // bad:  extra is not at the crate root\n-    use self::baz::foobaz; // good: self refers to module 'foo'\n-    use foo::bar::foobar;  // good: foo is at crate root\n+    use foo::native::start; // good: foo is at crate root\n+//  use native::start;      // bad:  native is not at the crate root\n+    use self::baz::foobaz;  // good: self refers to module 'foo'\n+    use foo::bar::foobar;   // good: foo is at crate root\n \n     pub mod bar {\n         pub fn foobar() { }"}, {"sha": "4a4ec01f6d20aafd50566c7a0b82dfe84b5df3e4", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -30,8 +30,6 @@ use std::iter;\n \n use deque::Deque;\n \n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n-\n /// A doubly-linked list.\n pub struct DList<T> {\n     priv length: uint,\n@@ -630,31 +628,6 @@ impl<A: Clone> Clone for DList<A> {\n     }\n }\n \n-impl<\n-    S: Encoder,\n-    T: Encodable<S>\n-> Encodable<S> for DList<T> {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s));\n-            }\n-        })\n-    }\n-}\n-\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for DList<T> {\n-    fn decode(d: &mut D) -> DList<T> {\n-        let mut list = DList::new();\n-        d.read_seq(|d, len| {\n-            for i in range(0u, len) {\n-                list.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n-            }\n-        });\n-        list\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     extern crate test;"}, {"sha": "f33d77ba68219921b665135ffceb42586b2b99de", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -15,7 +15,7 @@\n \n use std::num::Bitwise;\n \n-#[deriving(Clone, Eq, Hash, Show, Encodable, Decodable)]\n+#[deriving(Clone, Eq, Hash, Show)]\n /// A specialized Set implementation to use enum types.\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set"}, {"sha": "4f0b7dfb35dde5e8975b28c796e3c60bcdfad8d1", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -65,8 +65,6 @@ use std::vec::{Items, MutItems};\n use std::vec_ng::Vec;\n use std::vec_ng;\n \n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n-\n static INITIAL_CAPACITY: uint = 32u; // 2^5\n \n struct Bucket<K,V> {\n@@ -912,71 +910,6 @@ pub type SetAlgebraItems<'a, T> =\n     FilterMap<'static,(&'a HashSet<T>, &'a T), &'a T,\n               Zip<Repeat<&'a HashSet<T>>,SetItems<'a,T>>>;\n \n-impl<\n-    E: Encoder,\n-    K: Encodable<E> + Hash + Eq,\n-    V: Encodable<E>\n-> Encodable<E> for HashMap<K, V> {\n-    fn encode(&self, e: &mut E) {\n-        e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            for (key, val) in self.iter() {\n-                e.emit_map_elt_key(i, |e| key.encode(e));\n-                e.emit_map_elt_val(i, |e| val.encode(e));\n-                i += 1;\n-            }\n-        })\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    K: Decodable<D> + Hash + Eq,\n-    V: Decodable<D>\n-> Decodable<D> for HashMap<K, V> {\n-    fn decode(d: &mut D) -> HashMap<K, V> {\n-        d.read_map(|d, len| {\n-            let mut map = HashMap::with_capacity(len);\n-            for i in range(0u, len) {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n-                map.insert(key, val);\n-            }\n-            map\n-        })\n-    }\n-}\n-\n-impl<\n-    S: Encoder,\n-    T: Encodable<S> + Hash + Eq\n-> Encodable<S> for HashSet<T> {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            for e in self.iter() {\n-                s.emit_seq_elt(i, |s| e.encode(s));\n-                i += 1;\n-            }\n-        })\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    T: Decodable<D> + Hash + Eq\n-> Decodable<D> for HashSet<T> {\n-    fn decode(d: &mut D) -> HashSet<T> {\n-        d.read_seq(|d, len| {\n-            let mut set = HashSet::with_capacity(len);\n-            for i in range(0u, len) {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n-            }\n-            set\n-        })\n-    }\n-}\n-\n #[cfg(test)]\n mod test_map {\n     use super::{HashMap, HashSet};"}, {"sha": "14aee6653ac062fbfa9f7d77f91e729a831c9a2a", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -19,7 +19,6 @@\n \n #[feature(macro_rules, managed_boxes)];\n \n-extern crate serialize;\n #[cfg(test)] extern crate test;\n \n pub use bitv::Bitv;"}, {"sha": "4b97bfbd18de59f331ee308394cf4f0307f08cc6", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -19,8 +19,6 @@ use std::iter::{Rev, RandomAccessIterator};\n \n use deque::Deque;\n \n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n-\n static INITIAL_CAPACITY: uint = 8u; // 2^3\n static MINIMUM_CAPACITY: uint = 2u;\n \n@@ -404,31 +402,6 @@ impl<A> Extendable<A> for RingBuf<A> {\n     }\n }\n \n-impl<\n-    S: Encoder,\n-    T: Encodable<S>\n-> Encodable<S> for RingBuf<T> {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s));\n-            }\n-        })\n-    }\n-}\n-\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for RingBuf<T> {\n-    fn decode(d: &mut D) -> RingBuf<T> {\n-        let mut deque = RingBuf::new();\n-        d.read_seq(|d, len| {\n-            for i in range(0u, len) {\n-                deque.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n-            }\n-        });\n-        deque\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     extern crate test;"}, {"sha": "6388b4c7c521d45eae0e7e3a7741722e55fa87fc", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -17,8 +17,6 @@ use std::cmp::Ordering;\n use std::mem::{replace, swap};\n use std::ptr;\n \n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n-\n // This is implemented as an AA tree, which is a simplified variation of\n // a red-black tree where red (horizontal) nodes can only be added\n // as a right child. The time complexity is the same, and re-balancing\n@@ -1006,71 +1004,6 @@ impl<T: TotalOrd> Extendable<T> for TreeSet<T> {\n     }\n }\n \n-impl<\n-    E: Encoder,\n-    K: Encodable<E> + Eq + TotalOrd,\n-    V: Encodable<E> + Eq\n-> Encodable<E> for TreeMap<K, V> {\n-    fn encode(&self, e: &mut E) {\n-        e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            for (key, val) in self.iter() {\n-                e.emit_map_elt_key(i, |e| key.encode(e));\n-                e.emit_map_elt_val(i, |e| val.encode(e));\n-                i += 1;\n-            }\n-        })\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    K: Decodable<D> + Eq + TotalOrd,\n-    V: Decodable<D> + Eq\n-> Decodable<D> for TreeMap<K, V> {\n-    fn decode(d: &mut D) -> TreeMap<K, V> {\n-        d.read_map(|d, len| {\n-            let mut map = TreeMap::new();\n-            for i in range(0u, len) {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n-                map.insert(key, val);\n-            }\n-            map\n-        })\n-    }\n-}\n-\n-impl<\n-    S: Encoder,\n-    T: Encodable<S> + Eq + TotalOrd\n-> Encodable<S> for TreeSet<T> {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            for e in self.iter() {\n-                s.emit_seq_elt(i, |s| e.encode(s));\n-                i += 1;\n-            }\n-        })\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    T: Decodable<D> + Eq + TotalOrd\n-> Decodable<D> for TreeSet<T> {\n-    fn decode(d: &mut D) -> TreeSet<T> {\n-        d.read_seq(|d, len| {\n-            let mut set = TreeSet::new();\n-            for i in range(0u, len) {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n-            }\n-            set\n-        })\n-    }\n-}\n-\n #[cfg(test)]\n mod test_treemap {\n "}, {"sha": "5d285e7d29e6f6f295a59fa1b7010f3218154772", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -16,8 +16,6 @@ use std::mem::init;\n use std::vec;\n use std::vec::{Items, MutItems};\n \n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n-\n // FIXME: #5244: need to manually update the TrieNode constructor\n static SHIFT: uint = 4;\n static SIZE: uint = 1 << SHIFT;\n@@ -620,59 +618,6 @@ impl<'a> Iterator<uint> for SetItems<'a> {\n     }\n }\n \n-impl<\n-    E: Encoder,\n-    V: Encodable<E>\n-> Encodable<E> for TrieMap<V> {\n-    fn encode(&self, e: &mut E) {\n-        e.emit_map(self.len(), |e| {\n-                for (i, (key, val)) in self.iter().enumerate() {\n-                    e.emit_map_elt_key(i, |e| key.encode(e));\n-                    e.emit_map_elt_val(i, |e| val.encode(e));\n-                }\n-            });\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    V: Decodable<D>\n-> Decodable<D> for TrieMap<V> {\n-    fn decode(d: &mut D) -> TrieMap<V> {\n-        d.read_map(|d, len| {\n-            let mut map = TrieMap::new();\n-            for i in range(0u, len) {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n-                map.insert(key, val);\n-            }\n-            map\n-        })\n-    }\n-}\n-\n-impl<S: Encoder> Encodable<S> for TrieSet {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_seq(self.len(), |s| {\n-                for (i, e) in self.iter().enumerate() {\n-                    s.emit_seq_elt(i, |s| e.encode(s));\n-                }\n-            })\n-    }\n-}\n-\n-impl<D: Decoder> Decodable<D> for TrieSet {\n-    fn decode(d: &mut D) -> TrieSet {\n-        d.read_seq(|d, len| {\n-            let mut set = TrieSet::new();\n-            for i in range(0u, len) {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n-            }\n-            set\n-        })\n-    }\n-}\n-\n #[cfg(test)]\n mod test_map {\n     use super::{TrieMap, TrieNode, Internal, External};"}, {"sha": "ba26e0c44fa39d671c27a521451248d4009293b9", "filename": "src/libextra/lib.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibextra%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibextra%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flib.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -42,19 +42,9 @@ extern crate time;\n // Utility modules\n pub mod c_vec;\n pub mod url;\n-pub mod json;\n pub mod tempfile;\n pub mod workcache;\n pub mod stats;\n \n #[cfg(unicode)]\n mod unicode;\n-\n-// A curious inner-module that's not exported that contains the binding\n-// 'extra' so that macro-expanded references to extra::serialize and such\n-// can be resolved within libextra.\n-#[doc(hidden)]\n-pub mod extra {\n-    pub use serialize;\n-}\n-"}, {"sha": "97c0f7860715cf17c03a5a3d0e6832394e95db8e", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -10,8 +10,8 @@\n \n #[allow(missing_doc)];\n \n-use json;\n-use json::ToJson;\n+use serialize::json;\n+use serialize::json::ToJson;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n use sync::{Arc,RWArc};\n use collections::TreeMap;"}, {"sha": "8e42b01f14ccbe7a02ae8f95a4e1f8b3c2f5697f", "filename": "src/libnum/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibnum%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibnum%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Flib.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -15,8 +15,6 @@\n #[crate_type = \"dylib\"];\n #[license = \"MIT/ASL2\"];\n \n-extern crate extra;\n-\n pub mod bigint;\n pub mod rational;\n pub mod complex;"}, {"sha": "6f90ed81924397b30b2d97e38d3952fbec5888d1", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -27,8 +27,7 @@ use middle;\n use util::common::time;\n use util::ppaux;\n \n-use extra::json;\n-use serialize::Encodable;\n+use serialize::{json, Encodable};\n \n use std::cell::{Cell, RefCell};\n use std::io;"}, {"sha": "d52389f15a3b0a882d90a92f56fe0636b96c25a9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -42,7 +42,7 @@ use std::vec;\n use collections::{HashMap, HashSet};\n \n use sync::Arc;\n-use extra::json::ToJson;\n+use serialize::json::ToJson;\n use syntax::ast;\n use syntax::attr;\n use syntax::parse::token::InternedString;"}, {"sha": "19e3aed6462698f156bcb3969b13e5d7112dc5e1", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -30,8 +30,7 @@ use std::local_data;\n use std::io;\n use std::io::{File, MemWriter};\n use std::str;\n-use extra::json;\n-use serialize::{Decodable, Encodable};\n+use serialize::{json, Decodable, Encodable};\n \n pub mod clean;\n pub mod core;"}, {"sha": "2e7c4224ee186ef9c9f5077df3db64c1b83e53b6", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -10,7 +10,7 @@\n \n use clean;\n \n-use extra::json;\n+use serialize::json;\n use dl = std::unstable::dynamic_lib;\n \n pub type PluginJson = Option<(~str, json::Json)>;"}, {"sha": "43200a990471bba9ba2084c6d18046ed0b9bdd66", "filename": "src/libserialize/collection_impls.rs", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -0,0 +1,281 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementations of serialization for structures found in libcollections\n+\n+use std::uint;\n+use std::hash::Hash;\n+\n+use {Decodable, Encodable, Decoder, Encoder};\n+use collections::{DList, RingBuf, TreeMap, TreeSet, Deque, HashMap, HashSet,\n+                  TrieMap, TrieSet};\n+use collections::enum_set::{EnumSet, CLike};\n+\n+impl<\n+    S: Encoder,\n+    T: Encodable<S>\n+> Encodable<S> for DList<T> {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                s.emit_seq_elt(i, |s| e.encode(s));\n+            }\n+        })\n+    }\n+}\n+\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for DList<T> {\n+    fn decode(d: &mut D) -> DList<T> {\n+        let mut list = DList::new();\n+        d.read_seq(|d, len| {\n+            for i in range(0u, len) {\n+                list.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+            }\n+        });\n+        list\n+    }\n+}\n+\n+impl<\n+    S: Encoder,\n+    T: Encodable<S>\n+> Encodable<S> for RingBuf<T> {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                s.emit_seq_elt(i, |s| e.encode(s));\n+            }\n+        })\n+    }\n+}\n+\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for RingBuf<T> {\n+    fn decode(d: &mut D) -> RingBuf<T> {\n+        let mut deque = RingBuf::new();\n+        d.read_seq(|d, len| {\n+            for i in range(0u, len) {\n+                deque.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+            }\n+        });\n+        deque\n+    }\n+}\n+\n+impl<\n+    E: Encoder,\n+    K: Encodable<E> + Eq + TotalOrd,\n+    V: Encodable<E> + Eq\n+> Encodable<E> for TreeMap<K, V> {\n+    fn encode(&self, e: &mut E) {\n+        e.emit_map(self.len(), |e| {\n+            let mut i = 0;\n+            for (key, val) in self.iter() {\n+                e.emit_map_elt_key(i, |e| key.encode(e));\n+                e.emit_map_elt_val(i, |e| val.encode(e));\n+                i += 1;\n+            }\n+        })\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    K: Decodable<D> + Eq + TotalOrd,\n+    V: Decodable<D> + Eq\n+> Decodable<D> for TreeMap<K, V> {\n+    fn decode(d: &mut D) -> TreeMap<K, V> {\n+        d.read_map(|d, len| {\n+            let mut map = TreeMap::new();\n+            for i in range(0u, len) {\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        })\n+    }\n+}\n+\n+impl<\n+    S: Encoder,\n+    T: Encodable<S> + Eq + TotalOrd\n+> Encodable<S> for TreeSet<T> {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_seq(self.len(), |s| {\n+            let mut i = 0;\n+            for e in self.iter() {\n+                s.emit_seq_elt(i, |s| e.encode(s));\n+                i += 1;\n+            }\n+        })\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    T: Decodable<D> + Eq + TotalOrd\n+> Decodable<D> for TreeSet<T> {\n+    fn decode(d: &mut D) -> TreeSet<T> {\n+        d.read_seq(|d, len| {\n+            let mut set = TreeSet::new();\n+            for i in range(0u, len) {\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+            }\n+            set\n+        })\n+    }\n+}\n+\n+impl<\n+    S: Encoder,\n+    T: Encodable<S> + CLike\n+> Encodable<S> for EnumSet<T> {\n+    fn encode(&self, s: &mut S) {\n+        let mut bits = 0;\n+        for item in self.iter() {\n+            bits |= item.to_uint();\n+        }\n+        s.emit_uint(bits);\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    T: Decodable<D> + CLike\n+> Decodable<D> for EnumSet<T> {\n+    fn decode(d: &mut D) -> EnumSet<T> {\n+        let bits = d.read_uint();\n+        let mut set = EnumSet::empty();\n+        for bit in range(0, uint::BITS) {\n+            if bits & (1 << bit) != 0 {\n+                set.add(CLike::from_uint(1 << bit));\n+            }\n+        }\n+        set\n+    }\n+}\n+\n+impl<\n+    E: Encoder,\n+    K: Encodable<E> + Hash + Eq,\n+    V: Encodable<E>\n+> Encodable<E> for HashMap<K, V> {\n+    fn encode(&self, e: &mut E) {\n+        e.emit_map(self.len(), |e| {\n+            let mut i = 0;\n+            for (key, val) in self.iter() {\n+                e.emit_map_elt_key(i, |e| key.encode(e));\n+                e.emit_map_elt_val(i, |e| val.encode(e));\n+                i += 1;\n+            }\n+        })\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    K: Decodable<D> + Hash + Eq,\n+    V: Decodable<D>\n+> Decodable<D> for HashMap<K, V> {\n+    fn decode(d: &mut D) -> HashMap<K, V> {\n+        d.read_map(|d, len| {\n+            let mut map = HashMap::with_capacity(len);\n+            for i in range(0u, len) {\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        })\n+    }\n+}\n+\n+impl<\n+    S: Encoder,\n+    T: Encodable<S> + Hash + Eq\n+> Encodable<S> for HashSet<T> {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_seq(self.len(), |s| {\n+            let mut i = 0;\n+            for e in self.iter() {\n+                s.emit_seq_elt(i, |s| e.encode(s));\n+                i += 1;\n+            }\n+        })\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    T: Decodable<D> + Hash + Eq\n+> Decodable<D> for HashSet<T> {\n+    fn decode(d: &mut D) -> HashSet<T> {\n+        d.read_seq(|d, len| {\n+            let mut set = HashSet::with_capacity(len);\n+            for i in range(0u, len) {\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+            }\n+            set\n+        })\n+    }\n+}\n+\n+impl<\n+    E: Encoder,\n+    V: Encodable<E>\n+> Encodable<E> for TrieMap<V> {\n+    fn encode(&self, e: &mut E) {\n+        e.emit_map(self.len(), |e| {\n+                for (i, (key, val)) in self.iter().enumerate() {\n+                    e.emit_map_elt_key(i, |e| key.encode(e));\n+                    e.emit_map_elt_val(i, |e| val.encode(e));\n+                }\n+            });\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    V: Decodable<D>\n+> Decodable<D> for TrieMap<V> {\n+    fn decode(d: &mut D) -> TrieMap<V> {\n+        d.read_map(|d, len| {\n+            let mut map = TrieMap::new();\n+            for i in range(0u, len) {\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        })\n+    }\n+}\n+\n+impl<S: Encoder> Encodable<S> for TrieSet {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_seq(self.len(), |s| {\n+                for (i, e) in self.iter().enumerate() {\n+                    s.emit_seq_elt(i, |s| e.encode(s));\n+                }\n+            })\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for TrieSet {\n+    fn decode(d: &mut D) -> TrieSet {\n+        d.read_seq(|d, len| {\n+            let mut set = TrieSet::new();\n+            for i in range(0u, len) {\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+            }\n+            set\n+        })\n+    }\n+}"}, {"sha": "be13a8d0696d37cee3174d8c4cb9de1c022ac71b", "filename": "src/libserialize/json.rs", "status": "renamed", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -59,11 +59,8 @@ the code for these traits: `#[deriving(Decodable, Encodable)]`\n To encode using Encodable :\n \n ```rust\n-extern crate extra;\n-extern crate serialize;\n-use extra::json;\n use std::io;\n-use serialize::Encodable;\n+use serialize::{json, Encodable};\n \n  #[deriving(Encodable)]\n  pub struct TestStruct   {\n@@ -84,7 +81,7 @@ Two wrapper functions are provided to encode a Encodable object\n into a string (~str) or buffer (~[u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n \n ```rust\n-use extra::json;\n+use serialize::json;\n let to_encode_object = ~\"example of string to encode\";\n let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n ```\n@@ -99,11 +96,11 @@ A basic `ToJson` example using a TreeMap of attribute name / attribute value:\n \n \n ```rust\n-extern crate extra;\n extern crate collections;\n+extern crate serialize;\n \n-use extra::json;\n-use extra::json::ToJson;\n+use serialize::json;\n+use serialize::json::ToJson;\n use collections::TreeMap;\n \n pub struct MyStruct  {\n@@ -130,9 +127,8 @@ fn main() {\n To decode a JSON string using `Decodable` trait :\n \n ```rust\n-extern crate extra;\n extern crate serialize;\n-use serialize::Decodable;\n+use serialize::{json, Decodable};\n \n #[deriving(Decodable)]\n pub struct MyStruct  {\n@@ -143,8 +139,8 @@ pub struct MyStruct  {\n fn main() {\n     let json_str_to_decode: ~str =\n             ~\"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\";\n-    let json_object = extra::json::from_str(json_str_to_decode);\n-    let mut decoder = extra::json::Decoder::new(json_object.unwrap());\n+    let json_object = json::from_str(json_str_to_decode);\n+    let mut decoder = json::Decoder::new(json_object.unwrap());\n     let decoded_object: MyStruct = Decodable::decode(&mut decoder); // create the final object\n }\n ```\n@@ -157,10 +153,8 @@ Create a struct called TestStruct1 and serialize and deserialize it to and from\n using the serialization API, using the derived serialization code.\n \n ```rust\n-extern crate extra;\n extern crate serialize;\n-use extra::json;\n-use serialize::{Encodable, Decodable};\n+use serialize::{json, Encodable, Decodable};\n \n  #[deriving(Decodable, Encodable)] //generate Decodable, Encodable impl.\n  pub struct TestStruct1  {\n@@ -176,9 +170,9 @@ fn main() {\n          {data_int: 1, data_str:~\"toto\", data_vector:~[2,3,4,5]};\n     let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n \n-    // To deserialize use the `extra::json::from_str` and `extra::json::Decoder`\n+    // To deserialize use the `json::from_str` and `json::Decoder`\n \n-    let json_object = extra::json::from_str(encoded_str);\n+    let json_object = json::from_str(encoded_str);\n     let mut decoder = json::Decoder::new(json_object.unwrap());\n     let decoded1: TestStruct1 = Decodable::decode(&mut decoder); // create the final object\n }\n@@ -190,13 +184,11 @@ This example use the ToJson impl to deserialize the JSON string.\n Example of `ToJson` trait implementation for TestStruct1.\n \n ```rust\n-extern crate extra;\n extern crate serialize;\n extern crate collections;\n \n-use extra::json;\n-use extra::json::ToJson;\n-use serialize::{Encodable, Decodable};\n+use serialize::json::ToJson;\n+use serialize::{json, Encodable, Decodable};\n use collections::TreeMap;\n \n #[deriving(Decodable, Encodable)] // generate Decodable, Encodable impl.\n@@ -242,8 +234,7 @@ use std::num;\n use std::str;\n use std::fmt;\n \n-use serialize::Encodable;\n-use serialize;\n+use Encodable;\n use collections::TreeMap;\n \n macro_rules! try( ($e:expr) => (\n@@ -324,7 +315,7 @@ impl<'a> Encoder<'a> {\n     }\n \n     /// Encode the specified struct into a json [u8]\n-    pub fn buffer_encode<T:serialize::Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~[u8]  {\n+    pub fn buffer_encode<T:Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~[u8]  {\n        //Serialize the object in a string using a writer\n         let mut m = MemWriter::new();\n         {\n@@ -335,13 +326,13 @@ impl<'a> Encoder<'a> {\n     }\n \n     /// Encode the specified struct into a json str\n-    pub fn str_encode<T:serialize::Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~str  {\n+    pub fn str_encode<T:Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~str  {\n         let buff:~[u8] = Encoder::buffer_encode(to_encode_object);\n         str::from_utf8_owned(buff).unwrap()\n     }\n }\n \n-impl<'a> serialize::Encoder for Encoder<'a> {\n+impl<'a> ::Encoder for Encoder<'a> {\n     fn emit_nil(&mut self) { try!(write!(self.wr, \"null\")) }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n@@ -502,7 +493,7 @@ impl<'a> PrettyEncoder<'a> {\n     }\n }\n \n-impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n+impl<'a> ::Encoder for PrettyEncoder<'a> {\n     fn emit_nil(&mut self) { try!(write!(self.wr, \"null\")); }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n@@ -683,7 +674,7 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n     }\n }\n \n-impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n+impl<E: ::Encoder> Encodable<E> for Json {\n     fn encode(&self, e: &mut E) {\n         match *self {\n             Number(v) => v.encode(e),\n@@ -1154,7 +1145,7 @@ impl Decoder {\n     }\n }\n \n-impl serialize::Decoder for Decoder {\n+impl ::Decoder for Decoder {\n     fn read_nil(&mut self) -> () {\n         debug!(\"read_nil\");\n         match self.stack.pop().unwrap() {\n@@ -1591,10 +1582,10 @@ impl fmt::Show for Error {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-\n+    use {Encodable, Decodable};\n+    use super::{Encoder, Decoder, Error, Boolean, Number, List, String, Null,\n+                PrettyEncoder, Object, Json, from_str};\n     use std::io;\n-    use serialize::{Encodable, Decodable};\n     use collections::TreeMap;\n \n     #[deriving(Eq, Encodable, Decodable)]", "previous_filename": "src/libextra/json.rs"}, {"sha": "f8bb39bd34df718ea7010d85853605591a9d5e67", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -26,12 +26,15 @@ Core encoding and decoding interfaces.\n #[cfg(test)]\n extern crate test;\n \n+extern crate collections;\n+\n pub use self::serialize::{Decoder, Encoder, Decodable, Encodable,\n-    DecoderHelpers, EncoderHelpers};\n+                          DecoderHelpers, EncoderHelpers};\n \n mod serialize;\n+mod collection_impls;\n \n pub mod base64;\n pub mod ebml;\n pub mod hex;\n-\n+pub mod json;"}, {"sha": "0415748097c7c39335b4a03c93b779fe8418d6a7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -1201,8 +1201,7 @@ pub enum InlinedItem {\n \n #[cfg(test)]\n mod test {\n-    extern crate extra;\n-    use self::extra::json;\n+    use serialize::json;\n     use serialize;\n     use codemap::*;\n     use super::*;"}, {"sha": "9d0c9d0f4d3a37b854bfaf14e8d734d26e47fe67", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -283,10 +283,8 @@ pub fn maybe_aborted<T>(result: T, mut p: Parser) -> T {\n \n #[cfg(test)]\n mod test {\n-    extern crate extra;\n-    use self::extra::json;\n     use super::*;\n-    use serialize::Encodable;\n+    use serialize::{json, Encodable};\n     use std::io;\n     use std::io::MemWriter;\n     use std::str;"}, {"sha": "6093948d9f4d473f5616d7d4767a630c9f33ec58", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -29,13 +29,12 @@ extern crate term;\n extern crate time;\n \n use collections::TreeMap;\n-use extra::json::ToJson;\n-use extra::json;\n use extra::stats::Stats;\n use extra::stats;\n use time::precise_time_ns;\n use getopts::{OptGroup, optflag, optopt};\n-use serialize::Decodable;\n+use serialize::{json, Decodable};\n+use serialize::json::ToJson;\n use term::Terminal;\n use term::color::{Color, RED, YELLOW, GREEN, CYAN};\n "}, {"sha": "e31a9e3f7f5c759b463b9a5499bd14855a5c652f", "filename": "src/test/run-pass/extern-mod-syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Ftest%2Frun-pass%2Fextern-mod-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Ftest%2Frun-pass%2Fextern-mod-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-mod-syntax.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -12,8 +12,8 @@\n \n #[allow(unused_imports)];\n \n-extern crate extra;\n-use extra::json::Object;\n+extern crate serialize;\n+use serialize::json::Object;\n \n pub fn main() {\n     println!(\"Hello world!\");"}, {"sha": "8370e0f7f9c86b78c06b8ca63ad7a36dc7dc741b", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -11,10 +11,10 @@\n // except according to those terms.\n \n extern crate collections;\n-extern crate extra;\n+extern crate serialize;\n \n-use extra::json;\n use collections::HashMap;\n+use serialize::json;\n use std::option;\n \n enum object {\n@@ -25,7 +25,7 @@ enum object {\n fn lookup(table: ~json::Object, key: ~str, default: ~str) -> ~str\n {\n     match table.find(&key) {\n-        option::Some(&extra::json::String(ref s)) => {\n+        option::Some(&json::String(ref s)) => {\n             (*s).clone()\n         }\n         option::Some(value) => {\n@@ -38,10 +38,10 @@ fn lookup(table: ~json::Object, key: ~str, default: ~str) -> ~str\n     }\n }\n \n-fn add_interface(_store: int, managed_ip: ~str, data: extra::json::Json) -> (~str, object)\n+fn add_interface(_store: int, managed_ip: ~str, data: json::Json) -> (~str, object)\n {\n     match &data {\n-        &extra::json::Object(ref interface) => {\n+        &json::Object(ref interface) => {\n             let name = lookup((*interface).clone(), ~\"ifDescr\", ~\"\");\n             let label = format!(\"{}-{}\", managed_ip, name);\n \n@@ -54,12 +54,12 @@ fn add_interface(_store: int, managed_ip: ~str, data: extra::json::Json) -> (~st\n     }\n }\n \n-fn add_interfaces(store: int, managed_ip: ~str, device: HashMap<~str, extra::json::Json>)\n+fn add_interfaces(store: int, managed_ip: ~str, device: HashMap<~str, json::Json>)\n -> ~[(~str, object)]\n {\n     match device.get(&~\"interfaces\")\n     {\n-        &extra::json::List(ref interfaces) =>\n+        &json::List(ref interfaces) =>\n         {\n           interfaces.map(|interface| {\n                 add_interface(store, managed_ip.clone(), (*interface).clone())"}, {"sha": "4b9a23538620473d52c5b5b26ca9954031bb41ba", "filename": "src/test/run-pass/issue-4016.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4016.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -11,11 +11,9 @@\n \n // ignore-fast\n \n-extern crate extra;\n extern crate serialize;\n \n-use extra::json;\n-use serialize::Decodable;\n+use serialize::{json, Decodable};\n \n trait JD : Decodable<json::Decoder> { }\n "}, {"sha": "0298a2a324fec446916149c08e0d373ead3cdf68", "filename": "src/test/run-pass/issue-4036.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6485917d7ca832ee8867c6a7a55af3ed1e9d304c/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4036.rs?ref=6485917d7ca832ee8867c6a7a55af3ed1e9d304c", "patch": "@@ -13,10 +13,8 @@\n // Issue #4036: Test for an issue that arose around fixing up type inference\n // byproducts in vtable records.\n \n-extern crate extra;\n extern crate serialize;\n-use extra::json;\n-use serialize::Decodable;\n+use serialize::{json, Decodable};\n \n pub fn main() {\n     let json = json::from_str(\"[1]\").unwrap();"}]}