{"sha": "70073ec61d0d56bca45b9bd40659bb75799cd273", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMDczZWM2MWQwZDU2YmNhNDViOWJkNDA2NTliYjc1Nzk5Y2QyNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-24T17:36:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-24T17:36:44Z"}, "message": "Auto merge of #53783 - RalfJung:ptr-docs, r=alexcrichton\n\nRewrite docs for pointer methods\n\nThis takes over https://github.com/rust-lang/rust/pull/51016 by @ecstatic-morse. They did most of the work, I just did some editing.\n\nHowever, I realized one problem: This updates the docs for the \"free functions\" in `core::ptr`, but it does not update the copies of these docs for the inherent methods of the `*const T` and `*mut T` types. These getting out-of-sync is certainly bad, but I also don't feel like copying all this stuff around. Instead, we should remove this redundancy. Any good ideas?", "tree": {"sha": "aa53b4fa6371470573a22665d07ae5f2815656ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa53b4fa6371470573a22665d07ae5f2815656ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70073ec61d0d56bca45b9bd40659bb75799cd273", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70073ec61d0d56bca45b9bd40659bb75799cd273", "html_url": "https://github.com/rust-lang/rust/commit/70073ec61d0d56bca45b9bd40659bb75799cd273", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70073ec61d0d56bca45b9bd40659bb75799cd273/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a072d1bca6282d1d2fbec103d12393527eb5a868", "url": "https://api.github.com/repos/rust-lang/rust/commits/a072d1bca6282d1d2fbec103d12393527eb5a868", "html_url": "https://github.com/rust-lang/rust/commit/a072d1bca6282d1d2fbec103d12393527eb5a868"}, {"sha": "c197dc467fc18c3923f27c8e57e174497f2e63ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/c197dc467fc18c3923f27c8e57e174497f2e63ed", "html_url": "https://github.com/rust-lang/rust/commit/c197dc467fc18c3923f27c8e57e174497f2e63ed"}], "stats": {"total": 1250, "additions": 701, "deletions": 549}, "files": [{"sha": "56a24168e28d959629f08b8d81079488e4b693ad", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 160, "deletions": 36, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/70073ec61d0d56bca45b9bd40659bb75799cd273/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70073ec61d0d56bca45b9bd40659bb75799cd273/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=70073ec61d0d56bca45b9bd40659bb75799cd273", "patch": "@@ -962,59 +962,127 @@ extern \"rust-intrinsic\" {\n     /// value is not necessarily valid to be used to actually access memory.\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n-    /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n-    /// and destination may *not* overlap.\n+    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+    /// and destination must *not* overlap.\n     ///\n-    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n+    /// For regions of memory which might overlap, use [`copy`] instead.\n+    ///\n+    /// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n+    /// with the argument order swapped.\n+    ///\n+    /// [`copy`]: ./fn.copy.html\n+    /// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n     ///\n     /// # Safety\n     ///\n-    /// Beyond requiring that the program must be allowed to access both regions\n-    /// of memory, it is Undefined Behavior for source and destination to\n-    /// overlap. Care must also be taken with the ownership of `src` and\n-    /// `dst`. This method semantically moves the values of `src` into `dst`.\n-    /// However it does not drop the contents of `dst`, or prevent the contents\n-    /// of `src` from being dropped or used.\n+    /// Behavior is undefined if any of the following conditions are violated:\n+    ///\n+    /// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n+    ///\n+    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n+    ///\n+    /// * Both `src` and `dst` must be properly aligned.\n+    ///\n+    /// * The region of memory beginning at `src` with a size of `count *\n+    ///   size_of::<T>()` bytes must *not* overlap with the region of memory\n+    ///   beginning at `dst` with the same size.\n+    ///\n+    /// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n+    /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using *both* the values\n+    /// in the region beginning at `*src` and the region beginning at `*dst` can\n+    /// [violate memory safety][read-ownership].\n+    ///\n+    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+    /// `0`, the pointers must be non-NULL and properly aligned.\n+    ///\n+    /// [`Copy`]: ../marker/trait.Copy.html\n+    /// [`read`]: ../ptr/fn.read.html\n+    /// [read-ownership]: ../ptr/fn.read.html#ownership-of-the-returned-value\n+    /// [valid]: ../ptr/index.html#safety\n     ///\n     /// # Examples\n     ///\n-    /// A safe swap function:\n+    /// Manually implement [`Vec::append`]:\n     ///\n     /// ```\n-    /// use std::mem;\n     /// use std::ptr;\n     ///\n-    /// # #[allow(dead_code)]\n-    /// fn swap<T>(x: &mut T, y: &mut T) {\n-    ///     unsafe {\n-    ///         // Give ourselves some scratch space to work with\n-    ///         let mut t: T = mem::uninitialized();\n+    /// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n+    /// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n+    ///     let src_len = src.len();\n+    ///     let dst_len = dst.len();\n     ///\n-    ///         // Perform the swap, `&mut` pointers never alias\n-    ///         ptr::copy_nonoverlapping(x, &mut t, 1);\n-    ///         ptr::copy_nonoverlapping(y, x, 1);\n-    ///         ptr::copy_nonoverlapping(&t, y, 1);\n+    ///     // Ensure that `dst` has enough capacity to hold all of `src`.\n+    ///     dst.reserve(src_len);\n     ///\n-    ///         // y and t now point to the same thing, but we need to completely forget `t`\n-    ///         // because it's no longer relevant.\n-    ///         mem::forget(t);\n+    ///     unsafe {\n+    ///         // The call to offset is always safe because `Vec` will never\n+    ///         // allocate more than `isize::MAX` bytes.\n+    ///         let dst_ptr = dst.as_mut_ptr().offset(dst_len as isize);\n+    ///         let src_ptr = src.as_ptr();\n+    ///\n+    ///         // Truncate `src` without dropping its contents. We do this first,\n+    ///         // to avoid problems in case something further down panics.\n+    ///         src.set_len(0);\n+    ///\n+    ///         // The two regions cannot overlap becuase mutable references do\n+    ///         // not alias, and two different vectors cannot own the same\n+    ///         // memory.\n+    ///         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n+    ///\n+    ///         // Notify `dst` that it now holds the contents of `src`.\n+    ///         dst.set_len(dst_len + src_len);\n     ///     }\n     /// }\n+    ///\n+    /// let mut a = vec!['r'];\n+    /// let mut b = vec!['u', 's', 't'];\n+    ///\n+    /// append(&mut a, &mut b);\n+    ///\n+    /// assert_eq!(a, &['r', 'u', 's', 't']);\n+    /// assert!(b.is_empty());\n     /// ```\n+    ///\n+    /// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n \n-    /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n+    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n     /// and destination may overlap.\n     ///\n-    /// `copy` is semantically equivalent to C's `memmove`.\n+    /// If the source and destination will *never* overlap,\n+    /// [`copy_nonoverlapping`] can be used instead.\n+    ///\n+    /// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n+    /// order swapped.  Copying takes place as if the bytes were copied from `src`\n+    /// to a temporary array and then copied from the array to `dst`.\n+    ///\n+    /// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n+    /// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n     ///\n     /// # Safety\n     ///\n-    /// Care must be taken with the ownership of `src` and `dst`.\n-    /// This method semantically moves the values of `src` into `dst`.\n-    /// However it does not drop the contents of `dst`, or prevent the contents of `src`\n-    /// from being dropped or used.\n+    /// Behavior is undefined if any of the following conditions are violated:\n+    ///\n+    /// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n+    ///\n+    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n+    ///\n+    /// * Both `src` and `dst` must be properly aligned.\n+    ///\n+    /// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n+    /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the values\n+    /// in the region beginning at `*src` and the region beginning at `*dst` can\n+    /// [violate memory safety][read-ownership].\n+    ///\n+    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+    /// `0`, the pointers must be non-NULL and properly aligned.\n+    ///\n+    /// [`Copy`]: ../marker/trait.Copy.html\n+    /// [`read`]: ../ptr/fn.read.html\n+    /// [read-ownership]: ../ptr/fn.read.html#ownership-of-the-returned-value\n+    /// [valid]: ../ptr/index.html#safety\n     ///\n     /// # Examples\n     ///\n@@ -1031,24 +1099,80 @@ extern \"rust-intrinsic\" {\n     ///     dst\n     /// }\n     /// ```\n-    ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n \n-    /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n-    /// bytes of memory starting at `dst` to `val`.\n+    /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n+    /// `val`.\n+    ///\n+    /// `write_bytes` is similar to C's [`memset`], but sets `count *\n+    /// size_of::<T>()` bytes to `val`.\n+    ///\n+    /// [`memset`]: https://en.cppreference.com/w/c/string/byte/memset\n+    ///\n+    /// # Safety\n+    ///\n+    /// Behavior is undefined if any of the following conditions are violated:\n+    ///\n+    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n+    ///\n+    /// * `dst` must be properly aligned.\n+    ///\n+    /// Additionally, the caller must ensure that writing `count *\n+    /// size_of::<T>()` bytes to the given region of memory results in a valid\n+    /// value of `T`. Using a region of memory typed as a `T` that contains an\n+    /// invalid value of `T` is undefined behavior.\n+    ///\n+    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+    /// `0`, the pointer must be non-NULL and properly aligned.\n+    ///\n+    /// [valid]: ../ptr/index.html#safety\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::ptr;\n     ///\n-    /// let mut vec = vec![0; 4];\n+    /// let mut vec = vec![0u32; 4];\n     /// unsafe {\n     ///     let vec_ptr = vec.as_mut_ptr();\n-    ///     ptr::write_bytes(vec_ptr, b'a', 2);\n+    ///     ptr::write_bytes(vec_ptr, 0xfe, 2);\n+    /// }\n+    /// assert_eq!(vec, [0xfefefefe, 0xfefefefe, 0, 0]);\n+    /// ```\n+    ///\n+    /// Creating an invalid value:\n+    ///\n+    /// ```\n+    /// use std::ptr;\n+    ///\n+    /// let mut v = Box::new(0i32);\n+    ///\n+    /// unsafe {\n+    ///     // Leaks the previously held value by overwriting the `Box<T>` with\n+    ///     // a null pointer.\n+    ///     ptr::write_bytes(&mut v as *mut Box<i32>, 0, 1);\n     /// }\n-    /// assert_eq!(vec, [b'a', b'a', 0, 0]);\n+    ///\n+    /// // At this point, using or dropping `v` results in undefined behavior.\n+    /// // drop(v); // ERROR\n+    ///\n+    /// // Even leaking `v` \"uses\" it, and hence is undefined behavior.\n+    /// // mem::forget(v); // ERROR\n+    ///\n+    /// // In fact, `v` is invalid according to basic type layout invariants, so *any*\n+    /// // operation touching it is undefined behavior.\n+    /// // let v2 = v; // ERROR\n+    ///\n+    /// unsafe {\n+    ///     // Let us instead put in a valid value\n+    ///     ptr::write(&mut v as *mut Box<i32>, Box::new(42i32));\n+    /// }\n+    ///\n+    /// // Now the box is fine\n+    /// assert_eq!(*v, 42);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n@@ -1066,7 +1190,7 @@ extern \"rust-intrinsic\" {\n     /// `min_align_of::<T>()`\n     ///\n     /// The volatile parameter is set to `true`, so it will not be optimized out\n-    /// unless size is equal to zero..\n+    /// unless size is equal to zero.\n     pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count` * `size_of::<T>()` and an alignment of"}, {"sha": "b23b72c3720105f5aacde04707fe84bbbe37659a", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 541, "deletions": 513, "changes": 1054, "blob_url": "https://github.com/rust-lang/rust/blob/70073ec61d0d56bca45b9bd40659bb75799cd273/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70073ec61d0d56bca45b9bd40659bb75799cd273/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=70073ec61d0d56bca45b9bd40659bb75799cd273", "patch": "@@ -8,11 +8,68 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME: talk about offset, copy_memory, copy_nonoverlapping_memory\n-\n-//! Raw, unsafe pointers, `*const T`, and `*mut T`.\n+//! Manually manage memory through raw pointers.\n //!\n //! *[See also the pointer primitive types](../../std/primitive.pointer.html).*\n+//!\n+//! # Safety\n+//!\n+//! Many functions in this module take raw pointers as arguments and read from\n+//! or write to them. For this to be safe, these pointers must be *valid*.\n+//! Whether a pointer is valid depends on the operation it is used for\n+//! (read or write), and the extent of the memory that is accessed (i.e.,\n+//! how many bytes are read/written). Most functions use `*mut T` and `*const T`\n+//! to access only a single value, in which case the documentation omits the size\n+//! and implicitly assumes it to be `size_of::<T>()` bytes.\n+//!\n+//! The precise rules for validity are not determined yet.  The guarantees that are\n+//! provided at this point are very minimal:\n+//!\n+//! * A [null] pointer is *never* valid, not even for accesses of [size zero][zst].\n+//! * All pointers (except for the null pointer) are valid for all operations of\n+//!   [size zero][zst].\n+//! * All accesses performed by functions in this module are *non-atomic* in the sense\n+//!   of [atomic operations] used to synchronize between threads. This means it is\n+//!   undefined behavior to perform two concurrent accesses to the same location from different\n+//!   threads unless both accesses only read from memory. Notice that this explicitly\n+//!   includes [`read_volatile`] and [`write_volatile`]: Volatile accesses cannot\n+//!   be used for inter-thread synchronization.\n+//! * The result of casting a reference to a pointer is valid for as long as the\n+//!   underlying object is live and no reference (just raw pointers) is used to\n+//!   access the same memory.\n+//!\n+//! These axioms, along with careful use of [`offset`] for pointer arithmentic,\n+//! are enough to correctly implement many useful things in unsafe code. Stronger guarantees\n+//! will be provided eventually, as the [aliasing] rules are being determined. For more\n+//! information, see the [book] as well as the section in the reference devoted\n+//! to [undefined behavior][ub].\n+//!\n+//! ## Alignment\n+//!\n+//! Valid raw pointers as defined above are not necessarily properly aligned (where\n+//! \"proper\" alignment is defined by the pointee type, i.e., `*const T` must be\n+//! aligned to `mem::align_of::<T>()`). However, most functions require their\n+//! arguments to be properly aligned, and will explicitly state\n+//! this requirement in their documentation. Notable exceptions to this are\n+//! [`read_unaligned`] and [`write_unaligned`].\n+//!\n+//! When a function requires proper alignment, it does so even if the access\n+//! has size 0, i.e., even if memory is not actually touched. Consider using\n+//! [`NonNull::dangling`] in such cases.\n+//!\n+//! [aliasing]: ../../nomicon/aliasing.html\n+//! [book]: ../../book/second-edition/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n+//! [ub]: ../../reference/behavior-considered-undefined.html\n+//! [null]: ./fn.null.html\n+//! [zst]: ../../nomicon/exotic-sizes.html#zero-sized-types-zsts\n+//! [atomic operations]: ../../std/sync/atomic/index.html\n+//! [`copy`]: ../../std/ptr/fn.copy.html\n+//! [`offset`]: ../../std/primitive.pointer.html#method.offset\n+//! [`read_unaligned`]: ./fn.read_unaligned.html\n+//! [`write_unaligned`]: ./fn.write_unaligned.html\n+//! [`read_volatile`]: ./fn.read_volatile.html\n+//! [`write_volatile`]: ./fn.write_volatile.html\n+//! [`NonNull::dangling`]: ./struct.NonNull.html#method.dangling\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -38,21 +95,99 @@ pub use intrinsics::write_bytes;\n \n /// Executes the destructor (if any) of the pointed-to value.\n ///\n-/// This has two use cases:\n+/// This is semantically equivalent to calling [`ptr::read`] and discarding\n+/// the result, but has the following advantages:\n ///\n /// * It is *required* to use `drop_in_place` to drop unsized types like\n ///   trait objects, because they can't be read out onto the stack and\n ///   dropped normally.\n ///\n-/// * It is friendlier to the optimizer to do this over `ptr::read` when\n+/// * It is friendlier to the optimizer to do this over [`ptr::read`] when\n ///   dropping manually allocated memory (e.g. when writing Box/Rc/Vec),\n ///   as the compiler doesn't need to prove that it's sound to elide the\n ///   copy.\n ///\n+/// [`ptr::read`]: ../ptr/fn.read.html\n+///\n /// # Safety\n ///\n-/// This has all the same safety problems as `ptr::read` with respect to\n-/// invalid pointers, types, and double drops.\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `to_drop` must be [valid] for reads.\n+///\n+/// * `to_drop` must be properly aligned.  See the example below for how to drop\n+///   an unaligned pointer.\n+///\n+/// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n+/// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n+/// foo` counts as a use because it will cause the the value to be dropped\n+/// again. [`write`] can be used to overwrite data without causing it to be\n+/// dropped.\n+///\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n+///\n+/// [valid]: ../ptr/index.html#safety\n+/// [`Copy`]: ../marker/trait.Copy.html\n+/// [`write`]: ../ptr/fn.write.html\n+///\n+/// # Examples\n+///\n+/// Manually remove the last item from a vector:\n+///\n+/// ```\n+/// use std::ptr;\n+/// use std::rc::Rc;\n+///\n+/// let last = Rc::new(1);\n+/// let weak = Rc::downgrade(&last);\n+///\n+/// let mut v = vec![Rc::new(0), last];\n+///\n+/// unsafe {\n+///     // Get a raw pointer to the last element in `v`.\n+///     let ptr = &mut v[1] as *mut _;\n+///     // Shorten `v` to prevent the last item from being dropped.  We do that first,\n+///     // to prevent issues if the `drop_in_place` below panics.\n+///     v.set_len(1);\n+///     // Without a call `drop_in_place`, the last item would never be dropped,\n+///     // and the memory it manages would be leaked.\n+///     ptr::drop_in_place(ptr);\n+/// }\n+///\n+/// assert_eq!(v, &[0.into()]);\n+///\n+/// // Ensure that the last item was dropped.\n+/// assert!(weak.upgrade().is_none());\n+/// ```\n+///\n+/// Unaligned values cannot be dropped in place, they must be copied to an aligned\n+/// location first:\n+/// ```\n+/// use std::ptr;\n+/// use std::mem;\n+///\n+/// unsafe fn drop_after_copy<T>(to_drop: *mut T) {\n+///     let mut copy: T = mem::uninitialized();\n+///     ptr::copy(to_drop, &mut copy, 1);\n+///     drop(copy);\n+/// }\n+///\n+/// #[repr(packed, C)]\n+/// struct Packed {\n+///     _padding: u8,\n+///     unaligned: Vec<i32>,\n+/// }\n+///\n+/// let mut p = Packed { _padding: 0, unaligned: vec![42] };\n+/// unsafe {\n+///     drop_after_copy(&mut p.unaligned as *mut _);\n+///     mem::forget(p);\n+/// }\n+/// ```\n+///\n+/// Notice that the compiler performs this copy automatically when dropping packed structs,\n+/// i.e., you do not usually have to worry about such issues unless you call `drop_in_place`\n+/// manually.\n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n #[lang = \"drop_in_place\"]\n #[allow(unconditional_recursion)]\n@@ -93,17 +228,29 @@ pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n /// Swaps the values at two mutable locations of the same type, without\n /// deinitializing either.\n ///\n-/// The values pointed at by `x` and `y` may overlap, unlike `mem::swap` which\n-/// is otherwise equivalent. If the values do overlap, then the overlapping\n-/// region of memory from `x` will be used. This is demonstrated in the\n-/// examples section below.\n+/// But for the following two exceptions, this function is semantically\n+/// equivalent to [`mem::swap`]:\n+///\n+/// * It operates on raw pointers instead of references. When references are\n+///   available, [`mem::swap`] should be preferred.\n+///\n+/// * The two pointed-to values may overlap. If the values do overlap, then the\n+///   overlapping region of memory from `x` will be used. This is demonstrated\n+///   in the second example below.\n+///\n+/// [`mem::swap`]: ../mem/fn.swap.html\n ///\n /// # Safety\n ///\n-/// This function copies the memory through the raw pointers passed to it\n-/// as arguments.\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * Both `x` and `y` must be [valid] for reads and writes.\n+///\n+/// * Both `x` and `y` must be properly aligned.\n ///\n-/// Ensure that these pointers are valid before calling `swap`.\n+/// Note that even if `T` has size `0`, the pointers must be non-NULL and properly aligned.\n+///\n+/// [valid]: ../ptr/index.html#safety\n ///\n /// # Examples\n ///\n@@ -114,8 +261,8 @@ pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n ///\n /// let mut array = [0, 1, 2, 3];\n ///\n-/// let x = array[0..].as_mut_ptr() as *mut [u32; 2];\n-/// let y = array[2..].as_mut_ptr() as *mut [u32; 2];\n+/// let x = array[0..].as_mut_ptr() as *mut [u32; 2]; // this is `array[0..2]`\n+/// let y = array[2..].as_mut_ptr() as *mut [u32; 2]; // this is `array[2..4]`\n ///\n /// unsafe {\n ///     ptr::swap(x, y);\n@@ -130,11 +277,16 @@ pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n ///\n /// let mut array = [0, 1, 2, 3];\n ///\n-/// let x = array[0..].as_mut_ptr() as *mut [u32; 3];\n-/// let y = array[1..].as_mut_ptr() as *mut [u32; 3];\n+/// let x = array[0..].as_mut_ptr() as *mut [u32; 3]; // this is `array[0..3]`\n+/// let y = array[1..].as_mut_ptr() as *mut [u32; 3]; // this is `array[1..4]`\n ///\n /// unsafe {\n ///     ptr::swap(x, y);\n+///     // The indices `1..3` of the slice overlap between `x` and `y`.\n+///     // Reasonable results would be for to them be `[2, 3]`, so that indices `0..3` are\n+///     // `[1, 2, 3]` (matching `y` before the `swap`); or for them to be `[0, 1]`\n+///     // so that indices `1..4` are `[0, 1, 2]` (matching `x` before the `swap`).\n+///     // This implementation is defined to make the latter choice.\n ///     assert_eq!([1, 0, 1, 2], array);\n /// }\n /// ```\n@@ -150,12 +302,26 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     copy_nonoverlapping(tmp.get_ref(), y, 1);\n }\n \n-/// Swaps a sequence of values at two mutable locations of the same type.\n+/// Swaps `count * size_of::<T>()` bytes between the two regions of memory\n+/// beginning at `x` and `y`. The two regions must *not* overlap.\n ///\n /// # Safety\n ///\n-/// The two arguments must each point to the beginning of `count` locations\n-/// of valid memory, and the two memory ranges must not overlap.\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * Both `x` and `y` must be [valid] for reads and writes of `count *\n+///   size_of::<T>()` bytes.\n+///\n+/// * Both `x` and `y` must be properly aligned.\n+///\n+/// * The region of memory beginning at `x` with a size of `count *\n+///   size_of::<T>()` bytes must *not* overlap with the region of memory\n+///   beginning at `y` with the same size.\n+///\n+/// Note that even if the effectively copied size (`count * size_of::<T>()`) is `0`,\n+/// the pointers must be non-NULL and properly aligned.\n+///\n+/// [valid]: ../ptr/index.html#safety\n ///\n /// # Examples\n ///\n@@ -248,18 +414,48 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n     }\n }\n \n-/// Moves `src` into the pointed `dest`, returning the previous `dest` value.\n+/// Moves `src` into the pointed `dst`, returning the previous `dst` value.\n ///\n /// Neither value is dropped.\n ///\n+/// This function is semantically equivalent to [`mem::replace`] except that it\n+/// operates on raw pointers instead of references. When references are\n+/// available, [`mem::replace`] should be preferred.\n+///\n+/// [`mem::replace`]: ../mem/fn.replace.html\n+///\n /// # Safety\n ///\n-/// This is only unsafe because it accepts a raw pointer.\n-/// Otherwise, this operation is identical to `mem::replace`.\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `dst` must be [valid] for writes.\n+///\n+/// * `dst` must be properly aligned.\n+///\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n+///\n+/// [valid]: ../ptr/index.html#safety\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let mut rust = vec!['b', 'u', 's', 't'];\n+///\n+/// // `mem::replace` would have the same effect without requiring the unsafe\n+/// // block.\n+/// let b = unsafe {\n+///     ptr::replace(&mut rust[0], 'r')\n+/// };\n+///\n+/// assert_eq!(b, 'b');\n+/// assert_eq!(rust, &['r', 'u', 's', 't']);\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n-    mem::swap(&mut *dest, &mut src); // cannot overlap\n+pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n+    mem::swap(&mut *dst, &mut src); // cannot overlap\n     src\n }\n \n@@ -268,14 +464,14 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n ///\n /// # Safety\n ///\n-/// Beyond accepting a raw pointer, this is unsafe because it semantically\n-/// moves the value out of `src` without preventing further usage of `src`.\n-/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-/// `src` is not used before the data is overwritten again (e.g. with `write`,\n-/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n-/// because it will attempt to drop the value previously at `*src`.\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `src` must be [valid] for reads.\n+///\n+/// * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n+///   case.\n ///\n-/// The pointer must be aligned; use `read_unaligned` if that is not the case.\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n /// # Examples\n ///\n@@ -289,6 +485,87 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n ///     assert_eq!(std::ptr::read(y), 12);\n /// }\n /// ```\n+///\n+/// Manually implement [`mem::swap`]:\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// fn swap<T>(a: &mut T, b: &mut T) {\n+///     unsafe {\n+///         // Create a bitwise copy of the value at `a` in `tmp`.\n+///         let tmp = ptr::read(a);\n+///\n+///         // Exiting at this point (either by explicitly returning or by\n+///         // calling a function which panics) would cause the value in `tmp` to\n+///         // be dropped while the same value is still referenced by `a`. This\n+///         // could trigger undefined behavior if `T` is not `Copy`.\n+///\n+///         // Create a bitwise copy of the value at `b` in `a`.\n+///         // This is safe because mutable references cannot alias.\n+///         ptr::copy_nonoverlapping(b, a, 1);\n+///\n+///         // As above, exiting here could trigger undefined behavior because\n+///         // the same value is referenced by `a` and `b`.\n+///\n+///         // Move `tmp` into `b`.\n+///         ptr::write(b, tmp);\n+///\n+///         // `tmp` has been moved (`write` takes ownership of its second argument),\n+///         // so nothing is dropped implicitly here.\n+///     }\n+/// }\n+///\n+/// let mut foo = \"foo\".to_owned();\n+/// let mut bar = \"bar\".to_owned();\n+///\n+/// swap(&mut foo, &mut bar);\n+///\n+/// assert_eq!(foo, \"bar\");\n+/// assert_eq!(bar, \"foo\");\n+/// ```\n+///\n+/// ## Ownership of the Returned Value\n+///\n+/// `read` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].\n+/// If `T` is not [`Copy`], using both the returned value and the value at\n+/// `*src` can violate memory safety.  Note that assigning to `*src` counts as a\n+/// use because it will attempt to drop the value at `*src`.\n+///\n+/// [`write`] can be used to overwrite data without causing it to be dropped.\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let mut s = String::from(\"foo\");\n+/// unsafe {\n+///     // `s2` now points to the same underlying memory as `s`.\n+///     let mut s2: String = ptr::read(&s);\n+///\n+///     assert_eq!(s2, \"foo\");\n+///\n+///     // Assigning to `s2` causes its original value to be dropped. Beyond\n+///     // this point, `s` must no longer be used, as the underlying memory has\n+///     // been freed.\n+///     s2 = String::default();\n+///     assert_eq!(s2, \"\");\n+///\n+///     // Assigning to `s` would cause the old value to be dropped again,\n+///     // resulting in undefined behavior.\n+///     // s = String::from(\"bar\"); // ERROR\n+///\n+///     // `ptr::write` can be used to overwrite a value without dropping it.\n+///     ptr::write(&mut s, String::from(\"bar\"));\n+/// }\n+///\n+/// assert_eq!(s, \"bar\");\n+/// ```\n+///\n+/// [`mem::swap`]: ../mem/fn.swap.html\n+/// [valid]: ../ptr/index.html#safety\n+/// [`Copy`]: ../marker/trait.Copy.html\n+/// [`read_unaligned`]: ./fn.read_unaligned.html\n+/// [`write`]: ./fn.write.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n@@ -300,28 +577,61 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// Reads the value from `src` without moving it. This leaves the\n /// memory in `src` unchanged.\n ///\n-/// Unlike `read`, the pointer may be unaligned.\n+/// Unlike [`read`], `read_unaligned` works with unaligned pointers.\n ///\n /// # Safety\n ///\n-/// Beyond accepting a raw pointer, this is unsafe because it semantically\n-/// moves the value out of `src` without preventing further usage of `src`.\n-/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-/// `src` is not used before the data is overwritten again (e.g. with `write`,\n-/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n-/// because it will attempt to drop the value previously at `*src`.\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `src` must be [valid] for reads.\n+///\n+/// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n+/// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the returned\n+/// value and the value at `*src` can [violate memory safety][read-ownership].\n+///\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n+///\n+/// [`Copy`]: ../marker/trait.Copy.html\n+/// [`read`]: ./fn.read.html\n+/// [`write_unaligned`]: ./fn.write_unaligned.html\n+/// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n+/// [valid]: ../ptr/index.html#safety\n ///\n /// # Examples\n ///\n-/// Basic usage:\n+/// Access members of a packed struct by reference:\n ///\n /// ```\n-/// let x = 12;\n-/// let y = &x as *const i32;\n+/// use std::ptr;\n ///\n-/// unsafe {\n-///     assert_eq!(std::ptr::read_unaligned(y), 12);\n+/// #[repr(packed, C)]\n+/// struct Packed {\n+///     _padding: u8,\n+///     unaligned: u32,\n /// }\n+///\n+/// let x = Packed {\n+///     _padding: 0x00,\n+///     unaligned: 0x01020304,\n+/// };\n+///\n+/// let v = unsafe {\n+///     // Take the address of a 32-bit integer which is not aligned.\n+///     // This must be done as a raw pointer; unaligned references are invalid.\n+///     let unaligned = &x.unaligned as *const u32;\n+///\n+///     // Dereferencing normally will emit an aligned load instruction,\n+///     // causing undefined behavior.\n+///     // let v = *unaligned; // ERROR\n+///\n+///     // Instead, use `read_unaligned` to read improperly aligned values.\n+///     let v = ptr::read_unaligned(unaligned);\n+///\n+///     v\n+/// };\n+///\n+/// // Accessing unaligned values directly is safe.\n+/// assert!(x.unaligned == v);\n /// ```\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n@@ -336,21 +646,31 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n-/// # Safety\n-///\n-/// This operation is marked unsafe because it accepts a raw pointer.\n-///\n-/// It does not drop the contents of `dst`. This is safe, but it could leak\n-/// allocations or resources, so care must be taken not to overwrite an object\n+/// `write` does not drop the contents of `dst`. This is safe, but it could leak\n+/// allocations or resources, so care should be taken not to overwrite an object\n /// that should be dropped.\n ///\n /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n /// location pointed to by `dst`.\n ///\n /// This is appropriate for initializing uninitialized memory, or overwriting\n-/// memory that has previously been `read` from.\n+/// memory that has previously been [`read`] from.\n+///\n+/// [`read`]: ./fn.read.html\n+///\n+/// # Safety\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// The pointer must be aligned; use `write_unaligned` if that is not the case.\n+/// * `dst` must be [valid] for writes.\n+///\n+/// * `dst` must be properly aligned. Use [`write_unaligned`] if this is not the\n+///   case.\n+///\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n+///\n+/// [valid]: ../ptr/index.html#safety\n+/// [`write_unaligned`]: ./fn.write_unaligned.html\n ///\n /// # Examples\n ///\n@@ -366,6 +686,47 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n ///     assert_eq!(std::ptr::read(y), 12);\n /// }\n /// ```\n+///\n+/// Manually implement [`mem::swap`]:\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// fn swap<T>(a: &mut T, b: &mut T) {\n+///     unsafe {\n+///         // Create a bitwise copy of the value at `a` in `tmp`.\n+///         let tmp = ptr::read(a);\n+///\n+///         // Exiting at this point (either by explicitly returning or by\n+///         // calling a function which panics) would cause the value in `tmp` to\n+///         // be dropped while the same value is still referenced by `a`. This\n+///         // could trigger undefined behavior if `T` is not `Copy`.\n+///\n+///         // Create a bitwise copy of the value at `b` in `a`.\n+///         // This is safe because mutable references cannot alias.\n+///         ptr::copy_nonoverlapping(b, a, 1);\n+///\n+///         // As above, exiting here could trigger undefined behavior because\n+///         // the same value is referenced by `a` and `b`.\n+///\n+///         // Move `tmp` into `b`.\n+///         ptr::write(b, tmp);\n+///\n+///         // `tmp` has been moved (`write` takes ownership of its second argument),\n+///         // so nothing is dropped implicitly here.\n+///     }\n+/// }\n+///\n+/// let mut foo = \"foo\".to_owned();\n+/// let mut bar = \"bar\".to_owned();\n+///\n+/// swap(&mut foo, &mut bar);\n+///\n+/// assert_eq!(foo, \"bar\");\n+/// assert_eq!(bar, \"foo\");\n+/// ```\n+///\n+/// [`mem::swap`]: ../mem/fn.swap.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n@@ -375,35 +736,62 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n-/// Unlike `write`, the pointer may be unaligned.\n-///\n-/// # Safety\n-///\n-/// This operation is marked unsafe because it accepts a raw pointer.\n+/// Unlike [`write`], the pointer may be unaligned.\n ///\n-/// It does not drop the contents of `dst`. This is safe, but it could leak\n-/// allocations or resources, so care must be taken not to overwrite an object\n-/// that should be dropped.\n+/// `write_unaligned` does not drop the contents of `dst`. This is safe, but it\n+/// could leak allocations or resources, so care should be taken not to overwrite\n+/// an object that should be dropped.\n ///\n /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n /// location pointed to by `dst`.\n ///\n /// This is appropriate for initializing uninitialized memory, or overwriting\n-/// memory that has previously been `read` from.\n+/// memory that has previously been read with [`read_unaligned`].\n+///\n+/// [`write`]: ./fn.write.html\n+/// [`read_unaligned`]: ./fn.read_unaligned.html\n+///\n+/// # Safety\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `dst` must be [valid] for writes.\n+///\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n+///\n+/// [valid]: ../ptr/index.html#safety\n ///\n /// # Examples\n ///\n-/// Basic usage:\n+/// Access fields in a packed struct:\n ///\n /// ```\n-/// let mut x = 0;\n-/// let y = &mut x as *mut i32;\n-/// let z = 12;\n+/// use std::{mem, ptr};\n+///\n+/// #[repr(packed, C)]\n+/// #[derive(Default)]\n+/// struct Packed {\n+///     _padding: u8,\n+///     unaligned: u32,\n+/// }\n+///\n+/// let v = 0x01020304;\n+/// let mut x: Packed = unsafe { mem::zeroed() };\n ///\n /// unsafe {\n-///     std::ptr::write_unaligned(y, z);\n-///     assert_eq!(std::ptr::read_unaligned(y), 12);\n+///     // Take a reference to a 32-bit integer which is not aligned.\n+///     let unaligned = &mut x.unaligned as *mut u32;\n+///\n+///     // Dereferencing normally will emit an aligned store instruction,\n+///     // causing undefined behavior because the pointer is not aligned.\n+///     // *unaligned = v; // ERROR\n+///\n+///     // Instead, use `write_unaligned` to write improperly aligned values.\n+///     ptr::write_unaligned(unaligned, v);\n /// }\n+///\n+/// // Accessing unaligned values directly is safe.\n+/// assert!(x.unaligned == v);\n /// ```\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n@@ -421,6 +809,11 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// to not be elided or reordered by the compiler across other volatile\n /// operations.\n ///\n+/// Memory accessed with `read_volatile` or [`write_volatile`] should not be\n+/// accessed with non-volatile operations.\n+///\n+/// [`write_volatile`]: ./fn.write_volatile.html\n+///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -437,12 +830,23 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// # Safety\n ///\n-/// Beyond accepting a raw pointer, this is unsafe because it semantically\n-/// moves the value out of `src` without preventing further usage of `src`.\n-/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-/// `src` is not used before the data is overwritten again (e.g. with `write`,\n-/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n-/// because it will attempt to drop the value previously at `*src`.\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `src` must be [valid] for reads.\n+///\n+/// * `src` must be properly aligned.\n+///\n+/// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n+/// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the returned\n+/// value and the value at `*src` can [violate memory safety][read-ownership].\n+/// However, storing non-[`Copy`] types in volatile memory is almost certainly\n+/// incorrect.\n+///\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n+///\n+/// [valid]: ../ptr/index.html#safety\n+/// [`Copy`]: ../marker/trait.Copy.html\n+/// [`read`]: ./fn.read.html\n ///\n /// Just like in C, whether an operation is volatile has no bearing whatsoever\n /// on questions involving concurrent access from multiple threads. Volatile\n@@ -475,6 +879,18 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// to not be elided or reordered by the compiler across other volatile\n /// operations.\n ///\n+/// Memory accessed with [`read_volatile`] or `write_volatile` should not be\n+/// accessed with non-volatile operations.\n+///\n+/// `write_volatile` does not drop the contents of `dst`. This is safe, but it\n+/// could leak allocations or resources, so care should be taken not to overwrite\n+/// an object that should be dropped.\n+///\n+/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n+/// location pointed to by `dst`.\n+///\n+/// [`read_volatile`]: ./fn.read_volatile.html\n+///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -491,14 +907,15 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// # Safety\n ///\n-/// This operation is marked unsafe because it accepts a raw pointer.\n+/// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// It does not drop the contents of `dst`. This is safe, but it could leak\n-/// allocations or resources, so care must be taken not to overwrite an object\n-/// that should be dropped.\n+/// * `dst` must be [valid] for writes.\n ///\n-/// This is appropriate for initializing uninitialized memory, or overwriting\n-/// memory that has previously been `read` from.\n+/// * `dst` must be properly aligned.\n+///\n+/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n+///\n+/// [valid]: ../ptr/index.html#safety\n ///\n /// Just like in C, whether an operation is volatile has no bearing whatsoever\n /// on questions involving concurrent access from multiple threads. Volatile\n@@ -1019,29 +1436,9 @@ impl<T: ?Sized> *const T {\n     /// Reads the value from `self` without moving it. This leaves the\n     /// memory in `self` unchanged.\n     ///\n-    /// # Safety\n+    /// See [`ptr::read`] for safety concerns and examples.\n     ///\n-    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n-    /// moves the value out of `self` without preventing further usage of `self`.\n-    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n-    /// because it will attempt to drop the value previously at `*self`.\n-    ///\n-    /// The pointer must be aligned; use `read_unaligned` if that is not the case.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let x = 12;\n-    /// let y = &x as *const i32;\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(y.read(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::read`]: ./ptr/fn.read.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read(self) -> T\n@@ -1057,47 +1454,9 @@ impl<T: ?Sized> *const T {\n     /// to not be elided or reordered by the compiler across other volatile\n     /// operations.\n     ///\n-    /// # Notes\n-    ///\n-    /// Rust does not currently have a rigorously and formally defined memory model,\n-    /// so the precise semantics of what \"volatile\" means here is subject to change\n-    /// over time. That being said, the semantics will almost always end up pretty\n-    /// similar to [C11's definition of volatile][c11].\n-    ///\n-    /// The compiler shouldn't change the relative order or number of volatile\n-    /// memory operations. However, volatile memory operations on zero-sized types\n-    /// (e.g. if a zero-sized type is passed to `read_volatile`) are no-ops\n-    /// and may be ignored.\n-    ///\n-    /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n-    ///\n-    /// # Safety\n-    ///\n-    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n-    /// moves the value out of `self` without preventing further usage of `self`.\n-    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n-    /// because it will attempt to drop the value previously at `*self`.\n+    /// See [`ptr::read_volatile`] for safety concerns and examples.\n     ///\n-    /// Just like in C, whether an operation is volatile has no bearing whatsoever\n-    /// on questions involving concurrent access from multiple threads. Volatile\n-    /// accesses behave exactly like non-atomic accesses in that regard. In particular,\n-    /// a race between a `read_volatile` and any write operation to the same location\n-    /// is undefined behavior.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let x = 12;\n-    /// let y = &x as *const i32;\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(y.read_volatile(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::read_volatile`]: ./ptr/fn.read_volatile.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_volatile(self) -> T\n@@ -1111,27 +1470,9 @@ impl<T: ?Sized> *const T {\n     ///\n     /// Unlike `read`, the pointer may be unaligned.\n     ///\n-    /// # Safety\n-    ///\n-    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n-    /// moves the value out of `self` without preventing further usage of `self`.\n-    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n-    /// because it will attempt to drop the value previously at `*self`.\n+    /// See [`ptr::read_unaligned`] for safety concerns and examples.\n     ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let x = 12;\n-    /// let y = &x as *const i32;\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(y.read_unaligned(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::read_unaligned`]: ./ptr/fn.read_unaligned.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_unaligned(self) -> T\n@@ -1143,30 +1484,11 @@ impl<T: ?Sized> *const T {\n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n     /// and destination may overlap.\n     ///\n-    /// NOTE: this has the *same* argument order as `ptr::copy`.\n-    ///\n-    /// This is semantically equivalent to C's `memmove`.\n-    ///\n-    /// # Safety\n+    /// NOTE: this has the *same* argument order as [`ptr::copy`].\n     ///\n-    /// Care must be taken with the ownership of `self` and `dest`.\n-    /// This method semantically moves the values of `self` into `dest`.\n-    /// However it does not drop the contents of `dest`, or prevent the contents\n-    /// of `self` from being dropped or used.\n+    /// See [`ptr::copy`] for safety concerns and examples.\n     ///\n-    /// # Examples\n-    ///\n-    /// Efficiently create a Rust vector from an unsafe buffer:\n-    ///\n-    /// ```\n-    /// # #[allow(dead_code)]\n-    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n-    ///     let mut dst = Vec::with_capacity(elts);\n-    ///     dst.set_len(elts);\n-    ///     ptr.copy_to(dst.as_mut_ptr(), elts);\n-    ///     dst\n-    /// }\n-    /// ```\n+    /// [`ptr::copy`]: ./ptr/fn.copy.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n@@ -1178,32 +1500,11 @@ impl<T: ?Sized> *const T {\n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n     /// and destination may *not* overlap.\n     ///\n-    /// NOTE: this has the *same* argument order as `ptr::copy_nonoverlapping`.\n+    /// NOTE: this has the *same* argument order as [`ptr::copy_nonoverlapping`].\n     ///\n-    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Beyond requiring that the program must be allowed to access both regions\n-    /// of memory, it is Undefined Behavior for source and destination to\n-    /// overlap. Care must also be taken with the ownership of `self` and\n-    /// `self`. This method semantically moves the values of `self` into `dest`.\n-    /// However it does not drop the contents of `dest`, or prevent the contents\n-    /// of `self` from being dropped or used.\n-    ///\n-    /// # Examples\n+    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n     ///\n-    /// Efficiently create a Rust vector from an unsafe buffer:\n-    ///\n-    /// ```\n-    /// # #[allow(dead_code)]\n-    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n-    ///     let mut dst = Vec::with_capacity(elts);\n-    ///     dst.set_len(elts);\n-    ///     ptr.copy_to_nonoverlapping(dst.as_mut_ptr(), elts);\n-    ///     dst\n-    /// }\n-    /// ```\n+    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n@@ -1773,29 +2074,9 @@ impl<T: ?Sized> *mut T {\n     /// Reads the value from `self` without moving it. This leaves the\n     /// memory in `self` unchanged.\n     ///\n-    /// # Safety\n-    ///\n-    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n-    /// moves the value out of `self` without preventing further usage of `self`.\n-    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n-    /// because it will attempt to drop the value previously at `*self`.\n+    /// See [`ptr::read`] for safety concerns and examples.\n     ///\n-    /// The pointer must be aligned; use `read_unaligned` if that is not the case.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let x = 12;\n-    /// let y = &x as *const i32;\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(y.read(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::read`]: ./ptr/fn.read.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read(self) -> T\n@@ -1811,47 +2092,9 @@ impl<T: ?Sized> *mut T {\n     /// to not be elided or reordered by the compiler across other volatile\n     /// operations.\n     ///\n-    /// # Notes\n-    ///\n-    /// Rust does not currently have a rigorously and formally defined memory model,\n-    /// so the precise semantics of what \"volatile\" means here is subject to change\n-    /// over time. That being said, the semantics will almost always end up pretty\n-    /// similar to [C11's definition of volatile][c11].\n-    ///\n-    /// The compiler shouldn't change the relative order or number of volatile\n-    /// memory operations. However, volatile memory operations on zero-sized types\n-    /// (e.g. if a zero-sized type is passed to `read_volatile`) are no-ops\n-    /// and may be ignored.\n-    ///\n-    /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n-    ///\n-    /// # Safety\n-    ///\n-    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n-    /// moves the value out of `self` without preventing further usage of `self`.\n-    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n-    /// because it will attempt to drop the value previously at `*self`.\n-    ///\n-    /// Just like in C, whether an operation is volatile has no bearing whatsoever\n-    /// on questions involving concurrent access from multiple threads. Volatile\n-    /// accesses behave exactly like non-atomic accesses in that regard. In particular,\n-    /// a race between a `read_volatile` and any write operation to the same location\n-    /// is undefined behavior.\n+    /// See [`ptr::read_volatile`] for safety concerns and examples.\n     ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let x = 12;\n-    /// let y = &x as *const i32;\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(y.read_volatile(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::read_volatile`]: ./ptr/fn.read_volatile.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_volatile(self) -> T\n@@ -1865,27 +2108,9 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// Unlike `read`, the pointer may be unaligned.\n     ///\n-    /// # Safety\n-    ///\n-    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n-    /// moves the value out of `self` without preventing further usage of `self`.\n-    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n-    /// because it will attempt to drop the value previously at `*self`.\n+    /// See [`ptr::read_unaligned`] for safety concerns and examples.\n     ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let x = 12;\n-    /// let y = &x as *const i32;\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(y.read_unaligned(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::read_unaligned`]: ./ptr/fn.read_unaligned.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_unaligned(self) -> T\n@@ -1897,30 +2122,11 @@ impl<T: ?Sized> *mut T {\n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n     /// and destination may overlap.\n     ///\n-    /// NOTE: this has the *same* argument order as `ptr::copy`.\n-    ///\n-    /// This is semantically equivalent to C's `memmove`.\n-    ///\n-    /// # Safety\n+    /// NOTE: this has the *same* argument order as [`ptr::copy`].\n     ///\n-    /// Care must be taken with the ownership of `self` and `dest`.\n-    /// This method semantically moves the values of `self` into `dest`.\n-    /// However it does not drop the contents of `self`, or prevent the contents\n-    /// of `dest` from being dropped or used.\n+    /// See [`ptr::copy`] for safety concerns and examples.\n     ///\n-    /// # Examples\n-    ///\n-    /// Efficiently create a Rust vector from an unsafe buffer:\n-    ///\n-    /// ```\n-    /// # #[allow(dead_code)]\n-    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n-    ///     let mut dst = Vec::with_capacity(elts);\n-    ///     dst.set_len(elts);\n-    ///     ptr.copy_to(dst.as_mut_ptr(), elts);\n-    ///     dst\n-    /// }\n-    /// ```\n+    /// [`ptr::copy`]: ./ptr/fn.copy.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n@@ -1932,32 +2138,11 @@ impl<T: ?Sized> *mut T {\n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n     /// and destination may *not* overlap.\n     ///\n-    /// NOTE: this has the *same* argument order as `ptr::copy_nonoverlapping`.\n-    ///\n-    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Beyond requiring that the program must be allowed to access both regions\n-    /// of memory, it is Undefined Behavior for source and destination to\n-    /// overlap. Care must also be taken with the ownership of `self` and\n-    /// `self`. This method semantically moves the values of `self` into `dest`.\n-    /// However it does not drop the contents of `dest`, or prevent the contents\n-    /// of `self` from being dropped or used.\n-    ///\n-    /// # Examples\n+    /// NOTE: this has the *same* argument order as [`ptr::copy_nonoverlapping`].\n     ///\n-    /// Efficiently create a Rust vector from an unsafe buffer:\n+    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n     ///\n-    /// ```\n-    /// # #[allow(dead_code)]\n-    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n-    ///     let mut dst = Vec::with_capacity(elts);\n-    ///     dst.set_len(elts);\n-    ///     ptr.copy_to_nonoverlapping(dst.as_mut_ptr(), elts);\n-    ///     dst\n-    /// }\n-    /// ```\n+    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n@@ -1969,30 +2154,11 @@ impl<T: ?Sized> *mut T {\n     /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n     /// and destination may overlap.\n     ///\n-    /// NOTE: this has the *opposite* argument order of `ptr::copy`.\n-    ///\n-    /// This is semantically equivalent to C's `memmove`.\n-    ///\n-    /// # Safety\n+    /// NOTE: this has the *opposite* argument order of [`ptr::copy`].\n     ///\n-    /// Care must be taken with the ownership of `src` and `self`.\n-    /// This method semantically moves the values of `src` into `self`.\n-    /// However it does not drop the contents of `self`, or prevent the contents\n-    /// of `src` from being dropped or used.\n+    /// See [`ptr::copy`] for safety concerns and examples.\n     ///\n-    /// # Examples\n-    ///\n-    /// Efficiently create a Rust vector from an unsafe buffer:\n-    ///\n-    /// ```\n-    /// # #[allow(dead_code)]\n-    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n-    ///     let mut dst: Vec<T> = Vec::with_capacity(elts);\n-    ///     dst.set_len(elts);\n-    ///     dst.as_mut_ptr().copy_from(ptr, elts);\n-    ///     dst\n-    /// }\n-    /// ```\n+    /// [`ptr::copy`]: ./ptr/fn.copy.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_from(self, src: *const T, count: usize)\n@@ -2004,32 +2170,11 @@ impl<T: ?Sized> *mut T {\n     /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n     /// and destination may *not* overlap.\n     ///\n-    /// NOTE: this has the *opposite* argument order of `ptr::copy_nonoverlapping`.\n-    ///\n-    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Beyond requiring that the program must be allowed to access both regions\n-    /// of memory, it is Undefined Behavior for source and destination to\n-    /// overlap. Care must also be taken with the ownership of `src` and\n-    /// `self`. This method semantically moves the values of `src` into `self`.\n-    /// However it does not drop the contents of `self`, or prevent the contents\n-    /// of `src` from being dropped or used.\n-    ///\n-    /// # Examples\n+    /// NOTE: this has the *opposite* argument order of [`ptr::copy_nonoverlapping`].\n     ///\n-    /// Efficiently create a Rust vector from an unsafe buffer:\n+    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n     ///\n-    /// ```\n-    /// # #[allow(dead_code)]\n-    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n-    ///     let mut dst: Vec<T> = Vec::with_capacity(elts);\n-    ///     dst.set_len(elts);\n-    ///     dst.as_mut_ptr().copy_from_nonoverlapping(ptr, elts);\n-    ///     dst\n-    /// }\n-    /// ```\n+    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_from_nonoverlapping(self, src: *const T, count: usize)\n@@ -2040,21 +2185,9 @@ impl<T: ?Sized> *mut T {\n \n     /// Executes the destructor (if any) of the pointed-to value.\n     ///\n-    /// This has two use cases:\n-    ///\n-    /// * It is *required* to use `drop_in_place` to drop unsized types like\n-    ///   trait objects, because they can't be read out onto the stack and\n-    ///   dropped normally.\n-    ///\n-    /// * It is friendlier to the optimizer to do this over `ptr::read` when\n-    ///   dropping manually allocated memory (e.g. when writing Box/Rc/Vec),\n-    ///   as the compiler doesn't need to prove that it's sound to elide the\n-    ///   copy.\n+    /// See [`ptr::drop_in_place`] for safety concerns and examples.\n     ///\n-    /// # Safety\n-    ///\n-    /// This has all the same safety problems as `ptr::read` with respect to\n-    /// invalid pointers, types, and double drops.\n+    /// [`ptr::drop_in_place`]: ./ptr/fn.drop_in_place.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn drop_in_place(self) {\n@@ -2064,36 +2197,9 @@ impl<T: ?Sized> *mut T {\n     /// Overwrites a memory location with the given value without reading or\n     /// dropping the old value.\n     ///\n-    /// # Safety\n-    ///\n-    /// This operation is marked unsafe because it writes through a raw pointer.\n-    ///\n-    /// It does not drop the contents of `self`. This is safe, but it could leak\n-    /// allocations or resources, so care must be taken not to overwrite an object\n-    /// that should be dropped.\n-    ///\n-    /// Additionally, it does not drop `val`. Semantically, `val` is moved into the\n-    /// location pointed to by `self`.\n-    ///\n-    /// This is appropriate for initializing uninitialized memory, or overwriting\n-    /// memory that has previously been `read` from.\n-    ///\n-    /// The pointer must be aligned; use `write_unaligned` if that is not the case.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut x = 0;\n-    /// let y = &mut x as *mut i32;\n-    /// let z = 12;\n+    /// See [`ptr::write`] for safety concerns and examples.\n     ///\n-    /// unsafe {\n-    ///     y.write(z);\n-    ///     assert_eq!(y.read(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::write`]: ./ptr/fn.write.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write(self, val: T)\n@@ -2105,16 +2211,9 @@ impl<T: ?Sized> *mut T {\n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `self` to `val`.\n     ///\n-    /// # Examples\n+    /// See [`ptr::write_bytes`] for safety concerns and examples.\n     ///\n-    /// ```\n-    /// let mut vec = vec![0; 4];\n-    /// unsafe {\n-    ///     let vec_ptr = vec.as_mut_ptr();\n-    ///     vec_ptr.write_bytes(b'a', 2);\n-    /// }\n-    /// assert_eq!(vec, [b'a', b'a', 0, 0]);\n-    /// ```\n+    /// [`ptr::write_bytes`]: ./ptr/fn.write_bytes.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_bytes(self, val: u8, count: usize)\n@@ -2130,51 +2229,9 @@ impl<T: ?Sized> *mut T {\n     /// to not be elided or reordered by the compiler across other volatile\n     /// operations.\n     ///\n-    /// # Notes\n-    ///\n-    /// Rust does not currently have a rigorously and formally defined memory model,\n-    /// so the precise semantics of what \"volatile\" means here is subject to change\n-    /// over time. That being said, the semantics will almost always end up pretty\n-    /// similar to [C11's definition of volatile][c11].\n-    ///\n-    /// The compiler shouldn't change the relative order or number of volatile\n-    /// memory operations. However, volatile memory operations on zero-sized types\n-    /// (e.g. if a zero-sized type is passed to `write_volatile`) are no-ops\n-    /// and may be ignored.\n-    ///\n-    /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n-    ///\n-    /// # Safety\n-    ///\n-    /// This operation is marked unsafe because it accepts a raw pointer.\n-    ///\n-    /// It does not drop the contents of `self`. This is safe, but it could leak\n-    /// allocations or resources, so care must be taken not to overwrite an object\n-    /// that should be dropped.\n-    ///\n-    /// This is appropriate for initializing uninitialized memory, or overwriting\n-    /// memory that has previously been `read` from.\n-    ///\n-    /// Just like in C, whether an operation is volatile has no bearing whatsoever\n-    /// on questions involving concurrent access from multiple threads. Volatile\n-    /// accesses behave exactly like non-atomic accesses in that regard. In particular,\n-    /// a race between a `write_volatile` and any other operation (reading or writing)\n-    /// on the same location is undefined behavior.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut x = 0;\n-    /// let y = &mut x as *mut i32;\n-    /// let z = 12;\n+    /// See [`ptr::write_volatile`] for safety concerns and examples.\n     ///\n-    /// unsafe {\n-    ///     y.write_volatile(z);\n-    ///     assert_eq!(y.read_volatile(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::write_volatile`]: ./ptr/fn.write_volatile.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_volatile(self, val: T)\n@@ -2188,34 +2245,9 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// Unlike `write`, the pointer may be unaligned.\n     ///\n-    /// # Safety\n-    ///\n-    /// This operation is marked unsafe because it writes through a raw pointer.\n-    ///\n-    /// It does not drop the contents of `self`. This is safe, but it could leak\n-    /// allocations or resources, so care must be taken not to overwrite an object\n-    /// that should be dropped.\n+    /// See [`ptr::write_unaligned`] for safety concerns and examples.\n     ///\n-    /// Additionally, it does not drop `self`. Semantically, `self` is moved into the\n-    /// location pointed to by `val`.\n-    ///\n-    /// This is appropriate for initializing uninitialized memory, or overwriting\n-    /// memory that has previously been `read` from.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut x = 0;\n-    /// let y = &mut x as *mut i32;\n-    /// let z = 12;\n-    ///\n-    /// unsafe {\n-    ///     y.write_unaligned(z);\n-    ///     assert_eq!(y.read_unaligned(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::write_unaligned`]: ./ptr/fn.write_unaligned.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_unaligned(self, val: T)\n@@ -2227,10 +2259,9 @@ impl<T: ?Sized> *mut T {\n     /// Replaces the value at `self` with `src`, returning the old\n     /// value, without dropping either.\n     ///\n-    /// # Safety\n+    /// See [`ptr::replace`] for safety concerns and examples.\n     ///\n-    /// This is only unsafe because it accepts a raw pointer.\n-    /// Otherwise, this operation is identical to `mem::replace`.\n+    /// [`ptr::replace`]: ./ptr/fn.replace.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn replace(self, src: T) -> T\n@@ -2243,12 +2274,9 @@ impl<T: ?Sized> *mut T {\n     /// deinitializing either. They may overlap, unlike `mem::swap` which is\n     /// otherwise equivalent.\n     ///\n-    /// # Safety\n-    ///\n-    /// This function copies the memory through the raw pointers passed to it\n-    /// as arguments.\n+    /// See [`ptr::swap`] for safety concerns and examples.\n     ///\n-    /// Ensure that these pointers are valid before calling `swap`.\n+    /// [`ptr::swap`]: ./ptr/fn.swap.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn swap(self, with: *mut T)"}]}