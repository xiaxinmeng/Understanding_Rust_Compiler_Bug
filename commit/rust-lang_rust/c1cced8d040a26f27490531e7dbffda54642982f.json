{"sha": "c1cced8d040a26f27490531e7dbffda54642982f", "node_id": "C_kwDOAAsO6NoAKGMxY2NlZDhkMDQwYTI2ZjI3NDkwNTMxZTdkYmZmZGE1NDY0Mjk4MmY", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2023-01-26T15:16:03Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2023-01-26T15:16:03Z"}, "message": "std: optimize `LazyLock` size", "tree": {"sha": "dabe8ebc77c7339967a85b5cab18726c76db7e08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dabe8ebc77c7339967a85b5cab18726c76db7e08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1cced8d040a26f27490531e7dbffda54642982f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmPSmTMACgkQcE4BSbAZ\nSzwdIRAAh/XQQeKShWnsq2aj0rd/gqgJz8KNhXajczBcmdNnY6kbBUtTBaYrkSNn\nfX15qiaNtZ/f7q6+jhD3v1wDhho9XRQ1A5LAPnggiv2cAyKDn456M5SZmogBgCZS\n/Rnv4g+IkMwy+Q8InWEzRxep7a4cdo2BdvcP3OFM2C5+FFIE7j3LmeEBL6+YCzlX\nUmGZH5JCaexVh0LJfNDfZqsJC5xZgU5oEryZTIYeV1VWFlZ/WBSrmxZxpulmoPJV\nBCmnuxJRurq8CJ7ZXBHmSgbIlYcc05zBmYf7FtJSRx5HzvkxcUOX8a72oc6ZQQyp\n9xymPWV+Rb64s6AQYF9kG5zIcSN81/ahy+mvdk5pvNZPFq2/eWPDmCAPeHLTDArw\nGeAKK3PPjleZY1utKdhPLvsn0MJjcbEQT0p/m1E4VB/srgmiSeJIFIkIxOwSS2JW\nwj63LvRcqQqYxEZjvNOpEJPRUbmF0hGj5hn3QHlbiLqikQRoBV9FpCUaxNRIKBzy\niOQhAh5hhPZo3/5Jkc979syqjVhtgR4ELLe+o+tksuSuYy2aoB58j5dUP01wtiFc\nPjnRa8kvyoHbmwYGB2y7tHpqnl5pASY71BtPqBCXjzcXs1X65/5161fD+Ga7dyyO\nowxdXTN2ZbGt4iWEHR81GN0UOQnPRlF1GRJYgHoua9HIMp72koo=\n=78UJ\n-----END PGP SIGNATURE-----", "payload": "tree dabe8ebc77c7339967a85b5cab18726c76db7e08\nparent 5bef91c6e902f3bded724713bd2a64ea50abbd25\nauthor joboet <jonasboettiger@icloud.com> 1674746163 +0100\ncommitter joboet <jonasboettiger@icloud.com> 1674746163 +0100\n\nstd: optimize `LazyLock` size\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1cced8d040a26f27490531e7dbffda54642982f", "html_url": "https://github.com/rust-lang/rust/commit/c1cced8d040a26f27490531e7dbffda54642982f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1cced8d040a26f27490531e7dbffda54642982f/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bef91c6e902f3bded724713bd2a64ea50abbd25", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bef91c6e902f3bded724713bd2a64ea50abbd25", "html_url": "https://github.com/rust-lang/rust/commit/5bef91c6e902f3bded724713bd2a64ea50abbd25"}], "stats": {"total": 133, "additions": 116, "deletions": 17}, "files": [{"sha": "d7509bb973245194261fa8fb3c64e94a67757d1f", "filename": "library/std/src/sync/lazy_lock.rs", "status": "modified", "additions": 66, "deletions": 16, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c1cced8d040a26f27490531e7dbffda54642982f/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cced8d040a26f27490531e7dbffda54642982f/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs?ref=c1cced8d040a26f27490531e7dbffda54642982f", "patch": "@@ -1,8 +1,22 @@\n-use crate::cell::Cell;\n+use crate::mem::ManuallyDrop;\n+\n+use crate::cell::UnsafeCell;\n use crate::fmt;\n use crate::ops::Deref;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n-use crate::sync::OnceLock;\n+use crate::sync::Once;\n+\n+use super::once::ExclusiveState;\n+\n+// We use the state of a Once as discriminant value. Upon creation, the state is\n+// \"incomplete\" and `f` contains the initialization closure. In the first call to\n+// `call_once`, `f` is taken and run. If it succeeds, `value` is set and the state\n+// is changed to \"complete\". If it panics, the Once is poisoned, so none of the\n+// two fields is initialized.\n+union Data<T, F> {\n+    value: ManuallyDrop<T>,\n+    f: ManuallyDrop<F>,\n+}\n \n /// A value which is initialized on the first access.\n ///\n@@ -43,16 +57,17 @@ use crate::sync::OnceLock;\n /// ```\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n pub struct LazyLock<T, F = fn() -> T> {\n-    cell: OnceLock<T>,\n-    init: Cell<Option<F>>,\n+    once: Once,\n+    data: UnsafeCell<Data<T, F>>,\n }\n+\n impl<T, F: FnOnce() -> T> LazyLock<T, F> {\n     /// Creates a new lazy value with the given initializing\n     /// function.\n     #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub const fn new(f: F) -> LazyLock<T, F> {\n-        LazyLock { cell: OnceLock::new(), init: Cell::new(Some(f)) }\n+        LazyLock { once: Once::new(), data: UnsafeCell::new(Data { f: ManuallyDrop::new(f) }) }\n     }\n \n     /// Forces the evaluation of this lazy value and\n@@ -74,10 +89,43 @@ impl<T, F: FnOnce() -> T> LazyLock<T, F> {\n     #[inline]\n     #[unstable(feature = \"once_cell\", issue = \"74465\")]\n     pub fn force(this: &LazyLock<T, F>) -> &T {\n-        this.cell.get_or_init(|| match this.init.take() {\n-            Some(f) => f(),\n-            None => panic!(\"Lazy instance has previously been poisoned\"),\n-        })\n+        this.once.call_once(|| {\n+            // SAFETY: `call_once` only runs this closure once, ever.\n+            let data = unsafe { &mut *this.data.get() };\n+            let f = unsafe { ManuallyDrop::take(&mut data.f) };\n+            let value = f();\n+            data.value = ManuallyDrop::new(value);\n+        });\n+\n+        // SAFETY:\n+        // There are four possible scenarios:\n+        // * the closure was called and initialized `value`.\n+        // * the closure was called and panicked, so this point is never reached.\n+        // * the closure was not called, but a previous call initialized `value`.\n+        // * the closure was not called because the Once is poisoned, so this point\n+        //   is never reached.\n+        // So `value` has definitely been initialized and will not be modified again.\n+        unsafe { &*(*this.data.get()).value }\n+    }\n+}\n+\n+impl<T, F> LazyLock<T, F> {\n+    /// Get the inner value if it has already been initialized.\n+    fn get(&self) -> Option<&T> {\n+        if self.once.is_completed() { Some(unsafe { &*(*self.data.get()).value }) } else { None }\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F> Drop for LazyLock<T, F> {\n+    fn drop(&mut self) {\n+        match self.once.state() {\n+            ExclusiveState::Incomplete => unsafe { ManuallyDrop::drop(&mut self.data.get_mut().f) },\n+            ExclusiveState::Complete => unsafe {\n+                ManuallyDrop::drop(&mut self.data.get_mut().value)\n+            },\n+            ExclusiveState::Poisoned => {}\n+        }\n     }\n }\n \n@@ -103,23 +151,25 @@ impl<T: Default> Default for LazyLock<T> {\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n impl<T: fmt::Debug, F> fmt::Debug for LazyLock<T, F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).finish_non_exhaustive()\n+        f.debug_tuple(\"LazyLock\")\n+            .field(match self.get() {\n+                Some(v) => v,\n+                None => &\"Uninit\",\n+            })\n+            .finish()\n     }\n }\n \n // We never create a `&F` from a `&LazyLock<T, F>` so it is fine\n // to not impl `Sync` for `F`\n-// we do create a `&mut Option<F>` in `force`, but this is\n-// properly synchronized, so it only happens once\n-// so it also does not contribute to this impl.\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-unsafe impl<T, F: Send> Sync for LazyLock<T, F> where OnceLock<T>: Sync {}\n+unsafe impl<T: Sync + Send, F: Send> Sync for LazyLock<T, F> {}\n // auto-derived `Send` impl is OK.\n \n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T, F: UnwindSafe> RefUnwindSafe for LazyLock<T, F> where OnceLock<T>: RefUnwindSafe {}\n+impl<T: RefUnwindSafe + UnwindSafe, F: UnwindSafe> RefUnwindSafe for LazyLock<T, F> {}\n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T, F: UnwindSafe> UnwindSafe for LazyLock<T, F> where OnceLock<T>: UnwindSafe {}\n+impl<T: UnwindSafe, F: UnwindSafe> UnwindSafe for LazyLock<T, F> {}\n \n #[cfg(test)]\n mod tests;"}, {"sha": "4edc956173b08e37d94d4e87a6b9d9f8112fee95", "filename": "library/std/src/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1cced8d040a26f27490531e7dbffda54642982f/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cced8d040a26f27490531e7dbffda54642982f/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs?ref=c1cced8d040a26f27490531e7dbffda54642982f", "patch": "@@ -186,7 +186,7 @@ mod condvar;\n mod lazy_lock;\n mod mpmc;\n mod mutex;\n-mod once;\n+pub(crate) mod once;\n mod once_lock;\n mod poison;\n mod remutex;"}, {"sha": "1b17c31089ff2d9dba11eea7dc7bcf30980a4584", "filename": "library/std/src/sync/once.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1cced8d040a26f27490531e7dbffda54642982f/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cced8d040a26f27490531e7dbffda54642982f/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs?ref=c1cced8d040a26f27490531e7dbffda54642982f", "patch": "@@ -43,6 +43,12 @@ pub struct OnceState {\n     pub(crate) inner: sys::OnceState,\n }\n \n+pub(crate) enum ExclusiveState {\n+    Incomplete,\n+    Poisoned,\n+    Complete,\n+}\n+\n /// Initialization value for static [`Once`] values.\n ///\n /// # Examples\n@@ -248,6 +254,16 @@ impl Once {\n     pub fn is_completed(&self) -> bool {\n         self.inner.is_completed()\n     }\n+\n+    /// Returns the current state of the `Once` instance.\n+    ///\n+    /// Since this takes a mutable reference, no initialization can currently\n+    /// be running, so the state must be either \"incomplete\", \"poisoned\" or\n+    /// \"complete\".\n+    #[inline]\n+    pub(crate) fn state(&mut self) -> ExclusiveState {\n+        self.inner.state()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]"}, {"sha": "11fde1888ba7cf975a360031a846f401d75938a7", "filename": "library/std/src/sys/unsupported/once.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1cced8d040a26f27490531e7dbffda54642982f/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cced8d040a26f27490531e7dbffda54642982f/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fonce.rs?ref=c1cced8d040a26f27490531e7dbffda54642982f", "patch": "@@ -1,5 +1,6 @@\n use crate::cell::Cell;\n use crate::sync as public;\n+use crate::sync::once::ExclusiveState;\n \n pub struct Once {\n     state: Cell<State>,\n@@ -44,6 +45,16 @@ impl Once {\n         self.state.get() == State::Complete\n     }\n \n+    #[inline]\n+    pub(crate) fn state(&mut self) -> ExclusiveState {\n+        match self.state.get() {\n+            State::Incomplete => ExclusiveState::Incomplete,\n+            State::Poisoned => ExclusiveState::Poisoned,\n+            State::Complete => ExclusiveState::Complete,\n+            _ => unreachable!(\"invalid Once state\"),\n+        }\n+    }\n+\n     #[cold]\n     #[track_caller]\n     pub fn call(&self, ignore_poisoning: bool, f: &mut impl FnMut(&public::OnceState)) {"}, {"sha": "42db5fad4b4518d270bbaea0da48ca854499c3f3", "filename": "library/std/src/sys_common/once/futex.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1cced8d040a26f27490531e7dbffda54642982f/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cced8d040a26f27490531e7dbffda54642982f/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Ffutex.rs?ref=c1cced8d040a26f27490531e7dbffda54642982f", "patch": "@@ -4,6 +4,7 @@ use crate::sync::atomic::{\n     AtomicU32,\n     Ordering::{Acquire, Relaxed, Release},\n };\n+use crate::sync::once::ExclusiveState;\n use crate::sys::futex::{futex_wait, futex_wake_all};\n \n // On some platforms, the OS is very nice and handles the waiter queue for us.\n@@ -78,6 +79,16 @@ impl Once {\n         self.state.load(Acquire) == COMPLETE\n     }\n \n+    #[inline]\n+    pub(crate) fn state(&mut self) -> ExclusiveState {\n+        match *self.state.get_mut() {\n+            INCOMPLETE => ExclusiveState::Incomplete,\n+            POISONED => ExclusiveState::Poisoned,\n+            COMPLETE => ExclusiveState::Complete,\n+            _ => unreachable!(\"invalid Once state\"),\n+        }\n+    }\n+\n     // This uses FnMut to match the API of the generic implementation. As this\n     // implementation is quite light-weight, it is generic over the closure and\n     // so avoids the cost of dynamic dispatch."}, {"sha": "def0bcd6fac444167a13c8338d9a8b1d03129a23", "filename": "library/std/src/sys_common/once/queue.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1cced8d040a26f27490531e7dbffda54642982f/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cced8d040a26f27490531e7dbffda54642982f/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fqueue.rs?ref=c1cced8d040a26f27490531e7dbffda54642982f", "patch": "@@ -60,6 +60,7 @@ use crate::fmt;\n use crate::ptr;\n use crate::sync as public;\n use crate::sync::atomic::{AtomicBool, AtomicPtr, Ordering};\n+use crate::sync::once::ExclusiveState;\n use crate::thread::{self, Thread};\n \n type Masked = ();\n@@ -121,6 +122,16 @@ impl Once {\n         self.state_and_queue.load(Ordering::Acquire).addr() == COMPLETE\n     }\n \n+    #[inline]\n+    pub(crate) fn state(&mut self) -> ExclusiveState {\n+        match self.state_and_queue.get_mut().addr() {\n+            INCOMPLETE => ExclusiveState::Incomplete,\n+            POISONED => ExclusiveState::Poisoned,\n+            COMPLETE => ExclusiveState::Complete,\n+            _ => unreachable!(\"invalid Once state\"),\n+        }\n+    }\n+\n     // This is a non-generic function to reduce the monomorphization cost of\n     // using `call_once` (this isn't exactly a trivial or small implementation).\n     //"}]}