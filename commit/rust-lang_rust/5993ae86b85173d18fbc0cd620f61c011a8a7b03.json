{"sha": "5993ae86b85173d18fbc0cd620f61c011a8a7b03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5OTNhZTg2Yjg1MTczZDE4ZmJjMGNkNjIwZjYxYzAxMWE4YTdiMDM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-24T01:20:54Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-29T05:23:36Z"}, "message": "debuginfo: pull out docs", "tree": {"sha": "2542b628872dc6df5201210774c432461fc37841", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2542b628872dc6df5201210774c432461fc37841"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5993ae86b85173d18fbc0cd620f61c011a8a7b03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5993ae86b85173d18fbc0cd620f61c011a8a7b03", "html_url": "https://github.com/rust-lang/rust/commit/5993ae86b85173d18fbc0cd620f61c011a8a7b03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5993ae86b85173d18fbc0cd620f61c011a8a7b03/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39e2e649cb0ef3da750d296af07d4cea6aadf51f", "url": "https://api.github.com/repos/rust-lang/rust/commits/39e2e649cb0ef3da750d296af07d4cea6aadf51f", "html_url": "https://github.com/rust-lang/rust/commit/39e2e649cb0ef3da750d296af07d4cea6aadf51f"}], "stats": {"total": 391, "additions": 202, "deletions": 189}, "files": [{"sha": "138770c42b806b863d0a32ec3d4c852f31648401", "filename": "src/librustc_trans/trans/debuginfo/doc.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/5993ae86b85173d18fbc0cd620f61c011a8a7b03/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5993ae86b85173d18fbc0cd620f61c011a8a7b03/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs?ref=5993ae86b85173d18fbc0cd620f61c011a8a7b03", "patch": "@@ -0,0 +1,189 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://!rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://!www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://!opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! # Debug Info Module\n+//!\n+//! This module serves the purpose of generating debug symbols. We use LLVM's\n+//! [source level debugging](http://!llvm.org/docs/SourceLevelDebugging.html)\n+//! features for generating the debug information. The general principle is\n+//! this:\n+//!\n+//! Given the right metadata in the LLVM IR, the LLVM code generator is able to\n+//! create DWARF debug symbols for the given code. The\n+//! [metadata](http://!llvm.org/docs/LangRef.html#metadata-type) is structured\n+//! much like DWARF *debugging information entries* (DIE), representing type\n+//! information such as datatype layout, function signatures, block layout,\n+//! variable location and scope information, etc. It is the purpose of this\n+//! module to generate correct metadata and insert it into the LLVM IR.\n+//!\n+//! As the exact format of metadata trees may change between different LLVM\n+//! versions, we now use LLVM\n+//! [DIBuilder](http://!llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n+//! to create metadata where possible. This will hopefully ease the adaption of\n+//! this module to future LLVM versions.\n+//!\n+//! The public API of the module is a set of functions that will insert the\n+//! correct metadata into the LLVM IR when called with the right parameters.\n+//! The module is thus driven from an outside client with functions like\n+//! `debuginfo::create_local_var_metadata(bcx: block, local: &ast::local)`.\n+//!\n+//! Internally the module will try to reuse already created metadata by\n+//! utilizing a cache. The way to get a shared metadata node when needed is\n+//! thus to just call the corresponding function in this module:\n+//!\n+//!     let file_metadata = file_metadata(crate_context, path);\n+//!\n+//! The function will take care of probing the cache for an existing node for\n+//! that exact file path.\n+//!\n+//! All private state used by the module is stored within either the\n+//! CrateDebugContext struct (owned by the CrateContext) or the\n+//! FunctionDebugContext (owned by the FunctionContext).\n+//!\n+//! This file consists of three conceptual sections:\n+//! 1. The public interface of the module\n+//! 2. Module-internal metadata creation functions\n+//! 3. Minor utility functions\n+//!\n+//!\n+//! ## Recursive Types\n+//!\n+//! Some kinds of types, such as structs and enums can be recursive. That means\n+//! that the type definition of some type X refers to some other type which in\n+//! turn (transitively) refers to X. This introduces cycles into the type\n+//! referral graph. A naive algorithm doing an on-demand, depth-first traversal\n+//! of this graph when describing types, can get trapped in an endless loop\n+//! when it reaches such a cycle.\n+//!\n+//! For example, the following simple type for a singly-linked list...\n+//!\n+//! ```\n+//! struct List {\n+//!     value: int,\n+//!     tail: Option<Box<List>>,\n+//! }\n+//! ```\n+//!\n+//! will generate the following callstack with a naive DFS algorithm:\n+//!\n+//! ```\n+//! describe(t = List)\n+//!   describe(t = int)\n+//!   describe(t = Option<Box<List>>)\n+//!     describe(t = Box<List>)\n+//!       describe(t = List) // at the beginning again...\n+//!       ...\n+//! ```\n+//!\n+//! To break cycles like these, we use \"forward declarations\". That is, when\n+//! the algorithm encounters a possibly recursive type (any struct or enum), it\n+//! immediately creates a type description node and inserts it into the cache\n+//! *before* describing the members of the type. This type description is just\n+//! a stub (as type members are not described and added to it yet) but it\n+//! allows the algorithm to already refer to the type. After the stub is\n+//! inserted into the cache, the algorithm continues as before. If it now\n+//! encounters a recursive reference, it will hit the cache and does not try to\n+//! describe the type anew.\n+//!\n+//! This behaviour is encapsulated in the 'RecursiveTypeDescription' enum,\n+//! which represents a kind of continuation, storing all state needed to\n+//! continue traversal at the type members after the type has been registered\n+//! with the cache. (This implementation approach might be a tad over-\n+//! engineered and may change in the future)\n+//!\n+//!\n+//! ## Source Locations and Line Information\n+//!\n+//! In addition to data type descriptions the debugging information must also\n+//! allow to map machine code locations back to source code locations in order\n+//! to be useful. This functionality is also handled in this module. The\n+//! following functions allow to control source mappings:\n+//!\n+//! + set_source_location()\n+//! + clear_source_location()\n+//! + start_emitting_source_locations()\n+//!\n+//! `set_source_location()` allows to set the current source location. All IR\n+//! instructions created after a call to this function will be linked to the\n+//! given source location, until another location is specified with\n+//! `set_source_location()` or the source location is cleared with\n+//! `clear_source_location()`. In the later case, subsequent IR instruction\n+//! will not be linked to any source location. As you can see, this is a\n+//! stateful API (mimicking the one in LLVM), so be careful with source\n+//! locations set by previous calls. It's probably best to not rely on any\n+//! specific state being present at a given point in code.\n+//!\n+//! One topic that deserves some extra attention is *function prologues*. At\n+//! the beginning of a function's machine code there are typically a few\n+//! instructions for loading argument values into allocas and checking if\n+//! there's enough stack space for the function to execute. This *prologue* is\n+//! not visible in the source code and LLVM puts a special PROLOGUE END marker\n+//! into the line table at the first non-prologue instruction of the function.\n+//! In order to find out where the prologue ends, LLVM looks for the first\n+//! instruction in the function body that is linked to a source location. So,\n+//! when generating prologue instructions we have to make sure that we don't\n+//! emit source location information until the 'real' function body begins. For\n+//! this reason, source location emission is disabled by default for any new\n+//! function being translated and is only activated after a call to the third\n+//! function from the list above, `start_emitting_source_locations()`. This\n+//! function should be called right before regularly starting to translate the\n+//! top-level block of the given function.\n+//!\n+//! There is one exception to the above rule: `llvm.dbg.declare` instruction\n+//! must be linked to the source location of the variable being declared. For\n+//! function parameters these `llvm.dbg.declare` instructions typically occur\n+//! in the middle of the prologue, however, they are ignored by LLVM's prologue\n+//! detection. The `create_argument_metadata()` and related functions take care\n+//! of linking the `llvm.dbg.declare` instructions to the correct source\n+//! locations even while source location emission is still disabled, so there\n+//! is no need to do anything special with source location handling here.\n+//!\n+//! ## Unique Type Identification\n+//!\n+//! In order for link-time optimization to work properly, LLVM needs a unique\n+//! type identifier that tells it across compilation units which types are the\n+//! same as others. This type identifier is created by\n+//! TypeMap::get_unique_type_id_of_type() using the following algorithm:\n+//!\n+//! (1) Primitive types have their name as ID\n+//! (2) Structs, enums and traits have a multipart identifier\n+//!\n+//!     (1) The first part is the SVH (strict version hash) of the crate they\n+//!          wereoriginally defined in\n+//!\n+//!     (2) The second part is the ast::NodeId of the definition in their\n+//!          originalcrate\n+//!\n+//!     (3) The final part is a concatenation of the type IDs of their concrete\n+//!          typearguments if they are generic types.\n+//!\n+//! (3) Tuple-, pointer and function types are structurally identified, which\n+//!     means that they are equivalent if their component types are equivalent\n+//!     (i.e. (int, int) is the same regardless in which crate it is used).\n+//!\n+//! This algorithm also provides a stable ID for types that are defined in one\n+//! crate but instantiated from metadata within another crate. We just have to\n+//! take care to always map crate and node IDs back to the original crate\n+//! context.\n+//!\n+//! As a side-effect these unique type IDs also help to solve a problem arising\n+//! from lifetime parameters. Since lifetime parameters are completely omitted\n+//! in debuginfo, more than one `Ty` instance may map to the same debuginfo\n+//! type metadata, that is, some struct `Struct<'a>` may have N instantiations\n+//! with different concrete substitutions for `'a`, and thus there will be N\n+//! `Ty` instances for the type `Struct<'a>` even though it is not generic\n+//! otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n+//! cheap identifier for type metadata---we have done this in the past, but it\n+//! led to unnecessary metadata duplication in the best case and LLVM\n+//! assertions in the worst. However, the unique type ID as described above\n+//! *can* be used as identifier. Since it is comparatively expensive to\n+//! construct, though, `ty::type_id()` is still used additionally as an\n+//! optimization for cases where the exact same type has been seen before\n+//! (which is most of the time)."}, {"sha": "bbd8c325487f84f039d5bf620ec7f766d8040729", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 13, "deletions": 189, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/5993ae86b85173d18fbc0cd620f61c011a8a7b03/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5993ae86b85173d18fbc0cd620f61c011a8a7b03/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=5993ae86b85173d18fbc0cd620f61c011a8a7b03", "patch": "@@ -1,192 +1,16 @@\n-//! Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-//! file at the top-level directory of this distribution and at\n-//! http://!rust-lang.org/COPYRIGHT.\n-//!\n-//! Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-//! http://!www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-//! <LICENSE-MIT or http://!opensource.org/licenses/MIT>, at your\n-//! option. This file may not be copied, modified, or distributed\n-//! except according to those terms.\n-\n-//! # Debug Info Module\n-//!\n-//! This module serves the purpose of generating debug symbols. We use LLVM's\n-//! [source level debugging](http://!llvm.org/docs/SourceLevelDebugging.html)\n-//! features for generating the debug information. The general principle is\n-//! this:\n-//!\n-//! Given the right metadata in the LLVM IR, the LLVM code generator is able to\n-//! create DWARF debug symbols for the given code. The\n-//! [metadata](http://!llvm.org/docs/LangRef.html#metadata-type) is structured\n-//! much like DWARF *debugging information entries* (DIE), representing type\n-//! information such as datatype layout, function signatures, block layout,\n-//! variable location and scope information, etc. It is the purpose of this\n-//! module to generate correct metadata and insert it into the LLVM IR.\n-//!\n-//! As the exact format of metadata trees may change between different LLVM\n-//! versions, we now use LLVM\n-//! [DIBuilder](http://!llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html)\n-//! to create metadata where possible. This will hopefully ease the adaption of\n-//! this module to future LLVM versions.\n-//!\n-//! The public API of the module is a set of functions that will insert the\n-//! correct metadata into the LLVM IR when called with the right parameters.\n-//! The module is thus driven from an outside client with functions like\n-//! `debuginfo::create_local_var_metadata(bcx: block, local: &ast::local)`.\n-//!\n-//! Internally the module will try to reuse already created metadata by\n-//! utilizing a cache. The way to get a shared metadata node when needed is\n-//! thus to just call the corresponding function in this module:\n-//!\n-//!     let file_metadata = file_metadata(crate_context, path);\n-//!\n-//! The function will take care of probing the cache for an existing node for\n-//! that exact file path.\n-//!\n-//! All private state used by the module is stored within either the\n-//! CrateDebugContext struct (owned by the CrateContext) or the\n-//! FunctionDebugContext (owned by the FunctionContext).\n-//!\n-//! This file consists of three conceptual sections:\n-//! 1. The public interface of the module\n-//! 2. Module-internal metadata creation functions\n-//! 3. Minor utility functions\n-//!\n-//!\n-//! ## Recursive Types\n-//!\n-//! Some kinds of types, such as structs and enums can be recursive. That means\n-//! that the type definition of some type X refers to some other type which in\n-//! turn (transitively) refers to X. This introduces cycles into the type\n-//! referral graph. A naive algorithm doing an on-demand, depth-first traversal\n-//! of this graph when describing types, can get trapped in an endless loop\n-//! when it reaches such a cycle.\n-//!\n-//! For example, the following simple type for a singly-linked list...\n-//!\n-//! ```\n-//! struct List {\n-//!     value: int,\n-//!     tail: Option<Box<List>>,\n-//! }\n-//! ```\n-//!\n-//! will generate the following callstack with a naive DFS algorithm:\n-//!\n-//! ```\n-//! describe(t = List)\n-//!   describe(t = int)\n-//!   describe(t = Option<Box<List>>)\n-//!     describe(t = Box<List>)\n-//!       describe(t = List) // at the beginning again...\n-//!       ...\n-//! ```\n-//!\n-//! To break cycles like these, we use \"forward declarations\". That is, when\n-//! the algorithm encounters a possibly recursive type (any struct or enum), it\n-//! immediately creates a type description node and inserts it into the cache\n-//! *before* describing the members of the type. This type description is just\n-//! a stub (as type members are not described and added to it yet) but it\n-//! allows the algorithm to already refer to the type. After the stub is\n-//! inserted into the cache, the algorithm continues as before. If it now\n-//! encounters a recursive reference, it will hit the cache and does not try to\n-//! describe the type anew.\n-//!\n-//! This behaviour is encapsulated in the 'RecursiveTypeDescription' enum,\n-//! which represents a kind of continuation, storing all state needed to\n-//! continue traversal at the type members after the type has been registered\n-//! with the cache. (This implementation approach might be a tad over-\n-//! engineered and may change in the future)\n-//!\n-//!\n-//! ## Source Locations and Line Information\n-//!\n-//! In addition to data type descriptions the debugging information must also\n-//! allow to map machine code locations back to source code locations in order\n-//! to be useful. This functionality is also handled in this module. The\n-//! following functions allow to control source mappings:\n-//!\n-//! + set_source_location()\n-//! + clear_source_location()\n-//! + start_emitting_source_locations()\n-//!\n-//! `set_source_location()` allows to set the current source location. All IR\n-//! instructions created after a call to this function will be linked to the\n-//! given source location, until another location is specified with\n-//! `set_source_location()` or the source location is cleared with\n-//! `clear_source_location()`. In the later case, subsequent IR instruction\n-//! will not be linked to any source location. As you can see, this is a\n-//! stateful API (mimicking the one in LLVM), so be careful with source\n-//! locations set by previous calls. It's probably best to not rely on any\n-//! specific state being present at a given point in code.\n-//!\n-//! One topic that deserves some extra attention is *function prologues*. At\n-//! the beginning of a function's machine code there are typically a few\n-//! instructions for loading argument values into allocas and checking if\n-//! there's enough stack space for the function to execute. This *prologue* is\n-//! not visible in the source code and LLVM puts a special PROLOGUE END marker\n-//! into the line table at the first non-prologue instruction of the function.\n-//! In order to find out where the prologue ends, LLVM looks for the first\n-//! instruction in the function body that is linked to a source location. So,\n-//! when generating prologue instructions we have to make sure that we don't\n-//! emit source location information until the 'real' function body begins. For\n-//! this reason, source location emission is disabled by default for any new\n-//! function being translated and is only activated after a call to the third\n-//! function from the list above, `start_emitting_source_locations()`. This\n-//! function should be called right before regularly starting to translate the\n-//! top-level block of the given function.\n-//!\n-//! There is one exception to the above rule: `llvm.dbg.declare` instruction\n-//! must be linked to the source location of the variable being declared. For\n-//! function parameters these `llvm.dbg.declare` instructions typically occur\n-//! in the middle of the prologue, however, they are ignored by LLVM's prologue\n-//! detection. The `create_argument_metadata()` and related functions take care\n-//! of linking the `llvm.dbg.declare` instructions to the correct source\n-//! locations even while source location emission is still disabled, so there\n-//! is no need to do anything special with source location handling here.\n-//!\n-//! ## Unique Type Identification\n-//!\n-//! In order for link-time optimization to work properly, LLVM needs a unique\n-//! type identifier that tells it across compilation units which types are the\n-//! same as others. This type identifier is created by\n-//! TypeMap::get_unique_type_id_of_type() using the following algorithm:\n-//!\n-//! (1) Primitive types have their name as ID\n-//! (2) Structs, enums and traits have a multipart identifier\n-//!\n-//!     (1) The first part is the SVH (strict version hash) of the crate they\n-//!          wereoriginally defined in\n-//!\n-//!     (2) The second part is the ast::NodeId of the definition in their\n-//!          originalcrate\n-//!\n-//!     (3) The final part is a concatenation of the type IDs of their concrete\n-//!          typearguments if they are generic types.\n-//!\n-//! (3) Tuple-, pointer and function types are structurally identified, which\n-//!     means that they are equivalent if their component types are equivalent\n-//!     (i.e. (int, int) is the same regardless in which crate it is used).\n-//!\n-//! This algorithm also provides a stable ID for types that are defined in one\n-//! crate but instantiated from metadata within another crate. We just have to\n-//! take care to always map crate and node IDs back to the original crate\n-//! context.\n-//!\n-//! As a side-effect these unique type IDs also help to solve a problem arising\n-//! from lifetime parameters. Since lifetime parameters are completely omitted\n-//! in debuginfo, more than one `Ty` instance may map to the same debuginfo\n-//! type metadata, that is, some struct `Struct<'a>` may have N instantiations\n-//! with different concrete substitutions for `'a`, and thus there will be N\n-//! `Ty` instances for the type `Struct<'a>` even though it is not generic\n-//! otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n-//! cheap identifier for type metadata---we have done this in the past, but it\n-//! led to unnecessary metadata duplication in the best case and LLVM\n-//! assertions in the worst. However, the unique type ID as described above\n-//! *can* be used as identifier. Since it is comparatively expensive to\n-//! construct, though, `ty::type_id()` is still used additionally as an\n-//! optimization for cases where the exact same type has been seen before\n-//! (which is most of the time).\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://!rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://!www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://!opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// See doc.rs for documentation.\n+mod doc;\n+\n use self::VariableAccess::*;\n use self::VariableKind::*;\n use self::MemberOffset::*;"}]}