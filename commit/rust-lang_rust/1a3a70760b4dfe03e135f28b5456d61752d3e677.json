{"sha": "1a3a70760b4dfe03e135f28b5456d61752d3e677", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhM2E3MDc2MGI0ZGZlMDNlMTM1ZjI4YjU0NTZkNjE3NTJkM2U2Nzc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-10-19T13:01:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-10-25T01:56:31Z"}, "message": "Implement proper subtyping for region fn types (part of #2263)", "tree": {"sha": "00c4623d61c3a3b19c0077e93cd158cb3553b8a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00c4623d61c3a3b19c0077e93cd158cb3553b8a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a3a70760b4dfe03e135f28b5456d61752d3e677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a3a70760b4dfe03e135f28b5456d61752d3e677", "html_url": "https://github.com/rust-lang/rust/commit/1a3a70760b4dfe03e135f28b5456d61752d3e677", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a3a70760b4dfe03e135f28b5456d61752d3e677/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f04a6fc21309083e3ffbcb44b05227dca6dba4d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f04a6fc21309083e3ffbcb44b05227dca6dba4d5", "html_url": "https://github.com/rust-lang/rust/commit/f04a6fc21309083e3ffbcb44b05227dca6dba4d5"}], "stats": {"total": 1294, "additions": 877, "deletions": 417}, "files": [{"sha": "83ed0f0d315fd871b8d5a1365e9e3ca530210cc6", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -136,12 +136,23 @@ pub pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n #[cfg(notest)]\n pub mod traits {\n     #[legacy_exports];\n+\n+    #[cfg(stage0)]\n     pub impl<T: Copy> @[T] : Add<&[const T],@[T]> {\n         #[inline(always)]\n         pure fn add(rhs: & &[const T]) -> @[T] {\n             append(self, (*rhs))\n         }\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    pub impl<T: Copy> @[T] : Add<&[const T],@[T]> {\n+        #[inline(always)]\n+        pure fn add(rhs: & &self/[const T]) -> @[T] {\n+            append(self, (*rhs))\n+        }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "d9e6cd4685955d36b66834659a50e63eada8c723", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -226,19 +226,37 @@ impl<T> *const T : Ord {\n }\n \n // Equality for region pointers\n+#[cfg(stage0)]\n impl<T:Eq> &const T : Eq {\n     pure fn eq(other: & &const T) -> bool { return *self == *(*other); }\n     pure fn ne(other: & &const T) -> bool { return *self != *(*other); }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T:Eq> &const T : Eq {\n+    pure fn eq(other: & &self/const T) -> bool { return *self == *(*other); }\n+    pure fn ne(other: & &self/const T) -> bool { return *self != *(*other); }\n+}\n+\n // Comparison for region pointers\n+#[cfg(stage0)]\n impl<T:Ord> &const T : Ord {\n     pure fn lt(other: & &const T) -> bool { *self < *(*other) }\n     pure fn le(other: & &const T) -> bool { *self <= *(*other) }\n     pure fn ge(other: & &const T) -> bool { *self >= *(*other) }\n     pure fn gt(other: & &const T) -> bool { *self > *(*other) }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T:Ord> &const T : Ord {\n+    pure fn lt(other: & &self/const T) -> bool { *self < *(*other) }\n+    pure fn le(other: & &self/const T) -> bool { *self <= *(*other) }\n+    pure fn ge(other: & &self/const T) -> bool { *self >= *(*other) }\n+    pure fn gt(other: & &self/const T) -> bool { *self > *(*other) }\n+}\n+\n #[test]\n pub fn test() {\n     unsafe {"}, {"sha": "4f078a5e482c19fd74607584d8009ea0b84929a7", "filename": "src/libcore/str.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -735,6 +735,7 @@ pure fn gt(a: &str, b: &str) -> bool {\n     !le(a, b)\n }\n \n+#[cfg(stage0)]\n impl &str : Eq {\n     #[inline(always)]\n     pure fn eq(other: & &str) -> bool {\n@@ -744,6 +745,17 @@ impl &str : Eq {\n     pure fn ne(other: & &str) -> bool { !self.eq(other) }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl &str : Eq {\n+    #[inline(always)]\n+    pure fn eq(other: & &self/str) -> bool {\n+        eq_slice(self, (*other))\n+    }\n+    #[inline(always)]\n+    pure fn ne(other: & &self/str) -> bool { !self.eq(other) }\n+}\n+\n impl ~str : Eq {\n     #[inline(always)]\n     pure fn eq(other: &~str) -> bool {\n@@ -773,6 +785,7 @@ impl ~str : Ord {\n     pure fn gt(other: &~str) -> bool { gt(self, (*other)) }\n }\n \n+#[cfg(stage0)]\n impl &str : Ord {\n     #[inline(always)]\n     pure fn lt(other: & &str) -> bool { lt(self, (*other)) }\n@@ -784,6 +797,19 @@ impl &str : Ord {\n     pure fn gt(other: & &str) -> bool { gt(self, (*other)) }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl &str : Ord {\n+    #[inline(always)]\n+    pure fn lt(other: & &self/str) -> bool { lt(self, (*other)) }\n+    #[inline(always)]\n+    pure fn le(other: & &self/str) -> bool { le(self, (*other)) }\n+    #[inline(always)]\n+    pure fn ge(other: & &self/str) -> bool { ge(self, (*other)) }\n+    #[inline(always)]\n+    pure fn gt(other: & &self/str) -> bool { gt(self, (*other)) }\n+}\n+\n impl @str : Ord {\n     #[inline(always)]\n     pure fn lt(other: &@str) -> bool { lt(self, (*other)) }\n@@ -2096,12 +2122,22 @@ impl ~str: Trimmable {\n \n #[cfg(notest)]\n pub mod traits {\n+    #[cfg(stage0)]\n     impl ~str : Add<&str,~str> {\n         #[inline(always)]\n         pure fn add(rhs: & &str) -> ~str {\n             append(copy self, (*rhs))\n         }\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    impl ~str : Add<&str,~str> {\n+        #[inline(always)]\n+        pure fn add(rhs: & &self/str) -> ~str {\n+            append(copy self, (*rhs))\n+        }\n+    }\n }\n \n #[cfg(test)]\n@@ -2558,7 +2594,7 @@ mod tests {\n         assert find_str_between(data, ~\"ab\", 2u, 4u).is_none();\n \n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        data += data;\n+        data = data + data;\n         assert find_str_between(data, ~\"\", 0u, 43u) == Some(0u);\n         assert find_str_between(data, ~\"\", 6u, 43u) == Some(6u);\n "}, {"sha": "24a44c591c1b6bcfa268c45abf77185610c00814", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 81, "deletions": 7, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -736,6 +736,27 @@ pub pure fn filter<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[T] {\n     move result\n }\n \n+/**\n+ * Like `filter()`, but in place.  Preserves order of `v`.  Linear time.\n+ */\n+pub fn retain<T>(v: &mut ~[T], f: pure fn(t: &T) -> bool) {\n+    let len = v.len();\n+    let mut deleted: uint = 0;\n+\n+    for uint::range(0, len) |i| {\n+        if !f(&v[i]) {\n+            deleted += 1;\n+        } else if deleted > 0 {\n+            v[i - deleted] <-> v[i];\n+        }\n+    }\n+\n+    while deleted > 0 {\n+        v.pop();\n+        deleted -= 1;\n+    }\n+}\n+\n /**\n  * Concatenate a vector of vectors.\n  *\n@@ -759,14 +780,17 @@ pub pure fn connect<T: Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n }\n \n /// Reduce a vector from left to right\n-pub pure fn foldl<T: Copy, U>(z: T, v: &[U], p: fn(t: T, u: &U) -> T) -> T {\n-    let mut accum = z;\n-    for each(v) |elt| {\n-        // it should be possible to move accum in, but the liveness analysis\n-        // is not smart enough.\n-        accum = p(accum, elt);\n+pub pure fn foldl<T, U>(z: T, v: &[U], p: fn(t: T, u: &U) -> T) -> T {\n+    let mut accum = move z;\n+    let mut i = 0;\n+    let l = v.len();\n+    while i < l {\n+        // Use a while loop so that liveness analysis can handle moving\n+        // the accumulator.\n+        accum = p(move accum, &v[i]);\n+        i += 1;\n     }\n-    return accum;\n+    return move accum;\n }\n \n /// Reduce a vector from right to left\n@@ -1293,13 +1317,24 @@ pure fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n     return true;\n }\n \n+#[cfg(stage0)]\n impl<T: Eq> &[T] : Eq {\n     #[inline(always)]\n     pure fn eq(other: & &[T]) -> bool { eq(self, (*other)) }\n     #[inline(always)]\n     pure fn ne(other: & &[T]) -> bool { !self.eq(other) }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T: Eq> &[T] : Eq {\n+    #[inline(always)]\n+    pure fn eq(other: & &self/[T]) -> bool { eq(self, (*other)) }\n+    #[inline(always)]\n+    pure fn ne(other: & &self/[T]) -> bool { !self.eq(other) }\n+}\n+\n+\n impl<T: Eq> ~[T] : Eq {\n     #[inline(always)]\n     pure fn eq(other: &~[T]) -> bool { eq(self, (*other)) }\n@@ -1335,6 +1370,7 @@ pure fn le<T: Ord>(a: &[T], b: &[T]) -> bool { !lt(b, a) }\n pure fn ge<T: Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n pure fn gt<T: Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n \n+#[cfg(stage0)]\n impl<T: Ord> &[T] : Ord {\n     #[inline(always)]\n     pure fn lt(other: & &[T]) -> bool { lt(self, (*other)) }\n@@ -1346,6 +1382,19 @@ impl<T: Ord> &[T] : Ord {\n     pure fn gt(other: & &[T]) -> bool { gt(self, (*other)) }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<T: Ord> &[T] : Ord {\n+    #[inline(always)]\n+    pure fn lt(other: & &self/[T]) -> bool { lt(self, (*other)) }\n+    #[inline(always)]\n+    pure fn le(other: & &self/[T]) -> bool { le(self, (*other)) }\n+    #[inline(always)]\n+    pure fn ge(other: & &self/[T]) -> bool { ge(self, (*other)) }\n+    #[inline(always)]\n+    pure fn gt(other: & &self/[T]) -> bool { gt(self, (*other)) }\n+}\n+\n impl<T: Ord> ~[T] : Ord {\n     #[inline(always)]\n     pure fn lt(other: &~[T]) -> bool { lt(self, (*other)) }\n@@ -1370,19 +1419,39 @@ impl<T: Ord> @[T] : Ord {\n \n #[cfg(notest)]\n pub mod traits {\n+    #[cfg(stage0)]\n     impl<T: Copy> ~[T] : Add<&[const T],~[T]> {\n         #[inline(always)]\n         pure fn add(rhs: & &[const T]) -> ~[T] {\n             append(copy self, (*rhs))\n         }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    impl<T: Copy> ~[T] : Add<&[const T],~[T]> {\n+        #[inline(always)]\n+        pure fn add(rhs: & &self/[const T]) -> ~[T] {\n+            append(copy self, (*rhs))\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     impl<T: Copy> ~[mut T] : Add<&[const T],~[mut T]> {\n         #[inline(always)]\n         pure fn add(rhs: & &[const T]) -> ~[mut T] {\n             append_mut(copy self, (*rhs))\n         }\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    impl<T: Copy> ~[mut T] : Add<&[const T],~[mut T]> {\n+        #[inline(always)]\n+        pure fn add(rhs: & &self/[const T]) -> ~[mut T] {\n+            append_mut(copy self, (*rhs))\n+        }\n+    }\n }\n \n #[cfg(test)]\n@@ -1590,6 +1659,7 @@ pub trait MutableVector<T> {\n     fn unshift(&mut self, x: T);\n     fn swap_remove(&mut self, index: uint) -> T;\n     fn truncate(&mut self, newlen: uint);\n+    fn retain(&mut self, f: pure fn(t: &T) -> bool);\n }\n \n pub trait MutableCopyableVector<T: Copy> {\n@@ -1631,6 +1701,10 @@ impl<T> ~[T]: MutableVector<T> {\n     fn truncate(&mut self, newlen: uint) {\n         truncate(self, newlen);\n     }\n+\n+    fn retain(&mut self, f: pure fn(t: &T) -> bool) {\n+        retain(self, f);\n+    }\n }\n \n impl<T: Copy> ~[T]: MutableCopyableVector<T> {"}, {"sha": "e69815379737ca5ac232fe1965664f66b4c6ef7a", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -147,7 +147,7 @@ fn enc_region(w: io::Writer, cx: @ctxt, r: ty::Region) {\n       ty::re_static => {\n         w.write_char('t');\n       }\n-      ty::re_var(_) => {\n+      ty::re_infer(_) => {\n         // these should not crop up after typeck\n         cx.diag.handler().bug(~\"Cannot encode region variables\");\n       }"}, {"sha": "e10966a6c22923b224f817d10852950505396fba", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -387,7 +387,7 @@ impl ty::Region: tr {\n             ty::re_bound(br) => ty::re_bound(br.tr(xcx)),\n             ty::re_free(id, br) => ty::re_free(xcx.tr_id(id), br.tr(xcx)),\n             ty::re_scope(id) => ty::re_scope(xcx.tr_id(id)),\n-            ty::re_static | ty::re_var(*) => self,\n+            ty::re_static | ty::re_infer(*) => self,\n         }\n     }\n }"}, {"sha": "089381d390446af081731d0502d49dbef05cc7d7", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -580,7 +580,7 @@ fn check_cast_for_escaping_regions(\n     match target_substs.self_r {\n       Some(ty::re_scope(*)) => { return; /* case (1) */ }\n       None | Some(ty::re_static) | Some(ty::re_free(*)) => {}\n-      Some(ty::re_bound(*)) | Some(ty::re_var(*)) => {\n+      Some(ty::re_bound(*)) | Some(ty::re_infer(*)) => {\n         cx.tcx.sess.span_bug(\n             source.span,\n             fmt!(\"bad region found in kind: %?\", target_substs.self_r));"}, {"sha": "415cd12536c05cc6baf0f3d76744d0364b127cd1", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -112,18 +112,18 @@ fn is_subregion_of(region_map: region_map,\n                    super_region: ty::Region) -> bool {\n     sub_region == super_region ||\n         match (sub_region, super_region) {\n-          (_, ty::re_static) => {\n-            true\n-          }\n+            (_, ty::re_static) => {\n+                true\n+            }\n \n-          (ty::re_scope(sub_scope), ty::re_scope(super_scope)) |\n-          (ty::re_scope(sub_scope), ty::re_free(super_scope, _)) => {\n-            scope_contains(region_map, super_scope, sub_scope)\n-          }\n+            (ty::re_scope(sub_scope), ty::re_scope(super_scope)) |\n+            (ty::re_scope(sub_scope), ty::re_free(super_scope, _)) => {\n+                scope_contains(region_map, super_scope, sub_scope)\n+            }\n \n-          _ => {\n-            false\n-          }\n+            _ => {\n+                false\n+            }\n         }\n }\n "}, {"sha": "2daf40dbf841f329d7a6429cbf7f89c296c95a36", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 150, "deletions": 91, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -12,7 +12,7 @@ use syntax::ast_util::{is_local, local_def};\n use syntax::codemap::span;\n use metadata::csearch;\n use util::ppaux::{region_to_str, explain_region, vstore_to_str,\n-                  note_and_explain_region};\n+                  note_and_explain_region, bound_region_to_str};\n use middle::lint;\n use middle::lint::{get_lint_level, allow};\n use syntax::ast::*;\n@@ -107,7 +107,8 @@ export InferTy, TyVar, IntVar;\n export ty_self, mk_self, type_has_self;\n export ty_class;\n export Region, bound_region, encl_region;\n-export re_bound, re_free, re_scope, re_static, re_var;\n+export re_bound, re_free, re_scope, re_static, re_infer;\n+export ReVar, ReSkolemized;\n export br_self, br_anon, br_named, br_cap_avoid;\n export get, type_has_params, type_needs_infer, type_has_regions;\n export type_is_region_ptr;\n@@ -179,6 +180,8 @@ export terr_in_field, terr_record_fields, terr_vstores_differ, terr_arg_count;\n export terr_sorts, terr_vec, terr_str, terr_record_size, terr_tuple_size;\n export terr_regions_does_not_outlive, terr_mutability, terr_purity_mismatch;\n export terr_regions_not_same, terr_regions_no_overlap;\n+export terr_regions_insufficiently_polymorphic;\n+export terr_regions_overly_polymorphic;\n export terr_proto_mismatch;\n export terr_ret_style_mismatch;\n export terr_fn, terr_trait;\n@@ -555,7 +558,7 @@ enum Region {\n     re_static,\n \n     /// A region variable.  Should not exist after typeck.\n-    re_var(RegionVid)\n+    re_infer(InferRegion)\n }\n \n #[auto_serialize]\n@@ -671,6 +674,8 @@ enum type_err {\n     terr_regions_does_not_outlive(Region, Region),\n     terr_regions_not_same(Region, Region),\n     terr_regions_no_overlap(Region, Region),\n+    terr_regions_insufficiently_polymorphic(bound_region, Region),\n+    terr_regions_overly_polymorphic(bound_region, Region),\n     terr_vstores_differ(terr_vstore_kind, expected_found<vstore>),\n     terr_in_field(@type_err, ast::ident),\n     terr_sorts(expected_found<t>),\n@@ -707,6 +712,39 @@ impl InferTy : to_bytes::IterBytes {\n     }\n }\n \n+#[auto_serialize]\n+#[auto_deserialize]\n+enum InferRegion {\n+    ReVar(RegionVid),\n+    ReSkolemized(uint, bound_region)\n+}\n+\n+impl InferRegion : to_bytes::IterBytes {\n+    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n+        match self {\n+            ReVar(ref rv) => to_bytes::iter_bytes_2(&0u8, rv, lsb0, f),\n+            ReSkolemized(ref v, _) => to_bytes::iter_bytes_2(&1u8, v, lsb0, f)\n+        }\n+    }\n+}\n+\n+impl InferRegion : cmp::Eq {\n+    pure fn eq(other: &InferRegion) -> bool {\n+        match (self, *other) {\n+            (ReVar(rva), ReVar(rvb)) => {\n+                rva == rvb\n+            }\n+            (ReSkolemized(rva, _), ReSkolemized(rvb, _)) => {\n+                rva == rvb\n+            }\n+            _ => false\n+        }\n+    }\n+    pure fn ne(other: &InferRegion) -> bool {\n+        !(self == (*other))\n+    }\n+}\n+\n impl param_bound : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n@@ -923,7 +961,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n     fn rflags(r: Region) -> uint {\n         (has_regions as uint) | {\n             match r {\n-              ty::re_var(_) => needs_infer as uint,\n+              ty::re_infer(_) => needs_infer as uint,\n               _ => 0u\n             }\n         }\n@@ -2591,7 +2629,7 @@ impl Region : to_bytes::IterBytes {\n           re_scope(ref id) =>\n           to_bytes::iter_bytes_2(&2u8, id, lsb0, f),\n \n-          re_var(ref id) =>\n+          re_infer(ref id) =>\n           to_bytes::iter_bytes_2(&3u8, id, lsb0, f),\n \n           re_static => 4u8.iter_bytes(lsb0, f)\n@@ -3253,92 +3291,103 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n     }\n \n     match *err {\n-      terr_mismatch => ~\"types differ\",\n-      terr_ret_style_mismatch(values) => {\n-        fn to_str(s: ast::ret_style) -> ~str {\n-            match s {\n-              ast::noreturn => ~\"non-returning\",\n-              ast::return_val => ~\"return-by-value\"\n+        terr_mismatch => ~\"types differ\",\n+        terr_ret_style_mismatch(values) => {\n+            fn to_str(s: ast::ret_style) -> ~str {\n+                match s {\n+                    ast::noreturn => ~\"non-returning\",\n+                    ast::return_val => ~\"return-by-value\"\n+                }\n             }\n+            fmt!(\"expected %s function, found %s function\",\n+                 to_str(values.expected),\n+                 to_str(values.expected))\n+        }\n+        terr_purity_mismatch(values) => {\n+            fmt!(\"expected %s fn but found %s fn\",\n+                 purity_to_str(values.expected),\n+                 purity_to_str(values.found))\n+        }\n+        terr_proto_mismatch(values) => {\n+            fmt!(\"expected %s closure, found %s closure\",\n+                 proto_ty_to_str(cx, values.expected),\n+                 proto_ty_to_str(cx, values.found))\n+        }\n+        terr_mutability => ~\"values differ in mutability\",\n+        terr_box_mutability => ~\"boxed values differ in mutability\",\n+        terr_vec_mutability => ~\"vectors differ in mutability\",\n+        terr_ptr_mutability => ~\"pointers differ in mutability\",\n+        terr_ref_mutability => ~\"references differ in mutability\",\n+        terr_ty_param_size(values) => {\n+            fmt!(\"expected a type with %? type params \\\n+                  but found one with %? type params\",\n+                 values.expected, values.found)\n+        }\n+        terr_tuple_size(values) => {\n+            fmt!(\"expected a tuple with %? elements \\\n+                  but found one with %? elements\",\n+                 values.expected, values.found)\n+        }\n+        terr_record_size(values) => {\n+            fmt!(\"expected a record with %? fields \\\n+                  but found one with %? fields\",\n+                 values.expected, values.found)\n+        }\n+        terr_record_mutability => {\n+            ~\"record elements differ in mutability\"\n+        }\n+        terr_record_fields(values) => {\n+            fmt!(\"expected a record with field `%s` but found one with field \\\n+                  `%s`\",\n+                 cx.sess.str_of(values.expected),\n+                 cx.sess.str_of(values.found))\n+        }\n+        terr_arg_count => ~\"incorrect number of function parameters\",\n+        terr_mode_mismatch(values) => {\n+            fmt!(\"expected argument mode %s, but found %s\",\n+                 mode_to_str(values.expected), mode_to_str(values.found))\n+        }\n+        terr_regions_does_not_outlive(*) => {\n+            fmt!(\"lifetime mismatch\")\n+        }\n+        terr_regions_not_same(*) => {\n+            fmt!(\"lifetimes are not the same\")\n+        }\n+        terr_regions_no_overlap(*) => {\n+            fmt!(\"lifetimes do not intersect\")\n+        }\n+        terr_regions_insufficiently_polymorphic(br, _) => {\n+            fmt!(\"expected bound lifetime parameter %s, \\\n+                  but found concrete lifetime\",\n+                 bound_region_to_str(cx, br))\n+        }\n+        terr_regions_overly_polymorphic(br, _) => {\n+            fmt!(\"expected concrete lifetime, \\\n+                  but found bound lifetime parameter %s\",\n+                 bound_region_to_str(cx, br))\n+        }\n+        terr_vstores_differ(k, values) => {\n+            fmt!(\"%s storage differs: expected %s but found %s\",\n+                 terr_vstore_kind_to_str(k),\n+                 vstore_to_str(cx, values.expected),\n+                 vstore_to_str(cx, values.found))\n+        }\n+        terr_in_field(err, fname) => {\n+            fmt!(\"in field `%s`, %s\", cx.sess.str_of(fname),\n+                 type_err_to_str(cx, err))\n+        }\n+        terr_sorts(values) => {\n+            fmt!(\"expected %s but found %s\",\n+                 ty_sort_str(cx, values.expected),\n+                 ty_sort_str(cx, values.found))\n+        }\n+        terr_self_substs => {\n+            ~\"inconsistent self substitution\" // XXX this is more of a bug\n+        }\n+        terr_no_integral_type => {\n+            ~\"couldn't determine an appropriate integral type for integer \\\n+              literal\"\n         }\n-        fmt!(\"expected %s function, found %s function\",\n-                    to_str(values.expected),\n-                    to_str(values.expected))\n-      }\n-      terr_purity_mismatch(values) => {\n-        fmt!(\"expected %s fn but found %s fn\",\n-                    purity_to_str(values.expected),\n-                    purity_to_str(values.found))\n-      }\n-      terr_proto_mismatch(values) => {\n-        fmt!(\"expected %s closure, found %s closure\",\n-             proto_ty_to_str(cx, values.expected),\n-             proto_ty_to_str(cx, values.found))\n-      }\n-      terr_mutability => ~\"values differ in mutability\",\n-      terr_box_mutability => ~\"boxed values differ in mutability\",\n-      terr_vec_mutability => ~\"vectors differ in mutability\",\n-      terr_ptr_mutability => ~\"pointers differ in mutability\",\n-      terr_ref_mutability => ~\"references differ in mutability\",\n-      terr_ty_param_size(values) => {\n-        fmt!(\"expected a type with %? type params \\\n-              but found one with %? type params\",\n-             values.expected, values.found)\n-      }\n-      terr_tuple_size(values) => {\n-        fmt!(\"expected a tuple with %? elements \\\n-              but found one with %? elements\",\n-             values.expected, values.found)\n-      }\n-      terr_record_size(values) => {\n-        fmt!(\"expected a record with %? fields \\\n-              but found one with %? fields\",\n-             values.expected, values.found)\n-      }\n-      terr_record_mutability => {\n-        ~\"record elements differ in mutability\"\n-      }\n-      terr_record_fields(values) => {\n-        fmt!(\"expected a record with field `%s` but found one with field \\\n-              `%s`\",\n-             cx.sess.str_of(values.expected), cx.sess.str_of(values.found))\n-      }\n-      terr_arg_count => ~\"incorrect number of function parameters\",\n-      terr_mode_mismatch(values) => {\n-        fmt!(\"expected argument mode %s, but found %s\",\n-             mode_to_str(values.expected), mode_to_str(values.found))\n-      }\n-      terr_regions_does_not_outlive(*) => {\n-        fmt!(\"lifetime mismatch\")\n-      }\n-      terr_regions_not_same(*) => {\n-        fmt!(\"lifetimes are not the same\")\n-      }\n-      terr_regions_no_overlap(*) => {\n-        fmt!(\"lifetimes do not intersect\")\n-      }\n-      terr_vstores_differ(k, values) => {\n-        fmt!(\"%s storage differs: expected %s but found %s\",\n-                    terr_vstore_kind_to_str(k),\n-                    vstore_to_str(cx, values.expected),\n-                    vstore_to_str(cx, values.found))\n-      }\n-      terr_in_field(err, fname) => {\n-        fmt!(\"in field `%s`, %s\", cx.sess.str_of(fname),\n-             type_err_to_str(cx, err))\n-      }\n-      terr_sorts(values) => {\n-        fmt!(\"expected %s but found %s\",\n-                    ty_sort_str(cx, values.expected),\n-                    ty_sort_str(cx, values.found))\n-      }\n-      terr_self_substs => {\n-        ~\"inconsistent self substitution\" // XXX this is more of a bug\n-      }\n-      terr_no_integral_type => {\n-        ~\"couldn't determine an appropriate integral type for integer \\\n-          literal\"\n-      }\n     }\n }\n \n@@ -3359,6 +3408,16 @@ fn note_and_explain_type_err(cx: ctxt, err: &type_err) {\n             note_and_explain_region(cx, ~\"...does not overlap \",\n                                     region2, ~\"\");\n         }\n+        terr_regions_insufficiently_polymorphic(_, conc_region) => {\n+            note_and_explain_region(cx,\n+                                    ~\"concrete lifetime that was found is \",\n+                                    conc_region, ~\"\");\n+        }\n+        terr_regions_overly_polymorphic(_, conc_region) => {\n+            note_and_explain_region(cx,\n+                                    ~\"expected concrete lifetime is \",\n+                                    conc_region, ~\"\");\n+        }\n         _ => {}\n     }\n }\n@@ -4182,9 +4241,9 @@ impl Region : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            re_var(e0a) => {\n+            re_infer(e0a) => {\n                 match (*other) {\n-                    re_var(e0b) => e0a == e0b,\n+                    re_infer(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }"}, {"sha": "d163dd4b3cfa6f221ebb0076d2801e937e487858", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -97,7 +97,7 @@ fn replace_bound_regions_in_fn_ty(\n                       r: ty::Region) -> isr_alist {\n             match r {\n               ty::re_free(_, _) | ty::re_static | ty::re_scope(_) |\n-              ty::re_var(_) => {\n+              ty::re_infer(_) => {\n                 isr\n               }\n               ty::re_bound(br) => {\n@@ -165,7 +165,7 @@ fn replace_bound_regions_in_fn_ty(\n               ty::re_static |\n               ty::re_scope(_) |\n               ty::re_free(_, _) |\n-              ty::re_var(_) => r\n+              ty::re_infer(_) => r\n             }\n         }\n     }"}, {"sha": "6a11cccd5d7627e0185f8f0831e3567e8142cca7", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 102, "deletions": 64, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -272,46 +272,60 @@ fn ensure_supertraits(ccx: @crate_ctxt,\n  *\n  * - impl_m: the method in the impl\n  * - impl_tps: the type params declared on the impl itself (not the method!)\n+ * - impl_body_id: the id of the method body from the impl\n  * - trait_m: the method in the trait\n  * - trait_substs: the substitutions used on the type of the trait\n  * - self_ty: the self type of the impl\n  */\n-fn compare_impl_method(tcx: ty::ctxt, sp: span,\n-                       impl_m: ty::method, impl_tps: uint,\n-                       trait_m: ty::method, trait_substs: ty::substs,\n-                       self_ty: ty::t) {\n+fn compare_impl_method(tcx: ty::ctxt,\n+                       impl_tps: uint,\n+                       cm: &ConvertedMethod,\n+                       trait_m: &ty::method,\n+                       trait_substs: &ty::substs,\n+                       self_ty: ty::t)\n+{\n+    debug!(\"compare_impl_method()\");\n+    let _indenter = indenter();\n+\n+    let impl_m = &cm.mty;\n \n     if impl_m.fty.meta.purity != trait_m.fty.meta.purity {\n         tcx.sess.span_err(\n-            sp, fmt!(\"method `%s`'s purity does \\\n-                          not match the trait method's \\\n-                          purity\", tcx.sess.str_of(impl_m.ident)));\n+            cm.span,\n+            fmt!(\"method `%s`'s purity does \\\n+                  not match the trait method's \\\n+                  purity\", tcx.sess.str_of(impl_m.ident)));\n     }\n \n     // is this check right?\n     if impl_m.self_ty != trait_m.self_ty {\n         tcx.sess.span_err(\n-            sp, fmt!(\"method `%s`'s self type does \\\n-                          not match the trait method's \\\n-                          self type\", tcx.sess.str_of(impl_m.ident)));\n+            cm.span,\n+            fmt!(\"method `%s`'s self type does \\\n+                  not match the trait method's \\\n+                  self type\", tcx.sess.str_of(impl_m.ident)));\n     }\n \n     if impl_m.tps.len() != trait_m.tps.len() {\n-        tcx.sess.span_err(sp, fmt!(\"method `%s` \\\n-           has %u type %s, but its trait declaration has %u type %s\",\n-           tcx.sess.str_of(trait_m.ident), impl_m.tps.len(),\n-           pluralize(impl_m.tps.len(), ~\"parameter\"),\n-           trait_m.tps.len(),\n-           pluralize(trait_m.tps.len(), ~\"parameter\")));\n+        tcx.sess.span_err(\n+            cm.span,\n+            fmt!(\"method `%s` has %u type %s, but its trait \\\n+                  declaration has %u type %s\",\n+                 tcx.sess.str_of(trait_m.ident), impl_m.tps.len(),\n+                 pluralize(impl_m.tps.len(), ~\"parameter\"),\n+                 trait_m.tps.len(),\n+                 pluralize(trait_m.tps.len(), ~\"parameter\")));\n         return;\n     }\n \n     if vec::len(impl_m.fty.sig.inputs) != vec::len(trait_m.fty.sig.inputs) {\n-        tcx.sess.span_err(sp,fmt!(\"method `%s` has %u parameters \\\n-                                   but the trait has %u\",\n-                                   tcx.sess.str_of(trait_m.ident),\n-                                   vec::len(impl_m.fty.sig.inputs),\n-                                   vec::len(trait_m.fty.sig.inputs)));\n+        tcx.sess.span_err(\n+            cm.span,\n+            fmt!(\"method `%s` has %u parameters \\\n+                  but the trait has %u\",\n+                 tcx.sess.str_of(trait_m.ident),\n+                 vec::len(impl_m.fty.sig.inputs),\n+                 vec::len(trait_m.fty.sig.inputs)));\n         return;\n     }\n \n@@ -322,50 +336,68 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n         // Would be nice to use the ty param names in the error message,\n         // but we don't have easy access to them here\n         if impl_param_bounds.len() != trait_param_bounds.len() {\n-           tcx.sess.span_err(sp, fmt!(\"in method `%s`, \\\n-             type parameter %u has %u %s, but the same type \\\n-             parameter in its trait declaration has %u %s\",\n-             tcx.sess.str_of(trait_m.ident),\n-             i, impl_param_bounds.len(),\n-             pluralize(impl_param_bounds.len(), ~\"bound\"),\n-             trait_param_bounds.len(),\n-             pluralize(trait_param_bounds.len(), ~\"bound\")));\n+           tcx.sess.span_err(\n+               cm.span,\n+               fmt!(\"in method `%s`, \\\n+                     type parameter %u has %u %s, but the same type \\\n+                     parameter in its trait declaration has %u %s\",\n+                    tcx.sess.str_of(trait_m.ident),\n+                    i, impl_param_bounds.len(),\n+                    pluralize(impl_param_bounds.len(), ~\"bound\"),\n+                    trait_param_bounds.len(),\n+                    pluralize(trait_param_bounds.len(), ~\"bound\")));\n            return;\n         }\n         // tjc: I'm mildly worried that there's something I'm\n         // not checking that require_same_types doesn't catch,\n         // but I can't figure out what.\n     }\n \n+    // Replace any references to the self region in the self type with\n+    // a free region.  So, for example, if the impl type is\n+    // \"&self/str\", then this would replace the self type with a free\n+    // region `self`.\n+    //\n+    // Note: Ideal would be to use the node-id of the method body here,\n+    // not the node id of the method itself.\n+    let dummy_self_r = ty::re_free(cm.body_id, ty::br_self);\n+    let self_ty = replace_bound_self(tcx, self_ty, dummy_self_r);\n+\n     // Perform substitutions so that the trait/impl methods are expressed\n     // in terms of the same set of type/region parameters:\n-    // - replace trait type parameters with those from `trait_substs`\n+    // - replace trait type parameters with those from `trait_substs`,\n+    //   except with any reference to bound self replaced with `dummy_self_r`\n     // - replace method parameters on the trait with fresh, dummy parameters\n     //   that correspond to the parameters we will find on the impl\n     // - replace self region with a fresh, dummy region\n-    let dummy_self_r = ty::re_free(0, ty::br_self);\n     let impl_fty = {\n         let impl_fty = ty::mk_fn(tcx, impl_m.fty);\n+        debug!(\"impl_fty (pre-subst): %s\", ty_to_str(tcx, impl_fty));\n         replace_bound_self(tcx, impl_fty, dummy_self_r)\n     };\n+    debug!(\"impl_fty: %s\", ty_to_str(tcx, impl_fty));\n     let trait_fty = {\n         let dummy_tps = do vec::from_fn((*trait_m.tps).len()) |i| {\n             // hack: we don't know the def id of the impl tp, but it\n             // is not important for unification\n             ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n         };\n+        let trait_tps = trait_substs.tps.map(\n+            |t| replace_bound_self(tcx, *t, dummy_self_r));\n         let substs = {\n             self_r: Some(dummy_self_r),\n             self_ty: Some(self_ty),\n-            tps: vec::append(trait_substs.tps, dummy_tps)\n+            tps: vec::append(trait_tps, dummy_tps)\n         };\n         let trait_fty = ty::mk_fn(tcx, trait_m.fty);\n+        debug!(\"trait_fty (pre-subst): %s\", ty_to_str(tcx, trait_fty));\n         ty::subst(tcx, &substs, trait_fty)\n     };\n+    debug!(\"trait_fty: %s\", ty_to_str(tcx, trait_fty));\n     require_same_types(\n-        tcx, None, false, sp, impl_fty, trait_fty,\n-        || ~\"method `\" + tcx.sess.str_of(trait_m.ident)\n-           + ~\"` has an incompatible type\");\n+        tcx, None, false, cm.span, impl_fty, trait_fty,\n+        || fmt!(\"method `%s` has an incompatible type\",\n+                tcx.sess.str_of(trait_m.ident)));\n     return;\n \n     // Replaces bound references to the self region with `with_r`.\n@@ -382,7 +414,7 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n                                rp: Option<ty::region_variance>,\n                                selfty: ty::t,\n                                a_trait_ty: @ast::trait_ref,\n-                               impl_ms: ~[converted_method]) {\n+                               impl_ms: ~[ConvertedMethod]) {\n \n     let tcx = ccx.tcx;\n     let (did, tpt) = instantiate_trait_ref(ccx, a_trait_ty, rp);\n@@ -391,32 +423,32 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n     }\n     for vec::each(*ty::trait_methods(tcx, did)) |trait_m| {\n         match vec::find(impl_ms, |impl_m| trait_m.ident == impl_m.mty.ident) {\n-          Some({mty: impl_m, span, _}) => {\n-            compare_impl_method(\n-                ccx.tcx, span, impl_m, vec::len(tps),\n-                *trait_m, tpt.substs, selfty);\n-          }\n-          None => {\n-              // If we couldn't find an implementation for trait_m in\n-              // the impl, then see if there was a default\n-              // implementation in the trait itself.  If not, raise a\n-              // \"missing method\" error.\n-\n-              let provided_methods = ty::provided_trait_methods(tcx, did);\n-              match vec::find(provided_methods, |provided_method|\n-                              *provided_method == trait_m.ident) {\n-                Some(_) => {\n-                    // If there's a provided method with the name we\n-                    // want, then we're fine; nothing else to do.\n-                }\n-                None => {\n-                    tcx.sess.span_err(\n-                        a_trait_ty.path.span,\n-                        fmt!(\"missing method `%s`\",\n-                             tcx.sess.str_of(trait_m.ident)));\n+            Some(ref cm) => {\n+                compare_impl_method(\n+                    ccx.tcx, vec::len(tps), cm, trait_m,\n+                    &tpt.substs, selfty);\n+            }\n+            None => {\n+                // If we couldn't find an implementation for trait_m in\n+                // the impl, then see if there was a default\n+                // implementation in the trait itself.  If not, raise a\n+                // \"missing method\" error.\n+\n+                let provided_methods = ty::provided_trait_methods(tcx, did);\n+                match vec::find(provided_methods, |provided_method|\n+                                *provided_method == trait_m.ident) {\n+                    Some(_) => {\n+                        // If there's a provided method with the name we\n+                        // want, then we're fine; nothing else to do.\n+                    }\n+                    None => {\n+                        tcx.sess.span_err(\n+                            a_trait_ty.path.span,\n+                            fmt!(\"missing method `%s`\",\n+                                 tcx.sess.str_of(trait_m.ident)));\n+                    }\n                 }\n-              }\n-          }\n+            }\n         } // match\n     } // |trait_m|\n } // fn\n@@ -434,12 +466,17 @@ fn convert_field(ccx: @crate_ctxt,\n                            ty: tt});\n }\n \n-type converted_method = {mty: ty::method, id: ast::node_id, span: span};\n+struct ConvertedMethod {\n+    mty: ty::method,\n+    id: ast::node_id,\n+    span: span,\n+    body_id: ast::node_id\n+}\n \n fn convert_methods(ccx: @crate_ctxt,\n                    ms: ~[@ast::method],\n                    rp: Option<ty::region_variance>,\n-                   rcvr_bounds: @~[ty::param_bounds]) -> ~[converted_method] {\n+                   rcvr_bounds: @~[ty::param_bounds]) -> ~[ConvertedMethod] {\n \n     let tcx = ccx.tcx;\n     do vec::map(ms) |m| {\n@@ -455,7 +492,8 @@ fn convert_methods(ccx: @crate_ctxt,\n              region_param: rp,\n              ty: fty});\n         write_ty_to_tcx(tcx, m.id, fty);\n-        {mty: mty, id: m.id, span: m.span}\n+        ConvertedMethod {mty: mty, id: m.id,\n+                         span: m.span, body_id: m.body.node.id}\n     }\n }\n "}, {"sha": "61dc10ee09e05d935cb46e335a1b2e78414df29e", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -262,7 +262,7 @@ use util::common::{indent, indenter};\n use ast::{unsafe_fn, impure_fn, pure_fn, extern_fn};\n use ast::{m_const, m_imm, m_mutbl};\n use dvec::DVec;\n-use region_var_bindings::{RegionVarBindings};\n+use region_inference::{RegionVarBindings};\n use ast_util::dummy_sp;\n use cmp::Eq;\n \n@@ -628,7 +628,7 @@ impl infer_ctxt {\n     }\n \n     fn next_region_var_nb(span: span) -> ty::Region {\n-        ty::re_var(self.region_vars.new_region_var(span))\n+        ty::re_infer(ty::ReVar(self.region_vars.new_region_var(span)))\n     }\n \n     fn next_region_var_with_lb(span: span,"}, {"sha": "faac3d9ac55c46b6a2a51496a43e5b97644f33c0", "filename": "src/rustc/middle/typeck/infer/macros.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -0,0 +1,12 @@\n+{\n+\n+macro_rules! if_ok(\n+    ($inp: expr) => (\n+        match $inp {\n+            Ok(move v) => { move v }\n+            Err(move e) => { return Err(e); }\n+        }\n+    )\n+);\n+\n+}\n\\ No newline at end of file"}, {"sha": "bdc764a8d0b098f604b2573428de0ced66b49c5e", "filename": "src/rustc/middle/typeck/infer/region_inference.rs", "status": "renamed", "additions": 343, "deletions": 200, "changes": 543, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -134,45 +134,66 @@ to read the whole thing):\n \n http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n \n-NOTE--for the most part, we do not yet handle these cases correctly!\n+Although my explanation will never compete with SPJ's (for one thing,\n+his is approximately 100 pages), I will attempt to explain the basic\n+problem and also how we solve it.  Note that the paper only discusses\n+subtyping, not the computation of LUB/GLB.\n \n-## Subtyping and bound regions\n+The problem we are addressing is that there is a kind of subtyping\n+between functions with bound region parameters.  Consider, for\n+example, whether the following relation holds:\n \n-### Simple examples\n+    fn(&a/int) <: fn(&b/int)? (Yes, a => b)\n \n-The situation is well-summarized by these examples (here I am omitting\n-the types as they are not interesting, and I am writing binding\n-explicitly):\n+The answer is that of course it does.  These two types are basically\n+the same, except that in one we used the name `a` and one we used\n+the name `b`.\n \n-    1. fn<a>(&a/T) <: fn<b>(&b/T)?        Yes: a -> b\n-    2. fn<a>(&a/T) <: fn(&b/T)?           Yes: a -> b\n-    3. fn(&a/T)    <: fn<b>(&b/T)?        No!\n-    4. fn(&a/T)    <: fn(&b/T)?           No!\n-    5. fn(&a/T)    <: fn(&a)?           Yes!\n-\n-In case one, the two function types are equivalent because both\n-reference a bound region, just with different names.\n-\n-In case two, the subtyping relationship is valid because the subtyping\n-function accepts a pointer in *any* region, whereas the supertype\n-function accepts a pointer *only in the region `b`*.  Therefore, it is\n-safe to use the subtype wherever the supertype is expected, as the\n-supertype can only be passed pointers in region `b`, and the subtype\n-can handle `b` (but also others).\n-\n-Case three is the opposite: here the subtype requires the region `a`,\n-but the supertype must accept pointers in any region.  That means that\n-it is not safe to use the subtype where the supertype is expected: the\n-supertype can be passed pointers in any region, but the subtype can\n-only handle pointers in the region `a`.\n-\n-Case four is fairly simple.  The subtype expects region `a` but the supertype\n-expects region `b`.  These two regions are not the same.  Therefore, not\n-a subtype.\n-\n-Case five is similar to four, except that the subtype and supertype\n-expect the same region, so in fact they are the same type.  That's\n-fine.\n+In the examples that follow, it becomes very important to know whether\n+a lifetime is bound in a function type (that is, is a lifetime\n+parameter) or appears free (is defined in some outer scope).\n+Therefore, from now on I will write the bindings explicitly, using a\n+notation like `fn<a>(&a/int)` to indicate that `a` is a lifetime\n+parameter.\n+\n+Now let's consider two more function types.  Here, we assume that the\n+`self` lifetime is defined somewhere outside and hence is not a\n+lifetime parameter bound by the function type (it \"appears free\"):\n+\n+    fn<a>(&a/int) <: fn(&self/int)? (Yes, a => self)\n+\n+This subtyping relation does in fact hold.  To see why, you have to\n+consider what subtyping means.  One way to look at `T1 <: T2` is to\n+say that it means that it is always ok to treat an instance of `T1` as\n+if it had the type `T2`.  So, with our functions, it is always ok to\n+treat a function that can take pointers with any lifetime as if it\n+were a function that can only take a pointer with the specific\n+lifetime `&self`.  After all, `&self` is a lifetime, after all, and\n+the function can take values of any lifetime.\n+\n+You can also look at subtyping as the *is a* relationship.  This amounts\n+to the same thing: a function that accepts pointers with any lifetime\n+*is a* function that accepts pointers with some specific lifetime.\n+\n+So, what if we reverse the order of the two function types, like this:\n+\n+    fn(&self/int) <: fn<a>(&a/int)? (No)\n+\n+Does the subtyping relationship still hold?  The answer of course is\n+no.  In this case, the function accepts *only the lifetime `&self`*,\n+so it is not reasonable to treat it as if it were a function that\n+accepted any lifetime.\n+\n+What about these two examples:\n+\n+    fn<a,b>(&a/int, &b/int) <: fn<a>(&a/int, &a/int)? (Yes)\n+    fn<a>(&a/int, &a/int) <: fn<a,b>(&a/int, &b/int)? (No)\n+\n+Here, it is true that functions which take two pointers with any two\n+lifetimes can be treated as if they only accepted two pointers with\n+the same lifetime, but not the reverse.\n+\n+## The algorithm\n \n Here is the algorithm we use to perform the subtyping check:\n \n@@ -184,15 +205,13 @@ Here is the algorithm we use to perform the subtyping check:\n 4. Ensure that no skolemized regions 'leak' into region variables\n    visible from \"the outside\"\n \n-I'll walk briefly through how this works with the examples above.\n-I'll ignore the last step for now, it'll come up in the complex\n-examples below.\n+Let's walk through some examples and see how this algorithm plays out.\n \n #### First example\n \n-Let's look first at the first example, which was:\n+We'll start with the first example, which was:\n \n-    1. fn<a>(&a/T) <: fn<b>(&b/T/T)?        Yes: a -> x\n+    1. fn<a>(&a/T) <: fn<b>(&b/T)?        Yes: a -> b\n \n After steps 1 and 2 of the algorithm we will have replaced the types\n like so:\n@@ -204,7 +223,7 @@ region whose value is being inferred by the system.  I also replaced\n `&b` with `&x`---I'll use letters late in the alphabet (`x`, `y`, `z`)\n to indicate skolemized region names.  We can assume they don't appear\n elsewhere.  Note that neither the sub- nor the supertype bind any\n-region names anymore (that is, the `<a>` and `<b>` have been removed).\n+region names anymore (as indicated by the absence of `<` and `>`).\n \n The next step is to check that the parameter types match.  Because\n parameters are contravariant, this means that we check whether:\n@@ -226,25 +245,25 @@ So far we have encountered no error, so the subtype check succeeds.\n \n Now let's look first at the third example, which was:\n \n-    3. fn(&a/T)    <: fn<b>(&b/T)?        No!\n+    3. fn(&self/T)    <: fn<b>(&b/T)?        No!\n \n After steps 1 and 2 of the algorithm we will have replaced the types\n like so:\n \n-    3. fn(&a/T) <: fn(&x/T)?\n+    3. fn(&self/T) <: fn(&x/T)?\n \n-This looks pretty much the same as before, except that on the LHS `&a`\n-was not bound, and hence was left as-is and not replaced with a\n-variable.  The next step is again to check that the parameter types\n-match.  This will ultimately require (as before) that `&a` <= `&x`\n-must hold: but this does not hold.  `a` and `x` are both distinct free\n-regions.  So the subtype check fails.\n+This looks pretty much the same as before, except that on the LHS\n+`&self` was not bound, and hence was left as-is and not replaced with\n+a variable.  The next step is again to check that the parameter types\n+match.  This will ultimately require (as before) that `&self` <= `&x`\n+must hold: but this does not hold.  `self` and `x` are both distinct\n+free regions.  So the subtype check fails.\n \n #### Checking for skolemization leaks\n \n-You may be wondering about that mysterious last step.  So far it has not\n-been relevant.  The purpose of that last step is to catch something like\n-*this*:\n+You may be wondering about that mysterious last step in the algorithm.\n+So far it has not been relevant.  The purpose of that last step is to\n+catch something like *this*:\n \n     fn<a>() -> fn(&a/T) <: fn() -> fn<b>(&b/T)?   No.\n \n@@ -295,10 +314,11 @@ rule.\n \n So the way we solve this is to add a fourth step that examines the\n constraints that refer to skolemized names.  Basically, consider a\n-non-directed verison of the constraint graph.  The only things\n-reachable from a skolemized region ought to be the region variables\n-that were created at the same time.  So this case here would fail\n-because `&x` was created alone, but is relatable to `&A`.\n+non-directed verison of the constraint graph.  Let `Tainted(x)` be the\n+set of all things reachable from a skolemized variable `x`.\n+`Tainted(x)` should not contain any regions that existed before the\n+step at which the skolemization was performed.  So this case here\n+would fail because `&x` was created alone, but is relatable to `&A`.\n \n */\n \n@@ -313,7 +333,8 @@ use std::cell::{Cell, empty_cell};\n use std::list::{List, Nil, Cons};\n \n use region::is_subregion_of;\n-use ty::{Region, RegionVid};\n+use ty::{Region, RegionVid, re_static, re_infer, re_free, re_bound,\n+         re_scope, ReVar, ReSkolemized};\n use syntax::codemap;\n use to_str::ToStr;\n use util::ppaux::note_and_explain_region;\n@@ -350,7 +371,7 @@ impl Constraint : cmp::Eq {\n }\n \n impl Constraint : to_bytes::IterBytes {\n-   pure  fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n+   pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n           ConstrainVarSubVar(ref v0, ref v1) =>\n           to_bytes::iter_bytes_3(&0u8, v0, v1, lsb0, f),\n@@ -394,10 +415,11 @@ type CombineMap = HashMap<TwoRegions, RegionVid>;\n struct RegionVarBindings {\n     tcx: ty::ctxt,\n     var_spans: DVec<span>,\n-    values: Cell<~[ty::Region]>,\n+    values: Cell<~[Region]>,\n     constraints: HashMap<Constraint, span>,\n     lubs: CombineMap,\n     glbs: CombineMap,\n+    mut skolemization_count: uint,\n \n     // The undo log records actions that might later be undone.\n     //\n@@ -407,7 +429,7 @@ struct RegionVarBindings {\n     // actively snapshotting.  The reason for this is that otherwise\n     // we end up adding entries for things like the lower bound on\n     // a variable and so forth, which can never be rolled back.\n-    undo_log: DVec<UndoLogEntry>\n+    mut undo_log: ~[UndoLogEntry]\n }\n \n fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n@@ -418,7 +440,8 @@ fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n         constraints: HashMap(),\n         lubs: CombineMap(),\n         glbs: CombineMap(),\n-        undo_log: DVec()\n+        skolemization_count: 0,\n+        undo_log: ~[]\n     }\n }\n \n@@ -430,11 +453,11 @@ fn CombineMap() -> CombineMap {\n }\n \n impl RegionVarBindings {\n-    fn in_snapshot() -> bool {\n+    fn in_snapshot(&self) -> bool {\n         self.undo_log.len() > 0\n     }\n \n-    fn start_snapshot() -> uint {\n+    fn start_snapshot(&self) -> uint {\n         debug!(\"RegionVarBindings: snapshot()=%u\", self.undo_log.len());\n         if self.in_snapshot() {\n             self.undo_log.len()\n@@ -444,14 +467,14 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn commit() {\n+    fn commit(&self) {\n         debug!(\"RegionVarBindings: commit()\");\n         while self.undo_log.len() > 0 {\n             self.undo_log.pop();\n         }\n     }\n \n-    fn rollback_to(snapshot: uint) {\n+    fn rollback_to(&self, snapshot: uint) {\n         debug!(\"RegionVarBindings: rollback_to(%u)\", snapshot);\n         while self.undo_log.len() > snapshot {\n             let undo_item = self.undo_log.pop();\n@@ -472,11 +495,11 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn num_vars() -> uint {\n+    fn num_vars(&self) -> uint {\n         self.var_spans.len()\n     }\n \n-    fn new_region_var(span: span) -> RegionVid {\n+    fn new_region_var(&self, span: span) -> RegionVid {\n         let id = self.num_vars();\n         self.var_spans.push(span);\n         let vid = RegionVid(id);\n@@ -488,7 +511,13 @@ impl RegionVarBindings {\n         return vid;\n     }\n \n-    fn add_constraint(+constraint: Constraint, span: span) {\n+    fn new_skolemized(&self, br: ty::bound_region) -> Region {\n+        let sc = self.skolemization_count;\n+        self.skolemization_count += 1;\n+        re_infer(ReSkolemized(sc, br))\n+    }\n+\n+    fn add_constraint(&self, +constraint: Constraint, span: span) {\n         // cannot add constraints once regions are resolved\n         assert self.values.is_empty();\n \n@@ -501,21 +530,22 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn make_subregion(span: span, sub: Region, sup: Region) -> cres<()> {\n+    fn make_subregion(&self, span: span,\n+                      sub: Region, sup: Region) -> cres<()> {\n         // cannot add constraints once regions are resolved\n         assert self.values.is_empty();\n \n         debug!(\"RegionVarBindings: make_subregion(%?, %?)\", sub, sup);\n         match (sub, sup) {\n-          (ty::re_var (sub_id), ty::re_var(sup_id)) => {\n+          (re_infer(ReVar(sub_id)), re_infer(ReVar(sup_id))) => {\n             self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), span);\n             Ok(())\n           }\n-          (r, ty::re_var(sup_id)) => {\n+          (r, re_infer(ReVar(sup_id))) => {\n             self.add_constraint(ConstrainRegSubVar(r, sup_id), span);\n             Ok(())\n           }\n-          (ty::re_var(sub_id), r) => {\n+          (re_infer(ReVar(sub_id)), r) => {\n             self.add_constraint(ConstrainVarSubReg(sub_id, r), span);\n             Ok(())\n           }\n@@ -529,17 +559,17 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn lub_regions(span: span, a: Region, b: Region) -> cres<Region> {\n+    fn lub_regions(&self, span: span, a: Region, b: Region) -> cres<Region> {\n         // cannot add constraints once regions are resolved\n         assert self.values.is_empty();\n \n         debug!(\"RegionVarBindings: lub_regions(%?, %?)\", a, b);\n         match (a, b) {\n-          (ty::re_static, _) | (_, ty::re_static) => {\n-            Ok(ty::re_static) // nothing lives longer than static\n+          (re_static, _) | (_, re_static) => {\n+            Ok(re_static) // nothing lives longer than static\n           }\n \n-          (ty::re_var(*), _) | (_, ty::re_var(*)) => {\n+          (re_infer(ReVar(*)), _) | (_, re_infer(ReVar(*))) => {\n             self.combine_vars(\n                 self.lubs, a, b, span,\n                 |old_r, new_r| self.make_subregion(span, old_r, new_r))\n@@ -551,18 +581,18 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn glb_regions(span: span, a: Region, b: Region) -> cres<Region> {\n+    fn glb_regions(&self, span: span, a: Region, b: Region) -> cres<Region> {\n         // cannot add constraints once regions are resolved\n         assert self.values.is_empty();\n \n         debug!(\"RegionVarBindings: glb_regions(%?, %?)\", a, b);\n         match (a, b) {\n-          (ty::re_static, r) | (r, ty::re_static) => {\n+          (re_static, r) | (r, re_static) => {\n             // static lives longer than everything else\n             Ok(r)\n           }\n \n-          (ty::re_var(*), _) | (_, ty::re_var(*)) => {\n+          (re_infer(ReVar(*)), _) | (_, re_infer(ReVar(*))) => {\n             self.combine_vars(\n                 self.glbs, a, b, span,\n                 |old_r, new_r| self.make_subregion(span, new_r, old_r))\n@@ -574,7 +604,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn resolve_var(rid: RegionVid) -> ty::Region {\n+    fn resolve_var(&self, rid: RegionVid) -> ty::Region {\n         debug!(\"RegionVarBindings: resolve_var(%?=%u)\", rid, *rid);\n         if self.values.is_empty() {\n             self.tcx.sess.span_bug(\n@@ -586,62 +616,162 @@ impl RegionVarBindings {\n         self.values.with_ref(|values| values[*rid])\n     }\n \n-    fn combine_vars(combines: CombineMap, a: Region, b: Region, span: span,\n+    fn combine_vars(&self,\n+                    combines: CombineMap,\n+                    a: Region,\n+                    b: Region,\n+                    span: span,\n                     relate: fn(old_r: Region, new_r: Region) -> cres<()>)\n         -> cres<Region> {\n \n         let vars = TwoRegions { a: a, b: b };\n         match combines.find(vars) {\n-          Some(c) => Ok(ty::re_var(c)),\n+          Some(c) => Ok(re_infer(ReVar(c))),\n           None => {\n             let c = self.new_region_var(span);\n             combines.insert(vars, c);\n             if self.in_snapshot() {\n                 self.undo_log.push(AddCombination(combines, vars));\n             }\n-            do relate(a, ty::re_var(c)).then {\n-                do relate(b, ty::re_var(c)).then {\n-                    debug!(\"combine_vars() c=%?\", ty::re_var(c));\n-                    Ok(ty::re_var(c))\n+            do relate(a, re_infer(ReVar(c))).then {\n+                do relate(b, re_infer(ReVar(c))).then {\n+                    debug!(\"combine_vars() c=%?\", c);\n+                    Ok(re_infer(ReVar(c)))\n                 }\n             }\n           }\n         }\n     }\n \n+    fn tainted(&self, snapshot: uint, r0: Region) -> ~[Region] {\n+        /*!\n+         *\n+         * Computes all regions that have been related to `r0` in any\n+         * way since the snapshot `snapshot` was taken---excluding\n+         * `r0` itself and any region variables added as part of the\n+         * snapshot.  This is used when checking whether skolemized\n+         * regions are being improperly related to other regions.\n+         */\n+\n+        debug!(\"tainted(snapshot=%u, r0=%?)\", snapshot, r0);\n+        let _indenter = indenter();\n+\n+        let undo_len = self.undo_log.len();\n+\n+        // collect variables added since the snapshot was taken\n+        let new_vars = do vec::build |push| {\n+            for uint::range(snapshot, undo_len) |i| {\n+                match self.undo_log[i] {\n+                    AddVar(vid) => push(vid),\n+                    _ => ()\n+                }\n+            }\n+        };\n+\n+        // `result_set` acts as a worklist: we explore all outgoing\n+        // edges and add any new regions we find to result_set.  This\n+        // is not a terribly efficient implementation.\n+        let mut result_set = ~[r0], result_index = 0;\n+        while result_index < result_set.len() {\n+            // nb: can't use uint::range() here because result_set grows\n+            let r = result_set[result_index];\n+\n+            debug!(\"result_index=%u, r=%?\", result_index, r);\n+\n+            let mut undo_index = snapshot;\n+            while undo_index < undo_len {\n+                // nb: can't use uint::range() here as we move result_set\n+                let regs = match self.undo_log[undo_index] {\n+                    AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n+                        Some((re_infer(ReVar(*a)),\n+                              re_infer(ReVar(*b))))\n+                    }\n+                    AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n+                        Some((*a, re_infer(ReVar(*b))))\n+                    }\n+                    AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n+                        Some((re_infer(ReVar(*a)), *b))\n+                    }\n+                    _ => {\n+                        None\n+                    }\n+                };\n+\n+                match regs {\n+                    None => {}\n+                    Some((ref r1, ref r2)) => {\n+                        result_set =\n+                            consider_adding_edge(move result_set, &r, r1, r2);\n+                        result_set =\n+                            consider_adding_edge(move result_set, &r, r2, r1);\n+                    }\n+                }\n+\n+                undo_index += 1;\n+            }\n+\n+            result_index += 1;\n+        }\n+\n+        // Drop `r0` itself and any region variables that were created\n+        // since the snapshot.\n+        result_set.retain(|r| {\n+            match *r {\n+                re_infer(ReVar(ref vid)) => !new_vars.contains(vid),\n+                _ => *r != r0\n+            }\n+        });\n+\n+        return result_set;\n+\n+        fn consider_adding_edge(+result_set: ~[Region],\n+                                r: &Region,\n+                                r1: &Region,\n+                                r2: &Region) -> ~[Region]\n+        {\n+            let mut result_set = move result_set;\n+            if *r == *r1 { // Clearly, this is potentially inefficient.\n+                if !result_set.contains(r2) {\n+                    result_set.push(*r2);\n+                }\n+            }\n+            return move result_set;\n+        }\n+    }\n+\n     /**\n     This function performs the actual region resolution.  It must be\n     called after all constraints have been added.  It performs a\n     fixed-point iteration to find region values which satisfy all\n     constraints, assuming such values can be found; if they cannot,\n     errors are reported.\n     */\n-    fn resolve_regions() {\n+    fn resolve_regions(&self) {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         self.values.put_back(self.infer_variable_values());\n     }\n }\n \n priv impl RegionVarBindings {\n-    fn is_subregion_of(sub: Region, sup: Region) -> bool {\n+    fn is_subregion_of(&self, sub: Region, sup: Region) -> bool {\n         is_subregion_of(self.tcx.region_map, sub, sup)\n     }\n \n-    fn lub_concrete_regions(+a: Region, +b: Region) -> Region {\n+    fn lub_concrete_regions(&self, +a: Region, +b: Region) -> Region {\n         match (a, b) {\n-          (ty::re_static, _) | (_, ty::re_static) => {\n-            ty::re_static // nothing lives longer than static\n+          (re_static, _) | (_, re_static) => {\n+            re_static // nothing lives longer than static\n           }\n \n-          (ty::re_var(v_id), _) | (_, ty::re_var(v_id)) => {\n+          (re_infer(ReVar(v_id)), _) | (_, re_infer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n                 self.var_spans[*v_id],\n                 fmt!(\"lub_concrete_regions invoked with \\\n                       non-concrete regions: %?, %?\", a, b));\n           }\n \n-          (f @ ty::re_free(f_id, _), ty::re_scope(s_id)) |\n-          (ty::re_scope(s_id), f @ ty::re_free(f_id, _)) => {\n+          (f @ re_free(f_id, _), re_scope(s_id)) |\n+          (re_scope(s_id), f @ re_free(f_id, _)) => {\n             // A \"free\" region can be interpreted as \"some region\n             // at least as big as the block f_id\".  So, we can\n             // reasonably compare free regions and scopes:\n@@ -654,98 +784,103 @@ priv impl RegionVarBindings {\n \n               // otherwise, we don't know what the free region is,\n               // so we must conservatively say the LUB is static:\n-              _ => ty::re_static\n+              _ => re_static\n             }\n           }\n \n-          (ty::re_scope(a_id), ty::re_scope(b_id)) => {\n+          (re_scope(a_id), re_scope(b_id)) => {\n             // The region corresponding to an outer block is a\n             // subtype of the region corresponding to an inner\n             // block.\n             let rm = self.tcx.region_map;\n             match region::nearest_common_ancestor(rm, a_id, b_id) {\n-              Some(r_id) => ty::re_scope(r_id),\n-              _ => ty::re_static\n+              Some(r_id) => re_scope(r_id),\n+              _ => re_static\n             }\n           }\n \n           // For these types, we cannot define any additional\n           // relationship:\n-          (ty::re_free(_, _), ty::re_free(_, _)) |\n-          (ty::re_bound(_), ty::re_bound(_)) |\n-          (ty::re_bound(_), ty::re_free(_, _)) |\n-          (ty::re_bound(_), ty::re_scope(_)) |\n-          (ty::re_free(_, _), ty::re_bound(_)) |\n-          (ty::re_scope(_), ty::re_bound(_)) => {\n-            if a == b {a} else {ty::re_static}\n+          (re_infer(ReSkolemized(*)), _) |\n+          (_, re_infer(ReSkolemized(*))) |\n+          (re_free(_, _), re_free(_, _)) |\n+          (re_bound(_), re_bound(_)) |\n+          (re_bound(_), re_free(_, _)) |\n+          (re_bound(_), re_scope(_)) |\n+          (re_free(_, _), re_bound(_)) |\n+          (re_scope(_), re_bound(_)) => {\n+            if a == b {a} else {re_static}\n           }\n         }\n     }\n \n-    fn glb_concrete_regions(+a: Region, +b: Region) -> cres<Region> {\n+    fn glb_concrete_regions(&self, +a: Region, +b: Region) -> cres<Region> {\n         match (a, b) {\n-          (ty::re_static, r) | (r, ty::re_static) => {\n-            // static lives longer than everything else\n-            Ok(r)\n-          }\n-\n-          (ty::re_var(v_id), _) | (_, ty::re_var(v_id)) => {\n-            self.tcx.sess.span_bug(\n-                self.var_spans[*v_id],\n-                fmt!(\"glb_concrete_regions invoked with \\\n-                      non-concrete regions: %?, %?\", a, b));\n-          }\n+            (re_static, r) | (r, re_static) => {\n+                // static lives longer than everything else\n+                Ok(r)\n+            }\n \n-          (ty::re_free(f_id, _), s @ ty::re_scope(s_id)) |\n-          (s @ ty::re_scope(s_id), ty::re_free(f_id, _)) => {\n-            // Free region is something \"at least as big as\n-            // `f_id`.\"  If we find that the scope `f_id` is bigger\n-            // than the scope `s_id`, then we can say that the GLB\n-            // is the scope `s_id`.  Otherwise, as we do not know\n-            // big the free region is precisely, the GLB is undefined.\n-            let rm = self.tcx.region_map;\n-            match region::nearest_common_ancestor(rm, f_id, s_id) {\n-              Some(r_id) if r_id == f_id => Ok(s),\n-              _ => Err(ty::terr_regions_no_overlap(b, a))\n+            (re_infer(ReVar(v_id)), _) |\n+            (_, re_infer(ReVar(v_id))) => {\n+                self.tcx.sess.span_bug(\n+                    self.var_spans[*v_id],\n+                    fmt!(\"glb_concrete_regions invoked with \\\n+                          non-concrete regions: %?, %?\", a, b));\n             }\n-          }\n \n-          (ty::re_scope(a_id), ty::re_scope(b_id)) |\n-          (ty::re_free(a_id, _), ty::re_free(b_id, _)) => {\n-            if a == b {\n-                // Same scope or same free identifier, easy case.\n-                Ok(a)\n-            } else {\n-                // We want to generate the intersection of two\n-                // scopes or two free regions.  So, if one of\n-                // these scopes is a subscope of the other, return\n-                // it.  Otherwise fail.\n+            (re_free(f_id, _), s @ re_scope(s_id)) |\n+            (s @ re_scope(s_id), re_free(f_id, _)) => {\n+                // Free region is something \"at least as big as\n+                // `f_id`.\"  If we find that the scope `f_id` is bigger\n+                // than the scope `s_id`, then we can say that the GLB\n+                // is the scope `s_id`.  Otherwise, as we do not know\n+                // big the free region is precisely, the GLB is undefined.\n                 let rm = self.tcx.region_map;\n-                match region::nearest_common_ancestor(rm, a_id, b_id) {\n-                  Some(r_id) if a_id == r_id => Ok(ty::re_scope(b_id)),\n-                  Some(r_id) if b_id == r_id => Ok(ty::re_scope(a_id)),\n-                  _ => Err(ty::terr_regions_no_overlap(b, a))\n+                match region::nearest_common_ancestor(rm, f_id, s_id) {\n+                    Some(r_id) if r_id == f_id => Ok(s),\n+                    _ => Err(ty::terr_regions_no_overlap(b, a))\n                 }\n             }\n-          }\n \n-          // For these types, we cannot define any additional\n-          // relationship:\n-          (ty::re_bound(_), ty::re_bound(_)) |\n-          (ty::re_bound(_), ty::re_free(_, _)) |\n-          (ty::re_bound(_), ty::re_scope(_)) |\n-          (ty::re_free(_, _), ty::re_bound(_)) |\n-          (ty::re_scope(_), ty::re_bound(_)) => {\n-            if a == b {\n-                Ok(a)\n-            } else {\n-                Err(ty::terr_regions_no_overlap(b, a))\n+            (re_scope(a_id), re_scope(b_id)) |\n+            (re_free(a_id, _), re_free(b_id, _)) => {\n+                if a == b {\n+                    // Same scope or same free identifier, easy case.\n+                    Ok(a)\n+                } else {\n+                    // We want to generate the intersection of two\n+                    // scopes or two free regions.  So, if one of\n+                    // these scopes is a subscope of the other, return\n+                    // it.  Otherwise fail.\n+                    let rm = self.tcx.region_map;\n+                    match region::nearest_common_ancestor(rm, a_id, b_id) {\n+                        Some(r_id) if a_id == r_id => Ok(re_scope(b_id)),\n+                        Some(r_id) if b_id == r_id => Ok(re_scope(a_id)),\n+                        _ => Err(ty::terr_regions_no_overlap(b, a))\n+                    }\n+                }\n+            }\n+\n+            // For these types, we cannot define any additional\n+            // relationship:\n+            (re_infer(ReSkolemized(*)), _) |\n+            (_, re_infer(ReSkolemized(*))) |\n+            (re_bound(_), re_bound(_)) |\n+            (re_bound(_), re_free(_, _)) |\n+            (re_bound(_), re_scope(_)) |\n+            (re_free(_, _), re_bound(_)) |\n+            (re_scope(_), re_bound(_)) => {\n+                if a == b {\n+                    Ok(a)\n+                } else {\n+                    Err(ty::terr_regions_no_overlap(b, a))\n+                }\n             }\n-          }\n         }\n     }\n \n-    fn report_type_error(span: span, terr: &ty::type_err) {\n+    fn report_type_error(&self, span: span, terr: &ty::type_err) {\n         let terr_str = ty::type_err_to_str(self.tcx, terr);\n         self.tcx.sess.span_err(span, terr_str);\n     }\n@@ -803,14 +938,14 @@ fn TwoRegionsMap() -> TwoRegionsMap {\n }\n \n impl RegionVarBindings {\n-    fn infer_variable_values() -> ~[Region] {\n+    fn infer_variable_values(&self) -> ~[Region] {\n         let graph = self.construct_graph();\n         self.expansion(&graph);\n         self.contraction(&graph);\n         self.extract_regions_and_report_errors(&graph)\n     }\n \n-    fn construct_graph() -> Graph {\n+    fn construct_graph(&self) -> Graph {\n         let num_vars = self.num_vars();\n         let num_edges = self.constraints.size();\n \n@@ -871,7 +1006,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn expansion(graph: &Graph) {\n+    fn expansion(&self, graph: &Graph) {\n         do self.iterate_until_fixed_point(~\"Expansion\", graph) |edge| {\n             match edge.constraint {\n               ConstrainRegSubVar(copy a_region, copy b_vid) => {\n@@ -895,7 +1030,8 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn expand_node(a_region: Region,\n+    fn expand_node(&self,\n+                   a_region: Region,\n                    b_vid: RegionVid,\n                    b_node: &GraphNode) -> bool {\n         debug!(\"expand_node(%?, %? == %?)\",\n@@ -929,7 +1065,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn contraction(graph: &Graph) {\n+    fn contraction(&self, graph: &Graph) {\n         do self.iterate_until_fixed_point(~\"Contraction\", graph) |edge| {\n             match edge.constraint {\n               ConstrainRegSubVar(*) => {\n@@ -953,33 +1089,34 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn contract_node(a_vid: RegionVid,\n+    fn contract_node(&self,\n+                     a_vid: RegionVid,\n                      a_node: &GraphNode,\n                      b_region: Region) -> bool {\n         debug!(\"contract_node(%? == %?/%?, %?)\",\n                a_vid, a_node.value, a_node.classification, b_region);\n \n         return match a_node.value {\n-          NoValue => {\n-            assert a_node.classification == Contracting;\n-            a_node.value = Value(b_region);\n-            true // changed\n-          }\n+            NoValue => {\n+                assert a_node.classification == Contracting;\n+                a_node.value = Value(b_region);\n+                true // changed\n+            }\n \n-          ErrorValue => {\n-            false // no change\n-          }\n+            ErrorValue => {\n+                false // no change\n+            }\n \n-          Value(copy a_region) => {\n-            match a_node.classification {\n-              Expanding => {\n-                check_node(&self, a_vid, a_node, a_region, b_region)\n-              }\n-              Contracting => {\n-                adjust_node(&self, a_vid, a_node, a_region, b_region)\n-              }\n+            Value(copy a_region) => {\n+                match a_node.classification {\n+                    Expanding => {\n+                        check_node(self, a_vid, a_node, a_region, b_region)\n+                    }\n+                    Contracting => {\n+                        adjust_node(self, a_vid, a_node, a_region, b_region)\n+                    }\n+                }\n             }\n-          }\n         };\n \n         fn check_node(self: &RegionVarBindings,\n@@ -1001,25 +1138,26 @@ impl RegionVarBindings {\n                        a_region: Region,\n                        b_region: Region) -> bool {\n             match self.glb_concrete_regions(a_region, b_region) {\n-              Ok(glb) => {\n-                if glb == a_region {\n+                Ok(glb) => {\n+                    if glb == a_region {\n+                        false\n+                    } else {\n+                        debug!(\"Contracting value of %? from %? to %?\",\n+                               a_vid, a_region, glb);\n+                        a_node.value = Value(glb);\n+                        true\n+                    }\n+                }\n+                Err(_) => {\n+                    a_node.value = ErrorValue;\n                     false\n-                } else {\n-                    debug!(\"Contracting value of %? from %? to %?\",\n-                           a_vid, a_region, glb);\n-                    a_node.value = Value(glb);\n-                    true\n                 }\n-              }\n-              Err(_) => {\n-                a_node.value = ErrorValue;\n-                false\n-              }\n             }\n         }\n     }\n \n     fn iterate_until_fixed_point(\n+        &self,\n         tag: ~str,\n         graph: &Graph,\n         body: fn(edge: &GraphEdge) -> bool)\n@@ -1040,7 +1178,7 @@ impl RegionVarBindings {\n         debug!(\"---- %s Complete after %u iteration(s)\", tag, iteration);\n     }\n \n-    fn extract_regions_and_report_errors(graph: &Graph) -> ~[Region] {\n+    fn extract_regions_and_report_errors(&self, graph: &Graph) -> ~[Region] {\n         let dup_map = TwoRegionsMap();\n         graph.nodes.mapi(|idx, node| {\n             match node.value {\n@@ -1050,7 +1188,7 @@ impl RegionVarBindings {\n                 self.tcx.sess.span_err(\n                     node.span,\n                     fmt!(\"Unconstrained region variable #%u\", idx));\n-                ty::re_static\n+                re_static\n               }\n \n               ErrorValue => {\n@@ -1065,21 +1203,23 @@ impl RegionVarBindings {\n                         graph, dup_map, node_vid);\n                   }\n                 }\n-                ty::re_static\n+                re_static\n               }\n             }\n         })\n     }\n \n     // Used to suppress reporting the same basic error over and over\n-    fn is_reported(dup_map: TwoRegionsMap,\n+    fn is_reported(&self,\n+                   dup_map: TwoRegionsMap,\n                    r_a: Region,\n                    r_b: Region) -> bool {\n         let key = TwoRegions { a: r_a, b: r_b };\n         !dup_map.insert(key, ())\n     }\n \n-    fn report_error_for_expanding_node(graph: &Graph,\n+    fn report_error_for_expanding_node(&self,\n+                                       graph: &Graph,\n                                        dup_map: TwoRegionsMap,\n                                        node_idx: RegionVid) {\n         // Errors in expanding nodes result from a lower-bound that is\n@@ -1131,7 +1271,8 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn report_error_for_contracting_node(graph: &Graph,\n+    fn report_error_for_contracting_node(&self,\n+                                         graph: &Graph,\n                                          dup_map: TwoRegionsMap,\n                                          node_idx: RegionVid) {\n         // Errors in contracting nodes result from two upper-bounds\n@@ -1184,7 +1325,8 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn collect_concrete_regions(graph: &Graph,\n+    fn collect_concrete_regions(&self,\n+                                graph: &Graph,\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction) -> ~[SpannedRegion] {\n         let set = HashMap();\n@@ -1226,7 +1368,8 @@ impl RegionVarBindings {\n         return result;\n     }\n \n-    fn each_edge(graph: &Graph,\n+    fn each_edge(&self,\n+                 graph: &Graph,\n                  node_idx: RegionVid,\n                  dir: Direction,\n                  op: fn(edge: &GraphEdge) -> bool) {", "previous_filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs"}, {"sha": "f0794bf752e98d0aa0acce3a6a4eacdfde42adbe", "filename": "src/rustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -148,21 +148,21 @@ impl resolve_state {\n     fn resolve_region(orig: ty::Region) -> ty::Region {\n         debug!(\"Resolve_region(%s)\", orig.to_str(self.infcx));\n         match orig {\n-          ty::re_var(rid) => self.resolve_region_var(rid),\n+          ty::re_infer(ty::ReVar(rid)) => self.resolve_region_var(rid),\n           _ => orig\n         }\n     }\n \n     fn resolve_region_var(rid: RegionVid) -> ty::Region {\n         if !self.should(resolve_rvar) {\n-            return ty::re_var(rid)\n+            return ty::re_infer(ty::ReVar(rid));\n         }\n         self.infcx.region_vars.resolve_var(rid)\n     }\n \n     fn assert_not_rvar(rid: RegionVid, r: ty::Region) {\n         match r {\n-          ty::re_var(rid2) => {\n+          ty::re_infer(ty::ReVar(rid2)) => {\n             self.err = Some(region_var_bound_by_region_var(rid, rid2));\n           }\n           _ => { }"}, {"sha": "3677911b5eaa19e900e1d985dca53ddbfe522e3e", "filename": "src/rustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -1,6 +1,9 @@\n use combine::*;\n use unify::*;\n use to_str::ToStr;\n+use std::list;\n+\n+fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n \n enum Sub = combine_fields;  // \"subtype\", \"subregion\" etc\n \n@@ -125,10 +128,21 @@ impl Sub: combine {\n     }\n \n     fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n+        debug!(\"fns(a=%s, b=%s)\", a.to_str(self.infcx), b.to_str(self.infcx));\n+        let _indenter = indenter();\n+\n         // Rather than checking the subtype relationship between `a` and `b`\n         // as-is, we need to do some extra work here in order to make sure\n         // that function subtyping works correctly with respect to regions\n-        // (issue #2263).\n+        //\n+        // A rather detailed discussion of what's going on here can be\n+        // found in the region_inference.rs module.\n+\n+        // Take a snapshot.  We'll never roll this back, but in later\n+        // phases we do want to be able to examine \"all bindings that\n+        // were created as part of this type comparison\", and making a\n+        // snapshot is a convenient way to do that.\n+        let snapshot = self.infcx.region_vars.start_snapshot();\n \n         // First, we instantiate each bound region in the subtype with a fresh\n         // region variable.\n@@ -140,26 +154,50 @@ impl Sub: combine {\n                 // for it.  The only thing we're doing with `br` here is\n                 // using it in the debug message.\n                 let rvar = self.infcx.next_region_var_nb(self.span);\n-                debug!(\"Bound region %s maps to %s\",\n+                debug!(\"Bound region %s maps to %?\",\n                        bound_region_to_str(self.infcx.tcx, br),\n-                       region_to_str(self.infcx.tcx, rvar));\n+                       rvar);\n                 rvar\n             }\n         };\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n-        let {fn_ty: b_fn_ty, _} = {\n+        let {fn_ty: b_fn_ty, isr: skol_isr, _} = {\n             do replace_bound_regions_in_fn_ty(self.infcx.tcx, @Nil,\n                                               None, b) |br| {\n-                // FIXME: eventually re_skolemized (issue #2263)\n-                ty::re_bound(br)\n+                let skol = self.infcx.region_vars.new_skolemized(br);\n+                debug!(\"Bound region %s skolemized to %?\",\n+                       bound_region_to_str(self.infcx.tcx, br),\n+                       skol);\n+                skol\n             }\n         };\n \n-        // Try to compare the supertype and subtype now that they've been\n-        // instantiated.\n-        super_fns(&self, &a_fn_ty, &b_fn_ty)\n+        debug!(\"a_fn_ty=%s\", a_fn_ty.to_str(self.infcx));\n+        debug!(\"b_fn_ty=%s\", b_fn_ty.to_str(self.infcx));\n+\n+        // Compare types now that bound regions have been replaced.\n+        let fn_ty = if_ok!(super_fns(&self, &a_fn_ty, &b_fn_ty));\n+\n+        // Presuming type comparison succeeds, we need to check\n+        // that the skolemized regions do not \"leak\".\n+        for list::each(skol_isr) |pair| {\n+            let (skol_br, skol) = *pair;\n+            let tainted = self.infcx.region_vars.tainted(snapshot, skol);\n+            for tainted.each |tainted_region| {\n+                // A is not as polymorphic as B:\n+                if self.a_is_expected {\n+                    return Err(ty::terr_regions_insufficiently_polymorphic(\n+                        skol_br, *tainted_region));\n+                } else {\n+                    return Err(ty::terr_regions_overly_polymorphic(\n+                        skol_br, *tainted_region));\n+                }\n+            }\n+        }\n+\n+        return Ok(fn_ty)\n     }\n \n     // Traits please (FIXME: #2794):"}, {"sha": "3c9b22ff66f4ddf42f3f00a5efdfe67665f0ff68", "filename": "src/rustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -23,6 +23,12 @@ impl ty::Region: ToStr {\n     }\n }\n \n+impl ty::FnTy: ToStr {\n+    fn to_str(cx: infer_ctxt) -> ~str {\n+        ty::mk_fn(cx.tcx, self).to_str(cx)\n+    }\n+}\n+\n impl<V:Copy ToStr> bound<V>: ToStr {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         match self {"}, {"sha": "0e6f6536bf57e7ca00bfe5afb96711d3901699fd", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -133,7 +133,7 @@ mod middle {\n             #[legacy_exports]\n             mod lub;\n             #[legacy_exports]\n-            mod region_var_bindings;\n+            mod region_inference;\n             #[legacy_exports]\n             mod resolve;\n             #[legacy_exports]"}, {"sha": "75e21a5297b51c54c2c371c06097ded8f7021d55", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -6,7 +6,8 @@ use middle::ty::{bound_copy, bound_const, bound_owned, bound_send,\n use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid};\n use middle::ty::{ck_block, ck_box, ck_uniq, ctxt, field, method};\n use middle::ty::{mt, t, param_bound};\n-use middle::ty::{re_bound, re_free, re_scope, re_var, re_static, Region};\n+use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region};\n+use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{ty_bool, ty_bot, ty_box, ty_class, ty_enum};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_trait, ty_int};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n@@ -95,7 +96,7 @@ fn explain_region_and_span(cx: ctxt, region: ty::Region)\n \n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n-      re_var(_) | re_bound(_) => {\n+      re_infer(_) | re_bound(_) => {\n         (fmt!(\"lifetime %?\", region), None)\n       }\n     };\n@@ -184,8 +185,9 @@ fn region_to_str(cx: ctxt, region: Region) -> ~str {\n       re_scope(_) => ~\"&\",\n       re_bound(br) => bound_region_to_str(cx, br),\n       re_free(_, br) => bound_region_to_str(cx, br),\n-      re_var(_)    => ~\"&\",\n-      re_static     => ~\"&static\"\n+      re_infer(ReSkolemized(_, br)) => bound_region_to_str(cx, br),\n+      re_infer(ReVar(_)) => ~\"&\",\n+      re_static => ~\"&static\"\n     }\n }\n "}, {"sha": "8dc4fd2f6e282127d47f9c8af854c5cfa54fac9c", "filename": "src/test/compile-fail/regions-fn-subtyping.rs", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3a70760b4dfe03e135f28b5456d61752d3e677/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs?ref=1a3a70760b4dfe03e135f28b5456d61752d3e677", "patch": "@@ -1,24 +1,47 @@\n-// Here, `f` is a function that takes a pointer `x` and a function\n-// `g`, where `g` requires its argument `y` to be in the same region\n-// that `x` is in.\n-fn has_same_region(f: fn(x: &a/int, g: fn(y: &a/int))) {\n-    // Somewhat counterintuitively, this fails because, in\n-    // `wants_two_regions`, the `g` argument needs to be able to\n-    // accept any region.  That is, the type that `has_same_region`\n-    // expects is *not* a subtype of the type that `wants_two_regions`\n-    // expects.\n-    wants_two_regions(f); //~ ERROR mismatched types\n-}\n+fn of<T>() -> @fn(T) { fail; }\n+fn subtype<T>(x: @fn(T)) { fail; }\n \n-fn wants_two_regions(_f: fn(x: &int, g: fn(y: &int))) {\n-    // Suppose we were to write code here that passed some arbitrary\n-    // &int and some arbitrary fn(&int) to whatever's passed in as _f.\n-    // This would be fine as far as the type annotation on the formal\n-    // parameter _f goes, but if _f were `f` we'd be in trouble since\n-    // `f` can't handle those arguments.\n-}\n+fn test_fn<T>(_x: &x/T, _y: &y/T, _z: &z/T) {\n+    // Here, x, y, and z are free.  Other letters\n+    // are bound.  Note that the arrangement\n+    // subtype::<T1>(of::<T2>()) will typecheck\n+    // iff T1 <: T2.\n \n-fn main() {\n-}\n+    subtype::<fn(&a/T)>(\n+        of::<fn(&a/T)>());\n+\n+    subtype::<fn(&a/T)>(\n+        of::<fn(&b/T)>());\n+\n+    subtype::<fn(&b/T)>(\n+        of::<fn(&x/T)>());\n+\n+    subtype::<fn(&x/T)>(\n+        of::<fn(&b/T)>());  //~ ERROR mismatched types\n+\n+    subtype::<fn(&a/T, &b/T)>(\n+        of::<fn(&a/T, &a/T)>());\n \n+    subtype::<fn(&a/T, &a/T)>(\n+        of::<fn(&a/T, &b/T)>()); //~ ERROR mismatched types\n+\n+    subtype::<fn(&a/T, &b/T)>(\n+        of::<fn(&x/T, &y/T)>());\n+\n+    subtype::<fn(&x/T, &y/T)>(\n+        of::<fn(&a/T, &b/T)>()); //~ ERROR mismatched types\n+\n+    subtype::<fn(&x/T) -> @fn(&a/T)>(\n+        of::<fn(&x/T) -> @fn(&a/T)>());\n+\n+    subtype::<fn(&a/T) -> @fn(&a/T)>(\n+        of::<fn(&a/T) -> @fn(&b/T)>()); //~ ERROR mismatched types\n+\n+    subtype::<fn(&a/T) -> @fn(&a/T)>(\n+        of::<fn(&x/T) -> @fn(&b/T)>()); //~ ERROR mismatched types\n+\n+    subtype::<fn(&a/T) -> @fn(&b/T)>(\n+        of::<fn(&a/T) -> @fn(&a/T)>());\n+}\n \n+fn main() {}\n\\ No newline at end of file"}]}