{"sha": "ab4feea50dd3e0109a30488300c213ca074d01a6", "node_id": "C_kwDOAAsO6NoAKGFiNGZlZWE1MGRkM2UwMTA5YTMwNDg4MzAwYzIxM2NhMDc0ZDAxYTY", "commit": {"author": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-12-16T05:06:44Z"}, "committer": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2022-03-08T00:19:08Z"}, "message": "Point at uncovered variants in enum definition in `note` instead of a `span_label`\n\nThis makes the order of the output always consistent:\n\n1. Place of the `match` missing arms\n2. The `enum` definition span\n3. The structured suggestion to add a fallthrough arm", "tree": {"sha": "cad0af4e6d654a9ba06ba49bdd41a33a6033ec1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cad0af4e6d654a9ba06ba49bdd41a33a6033ec1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab4feea50dd3e0109a30488300c213ca074d01a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab4feea50dd3e0109a30488300c213ca074d01a6", "html_url": "https://github.com/rust-lang/rust/commit/ab4feea50dd3e0109a30488300c213ca074d01a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab4feea50dd3e0109a30488300c213ca074d01a6/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "084ca79e7c721e5b670eb4e4da4b45519c0822cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/084ca79e7c721e5b670eb4e4da4b45519c0822cb", "html_url": "https://github.com/rust-lang/rust/commit/084ca79e7c721e5b670eb4e4da4b45519c0822cb"}], "stats": {"total": 1729, "additions": 1033, "deletions": 696}, "files": [{"sha": "204009934e77892005a81c412c64d06738e2f120", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -20,7 +20,7 @@ use rustc_session::lint::builtin::{\n };\n use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n-use rustc_span::{DesugaringKind, ExpnKind, Span};\n+use rustc_span::{DesugaringKind, ExpnKind, MultiSpan, Span};\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match def_id.as_local() {\n@@ -669,15 +669,27 @@ fn adt_defined_here<'p, 'tcx>(\n ) {\n     let ty = ty.peel_refs();\n     if let ty::Adt(def, _) = ty.kind() {\n-        if let Some(sp) = cx.tcx.hir().span_if_local(def.did) {\n-            err.span_label(sp, format!(\"`{}` defined here\", ty));\n-        }\n-\n-        if witnesses.len() < 4 {\n+        let mut spans = vec![];\n+        if witnesses.len() < 5 {\n             for sp in maybe_point_at_variant(cx, def, witnesses.iter()) {\n-                err.span_label(sp, \"not covered\");\n+                spans.push(sp);\n             }\n         }\n+        let def_span = cx\n+            .tcx\n+            .hir()\n+            .get_if_local(def.did)\n+            .and_then(|node| node.ident())\n+            .map(|ident| ident.span)\n+            .unwrap_or_else(|| cx.tcx.def_span(def.did));\n+        let mut span: MultiSpan =\n+            if spans.is_empty() { def_span.into() } else { spans.clone().into() };\n+\n+        span.push_span_label(def_span, String::new());\n+        for pat in spans {\n+            span.push_span_label(pat, \"not covered\".to_string());\n+        }\n+        err.span_note(span, &format!(\"`{}` defined here\", ty));\n     }\n }\n "}, {"sha": "205a0e7c6fd47176e0f6552f15032376df05fdc2", "filename": "src/test/ui/closures/2229_closure_analysis/match/issue-88331.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fissue-88331.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fissue-88331.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fissue-88331.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,12 +1,14 @@\n error[E0004]: non-exhaustive patterns: `Opcode(0_u8)` and `Opcode(2_u8..=u8::MAX)` not covered\n   --> $DIR/issue-88331.rs:11:20\n    |\n-LL | pub struct Opcode(pub u8);\n-   | -------------------------- `Opcode` defined here\n-...\n LL |     move |i| match msg_type {\n    |                    ^^^^^^^^ patterns `Opcode(0_u8)` and `Opcode(2_u8..=u8::MAX)` not covered\n    |\n+note: `Opcode` defined here\n+  --> $DIR/issue-88331.rs:4:12\n+   |\n+LL | pub struct Opcode(pub u8);\n+   |            ^^^^^^\n    = note: the matched value is of type `Opcode`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -17,12 +19,14 @@ LL ~         Opcode(0_u8) | Opcode(2_u8..=u8::MAX) => todo!(),\n error[E0004]: non-exhaustive patterns: `Opcode2(Opcode(0_u8))` and `Opcode2(Opcode(2_u8..=u8::MAX))` not covered\n   --> $DIR/issue-88331.rs:27:20\n    |\n-LL | pub struct Opcode2(Opcode);\n-   | --------------------------- `Opcode2` defined here\n-...\n LL |     move |i| match msg_type {\n    |                    ^^^^^^^^ patterns `Opcode2(Opcode(0_u8))` and `Opcode2(Opcode(2_u8..=u8::MAX))` not covered\n    |\n+note: `Opcode2` defined here\n+  --> $DIR/issue-88331.rs:18:12\n+   |\n+LL | pub struct Opcode2(Opcode);\n+   |            ^^^^^^^\n    = note: the matched value is of type `Opcode2`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "02bd60893eb6be351d85c43ce68e7bf928cb4e6c", "filename": "src/test/ui/closures/2229_closure_analysis/match/non-exhaustive-match.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmatch%2Fnon-exhaustive-match.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,15 +1,14 @@\n error[E0004]: non-exhaustive patterns: `B` not covered\n   --> $DIR/non-exhaustive-match.rs:26:25\n    |\n-LL | enum L1 { A, B }\n-   | ----------------\n-   | |            |\n-   | |            not covered\n-   | `L1` defined here\n-...\n LL |     let _b = || { match l1 { L1::A => () } };\n    |                         ^^ pattern `B` not covered\n    |\n+note: `L1` defined here\n+  --> $DIR/non-exhaustive-match.rs:12:14\n+   |\n+LL | enum L1 { A, B }\n+   |      --      ^ not covered\n    = note: the matched value is of type `L1`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -22,6 +21,11 @@ error[E0004]: non-exhaustive patterns: type `E1` is non-empty\n LL |     let _d = || { match e1 {} };\n    |                         ^^\n    |\n+note: `E1` defined here\n+  --> $DIR/auxiliary/match_non_exhaustive_lib.rs:2:1\n+   |\n+LL | pub enum E1 {}\n+   | ^^^^^^^^^^^^^^\n    = note: the matched value is of type `E1`, which is marked as non-exhaustive\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -36,6 +40,11 @@ error[E0004]: non-exhaustive patterns: `_` not covered\n LL |     let _e = || { match e2 { E2::A => (), E2::B => () } };\n    |                         ^^ pattern `_` not covered\n    |\n+note: `E2` defined here\n+  --> $DIR/auxiliary/match_non_exhaustive_lib.rs:5:1\n+   |\n+LL | pub enum E2 { A, B }\n+   | ^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `E2`, which is marked as non-exhaustive\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "8dd0f377533ce8c0dc0ce1a22e1252c4daf38da2", "filename": "src/test/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,19 +1,18 @@\n error[E0005]: refutable pattern in local binding: `T(_, _)` not covered\n   --> $DIR/empty-never-array.rs:10:9\n    |\n-LL | / enum Helper<T, U> {\n-LL | |     T(T, [!; 0]),\n-   | |     - not covered\n-LL | |     #[allow(dead_code)]\n-LL | |     U(U),\n-LL | | }\n-   | |_- `Helper<T, U>` defined here\n-...\n-LL |       let Helper::U(u) = Helper::T(t, []);\n-   |           ^^^^^^^^^^^^ pattern `T(_, _)` not covered\n+LL |     let Helper::U(u) = Helper::T(t, []);\n+   |         ^^^^^^^^^^^^ pattern `T(_, _)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Helper<T, U>` defined here\n+  --> $DIR/empty-never-array.rs:4:5\n+   |\n+LL | enum Helper<T, U> {\n+   |      ------\n+LL |     T(T, [!; 0]),\n+   |     ^ not covered\n    = note: the matched value is of type `Helper<T, U>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "3dfa1fed48faa2c779701e485ee06c082d51db3b", "filename": "src/test/ui/error-codes/E0004-2.stderr", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,14 +4,20 @@ error[E0004]: non-exhaustive patterns: `None` and `Some(_)` not covered\n LL |     match x { }\n    |           ^ patterns `None` and `Some(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     None,\n-   |     ---- not covered\n-...\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ---- not covered\n+note: `Option<i32>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     None,\n+   | |     ^^^^ not covered\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   | |     ^^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Option<i32>`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "98cc08adf7f786320b6abc60097252ee54ef1a4b", "filename": "src/test/ui/error-codes/E0004.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Ferror-codes%2FE0004.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Ferror-codes%2FE0004.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0004.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,16 +1,16 @@\n error[E0004]: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n   --> $DIR/E0004.rs:9:11\n    |\n-LL | / enum Terminator {\n-LL | |     HastaLaVistaBaby,\n-   | |     ---------------- not covered\n-LL | |     TalkToMyHand,\n-LL | | }\n-   | |_- `Terminator` defined here\n-...\n-LL |       match x {\n-   |             ^ pattern `HastaLaVistaBaby` not covered\n+LL |     match x {\n+   |           ^ pattern `HastaLaVistaBaby` not covered\n    |\n+note: `Terminator` defined here\n+  --> $DIR/E0004.rs:2:5\n+   |\n+LL | enum Terminator {\n+   |      ----------\n+LL |     HastaLaVistaBaby,\n+   |     ^^^^^^^^^^^^^^^^ not covered\n    = note: the matched value is of type `Terminator`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "208c625a53e959c7df055d372bc5c1324b2249f3", "filename": "src/test/ui/error-codes/E0005.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,13 +4,21 @@ error[E0005]: refutable pattern in local binding: `None` not covered\n LL |     let Some(y) = x;\n    |         ^^^^^^^ pattern `None` not covered\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     None,\n-   |     ---- not covered\n-   |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Option<i32>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     None,\n+   | |     ^^^^ not covered\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Option<i32>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "95d95003c616f60e5cf0e5bfd46673aad2afa656", "filename": "src/test/ui/error-codes/E0297.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,11 +4,19 @@ error[E0005]: refutable pattern in `for` loop binding: `None` not covered\n LL |     for Some(x) in xs {}\n    |         ^^^^^^^ pattern `None` not covered\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     None,\n-   |     ---- not covered\n+note: `Option<i32>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     None,\n+   | |     ^^^^ not covered\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Option<i32>`\n \n error: aborting due to previous error"}, {"sha": "c2ffda6bb72d24e97dae7ce25fdcdfe0637b21d3", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,13 +4,20 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n LL |     let Ok(_x) = foo();\n    |         ^^^^^^ pattern `Err(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n-   |     --- not covered\n-   |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Result<u32, !>` defined here\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+   |\n+LL | / pub enum Result<T, E> {\n+LL | |     /// Contains the success value\n+LL | |     #[lang = \"Ok\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   | |     ^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Result<u32, !>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "52edb5b67a8791c0ea4d0e833a0862946c765f44", "filename": "src/test/ui/match/match_non_exhaustive.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fmatch%2Fmatch_non_exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fmatch%2Fmatch_non_exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch_non_exhaustive.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,15 +1,14 @@\n error[E0004]: non-exhaustive patterns: `B` not covered\n   --> $DIR/match_non_exhaustive.rs:23:11\n    |\n-LL | enum L { A, B }\n-   | ---------------\n-   | |           |\n-   | |           not covered\n-   | `L` defined here\n-...\n LL |     match l { L::A => () };\n    |           ^ pattern `B` not covered\n    |\n+note: `L` defined here\n+  --> $DIR/match_non_exhaustive.rs:10:13\n+   |\n+LL | enum L { A, B }\n+   |      -      ^ not covered\n    = note: the matched value is of type `L`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -22,6 +21,11 @@ error[E0004]: non-exhaustive patterns: type `E1` is non-empty\n LL |     match e1 {};\n    |           ^^\n    |\n+note: `E1` defined here\n+  --> $DIR/auxiliary/match_non_exhaustive_lib.rs:2:1\n+   |\n+LL | pub enum E1 {}\n+   | ^^^^^^^^^^^^^^\n    = note: the matched value is of type `E1`, which is marked as non-exhaustive\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -36,6 +40,11 @@ error[E0004]: non-exhaustive patterns: `_` not covered\n LL |     match e2 { E2::A => (), E2::B => () };\n    |           ^^ pattern `_` not covered\n    |\n+note: `E2` defined here\n+  --> $DIR/auxiliary/match_non_exhaustive_lib.rs:5:1\n+   |\n+LL | pub enum E2 { A, B }\n+   | ^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `E2`, which is marked as non-exhaustive\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "4b24e11881a80b24dc7e9a2367e66529795527ac", "filename": "src/test/ui/pattern/usefulness/always-inhabited-union-ref.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -16,14 +16,14 @@ LL +     }\n error[E0004]: non-exhaustive patterns: type `Foo` is non-empty\n   --> $DIR/always-inhabited-union-ref.rs:27:11\n    |\n-LL | / pub union Foo {\n-LL | |     foo: !,\n-LL | | }\n-   | |_- `Foo` defined here\n-...\n-LL |       match uninhab_union() {\n-   |             ^^^^^^^^^^^^^^^\n+LL |     match uninhab_union() {\n+   |           ^^^^^^^^^^^^^^^\n    |\n+note: `Foo` defined here\n+  --> $DIR/always-inhabited-union-ref.rs:10:11\n+   |\n+LL | pub union Foo {\n+   |           ^^^\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "5a2c3c1447f415d89d819199363d248c6f94f85f", "filename": "src/test/ui/pattern/usefulness/doc-hidden-non-exhaustive.stderr", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,6 +4,16 @@ error[E0004]: non-exhaustive patterns: `_` not covered\n LL |     match Foo::A {\n    |           ^^^^^^ pattern `_` not covered\n    |\n+note: `Foo` defined here\n+  --> $DIR/auxiliary/hidden.rs:1:1\n+   |\n+LL | / pub enum Foo {\n+LL | |     A,\n+LL | |     B,\n+LL | |     #[doc(hidden)]\n+LL | |     C,\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -17,11 +27,17 @@ error[E0004]: non-exhaustive patterns: `B` not covered\n LL |     match Foo::A {\n    |           ^^^^^^ pattern `B` not covered\n    |\n-  ::: $DIR/auxiliary/hidden.rs:3:5\n-   |\n-LL |     B,\n-   |     - not covered\n-   |\n+note: `Foo` defined here\n+  --> $DIR/auxiliary/hidden.rs:3:5\n+   |\n+LL | / pub enum Foo {\n+LL | |     A,\n+LL | |     B,\n+   | |     ^ not covered\n+LL | |     #[doc(hidden)]\n+LL | |     C,\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -35,11 +51,17 @@ error[E0004]: non-exhaustive patterns: `B` and `_` not covered\n LL |     match Foo::A {\n    |           ^^^^^^ patterns `B` and `_` not covered\n    |\n-  ::: $DIR/auxiliary/hidden.rs:3:5\n-   |\n-LL |     B,\n-   |     - not covered\n-   |\n+note: `Foo` defined here\n+  --> $DIR/auxiliary/hidden.rs:3:5\n+   |\n+LL | / pub enum Foo {\n+LL | |     A,\n+LL | |     B,\n+   | |     ^ not covered\n+LL | |     #[doc(hidden)]\n+LL | |     C,\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -53,11 +75,18 @@ error[E0004]: non-exhaustive patterns: `Some(B)` and `Some(_)` not covered\n LL |     match None {\n    |           ^^^^ patterns `Some(B)` and `Some(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ---- not covered\n-   |\n+note: `Option<Foo>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   | |     ^^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Option<Foo>`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "f8976960adc6a3838f4fce8a8d267eca3411ac2c", "filename": "src/test/ui/pattern/usefulness/empty-match.exhaustive_patterns.stderr", "status": "modified", "additions": 102, "deletions": 92, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -52,99 +52,104 @@ LL |     match_no_arms!(0u8);\n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct1` is non-empty\n   --> $DIR/empty-match.rs:79:20\n    |\n-LL | struct NonEmptyStruct1;\n-   | ----------------------- `NonEmptyStruct1` defined here\n-...\n LL |     match_no_arms!(NonEmptyStruct1);\n    |                    ^^^^^^^^^^^^^^^\n    |\n+note: `NonEmptyStruct1` defined here\n+  --> $DIR/empty-match.rs:14:8\n+   |\n+LL | struct NonEmptyStruct1;\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct1`\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct2` is non-empty\n   --> $DIR/empty-match.rs:80:20\n    |\n-LL | struct NonEmptyStruct2(bool);\n-   | ----------------------------- `NonEmptyStruct2` defined here\n-...\n LL |     match_no_arms!(NonEmptyStruct2(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^\n    |\n+note: `NonEmptyStruct2` defined here\n+  --> $DIR/empty-match.rs:15:8\n+   |\n+LL | struct NonEmptyStruct2(bool);\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct2`\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n   --> $DIR/empty-match.rs:81:20\n    |\n-LL | / union NonEmptyUnion1 {\n-LL | |     foo: (),\n-LL | | }\n-   | |_- `NonEmptyUnion1` defined here\n-...\n-LL |       match_no_arms!((NonEmptyUnion1 { foo: () }));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     match_no_arms!((NonEmptyUnion1 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n+note: `NonEmptyUnion1` defined here\n+  --> $DIR/empty-match.rs:16:7\n+   |\n+LL | union NonEmptyUnion1 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion1`\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n   --> $DIR/empty-match.rs:82:20\n    |\n-LL | / union NonEmptyUnion2 {\n-LL | |     foo: (),\n-LL | |     bar: (),\n-LL | | }\n-   | |_- `NonEmptyUnion2` defined here\n-...\n-LL |       match_no_arms!((NonEmptyUnion2 { foo: () }));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     match_no_arms!((NonEmptyUnion2 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `NonEmptyUnion2` defined here\n+  --> $DIR/empty-match.rs:19:7\n    |\n+LL | union NonEmptyUnion2 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion2`\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n   --> $DIR/empty-match.rs:83:20\n    |\n-LL | / enum NonEmptyEnum1 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum1` defined here\n-...\n-LL |       match_no_arms!(NonEmptyEnum1::Foo(true));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |     match_no_arms!(NonEmptyEnum1::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+   |\n+note: `NonEmptyEnum1` defined here\n+  --> $DIR/empty-match.rs:24:5\n    |\n+LL | enum NonEmptyEnum1 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum1`\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n   --> $DIR/empty-match.rs:84:20\n    |\n-LL | / enum NonEmptyEnum2 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | |     Bar,\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum2` defined here\n-...\n-LL |       match_no_arms!(NonEmptyEnum2::Foo(true));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+LL |     match_no_arms!(NonEmptyEnum2::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n+note: `NonEmptyEnum2` defined here\n+  --> $DIR/empty-match.rs:27:5\n+   |\n+LL | enum NonEmptyEnum2 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n+LL |     Bar,\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum2`\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n   --> $DIR/empty-match.rs:85:20\n    |\n-LL | / enum NonEmptyEnum5 {\n-LL | |     V1, V2, V3, V4, V5,\n-LL | | }\n-   | |_- `NonEmptyEnum5` defined here\n-...\n-LL |       match_no_arms!(NonEmptyEnum5::V1);\n-   |                      ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |     match_no_arms!(NonEmptyEnum5::V1);\n+   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |\n+note: `NonEmptyEnum5` defined here\n+  --> $DIR/empty-match.rs:30:6\n    |\n+LL | enum NonEmptyEnum5 {\n+   |      ^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyEnum5`\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n@@ -164,12 +169,14 @@ LL +             _ => todo!()\n error[E0004]: non-exhaustive patterns: `NonEmptyStruct1` not covered\n   --> $DIR/empty-match.rs:88:24\n    |\n-LL | struct NonEmptyStruct1;\n-   | ----------------------- `NonEmptyStruct1` defined here\n-...\n LL |     match_guarded_arm!(NonEmptyStruct1);\n    |                        ^^^^^^^^^^^^^^^ pattern `NonEmptyStruct1` not covered\n    |\n+note: `NonEmptyStruct1` defined here\n+  --> $DIR/empty-match.rs:14:8\n+   |\n+LL | struct NonEmptyStruct1;\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct1`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -180,12 +187,14 @@ LL +             NonEmptyStruct1 => todo!()\n error[E0004]: non-exhaustive patterns: `NonEmptyStruct2(_)` not covered\n   --> $DIR/empty-match.rs:89:24\n    |\n-LL | struct NonEmptyStruct2(bool);\n-   | ----------------------------- `NonEmptyStruct2` defined here\n-...\n LL |     match_guarded_arm!(NonEmptyStruct2(true));\n    |                        ^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct2(_)` not covered\n    |\n+note: `NonEmptyStruct2` defined here\n+  --> $DIR/empty-match.rs:15:8\n+   |\n+LL | struct NonEmptyStruct2(bool);\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct2`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -196,14 +205,14 @@ LL +             NonEmptyStruct2(_) => todo!()\n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n   --> $DIR/empty-match.rs:90:24\n    |\n-LL | / union NonEmptyUnion1 {\n-LL | |     foo: (),\n-LL | | }\n-   | |_- `NonEmptyUnion1` defined here\n-...\n-LL |       match_guarded_arm!((NonEmptyUnion1 { foo: () }));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n+LL |     match_guarded_arm!((NonEmptyUnion1 { foo: () }));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n    |\n+note: `NonEmptyUnion1` defined here\n+  --> $DIR/empty-match.rs:16:7\n+   |\n+LL | union NonEmptyUnion1 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion1`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -214,15 +223,14 @@ LL +             NonEmptyUnion1 { .. } => todo!()\n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n   --> $DIR/empty-match.rs:91:24\n    |\n-LL | / union NonEmptyUnion2 {\n-LL | |     foo: (),\n-LL | |     bar: (),\n-LL | | }\n-   | |_- `NonEmptyUnion2` defined here\n-...\n-LL |       match_guarded_arm!((NonEmptyUnion2 { foo: () }));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n+LL |     match_guarded_arm!((NonEmptyUnion2 { foo: () }));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n+   |\n+note: `NonEmptyUnion2` defined here\n+  --> $DIR/empty-match.rs:19:7\n    |\n+LL | union NonEmptyUnion2 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion2`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -233,15 +241,16 @@ LL +             NonEmptyUnion2 { .. } => todo!()\n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n   --> $DIR/empty-match.rs:92:24\n    |\n-LL | / enum NonEmptyEnum1 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum1` defined here\n-...\n-LL |       match_guarded_arm!(NonEmptyEnum1::Foo(true));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |     match_guarded_arm!(NonEmptyEnum1::Foo(true));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+   |\n+note: `NonEmptyEnum1` defined here\n+  --> $DIR/empty-match.rs:24:5\n    |\n+LL | enum NonEmptyEnum1 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum1`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -252,17 +261,18 @@ LL +             Foo(_) => todo!()\n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n   --> $DIR/empty-match.rs:93:24\n    |\n-LL | / enum NonEmptyEnum2 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | |     Bar,\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum2` defined here\n-...\n-LL |       match_guarded_arm!(NonEmptyEnum2::Foo(true));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+LL |     match_guarded_arm!(NonEmptyEnum2::Foo(true));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n+note: `NonEmptyEnum2` defined here\n+  --> $DIR/empty-match.rs:27:5\n+   |\n+LL | enum NonEmptyEnum2 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n+LL |     Bar,\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum2`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -273,14 +283,14 @@ LL +             Foo(_) | Bar => todo!()\n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n   --> $DIR/empty-match.rs:94:24\n    |\n-LL | / enum NonEmptyEnum5 {\n-LL | |     V1, V2, V3, V4, V5,\n-LL | | }\n-   | |_- `NonEmptyEnum5` defined here\n-...\n-LL |       match_guarded_arm!(NonEmptyEnum5::V1);\n-   |                          ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |     match_guarded_arm!(NonEmptyEnum5::V1);\n+   |                        ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |\n+note: `NonEmptyEnum5` defined here\n+  --> $DIR/empty-match.rs:30:6\n    |\n+LL | enum NonEmptyEnum5 {\n+   |      ^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyEnum5`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "f8976960adc6a3838f4fce8a8d267eca3411ac2c", "filename": "src/test/ui/pattern/usefulness/empty-match.normal.stderr", "status": "modified", "additions": 102, "deletions": 92, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -52,99 +52,104 @@ LL |     match_no_arms!(0u8);\n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct1` is non-empty\n   --> $DIR/empty-match.rs:79:20\n    |\n-LL | struct NonEmptyStruct1;\n-   | ----------------------- `NonEmptyStruct1` defined here\n-...\n LL |     match_no_arms!(NonEmptyStruct1);\n    |                    ^^^^^^^^^^^^^^^\n    |\n+note: `NonEmptyStruct1` defined here\n+  --> $DIR/empty-match.rs:14:8\n+   |\n+LL | struct NonEmptyStruct1;\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct1`\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct2` is non-empty\n   --> $DIR/empty-match.rs:80:20\n    |\n-LL | struct NonEmptyStruct2(bool);\n-   | ----------------------------- `NonEmptyStruct2` defined here\n-...\n LL |     match_no_arms!(NonEmptyStruct2(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^\n    |\n+note: `NonEmptyStruct2` defined here\n+  --> $DIR/empty-match.rs:15:8\n+   |\n+LL | struct NonEmptyStruct2(bool);\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct2`\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n   --> $DIR/empty-match.rs:81:20\n    |\n-LL | / union NonEmptyUnion1 {\n-LL | |     foo: (),\n-LL | | }\n-   | |_- `NonEmptyUnion1` defined here\n-...\n-LL |       match_no_arms!((NonEmptyUnion1 { foo: () }));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     match_no_arms!((NonEmptyUnion1 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n+note: `NonEmptyUnion1` defined here\n+  --> $DIR/empty-match.rs:16:7\n+   |\n+LL | union NonEmptyUnion1 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion1`\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n   --> $DIR/empty-match.rs:82:20\n    |\n-LL | / union NonEmptyUnion2 {\n-LL | |     foo: (),\n-LL | |     bar: (),\n-LL | | }\n-   | |_- `NonEmptyUnion2` defined here\n-...\n-LL |       match_no_arms!((NonEmptyUnion2 { foo: () }));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     match_no_arms!((NonEmptyUnion2 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `NonEmptyUnion2` defined here\n+  --> $DIR/empty-match.rs:19:7\n    |\n+LL | union NonEmptyUnion2 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion2`\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n   --> $DIR/empty-match.rs:83:20\n    |\n-LL | / enum NonEmptyEnum1 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum1` defined here\n-...\n-LL |       match_no_arms!(NonEmptyEnum1::Foo(true));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |     match_no_arms!(NonEmptyEnum1::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+   |\n+note: `NonEmptyEnum1` defined here\n+  --> $DIR/empty-match.rs:24:5\n    |\n+LL | enum NonEmptyEnum1 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum1`\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n   --> $DIR/empty-match.rs:84:20\n    |\n-LL | / enum NonEmptyEnum2 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | |     Bar,\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum2` defined here\n-...\n-LL |       match_no_arms!(NonEmptyEnum2::Foo(true));\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+LL |     match_no_arms!(NonEmptyEnum2::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n+note: `NonEmptyEnum2` defined here\n+  --> $DIR/empty-match.rs:27:5\n+   |\n+LL | enum NonEmptyEnum2 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n+LL |     Bar,\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum2`\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n   --> $DIR/empty-match.rs:85:20\n    |\n-LL | / enum NonEmptyEnum5 {\n-LL | |     V1, V2, V3, V4, V5,\n-LL | | }\n-   | |_- `NonEmptyEnum5` defined here\n-...\n-LL |       match_no_arms!(NonEmptyEnum5::V1);\n-   |                      ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |     match_no_arms!(NonEmptyEnum5::V1);\n+   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |\n+note: `NonEmptyEnum5` defined here\n+  --> $DIR/empty-match.rs:30:6\n    |\n+LL | enum NonEmptyEnum5 {\n+   |      ^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyEnum5`\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n@@ -164,12 +169,14 @@ LL +             _ => todo!()\n error[E0004]: non-exhaustive patterns: `NonEmptyStruct1` not covered\n   --> $DIR/empty-match.rs:88:24\n    |\n-LL | struct NonEmptyStruct1;\n-   | ----------------------- `NonEmptyStruct1` defined here\n-...\n LL |     match_guarded_arm!(NonEmptyStruct1);\n    |                        ^^^^^^^^^^^^^^^ pattern `NonEmptyStruct1` not covered\n    |\n+note: `NonEmptyStruct1` defined here\n+  --> $DIR/empty-match.rs:14:8\n+   |\n+LL | struct NonEmptyStruct1;\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct1`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -180,12 +187,14 @@ LL +             NonEmptyStruct1 => todo!()\n error[E0004]: non-exhaustive patterns: `NonEmptyStruct2(_)` not covered\n   --> $DIR/empty-match.rs:89:24\n    |\n-LL | struct NonEmptyStruct2(bool);\n-   | ----------------------------- `NonEmptyStruct2` defined here\n-...\n LL |     match_guarded_arm!(NonEmptyStruct2(true));\n    |                        ^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct2(_)` not covered\n    |\n+note: `NonEmptyStruct2` defined here\n+  --> $DIR/empty-match.rs:15:8\n+   |\n+LL | struct NonEmptyStruct2(bool);\n+   |        ^^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyStruct2`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -196,14 +205,14 @@ LL +             NonEmptyStruct2(_) => todo!()\n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n   --> $DIR/empty-match.rs:90:24\n    |\n-LL | / union NonEmptyUnion1 {\n-LL | |     foo: (),\n-LL | | }\n-   | |_- `NonEmptyUnion1` defined here\n-...\n-LL |       match_guarded_arm!((NonEmptyUnion1 { foo: () }));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n+LL |     match_guarded_arm!((NonEmptyUnion1 { foo: () }));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n    |\n+note: `NonEmptyUnion1` defined here\n+  --> $DIR/empty-match.rs:16:7\n+   |\n+LL | union NonEmptyUnion1 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion1`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -214,15 +223,14 @@ LL +             NonEmptyUnion1 { .. } => todo!()\n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n   --> $DIR/empty-match.rs:91:24\n    |\n-LL | / union NonEmptyUnion2 {\n-LL | |     foo: (),\n-LL | |     bar: (),\n-LL | | }\n-   | |_- `NonEmptyUnion2` defined here\n-...\n-LL |       match_guarded_arm!((NonEmptyUnion2 { foo: () }));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n+LL |     match_guarded_arm!((NonEmptyUnion2 { foo: () }));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n+   |\n+note: `NonEmptyUnion2` defined here\n+  --> $DIR/empty-match.rs:19:7\n    |\n+LL | union NonEmptyUnion2 {\n+   |       ^^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyUnion2`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -233,15 +241,16 @@ LL +             NonEmptyUnion2 { .. } => todo!()\n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n   --> $DIR/empty-match.rs:92:24\n    |\n-LL | / enum NonEmptyEnum1 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum1` defined here\n-...\n-LL |       match_guarded_arm!(NonEmptyEnum1::Foo(true));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |     match_guarded_arm!(NonEmptyEnum1::Foo(true));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+   |\n+note: `NonEmptyEnum1` defined here\n+  --> $DIR/empty-match.rs:24:5\n    |\n+LL | enum NonEmptyEnum1 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum1`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -252,17 +261,18 @@ LL +             Foo(_) => todo!()\n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n   --> $DIR/empty-match.rs:93:24\n    |\n-LL | / enum NonEmptyEnum2 {\n-LL | |     Foo(bool),\n-   | |     --- not covered\n-LL | |     Bar,\n-   | |     --- not covered\n-LL | | }\n-   | |_- `NonEmptyEnum2` defined here\n-...\n-LL |       match_guarded_arm!(NonEmptyEnum2::Foo(true));\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+LL |     match_guarded_arm!(NonEmptyEnum2::Foo(true));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n+note: `NonEmptyEnum2` defined here\n+  --> $DIR/empty-match.rs:27:5\n+   |\n+LL | enum NonEmptyEnum2 {\n+   |      -------------\n+LL |     Foo(bool),\n+   |     ^^^ not covered\n+LL |     Bar,\n+   |     ^^^ not covered\n    = note: the matched value is of type `NonEmptyEnum2`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -273,14 +283,14 @@ LL +             Foo(_) | Bar => todo!()\n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n   --> $DIR/empty-match.rs:94:24\n    |\n-LL | / enum NonEmptyEnum5 {\n-LL | |     V1, V2, V3, V4, V5,\n-LL | | }\n-   | |_- `NonEmptyEnum5` defined here\n-...\n-LL |       match_guarded_arm!(NonEmptyEnum5::V1);\n-   |                          ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |     match_guarded_arm!(NonEmptyEnum5::V1);\n+   |                        ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |\n+note: `NonEmptyEnum5` defined here\n+  --> $DIR/empty-match.rs:30:6\n    |\n+LL | enum NonEmptyEnum5 {\n+   |      ^^^^^^^^^^^^^\n    = note: the matched value is of type `NonEmptyEnum5`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "dffcfc016072f28d78c769ea47d0292ce2601ae6", "filename": "src/test/ui/pattern/usefulness/issue-31561.stderr", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,20 +1,21 @@\n error[E0005]: refutable pattern in local binding: `Bar` and `Baz` not covered\n   --> $DIR/issue-31561.rs:8:9\n    |\n-LL | / enum Thing {\n-LL | |     Foo(u8),\n-LL | |     Bar,\n-   | |     --- not covered\n-LL | |     Baz\n-   | |     --- not covered\n-LL | | }\n-   | |_- `Thing` defined here\n-...\n-LL |       let Thing::Foo(y) = Thing::Foo(1);\n-   |           ^^^^^^^^^^^^^ patterns `Bar` and `Baz` not covered\n+LL |     let Thing::Foo(y) = Thing::Foo(1);\n+   |         ^^^^^^^^^^^^^ patterns `Bar` and `Baz` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Thing` defined here\n+  --> $DIR/issue-31561.rs:3:5\n+   |\n+LL | enum Thing {\n+   |      -----\n+LL |     Foo(u8),\n+LL |     Bar,\n+   |     ^^^ not covered\n+LL |     Baz\n+   |     ^^^ not covered\n    = note: the matched value is of type `Thing`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "e5248ab985d62b81ff949b25eb612048769c6df5", "filename": "src/test/ui/pattern/usefulness/issue-35609.stderr", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -66,12 +66,14 @@ LL +         _ => todo!()\n error[E0004]: non-exhaustive patterns: `S(B, _)`, `S(C, _)`, `S(D, _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:31:11\n    |\n-LL | struct S(Enum, ());\n-   | ------------------- `S` defined here\n-...\n LL |     match S(A, ()) {\n    |           ^^^^^^^^ patterns `S(B, _)`, `S(C, _)`, `S(D, _)` and 2 more not covered\n    |\n+note: `S` defined here\n+  --> $DIR/issue-35609.rs:6:8\n+   |\n+LL | struct S(Enum, ());\n+   |        ^\n    = note: the matched value is of type `S`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -82,12 +84,14 @@ LL +         _ => todo!()\n error[E0004]: non-exhaustive patterns: `Sd { x: B, .. }`, `Sd { x: C, .. }`, `Sd { x: D, .. }` and 2 more not covered\n   --> $DIR/issue-35609.rs:35:11\n    |\n-LL | struct Sd { x: Enum, y: () }\n-   | ---------------------------- `Sd` defined here\n-...\n LL |     match (Sd { x: A, y: () }) {\n    |           ^^^^^^^^^^^^^^^^^^^^ patterns `Sd { x: B, .. }`, `Sd { x: C, .. }`, `Sd { x: D, .. }` and 2 more not covered\n    |\n+note: `Sd` defined here\n+  --> $DIR/issue-35609.rs:7:8\n+   |\n+LL | struct Sd { x: Enum, y: () }\n+   |        ^^\n    = note: the matched value is of type `Sd`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -101,6 +105,17 @@ error[E0004]: non-exhaustive patterns: `Some(B)`, `Some(C)`, `Some(D)` and 2 mor\n LL |     match Some(A) {\n    |           ^^^^^^^ patterns `Some(B)`, `Some(C)`, `Some(D)` and 2 more not covered\n    |\n+note: `Option<Enum>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `Option<Enum>`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "84916504220ba7409063f80e59a1cc414f94d49f", "filename": "src/test/ui/pattern/usefulness/issue-3601.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,6 +4,14 @@ error[E0004]: non-exhaustive patterns: `box _` not covered\n LL |         box NodeKind::Element(ed) => match ed.kind {\n    |                                            ^^^^^^^ pattern `box _` not covered\n    |\n+note: `Box<ElementKind>` defined here\n+  --> $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+   |\n+LL | / pub struct Box<\n+LL | |     T: ?Sized,\n+LL | |     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+LL | | >(Unique<T>, A);\n+   | |________________^\n    = note: the matched value is of type `Box<ElementKind>`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "f0f93af216abc4f14ab7505f8348b1289ce8fec8", "filename": "src/test/ui/pattern/usefulness/issue-39362.stderr", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-39362.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-39362.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-39362.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,14 +1,16 @@\n error[E0004]: non-exhaustive patterns: `Bar { bar: C, .. }`, `Bar { bar: D, .. }`, `Bar { bar: E, .. }` and 1 more not covered\n   --> $DIR/issue-39362.rs:10:11\n    |\n-LL | / enum Foo {\n-LL | |     Bar { bar: Bar, id: usize }\n-LL | | }\n-   | |_- `Foo` defined here\n-...\n-LL |       match f {\n-   |             ^ patterns `Bar { bar: C, .. }`, `Bar { bar: D, .. }`, `Bar { bar: E, .. }` and 1 more not covered\n+LL |     match f {\n+   |           ^ patterns `Bar { bar: C, .. }`, `Bar { bar: D, .. }`, `Bar { bar: E, .. }` and 1 more not covered\n    |\n+note: `Foo` defined here\n+  --> $DIR/issue-39362.rs:2:5\n+   |\n+LL | enum Foo {\n+   |      ---\n+LL |     Bar { bar: Bar, id: usize }\n+   |     ^^^ not covered\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "ca2ac71b1e4780ed21251408f1fbe426b384b1e9", "filename": "src/test/ui/pattern/usefulness/issue-40221.stderr", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-40221.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-40221.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-40221.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,15 +1,16 @@\n error[E0004]: non-exhaustive patterns: `C(QA)` not covered\n   --> $DIR/issue-40221.rs:11:11\n    |\n-LL | / enum P {\n-LL | |     C(PC),\n-   | |     - not covered\n-LL | | }\n-   | |_- `P` defined here\n-...\n-LL |       match proto {\n-   |             ^^^^^ pattern `C(QA)` not covered\n+LL |     match proto {\n+   |           ^^^^^ pattern `C(QA)` not covered\n    |\n+note: `P` defined here\n+  --> $DIR/issue-40221.rs:2:5\n+   |\n+LL | enum P {\n+   |      -\n+LL |     C(PC),\n+   |     ^ not covered\n    = note: the matched value is of type `P`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "6d437de8ceaa78524868eee4f200b9a417be3caf", "filename": "src/test/ui/pattern/usefulness/issue-50900.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-50900.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,12 +1,14 @@\n error[E0004]: non-exhaustive patterns: `Tag(Exif, _)` not covered\n   --> $DIR/issue-50900.rs:15:11\n    |\n-LL | pub struct Tag(pub Context, pub u16);\n-   | ------------------------------------- `Tag` defined here\n-...\n LL |     match Tag::ExifIFDPointer {\n    |           ^^^^^^^^^^^^^^^^^^^ pattern `Tag(Exif, _)` not covered\n    |\n+note: `Tag` defined here\n+  --> $DIR/issue-50900.rs:2:12\n+   |\n+LL | pub struct Tag(pub Context, pub u16);\n+   |            ^^^\n    = note: the matched value is of type `Tag`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "9d0ba0564a12befb6184d99db406c548d644d7ef", "filename": "src/test/ui/pattern/usefulness/issue-56379.stderr", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-56379.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,19 +1,20 @@\n error[E0004]: non-exhaustive patterns: `A(false)`, `B(false)` and `C(false)` not covered\n   --> $DIR/issue-56379.rs:8:11\n    |\n-LL | / enum Foo {\n-LL | |     A(bool),\n-   | |     - not covered\n-LL | |     B(bool),\n-   | |     - not covered\n-LL | |     C(bool),\n-   | |     - not covered\n-LL | | }\n-   | |_- `Foo` defined here\n-...\n-LL |       match Foo::A(true) {\n-   |             ^^^^^^^^^^^^ patterns `A(false)`, `B(false)` and `C(false)` not covered\n+LL |     match Foo::A(true) {\n+   |           ^^^^^^^^^^^^ patterns `A(false)`, `B(false)` and `C(false)` not covered\n    |\n+note: `Foo` defined here\n+  --> $DIR/issue-56379.rs:2:5\n+   |\n+LL | enum Foo {\n+   |      ---\n+LL |     A(bool),\n+   |     ^ not covered\n+LL |     B(bool),\n+   |     ^ not covered\n+LL |     C(bool),\n+   |     ^ not covered\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "cbfcf0eafd4901032ddf5b67f6825592d3b9ed70", "filename": "src/test/ui/pattern/usefulness/issue-78123-non-exhaustive-reference.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.rs?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,5 +1,6 @@\n enum A {}\n     //~^ NOTE `A` defined here\n+    //~| NOTE\n \n fn f(a: &A) {\n     match a {}"}, {"sha": "5b080b14849c404685ff90cd753e7e0dab75ec92", "filename": "src/test/ui/pattern/usefulness/issue-78123-non-exhaustive-reference.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78123-non-exhaustive-reference.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,12 +1,14 @@\n error[E0004]: non-exhaustive patterns: type `&A` is non-empty\n-  --> $DIR/issue-78123-non-exhaustive-reference.rs:5:11\n+  --> $DIR/issue-78123-non-exhaustive-reference.rs:6:11\n    |\n-LL | enum A {}\n-   | --------- `A` defined here\n-...\n LL |     match a {}\n    |           ^\n    |\n+note: `A` defined here\n+  --> $DIR/issue-78123-non-exhaustive-reference.rs:1:6\n+   |\n+LL | enum A {}\n+   |      ^\n    = note: the matched value is of type `&A`\n    = note: references are always considered inhabited\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms"}, {"sha": "892030c72ea1526850d2e929d89eb9e079a81f7a", "filename": "src/test/ui/pattern/usefulness/match-arm-statics-2.stderr", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -17,14 +17,21 @@ error[E0004]: non-exhaustive patterns: `Some(Some(West))` not covered\n LL |     match Some(Some(North)) {\n    |           ^^^^^^^^^^^^^^^^^ pattern `Some(Some(West))` not covered\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ----\n-   |     |\n-   |     not covered\n-   |     not covered\n-   |\n+note: `Option<Option<Direction>>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   | |     ^^^^\n+   | |     |\n+   | |     not covered\n+   | |     not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Option<Option<Direction>>`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -35,15 +42,14 @@ LL +         Some(Some(West)) => todo!()\n error[E0004]: non-exhaustive patterns: `Foo { bar: Some(North), baz: NewBool(true) }` not covered\n   --> $DIR/match-arm-statics-2.rs:48:11\n    |\n-LL | / struct Foo {\n-LL | |     bar: Option<Direction>,\n-LL | |     baz: NewBool\n-LL | | }\n-   | |_- `Foo` defined here\n-...\n-LL |       match (Foo { bar: Some(North), baz: NewBool(true) }) {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo { bar: Some(North), baz: NewBool(true) }` not covered\n+LL |     match (Foo { bar: Some(North), baz: NewBool(true) }) {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo { bar: Some(North), baz: NewBool(true) }` not covered\n+   |\n+note: `Foo` defined here\n+  --> $DIR/match-arm-statics-2.rs:40:8\n    |\n+LL | struct Foo {\n+   |        ^^^\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "8f8e87adb7a759358f48ea1b8a3acccb8d854e9b", "filename": "src/test/ui/pattern/usefulness/match-privately-empty.stderr", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,11 +4,18 @@ error[E0004]: non-exhaustive patterns: `Some(Private { misc: true, .. })` not co\n LL |     match private::DATA {\n    |           ^^^^^^^^^^^^^ pattern `Some(Private { misc: true, .. })` not covered\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ---- not covered\n+note: `Option<Private>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   | |     ^^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Option<Private>`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "2e15bc2d2a5f534fbab024f30bcd94f0039345fa", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-defined-here.rs", "status": "modified", "additions": 48, "deletions": 15, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,20 +4,26 @@\n \n #[derive(Clone)]\n enum E {\n-//~^ `E` defined here\n-//~| `E` defined here\n-//~| `E` defined here\n-//~| `E` defined here\n-//~| `E` defined here\n-//~| `E` defined here\n+    //~^ NOTE\n+    //~| NOTE\n+    //~| NOTE\n+    //~| NOTE\n+    //~| NOTE\n+    //~| NOTE\n     A,\n     B,\n-    //~^ not covered\n-    //~| not covered\n-    //~| not covered\n-    //~| not covered\n-    //~| not covered\n-    //~| not covered\n+    //~^ NOTE `E` defined here\n+    //~| NOTE `E` defined here\n+    //~| NOTE `E` defined here\n+    //~| NOTE `E` defined here\n+    //~| NOTE `E` defined here\n+    //~| NOTE `E` defined here\n+    //~| NOTE  not covered\n+    //~| NOTE  not covered\n+    //~| NOTE  not covered\n+    //~| NOTE  not covered\n+    //~| NOTE  not covered\n+    //~| NOTE  not covered\n     C\n     //~^ not covered\n     //~| not covered\n@@ -30,43 +36,70 @@ enum E {\n fn by_val(e: E) {\n     let e1 = e.clone();\n     match e1 { //~ ERROR non-exhaustive patterns: `B` and `C` not covered\n+        //~^ NOTE patterns `B` and `C` not covered\n+        //~| NOTE the matched value is of type `E`\n         E::A => {}\n     }\n \n     let E::A = e; //~ ERROR refutable pattern in local binding: `B` and `C` not covered\n+    //~^ NOTE patterns `B` and `C` not covered\n+    //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n+    //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+    //~| NOTE the matched value is of type `E`\n }\n \n fn by_ref_once(e: &E) {\n     match e { //~ ERROR non-exhaustive patterns: `&B` and `&C` not covered\n+    //~^ NOTE patterns `&B` and `&C` not covered\n+    //~| NOTE the matched value is of type `&E`\n         E::A => {}\n     }\n \n     let E::A = e; //~ ERROR refutable pattern in local binding: `&B` and `&C` not covered\n+    //~^ NOTE patterns `&B` and `&C` not covered\n+    //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n+    //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+    //~| NOTE the matched value is of type `&E`\n }\n \n fn by_ref_thrice(e: & &mut &E) {\n     match e { //~ ERROR non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n+    //~^ NOTE patterns `&&mut &B` and `&&mut &C` not covered\n+    //~| NOTE the matched value is of type `&&mut &E`\n         E::A => {}\n     }\n \n     let E::A = e;\n     //~^ ERROR refutable pattern in local binding: `&&mut &B` and `&&mut &C` not covered\n+    //~| NOTE patterns `&&mut &B` and `&&mut &C` not covered\n+    //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n+    //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+    //~| NOTE the matched value is of type `&&mut &E`\n }\n \n enum Opt {\n-//~^ `Opt` defined here\n-//~| `Opt` defined here\n+    //~^ NOTE\n+    //~| NOTE\n     Some(u8),\n     None,\n-    //~^ not covered\n+    //~^ NOTE `Opt` defined here\n+    //~| NOTE `Opt` defined here\n+    //~| NOTE not covered\n+    //~| NOTE not covered\n }\n \n fn ref_pat(e: Opt) {\n     match e {//~ ERROR non-exhaustive patterns: `None` not covered\n+        //~^ NOTE pattern `None` not covered\n+        //~| NOTE the matched value is of type `Opt`\n         Opt::Some(ref _x) => {}\n     }\n \n     let Opt::Some(ref _x) = e; //~ ERROR refutable pattern in local binding: `None` not covered\n+    //~^ NOTE the matched value is of type `Opt`\n+    //~| NOTE pattern `None` not covered\n+    //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n+    //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n }\n \n fn main() {}"}, {"sha": "9a2029cc257069af0215c8b38b3c4c64ec76cd41", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-defined-here.stderr", "status": "modified", "additions": 113, "deletions": 141, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,24 +1,20 @@\n error[E0004]: non-exhaustive patterns: `B` and `C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:32:11\n-   |\n-LL | / enum E {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     B,\n-   | |     - not covered\n-...  |\n-LL | |     C\n-   | |     - not covered\n-...  |\n-LL | |\n-LL | | }\n-   | |_- `E` defined here\n-...\n-LL |       match e1 {\n-   |             ^^ patterns `B` and `C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:38:11\n+   |\n+LL |     match e1 {\n+   |           ^^ patterns `B` and `C` not covered\n+   |\n+note: `E` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:14:5\n    |\n+LL | enum E {\n+   |      -\n+...\n+LL |     B,\n+   |     ^ not covered\n+...\n+LL |     C\n+   |     ^ not covered\n    = note: the matched value is of type `E`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -27,55 +23,47 @@ LL +         B | C => todo!()\n    |\n \n error[E0005]: refutable pattern in local binding: `B` and `C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:36:9\n-   |\n-LL | / enum E {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     B,\n-   | |     - not covered\n-...  |\n-LL | |     C\n-   | |     - not covered\n-...  |\n-LL | |\n-LL | | }\n-   | |_- `E` defined here\n-...\n-LL |       let E::A = e;\n-   |           ^^^^ patterns `B` and `C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:44:9\n+   |\n+LL |     let E::A = e;\n+   |         ^^^^ patterns `B` and `C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `E` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+   |\n+LL | enum E {\n+   |      -\n+...\n+LL |     B,\n+   |     ^ not covered\n+...\n+LL |     C\n+   |     ^ not covered\n    = note: the matched value is of type `E`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let E::A = e { /* */ }\n    |     ~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0004]: non-exhaustive patterns: `&B` and `&C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:40:11\n-   |\n-LL | / enum E {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     B,\n-   | |     - not covered\n-...  |\n-LL | |     C\n-   | |     - not covered\n-...  |\n-LL | |\n-LL | | }\n-   | |_- `E` defined here\n-...\n-LL |       match e {\n-   |             ^ patterns `&B` and `&C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:52:11\n+   |\n+LL |     match e {\n+   |           ^ patterns `&B` and `&C` not covered\n    |\n+note: `E` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+   |\n+LL | enum E {\n+   |      -\n+...\n+LL |     B,\n+   |     ^ not covered\n+...\n+LL |     C\n+   |     ^ not covered\n    = note: the matched value is of type `&E`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -84,55 +72,47 @@ LL +         &B | &C => todo!()\n    |\n \n error[E0005]: refutable pattern in local binding: `&B` and `&C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:44:9\n+  --> $DIR/non-exhaustive-defined-here.rs:58:9\n    |\n-LL | / enum E {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     B,\n-   | |     - not covered\n-...  |\n-LL | |     C\n-   | |     - not covered\n-...  |\n-LL | |\n-LL | | }\n-   | |_- `E` defined here\n-...\n-LL |       let E::A = e;\n-   |           ^^^^ patterns `&B` and `&C` not covered\n+LL |     let E::A = e;\n+   |         ^^^^ patterns `&B` and `&C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `E` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+   |\n+LL | enum E {\n+   |      -\n+...\n+LL |     B,\n+   |     ^ not covered\n+...\n+LL |     C\n+   |     ^ not covered\n    = note: the matched value is of type `&E`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let E::A = e { /* */ }\n    |     ~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0004]: non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:48:11\n-   |\n-LL | / enum E {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     B,\n-   | |     - not covered\n-...  |\n-LL | |     C\n-   | |     - not covered\n-...  |\n-LL | |\n-LL | | }\n-   | |_- `E` defined here\n-...\n-LL |       match e {\n-   |             ^ patterns `&&mut &B` and `&&mut &C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:66:11\n+   |\n+LL |     match e {\n+   |           ^ patterns `&&mut &B` and `&&mut &C` not covered\n    |\n+note: `E` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+   |\n+LL | enum E {\n+   |      -\n+...\n+LL |     B,\n+   |     ^ not covered\n+...\n+LL |     C\n+   |     ^ not covered\n    = note: the matched value is of type `&&mut &E`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -141,50 +121,44 @@ LL +         &&mut &B | &&mut &C => todo!()\n    |\n \n error[E0005]: refutable pattern in local binding: `&&mut &B` and `&&mut &C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:52:9\n-   |\n-LL | / enum E {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     B,\n-   | |     - not covered\n-...  |\n-LL | |     C\n-   | |     - not covered\n-...  |\n-LL | |\n-LL | | }\n-   | |_- `E` defined here\n-...\n-LL |       let E::A = e;\n-   |           ^^^^ patterns `&&mut &B` and `&&mut &C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:72:9\n+   |\n+LL |     let E::A = e;\n+   |         ^^^^ patterns `&&mut &B` and `&&mut &C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `E` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+   |\n+LL | enum E {\n+   |      -\n+...\n+LL |     B,\n+   |     ^ not covered\n+...\n+LL |     C\n+   |     ^ not covered\n    = note: the matched value is of type `&&mut &E`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let E::A = e { /* */ }\n    |\n \n error[E0004]: non-exhaustive patterns: `None` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:65:11\n-   |\n-LL | / enum Opt {\n-LL | |\n-LL | |\n-LL | |     Some(u8),\n-LL | |     None,\n-   | |     ---- not covered\n-LL | |\n-LL | | }\n-   | |_- `Opt` defined here\n-...\n-LL |       match e {\n-   |             ^ pattern `None` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:92:11\n+   |\n+LL |     match e {\n+   |           ^ pattern `None` not covered\n    |\n+note: `Opt` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:84:5\n+   |\n+LL | enum Opt {\n+   |      ---\n+...\n+LL |     None,\n+   |     ^^^^ not covered\n    = note: the matched value is of type `Opt`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -193,23 +167,21 @@ LL +         None => todo!()\n    |\n \n error[E0005]: refutable pattern in local binding: `None` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:69:9\n-   |\n-LL | / enum Opt {\n-LL | |\n-LL | |\n-LL | |     Some(u8),\n-LL | |     None,\n-   | |     ---- not covered\n-LL | |\n-LL | | }\n-   | |_- `Opt` defined here\n-...\n-LL |       let Opt::Some(ref _x) = e;\n-   |           ^^^^^^^^^^^^^^^^^ pattern `None` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:98:9\n+   |\n+LL |     let Opt::Some(ref _x) = e;\n+   |         ^^^^^^^^^^^^^^^^^ pattern `None` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Opt` defined here\n+  --> $DIR/non-exhaustive-defined-here.rs:84:5\n+   |\n+LL | enum Opt {\n+   |      ---\n+...\n+LL |     None,\n+   |     ^^^^ not covered\n    = note: the matched value is of type `Opt`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "312b9ad89cc34ce603f3865368fd43095ecb6392", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match-nested.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -14,15 +14,14 @@ LL +         (Some(&[]), Err(_)) => todo!()\n error[E0004]: non-exhaustive patterns: `A(C)` not covered\n   --> $DIR/non-exhaustive-match-nested.rs:15:11\n    |\n-LL | enum T { A(U), B }\n-   | ------------------\n-   | |        |\n-   | |        not covered\n-   | `T` defined here\n-...\n LL |     match x {\n    |           ^ pattern `A(C)` not covered\n    |\n+note: `T` defined here\n+  --> $DIR/non-exhaustive-match-nested.rs:1:10\n+   |\n+LL | enum T { A(U), B }\n+   |      -   ^ not covered\n    = note: the matched value is of type `T`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "15e967ae4dabac9b502db79354a4702919ab1a07", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,15 +1,14 @@\n error[E0004]: non-exhaustive patterns: `A` not covered\n   --> $DIR/non-exhaustive-match.rs:7:11\n    |\n-LL | enum T { A, B }\n-   | ---------------\n-   | |        |\n-   | |        not covered\n-   | `T` defined here\n-...\n LL |     match x { T::B => { } }\n    |           ^ pattern `A` not covered\n    |\n+note: `T` defined here\n+  --> $DIR/non-exhaustive-match.rs:3:10\n+   |\n+LL | enum T { A, B }\n+   |      -   ^ not covered\n    = note: the matched value is of type `T`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -35,11 +34,18 @@ error[E0004]: non-exhaustive patterns: `Some(_)` not covered\n LL |     match Some(10) {\n    |           ^^^^^^^^ pattern `Some(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ---- not covered\n-   |\n+note: `Option<i32>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL | / pub enum Option<T> {\n+LL | |     /// No value.\n+LL | |     #[lang = \"None\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   | |     ^^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Option<i32>`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -76,15 +82,14 @@ LL +       (A, A) | (B, B) => todo!()\n error[E0004]: non-exhaustive patterns: `B` not covered\n   --> $DIR/non-exhaustive-match.rs:22:11\n    |\n-LL | enum T { A, B }\n-   | ---------------\n-   | |           |\n-   | |           not covered\n-   | `T` defined here\n-...\n LL |     match T::A {\n    |           ^^^^ pattern `B` not covered\n    |\n+note: `T` defined here\n+  --> $DIR/non-exhaustive-match.rs:3:13\n+   |\n+LL | enum T { A, B }\n+   |      -      ^ not covered\n    = note: the matched value is of type `T`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "8883829aadf40284f27c203771a89700fdd9ec09", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-pattern-witness.stderr", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,15 +1,14 @@\n error[E0004]: non-exhaustive patterns: `Foo { first: false, second: Some([_, _, _, _]) }` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:7:11\n    |\n-LL | / struct Foo {\n-LL | |     first: bool,\n-LL | |     second: Option<[usize; 4]>\n-LL | | }\n-   | |_- `Foo` defined here\n-...\n-LL |       match (Foo { first: true, second: None }) {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo { first: false, second: Some([_, _, _, _]) }` not covered\n+LL |     match (Foo { first: true, second: None }) {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo { first: false, second: Some([_, _, _, _]) }` not covered\n+   |\n+note: `Foo` defined here\n+  --> $DIR/non-exhaustive-pattern-witness.rs:1:8\n    |\n+LL | struct Foo {\n+   |        ^^^\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -20,17 +19,16 @@ LL +         Foo { first: false, second: Some([_, _, _, _]) } => todo!()\n error[E0004]: non-exhaustive patterns: `Red` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:23:11\n    |\n-LL | / enum Color {\n-LL | |     Red,\n-   | |     --- not covered\n-LL | |     Green,\n-LL | |     CustomRGBA { a: bool, r: u8, g: u8, b: u8 }\n-LL | | }\n-   | |_- `Color` defined here\n-...\n-LL |       match Color::Red {\n-   |             ^^^^^^^^^^ pattern `Red` not covered\n+LL |     match Color::Red {\n+   |           ^^^^^^^^^^ pattern `Red` not covered\n    |\n+note: `Color` defined here\n+  --> $DIR/non-exhaustive-pattern-witness.rs:17:5\n+   |\n+LL | enum Color {\n+   |      -----\n+LL |     Red,\n+   |     ^^^ not covered\n    = note: the matched value is of type `Color`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -41,18 +39,19 @@ LL +         Red => todo!()\n error[E0004]: non-exhaustive patterns: `East`, `South` and `West` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:35:11\n    |\n-LL | / enum Direction {\n-LL | |     North, East, South, West\n-   | |            ----  -----  ---- not covered\n-   | |            |     |\n-   | |            |     not covered\n-   | |            not covered\n-LL | | }\n-   | |_- `Direction` defined here\n-...\n-LL |       match Direction::North {\n-   |             ^^^^^^^^^^^^^^^^ patterns `East`, `South` and `West` not covered\n+LL |     match Direction::North {\n+   |           ^^^^^^^^^^^^^^^^ patterns `East`, `South` and `West` not covered\n+   |\n+note: `Direction` defined here\n+  --> $DIR/non-exhaustive-pattern-witness.rs:31:12\n    |\n+LL | enum Direction {\n+   |      ---------\n+LL |     North, East, South, West\n+   |            ^^^^  ^^^^^  ^^^^ not covered\n+   |            |     |\n+   |            |     not covered\n+   |            not covered\n    = note: the matched value is of type `Direction`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -63,14 +62,14 @@ LL +         East | South | West => todo!()\n error[E0004]: non-exhaustive patterns: `Second`, `Third`, `Fourth` and 8 more not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:46:11\n    |\n-LL | / enum ExcessiveEnum {\n-LL | |     First, Second, Third, Fourth, Fifth, Sixth, Seventh, Eighth, Ninth, Tenth, Eleventh, Twelfth\n-LL | | }\n-   | |_- `ExcessiveEnum` defined here\n-...\n-LL |       match ExcessiveEnum::First {\n-   |             ^^^^^^^^^^^^^^^^^^^^ patterns `Second`, `Third`, `Fourth` and 8 more not covered\n+LL |     match ExcessiveEnum::First {\n+   |           ^^^^^^^^^^^^^^^^^^^^ patterns `Second`, `Third`, `Fourth` and 8 more not covered\n+   |\n+note: `ExcessiveEnum` defined here\n+  --> $DIR/non-exhaustive-pattern-witness.rs:41:6\n    |\n+LL | enum ExcessiveEnum {\n+   |      ^^^^^^^^^^^^^\n    = note: the matched value is of type `ExcessiveEnum`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -81,17 +80,17 @@ LL +         _ => todo!()\n error[E0004]: non-exhaustive patterns: `CustomRGBA { a: true, .. }` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:54:11\n    |\n-LL | / enum Color {\n-LL | |     Red,\n-LL | |     Green,\n-LL | |     CustomRGBA { a: bool, r: u8, g: u8, b: u8 }\n-   | |     ---------- not covered\n-LL | | }\n-   | |_- `Color` defined here\n-...\n-LL |       match Color::Red {\n-   |             ^^^^^^^^^^ pattern `CustomRGBA { a: true, .. }` not covered\n+LL |     match Color::Red {\n+   |           ^^^^^^^^^^ pattern `CustomRGBA { a: true, .. }` not covered\n    |\n+note: `Color` defined here\n+  --> $DIR/non-exhaustive-pattern-witness.rs:19:5\n+   |\n+LL | enum Color {\n+   |      -----\n+...\n+LL |     CustomRGBA { a: bool, r: u8, g: u8, b: u8 }\n+   |     ^^^^^^^^^^ not covered\n    = note: the matched value is of type `Color`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "5956c6b66158a34688de54e474acdba1bb103131", "filename": "src/test/ui/pattern/usefulness/stable-gated-patterns.stderr", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstable-gated-patterns.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,11 +4,19 @@ error[E0004]: non-exhaustive patterns: `Stable2` and `_` not covered\n LL |     match Foo::Stable {\n    |           ^^^^^^^^^^^ patterns `Stable2` and `_` not covered\n    |\n-  ::: $DIR/auxiliary/unstable.rs:9:5\n-   |\n-LL |     Stable2,\n-   |     ------- not covered\n-   |\n+note: `Foo` defined here\n+  --> $DIR/auxiliary/unstable.rs:9:5\n+   |\n+LL | / pub enum Foo {\n+LL | |     #[stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n+LL | |     Stable,\n+LL | |     #[stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n+LL | |     Stable2,\n+   | |     ^^^^^^^ not covered\n+LL | |     #[unstable(feature = \"unstable_test_feature\", issue = \"none\")]\n+LL | |     Unstable,\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -22,6 +30,17 @@ error[E0004]: non-exhaustive patterns: `_` not covered\n LL |     match Foo::Stable {\n    |           ^^^^^^^^^^^ pattern `_` not covered\n    |\n+note: `Foo` defined here\n+  --> $DIR/auxiliary/unstable.rs:5:1\n+   |\n+LL | / pub enum Foo {\n+LL | |     #[stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n+LL | |     Stable,\n+LL | |     #[stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n+...  |\n+LL | |     Unstable,\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "596fb13e92b3006e570914942e59a4c247d2ebef", "filename": "src/test/ui/pattern/usefulness/struct-like-enum-nonexhaustive.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,16 +1,16 @@\n error[E0004]: non-exhaustive patterns: `B { x: Some(_) }` not covered\n   --> $DIR/struct-like-enum-nonexhaustive.rs:8:11\n    |\n-LL | / enum A {\n-LL | |     B { x: Option<isize> },\n-   | |     - not covered\n-LL | |     C\n-LL | | }\n-   | |_- `A` defined here\n-...\n-LL |       match x {\n-   |             ^ pattern `B { x: Some(_) }` not covered\n+LL |     match x {\n+   |           ^ pattern `B { x: Some(_) }` not covered\n    |\n+note: `A` defined here\n+  --> $DIR/struct-like-enum-nonexhaustive.rs:2:5\n+   |\n+LL | enum A {\n+   |      -\n+LL |     B { x: Option<isize> },\n+   |     ^ not covered\n    = note: the matched value is of type `A`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "a1b233d3f98ff6513f34df8ac6445e4a27efecca", "filename": "src/test/ui/pattern/usefulness/tuple-struct-nonexhaustive.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,12 +1,14 @@\n error[E0004]: non-exhaustive patterns: `Foo(_, _)` not covered\n   --> $DIR/tuple-struct-nonexhaustive.rs:5:11\n    |\n-LL | struct Foo(isize, isize);\n-   | ------------------------- `Foo` defined here\n-...\n LL |     match x {\n    |           ^ pattern `Foo(_, _)` not covered\n    |\n+note: `Foo` defined here\n+  --> $DIR/tuple-struct-nonexhaustive.rs:1:8\n+   |\n+LL | struct Foo(isize, isize);\n+   |        ^^^\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "3f987fc2ef5bf928f1dc188a5cb7633c1a97c454", "filename": "src/test/ui/pattern/usefulness/unstable-gated-patterns.stderr", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funstable-gated-patterns.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,11 +4,18 @@ error[E0004]: non-exhaustive patterns: `Unstable` not covered\n LL |     match Foo::Stable {\n    |           ^^^^^^^^^^^ pattern `Unstable` not covered\n    |\n-  ::: $DIR/auxiliary/unstable.rs:11:5\n-   |\n-LL |     Unstable,\n-   |     -------- not covered\n+note: `Foo` defined here\n+  --> $DIR/auxiliary/unstable.rs:11:5\n    |\n+LL | / pub enum Foo {\n+LL | |     #[stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n+LL | |     Stable,\n+LL | |     #[stable(feature = \"stable_test_feature\", since = \"1.0.0\")]\n+...  |\n+LL | |     Unstable,\n+   | |     ^^^^^^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Foo`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "ded3cf3ad1d44ab24ed3bd39afea4f634b965b7d", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,13 +4,20 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n LL |     let Ok(x) = res;\n    |         ^^^^^ pattern `Err(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n-   |     --- not covered\n-   |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Result<u32, &R>` defined here\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+   |\n+LL | / pub enum Result<T, E> {\n+LL | |     /// Contains the success value\n+LL | |     #[lang = \"Ok\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   | |     ^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Result<u32, &R>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "8809f13079cec21357d9be2d6e4850a3130275ad", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum.stderr", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,6 +4,11 @@ error[E0004]: non-exhaustive patterns: type `EmptyNonExhaustiveEnum` is non-empt\n LL |     match x {}\n    |           ^\n    |\n+note: `EmptyNonExhaustiveEnum` defined here\n+  --> $DIR/auxiliary/enums.rs:18:1\n+   |\n+LL | pub enum EmptyNonExhaustiveEnum {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `EmptyNonExhaustiveEnum`, which is marked as non-exhaustive\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -18,6 +23,15 @@ error[E0004]: non-exhaustive patterns: `_` not covered\n LL |     match enum_unit {\n    |           ^^^^^^^^^ pattern `_` not covered\n    |\n+note: `NonExhaustiveEnum` defined here\n+  --> $DIR/auxiliary/enums.rs:4:1\n+   |\n+LL | / pub enum NonExhaustiveEnum {\n+LL | |     Unit,\n+LL | |     Tuple(u32),\n+LL | |     Struct { field: u32 },\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `NonExhaustiveEnum`, which is marked as non-exhaustive\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -31,6 +45,15 @@ error[E0004]: non-exhaustive patterns: `_` not covered\n LL |     match enum_unit {};\n    |           ^^^^^^^^^ pattern `_` not covered\n    |\n+note: `NonExhaustiveEnum` defined here\n+  --> $DIR/auxiliary/enums.rs:4:1\n+   |\n+LL | / pub enum NonExhaustiveEnum {\n+LL | |     Unit,\n+LL | |     Tuple(u32),\n+LL | |     Struct { field: u32 },\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `NonExhaustiveEnum`, which is marked as non-exhaustive\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "6da7950a7a072dbe49639819ff7e5d33f37e698c", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum_same_crate_empty_match.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -13,22 +13,22 @@ LL | #![deny(unreachable_patterns)]\n error[E0004]: non-exhaustive patterns: `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/enum_same_crate_empty_match.rs:33:11\n    |\n-LL | / pub enum NonExhaustiveEnum {\n-LL | |     Unit,\n-   | |     ---- not covered\n-LL | |\n-LL | |     Tuple(u32),\n-   | |     ----- not covered\n-LL | |\n-LL | |     Struct { field: u32 }\n-   | |     ------ not covered\n-LL | |\n-LL | | }\n-   | |_- `NonExhaustiveEnum` defined here\n-...\n-LL |       match NonExhaustiveEnum::Unit {}\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ patterns `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n+LL |     match NonExhaustiveEnum::Unit {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^ patterns `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n    |\n+note: `NonExhaustiveEnum` defined here\n+  --> $DIR/enum_same_crate_empty_match.rs:5:5\n+   |\n+LL | pub enum NonExhaustiveEnum {\n+   |          -----------------\n+LL |     Unit,\n+   |     ^^^^ not covered\n+LL |\n+LL |     Tuple(u32),\n+   |     ^^^^^ not covered\n+LL |\n+LL |     Struct { field: u32 }\n+   |     ^^^^^^ not covered\n    = note: the matched value is of type `NonExhaustiveEnum`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -40,22 +40,22 @@ LL +     }\n error[E0004]: non-exhaustive patterns: `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/enum_same_crate_empty_match.rs:35:11\n    |\n-LL | / pub enum NormalEnum {\n-LL | |     Unit,\n-   | |     ---- not covered\n-LL | |\n-LL | |     Tuple(u32),\n-   | |     ----- not covered\n-LL | |\n-LL | |     Struct { field: u32 }\n-   | |     ------ not covered\n-LL | |\n-LL | | }\n-   | |_- `NormalEnum` defined here\n-...\n-LL |       match NormalEnum::Unit {}\n-   |             ^^^^^^^^^^^^^^^^ patterns `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n+LL |     match NormalEnum::Unit {}\n+   |           ^^^^^^^^^^^^^^^^ patterns `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n+   |\n+note: `NormalEnum` defined here\n+  --> $DIR/enum_same_crate_empty_match.rs:14:5\n    |\n+LL | pub enum NormalEnum {\n+   |          ----------\n+LL |     Unit,\n+   |     ^^^^ not covered\n+LL |\n+LL |     Tuple(u32),\n+   |     ^^^^^ not covered\n+LL |\n+LL |     Struct { field: u32 }\n+   |     ^^^^^^ not covered\n    = note: the matched value is of type `NormalEnum`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "ed9f3cf1982cdc8ff59799d773756a5b05be87f6", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match.stderr", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,6 +4,11 @@ error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedEnum` is non-emp\n LL |     match x {}\n    |           ^\n    |\n+note: `IndirectUninhabitedEnum` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:26:1\n+   |\n+LL | pub struct IndirectUninhabitedEnum(UninhabitedEnum);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedEnum`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -18,6 +23,11 @@ error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedStruct` is non-e\n LL |     match x {}\n    |           ^\n    |\n+note: `IndirectUninhabitedStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:28:1\n+   |\n+LL | pub struct IndirectUninhabitedStruct(UninhabitedStruct);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedStruct`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -32,6 +42,11 @@ error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedTupleStruct` is\n LL |     match x {}\n    |           ^\n    |\n+note: `IndirectUninhabitedTupleStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:30:1\n+   |\n+LL | pub struct IndirectUninhabitedTupleStruct(UninhabitedTupleStruct);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedTupleStruct`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -46,6 +61,11 @@ error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedVariants` is non\n LL |     match x {}\n    |           ^\n    |\n+note: `IndirectUninhabitedVariants` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:32:1\n+   |\n+LL | pub struct IndirectUninhabitedVariants(UninhabitedVariants);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedVariants`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "f8751c89e14721f3434a0acb0fc487d34eb02854", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_same_crate.stderr", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,12 +1,14 @@\n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedEnum` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:34:11\n    |\n-LL | pub struct IndirectUninhabitedEnum(UninhabitedEnum);\n-   | ---------------------------------------------------- `IndirectUninhabitedEnum` defined here\n-...\n LL |     match x {}\n    |           ^\n    |\n+note: `IndirectUninhabitedEnum` defined here\n+  --> $DIR/indirect_match_same_crate.rs:20:12\n+   |\n+LL | pub struct IndirectUninhabitedEnum(UninhabitedEnum);\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedEnum`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -18,12 +20,14 @@ LL ~     }\n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedStruct` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:38:11\n    |\n-LL | pub struct IndirectUninhabitedStruct(UninhabitedStruct);\n-   | -------------------------------------------------------- `IndirectUninhabitedStruct` defined here\n-...\n LL |     match x {}\n    |           ^\n    |\n+note: `IndirectUninhabitedStruct` defined here\n+  --> $DIR/indirect_match_same_crate.rs:22:12\n+   |\n+LL | pub struct IndirectUninhabitedStruct(UninhabitedStruct);\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedStruct`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -35,12 +39,14 @@ LL ~     }\n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedTupleStruct` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:42:11\n    |\n-LL | pub struct IndirectUninhabitedTupleStruct(UninhabitedTupleStruct);\n-   | ------------------------------------------------------------------ `IndirectUninhabitedTupleStruct` defined here\n-...\n LL |     match x {}\n    |           ^\n    |\n+note: `IndirectUninhabitedTupleStruct` defined here\n+  --> $DIR/indirect_match_same_crate.rs:24:12\n+   |\n+LL | pub struct IndirectUninhabitedTupleStruct(UninhabitedTupleStruct);\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedTupleStruct`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -52,12 +58,14 @@ LL ~     }\n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedVariants` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:48:11\n    |\n-LL | pub struct IndirectUninhabitedVariants(UninhabitedVariants);\n-   | ------------------------------------------------------------ `IndirectUninhabitedVariants` defined here\n-...\n LL |     match x {}\n    |           ^\n    |\n+note: `IndirectUninhabitedVariants` defined here\n+  --> $DIR/indirect_match_same_crate.rs:26:12\n+   |\n+LL | pub struct IndirectUninhabitedVariants(UninhabitedVariants);\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedVariants`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "828f57cad0f9f47d5979cfc942dc3292f83e81bd", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_with_exhaustive_patterns.stderr", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,6 +4,11 @@ error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedEnum` is non-emp\n LL |     match x {}\n    |           ^\n    |\n+note: `IndirectUninhabitedEnum` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:26:1\n+   |\n+LL | pub struct IndirectUninhabitedEnum(UninhabitedEnum);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedEnum`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -18,6 +23,11 @@ error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedStruct` is non-e\n LL |     match x {}\n    |           ^\n    |\n+note: `IndirectUninhabitedStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:28:1\n+   |\n+LL | pub struct IndirectUninhabitedStruct(UninhabitedStruct);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedStruct`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -32,6 +42,11 @@ error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedTupleStruct` is\n LL |     match x {}\n    |           ^\n    |\n+note: `IndirectUninhabitedTupleStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:30:1\n+   |\n+LL | pub struct IndirectUninhabitedTupleStruct(UninhabitedTupleStruct);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedTupleStruct`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -46,6 +61,11 @@ error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedVariants` is non\n LL |     match x {}\n    |           ^\n    |\n+note: `IndirectUninhabitedVariants` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:32:1\n+   |\n+LL | pub struct IndirectUninhabitedVariants(UninhabitedVariants);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `IndirectUninhabitedVariants`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "82760df19d6ca95e483b94399956f432aeac7369", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match.stderr", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,6 +4,12 @@ error[E0004]: non-exhaustive patterns: type `UninhabitedEnum` is non-empty\n LL |     match x {}\n    |           ^\n    |\n+note: `UninhabitedEnum` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:5:1\n+   |\n+LL | / pub enum UninhabitedEnum {\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `UninhabitedEnum`, which is marked as non-exhaustive\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -18,6 +24,13 @@ error[E0004]: non-exhaustive patterns: type `UninhabitedStruct` is non-empty\n LL |     match x {}\n    |           ^\n    |\n+note: `UninhabitedStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:9:1\n+   |\n+LL | / pub struct UninhabitedStruct {\n+LL | |     _priv: !,\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `UninhabitedStruct`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -32,6 +45,11 @@ error[E0004]: non-exhaustive patterns: type `UninhabitedTupleStruct` is non-empt\n LL |     match x {}\n    |           ^\n    |\n+note: `UninhabitedTupleStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:14:1\n+   |\n+LL | pub struct UninhabitedTupleStruct(!);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `UninhabitedTupleStruct`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -46,13 +64,16 @@ error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covere\n LL |     match x {}\n    |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n    |\n-  ::: $DIR/auxiliary/uninhabited.rs:17:23\n-   |\n-LL |     #[non_exhaustive] Tuple(!),\n-   |                       ----- not covered\n-LL |     #[non_exhaustive] Struct { x: ! }\n-   |                       ------ not covered\n+note: `UninhabitedVariants` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:17:23\n    |\n+LL | / pub enum UninhabitedVariants {\n+LL | |     #[non_exhaustive] Tuple(!),\n+   | |                       ^^^^^ not covered\n+LL | |     #[non_exhaustive] Struct { x: ! }\n+   | |                       ^^^^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `UninhabitedVariants`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "4aea7da6b38ece50ad2d45edca12eeddcf9c6506", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_same_crate.stderr", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,14 +1,14 @@\n error[E0004]: non-exhaustive patterns: type `UninhabitedStruct` is non-empty\n   --> $DIR/match_same_crate.rs:30:11\n    |\n-LL | / pub struct UninhabitedStruct {\n-LL | |     _priv: !,\n-LL | | }\n-   | |_- `UninhabitedStruct` defined here\n-...\n-LL |       match x {}\n-   |             ^\n+LL |     match x {}\n+   |           ^\n    |\n+note: `UninhabitedStruct` defined here\n+  --> $DIR/match_same_crate.rs:8:12\n+   |\n+LL | pub struct UninhabitedStruct {\n+   |            ^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `UninhabitedStruct`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -20,12 +20,14 @@ LL ~     }\n error[E0004]: non-exhaustive patterns: type `UninhabitedTupleStruct` is non-empty\n   --> $DIR/match_same_crate.rs:34:11\n    |\n-LL | pub struct UninhabitedTupleStruct(!);\n-   | ------------------------------------- `UninhabitedTupleStruct` defined here\n-...\n LL |     match x {}\n    |           ^\n    |\n+note: `UninhabitedTupleStruct` defined here\n+  --> $DIR/match_same_crate.rs:13:12\n+   |\n+LL | pub struct UninhabitedTupleStruct(!);\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `UninhabitedTupleStruct`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -37,17 +39,18 @@ LL ~     }\n error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/match_same_crate.rs:38:11\n    |\n-LL | / pub enum UninhabitedVariants {\n-LL | |     #[non_exhaustive] Tuple(!),\n-   | |                       ----- not covered\n-LL | |     #[non_exhaustive] Struct { x: ! }\n-   | |                       ------ not covered\n-LL | | }\n-   | |_- `UninhabitedVariants` defined here\n-...\n-LL |       match x {}\n-   |             ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n+LL |     match x {}\n+   |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n+   |\n+note: `UninhabitedVariants` defined here\n+  --> $DIR/match_same_crate.rs:16:23\n    |\n+LL | pub enum UninhabitedVariants {\n+   |          -------------------\n+LL |     #[non_exhaustive] Tuple(!),\n+   |                       ^^^^^ not covered\n+LL |     #[non_exhaustive] Struct { x: ! }\n+   |                       ^^^^^^ not covered\n    = note: the matched value is of type `UninhabitedVariants`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "7414cd8a058ac86e9f4331a6068d50f7a189ae33", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_with_exhaustive_patterns.stderr", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,6 +4,12 @@ error[E0004]: non-exhaustive patterns: type `UninhabitedEnum` is non-empty\n LL |     match x {}\n    |           ^\n    |\n+note: `UninhabitedEnum` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:5:1\n+   |\n+LL | / pub enum UninhabitedEnum {\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `UninhabitedEnum`, which is marked as non-exhaustive\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -18,6 +24,13 @@ error[E0004]: non-exhaustive patterns: type `UninhabitedStruct` is non-empty\n LL |     match x {}\n    |           ^\n    |\n+note: `UninhabitedStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:9:1\n+   |\n+LL | / pub struct UninhabitedStruct {\n+LL | |     _priv: !,\n+LL | | }\n+   | |_^\n    = note: the matched value is of type `UninhabitedStruct`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -32,6 +45,11 @@ error[E0004]: non-exhaustive patterns: type `UninhabitedTupleStruct` is non-empt\n LL |     match x {}\n    |           ^\n    |\n+note: `UninhabitedTupleStruct` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:14:1\n+   |\n+LL | pub struct UninhabitedTupleStruct(!);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `UninhabitedTupleStruct`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -46,13 +64,16 @@ error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covere\n LL |     match x {}\n    |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n    |\n-  ::: $DIR/auxiliary/uninhabited.rs:17:23\n-   |\n-LL |     #[non_exhaustive] Tuple(!),\n-   |                       ----- not covered\n-LL |     #[non_exhaustive] Struct { x: ! }\n-   |                       ------ not covered\n+note: `UninhabitedVariants` defined here\n+  --> $DIR/auxiliary/uninhabited.rs:17:23\n    |\n+LL | / pub enum UninhabitedVariants {\n+LL | |     #[non_exhaustive] Tuple(!),\n+   | |                       ^^^^^ not covered\n+LL | |     #[non_exhaustive] Struct { x: ! }\n+   | |                       ^^^^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `UninhabitedVariants`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |"}, {"sha": "ad19c34a40a110237acf2eba71de2aa30ea23c74", "filename": "src/test/ui/uninhabited/uninhabited-irrefutable.stderr", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -1,20 +1,18 @@\n error[E0005]: refutable pattern in local binding: `A(_)` not covered\n   --> $DIR/uninhabited-irrefutable.rs:27:9\n    |\n-LL | / enum Foo {\n-LL | |     A(foo::SecretlyEmpty),\n-   | |     - not covered\n-LL | |     B(foo::NotSoSecretlyEmpty),\n-LL | |     C(NotSoSecretlyEmpty),\n-LL | |     D(u32),\n-LL | | }\n-   | |_- `Foo` defined here\n-...\n-LL |       let Foo::D(_y) = x;\n-   |           ^^^^^^^^^^ pattern `A(_)` not covered\n+LL |     let Foo::D(_y) = x;\n+   |         ^^^^^^^^^^ pattern `A(_)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Foo` defined here\n+  --> $DIR/uninhabited-irrefutable.rs:19:5\n+   |\n+LL | enum Foo {\n+   |      ---\n+LL |     A(foo::SecretlyEmpty),\n+   |     ^ not covered\n    = note: the matched value is of type `Foo`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "26d02006bf618907aaf5fa68c0069592de9f37b5", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab4feea50dd3e0109a30488300c213ca074d01a6/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=ab4feea50dd3e0109a30488300c213ca074d01a6", "patch": "@@ -4,11 +4,18 @@ error[E0004]: non-exhaustive patterns: `Err(_)` not covered\n LL |     let _ = match x {\n    |                   ^ pattern `Err(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n-   |     --- not covered\n-   |\n+note: `Result<u32, &Void>` defined here\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+   |\n+LL | / pub enum Result<T, E> {\n+LL | |     /// Contains the success value\n+LL | |     #[lang = \"Ok\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   | |     ^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Result<u32, &Void>`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -19,12 +26,14 @@ LL ~         Err(_) => todo!(),\n error[E0004]: non-exhaustive patterns: type `&Void` is non-empty\n   --> $DIR/uninhabited-matches-feature-gated.rs:15:19\n    |\n-LL | enum Void {}\n-   | ------------ `Void` defined here\n-...\n LL |     let _ = match x {};\n    |                   ^\n    |\n+note: `Void` defined here\n+  --> $DIR/uninhabited-matches-feature-gated.rs:2:6\n+   |\n+LL | enum Void {}\n+   |      ^^^^\n    = note: the matched value is of type `&Void`\n    = note: references are always considered inhabited\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n@@ -81,11 +90,18 @@ error[E0004]: non-exhaustive patterns: `Err(_)` not covered\n LL |     let _ = match x {\n    |                   ^ pattern `Err(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n-   |     --- not covered\n-   |\n+note: `Result<u32, Void>` defined here\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+   |\n+LL | / pub enum Result<T, E> {\n+LL | |     /// Contains the success value\n+LL | |     #[lang = \"Ok\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   | |     ^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Result<u32, Void>`\n help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    |\n@@ -99,13 +115,20 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n LL |     let Ok(x) = x;\n    |         ^^^^^ pattern `Err(_)` not covered\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n-   |     --- not covered\n-   |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Result<u32, Void>` defined here\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+   |\n+LL | / pub enum Result<T, E> {\n+LL | |     /// Contains the success value\n+LL | |     #[lang = \"Ok\"]\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+...  |\n+LL | |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   | |     ^^^ not covered\n+LL | | }\n+   | |_-\n    = note: the matched value is of type `Result<u32, Void>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}]}