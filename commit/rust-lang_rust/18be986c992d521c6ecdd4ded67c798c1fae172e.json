{"sha": "18be986c992d521c6ecdd4ded67c798c1fae172e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YmU5ODZjOTkyZDUyMWM2ZWNkZDRkZWQ2N2M3OThjMWZhZTE3MmU=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-10-10T15:45:52Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-10-11T17:28:36Z"}, "message": "clean up the `Rc`/`RcMut` types and move to libstd", "tree": {"sha": "b66dc8808a73efcea640cd536a28b64d99dc372f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b66dc8808a73efcea640cd536a28b64d99dc372f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18be986c992d521c6ecdd4ded67c798c1fae172e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18be986c992d521c6ecdd4ded67c798c1fae172e", "html_url": "https://github.com/rust-lang/rust/commit/18be986c992d521c6ecdd4ded67c798c1fae172e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18be986c992d521c6ecdd4ded67c798c1fae172e/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e192b6d7c59607233cc2e455c8d177cd37226162", "url": "https://api.github.com/repos/rust-lang/rust/commits/e192b6d7c59607233cc2e455c8d177cd37226162", "html_url": "https://github.com/rust-lang/rust/commit/e192b6d7c59607233cc2e455c8d177cd37226162"}], "stats": {"total": 203, "additions": 114, "deletions": 89}, "files": [{"sha": "1305535dc503035de854d7b55a499518b4e1a753", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18be986c992d521c6ecdd4ded67c798c1fae172e/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18be986c992d521c6ecdd4ded67c798c1fae172e/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=18be986c992d521c6ecdd4ded67c798c1fae172e", "patch": "@@ -46,7 +46,6 @@ pub use std::os;\n \n pub mod c_vec;\n pub mod io_util;\n-pub mod rc;\n \n // Concurrency\n "}, {"sha": "50dff380f007e2f01bcf4e9f280f97e7a45441c5", "filename": "src/libstd/rc.rs", "status": "renamed", "additions": 89, "deletions": 81, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/18be986c992d521c6ecdd4ded67c798c1fae172e/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18be986c992d521c6ecdd4ded67c798c1fae172e/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=18be986c992d521c6ecdd4ded67c798c1fae172e", "patch": "@@ -8,31 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(missing_doc)];\n+/** Task-local reference counted boxes\n \n-/** Task-local reference counted smart pointers\n+The `Rc` type provides shared ownership of an immutable value. Destruction is deterministic, and\n+will occur as soon as the last owner is gone. It is marked as non-sendable because it avoids the\n+overhead of atomic reference counting.\n \n-Task-local reference counted smart pointers are an alternative to managed boxes with deterministic\n-destruction. They are restricted to containing types that are either `Send` or `Freeze` (or both) to\n-prevent cycles.\n-\n-Neither `Rc<T>` or `RcMut<T>` is ever `Send` and `RcMut<T>` is never `Freeze`. If `T` is `Freeze`, a\n-cycle cannot be created with `Rc<T>` because there is no way to modify it after creation.\n+The `RcMut` type provides shared ownership of a mutable value. Since multiple owners prevent\n+inherited mutability, a dynamic freezing check is used to maintain the invariant that an `&mut`\n+reference is a unique handle and the type is marked as non-`Freeze`.\n \n */\n \n-\n-use std::cast;\n-use std::ptr;\n-use std::unstable::intrinsics;\n-\n-// Convert ~T into *mut T without dropping it\n-#[inline]\n-unsafe fn owned_to_raw<T>(mut box: ~T) -> *mut T {\n-    let ptr = ptr::to_mut_unsafe_ptr(box);\n-    intrinsics::forget(box);\n-    ptr\n-}\n+use ptr::RawPtr;\n+use unstable::intrinsics::transmute;\n+use ops::Drop;\n+use kinds::{Freeze, Send};\n+use clone::{Clone, DeepClone};\n \n struct RcBox<T> {\n     value: T,\n@@ -43,50 +35,38 @@ struct RcBox<T> {\n #[unsafe_no_drop_flag]\n #[no_send]\n pub struct Rc<T> {\n-    priv ptr: *mut RcBox<T>,\n-}\n-\n-impl<T> Rc<T> {\n-    unsafe fn new(value: T) -> Rc<T> {\n-        Rc{ptr: owned_to_raw(~RcBox{value: value, count: 1})}\n-    }\n-}\n-\n-impl<T: Send> Rc<T> {\n-    pub fn from_send(value: T) -> Rc<T> {\n-        unsafe { Rc::new(value) }\n-    }\n+    priv ptr: *mut RcBox<T>\n }\n \n impl<T: Freeze> Rc<T> {\n-    pub fn from_freeze(value: T) -> Rc<T> {\n-        unsafe { Rc::new(value) }\n+    /// Construct a new reference-counted box from a `Freeze` value\n+    #[inline]\n+    pub fn new(value: T) -> Rc<T> {\n+        unsafe {\n+            Rc::new_unchecked(value)\n+        }\n     }\n }\n \n impl<T> Rc<T> {\n+    /// Unsafety construct a new reference-counted box from any value.\n+    ///\n+    /// If the type is not `Freeze`, the `Rc` box will incorrectly still be considered as a `Freeze`\n+    /// type. It is also possible to create cycles, which will leak, and may interact poorly with\n+    /// managed pointers.\n     #[inline]\n-    pub fn borrow<'r>(&'r self) -> &'r T {\n-        unsafe { cast::copy_lifetime(self, &(*self.ptr).value) }\n+    pub unsafe fn new_unchecked(value: T) -> Rc<T> {\n+        Rc{ptr: transmute(~RcBox{value: value, count: 1})}\n     }\n-}\n \n-#[unsafe_destructor]\n-impl<T> Drop for Rc<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            if self.ptr.is_not_null() {\n-                (*self.ptr).count -= 1;\n-                if (*self.ptr).count == 0 {\n-                    let _: ~T = cast::transmute(self.ptr);\n-                }\n-            }\n-        }\n+    /// Borrow the value contained in the reference-counted box\n+    #[inline]\n+    pub fn borrow<'r>(&'r self) -> &'r T {\n+        unsafe { &(*self.ptr).value }\n     }\n }\n \n impl<T> Clone for Rc<T> {\n-    /// Return a shallow copy of the reference counted pointer.\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n         unsafe {\n@@ -97,56 +77,75 @@ impl<T> Clone for Rc<T> {\n }\n \n impl<T: DeepClone> DeepClone for Rc<T> {\n-    /// Return a deep copy of the reference counted pointer.\n     #[inline]\n     fn deep_clone(&self) -> Rc<T> {\n-        unsafe { Rc::new(self.borrow().deep_clone()) }\n+        unsafe { Rc::new_unchecked(self.borrow().deep_clone()) }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for Rc<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            if self.ptr.is_not_null() {\n+                (*self.ptr).count -= 1;\n+                if (*self.ptr).count == 0 {\n+                    let _: ~RcBox<T> = transmute(self.ptr);\n+                }\n+            }\n+        }\n     }\n }\n \n #[cfg(test)]\n mod test_rc {\n     use super::*;\n-    use std::cell::Cell;\n+    use cell::Cell;\n \n     #[test]\n     fn test_clone() {\n-        let x = Rc::from_send(Cell::new(5));\n-        let y = x.clone();\n-        do x.borrow().with_mut_ref |inner| {\n-            *inner = 20;\n+        unsafe {\n+            let x = Rc::new_unchecked(Cell::new(5));\n+            let y = x.clone();\n+            do x.borrow().with_mut_ref |inner| {\n+                *inner = 20;\n+            }\n+            assert_eq!(y.borrow().take(), 20);\n         }\n-        assert_eq!(y.borrow().take(), 20);\n     }\n \n     #[test]\n     fn test_deep_clone() {\n-        let x = Rc::from_send(Cell::new(5));\n-        let y = x.deep_clone();\n-        do x.borrow().with_mut_ref |inner| {\n-            *inner = 20;\n+        unsafe {\n+            let x = Rc::new_unchecked(Cell::new(5));\n+            let y = x.deep_clone();\n+            do x.borrow().with_mut_ref |inner| {\n+                *inner = 20;\n+            }\n+            assert_eq!(y.borrow().take(), 5);\n         }\n-        assert_eq!(y.borrow().take(), 5);\n     }\n \n     #[test]\n     fn test_simple() {\n-        let x = Rc::from_freeze(5);\n+        let x = Rc::new(5);\n         assert_eq!(*x.borrow(), 5);\n     }\n \n     #[test]\n     fn test_simple_clone() {\n-        let x = Rc::from_freeze(5);\n+        let x = Rc::new(5);\n         let y = x.clone();\n         assert_eq!(*x.borrow(), 5);\n         assert_eq!(*y.borrow(), 5);\n     }\n \n     #[test]\n     fn test_destructor() {\n-        let x = Rc::from_send(~5);\n-        assert_eq!(**x.borrow(), 5);\n+        unsafe {\n+            let x = Rc::new_unchecked(~5);\n+            assert_eq!(**x.borrow(), 5);\n+        }\n     }\n }\n \n@@ -171,21 +170,30 @@ pub struct RcMut<T> {\n     priv ptr: *mut RcMutBox<T>,\n }\n \n-impl<T> RcMut<T> {\n-    unsafe fn new(value: T) -> RcMut<T> {\n-        RcMut{ptr: owned_to_raw(~RcMutBox{value: value, count: 1, borrow: Nothing})}\n+impl<T: Freeze> RcMut<T> {\n+    /// Construct a new mutable reference-counted box from a `Freeze` value\n+    #[inline]\n+    pub fn new(value: T) -> RcMut<T> {\n+        unsafe { RcMut::new_unchecked(value) }\n     }\n }\n \n impl<T: Send> RcMut<T> {\n+    /// Construct a new mutable reference-counted box from a `Send` value\n+    #[inline]\n     pub fn from_send(value: T) -> RcMut<T> {\n-        unsafe { RcMut::new(value) }\n+        unsafe { RcMut::new_unchecked(value) }\n     }\n }\n \n-impl<T: Freeze> RcMut<T> {\n-    pub fn from_freeze(value: T) -> RcMut<T> {\n-        unsafe { RcMut::new(value) }\n+impl<T> RcMut<T> {\n+    /// Unsafety construct a new mutable reference-counted box from any value.\n+    ///\n+    /// It is possible to create cycles, which will leak, and may interact\n+    /// poorly with managed pointers.\n+    #[inline]\n+    pub unsafe fn new_unchecked(value: T) -> RcMut<T> {\n+        RcMut{ptr: transmute(~RcMutBox{value: value, count: 1, borrow: Nothing})}\n     }\n }\n \n@@ -223,7 +231,7 @@ impl<T> Drop for RcMut<T> {\n             if self.ptr.is_not_null() {\n                 (*self.ptr).count -= 1;\n                 if (*self.ptr).count == 0 {\n-                    let _: ~T = cast::transmute(self.ptr);\n+                    let _: ~RcMutBox<T> = transmute(self.ptr);\n                 }\n             }\n         }\n@@ -247,7 +255,7 @@ impl<T: DeepClone> DeepClone for RcMut<T> {\n     fn deep_clone(&self) -> RcMut<T> {\n         do self.with_borrow |x| {\n             // FIXME: #6497: should avoid freeze (slow)\n-            unsafe { RcMut::new(x.deep_clone()) }\n+            unsafe { RcMut::new_unchecked(x.deep_clone()) }\n         }\n     }\n }\n@@ -270,7 +278,7 @@ mod test_rc_mut {\n \n     #[test]\n     fn test_deep_clone() {\n-        let x = RcMut::from_freeze(5);\n+        let x = RcMut::new(5);\n         let y = x.deep_clone();\n         do x.with_mut_borrow |value| {\n             *value = 20;\n@@ -298,7 +306,7 @@ mod test_rc_mut {\n \n     #[test]\n     fn modify() {\n-        let x = RcMut::from_freeze(5);\n+        let x = RcMut::new(5);\n         let y = x.clone();\n \n         do y.with_mut_borrow |a| {\n@@ -320,7 +328,7 @@ mod test_rc_mut {\n \n     #[test]\n     fn release_mutable() {\n-        let x = RcMut::from_freeze(5);\n+        let x = RcMut::new(5);\n         do x.with_mut_borrow |_| {}\n         do x.with_borrow |_| {}\n     }\n@@ -340,7 +348,7 @@ mod test_rc_mut {\n     #[test]\n     #[should_fail]\n     fn mutable_dupe() {\n-        let x = RcMut::from_freeze(5);\n+        let x = RcMut::new(5);\n         let y = x.clone();\n \n         do x.with_mut_borrow |_| {\n@@ -364,7 +372,7 @@ mod test_rc_mut {\n     #[test]\n     #[should_fail]\n     fn restore_freeze() {\n-        let x = RcMut::from_freeze(5);\n+        let x = RcMut::new(5);\n         let y = x.clone();\n \n         do x.with_borrow |_| {", "previous_filename": "src/libextra/rc.rs"}, {"sha": "d35f26785dc450fbdfeab42bf05fd905835be221", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18be986c992d521c6ecdd4ded67c798c1fae172e/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18be986c992d521c6ecdd4ded67c798c1fae172e/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=18be986c992d521c6ecdd4ded67c798c1fae172e", "patch": "@@ -132,6 +132,7 @@ pub mod ptr;\n pub mod owned;\n pub mod managed;\n pub mod borrow;\n+pub mod rc;\n \n \n /* Core language traits */"}, {"sha": "5f39aac19af0de8ddd535e86e1f76aa35cddf0bd", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18be986c992d521c6ecdd4ded67c798c1fae172e/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18be986c992d521c6ecdd4ded67c798c1fae172e/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=18be986c992d521c6ecdd4ded67c798c1fae172e", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern mod extra;\n-use extra::rc::RcMut;\n+use std::rc::RcMut;\n \n trait Foo\n {\n@@ -37,7 +36,7 @@ struct A\n fn main()\n {\n     let a = A {v: ~B{v: None} as ~Foo}; //~ ERROR cannot pack type `~B`, which does not fulfill `Send`\n-    let v = RcMut::from_freeze(a); //~ ERROR instantiating a type parameter with an incompatible type\n+    let v = RcMut::new(a); //~ ERROR instantiating a type parameter with an incompatible type\n     let w = v.clone();\n     v.with_mut_borrow(|p| {p.v.set(w.clone());})\n }"}, {"sha": "d884ff7f231685f503ce41bf77fafe7918cad5c7", "filename": "src/test/compile-fail/no_send-rc.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/18be986c992d521c6ecdd4ded67c798c1fae172e/src%2Ftest%2Fcompile-fail%2Fno_send-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18be986c992d521c6ecdd4ded67c798c1fae172e/src%2Ftest%2Fcompile-fail%2Fno_send-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_send-rc.rs?ref=18be986c992d521c6ecdd4ded67c798c1fae172e", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+fn bar<T: Send>(_: T) {}\n+\n+fn main() {\n+    let x = Rc::new(5);\n+    bar(x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<int>`, which does not fulfill `Send`\n+}"}, {"sha": "fce1f592c626859fc908aff66caa75ac6b799199", "filename": "src/test/compile-fail/rcmut-not-const-and-not-owned.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18be986c992d521c6ecdd4ded67c798c1fae172e/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18be986c992d521c6ecdd4ded67c798c1fae172e/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs?ref=18be986c992d521c6ecdd4ded67c798c1fae172e", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern mod extra;\n+use std::rc::RcMut;\n \n fn o<T: Send>(_: &T) {}\n fn c<T: Freeze>(_: &T) {}\n \n fn main() {\n-    let x = extra::rc::RcMut::from_send(0);\n-    o(&x); //~ ERROR instantiating a type parameter with an incompatible type `extra::rc::RcMut<int>`, which does not fulfill `Send`\n-    c(&x); //~ ERROR instantiating a type parameter with an incompatible type `extra::rc::RcMut<int>`, which does not fulfill `Freeze`\n+    let x = RcMut::from_send(0);\n+    o(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::RcMut<int>`, which does not fulfill `Send`\n+    c(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::RcMut<int>`, which does not fulfill `Freeze`\n }"}]}