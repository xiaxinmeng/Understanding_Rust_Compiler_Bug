{"sha": "2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYzRjMWZmMzFiNmVmMGNhMTg0OGE3Y2UxMmY5ODFiOTNkY2RlZDA=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-10-21T11:57:12Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-10-21T11:57:12Z"}, "message": "Simplify cfg representation", "tree": {"sha": "e4a775098e38cf46b48a6daad58566e652d97536", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4a775098e38cf46b48a6daad58566e652d97536"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0", "html_url": "https://github.com/rust-lang/rust/commit/2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20d369a826e8f333cba1988325480a49a730f00e", "url": "https://api.github.com/repos/rust-lang/rust/commits/20d369a826e8f333cba1988325480a49a730f00e", "html_url": "https://github.com/rust-lang/rust/commit/20d369a826e8f333cba1988325480a49a730f00e"}], "stats": {"total": 72, "additions": 41, "deletions": 31}, "files": [{"sha": "db3655b7483a530aef16fb1c5deee652d63e101f", "filename": "crates/cfg/src/cfg_expr.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs?ref=2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0", "patch": "@@ -6,26 +6,42 @@ use std::slice::Iter as SliceIter;\n \n use tt::SmolStr;\n \n+/// A simple configuration value passed in from the outside.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum CfgAtom {\n+    /// eg. `#[cfg(test)]`\n+    Flag(SmolStr),\n+    /// eg. `#[cfg(target_os = \"linux\")]`\n+    ///\n+    /// Note that a key can have multiple values that are all considered \"active\" at the same time.\n+    /// For example, `#[cfg(target_feature = \"sse\")]` and `#[cfg(target_feature = \"sse2\")]`.\n+    KeyValue { key: SmolStr, value: SmolStr },\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum CfgExpr {\n     Invalid,\n-    Atom(SmolStr),\n-    KeyValue { key: SmolStr, value: SmolStr },\n+    Atom(CfgAtom),\n     All(Vec<CfgExpr>),\n     Any(Vec<CfgExpr>),\n     Not(Box<CfgExpr>),\n }\n \n+impl From<CfgAtom> for CfgExpr {\n+    fn from(atom: CfgAtom) -> Self {\n+        CfgExpr::Atom(atom)\n+    }\n+}\n+\n impl CfgExpr {\n     pub fn parse(tt: &tt::Subtree) -> CfgExpr {\n         next_cfg_expr(&mut tt.token_trees.iter()).unwrap_or(CfgExpr::Invalid)\n     }\n     /// Fold the cfg by querying all basic `Atom` and `KeyValue` predicates.\n-    pub fn fold(&self, query: &dyn Fn(&SmolStr, Option<&SmolStr>) -> bool) -> Option<bool> {\n+    pub fn fold(&self, query: &dyn Fn(&CfgAtom) -> bool) -> Option<bool> {\n         match self {\n             CfgExpr::Invalid => None,\n-            CfgExpr::Atom(name) => Some(query(name, None)),\n-            CfgExpr::KeyValue { key, value } => Some(query(key, Some(value))),\n+            CfgExpr::Atom(atom) => Some(query(atom)),\n             CfgExpr::All(preds) => {\n                 preds.iter().try_fold(true, |s, pred| Some(s && pred.fold(query)?))\n             }\n@@ -54,7 +70,7 @@ fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n                     // FIXME: escape? raw string?\n                     let value =\n                         SmolStr::new(literal.text.trim_start_matches('\"').trim_end_matches('\"'));\n-                    CfgExpr::KeyValue { key: name, value }\n+                    CfgAtom::KeyValue { key: name, value }.into()\n                 }\n                 _ => return Some(CfgExpr::Invalid),\n             }\n@@ -70,7 +86,7 @@ fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n                 _ => CfgExpr::Invalid,\n             }\n         }\n-        _ => CfgExpr::Atom(name),\n+        _ => CfgAtom::Flag(name).into(),\n     };\n \n     // Eat comma separator\n@@ -101,22 +117,22 @@ mod tests {\n \n     #[test]\n     fn test_cfg_expr_parser() {\n-        assert_parse_result(\"#![cfg(foo)]\", CfgExpr::Atom(\"foo\".into()));\n-        assert_parse_result(\"#![cfg(foo,)]\", CfgExpr::Atom(\"foo\".into()));\n+        assert_parse_result(\"#![cfg(foo)]\", CfgAtom::Flag(\"foo\".into()).into());\n+        assert_parse_result(\"#![cfg(foo,)]\", CfgAtom::Flag(\"foo\".into()).into());\n         assert_parse_result(\n             \"#![cfg(not(foo))]\",\n-            CfgExpr::Not(Box::new(CfgExpr::Atom(\"foo\".into()))),\n+            CfgExpr::Not(Box::new(CfgAtom::Flag(\"foo\".into()).into())),\n         );\n         assert_parse_result(\"#![cfg(foo(bar))]\", CfgExpr::Invalid);\n \n         // Only take the first\n-        assert_parse_result(r#\"#![cfg(foo, bar = \"baz\")]\"#, CfgExpr::Atom(\"foo\".into()));\n+        assert_parse_result(r#\"#![cfg(foo, bar = \"baz\")]\"#, CfgAtom::Flag(\"foo\".into()).into());\n \n         assert_parse_result(\n             r#\"#![cfg(all(foo, bar = \"baz\"))]\"#,\n             CfgExpr::All(vec![\n-                CfgExpr::Atom(\"foo\".into()),\n-                CfgExpr::KeyValue { key: \"bar\".into(), value: \"baz\".into() },\n+                CfgAtom::Flag(\"foo\".into()).into(),\n+                CfgAtom::KeyValue { key: \"bar\".into(), value: \"baz\".into() }.into(),\n             ]),\n         );\n \n@@ -126,7 +142,7 @@ mod tests {\n                 CfgExpr::Not(Box::new(CfgExpr::Invalid)),\n                 CfgExpr::All(vec![]),\n                 CfgExpr::Invalid,\n-                CfgExpr::KeyValue { key: \"bar\".into(), value: \"baz\".into() },\n+                CfgAtom::KeyValue { key: \"bar\".into(), value: \"baz\".into() }.into(),\n             ]),\n         );\n     }"}, {"sha": "35f540ac3a76b8a82034a3d5663dc3a881d5572e", "filename": "crates/cfg/src/lib.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0/crates%2Fcfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0/crates%2Fcfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Flib.rs?ref=2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0", "patch": "@@ -5,7 +5,7 @@ mod cfg_expr;\n use rustc_hash::FxHashSet;\n use tt::SmolStr;\n \n-pub use cfg_expr::CfgExpr;\n+pub use cfg_expr::{CfgAtom, CfgExpr};\n \n /// Configuration options used for conditional compilition on items with `cfg` attributes.\n /// We have two kind of options in different namespaces: atomic options like `unix`, and\n@@ -19,33 +19,25 @@ pub use cfg_expr::CfgExpr;\n /// See: https://doc.rust-lang.org/reference/conditional-compilation.html#set-configuration-options\n #[derive(Debug, Clone, PartialEq, Eq, Default)]\n pub struct CfgOptions {\n-    atoms: FxHashSet<SmolStr>,\n-    key_values: FxHashSet<(SmolStr, SmolStr)>,\n+    enabled: FxHashSet<CfgAtom>,\n }\n \n impl CfgOptions {\n     pub fn check(&self, cfg: &CfgExpr) -> Option<bool> {\n-        cfg.fold(&|key, value| match value {\n-            None => self.atoms.contains(key),\n-            Some(value) => self.key_values.contains(&(key.clone(), value.clone())),\n-        })\n+        cfg.fold(&|atom| self.enabled.contains(atom))\n     }\n \n     pub fn insert_atom(&mut self, key: SmolStr) {\n-        self.atoms.insert(key);\n+        self.enabled.insert(CfgAtom::Flag(key));\n     }\n \n     pub fn insert_key_value(&mut self, key: SmolStr, value: SmolStr) {\n-        self.key_values.insert((key, value));\n+        self.enabled.insert(CfgAtom::KeyValue { key, value });\n     }\n \n     pub fn append(&mut self, other: &CfgOptions) {\n-        for atom in &other.atoms {\n-            self.atoms.insert(atom.clone());\n-        }\n-\n-        for (key, value) in &other.key_values {\n-            self.key_values.insert((key.clone(), value.clone()));\n+        for atom in &other.enabled {\n+            self.enabled.insert(atom.clone());\n         }\n     }\n }"}, {"sha": "7da9354643b2f07017298901521644f64e281e56", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0", "patch": "@@ -1,6 +1,6 @@\n //! See `CargoTargetSpec`\n \n-use cfg::CfgExpr;\n+use cfg::{CfgAtom, CfgExpr};\n use ide::{FileId, RunnableKind, TestId};\n use project_model::{self, TargetKind};\n use vfs::AbsPathBuf;\n@@ -160,7 +160,9 @@ impl CargoTargetSpec {\n /// Fill minimal features needed\n fn required_features(cfg_expr: &CfgExpr, features: &mut Vec<String>) {\n     match cfg_expr {\n-        CfgExpr::KeyValue { key, value } if key == \"feature\" => features.push(value.to_string()),\n+        CfgExpr::Atom(CfgAtom::KeyValue { key, value }) if key == \"feature\" => {\n+            features.push(value.to_string())\n+        }\n         CfgExpr::All(preds) => {\n             preds.iter().for_each(|cfg| required_features(cfg, features));\n         }"}]}