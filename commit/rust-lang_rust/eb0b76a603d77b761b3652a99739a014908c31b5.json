{"sha": "eb0b76a603d77b761b3652a99739a014908c31b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMGI3NmE2MDNkNzdiNzYxYjM2NTJhOTk3MzlhMDE0OTA4YzMxYjU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-04T15:58:56Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-04T15:58:56Z"}, "message": "rustc: check_const: cleanup/simplify the code.", "tree": {"sha": "757115a270bab6cca1d426b782d98178b136c71f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/757115a270bab6cca1d426b782d98178b136c71f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb0b76a603d77b761b3652a99739a014908c31b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb0b76a603d77b761b3652a99739a014908c31b5", "html_url": "https://github.com/rust-lang/rust/commit/eb0b76a603d77b761b3652a99739a014908c31b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb0b76a603d77b761b3652a99739a014908c31b5/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5df03285e97d146a9f40d496835875876741f5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5df03285e97d146a9f40d496835875876741f5c", "html_url": "https://github.com/rust-lang/rust/commit/b5df03285e97d146a9f40d496835875876741f5c"}], "stats": {"total": 106, "additions": 40, "deletions": 66}, "files": [{"sha": "309e3aa8f05f3f2d1afda396ebdc8a7f212763a9", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 40, "deletions": 66, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/eb0b76a603d77b761b3652a99739a014908c31b5/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb0b76a603d77b761b3652a99739a014908c31b5/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=eb0b76a603d77b761b3652a99739a014908c31b5", "patch": "@@ -14,8 +14,7 @@ use middle::ty;\n use util::ppaux;\n \n use syntax::ast;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n+use syntax::visit::{self, Visitor};\n \n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n@@ -36,24 +35,39 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     {\n         self.with_const(true, f);\n     }\n-    fn outside_const<F>(&mut self, f: F) where\n-        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>),\n-    {\n-        self.with_const(false, f);\n-    }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item) {\n-        check_item(self, i);\n+        match i.node {\n+            ast::ItemStatic(_, _, ref ex) |\n+            ast::ItemConst(_, ref ex) => {\n+                self.inside_const(|v| v.visit_expr(&**ex));\n+            }\n+            ast::ItemEnum(ref enum_definition, _) => {\n+                self.inside_const(|v| {\n+                    for var in enum_definition.variants.iter() {\n+                        if let Some(ref ex) = var.node.disr_expr {\n+                            v.visit_expr(&**ex);\n+                        }\n+                    }\n+                });\n+            }\n+            _ => self.with_const(false, |v| visit::walk_item(v, i))\n+        }\n     }\n     fn visit_pat(&mut self, p: &ast::Pat) {\n-        check_pat(self, p);\n+        let is_const = match p.node {\n+            ast::PatLit(_) | ast::PatRange(..) => true,\n+            _ => false\n+        };\n+        self.with_const(is_const, |v| visit::walk_pat(v, p))\n     }\n     fn visit_expr(&mut self, ex: &ast::Expr) {\n-        if check_expr(self, ex) {\n-            visit::walk_expr(self, ex);\n+        if self.in_const {\n+            check_expr(self, ex);\n         }\n+        visit::walk_expr(self, ex);\n     }\n }\n \n@@ -63,40 +77,12 @@ pub fn check_crate(tcx: &ty::ctxt) {\n     tcx.sess.abort_if_errors();\n }\n \n-fn check_item(v: &mut CheckCrateVisitor, it: &ast::Item) {\n-    match it.node {\n-        ast::ItemStatic(_, _, ref ex) |\n-        ast::ItemConst(_, ref ex) => {\n-            v.inside_const(|v| v.visit_expr(&**ex));\n-        }\n-        ast::ItemEnum(ref enum_definition, _) => {\n-            for var in (*enum_definition).variants.iter() {\n-                for ex in var.node.disr_expr.iter() {\n-                    v.inside_const(|v| v.visit_expr(&**ex));\n-                }\n-            }\n-        }\n-        _ => v.outside_const(|v| visit::walk_item(v, it))\n-    }\n-}\n-\n-fn check_pat(v: &mut CheckCrateVisitor, p: &ast::Pat) {\n-    let is_const = match p.node {\n-        ast::PatLit(_) | ast::PatRange(..) => true,\n-        _ => false\n-    };\n-    v.with_const(is_const, |v| visit::walk_pat(v, p))\n-}\n-\n-fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) -> bool {\n-    if !v.in_const { return true }\n-\n+fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n     match e.node {\n         ast::ExprUnary(ast::UnDeref, _) => {}\n         ast::ExprUnary(ast::UnUniq, _) => {\n             span_err!(v.tcx.sess, e.span, E0010,\n                       \"cannot do allocations in constant expressions\");\n-            return false;\n         }\n         ast::ExprBinary(..) | ast::ExprUnary(..) => {\n             let method_call = ty::MethodCall::expr(e.id);\n@@ -135,29 +121,22 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) -> bool {\n                           \"paths in constants may only refer to items without \\\n                            type parameters\");\n             }\n-            match v.tcx.def_map.borrow().get(&e.id) {\n-                Some(&DefStatic(..)) |\n-                Some(&DefConst(..)) |\n-                Some(&DefFn(..)) |\n-                Some(&DefVariant(_, _, _)) |\n-                Some(&DefStruct(_)) => { }\n+            match v.tcx.def_map.borrow()[e.id] {\n+                DefStatic(..) | DefConst(..) |\n+                DefFn(..) | DefStruct(_) |\n+                DefVariant(_, _, _) => {}\n \n-                Some(&def) => {\n+                def => {\n                     debug!(\"(checking const) found bad def: {}\", def);\n                     span_err!(v.tcx.sess, e.span, E0014,\n                               \"paths in constants may only refer to constants \\\n                                or functions\");\n                 }\n-                None => {\n-                    v.tcx.sess.span_bug(e.span, \"unbound path in const?!\");\n-                }\n             }\n         }\n         ast::ExprCall(ref callee, _) => {\n-            match v.tcx.def_map.borrow().get(&callee.id) {\n-                Some(&DefStruct(..)) |\n-                Some(&DefVariant(..)) => {}    // OK.\n-\n+            match v.tcx.def_map.borrow()[callee.id] {\n+                DefStruct(..) | DefVariant(..) => {}    // OK.\n                 _ => {\n                     span_err!(v.tcx.sess, e.span, E0015,\n                               \"function calls in constants are limited to \\\n@@ -173,9 +152,9 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) -> bool {\n                               \"blocks in constants are limited to items and \\\n                                tail expressions\");\n                 match stmt.node {\n-                    ast::StmtDecl(ref span, _) => {\n-                        match span.node {\n-                            ast::DeclLocal(_) => block_span_err(span.span),\n+                    ast::StmtDecl(ref decl, _) => {\n+                        match decl.node {\n+                            ast::DeclLocal(_) => block_span_err(decl.span),\n \n                             // Item statements are allowed\n                             ast::DeclItem(_) => {}\n@@ -189,9 +168,8 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) -> bool {\n                     }\n                 }\n             }\n-            match block.expr {\n-                Some(ref expr) => { check_expr(v, &**expr); }\n-                None => {}\n+            if let Some(ref expr) = block.expr {\n+                check_expr(v, &**expr);\n             }\n         }\n         ast::ExprVec(_) |\n@@ -215,11 +193,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) -> bool {\n             }\n         }\n \n-        _ => {\n-            span_err!(v.tcx.sess, e.span, E0019,\n-                      \"constant contains unimplemented expression type\");\n-            return false;\n-        }\n+        _ => span_err!(v.tcx.sess, e.span, E0019,\n+                       \"constant contains unimplemented expression type\")\n     }\n-    true\n }"}]}