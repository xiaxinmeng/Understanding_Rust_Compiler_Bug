{"sha": "4828c88af6132085c709db79500ac130669f72e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MjhjODhhZjYxMzIwODVjNzA5ZGI3OTUwMGFjMTMwNjY5ZjcyZTI=", "commit": {"author": {"name": "Pascal Hertleif", "email": "killercup@gmail.com", "date": "2015-09-12T10:13:24Z"}, "committer": {"name": "Pascal Hertleif", "email": "killercup@gmail.com", "date": "2015-09-12T10:13:24Z"}, "message": "Nomicon: Fix Links\n\nThe style `[name][]` does not work with Pandoc, whereas `[name]` does.\nI hope hoedown accepts this as well.", "tree": {"sha": "ec0ad9a4afd644851893870f1b483583a028138b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec0ad9a4afd644851893870f1b483583a028138b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4828c88af6132085c709db79500ac130669f72e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4828c88af6132085c709db79500ac130669f72e2", "html_url": "https://github.com/rust-lang/rust/commit/4828c88af6132085c709db79500ac130669f72e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4828c88af6132085c709db79500ac130669f72e2/comments", "author": {"login": "killercup", "id": 20063, "node_id": "MDQ6VXNlcjIwMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/20063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killercup", "html_url": "https://github.com/killercup", "followers_url": "https://api.github.com/users/killercup/followers", "following_url": "https://api.github.com/users/killercup/following{/other_user}", "gists_url": "https://api.github.com/users/killercup/gists{/gist_id}", "starred_url": "https://api.github.com/users/killercup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killercup/subscriptions", "organizations_url": "https://api.github.com/users/killercup/orgs", "repos_url": "https://api.github.com/users/killercup/repos", "events_url": "https://api.github.com/users/killercup/events{/privacy}", "received_events_url": "https://api.github.com/users/killercup/received_events", "type": "User", "site_admin": false}, "committer": {"login": "killercup", "id": 20063, "node_id": "MDQ6VXNlcjIwMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/20063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killercup", "html_url": "https://github.com/killercup", "followers_url": "https://api.github.com/users/killercup/followers", "following_url": "https://api.github.com/users/killercup/following{/other_user}", "gists_url": "https://api.github.com/users/killercup/gists{/gist_id}", "starred_url": "https://api.github.com/users/killercup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killercup/subscriptions", "organizations_url": "https://api.github.com/users/killercup/orgs", "repos_url": "https://api.github.com/users/killercup/repos", "events_url": "https://api.github.com/users/killercup/events{/privacy}", "received_events_url": "https://api.github.com/users/killercup/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d89a10b0a6ae1763ade69ff2fff04aa84cb766b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d89a10b0a6ae1763ade69ff2fff04aa84cb766b6", "html_url": "https://github.com/rust-lang/rust/commit/d89a10b0a6ae1763ade69ff2fff04aa84cb766b6"}], "stats": {"total": 16, "additions": 8, "deletions": 8}, "files": [{"sha": "91abdab9778f2fc55a9ed9a72474f95334464599", "filename": "src/doc/nomicon/destructors.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4828c88af6132085c709db79500ac130669f72e2/src%2Fdoc%2Fnomicon%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/4828c88af6132085c709db79500ac130669f72e2/src%2Fdoc%2Fnomicon%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdestructors.md?ref=4828c88af6132085c709db79500ac130669f72e2", "patch": "@@ -52,7 +52,7 @@ impl<T> Drop for Box<T> {\n ```\n \n and this works fine because when Rust goes to drop the `ptr` field it just sees\n-a [Unique][] that has no actual `Drop` implementation. Similarly nothing can\n+a [Unique] that has no actual `Drop` implementation. Similarly nothing can\n use-after-free the `ptr` because when drop exits, it becomes inacessible.\n \n However this wouldn't work:"}, {"sha": "52582e8750b4690daa82520ba8a3f3066bda496d", "filename": "src/doc/nomicon/meet-safe-and-unsafe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4828c88af6132085c709db79500ac130669f72e2/src%2Fdoc%2Fnomicon%2Fmeet-safe-and-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/4828c88af6132085c709db79500ac130669f72e2/src%2Fdoc%2Fnomicon%2Fmeet-safe-and-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fmeet-safe-and-unsafe.md?ref=4828c88af6132085c709db79500ac130669f72e2", "patch": "@@ -60,8 +60,8 @@ Unlike C, Undefined Behaviour is pretty limited in scope in Rust. All the core\n language cares about is preventing the following things:\n \n * Dereferencing null or dangling pointers\n-* Reading [uninitialized memory][]\n-* Breaking the [pointer aliasing rules][]\n+* Reading [uninitialized memory]\n+* Breaking the [pointer aliasing rules]\n * Producing invalid primitive values:\n     * dangling/null references\n     * a `bool` that isn't 0 or 1"}, {"sha": "71da743f35d3cbc92784c5001eb0a601931cef9c", "filename": "src/doc/nomicon/other-reprs.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4828c88af6132085c709db79500ac130669f72e2/src%2Fdoc%2Fnomicon%2Fother-reprs.md", "raw_url": "https://github.com/rust-lang/rust/raw/4828c88af6132085c709db79500ac130669f72e2/src%2Fdoc%2Fnomicon%2Fother-reprs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fother-reprs.md?ref=4828c88af6132085c709db79500ac130669f72e2", "patch": "@@ -26,7 +26,7 @@ still consumes a byte of space.\n * DSTs, tuples, and tagged unions are not a concept in C and as such are never\n FFI safe.\n \n-* **If the type would have any [drop flags][], they will still be added**\n+* **If the type would have any [drop flags], they will still be added**\n \n * This is equivalent to one of `repr(u*)` (see the next section) for enums. The\n chosen size is the default enum size for the target platform's C ABI. Note that"}, {"sha": "3cb02d31b175f5b526cefaea78c0413783fc9a5e", "filename": "src/doc/nomicon/safe-unsafe-meaning.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4828c88af6132085c709db79500ac130669f72e2/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md", "raw_url": "https://github.com/rust-lang/rust/raw/4828c88af6132085c709db79500ac130669f72e2/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md?ref=4828c88af6132085c709db79500ac130669f72e2", "patch": "@@ -35,7 +35,7 @@ unchecked contracts:\n \n There is also `#[unsafe_no_drop_flag]`, which is a special case that exists for\n historical reasons and is in the process of being phased out. See the section on\n-[drop flags][] for details.\n+[drop flags] for details.\n \n Some examples of unsafe functions:\n \n@@ -44,7 +44,7 @@ Some examples of unsafe functions:\n * `ptr::offset` is an intrinsic that invokes Undefined Behaviour if it is\n   not \"in bounds\" as defined by LLVM.\n * `mem::transmute` reinterprets some value as having the given type,\n-  bypassing type safety in arbitrary ways. (see [conversions][] for details)\n+  bypassing type safety in arbitrary ways. (see [conversions] for details)\n * All FFI functions are `unsafe` because they can do arbitrary things.\n   C being an obvious culprit, but generally any language can do something\n   that Rust isn't happy about."}, {"sha": "9ab60d03fca7e41a6b1555f67683f207a8ed899b", "filename": "src/doc/nomicon/send-and-sync.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4828c88af6132085c709db79500ac130669f72e2/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md", "raw_url": "https://github.com/rust-lang/rust/raw/4828c88af6132085c709db79500ac130669f72e2/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md?ref=4828c88af6132085c709db79500ac130669f72e2", "patch": "@@ -10,7 +10,7 @@ captures this through the `Send` and `Sync` traits.\n \n Send and Sync are fundamental to Rust's concurrency story. As such, a\n substantial amount of special tooling exists to make them work right. First and\n-foremost, they're [unsafe traits][]. This means that they are unsafe to\n+foremost, they're [unsafe traits]. This means that they are unsafe to\n implement, and other unsafe code can assume that they are correctly\n implemented. Since they're *marker traits* (they have no associated items like\n methods), correctly implemented simply means that they have the intrinsic"}, {"sha": "2b34ad0a9fad164baf630f7bde97df6bbd1e84b1", "filename": "src/doc/nomicon/transmutes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4828c88af6132085c709db79500ac130669f72e2/src%2Fdoc%2Fnomicon%2Ftransmutes.md", "raw_url": "https://github.com/rust-lang/rust/raw/4828c88af6132085c709db79500ac130669f72e2/src%2Fdoc%2Fnomicon%2Ftransmutes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Ftransmutes.md?ref=4828c88af6132085c709db79500ac130669f72e2", "patch": "@@ -21,7 +21,7 @@ same size. The ways to cause Undefined Behaviour with this are mind boggling.\n     * No you can't do it\n     * No you're not special\n * Transmuting to a reference without an explicitly provided lifetime\n-  produces an [unbounded lifetime][]\n+  produces an [unbounded lifetime]\n \n `mem::transmute_copy<T, U>` somehow manages to be *even more* wildly unsafe than\n this. It copies `size_of<U>` bytes out of an `&T` and interprets them as a `U`."}]}