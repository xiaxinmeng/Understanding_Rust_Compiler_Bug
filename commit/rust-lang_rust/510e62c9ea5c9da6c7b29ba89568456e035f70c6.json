{"sha": "510e62c9ea5c9da6c7b29ba89568456e035f70c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMGU2MmM5ZWE1YzlkYTZjN2IyOWJhODk1Njg0NTZlMDM1ZjcwYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-28T19:16:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-28T19:16:50Z"}, "message": "Auto merge of #1559 - Aaron1011:new-miri-backtrace, r=RalfJung\n\nAdd API for capturing backtrace\n\nThis PR adds two new Miri-defined extern functions:\n`miri_get_backtrace` and `miri_resolve_frame`, which are documented in\nthe README. Together, they allow obtaining a backtrace for the currently\nexecuting program.\n\nI've added a test showing how these APIs are used. I've also prepared a\ncompanion PR `backtrace-rs`, which will allow\n`backtrace::Backtrace::new()` to work automatically under Miri.\n\nOnce these two PRs are merged, we will be able to print backtraces from\nthe normal Rust panic hook (since libstd is now using backtrace-rs).\n\nA few notes:\n* Resolving the backtrace frames is *very* slow - you can actually see\n  each line being printed out one at a time. Some local testing showed\n  that this is not (primrary) caused by resolving a `Span` - it seems\n  to be just Miri being slow.\n* For the first time, we now interact directly with a user-defined\n  struct (instead of just executing the user-provided MIR that\n  manipulates the struct). To allow for future changes, I've added\n  a 'version' parameter (currently required to be 0). This should allow\n  us to change the `MiriFrame` struct should the need ever arise.\n* I used the approach suggested by `@oli-obk` - a returned backtrace\n  pointer consists of a base function allocation, with the 'offset'\n  used to encode the `Span.lo`. This allows losslessly reconstructing\n  the location information in `miri_resolve_frame`.\n* There are a few quirks on the `backtrace-rs` side:\n  * `backtrace-rs` calls `getcwd()` by default to try to simplify\n    the filename. This results in an isolation error by default,\n    which could be annoying when printing a backtrace from libstd.\n  * `backtrace-rs` tries to remove 'internal' frames (everything between\n     the call to `Backtrace::new()` and the internal API call made by\n     backtrace-rs) by comparing the returned frame pointer value to\n     a Rust function pointer. This doesn't work due to the way we\n     construct the frame pointers passed to the caller. We could\n     attempt to support this kind of comparison, or just add a\n    `#[cfg(miri)]` and ignore the frames ourselves.", "tree": {"sha": "2d3afdede8a09acba5f263014203ad48d1e2f6ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d3afdede8a09acba5f263014203ad48d1e2f6ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/510e62c9ea5c9da6c7b29ba89568456e035f70c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/510e62c9ea5c9da6c7b29ba89568456e035f70c6", "html_url": "https://github.com/rust-lang/rust/commit/510e62c9ea5c9da6c7b29ba89568456e035f70c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/510e62c9ea5c9da6c7b29ba89568456e035f70c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa832c1133217a079ae5d9af65dd0b7ad96aca07", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa832c1133217a079ae5d9af65dd0b7ad96aca07", "html_url": "https://github.com/rust-lang/rust/commit/aa832c1133217a079ae5d9af65dd0b7ad96aca07"}, {"sha": "7fba3c2cf2058519b784de59605804899e0fe670", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fba3c2cf2058519b784de59605804899e0fe670", "html_url": "https://github.com/rust-lang/rust/commit/7fba3c2cf2058519b784de59605804899e0fe670"}], "stats": {"total": 255, "additions": 253, "deletions": 2}, "files": [{"sha": "2b015104828e98d82d5311bcc5546dcdc683a801", "filename": "README.md", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/510e62c9ea5c9da6c7b29ba89568456e035f70c6/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/510e62c9ea5c9da6c7b29ba89568456e035f70c6/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=510e62c9ea5c9da6c7b29ba89568456e035f70c6", "patch": "@@ -266,6 +266,34 @@ extern \"Rust\" {\n     /// `ptr` has to point to the beginning of an allocated block.\n     fn miri_static_root(ptr: *const u8);\n \n+    /// Miri-provided extern function to obtain a backtrace of the current call stack.\n+    /// This returns a boxed slice of pointers - each pointer is an opaque value\n+    /// that is only useful when passed to `miri_resolve_frame`\n+    /// The `flags` argument must be `0`.\n+    fn miri_get_backtrace(flags: u64) -> Box<[*mut ()]>;\n+\n+    /// Miri-provided extern function to resolve a frame pointer obtained\n+    /// from `miri_get_backtrace`. The `flags` argument must be `0`,\n+    /// and `MiriFrame` should be declared as follows:\n+    ///\n+    /// ```rust\n+    /// #[repr(C)]\n+    /// struct MiriFrame {\n+    ///     // The name of the function being executed, encoded in UTF-8\n+    ///     name: Box<[u8]>,\n+    ///     // The filename of the function being executed, encoded in UTF-8\n+    ///     filename: Box<[u8]>,\n+    ///     // The line number currently being executed in `filename`, starting from '1'.\n+    ///     lineno: u32,\n+    ///     // The column number currently being executed in `filename`, starting from '1'.\n+    ///     colno: u32,\n+    /// }\n+    /// ```\n+    ///\n+    /// The fields must be declared in exactly the same order as they appear in `MiriFrame` above.\n+    /// This function can be called on any thread (not just the one which obtained `frame`).\n+    fn miri_resolve_frame(frame: *mut (), flags: u64) -> MiriFrame;\n+\n     /// Miri-provided extern function to begin unwinding with the given payload.\n     ///\n     /// This is internal and unstable and should not be used; we give it here"}, {"sha": "75cd61b0f59e7e7eeae0de3e23d50e0b4653867a", "filename": "src/shims/backtrace.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/510e62c9ea5c9da6c7b29ba89568456e035f70c6/src%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510e62c9ea5c9da6c7b29ba89568456e035f70c6/src%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fbacktrace.rs?ref=510e62c9ea5c9da6c7b29ba89568456e035f70c6", "patch": "@@ -0,0 +1,121 @@\n+use crate::*;\n+use helpers::check_arg_count;\n+use rustc_middle::ty::{self, TypeAndMut};\n+use rustc_ast::ast::Mutability;\n+use rustc_span::BytePos;\n+use rustc_target::abi::Size;\n+use std::convert::TryInto as _;\n+use crate::rustc_target::abi::LayoutOf as _;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+\n+    fn handle_miri_get_backtrace(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: PlaceTy<'tcx, Tag>\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let tcx = this.tcx;\n+        let &[flags] = check_arg_count(args)?;\n+\n+        let flags = this.read_scalar(flags)?.to_u64()?;\n+        if flags != 0 {\n+            throw_unsup_format!(\"unknown `miri_get_backtrace` flags {}\", flags);\n+        }\n+\n+        let mut data = Vec::new();\n+        for frame in this.active_thread_stack().iter().rev() {\n+            data.push((frame.instance, frame.current_span().lo()));\n+        }\n+\n+        let ptrs: Vec<_> = data.into_iter().map(|(instance, pos)| {\n+            // We represent a frame pointer by using the `span.lo` value\n+            // as an offset into the function's allocation. This gives us an\n+            // opaque pointer that we can return to user code, and allows us\n+            // to reconstruct the needed frame information in `handle_miri_resolve_frame`.\n+            // Note that we never actually read or write anything from/to this pointer -\n+            // all of the data is represented by the pointer value itself.\n+            let mut fn_ptr = this.memory.create_fn_alloc(FnVal::Instance(instance));\n+            fn_ptr.offset = Size::from_bytes(pos.0);\n+            Scalar::Ptr(fn_ptr)\n+        }).collect();\n+\n+        let len = ptrs.len();\n+\n+        let ptr_ty = tcx.mk_ptr(TypeAndMut {\n+            ty: tcx.types.unit,\n+            mutbl: Mutability::Mut\n+        });\n+\n+        let array_ty = tcx.mk_array(ptr_ty, ptrs.len().try_into().unwrap());\n+\n+        // Write pointers into array\n+        let alloc = this.allocate(this.layout_of(array_ty).unwrap(), MiriMemoryKind::Rust.into());\n+        for (i, ptr) in ptrs.into_iter().enumerate() {\n+            let place = this.mplace_index(alloc, i as u64)?;\n+            this.write_immediate_to_mplace(ptr.into(), place)?;\n+        }\n+\n+        this.write_immediate(Immediate::new_slice(alloc.ptr.into(), len.try_into().unwrap(), this), dest)?;\n+        Ok(())\n+    }\n+\n+    fn handle_miri_resolve_frame(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: PlaceTy<'tcx, Tag>\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let tcx = this.tcx;\n+        let &[ptr, flags] = check_arg_count(args)?;\n+\n+        let flags = this.read_scalar(flags)?.to_u64()?;\n+        if flags != 0 {\n+            throw_unsup_format!(\"unknown `miri_resolve_frame` flags {}\", flags);\n+        }\n+\n+        let ptr = match this.read_scalar(ptr)?.check_init()? {\n+            Scalar::Ptr(ptr) => ptr,\n+            Scalar::Raw { .. } => throw_ub_format!(\"expected a pointer in `rust_miri_resolve_frame`, found {:?}\", ptr)\n+        };\n+\n+        let fn_instance = if let Some(GlobalAlloc::Function(instance)) = this.tcx.get_global_alloc(ptr.alloc_id) {\n+            instance\n+        } else {\n+            throw_ub_format!(\"expected function pointer, found {:?}\", ptr);\n+        };\n+\n+        if dest.layout.layout.fields.count() != 4 {\n+            throw_ub_format!(\"bad declaration of miri_resolve_frame - should return a struct with 4 fields\");\n+        }\n+\n+        let pos = BytePos(ptr.offset.bytes().try_into().unwrap());\n+        let name = fn_instance.to_string();\n+\n+        let lo = tcx.sess.source_map().lookup_char_pos(pos);\n+\n+        let filename = lo.file.name.to_string();\n+        let lineno: u32 = lo.line as u32;\n+        // `lo.col` is 0-based - add 1 to make it 1-based for the caller.\n+        let colno: u32 = lo.col.0 as u32 + 1;\n+\n+        let name_alloc = this.allocate_str(&name, MiriMemoryKind::Rust.into());\n+        let filename_alloc = this.allocate_str(&filename, MiriMemoryKind::Rust.into());\n+        let lineno_alloc = Scalar::from_u32(lineno);\n+        let colno_alloc = Scalar::from_u32(colno);\n+\n+        let dest = this.force_allocation(dest)?;\n+        if let ty::Adt(adt, _) = dest.layout.ty.kind() {\n+            if !adt.repr.c() {\n+                throw_ub_format!(\"miri_resolve_frame must be declared with a `#[repr(C)]` return type\");\n+            }\n+        }\n+\n+        this.write_immediate(name_alloc.to_ref(), this.mplace_field(dest, 0)?.into())?;\n+        this.write_immediate(filename_alloc.to_ref(), this.mplace_field(dest, 1)?.into())?;\n+        this.write_scalar(lineno_alloc, this.mplace_field(dest, 2)?.into())?;\n+        this.write_scalar(colno_alloc, this.mplace_field(dest, 3)?.into())?;\n+        Ok(())\n+    }\n+}"}, {"sha": "7118fbda2403a21ef6c6cc564fbe93ae944dc5dd", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/510e62c9ea5c9da6c7b29ba89568456e035f70c6/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510e62c9ea5c9da6c7b29ba89568456e035f70c6/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=510e62c9ea5c9da6c7b29ba89568456e035f70c6", "patch": "@@ -3,12 +3,14 @@ use std::{convert::{TryInto, TryFrom}, iter};\n use log::trace;\n \n use rustc_hir::def_id::DefId;\n-use rustc_middle::{mir, ty};\n+use rustc_middle::mir;\n use rustc_target::{abi::{Align, Size}, spec::PanicStrategy};\n+use rustc_middle::ty;\n use rustc_apfloat::Float;\n use rustc_span::symbol::sym;\n \n use crate::*;\n+use super::backtrace::EvalContextExt as _;\n use helpers::check_arg_count;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -211,6 +213,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.machine.static_roots.push(ptr.alloc_id);\n             }\n \n+            // Obtains a Miri backtrace. See the README for details.\n+            \"miri_get_backtrace\" => {\n+                this.handle_miri_get_backtrace(args, dest)?;\n+            }\n+\n+            // Resolves a Miri backtrace frame. See the README for details.\n+            \"miri_resolve_frame\" => {\n+                this.handle_miri_resolve_frame(args, dest)?;\n+            }\n+\n+\n             // Standard C allocation\n             \"malloc\" => {\n                 let &[size] = check_arg_count(args)?;"}, {"sha": "90dcc4d8ff1e4d35f4e737b2b42b9381b401eedb", "filename": "src/shims/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/510e62c9ea5c9da6c7b29ba89568456e035f70c6/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510e62c9ea5c9da6c7b29ba89568456e035f70c6/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=510e62c9ea5c9da6c7b29ba89568456e035f70c6", "patch": "@@ -1,4 +1,4 @@\n-\n+mod backtrace;\n pub mod foreign_items;\n pub mod intrinsics;\n pub mod posix;"}, {"sha": "b9f1c779ae23277377acab99fc60946b989e6618", "filename": "tests/compile-fail/backtrace/bad-backtrace-decl.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/510e62c9ea5c9da6c7b29ba89568456e035f70c6/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510e62c9ea5c9da6c7b29ba89568456e035f70c6/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-decl.rs?ref=510e62c9ea5c9da6c7b29ba89568456e035f70c6", "patch": "@@ -0,0 +1,13 @@\n+extern \"Rust\" {\n+    fn miri_get_backtrace(flags: u64) -> Box<[*mut ()]>;\n+    fn miri_resolve_frame(ptr: *mut (), flags: u64);\n+}\n+\n+fn main() {\n+    let frames = unsafe { miri_get_backtrace(0) };\n+    for frame in frames.into_iter() {\n+        unsafe {\n+            miri_resolve_frame(*frame, 0); //~ ERROR Undefined Behavior: bad declaration of miri_resolve_frame - should return a struct with 4 fields\n+        }\n+    }\n+}"}, {"sha": "5e245952e9b246e82fb36ec910a4f9a3e3c0b263", "filename": "tests/compile-fail/backtrace/bad-backtrace-ptr.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/510e62c9ea5c9da6c7b29ba89568456e035f70c6/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510e62c9ea5c9da6c7b29ba89568456e035f70c6/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-ptr.rs?ref=510e62c9ea5c9da6c7b29ba89568456e035f70c6", "patch": "@@ -0,0 +1,9 @@\n+extern \"Rust\" {\n+    fn miri_resolve_frame(ptr: *mut (), flags: u64);\n+}\n+\n+fn main() {\n+    unsafe {\n+        miri_resolve_frame(0 as *mut _, 0); //~ ERROR Undefined Behavior: expected a pointer\n+    }\n+}"}, {"sha": "4579b5d0ade89bd1830a98e6a87ab6c1b54eb63a", "filename": "tests/compile-fail/backtrace/bad-backtrace-version.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/510e62c9ea5c9da6c7b29ba89568456e035f70c6/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-version.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510e62c9ea5c9da6c7b29ba89568456e035f70c6/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-version.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-version.rs?ref=510e62c9ea5c9da6c7b29ba89568456e035f70c6", "patch": "@@ -0,0 +1,9 @@\n+extern \"Rust\" {\n+    fn miri_resolve_frame(ptr: *mut (), flags: u64);\n+}\n+\n+fn main() {\n+    unsafe {\n+        miri_resolve_frame(0 as *mut _, 1); //~ ERROR  unsupported operation: unknown `miri_resolve_frame` flags 1\n+    }\n+}"}, {"sha": "be1971efe28dd36d5d9748bb246d18311ec1c458", "filename": "tests/run-pass/backtrace-api.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/510e62c9ea5c9da6c7b29ba89568456e035f70c6/tests%2Frun-pass%2Fbacktrace-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510e62c9ea5c9da6c7b29ba89568456e035f70c6/tests%2Frun-pass%2Fbacktrace-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbacktrace-api.rs?ref=510e62c9ea5c9da6c7b29ba89568456e035f70c6", "patch": "@@ -0,0 +1,41 @@\n+// normalize-stderr-test \".*rustlib\" -> \"RUSTLIB\"\n+// normalize-stderr-test \"RUSTLIB/(.*):\\d+:\\d+ \"-> \"RUSTLIB/$1:LL:COL \"\n+// normalize-stderr-test \"::<.*>\" -> \"\"\n+\n+extern \"Rust\" {\n+    fn miri_get_backtrace(flags: u64) -> Box<[*mut ()]>;\n+    fn miri_resolve_frame(ptr: *mut (), flags: u64) -> MiriFrame;\n+}\n+\n+#[derive(Debug)]\n+#[repr(C)]\n+struct MiriFrame {\n+    name: Box<[u8]>,\n+    filename: Box<[u8]>,\n+    lineno: u32,\n+    colno: u32\n+}\n+\n+#[inline(never)] fn func_a() -> Box<[*mut ()]> { func_b::<u8>() }\n+#[inline(never)] fn func_b<T>() -> Box<[*mut ()]> { func_c() }\n+#[inline(never)] fn func_c() -> Box<[*mut ()]> { unsafe { miri_get_backtrace(0) } }\n+\n+fn main() {\n+    let mut seen_main = false;\n+    let frames = func_a();\n+    for frame in frames.into_iter() {\n+        let miri_frame = unsafe { miri_resolve_frame(*frame, 0) };\n+        let name = String::from_utf8(miri_frame.name.into()).unwrap();\n+        let filename = String::from_utf8(miri_frame.filename.into()).unwrap();\n+\n+        // Print every frame to stderr.\n+        let out = format!(\"{}:{}:{} ({})\", filename, miri_frame.lineno, miri_frame.colno, name);\n+        eprintln!(\"{}\", out);\n+        // Print the 'main' frame (and everything before it) to stdout, skipping\n+        // the printing of internal (and possibly fragile) libstd frames.\n+        if !seen_main {\n+            println!(\"{}\", out);\n+            seen_main = name == \"main\";\n+        }\n+    }\n+}"}, {"sha": "ea25267a1b148415f5e956d8758b0d00c82f3131", "filename": "tests/run-pass/backtrace-api.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/510e62c9ea5c9da6c7b29ba89568456e035f70c6/tests%2Frun-pass%2Fbacktrace-api.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/510e62c9ea5c9da6c7b29ba89568456e035f70c6/tests%2Frun-pass%2Fbacktrace-api.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbacktrace-api.stderr?ref=510e62c9ea5c9da6c7b29ba89568456e035f70c6", "patch": "@@ -0,0 +1,13 @@\n+$DIR/backtrace-api.rs:21:59 (func_c)\n+$DIR/backtrace-api.rs:20:53 (func_b)\n+$DIR/backtrace-api.rs:19:50 (func_a)\n+$DIR/backtrace-api.rs:25:18 (main)\n+RUSTLIB/src/rust/library/core/src/ops/function.rs:LL:COL (<fn() as std::ops::FnOnce<()>>::call_once - shim(fn()))\n+RUSTLIB/src/rust/library/std/src/sys_common/backtrace.rs:LL:COL (std::sys_common::backtrace::__rust_begin_short_backtrace)\n+RUSTLIB/src/rust/library/std/src/rt.rs:LL:COL (std::rt::lang_start::{closure#0})\n+RUSTLIB/src/rust/library/core/src/ops/function.rs:LL:COL (std::ops::function::impls::call_once)\n+RUSTLIB/src/rust/library/std/src/panicking.rs:LL:COL (std::panicking::r#try::do_call)\n+RUSTLIB/src/rust/library/std/src/panicking.rs:LL:COL (std::panicking::r#try)\n+RUSTLIB/src/rust/library/std/src/panic.rs:LL:COL (std::panic::catch_unwind)\n+RUSTLIB/src/rust/library/std/src/rt.rs:LL:COL (std::rt::lang_start_internal)\n+RUSTLIB/src/rust/library/std/src/rt.rs:LL:COL (std::rt::lang_start)"}, {"sha": "453cf0b774a109f7cc80a5c2fe680d597e3046cd", "filename": "tests/run-pass/backtrace-api.stdout", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/510e62c9ea5c9da6c7b29ba89568456e035f70c6/tests%2Frun-pass%2Fbacktrace-api.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/510e62c9ea5c9da6c7b29ba89568456e035f70c6/tests%2Frun-pass%2Fbacktrace-api.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbacktrace-api.stdout?ref=510e62c9ea5c9da6c7b29ba89568456e035f70c6", "patch": "@@ -0,0 +1,4 @@\n+$DIR/backtrace-api.rs:21:59 (func_c)\n+$DIR/backtrace-api.rs:20:53 (func_b::<u8>)\n+$DIR/backtrace-api.rs:19:50 (func_a)\n+$DIR/backtrace-api.rs:25:18 (main)"}]}