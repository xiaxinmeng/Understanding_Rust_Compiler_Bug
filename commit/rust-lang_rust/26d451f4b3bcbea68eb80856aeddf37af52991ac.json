{"sha": "26d451f4b3bcbea68eb80856aeddf37af52991ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZDQ1MWY0YjNiY2JlYTY4ZWI4MDg1NmFlZGRmMzdhZjUyOTkxYWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-10T23:36:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-10T23:36:33Z"}, "message": "Auto merge of #80782 - petrochenkov:viscopes, r=matthewjasper\n\nresolve: Scope visiting doesn't need an `Ident`\n\nResolution scope visitor (`fn visit_scopes`) currently takes an `Ident` parameter, but it doesn't need a full identifier, or even its span, it only needs the `SyntaxContext` part.\nThe `SyntaxContext` part is necessary because scope visitor has to jump to macro definition sites, so it has to be directed by macro expansion information somehow.\n\nI think it's clearer to pass only the necessary part.\nYes, usually visiting happens as a part of an identifier resolution, but in cases like collecting traits in scope (#80765) or collecting typo suggestions that's not the case.\n\nr? `@matthewjasper`", "tree": {"sha": "1fef6a7c8b363237f3aac07822458f9f045a247b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fef6a7c8b363237f3aac07822458f9f045a247b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26d451f4b3bcbea68eb80856aeddf37af52991ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26d451f4b3bcbea68eb80856aeddf37af52991ac", "html_url": "https://github.com/rust-lang/rust/commit/26d451f4b3bcbea68eb80856aeddf37af52991ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26d451f4b3bcbea68eb80856aeddf37af52991ac/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c97f11af7bc4a6d3578f6a953be04ab2449a5728", "url": "https://api.github.com/repos/rust-lang/rust/commits/c97f11af7bc4a6d3578f6a953be04ab2449a5728", "html_url": "https://github.com/rust-lang/rust/commit/c97f11af7bc4a6d3578f6a953be04ab2449a5728"}, {"sha": "3ff866ed7c814add27d32a31caaf29fa44cb53f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ff866ed7c814add27d32a31caaf29fa44cb53f5", "html_url": "https://github.com/rust-lang/rust/commit/3ff866ed7c814add27d32a31caaf29fa44cb53f5"}], "stats": {"total": 147, "additions": 90, "deletions": 57}, "files": [{"sha": "4f8047ac2dff02966aa4a8c91ed9b3fd53dc5dc5", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26d451f4b3bcbea68eb80856aeddf37af52991ac/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d451f4b3bcbea68eb80856aeddf37af52991ac/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=26d451f4b3bcbea68eb80856aeddf37af52991ac", "patch": "@@ -611,7 +611,8 @@ impl<'a> Resolver<'a> {\n         filter_fn: &impl Fn(Res) -> bool,\n     ) -> Option<TypoSuggestion> {\n         let mut suggestions = Vec::new();\n-        self.visit_scopes(scope_set, parent_scope, ident, |this, scope, use_prelude, _| {\n+        let ctxt = ident.span.ctxt();\n+        self.visit_scopes(scope_set, parent_scope, ctxt, |this, scope, use_prelude, _| {\n             match scope {\n                 Scope::DeriveHelpers(expn_id) => {\n                     let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);"}, {"sha": "8544e1d8ee55a4e263bc95daf6553dd22af4c735", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/26d451f4b3bcbea68eb80856aeddf37af52991ac/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d451f4b3bcbea68eb80856aeddf37af52991ac/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=26d451f4b3bcbea68eb80856aeddf37af52991ac", "patch": "@@ -268,52 +268,60 @@ impl<'a> PathSource<'a> {\n \n     crate fn is_expected(self, res: Res) -> bool {\n         match self {\n-            PathSource::Type => matches!(res, Res::Def(\n+            PathSource::Type => matches!(\n+                res,\n+                Res::Def(\n                     DefKind::Struct\n-                    | DefKind::Union\n-                    | DefKind::Enum\n-                    | DefKind::Trait\n-                    | DefKind::TraitAlias\n-                    | DefKind::TyAlias\n-                    | DefKind::AssocTy\n-                    | DefKind::TyParam\n-                    | DefKind::OpaqueTy\n-                    | DefKind::ForeignTy,\n+                        | DefKind::Union\n+                        | DefKind::Enum\n+                        | DefKind::Trait\n+                        | DefKind::TraitAlias\n+                        | DefKind::TyAlias\n+                        | DefKind::AssocTy\n+                        | DefKind::TyParam\n+                        | DefKind::OpaqueTy\n+                        | DefKind::ForeignTy,\n                     _,\n-                )\n-                | Res::PrimTy(..)\n-                | Res::SelfTy(..)),\n+                ) | Res::PrimTy(..)\n+                    | Res::SelfTy(..)\n+            ),\n             PathSource::Trait(AliasPossibility::No) => matches!(res, Res::Def(DefKind::Trait, _)),\n             PathSource::Trait(AliasPossibility::Maybe) => {\n                 matches!(res, Res::Def(DefKind::Trait | DefKind::TraitAlias, _))\n             }\n-            PathSource::Expr(..) => matches!(res, Res::Def(\n+            PathSource::Expr(..) => matches!(\n+                res,\n+                Res::Def(\n                     DefKind::Ctor(_, CtorKind::Const | CtorKind::Fn)\n-                    | DefKind::Const\n-                    | DefKind::Static\n-                    | DefKind::Fn\n-                    | DefKind::AssocFn\n-                    | DefKind::AssocConst\n-                    | DefKind::ConstParam,\n+                        | DefKind::Const\n+                        | DefKind::Static\n+                        | DefKind::Fn\n+                        | DefKind::AssocFn\n+                        | DefKind::AssocConst\n+                        | DefKind::ConstParam,\n                     _,\n-                )\n-                | Res::Local(..)\n-                | Res::SelfCtor(..)),\n-            PathSource::Pat => matches!(res, Res::Def(\n+                ) | Res::Local(..)\n+                    | Res::SelfCtor(..)\n+            ),\n+            PathSource::Pat => matches!(\n+                res,\n+                Res::Def(\n                     DefKind::Ctor(_, CtorKind::Const) | DefKind::Const | DefKind::AssocConst,\n                     _,\n-                )\n-                | Res::SelfCtor(..)),\n+                ) | Res::SelfCtor(..)\n+            ),\n             PathSource::TupleStruct(..) => res.expected_in_tuple_struct_pat(),\n-            PathSource::Struct => matches!(res, Res::Def(\n+            PathSource::Struct => matches!(\n+                res,\n+                Res::Def(\n                     DefKind::Struct\n-                    | DefKind::Union\n-                    | DefKind::Variant\n-                    | DefKind::TyAlias\n-                    | DefKind::AssocTy,\n+                        | DefKind::Union\n+                        | DefKind::Variant\n+                        | DefKind::TyAlias\n+                        | DefKind::AssocTy,\n                     _,\n-                )\n-                | Res::SelfTy(..)),\n+                ) | Res::SelfTy(..)\n+            ),\n             PathSource::TraitItem(ns) => match res {\n                 Res::Def(DefKind::AssocConst | DefKind::AssocFn, _) if ns == ValueNS => true,\n                 Res::Def(DefKind::AssocTy, _) if ns == TypeNS => true,\n@@ -2415,8 +2423,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 &mut found_traits,\n                 &self.parent_scope,\n             );\n-            search_module =\n-                unwrap_or!(self.r.hygienic_lexical_parent(search_module, &mut ident.span), break);\n+            let mut span_data = ident.span.data();\n+            search_module = unwrap_or!(\n+                self.r.hygienic_lexical_parent(search_module, &mut span_data.ctxt),\n+                break\n+            );\n+            ident.span = span_data.span();\n         }\n \n         if let Some(prelude) = self.r.prelude {"}, {"sha": "86bb1c77911ef36bddd09cf91f9d3373e53c62e1", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/26d451f4b3bcbea68eb80856aeddf37af52991ac/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d451f4b3bcbea68eb80856aeddf37af52991ac/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=26d451f4b3bcbea68eb80856aeddf37af52991ac", "patch": "@@ -50,6 +50,7 @@ use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::Session;\n+use rustc_span::edition::Edition;\n use rustc_span::hygiene::{ExpnId, ExpnKind, MacroKind, SyntaxContext, Transparency};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -763,10 +764,13 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn is_variant(&self) -> bool {\n-        matches!(self.kind, NameBindingKind::Res(\n+        matches!(\n+            self.kind,\n+            NameBindingKind::Res(\n                 Res::Def(DefKind::Variant | DefKind::Ctor(CtorOf::Variant, ..), _),\n                 _,\n-            ))\n+            )\n+        )\n     }\n \n     fn is_extern_crate(&self) -> bool {\n@@ -1630,8 +1634,13 @@ impl<'a> Resolver<'a> {\n         &mut self,\n         scope_set: ScopeSet,\n         parent_scope: &ParentScope<'a>,\n-        ident: Ident,\n-        mut visitor: impl FnMut(&mut Self, Scope<'a>, /*use_prelude*/ bool, Ident) -> Option<T>,\n+        ctxt: SyntaxContext,\n+        mut visitor: impl FnMut(\n+            &mut Self,\n+            Scope<'a>,\n+            /*use_prelude*/ bool,\n+            SyntaxContext,\n+        ) -> Option<T>,\n     ) -> Option<T> {\n         // General principles:\n         // 1. Not controlled (user-defined) names should have higher priority than controlled names\n@@ -1674,7 +1683,7 @@ impl<'a> Resolver<'a> {\n         // 4c. Standard library prelude (de-facto closed, controlled).\n         // 6. Language prelude: builtin attributes (closed, controlled).\n \n-        let rust_2015 = ident.span.rust_2015();\n+        let rust_2015 = ctxt.edition() == Edition::Edition2015;\n         let (ns, macro_kind, is_absolute_path) = match scope_set {\n             ScopeSet::All(ns, _) => (ns, None, false),\n             ScopeSet::AbsolutePath(ns) => (ns, None, true),\n@@ -1687,7 +1696,7 @@ impl<'a> Resolver<'a> {\n             TypeNS | ValueNS => Scope::Module(module),\n             MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n         };\n-        let mut ident = ident.normalize_to_macros_2_0();\n+        let mut ctxt = ctxt.normalize_to_macros_2_0();\n         let mut use_prelude = !module.no_implicit_prelude;\n \n         loop {\n@@ -1723,7 +1732,7 @@ impl<'a> Resolver<'a> {\n             };\n \n             if visit {\n-                if let break_result @ Some(..) = visitor(self, scope, use_prelude, ident) {\n+                if let break_result @ Some(..) = visitor(self, scope, use_prelude, ctxt) {\n                     return break_result;\n                 }\n             }\n@@ -1753,17 +1762,17 @@ impl<'a> Resolver<'a> {\n                 },\n                 Scope::CrateRoot => match ns {\n                     TypeNS => {\n-                        ident.span.adjust(ExpnId::root());\n+                        ctxt.adjust(ExpnId::root());\n                         Scope::ExternPrelude\n                     }\n                     ValueNS | MacroNS => break,\n                 },\n                 Scope::Module(module) => {\n                     use_prelude = !module.no_implicit_prelude;\n-                    match self.hygienic_lexical_parent(module, &mut ident.span) {\n+                    match self.hygienic_lexical_parent(module, &mut ctxt) {\n                         Some(parent_module) => Scope::Module(parent_module),\n                         None => {\n-                            ident.span.adjust(ExpnId::root());\n+                            ctxt.adjust(ExpnId::root());\n                             match ns {\n                                 TypeNS => Scope::ExternPrelude,\n                                 ValueNS => Scope::StdLibPrelude,\n@@ -1888,16 +1897,18 @@ impl<'a> Resolver<'a> {\n         ident = normalized_ident;\n         let mut poisoned = None;\n         loop {\n+            let mut span_data = ident.span.data();\n             let opt_module = if let Some(node_id) = record_used_id {\n                 self.hygienic_lexical_parent_with_compatibility_fallback(\n                     module,\n-                    &mut ident.span,\n+                    &mut span_data.ctxt,\n                     node_id,\n                     &mut poisoned,\n                 )\n             } else {\n-                self.hygienic_lexical_parent(module, &mut ident.span)\n+                self.hygienic_lexical_parent(module, &mut span_data.ctxt)\n             };\n+            ident.span = span_data.span();\n             module = unwrap_or!(opt_module, break);\n             let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n             let result = self.resolve_ident_in_module_unadjusted(\n@@ -1971,10 +1982,10 @@ impl<'a> Resolver<'a> {\n     fn hygienic_lexical_parent(\n         &mut self,\n         module: Module<'a>,\n-        span: &mut Span,\n+        ctxt: &mut SyntaxContext,\n     ) -> Option<Module<'a>> {\n-        if !module.expansion.outer_expn_is_descendant_of(span.ctxt()) {\n-            return Some(self.macro_def_scope(span.remove_mark()));\n+        if !module.expansion.outer_expn_is_descendant_of(*ctxt) {\n+            return Some(self.macro_def_scope(ctxt.remove_mark()));\n         }\n \n         if let ModuleKind::Block(..) = module.kind {\n@@ -1987,11 +1998,11 @@ impl<'a> Resolver<'a> {\n     fn hygienic_lexical_parent_with_compatibility_fallback(\n         &mut self,\n         module: Module<'a>,\n-        span: &mut Span,\n+        ctxt: &mut SyntaxContext,\n         node_id: NodeId,\n         poisoned: &mut Option<NodeId>,\n     ) -> Option<Module<'a>> {\n-        if let module @ Some(..) = self.hygienic_lexical_parent(module, span) {\n+        if let module @ Some(..) = self.hygienic_lexical_parent(module, ctxt) {\n             return module;\n         }\n \n@@ -2016,7 +2027,7 @@ impl<'a> Resolver<'a> {\n                     let ext = self.get_macro_by_def_id(def_id);\n                     if ext.builtin_name.is_none()\n                         && ext.macro_kind() == MacroKind::Derive\n-                        && parent.expansion.outer_expn_is_descendant_of(span.ctxt())\n+                        && parent.expansion.outer_expn_is_descendant_of(*ctxt)\n                     {\n                         *poisoned = Some(node_id);\n                         return module.parent;"}, {"sha": "a5eb369ee9058e4d2b2b5695ed36989acf329403", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26d451f4b3bcbea68eb80856aeddf37af52991ac/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d451f4b3bcbea68eb80856aeddf37af52991ac/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=26d451f4b3bcbea68eb80856aeddf37af52991ac", "patch": "@@ -618,8 +618,9 @@ impl<'a> Resolver<'a> {\n         let break_result = self.visit_scopes(\n             scope_set,\n             parent_scope,\n-            orig_ident,\n-            |this, scope, use_prelude, ident| {\n+            orig_ident.span.ctxt(),\n+            |this, scope, use_prelude, ctxt| {\n+                let ident = Ident::new(orig_ident.name, orig_ident.span.with_ctxt(ctxt));\n                 let ok = |res, span, arenas| {\n                     Ok((\n                         (res, ty::Visibility::Public, span, ExpnId::root()).to_name_binding(arenas),"}, {"sha": "1fb5642912f43db483afb6194026e89eed78ffe5", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26d451f4b3bcbea68eb80856aeddf37af52991ac/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d451f4b3bcbea68eb80856aeddf37af52991ac/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=26d451f4b3bcbea68eb80856aeddf37af52991ac", "patch": "@@ -622,6 +622,10 @@ impl SyntaxContext {\n     pub fn dollar_crate_name(self) -> Symbol {\n         HygieneData::with(|data| data.syntax_context_data[self.0 as usize].dollar_crate_name)\n     }\n+\n+    pub fn edition(self) -> Edition {\n+        self.outer_expn_data().edition\n+    }\n }\n \n impl fmt::Debug for SyntaxContext {"}, {"sha": "62ca7b066d91bd675a31e5d3dfe2b1d7bdca53d2", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26d451f4b3bcbea68eb80856aeddf37af52991ac/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d451f4b3bcbea68eb80856aeddf37af52991ac/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=26d451f4b3bcbea68eb80856aeddf37af52991ac", "patch": "@@ -300,6 +300,10 @@ pub struct SpanData {\n }\n \n impl SpanData {\n+    #[inline]\n+    pub fn span(&self) -> Span {\n+        Span::new(self.lo, self.hi, self.ctxt)\n+    }\n     #[inline]\n     pub fn with_lo(&self, lo: BytePos) -> Span {\n         Span::new(lo, self.hi, self.ctxt)\n@@ -468,7 +472,7 @@ impl Span {\n \n     /// Edition of the crate from which this span came.\n     pub fn edition(self) -> edition::Edition {\n-        self.ctxt().outer_expn_data().edition\n+        self.ctxt().edition()\n     }\n \n     #[inline]"}]}