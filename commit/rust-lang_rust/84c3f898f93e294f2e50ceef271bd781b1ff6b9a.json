{"sha": "84c3f898f93e294f2e50ceef271bd781b1ff6b9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0YzNmODk4ZjkzZTI5NGYyZTUwY2VlZjI3MWJkNzgxYjFmZjZiOWE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-14T02:51:21Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-19T22:13:35Z"}, "message": "def_collector and crate reader operate on AST instead of HIR\n\nAnd move extern crate reading earlier in the driver", "tree": {"sha": "0c5946dedadfb09d6ddf3b3727f50705bde68dac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c5946dedadfb09d6ddf3b3727f50705bde68dac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84c3f898f93e294f2e50ceef271bd781b1ff6b9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84c3f898f93e294f2e50ceef271bd781b1ff6b9a", "html_url": "https://github.com/rust-lang/rust/commit/84c3f898f93e294f2e50ceef271bd781b1ff6b9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84c3f898f93e294f2e50ceef271bd781b1ff6b9a/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6af7acab1c6976933c90b07a58450567227b4719", "url": "https://api.github.com/repos/rust-lang/rust/commits/6af7acab1c6976933c90b07a58450567227b4719", "html_url": "https://github.com/rust-lang/rust/commit/6af7acab1c6976933c90b07a58450567227b4719"}], "stats": {"total": 264, "additions": 113, "deletions": 151}, "files": [{"sha": "a259c5a0f31470b2855831870c82a9b1a2034029", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/84c3f898f93e294f2e50ceef271bd781b1ff6b9a/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84c3f898f93e294f2e50ceef271bd781b1ff6b9a/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=84c3f898f93e294f2e50ceef271bd781b1ff6b9a", "patch": "@@ -10,10 +10,10 @@\n \n use super::*;\n \n-use hir::*;\n-use hir::intravisit::Visitor;\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n-use syntax::ast::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n+\n+use syntax::ast::*;\n+use syntax::visit;\n \n /// Creates def ids for nodes in the HIR.\n pub struct DefCollector<'ast> {\n@@ -80,31 +80,23 @@ impl<'ast> DefCollector<'ast> {\n     }\n }\n \n-impl<'ast> Visitor<'ast> for DefCollector<'ast> {\n-    /// Because we want to track parent items and so forth, enable\n-    /// deep walking so that we walk nested items in the context of\n-    /// their outer items.\n-    fn visit_nested_item(&mut self, item: ItemId) {\n-        debug!(\"visit_nested_item: {:?}\", item);\n-        self.visit_item(self.krate.item(item.id))\n-    }\n-\n+impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n     fn visit_item(&mut self, i: &'ast Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n         // Pick the def data. This need not be unique, but the more\n         // information we encapsulate into\n         let def_data = match i.node {\n-            ItemDefaultImpl(..) | ItemImpl(..) =>\n+            ItemKind::DefaultImpl(..) | ItemKind::Impl(..) =>\n                 DefPathData::Impl,\n-            ItemEnum(..) | ItemStruct(..) | ItemTrait(..) |\n-            ItemExternCrate(..) | ItemMod(..) | ItemForeignMod(..) |\n-            ItemTy(..) =>\n-                DefPathData::TypeNs(i.name),\n-            ItemStatic(..) | ItemConst(..) | ItemFn(..) =>\n-                DefPathData::ValueNs(i.name),\n-            ItemUse(..) =>\n-                DefPathData::Misc,\n+            ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Trait(..) |\n+            ItemKind::ExternCrate(..) | ItemKind::Mod(..) | ItemKind::ForeignMod(..) |\n+            ItemKind::Ty(..) =>\n+                DefPathData::TypeNs(i.ident.name),\n+            ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n+                DefPathData::ValueNs(i.ident.name),\n+            ItemKind::Mac(..) => DefPathData::MacroDef(i.ident.name),\n+            ItemKind::Use(..) => DefPathData::Misc,\n         };\n \n         let def = self.create_def(i.id, def_data);\n@@ -113,59 +105,63 @@ impl<'ast> Visitor<'ast> for DefCollector<'ast> {\n         self.parent_def = Some(def);\n \n         match i.node {\n-            ItemEnum(ref enum_definition, _) => {\n+            ItemKind::Enum(ref enum_definition, _) => {\n                 for v in &enum_definition.variants {\n                     let variant_def_index =\n                         self.create_def(v.node.data.id(),\n-                                        DefPathData::EnumVariant(v.node.name));\n+                                        DefPathData::EnumVariant(v.node.name.name));\n \n                     for field in v.node.data.fields() {\n-                        self.create_def_with_parent(\n-                            Some(variant_def_index),\n-                            field.id,\n-                            DefPathData::Field(field.name));\n+                        if let Some(ident) = field.ident {\n+                            self.create_def_with_parent(Some(variant_def_index),\n+                                                        field.id,\n+                                                        DefPathData::Field(ident.name));\n+                        }\n                     }\n                 }\n             }\n-            ItemStruct(ref struct_def, _) => {\n+            ItemKind::Struct(ref struct_def, _) => {\n                 // If this is a tuple-like struct, register the constructor.\n                 if !struct_def.is_struct() {\n                     self.create_def(struct_def.id(),\n                                     DefPathData::StructCtor);\n                 }\n \n                 for field in struct_def.fields() {\n-                    self.create_def(field.id, DefPathData::Field(field.name));\n+                    if let Some(ident) = field.ident {\n+                        self.create_def(field.id, DefPathData::Field(ident.name));\n+                    }\n                 }\n             }\n             _ => {}\n         }\n-        intravisit::walk_item(self, i);\n+        visit::walk_item(self, i);\n         self.parent_def = parent_def;\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n-        let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.name));\n+        let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.ident.name));\n \n         let parent_def = self.parent_def;\n         self.parent_def = Some(def);\n-        intravisit::walk_foreign_item(self, foreign_item);\n+        visit::walk_foreign_item(self, foreign_item);\n         self.parent_def = parent_def;\n     }\n \n     fn visit_generics(&mut self, generics: &'ast Generics) {\n         for ty_param in generics.ty_params.iter() {\n             self.create_def(ty_param.id,\n-                            DefPathData::TypeParam(ty_param.name));\n+                            DefPathData::TypeParam(ty_param.ident.name));\n         }\n \n-        intravisit::walk_generics(self, generics);\n+        visit::walk_generics(self, generics);\n     }\n \n     fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n         let def_data = match ti.node {\n-            MethodTraitItem(..) | ConstTraitItem(..) => DefPathData::ValueNs(ti.name),\n-            TypeTraitItem(..) => DefPathData::TypeNs(ti.name),\n+            TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n+                DefPathData::ValueNs(ti.ident.name),\n+            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name),\n         };\n \n         let def = self.create_def(ti.id, def_data);\n@@ -174,21 +170,23 @@ impl<'ast> Visitor<'ast> for DefCollector<'ast> {\n         self.parent_def = Some(def);\n \n         match ti.node {\n-            ConstTraitItem(_, Some(ref expr)) => {\n+            TraitItemKind::Const(_, Some(ref expr)) => {\n                 self.create_def(expr.id, DefPathData::Initializer);\n             }\n             _ => { }\n         }\n \n-        intravisit::walk_trait_item(self, ti);\n+        visit::walk_trait_item(self, ti);\n \n         self.parent_def = parent_def;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n         let def_data = match ii.node {\n-            ImplItemKind::Method(..) | ImplItemKind::Const(..) => DefPathData::ValueNs(ii.name),\n-            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name),\n+            ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n+                DefPathData::ValueNs(ii.ident.name),\n+            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name),\n+            ImplItemKind::Macro(..) => DefPathData::MacroDef(ii.ident.name),\n         };\n \n         let def = self.create_def(ii.id, def_data);\n@@ -203,7 +201,7 @@ impl<'ast> Visitor<'ast> for DefCollector<'ast> {\n             _ => { }\n         }\n \n-        intravisit::walk_impl_item(self, ii);\n+        visit::walk_impl_item(self, ii);\n \n         self.parent_def = parent_def;\n     }\n@@ -220,35 +218,35 @@ impl<'ast> Visitor<'ast> for DefCollector<'ast> {\n             self.parent_def = Some(def);\n         }\n \n-        intravisit::walk_pat(self, pat);\n+        visit::walk_pat(self, pat);\n         self.parent_def = parent_def;\n     }\n \n     fn visit_expr(&mut self, expr: &'ast Expr) {\n         let parent_def = self.parent_def;\n \n-        if let ExprClosure(..) = expr.node {\n+        if let ExprKind::Closure(..) = expr.node {\n             let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n             self.parent_def = Some(def);\n         }\n \n-        intravisit::walk_expr(self, expr);\n+        visit::walk_expr(self, expr);\n         self.parent_def = parent_def;\n     }\n \n     fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n-        intravisit::walk_stmt(self, stmt);\n+        visit::walk_stmt(self, stmt);\n     }\n \n     fn visit_block(&mut self, block: &'ast Block) {\n-        intravisit::walk_block(self, block);\n+        visit::walk_block(self, block);\n     }\n \n     fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n         self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n-        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n+        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name));\n     }\n }"}, {"sha": "b1954255278c0f10443c68f0ae6cfe9a662e465f", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/84c3f898f93e294f2e50ceef271bd781b1ff6b9a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84c3f898f93e294f2e50ceef271bd781b1ff6b9a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=84c3f898f93e294f2e50ceef271bd781b1ff6b9a", "patch": "@@ -22,9 +22,10 @@ use middle::cstore::InlinedItem as II;\n use hir::def_id::{CRATE_DEF_INDEX, DefId};\n \n use syntax::abi::Abi;\n-use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID};\n+use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, };\n use syntax::attr::ThinAttributesExt;\n use syntax::codemap::{Span, Spanned};\n+use syntax::visit;\n \n use hir::*;\n use hir::fold::Folder;\n@@ -782,10 +783,10 @@ impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n     }\n }\n \n-pub fn collect_definitions<'ast>(forest: &'ast mut Forest) -> Definitions {\n-    let mut def_collector = DefCollector::root(&forest.krate);\n-    intravisit::walk_crate(&mut def_collector, &forest.krate);\n-    def_collector.definitions    \n+pub fn collect_definitions<'ast>(krate: &'ast ast::Crate) -> Definitions {\n+    let mut def_collector = DefCollector::root(krate);\n+    visit::walk_crate(&mut def_collector, krate);\n+    def_collector.definitions\n }\n \n pub fn map_crate<'ast>(forest: &'ast mut Forest, definitions: Definitions) -> Map<'ast> {\n@@ -842,14 +843,15 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     let ii = map.forest.inlined_items.alloc(ii);\n     let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n \n-    let defs = mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new());\n-    let mut def_collector = DefCollector::extend(map.krate(),\n-                                                 ii_parent_id,\n-                                                 parent_def_path.clone(),\n-                                                 parent_def_id,\n-                                                 defs);\n-    ii.visit(&mut def_collector);\n-    *map.definitions.borrow_mut() = def_collector.definitions;\n+    // TODO need to save defs in metadata :-(\n+    // let defs = mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new());\n+    // let mut def_collector = DefCollector::extend(map.krate(),\n+    //                                              ii_parent_id,\n+    //                                              parent_def_path.clone(),\n+    //                                              parent_def_id,\n+    //                                              defs);\n+    // ii.visit(&mut def_collector);\n+    // *map.definitions.borrow_mut() = def_collector.definitions;\n \n     let mut collector = NodeCollector::extend(map.krate(),\n                                               ii,"}, {"sha": "6724c0ed8ebfd81f1053cbf4b86ac00b9f4e4987", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/84c3f898f93e294f2e50ceef271bd781b1ff6b9a/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84c3f898f93e294f2e50ceef271bd781b1ff6b9a/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=84c3f898f93e294f2e50ceef271bd781b1ff6b9a", "patch": "@@ -122,32 +122,22 @@ pub fn compile_input(sess: &Session,\n         let expanded_crate = assign_node_ids(sess, expanded_crate);\n         let dep_graph = DepGraph::new(sess.opts.build_dep_graph);\n \n-        // TODO\n-        // time(sess.time_passes(),\n-        //      \"external crate/lib resolution\",\n-        //      || LocalCrateReader::new(sess, &cstore, &defs, &id).read_crates());\n-\n-        // TODO\n-        panic!();\n-\n-        // TODO CrateMap result\n-        // let resolve::CrateMap {\n-        //     def_map,\n-        //     freevars,\n-        //     export_map,\n-        //     trait_map,\n-        //     glob_map,\n-        // } = time(sess.time_passes(),\n-        //          \"name resolution\",\n-        //          || resolve::resolve_crate(sess, &hir_map, control.make_glob_map));\n+        // Collect defintions for def ids.\n+        let defs = time(sess.time_passes(),\n+                        \"collecting defs\",\n+                        || hir_map::collect_definitions(&expanded_crate));\n+\n+        time(sess.time_passes(),\n+             \"external crate/lib resolution\",\n+             || LocalCrateReader::new(sess, &cstore, &defs, &expanded_crate, &id)\n+                    .read_crates(&dep_graph));\n \n         // Lower ast -> hir.\n         let lcx = LoweringContext::new(sess, Some(&expanded_crate));\n-        let dep_graph = DepGraph::new(sess.opts.build_dep_graph());\n-        let mut hir_forest = time(sess.time_passes(),\n-                                  \"lowering ast -> hir\",\n-                                  || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate),\n-                                                          dep_graph));\n+        let hir_forest = &mut time(sess.time_passes(),\n+                                   \"lowering ast -> hir\",\n+                                   || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate),\n+                                                           dep_graph));\n \n         // Discard MTWT tables that aren't required past lowering to HIR.\n         if !sess.opts.debugging_opts.keep_mtwt_tables &&\n@@ -156,10 +146,6 @@ pub fn compile_input(sess: &Session,\n         }\n \n         let arenas = ty::CtxtArenas::new();\n-        // Collect defintions for def ids.\n-        let defs = time(sess.time_passes(),\n-                        \"collecting defs\",\n-                        move || hir_map::collect_defs(hir_forest));\n \n         // Construct the HIR map\n         let hir_map = time(sess.time_passes(),\n@@ -201,10 +187,10 @@ pub fn compile_input(sess: &Session,\n         };\n \n         phase_3_run_analysis_passes(sess,\n-                                    &cstore,\n                                     hir_map,\n                                     &arenas,\n                                     &id,\n+                                    control.make_glob_map,\n                                     |tcx, mir_map, analysis, result| {\n             {\n                 // Eventually, we will want to track plugins.\n@@ -759,10 +745,10 @@ pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n-                                               cstore: &CStore,\n                                                hir_map: hir_map::Map<'tcx>,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: &str,\n+                                               make_glob_map: resolve::MakeGlobMap,\n                                                f: F)\n                                                -> Result<R, usize>\n     where F: FnOnce(&TyCtxt<'tcx>, Option<MirMap<'tcx>>, ty::CrateAnalysis, CompileResult) -> R\n@@ -787,6 +773,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         })\n     })?;\n \n+    let resolve::CrateMap {\n+        def_map,\n+        freevars,\n+        export_map,\n+        trait_map,\n+        glob_map,\n+    } = time(sess.time_passes(),\n+             \"name resolution\",\n+             || resolve::resolve_crate(sess, &hir_map, make_glob_map));\n+\n     let mut analysis = ty::CrateAnalysis {\n         export_map: export_map,\n         access_levels: AccessLevels::default(),"}, {"sha": "2e3a477e0484050ec5cf9db731d7a4c48564b6ae", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84c3f898f93e294f2e50ceef271bd781b1ff6b9a/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84c3f898f93e294f2e50ceef271bd781b1ff6b9a/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=84c3f898f93e294f2e50ceef271bd781b1ff6b9a", "patch": "@@ -179,7 +179,6 @@ impl PpSourceMode {\n     }\n     fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n                                                sess: &'tcx Session,\n-                                               cstore: &CStore,\n                                                ast_map: &hir_map::Map<'tcx>,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                id: &str,\n@@ -206,7 +205,6 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 abort_on_err(driver::phase_3_run_analysis_passes(sess,\n-                                                                 cstore,\n                                                                  ast_map.clone(),\n                                                                  arenas,\n                                                                  id,\n@@ -737,9 +735,9 @@ pub fn pretty_print_input(sess: Session,\n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n     let ast_map = if compute_ast_map {\n+        let defs = hir_map::collect_definitions(&krate);\n         hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph.clone());\n-        let defs = hir_map::collect_defs(hir_forest);\n-        let map = hir_map::map_crate(hir_forest, defs);\n+        let map = hir_map::map_crate(&mut hir_forest, defs);\n         Some(map)\n     } else {\n         None\n@@ -778,7 +776,6 @@ pub fn pretty_print_input(sess: Session,\n         (PpmHir(s), None) => {\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(&sess,\n-                                       cstore,\n                                        &ast_map.unwrap(),\n                                        &arenas,\n                                        &id,\n@@ -800,7 +797,6 @@ pub fn pretty_print_input(sess: Session,\n         (PpmHir(s), Some(uii)) => {\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(&sess,\n-                                       cstore,\n                                        &ast_map.unwrap(),\n                                        &arenas,\n                                        &id,\n@@ -841,7 +837,6 @@ pub fn pretty_print_input(sess: Session,\n                 None\n             };\n             abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n-                                                             &cstore,\n                                                              ast_map,\n                                                              &arenas,\n                                                              &id,\n@@ -888,7 +883,6 @@ pub fn pretty_print_input(sess: Session,\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n                     abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n-                                                                     &cstore,\n                                                                      ast_map,\n                                                                      &arenas,\n                                                                      &id,"}, {"sha": "4ba59a3d7ebe98dedc2def62d0624e70cc76cff9", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 26, "deletions": 54, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/84c3f898f93e294f2e50ceef271bd781b1ff6b9a/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84c3f898f93e294f2e50ceef271bd781b1ff6b9a/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=84c3f898f93e294f2e50ceef271bd781b1ff6b9a", "patch": "@@ -18,7 +18,7 @@ use decoder;\n use loader::{self, CratePaths};\n \n use rustc::hir::svh::Svh;\n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepGraph, DepNode};\n use rustc::session::{config, Session};\n use rustc::session::search_paths::PathKind;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n@@ -37,15 +37,15 @@ use syntax::parse;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::InternedString;\n-use rustc::hir::intravisit::Visitor;\n-use rustc::hir;\n+use syntax::visit;\n use log;\n \n-pub struct LocalCrateReader<'a, 'b:'a> {\n+pub struct LocalCrateReader<'a> {\n     sess: &'a Session,\n     cstore: &'a CStore,\n     creader: CrateReader<'a>,\n-    ast_map: &'a hir_map::Map<'b>,\n+    krate: &'a ast::Crate,\n+    defintions: &'a hir_map::Definitions,\n }\n \n pub struct CrateReader<'a> {\n@@ -56,8 +56,8 @@ pub struct CrateReader<'a> {\n     local_crate_name: String,\n }\n \n-impl<'a, 'b, 'hir> Visitor<'hir> for LocalCrateReader<'a, 'b> {\n-    fn visit_item(&mut self, a: &'hir hir::Item) {\n+impl<'a, 'ast> visit::Visitor<'ast> for LocalCrateReader<'a> {\n+    fn visit_item(&mut self, a: &'ast ast::Item) {\n         self.process_item(a);\n     }\n }\n@@ -80,10 +80,6 @@ fn dump_crates(cstore: &CStore) {\n fn should_link(i: &ast::Item) -> bool {\n     !attr::contains_name(&i.attrs, \"no_link\")\n }\n-// Dup for the hir\n-fn should_link_hir(i: &hir::Item) -> bool {\n-    !attr::contains_name(&i.attrs, \"no_link\")\n-}\n \n struct CrateInfo {\n     ident: String,\n@@ -181,31 +177,6 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n-    // Dup of the above, but for the hir\n-    fn extract_crate_info_hir(&self, i: &hir::Item) -> Option<CrateInfo> {\n-        match i.node {\n-            hir::ItemExternCrate(ref path_opt) => {\n-                debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n-                       i.name, path_opt);\n-                let name = match *path_opt {\n-                    Some(name) => {\n-                        validate_crate_name(Some(self.sess), &name.as_str(),\n-                                            Some(i.span));\n-                        name.to_string()\n-                    }\n-                    None => i.name.to_string(),\n-                };\n-                Some(CrateInfo {\n-                    ident: i.name.to_string(),\n-                    name: name,\n-                    id: i.id,\n-                    should_link: should_link_hir(i),\n-                })\n-            }\n-            _ => None\n-        }\n-    }\n-\n     fn existing_match(&self, name: &str, hash: Option<&Svh>, kind: PathKind)\n                       -> Option<ast::CrateNum> {\n         let mut ret = None;\n@@ -776,29 +747,30 @@ impl<'a> CrateReader<'a> {\n     }\n }\n \n-impl<'a, 'b> LocalCrateReader<'a, 'b> {\n+impl<'a> LocalCrateReader<'a> {\n     pub fn new(sess: &'a Session,\n                cstore: &'a CStore,\n-               map: &'a hir_map::Map<'b>,\n+               defs: &'a hir_map::Definitions,\n+               krate: &'a ast::Crate,\n                local_crate_name: &str)\n-               -> LocalCrateReader<'a, 'b> {\n+               -> LocalCrateReader<'a> {\n         LocalCrateReader {\n             sess: sess,\n             cstore: cstore,\n             creader: CrateReader::new(sess, cstore, local_crate_name),\n-            ast_map: map,\n+            krate: krate,\n+            defintions: defs,\n         }\n     }\n \n     // Traverses an AST, reading all the information about use'd crates and\n     // extern libraries necessary for later resolving, typechecking, linking,\n     // etc.\n-    pub fn read_crates(&mut self) {\n-        let _task = self.ast_map.dep_graph.in_task(DepNode::CrateReader);\n-        let krate = self.ast_map.krate();\n+    pub fn read_crates(&mut self, dep_graph: &DepGraph) {\n+        let _task = dep_graph.in_task(DepNode::CrateReader);\n \n-        self.process_crate(krate);\n-        krate.visit_all_items(self);\n+        self.process_crate(self.krate);\n+        visit::walk_crate(self, self.krate);\n         self.creader.inject_allocator_crate();\n \n         if log_enabled!(log::INFO) {\n@@ -811,22 +783,22 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n         self.creader.register_statically_included_foreign_items();\n     }\n \n-    fn process_crate(&self, c: &hir::Crate) {\n+    fn process_crate(&self, c: &ast::Crate) {\n         for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n             if let Some(ref linkarg) = a.value_str() {\n                 self.cstore.add_used_link_args(&linkarg);\n             }\n         }\n     }\n \n-    fn process_item(&mut self, i: &hir::Item) {\n+    fn process_item(&mut self, i: &ast::Item) {\n         match i.node {\n-            hir::ItemExternCrate(_) => {\n-                if !should_link_hir(i) {\n+            ast::ItemKind::ExternCrate(_) => {\n+                if !should_link(i) {\n                     return;\n                 }\n \n-                match self.creader.extract_crate_info_hir(i) {\n+                match self.creader.extract_crate_info(i) {\n                     Some(info) => {\n                         let (cnum, _, _) = self.creader.resolve_crate(&None,\n                                                                       &info.ident,\n@@ -835,9 +807,9 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n                                                                       i.span,\n                                                                       PathKind::Crate,\n                                                                       true);\n-                        let def_id = self.ast_map.local_def_id(i.id);\n+                        let def_id = self.defintions.opt_local_def_id(i.id).unwrap();\n \n-                        let len = self.ast_map.def_path(def_id).data.len();\n+                        let len = self.defintions.def_path(def_id.index).data.len();\n \n                         self.creader.update_extern_crate(cnum,\n                                                          ExternCrate {\n@@ -851,12 +823,12 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n                     None => ()\n                 }\n             }\n-            hir::ItemForeignMod(ref fm) => self.process_foreign_mod(i, fm),\n+            ast::ItemKind::ForeignMod(ref fm) => self.process_foreign_mod(i, fm),\n             _ => { }\n         }\n     }\n \n-    fn process_foreign_mod(&mut self, i: &hir::Item, fm: &hir::ForeignMod) {\n+    fn process_foreign_mod(&mut self, i: &ast::Item, fm: &ast::ForeignMod) {\n         if fm.abi == Abi::Rust || fm.abi == Abi::RustIntrinsic || fm.abi == Abi::PlatformIntrinsic {\n             return;\n         }"}]}