{"sha": "511dfdb8b3d8c6d395b1b5a205c3464ae802509f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMWRmZGI4YjNkOGM2ZDM5NWIxYjVhMjA1YzM0NjRhZTgwMjUwOWY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-31T06:00:19Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-13T14:16:36Z"}, "message": "parser: extract `recover_missing_kw_before_item`", "tree": {"sha": "82ecae7c6d6dab0fe23ccfa8f8db2d7031a8f3aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82ecae7c6d6dab0fe23ccfa8f8db2d7031a8f3aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/511dfdb8b3d8c6d395b1b5a205c3464ae802509f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/511dfdb8b3d8c6d395b1b5a205c3464ae802509f", "html_url": "https://github.com/rust-lang/rust/commit/511dfdb8b3d8c6d395b1b5a205c3464ae802509f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/511dfdb8b3d8c6d395b1b5a205c3464ae802509f/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7737d0ffdef6f3d7395e80291e3143522f46b95b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7737d0ffdef6f3d7395e80291e3143522f46b95b", "html_url": "https://github.com/rust-lang/rust/commit/7737d0ffdef6f3d7395e80291e3143522f46b95b"}], "stats": {"total": 174, "additions": 90, "deletions": 84}, "files": [{"sha": "acbae7dfd6810df826beaebb5b05d5a494537a2a", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 90, "deletions": 84, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/511dfdb8b3d8c6d395b1b5a205c3464ae802509f/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/511dfdb8b3d8c6d395b1b5a205c3464ae802509f/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=511dfdb8b3d8c6d395b1b5a205c3464ae802509f", "patch": "@@ -203,101 +203,107 @@ impl<'a> Parser<'a> {\n             return Ok(Some(macro_def));\n         }\n \n-        // Verify whether we have encountered a struct or method definition where the user forgot to\n-        // add the `struct` or `fn` keyword after writing `pub`: `pub S {}`\n         if vis.node.is_pub() && self.check_ident() && self.look_ahead(1, |t| *t != token::Not) {\n-            // Space between `pub` keyword and the identifier\n-            //\n-            //     pub   S {}\n-            //        ^^^ `sp` points here\n-            let sp = self.prev_span.between(self.token.span);\n-            let full_sp = self.prev_span.to(self.token.span);\n-            let ident_sp = self.token.span;\n-            if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n-                // possible public struct definition where `struct` was forgotten\n-                let ident = self.parse_ident().unwrap();\n-                let msg = format!(\"add `struct` here to parse `{}` as a public struct\", ident);\n-                let mut err = self.struct_span_err(sp, \"missing `struct` for struct definition\");\n+            self.recover_missing_kw_before_item()?;\n+        }\n+        self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, vis)\n+    }\n+\n+    /// Recover on encountering a struct or method definition where the user\n+    /// forgot to add the `struct` or `fn` keyword after writing `pub`: `pub S {}`.\n+    fn recover_missing_kw_before_item(&mut self) -> PResult<'a, ()> {\n+        // Space between `pub` keyword and the identifier\n+        //\n+        //     pub   S {}\n+        //        ^^^ `sp` points here\n+        let sp = self.prev_span.between(self.token.span);\n+        let full_sp = self.prev_span.to(self.token.span);\n+        let ident_sp = self.token.span;\n+        if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n+            // possible public struct definition where `struct` was forgotten\n+            let ident = self.parse_ident().unwrap();\n+            let msg = format!(\"add `struct` here to parse `{}` as a public struct\", ident);\n+            let mut err = self.struct_span_err(sp, \"missing `struct` for struct definition\");\n+            err.span_suggestion_short(\n+                sp,\n+                &msg,\n+                \" struct \".into(),\n+                Applicability::MaybeIncorrect, // speculative\n+            );\n+            return Err(err);\n+        } else if self.look_ahead(1, |t| *t == token::OpenDelim(token::Paren)) {\n+            let ident = self.parse_ident().unwrap();\n+            self.bump(); // `(`\n+            let kw_name = self.recover_first_param();\n+            self.consume_block(token::Paren, ConsumeClosingDelim::Yes);\n+            let (kw, kw_name, ambiguous) = if self.check(&token::RArrow) {\n+                self.eat_to_tokens(&[&token::OpenDelim(token::Brace)]);\n+                self.bump(); // `{`\n+                (\"fn\", kw_name, false)\n+            } else if self.check(&token::OpenDelim(token::Brace)) {\n+                self.bump(); // `{`\n+                (\"fn\", kw_name, false)\n+            } else if self.check(&token::Colon) {\n+                let kw = \"struct\";\n+                (kw, kw, false)\n+            } else {\n+                (\"fn` or `struct\", \"function or struct\", true)\n+            };\n+\n+            let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n+            let mut err = self.struct_span_err(sp, &msg);\n+            if !ambiguous {\n+                self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n+                let suggestion =\n+                    format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name);\n                 err.span_suggestion_short(\n                     sp,\n-                    &msg,\n-                    \" struct \".into(),\n-                    Applicability::MaybeIncorrect, // speculative\n+                    &suggestion,\n+                    format!(\" {} \", kw),\n+                    Applicability::MachineApplicable,\n                 );\n-                return Err(err);\n-            } else if self.look_ahead(1, |t| *t == token::OpenDelim(token::Paren)) {\n-                let ident = self.parse_ident().unwrap();\n-                self.bump(); // `(`\n-                let kw_name = self.recover_first_param();\n-                self.consume_block(token::Paren, ConsumeClosingDelim::Yes);\n-                let (kw, kw_name, ambiguous) = if self.check(&token::RArrow) {\n-                    self.eat_to_tokens(&[&token::OpenDelim(token::Brace)]);\n-                    self.bump(); // `{`\n-                    (\"fn\", kw_name, false)\n-                } else if self.check(&token::OpenDelim(token::Brace)) {\n-                    self.bump(); // `{`\n-                    (\"fn\", kw_name, false)\n-                } else if self.check(&token::Colon) {\n-                    let kw = \"struct\";\n-                    (kw, kw, false)\n-                } else {\n-                    (\"fn` or `struct\", \"function or struct\", true)\n-                };\n-\n-                let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n-                let mut err = self.struct_span_err(sp, &msg);\n-                if !ambiguous {\n-                    self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n-                    let suggestion =\n-                        format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name);\n-                    err.span_suggestion_short(\n-                        sp,\n-                        &suggestion,\n-                        format!(\" {} \", kw),\n-                        Applicability::MachineApplicable,\n+            } else {\n+                if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n+                    err.span_suggestion(\n+                        full_sp,\n+                        \"if you meant to call a macro, try\",\n+                        format!(\"{}!\", snippet),\n+                        // this is the `ambiguous` conditional branch\n+                        Applicability::MaybeIncorrect,\n                     );\n                 } else {\n-                    if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n-                        err.span_suggestion(\n-                            full_sp,\n-                            \"if you meant to call a macro, try\",\n-                            format!(\"{}!\", snippet),\n-                            // this is the `ambiguous` conditional branch\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        err.help(\n-                            \"if you meant to call a macro, remove the `pub` \\\n+                    err.help(\n+                        \"if you meant to call a macro, remove the `pub` \\\n                                   and add a trailing `!` after the identifier\",\n-                        );\n-                    }\n-                }\n-                return Err(err);\n-            } else if self.look_ahead(1, |t| *t == token::Lt) {\n-                let ident = self.parse_ident().unwrap();\n-                self.eat_to_tokens(&[&token::Gt]);\n-                self.bump(); // `>`\n-                let (kw, kw_name, ambiguous) = if self.eat(&token::OpenDelim(token::Paren)) {\n-                    (\"fn\", self.recover_first_param(), false)\n-                } else if self.check(&token::OpenDelim(token::Brace)) {\n-                    (\"struct\", \"struct\", false)\n-                } else {\n-                    (\"fn` or `struct\", \"function or struct\", true)\n-                };\n-                let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n-                let mut err = self.struct_span_err(sp, &msg);\n-                if !ambiguous {\n-                    err.span_suggestion_short(\n-                        sp,\n-                        &format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name),\n-                        format!(\" {} \", kw),\n-                        Applicability::MachineApplicable,\n                     );\n                 }\n-                return Err(err);\n             }\n+            return Err(err);\n+        } else if self.look_ahead(1, |t| *t == token::Lt) {\n+            let ident = self.parse_ident().unwrap();\n+            self.eat_to_tokens(&[&token::Gt]);\n+            self.bump(); // `>`\n+            let (kw, kw_name, ambiguous) = if self.eat(&token::OpenDelim(token::Paren)) {\n+                (\"fn\", self.recover_first_param(), false)\n+            } else if self.check(&token::OpenDelim(token::Brace)) {\n+                (\"struct\", \"struct\", false)\n+            } else {\n+                (\"fn` or `struct\", \"function or struct\", true)\n+            };\n+            let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n+            let mut err = self.struct_span_err(sp, &msg);\n+            if !ambiguous {\n+                err.span_suggestion_short(\n+                    sp,\n+                    &format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name),\n+                    format!(\" {} \", kw),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            return Err(err);\n+        } else {\n+            Ok(())\n         }\n-        self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, vis)\n     }\n \n     pub(super) fn mk_item_with_info("}]}