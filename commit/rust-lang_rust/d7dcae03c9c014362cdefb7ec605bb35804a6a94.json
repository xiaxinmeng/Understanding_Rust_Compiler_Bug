{"sha": "d7dcae03c9c014362cdefb7ec605bb35804a6a94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZGNhZTAzYzljMDE0MzYyY2RlZmI3ZWM2MDViYjM1ODA0YTZhOTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-18T01:11:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-18T01:11:43Z"}, "message": "Auto merge of #75653 - JohnTitor:rollup-0ejtdfo, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #75389 (attempt to improve span_label docs)\n - #75392 (Add `as_uninit`-like methods to pointer types and unify documentation of `as_ref` methods)\n - #75464 (Move to intra doc links for ascii.rs and panic.rs)\n - #75578 (Allowing raw ptr dereference in const fn)\n - #75613 (Add explanation for `&mut self` method call when expecting `-> Self`)\n - #75626 (Clean up E0754 explanation)\n - #75629 (Use intra-doc links in `std::env`, `std::alloc` and `std::error`)\n - #75634 (Mark x86_64-linux-kernel as *)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "9be507e2db101a874e421bc81a4800a0e8bcc327", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9be507e2db101a874e421bc81a4800a0e8bcc327"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7dcae03c9c014362cdefb7ec605bb35804a6a94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7dcae03c9c014362cdefb7ec605bb35804a6a94", "html_url": "https://github.com/rust-lang/rust/commit/d7dcae03c9c014362cdefb7ec605bb35804a6a94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7dcae03c9c014362cdefb7ec605bb35804a6a94/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "668ef72f4429059240ee361a2f0f748558a5326f", "url": "https://api.github.com/repos/rust-lang/rust/commits/668ef72f4429059240ee361a2f0f748558a5326f", "html_url": "https://github.com/rust-lang/rust/commit/668ef72f4429059240ee361a2f0f748558a5326f"}, {"sha": "51154d82959f941ff334de306d9426557b9f4214", "url": "https://api.github.com/repos/rust-lang/rust/commits/51154d82959f941ff334de306d9426557b9f4214", "html_url": "https://github.com/rust-lang/rust/commit/51154d82959f941ff334de306d9426557b9f4214"}], "stats": {"total": 917, "additions": 702, "deletions": 215}, "files": [{"sha": "3838fcf74ccd6f849e0358b68573f5c8075d8948", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -114,6 +114,7 @@\n #![feature(optin_builtin_traits)]\n #![feature(or_patterns)]\n #![feature(prelude_import)]\n+#![feature(ptr_as_uninit)]\n #![feature(repr_simd, platform_intrinsics)]\n #![feature(rustc_attrs)]\n #![feature(simd_ffi)]"}, {"sha": "7d7306574a6e87f80cff7884f9637ff38e4aeb12", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 117, "deletions": 17, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -2,7 +2,7 @@ use super::*;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics;\n use crate::mem;\n-use crate::slice::SliceIndex;\n+use crate::slice::{self, SliceIndex};\n \n #[lang = \"const_ptr\"]\n impl<T: ?Sized> *const T {\n@@ -48,32 +48,33 @@ impl<T: ?Sized> *const T {\n         self as _\n     }\n \n-    /// Returns `None` if the pointer is null, or else returns a reference to\n-    /// the value wrapped in `Some`.\n+    /// Returns `None` if the pointer is null, or else returns a shared reference to\n+    /// the value wrapped in `Some`. If the value may be uninitialized, [`as_uninit_ref`]\n+    /// must be used instead.\n     ///\n-    /// # Safety\n+    /// [`as_uninit_ref`]: #method.as_uninit_ref\n     ///\n-    /// While this method and its mutable counterpart are useful for\n-    /// null-safety, it is important to note that this is still an unsafe\n-    /// operation because the returned value could be pointing to invalid\n-    /// memory.\n+    /// # Safety\n     ///\n     /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n     /// all of the following is true:\n-    /// - it is properly aligned\n-    /// - it must point to an initialized instance of T; in particular, the pointer must be\n-    ///   \"dereferenceable\" in the sense defined [here].\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * The pointer must point to an initialized instance of `T`.\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n     ///\n     /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n     /// it is, the only safe approach is to ensure that they are indeed initialized.)\n     ///\n-    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n-    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n-    /// the memory the pointer points to must not get mutated (except inside `UnsafeCell`).\n-    ///\n-    /// [here]: crate::ptr#safety\n+    /// [the module documentation]: crate::ptr#safety\n     ///\n     /// # Examples\n     ///\n@@ -111,6 +112,56 @@ impl<T: ?Sized> *const T {\n         if self.is_null() { None } else { unsafe { Some(&*self) } }\n     }\n \n+    /// Returns `None` if the pointer is null, or else returns a shared reference to\n+    /// the value wrapped in `Some`. In contrast to [`as_ref`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// [`as_ref`]: #method.as_ref\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// [the module documentation]: crate::ptr#safety\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_as_uninit)]\n+    ///\n+    /// let ptr: *const u8 = &10u8 as *const u8;\n+    ///\n+    /// unsafe {\n+    ///     if let Some(val_back) = ptr.as_uninit_ref() {\n+    ///         println!(\"We got back the value: {}!\", val_back.assume_init());\n+    ///     }\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_ref<'a>(self) -> Option<&'a MaybeUninit<T>>\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        if self.is_null() { None } else { Some(unsafe { &*(self as *const MaybeUninit<T>) }) }\n+    }\n+\n     /// Calculates the offset from a pointer.\n     ///\n     /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n@@ -925,6 +976,55 @@ impl<T> *const [T] {\n         // SAFETY: the caller ensures that `self` is dereferencable and `index` in-bounds.\n         unsafe { index.get_unchecked(self) }\n     }\n+\n+    /// Returns `None` if the pointer is null, or else returns a shared slice to\n+    /// the value wrapped in `Some`. In contrast to [`as_ref`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// [`as_ref`]: #method.as_ref\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    ///\n+    /// * The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes,\n+    ///   and it must be properly aligned. This means in particular:\n+    ///\n+    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///       Slices can never span across multiple allocated objects.\n+    ///\n+    ///     * The pointer must be aligned even for zero-length slices. One\n+    ///       reason for this is that enum layout optimizations may rely on references\n+    ///       (including slices of any length) being aligned and non-null to distinguish\n+    ///       them from other data. You can obtain a pointer that is usable as `data`\n+    ///       for zero-length slices using [`NonNull::dangling()`].\n+    ///\n+    /// * The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+    ///   See the safety documentation of [`pointer::offset`].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// See also [`slice::from_raw_parts`][].\n+    ///\n+    /// [valid]: crate::ptr#safety\n+    /// [`NonNull::dangling()`]: NonNull::dangling\n+    /// [`pointer::offset`]: ../std/primitive.pointer.html#method.offset\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {\n+        if self.is_null() {\n+            None\n+        } else {\n+            // SAFETY: the caller must uphold the safety contract for `as_uninit_slice`.\n+            Some(unsafe { slice::from_raw_parts(self as *const MaybeUninit<T>, self.len()) })\n+        }\n+    }\n }\n \n // Equality for pointers"}, {"sha": "3daeec3604185b1bfbece98b9649ce445b08cd4c", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 238, "deletions": 35, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -1,7 +1,7 @@\n use super::*;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics;\n-use crate::slice::SliceIndex;\n+use crate::slice::{self, SliceIndex};\n \n #[lang = \"mut_ptr\"]\n impl<T: ?Sized> *mut T {\n@@ -47,32 +47,36 @@ impl<T: ?Sized> *mut T {\n         self as _\n     }\n \n-    /// Returns `None` if the pointer is null, or else returns a reference to\n-    /// the value wrapped in `Some`.\n+    /// Returns `None` if the pointer is null, or else returns a shared reference to\n+    /// the value wrapped in `Some`. If the value may be uninitialized, [`as_uninit_ref`]\n+    /// must be used instead.\n     ///\n-    /// # Safety\n+    /// For the mutable counterpart see [`as_mut`].\n+    ///\n+    /// [`as_uninit_ref`]: #method.as_uninit_ref-1\n+    /// [`as_mut`]: #method.as_mut\n     ///\n-    /// While this method and its mutable counterpart are useful for\n-    /// null-safety, it is important to note that this is still an unsafe\n-    /// operation because the returned value could be pointing to invalid\n-    /// memory.\n+    /// # Safety\n     ///\n     /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n     /// all of the following is true:\n-    /// - it is properly aligned\n-    /// - it must point to an initialized instance of T; in particular, the pointer must be\n-    ///   \"dereferencable\" in the sense defined [here].\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * The pointer must point to an initialized instance of `T`.\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n     ///\n     /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n     /// it is, the only safe approach is to ensure that they are indeed initialized.)\n     ///\n-    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n-    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n-    /// the memory the pointer points to must not get mutated (except inside `UnsafeCell`).\n-    ///\n-    /// [here]: crate::ptr#safety\n+    /// [the module documentation]: crate::ptr#safety\n     ///\n     /// # Examples\n     ///\n@@ -110,6 +114,59 @@ impl<T: ?Sized> *mut T {\n         if self.is_null() { None } else { unsafe { Some(&*self) } }\n     }\n \n+    /// Returns `None` if the pointer is null, or else returns a shared reference to\n+    /// the value wrapped in `Some`. In contrast to [`as_ref`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// For the mutable counterpart see [`as_uninit_mut`].\n+    ///\n+    /// [`as_ref`]: #method.as_ref-1\n+    /// [`as_uninit_mut`]: #method.as_uninit_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// [the module documentation]: crate::ptr#safety\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_as_uninit)]\n+    ///\n+    /// let ptr: *mut u8 = &mut 10u8 as *mut u8;\n+    ///\n+    /// unsafe {\n+    ///     if let Some(val_back) = ptr.as_uninit_ref() {\n+    ///         println!(\"We got back the value: {}!\", val_back.assume_init());\n+    ///     }\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_ref<'a>(self) -> Option<&'a MaybeUninit<T>>\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        if self.is_null() { None } else { Some(unsafe { &*(self as *const MaybeUninit<T>) }) }\n+    }\n+\n     /// Calculates the offset from a pointer.\n     ///\n     /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n@@ -235,33 +292,36 @@ impl<T: ?Sized> *mut T {\n         unsafe { intrinsics::arith_offset(self, count) as *mut T }\n     }\n \n-    /// Returns `None` if the pointer is null, or else returns a mutable\n-    /// reference to the value wrapped in `Some`.\n+    /// Returns `None` if the pointer is null, or else returns a unique reference to\n+    /// the value wrapped in `Some`. If the value may be uninitialized, [`as_uninit_mut`]\n+    /// must be used instead.\n     ///\n-    /// # Safety\n+    /// For the shared counterpart see [`as_ref`].\n     ///\n-    /// As with [`as_ref`], this is unsafe because it cannot verify the validity\n-    /// of the returned pointer, nor can it ensure that the lifetime `'a`\n-    /// returned is indeed a valid lifetime for the contained data.\n+    /// [`as_uninit_mut`]: #method.as_uninit_mut\n+    /// [`as_ref`]: #method.as_ref-1\n+    ///\n+    /// # Safety\n     ///\n     /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n     /// all of the following is true:\n-    /// - it is properly aligned\n-    /// - it must point to an initialized instance of T; in particular, the pointer must be\n-    ///   \"dereferenceable\" in the sense defined [here].\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * The pointer must point to an initialized instance of `T`.\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get accessed (read or written) through any other pointer.\n     ///\n     /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n-    /// it is the only safe approach is to ensure that they are indeed initialized.)\n-    ///\n-    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n-    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n-    /// the memory this pointer points to must not get accessed (read or written)\n-    /// through any other pointer.\n+    /// it is, the only safe approach is to ensure that they are indeed initialized.)\n     ///\n-    /// [here]: crate::ptr#safety\n-    /// [`as_ref`]: #method.as_ref\n+    /// [the module documentation]: crate::ptr#safety\n     ///\n     /// # Examples\n     ///\n@@ -272,6 +332,7 @@ impl<T: ?Sized> *mut T {\n     /// let ptr: *mut u32 = s.as_mut_ptr();\n     /// let first_value = unsafe { ptr.as_mut().unwrap() };\n     /// *first_value = 4;\n+    /// # assert_eq!(s, [4, 2, 3]);\n     /// println!(\"{:?}\", s); // It'll print: \"[4, 2, 3]\".\n     /// ```\n     ///\n@@ -286,6 +347,7 @@ impl<T: ?Sized> *mut T {\n     /// let ptr: *mut u32 = s.as_mut_ptr();\n     /// let first_value = unsafe { &mut *ptr };\n     /// *first_value = 4;\n+    /// # assert_eq!(s, [4, 2, 3]);\n     /// println!(\"{:?}\", s); // It'll print: \"[4, 2, 3]\".\n     /// ```\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n@@ -296,6 +358,43 @@ impl<T: ?Sized> *mut T {\n         if self.is_null() { None } else { unsafe { Some(&mut *self) } }\n     }\n \n+    /// Returns `None` if the pointer is null, or else returns a unique reference to\n+    /// the value wrapped in `Some`. In contrast to [`as_mut`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// For the shared counterpart see [`as_uninit_ref`].\n+    ///\n+    /// [`as_mut`]: #method.as_mut\n+    /// [`as_uninit_ref`]: #method.as_uninit_ref-1\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get accessed (read or written) through any other pointer.\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// [the module documentation]: crate::ptr#safety\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_mut<'a>(self) -> Option<&'a mut MaybeUninit<T>>\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        if self.is_null() { None } else { Some(unsafe { &mut *(self as *mut MaybeUninit<T>) }) }\n+    }\n+\n     /// Returns whether two pointers are guaranteed to be equal.\n     ///\n     /// At runtime this function behaves like `self == other`.\n@@ -1131,6 +1230,110 @@ impl<T> *mut [T] {\n         // SAFETY: the caller ensures that `self` is dereferencable and `index` in-bounds.\n         unsafe { index.get_unchecked_mut(self) }\n     }\n+\n+    /// Returns `None` if the pointer is null, or else returns a shared slice to\n+    /// the value wrapped in `Some`. In contrast to [`as_ref`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// For the mutable counterpart see [`as_uninit_slice_mut`].\n+    ///\n+    /// [`as_ref`]: #method.as_ref-1\n+    /// [`as_uninit_slice_mut`]: #method.as_uninit_slice_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    ///\n+    /// * The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes,\n+    ///   and it must be properly aligned. This means in particular:\n+    ///\n+    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///       Slices can never span across multiple allocated objects.\n+    ///\n+    ///     * The pointer must be aligned even for zero-length slices. One\n+    ///       reason for this is that enum layout optimizations may rely on references\n+    ///       (including slices of any length) being aligned and non-null to distinguish\n+    ///       them from other data. You can obtain a pointer that is usable as `data`\n+    ///       for zero-length slices using [`NonNull::dangling()`].\n+    ///\n+    /// * The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+    ///   See the safety documentation of [`pointer::offset`].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// See also [`slice::from_raw_parts`][].\n+    ///\n+    /// [valid]: crate::ptr#safety\n+    /// [`NonNull::dangling()`]: NonNull::dangling\n+    /// [`pointer::offset`]: ../std/primitive.pointer.html#method.offset\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_slice<'a>(self) -> Option<&'a [MaybeUninit<T>]> {\n+        if self.is_null() {\n+            None\n+        } else {\n+            // SAFETY: the caller must uphold the safety contract for `as_uninit_slice`.\n+            Some(unsafe { slice::from_raw_parts(self as *const MaybeUninit<T>, self.len()) })\n+        }\n+    }\n+\n+    /// Returns `None` if the pointer is null, or else returns a unique slice to\n+    /// the value wrapped in `Some`. In contrast to [`as_mut`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// For the shared counterpart see [`as_uninit_slice`].\n+    ///\n+    /// [`as_mut`]: #method.as_mut\n+    /// [`as_uninit_slice`]: #method.as_uninit_slice-1\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    ///\n+    /// * The pointer must be [valid] for reads and writes for `ptr.len() * mem::size_of::<T>()`\n+    ///   many bytes, and it must be properly aligned. This means in particular:\n+    ///\n+    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///       Slices can never span across multiple allocated objects.\n+    ///\n+    ///     * The pointer must be aligned even for zero-length slices. One\n+    ///       reason for this is that enum layout optimizations may rely on references\n+    ///       (including slices of any length) being aligned and non-null to distinguish\n+    ///       them from other data. You can obtain a pointer that is usable as `data`\n+    ///       for zero-length slices using [`NonNull::dangling()`].\n+    ///\n+    /// * The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+    ///   See the safety documentation of [`pointer::offset`].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get accessed (read or written) through any other pointer.\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// See also [`slice::from_raw_parts_mut`][].\n+    ///\n+    /// [valid]: crate::ptr#safety\n+    /// [`NonNull::dangling()`]: NonNull::dangling\n+    /// [`pointer::offset`]: ../std/primitive.pointer.html#method.offset\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_slice_mut<'a>(self) -> Option<&'a mut [MaybeUninit<T>]> {\n+        if self.is_null() {\n+            None\n+        } else {\n+            // SAFETY: the caller must uphold the safety contract for `as_uninit_slice_mut`.\n+            Some(unsafe { slice::from_raw_parts_mut(self as *mut MaybeUninit<T>, self.len()) })\n+        }\n+    }\n }\n \n // Equality for pointers"}, {"sha": "294a3173d0cbf7ee00a4a0b18c197339ca6cdc3c", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 212, "deletions": 29, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -3,10 +3,10 @@ use crate::convert::From;\n use crate::fmt;\n use crate::hash;\n use crate::marker::Unsize;\n-use crate::mem;\n+use crate::mem::{self, MaybeUninit};\n use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::Unique;\n-use crate::slice::SliceIndex;\n+use crate::slice::{self, SliceIndex};\n \n /// `*mut T` but non-zero and covariant.\n ///\n@@ -76,6 +76,70 @@ impl<T: Sized> NonNull<T> {\n             NonNull::new_unchecked(ptr)\n         }\n     }\n+\n+    /// Returns a shared references to the value. In contrast to [`as_ref`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// For the mutable counterpart see [`as_uninit_mut`].\n+    ///\n+    /// [`as_ref`]: #method.as_ref\n+    /// [`as_uninit_mut`]: #method.as_uninit_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that all of the following is true:\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// [the module documentation]: crate::ptr#safety\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_ref(&self) -> &MaybeUninit<T> {\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        unsafe { &*self.cast().as_ptr() }\n+    }\n+\n+    /// Returns a unique references to the value. In contrast to [`as_mut`], this does not require\n+    /// that the value has to be initialized.\n+    ///\n+    /// For the shared counterpart see [`as_uninit_ref`].\n+    ///\n+    /// [`as_mut`]: #method.as_mut\n+    /// [`as_uninit_ref`]: #method.as_uninit_ref\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that all of the following is true:\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get accessed (read or written) through any other pointer.\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// [the module documentation]: crate::ptr#safety\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_mut(&mut self) -> &mut MaybeUninit<T> {\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        unsafe { &mut *self.cast().as_ptr() }\n+    }\n }\n \n impl<T: ?Sized> NonNull<T> {\n@@ -112,29 +176,34 @@ impl<T: ?Sized> NonNull<T> {\n         self.pointer as *mut T\n     }\n \n-    /// Dereferences the content.\n+    /// Returns a shared reference to the value. If the value may be uninitialized, [`as_uninit_ref`]\n+    /// must be used instead.\n+    ///\n+    /// For the mutable counterpart see [`as_mut`].\n     ///\n-    /// The resulting lifetime is bound to self so this behaves \"as if\"\n-    /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n+    /// [`as_uninit_ref`]: #method.as_uninit_ref\n+    /// [`as_mut`]: #method.as_mut\n     ///\n     /// # Safety\n     ///\n     /// When calling this method, you have to ensure that all of the following is true:\n-    /// - `self` is properly aligned\n-    /// - `self` must point to an initialized instance of T; in particular, the pointer must be\n-    ///   \"dereferencable\" in the sense defined [here].\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * The pointer must point to an initialized instance of `T`.\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n     ///\n     /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n     /// it is, the only safe approach is to ensure that they are indeed initialized.)\n     ///\n-    /// Additionally, the lifetime of `self` does not necessarily reflect the actual\n-    /// lifetime of the data. *You* must enforce Rust's aliasing rules. In particular,\n-    /// for the duration of this lifetime, the memory the pointer points to must not\n-    /// get mutated (except inside `UnsafeCell`).\n-    ///\n-    /// [here]: crate::ptr#safety\n+    /// [the module documentation]: crate::ptr#safety\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub unsafe fn as_ref(&self) -> &T {\n@@ -143,29 +212,34 @@ impl<T: ?Sized> NonNull<T> {\n         unsafe { &*self.as_ptr() }\n     }\n \n-    /// Mutably dereferences the content.\n+    /// Returns a unique reference to the value. If the value may be uninitialized, [`as_uninit_mut`]\n+    /// must be used instead.\n+    ///\n+    /// For the shared counterpart see [`as_ref`].\n     ///\n-    /// The resulting lifetime is bound to self so this behaves \"as if\"\n-    /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n+    /// [`as_uninit_mut`]: #method.as_uninit_mut\n+    /// [`as_ref`]: #method.as_ref\n     ///\n     /// # Safety\n     ///\n     /// When calling this method, you have to ensure that all of the following is true:\n-    /// - `self` is properly aligned\n-    /// - `self` must point to an initialized instance of T; in particular, the pointer must be\n-    ///   \"dereferenceable\" in the sense defined [here].\n+    ///\n+    /// * The pointer must be properly aligned.\n+    ///\n+    /// * It must be \"dereferencable\" in the sense defined in [the module documentation].\n+    ///\n+    /// * The pointer must point to an initialized instance of `T`.\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get accessed (read or written) through any other pointer.\n     ///\n     /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n-    /// it is the only safe approach is to ensure that they are indeed initialized.)\n-    ///\n-    /// Additionally, the lifetime of `self` does not necessarily reflect the actual\n-    /// lifetime of the data. *You* must enforce Rust's aliasing rules. In particular,\n-    /// for the duration of this lifetime, the memory this pointer points to must not\n-    /// get accessed (read or written) through any other pointer.\n+    /// it is, the only safe approach is to ensure that they are indeed initialized.)\n     ///\n-    /// [here]: crate::ptr#safety\n+    /// [the module documentation]: crate::ptr#safety\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n@@ -278,6 +352,115 @@ impl<T> NonNull<[T]> {\n         self.as_non_null_ptr().as_ptr()\n     }\n \n+    /// Returns a shared reference to a slice of possibly uninitialized values. In contrast to\n+    /// [`as_ref`], this does not require that the value has to be initialized.\n+    ///\n+    /// For the mutable counterpart see [`as_uninit_slice_mut`].\n+    ///\n+    /// [`as_ref`]: #method.as_ref\n+    /// [`as_uninit_slice_mut`]: #method.as_uninit_slice_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that all of the following is true:\n+    ///\n+    /// * The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes,\n+    ///   and it must be properly aligned. This means in particular:\n+    ///\n+    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///       Slices can never span across multiple allocated objects.\n+    ///\n+    ///     * The pointer must be aligned even for zero-length slices. One\n+    ///       reason for this is that enum layout optimizations may rely on references\n+    ///       (including slices of any length) being aligned and non-null to distinguish\n+    ///       them from other data. You can obtain a pointer that is usable as `data`\n+    ///       for zero-length slices using [`NonNull::dangling()`].\n+    ///\n+    /// * The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+    ///   See the safety documentation of [`pointer::offset`].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// See also [`slice::from_raw_parts`][].\n+    ///\n+    /// [valid]: crate::ptr#safety\n+    /// [`NonNull::dangling()`]: NonNull::dangling\n+    /// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_slice(&self) -> &[MaybeUninit<T>] {\n+        // SAFETY: the caller must uphold the safety contract for `as_uninit_slice`.\n+        unsafe { slice::from_raw_parts(self.cast().as_ptr(), self.len()) }\n+    }\n+\n+    /// Returns a unique reference to a slice of possibly uninitialized values. In contrast to\n+    /// [`as_mut`], this does not require that the value has to be initialized.\n+    ///\n+    /// For the shared counterpart see [`as_uninit_slice`].\n+    ///\n+    /// [`as_mut`]: #method.as_mut\n+    /// [`as_uninit_slice`]: #method.as_uninit_slice\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that all of the following is true:\n+    ///\n+    /// * The pointer must be [valid] for reads and writes for `ptr.len() * mem::size_of::<T>()`\n+    ///   many bytes, and it must be properly aligned. This means in particular:\n+    ///\n+    ///     * The entire memory range of this slice must be contained within a single allocated object!\n+    ///       Slices can never span across multiple allocated objects.\n+    ///\n+    ///     * The pointer must be aligned even for zero-length slices. One\n+    ///       reason for this is that enum layout optimizations may rely on references\n+    ///       (including slices of any length) being aligned and non-null to distinguish\n+    ///       them from other data. You can obtain a pointer that is usable as `data`\n+    ///       for zero-length slices using [`NonNull::dangling()`].\n+    ///\n+    /// * The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+    ///   See the safety documentation of [`pointer::offset`].\n+    ///\n+    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n+    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n+    ///   In particular, for the duration of this lifetime, the memory the pointer points to must\n+    ///   not get accessed (read or written) through any other pointer.\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    ///\n+    /// See also [`slice::from_raw_parts_mut`][].\n+    ///\n+    /// [valid]: crate::ptr#safety\n+    /// [`NonNull::dangling()`]: NonNull::dangling\n+    /// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(allocator_api, ptr_as_uninit)]\n+    ///\n+    /// use std::alloc::{AllocRef, Layout, Global};\n+    /// use std::mem::MaybeUninit;\n+    /// use std::ptr::NonNull;\n+    ///\n+    /// let memory: NonNull<[u8]> = Global.alloc(Layout::new::<[u8; 32]>())?;\n+    /// // This is safe as `memory` is valid for reads and writes for `memory.len()` many bytes.\n+    /// // Note that calling `memory.as_mut()` is not allowed here as the content may be uninitialized.\n+    /// # #[allow(unused_variables)]\n+    /// let slice: &mut [MaybeUninit<u8>] = unsafe { memory.as_uninit_slice_mut() };\n+    /// # Ok::<_, std::alloc::AllocErr>(())\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n+    pub unsafe fn as_uninit_slice_mut(&self) -> &mut [MaybeUninit<T>] {\n+        // SAFETY: the caller must uphold the safety contract for `as_uninit_slice_mut`.\n+        unsafe { slice::from_raw_parts_mut(self.cast().as_ptr(), self.len()) }\n+    }\n+\n     /// Returns a raw pointer to an element or subslice, without doing bounds\n     /// checking.\n     ///"}, {"sha": "37a8f514aa1574da0cf12dba6fa0ff095403394b", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -7,8 +7,6 @@\n //! like `cdylib`s and `staticlib`s are guaranteed to use the [`System`] by\n //! default.\n //!\n-//! [`System`]: struct.System.html\n-//!\n //! # The `#[global_allocator]` attribute\n //!\n //! This attribute allows configuring the choice of global allocator.\n@@ -43,8 +41,6 @@\n //! The attribute is used on a `static` item whose type implements the\n //! [`GlobalAlloc`] trait. This type can be provided by an external library:\n //!\n-//! [`GlobalAlloc`]: ../../core/alloc/trait.GlobalAlloc.html\n-//!\n //! ```rust,ignore (demonstrates crates.io usage)\n //! extern crate jemallocator;\n //!\n@@ -284,9 +280,6 @@ static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());\n /// about the allocation that failed.\n ///\n /// The allocation error hook is a global resource.\n-///\n-/// [`set_alloc_error_hook`]: fn.set_alloc_error_hook.html\n-/// [`take_alloc_error_hook`]: fn.take_alloc_error_hook.html\n #[unstable(feature = \"alloc_error_hook\", issue = \"51245\")]\n pub fn set_alloc_error_hook(hook: fn(Layout)) {\n     HOOK.store(hook as *mut (), Ordering::SeqCst);\n@@ -297,8 +290,6 @@ pub fn set_alloc_error_hook(hook: fn(Layout)) {\n /// *See also the function [`set_alloc_error_hook`].*\n ///\n /// If no custom hook is registered, the default hook will be returned.\n-///\n-/// [`set_alloc_error_hook`]: fn.set_alloc_error_hook.html\n #[unstable(feature = \"alloc_error_hook\", issue = \"51245\")]\n pub fn take_alloc_error_hook() -> fn(Layout) {\n     let hook = HOOK.swap(ptr::null_mut(), Ordering::SeqCst);"}, {"sha": "c9106136d3441a8bab44a92a6080b5d801c2d03a", "filename": "library/std/src/ascii.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fstd%2Fsrc%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fstd%2Fsrc%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fascii.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -10,9 +10,6 @@\n //!\n //! The [`escape_default`] function provides an iterator over the bytes of an\n //! escaped version of the character given.\n-//!\n-//! [`AsciiExt`]: trait.AsciiExt.html\n-//! [`escape_default`]: fn.escape_default.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -52,7 +49,7 @@ pub trait AsciiExt {\n     ///\n     /// # Note\n     ///\n-    /// This method will be deprecated in favor of the identically-named\n+    /// This method is deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_ascii(&self) -> bool;\n@@ -69,10 +66,10 @@ pub trait AsciiExt {\n     ///\n     /// # Note\n     ///\n-    /// This method will be deprecated in favor of the identically-named\n+    /// This method is deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     ///\n-    /// [`make_ascii_uppercase`]: #tymethod.make_ascii_uppercase\n+    /// [`make_ascii_uppercase`]: AsciiExt::make_ascii_uppercase\n     /// [`str::to_uppercase`]: ../primitive.str.html#method.to_uppercase\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n@@ -90,10 +87,10 @@ pub trait AsciiExt {\n     ///\n     /// # Note\n     ///\n-    /// This method will be deprecated in favor of the identically-named\n+    /// This method is deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     ///\n-    /// [`make_ascii_lowercase`]: #tymethod.make_ascii_lowercase\n+    /// [`make_ascii_lowercase`]: AsciiExt::make_ascii_lowercase\n     /// [`str::to_lowercase`]: ../primitive.str.html#method.to_lowercase\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n@@ -106,7 +103,7 @@ pub trait AsciiExt {\n     ///\n     /// # Note\n     ///\n-    /// This method will be deprecated in favor of the identically-named\n+    /// This method is deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n@@ -121,10 +118,10 @@ pub trait AsciiExt {\n     ///\n     /// # Note\n     ///\n-    /// This method will be deprecated in favor of the identically-named\n+    /// This method is deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     ///\n-    /// [`to_ascii_uppercase`]: #tymethod.to_ascii_uppercase\n+    /// [`to_ascii_uppercase`]: AsciiExt::to_ascii_uppercase\n     #[stable(feature = \"ascii\", since = \"1.9.0\")]\n     fn make_ascii_uppercase(&mut self);\n \n@@ -138,10 +135,10 @@ pub trait AsciiExt {\n     ///\n     /// # Note\n     ///\n-    /// This method will be deprecated in favor of the identically-named\n+    /// This method is deprecated in favor of the identically-named\n     /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     ///\n-    /// [`to_ascii_lowercase`]: #tymethod.to_ascii_lowercase\n+    /// [`to_ascii_lowercase`]: AsciiExt::to_ascii_lowercase\n     #[stable(feature = \"ascii\", since = \"1.9.0\")]\n     fn make_ascii_lowercase(&mut self);\n }"}, {"sha": "387c588f4a061d18f7e1879202ac9f9ce0790395", "filename": "library/std/src/env.rs", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fstd%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fstd%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fenv.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -7,9 +7,6 @@\n //! There are several functions and structs in this module that have a\n //! counterpart ending in `os`. Those ending in `os` will return an [`OsString`]\n //! and those without will return a [`String`].\n-//!\n-//! [`OsString`]: ../../std/ffi/struct.OsString.html\n-//! [`String`]: ../string/struct.String.html\n \n #![stable(feature = \"env\", since = \"1.0.0\")]\n \n@@ -31,9 +28,6 @@ use crate::sys::os as os_imp;\n /// * Current directory does not exist.\n /// * There are insufficient permissions to access the current directory.\n ///\n-/// [`PathBuf`]: ../../std/path/struct.PathBuf.html\n-/// [`Err`]: ../../std/result/enum.Result.html#method.err\n-///\n /// # Examples\n ///\n /// ```\n@@ -54,8 +48,6 @@ pub fn current_dir() -> io::Result<PathBuf> {\n ///\n /// Returns an [`Err`] if the operation fails.\n ///\n-/// [`Err`]: ../../std/result/enum.Result.html#method.err\n-///\n /// # Examples\n ///\n /// ```\n@@ -76,7 +68,7 @@ pub fn set_current_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// This structure is created by the [`std::env::vars`] function. See its\n /// documentation for more.\n ///\n-/// [`std::env::vars`]: fn.vars.html\n+/// [`std::env::vars`]: vars\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub struct Vars {\n     inner: VarsOs,\n@@ -87,7 +79,7 @@ pub struct Vars {\n /// This structure is created by the [`std::env::vars_os`] function. See\n /// its documentation for more.\n ///\n-/// [`std::env::vars_os`]: fn.vars_os.html\n+/// [`std::env::vars_os`]: vars_os\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub struct VarsOs {\n     inner: os_imp::Env,\n@@ -106,7 +98,7 @@ pub struct VarsOs {\n /// environment is not valid unicode. If this is not desired, consider using the\n /// [`env::vars_os`] function.\n ///\n-/// [`env::vars_os`]: fn.vars_os.html\n+/// [`env::vars_os`]: vars_os\n ///\n /// # Examples\n ///\n@@ -222,8 +214,6 @@ fn _var(key: &OsStr) -> Result<String, VarError> {\n /// Fetches the environment variable `key` from the current process, returning\n /// [`None`] if the variable isn't set.\n ///\n-/// [`None`]: ../option/enum.Option.html#variant.None\n-///\n /// # Panics\n ///\n /// This function may panic if `key` is empty, contains an ASCII equals sign\n@@ -254,7 +244,7 @@ fn _var_os(key: &OsStr) -> Option<OsString> {\n /// The error type for operations interacting with environment variables.\n /// Possibly returned from the [`env::var`] function.\n ///\n-/// [`env::var`]: fn.var.html\n+/// [`env::var`]: var\n #[derive(Debug, PartialEq, Eq, Clone)]\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub enum VarError {\n@@ -382,8 +372,7 @@ fn _remove_var(k: &OsStr) {\n /// This structure is created by the [`std::env::split_paths`] function. See its\n /// documentation for more.\n ///\n-/// [`PathBuf`]: ../../std/path/struct.PathBuf.html\n-/// [`std::env::split_paths`]: fn.split_paths.html\n+/// [`std::env::split_paths`]: split_paths\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub struct SplitPaths<'a> {\n     inner: os_imp::SplitPaths<'a>,\n@@ -410,8 +399,6 @@ pub struct SplitPaths<'a> {\n ///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n-///\n-/// [`PathBuf`]: ../../std/path/struct.PathBuf.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn split_paths<T: AsRef<OsStr> + ?Sized>(unparsed: &T) -> SplitPaths<'_> {\n     SplitPaths { inner: os_imp::split_paths(unparsed.as_ref()) }\n@@ -438,7 +425,7 @@ impl fmt::Debug for SplitPaths<'_> {\n /// The error type for operations on the `PATH` variable. Possibly returned from\n /// the [`env::join_paths`] function.\n ///\n-/// [`env::join_paths`]: fn.join_paths.html\n+/// [`env::join_paths`]: join_paths\n #[derive(Debug)]\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub struct JoinPathsError {\n@@ -450,14 +437,10 @@ pub struct JoinPathsError {\n ///\n /// # Errors\n ///\n-/// Returns an [`Err`][err] (containing an error message) if one of the input\n+/// Returns an [`Err`] (containing an error message) if one of the input\n /// [`Path`]s contains an invalid character for constructing the `PATH`\n /// variable (a double quote on Windows or a colon on Unix).\n ///\n-/// [`Path`]: ../../std/path/struct.Path.html\n-/// [`OsString`]: ../../std/ffi/struct.OsString.html\n-/// [err]: ../../std/result/enum.Result.html#variant.Err\n-///\n /// # Examples\n ///\n /// Joining paths on a Unix-like platform:\n@@ -508,7 +491,7 @@ pub struct JoinPathsError {\n /// }\n /// ```\n ///\n-/// [`env::split_paths`]: fn.split_paths.html\n+/// [`env::split_paths`]: split_paths\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n where\n@@ -688,8 +671,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n /// set to arbitrary text, and may not even exist. This means this property\n /// should not be relied upon for security purposes.\n ///\n-/// [`String`]: ../string/struct.String.html\n-/// [`std::env::args`]: ./fn.args.html\n+/// [`std::env::args`]: args\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub struct Args {\n     inner: ArgsOs,\n@@ -705,8 +687,7 @@ pub struct Args {\n /// set to arbitrary text, and may not even exist. This means this property\n /// should not be relied upon for security purposes.\n ///\n-/// [`OsString`]: ../ffi/struct.OsString.html\n-/// [`std::env::args_os`]: ./fn.args_os.html\n+/// [`std::env::args_os`]: args_os\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub struct ArgsOs {\n     inner: sys::args::Args,\n@@ -744,8 +725,6 @@ pub struct ArgsOs {\n ///     println!(\"{}\", argument);\n /// }\n /// ```\n-///\n-/// [`args_os`]: ./fn.args_os.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn args() -> Args {\n     Args { inner: args_os() }"}, {"sha": "1b7681bd4bb1de0cc282b2efdc972b81bb842659", "filename": "library/std/src/error.rs", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -40,10 +40,8 @@ use crate::string;\n /// provide its own errors while also revealing some of the implementation for\n /// debugging via [`source`] chains.\n ///\n-/// [`Result<T, E>`]: ../result/enum.Result.html\n-/// [`Display`]: ../fmt/trait.Display.html\n-/// [`Debug`]: ../fmt/trait.Debug.html\n-/// [`source`]: trait.Error.html#method.source\n+/// [`Result<T, E>`]: Result\n+/// [`source`]: Error::source\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Error: Debug + Display {\n     /// The lower-level source of this error, if any.\n@@ -164,8 +162,6 @@ mod private {\n impl<'a, E: Error + 'a> From<E> for Box<dyn Error + 'a> {\n     /// Converts a type of [`Error`] into a box of dyn [`Error`].\n     ///\n-    /// [`Error`]: ../error/trait.Error.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -199,8 +195,6 @@ impl<'a, E: Error + Send + Sync + 'a> From<E> for Box<dyn Error + Send + Sync +\n     /// Converts a type of [`Error`] + [`Send`] + [`Sync`] into a box of\n     /// dyn [`Error`] + [`Send`] + [`Sync`].\n     ///\n-    /// [`Error`]: ../error/trait.Error.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -238,8 +232,6 @@ impl<'a, E: Error + Send + Sync + 'a> From<E> for Box<dyn Error + Send + Sync +\n impl From<String> for Box<dyn Error + Send + Sync> {\n     /// Converts a [`String`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n     ///\n-    /// [`Error`]: ../error/trait.Error.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -283,8 +275,6 @@ impl From<String> for Box<dyn Error + Send + Sync> {\n impl From<String> for Box<dyn Error> {\n     /// Converts a [`String`] into a box of dyn [`Error`].\n     ///\n-    /// [`Error`]: ../error/trait.Error.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -306,8 +296,6 @@ impl From<String> for Box<dyn Error> {\n impl<'a> From<&str> for Box<dyn Error + Send + Sync + 'a> {\n     /// Converts a [`str`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n     ///\n-    /// [`Error`]: ../error/trait.Error.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -329,8 +317,6 @@ impl<'a> From<&str> for Box<dyn Error + Send + Sync + 'a> {\n impl From<&str> for Box<dyn Error> {\n     /// Converts a [`str`] into a box of dyn [`Error`].\n     ///\n-    /// [`Error`]: ../error/trait.Error.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -350,9 +336,6 @@ impl From<&str> for Box<dyn Error> {\n impl<'a, 'b> From<Cow<'b, str>> for Box<dyn Error + Send + Sync + 'a> {\n     /// Converts a [`Cow`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n     ///\n-    /// [`Cow`]: ../borrow/enum.Cow.html\n-    /// [`Error`]: ../error/trait.Error.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -374,9 +357,6 @@ impl<'a, 'b> From<Cow<'b, str>> for Box<dyn Error + Send + Sync + 'a> {\n impl<'a> From<Cow<'a, str>> for Box<dyn Error> {\n     /// Converts a [`Cow`] into a box of dyn [`Error`].\n     ///\n-    /// [`Cow`]: ../borrow/enum.Cow.html\n-    /// [`Error`]: ../error/trait.Error.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -703,7 +683,7 @@ impl dyn Error {\n     /// assert!(iter.next().is_none());\n     /// ```\n     ///\n-    /// [`source`]: trait.Error.html#method.source\n+    /// [`source`]: Error::source\n     #[unstable(feature = \"error_iter\", issue = \"58520\")]\n     #[inline]\n     pub fn chain(&self) -> Chain<'_> {\n@@ -715,8 +695,6 @@ impl dyn Error {\n ///\n /// If you want to omit the initial error and only process\n /// its sources, use `skip(1)`.\n-///\n-/// [`Error`]: trait.Error.html\n #[unstable(feature = \"error_iter\", issue = \"58520\")]\n #[derive(Clone, Debug)]\n pub struct Chain<'a> {"}, {"sha": "8fcb24033b1a74819d2b89e2b1a8e15ed72473bf", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -30,10 +30,6 @@ pub use core::panic::{Location, PanicInfo};\n /// purpose of this trait is to encode what types are safe to cross a [`catch_unwind`]\n /// boundary with no fear of unwind safety.\n ///\n-/// [`Send`]: ../marker/trait.Send.html\n-/// [`Sync`]: ../marker/trait.Sync.html\n-/// [`catch_unwind`]: ./fn.catch_unwind.html\n-///\n /// ## What is unwind safety?\n ///\n /// In Rust a function can \"return\" early if it either panics or calls a\n@@ -99,8 +95,6 @@ pub use core::panic::{Location, PanicInfo};\n /// above, the lack of `unsafe` means it is mostly an advisory. The\n /// [`AssertUnwindSafe`] wrapper struct can be used to force this trait to be\n /// implemented for any closed over variables passed to `catch_unwind`.\n-///\n-/// [`AssertUnwindSafe`]: ./struct.AssertUnwindSafe.html\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n #[rustc_on_unimplemented(\n     message = \"the type `{Self}` may not be safely transferred across an unwind boundary\",\n@@ -116,9 +110,6 @@ pub auto trait UnwindSafe {}\n ///\n /// This is a \"helper marker trait\" used to provide impl blocks for the\n /// [`UnwindSafe`] trait, for more information see that documentation.\n-///\n-/// [`UnsafeCell`]: ../cell/struct.UnsafeCell.html\n-/// [`UnwindSafe`]: ./trait.UnwindSafe.html\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n #[rustc_on_unimplemented(\n     message = \"the type `{Self}` may contain interior mutability and a reference may not be safely \\\n@@ -138,7 +129,6 @@ pub auto trait RefUnwindSafe {}\n /// account. This wrapper struct is useful for a quick and lightweight\n /// annotation that a variable is indeed unwind safe.\n ///\n-/// [`catch_unwind`]: ./fn.catch_unwind.html\n /// # Examples\n ///\n /// One way to use `AssertUnwindSafe` is to assert that the entire closure\n@@ -352,8 +342,6 @@ impl<F: Future> Future for AssertUnwindSafe<F> {\n /// can fail on a regular basis. Additionally, this function is not guaranteed\n /// to catch all panics, see the \"Notes\" section below.\n ///\n-/// [`Result`]: ../result/enum.Result.html\n-///\n /// The closure provided is required to adhere to the [`UnwindSafe`] trait to ensure\n /// that all captured variables are safe to cross this boundary. The purpose of\n /// this bound is to encode the concept of [exception safety][rfc] in the type\n@@ -362,9 +350,6 @@ impl<F: Future> Future for AssertUnwindSafe<F> {\n /// becomes a problem the [`AssertUnwindSafe`] wrapper struct can be used to quickly\n /// assert that the usage here is indeed unwind safe.\n ///\n-/// [`AssertUnwindSafe`]: ./struct.AssertUnwindSafe.html\n-/// [`UnwindSafe`]: ./trait.UnwindSafe.html\n-///\n /// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n ///\n /// # Notes\n@@ -399,8 +384,6 @@ pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n /// This is designed to be used in conjunction with [`catch_unwind`] to, for\n /// example, carry a panic across a layer of C code.\n ///\n-/// [`catch_unwind`]: ./fn.catch_unwind.html\n-///\n /// # Notes\n ///\n /// Note that panics in Rust are not always implemented via unwinding, but they"}, {"sha": "21874853839bd3b88002a7fac60594c1abd89fb1", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -204,7 +204,7 @@ target | std | host | notes\n `thumbv4t-none-eabi` | * |  | ARMv4T T32\n `x86_64-apple-ios-macabi` | \u2713[^apple] |  | Apple Catalyst\n `x86_64-apple-tvos` | *[^apple] | | x86 64-bit tvOS\n-`x86_64-linux-kernel` | ? |  | Linux kernel modules\n+`x86_64-linux-kernel` | * |  | Linux kernel modules\n `x86_64-pc-solaris` | ? |  |\n `x86_64-pc-windows-msvc` | \u2713 |  | 64-bit Windows XP support\n `x86_64-unknown-cloudabi` | \u2713 |  | 64-bit CloudABI"}, {"sha": "57620bcd65c18bd5d105f40258dc3026049f372f", "filename": "src/librustc_error_codes/error_codes/E0754.md", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Flibrustc_error_codes%2Ferror_codes%2FE0754.md", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Flibrustc_error_codes%2Ferror_codes%2FE0754.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0754.md?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -1,31 +1,25 @@\n An non-ascii identifier was used in an invalid context.\n \n-Erroneous code example:\n+Erroneous code examples:\n \n ```compile_fail,E0754\n # #![feature(non_ascii_idents)]\n \n-mod \u0159\u0173\u015b\u0165;\n-// ^ error!\n-fn main() {}\n-```\n-\n-```compile_fail,E0754\n-# #![feature(non_ascii_idents)]\n+mod \u0159\u0173\u015b\u0165; // error!\n \n #[no_mangle]\n-fn \u0159\u0173\u015b\u0165() {}\n-// ^ error!\n+fn \u0159\u0173\u015b\u0165() {} // error!\n+\n fn main() {}\n ```\n \n-Non-ascii can be used as module names if it is inline\n-or a #\\[path\\] attribute is specified. For example:\n+Non-ascii can be used as module names if it is inlined or if a `#[path]`\n+attribute is specified. For example:\n \n ```\n # #![feature(non_ascii_idents)]\n \n-mod \u0159\u0173\u015b\u0165 {\n+mod \u0159\u0173\u015b\u0165 { // ok!\n     const IS_GREAT: bool = true;\n }\n "}, {"sha": "870f7b81e21aa734db26b63eaf26c46ad02ef158", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -127,14 +127,15 @@ impl Diagnostic {\n     }\n \n     /// Adds a span/label to be included in the resulting snippet.\n-    /// This label will be shown together with the original span/label used when creating the\n-    /// diagnostic, *not* a span added by one of the `span_*` methods.\n     ///\n-    /// This is pushed onto the `MultiSpan` that was created when the\n-    /// diagnostic was first built. If you don't call this function at\n-    /// all, and you just supplied a `Span` to create the diagnostic,\n-    /// then the snippet will just include that `Span`, which is\n-    /// called the primary span.\n+    /// This is pushed onto the [`MultiSpan`] that was created when the diagnostic\n+    /// was first built. That means it will be shown together with the original\n+    /// span/label, *not* a span added by one of the `span_{note,warn,help,suggestions}` methods.\n+    ///\n+    /// This span is *not* considered a [\"primary span\"][`MultiSpan`]; only\n+    /// the `Span` supplied when creating the diagnostic is primary.\n+    ///\n+    /// [`MultiSpan`]: ../rustc_span/struct.MultiSpan.html\n     pub fn span_label<T: Into<String>>(&mut self, span: Span, label: T) -> &mut Self {\n         self.span.push_span_label(span, label.into());\n         self"}, {"sha": "d1ff6f721c4151ca8949574bdcbfff59b5eb282e", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -184,11 +184,15 @@ impl<'a> DiagnosticBuilder<'a> {\n     }\n \n     /// Adds a span/label to be included in the resulting snippet.\n-    /// This is pushed onto the `MultiSpan` that was created when the\n-    /// diagnostic was first built. If you don't call this function at\n-    /// all, and you just supplied a `Span` to create the diagnostic,\n-    /// then the snippet will just include that `Span`, which is\n-    /// called the primary span.\n+    ///\n+    /// This is pushed onto the [`MultiSpan`] that was created when the diagnostic\n+    /// was first built. That means it will be shown together with the original\n+    /// span/label, *not* a span added by one of the `span_{note,warn,help,suggestions}` methods.\n+    ///\n+    /// This span is *not* considered a [\"primary span\"][`MultiSpan`]; only\n+    /// the `Span` supplied when creating the diagnostic is primary.\n+    ///\n+    /// [`MultiSpan`]: ../rustc_span/struct.MultiSpan.html\n     pub fn span_label(&mut self, span: Span, label: impl Into<String>) -> &mut Self {\n         self.0.diagnostic.span_label(span, label);\n         self"}, {"sha": "6aabc1941a65e0eaeb969b388fd252ef7a7463b1", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -228,7 +228,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n             match base_ty.kind {\n                 ty::RawPtr(..) => self.require_unsafe(\n-                    UnsafetyViolationKind::General,\n+                    UnsafetyViolationKind::GeneralAndConstFn,\n                     UnsafetyViolationDetails::DerefOfRawPointer,\n                 ),\n                 ty::Adt(adt, _) => {"}, {"sha": "aa92d8b8b2b9b8d7e8f57bd57e70762c16bfbbee", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -36,6 +36,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.suggest_missing_await(err, expr, expected, expr_ty);\n         self.suggest_missing_parentheses(err, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n+        self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n     }\n \n     // Requires that the two types unify, and prints an error message if"}, {"sha": "824e81a974ca61f00b8dd7c6bf1d08a4fad52448", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -5198,6 +5198,51 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn note_internal_mutation_in_method(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) {\n+        if found != self.tcx.types.unit {\n+            return;\n+        }\n+        if let ExprKind::MethodCall(path_segment, _, [rcvr, ..], _) = expr.kind {\n+            if self\n+                .typeck_results\n+                .borrow()\n+                .expr_ty_adjusted_opt(rcvr)\n+                .map_or(true, |ty| expected.peel_refs() != ty.peel_refs())\n+            {\n+                return;\n+            }\n+            let mut sp = MultiSpan::from_span(path_segment.ident.span);\n+            sp.push_span_label(\n+                path_segment.ident.span,\n+                format!(\n+                    \"this call modifies {} in-place\",\n+                    match rcvr.kind {\n+                        ExprKind::Path(QPath::Resolved(\n+                            None,\n+                            hir::Path { segments: [segment], .. },\n+                        )) => format!(\"`{}`\", segment.ident),\n+                        _ => \"its receiver\".to_string(),\n+                    }\n+                ),\n+            );\n+            sp.push_span_label(\n+                rcvr.span,\n+                \"you probably want to use this value after calling the method...\".to_string(),\n+            );\n+            err.span_note(\n+                sp,\n+                &format!(\"method `{}` modifies its receiver in-place\", path_segment.ident),\n+            );\n+            err.note(&format!(\"...instead of the `()` output of method `{}`\", path_segment.ident));\n+        }\n+    }\n+\n     /// When encountering an `impl Future` where `BoxFuture` is expected, suggest `Box::pin`.\n     fn suggest_calling_boxed_future_when_appropriate(\n         &self,"}, {"sha": "25dc457d144551e1046592c68e402041870cc384", "filename": "src/test/ui/consts/min_const_fn/allow_raw_ptr_dereference_const_fn.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_raw_ptr_dereference_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_raw_ptr_dereference_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fallow_raw_ptr_dereference_const_fn.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+#![feature(const_raw_ptr_deref)]\n+#![feature(raw_ref_macros)]\n+\n+use std::ptr;\n+\n+const fn test_fn(x: *const i32) {\n+    let x2 = unsafe { ptr::raw_const!(*x) };\n+}\n+\n+fn main() {}"}, {"sha": "6462d736ad194ac5524c7b7eac7f03d9e9809e44", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe_bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -1,4 +1,4 @@\n-const fn bad_const_fn_deref_raw(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ is unsafe\n+const fn bad_const_fn_deref_raw(x: *mut usize) -> &'static usize { unsafe { &*x } }\n //~^ dereferencing raw pointers in constant functions\n \n const unsafe fn bad_const_unsafe_deref_raw(x: *mut usize) -> usize { *x }"}, {"sha": "427ecff5c6d1a6b2486c42313b3184dc4b6ebc81", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe_bad.stderr", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_bad.stderr?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -34,15 +34,7 @@ LL |     Foo { x: () }.y\n    = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n-  --> $DIR/min_const_fn_unsafe_bad.rs:1:77\n-   |\n-LL | const fn bad_const_fn_deref_raw(x: *mut usize) -> &'static usize { unsafe { &*x } }\n-   |                                                                             ^^^ dereference of raw pointer\n-   |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0133, E0658, E0723.\n-For more information about an error, try `rustc --explain E0133`.\n+Some errors have detailed explanations: E0658, E0723.\n+For more information about an error, try `rustc --explain E0658`."}, {"sha": "cb92ab87a8ff723ab76c6d6ddb6f5b02936e77a3", "filename": "src/test/ui/suggestions/chain-method-call-mutation-in-place.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Ftest%2Fui%2Fsuggestions%2Fchain-method-call-mutation-in-place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Ftest%2Fui%2Fsuggestions%2Fchain-method-call-mutation-in-place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fchain-method-call-mutation-in-place.rs?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -0,0 +1,4 @@\n+fn main() {}\n+fn foo(mut s: String) -> String {\n+    s.push_str(\"asdf\") //~ ERROR mismatched types\n+}"}, {"sha": "63e3bb78954cf298e86fc8e54b56729312963873", "filename": "src/test/ui/suggestions/chain-method-call-mutation-in-place.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Ftest%2Fui%2Fsuggestions%2Fchain-method-call-mutation-in-place.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dcae03c9c014362cdefb7ec605bb35804a6a94/src%2Ftest%2Fui%2Fsuggestions%2Fchain-method-call-mutation-in-place.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fchain-method-call-mutation-in-place.stderr?ref=d7dcae03c9c014362cdefb7ec605bb35804a6a94", "patch": "@@ -0,0 +1,20 @@\n+error[E0308]: mismatched types\n+  --> $DIR/chain-method-call-mutation-in-place.rs:3:5\n+   |\n+LL | fn foo(mut s: String) -> String {\n+   |                          ------ expected `std::string::String` because of return type\n+LL |     s.push_str(\"asdf\")\n+   |     ^^^^^^^^^^^^^^^^^^ expected struct `std::string::String`, found `()`\n+   |\n+note: method `push_str` modifies its receiver in-place\n+  --> $DIR/chain-method-call-mutation-in-place.rs:3:7\n+   |\n+LL |     s.push_str(\"asdf\")\n+   |     - ^^^^^^^^ this call modifies `s` in-place\n+   |     |\n+   |     you probably want to use this value after calling the method...\n+   = note: ...instead of the `()` output of method `push_str`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}