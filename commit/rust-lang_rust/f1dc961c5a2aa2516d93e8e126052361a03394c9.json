{"sha": "f1dc961c5a2aa2516d93e8e126052361a03394c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZGM5NjFjNWEyYWEyNTE2ZDkzZThlMTI2MDUyMzYxYTAzMzk0Yzk=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-07T11:03:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-07T11:03:17Z"}, "message": "Merge pull request #48 from oli-obk/fix_call_stack_positions\n\nchange the block and stmt position after a function call returns", "tree": {"sha": "d0e1bdd16bd6c9191d67ee007a4758be0a9f85d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0e1bdd16bd6c9191d67ee007a4758be0a9f85d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1dc961c5a2aa2516d93e8e126052361a03394c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1dc961c5a2aa2516d93e8e126052361a03394c9", "html_url": "https://github.com/rust-lang/rust/commit/f1dc961c5a2aa2516d93e8e126052361a03394c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1dc961c5a2aa2516d93e8e126052361a03394c9/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be23dcdb8c5d038c4d594e924e4e17f02c0161ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/be23dcdb8c5d038c4d594e924e4e17f02c0161ce", "html_url": "https://github.com/rust-lang/rust/commit/be23dcdb8c5d038c4d594e924e4e17f02c0161ce"}, {"sha": "ad053d66fec4e2cdea2a93621caa303029b3a1e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad053d66fec4e2cdea2a93621caa303029b3a1e9", "html_url": "https://github.com/rust-lang/rust/commit/ad053d66fec4e2cdea2a93621caa303029b3a1e9"}], "stats": {"total": 83, "additions": 49, "deletions": 34}, "files": [{"sha": "a8d29f787585704c0c5dc9b1ed2ece242bdab80a", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1dc961c5a2aa2516d93e8e126052361a03394c9/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dc961c5a2aa2516d93e8e126052361a03394c9/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=f1dc961c5a2aa2516d93e8e126052361a03394c9", "patch": "@@ -71,6 +71,9 @@ pub struct Frame<'a, 'tcx: 'a> {\n     /// A pointer for writing the return value of the current call if it's not a diverging call.\n     pub return_ptr: Option<Pointer>,\n \n+    /// The block to return to when returning from the current stack frame\n+    pub return_to_block: Option<mir::BasicBlock>,\n+\n     /// The list of locals for the current function, stored in order as\n     /// `[arguments..., variables..., temporaries...]`. The variables begin at `self.var_offset`\n     /// and the temporaries at `self.temp_offset`.\n@@ -305,6 +308,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         mir: CachedMir<'a, 'tcx>,\n         substs: &'tcx Substs<'tcx>,\n         return_ptr: Option<Pointer>,\n+        return_to_block: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx, ()> {\n         let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n         let var_tys = mir.var_decls.iter().map(|v| v.ty);\n@@ -325,6 +329,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             mir: mir.clone(),\n             block: mir::START_BLOCK,\n             return_ptr: return_ptr,\n+            return_to_block: return_to_block,\n             locals: locals?,\n             var_offset: num_args,\n             temp_offset: num_args + num_vars,\n@@ -342,7 +347,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn pop_stack_frame(&mut self) {\n         ::log_settings::settings().indentation -= 1;\n-        let _frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n+        let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n+        if let Some(target) = frame.return_to_block {\n+            self.goto_block(target);\n+        }\n         // TODO(solson): Deallocate local variables.\n     }\n \n@@ -961,7 +969,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs)\n         .expect(\"should at least be able to allocate space for the main function's return value\");\n \n-    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr))\n+    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr), None)\n         .expect(\"could not allocate first stack frame\");\n \n     if mir.arg_decls.len() == 2 {"}, {"sha": "3684f525ba632909572dfd3103cc10a84c2c9871", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1dc961c5a2aa2516d93e8e126052361a03394c9/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dc961c5a2aa2516d93e8e126052361a03394c9/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=f1dc961c5a2aa2516d93e8e126052361a03394c9", "patch": "@@ -87,8 +87,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<'tcx, ()> {\n-        // after a terminator we go to a new block\n-        self.frame_mut().stmt = 0;\n         trace!(\"{:?}\", terminator.kind);\n         self.eval_terminator(terminator)?;\n         if !self.stack.is_empty() {\n@@ -125,7 +123,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         self.try(|this| {\n             let ptr = this.ecx.alloc_ret_ptr(mir.return_ty, substs)?;\n             this.ecx.statics.insert(cid.clone(), ptr);\n-            this.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr))\n+            this.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr), None)\n         });\n     }\n     fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, ()>>(&mut self, f: F) {\n@@ -170,7 +168,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                     let return_ptr = this.ecx.alloc_ret_ptr(return_ty, cid.substs)?;\n                     let mir = CachedMir::Owned(Rc::new(mir));\n                     this.ecx.statics.insert(cid.clone(), return_ptr);\n-                    this.ecx.push_stack_frame(this.def_id, constant.span, mir, this.substs, Some(return_ptr))\n+                    this.ecx.push_stack_frame(this.def_id, constant.span, mir, this.substs, Some(return_ptr), None)\n                 });\n             }\n         }"}, {"sha": "36e2c05f4f3ee0b92e1b65924ae5d557c0358e84", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f1dc961c5a2aa2516d93e8e126052361a03394c9/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dc961c5a2aa2516d93e8e126052361a03394c9/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=f1dc961c5a2aa2516d93e8e126052361a03394c9", "patch": "@@ -15,6 +15,12 @@ use error::{EvalError, EvalResult};\n use memory::{Pointer, FunctionDefinition};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+\n+    pub(super) fn goto_block(&mut self, target: mir::BasicBlock) {\n+        self.frame_mut().block = target;\n+        self.frame_mut().stmt = 0;\n+    }\n+\n     pub(super) fn eval_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n@@ -23,14 +29,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match terminator.kind {\n             Return => self.pop_stack_frame(),\n \n-            Goto { target } => {\n-                self.frame_mut().block = target;\n-            },\n+            Goto { target } => self.goto_block(target),\n \n             If { ref cond, targets: (then_target, else_target) } => {\n                 let cond_ptr = self.eval_operand(cond)?;\n                 let cond_val = self.memory.read_bool(cond_ptr)?;\n-                self.frame_mut().block = if cond_val { then_target } else { else_target };\n+                self.goto_block(if cond_val { then_target } else { else_target });\n             }\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n@@ -59,7 +63,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 }\n \n-                self.frame_mut().block = target_block;\n+                self.goto_block(target_block);\n             }\n \n             Switch { ref discr, ref targets, adt_def } => {\n@@ -70,19 +74,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     .position(|v| discr_val == v.disr_val.to_u64_unchecked());\n \n                 match matching {\n-                    Some(i) => {\n-                        self.frame_mut().block = targets[i];\n-                    },\n+                    Some(i) => self.goto_block(targets[i]),\n                     None => return Err(EvalError::InvalidDiscriminant),\n                 }\n             }\n \n             Call { ref func, ref args, ref destination, .. } => {\n-                let mut return_ptr = None;\n-                if let Some((ref lv, target)) = *destination {\n-                    self.frame_mut().block = target;\n-                    return_ptr = Some(self.eval_lvalue(lv)?.to_ptr());\n-                }\n+                let destination = match *destination {\n+                    Some((ref lv, target)) => Some((self.eval_lvalue(lv)?.to_ptr(), target)),\n+                    None => None,\n+                };\n \n                 let func_ty = self.operand_ty(func);\n                 match func_ty.sty {\n@@ -93,11 +94,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         if fn_ty != bare_fn_ty {\n                             return Err(EvalError::FunctionPointerTyMismatch(fn_ty, bare_fn_ty));\n                         }\n-                        self.eval_fn_call(def_id, substs, bare_fn_ty, return_ptr, args,\n+                        self.eval_fn_call(def_id, substs, bare_fn_ty, destination, args,\n                                           terminator.source_info.span)?\n                     },\n                     ty::TyFnDef(def_id, substs, fn_ty) => {\n-                        self.eval_fn_call(def_id, substs, fn_ty, return_ptr, args,\n+                        self.eval_fn_call(def_id, substs, fn_ty, destination, args,\n                                           terminator.source_info.span)?\n                     }\n \n@@ -109,13 +110,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = self.eval_lvalue(location)?.to_ptr();\n                 let ty = self.lvalue_ty(location);\n                 self.drop(ptr, ty)?;\n-                self.frame_mut().block = target;\n+                self.goto_block(target);\n             }\n \n             Assert { ref cond, expected, ref msg, target, .. } => {\n                 let cond_ptr = self.eval_operand(cond)?;\n                 if expected == self.memory.read_bool(cond_ptr)? {\n-                    self.frame_mut().block = target;\n+                    self.goto_block(target);\n                 } else {\n                     return match *msg {\n                         mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n@@ -143,7 +144,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n         fn_ty: &'tcx BareFnTy,\n-        return_ptr: Option<Pointer>,\n+        destination: Option<(Pointer, mir::BasicBlock)>,\n         args: &[mir::Operand<'tcx>],\n         span: Span,\n     ) -> EvalResult<'tcx, ()> {\n@@ -152,14 +153,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Abi::RustIntrinsic => {\n                 let ty = fn_ty.sig.0.output;\n                 let layout = self.type_layout(ty);\n-                let ret = return_ptr.unwrap();\n-                self.call_intrinsic(def_id, substs, args, ret, layout)\n+                let (ret, target) = destination.unwrap();\n+                self.call_intrinsic(def_id, substs, args, ret, layout)?;\n+                self.goto_block(target);\n+                Ok(())\n             }\n \n             Abi::C => {\n                 let ty = fn_ty.sig.0.output;\n                 let size = self.type_size(ty);\n-                self.call_c_abi(def_id, args, return_ptr.unwrap(), size)\n+                let (ret, target) = destination.unwrap();\n+                self.call_c_abi(def_id, args, ret, size)?;\n+                self.goto_block(target);\n+                Ok(())\n             }\n \n             Abi::Rust | Abi::RustCall => {\n@@ -203,7 +209,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n \n                 let mir = self.load_mir(resolved_def_id);\n-                self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr)?;\n+                let (return_ptr, return_to_block) = match destination {\n+                    Some((ptr, block)) => (Some(ptr), Some(block)),\n+                    None => (None, None),\n+                };\n+                self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr, return_to_block)?;\n \n                 for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n                     let dest = self.frame().locals[i];"}, {"sha": "e9b2536a7005a85823fbee69085184554d41925c", "filename": "tests/compile-fail/cast_fn_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1dc961c5a2aa2516d93e8e126052361a03394c9/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dc961c5a2aa2516d93e8e126052361a03394c9/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr.rs?ref=f1dc961c5a2aa2516d93e8e126052361a03394c9", "patch": "@@ -1,9 +1,9 @@\n fn main() {\n     fn f() {}\n \n-    let g = unsafe { //~ ERROR tried to call a function of type\n+    let g = unsafe {\n         std::mem::transmute::<fn(), fn(i32)>(f)\n     };\n \n-    g(42)\n+    g(42) //~ ERROR tried to call a function of type\n }"}, {"sha": "8d3c9df0320ba24e53a707cb1457ceacf5b8fa55", "filename": "tests/compile-fail/execute_memory.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1dc961c5a2aa2516d93e8e126052361a03394c9/tests%2Fcompile-fail%2Fexecute_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dc961c5a2aa2516d93e8e126052361a03394c9/tests%2Fcompile-fail%2Fexecute_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fexecute_memory.rs?ref=f1dc961c5a2aa2516d93e8e126052361a03394c9", "patch": "@@ -4,7 +4,6 @@ fn main() {\n     let x = box 42;\n     unsafe {\n         let f = std::mem::transmute::<Box<i32>, fn()>(x);\n-        //~^ ERROR: tried to treat a memory pointer as a function pointer\n-        f()\n+        f() //~ ERROR: tried to treat a memory pointer as a function pointer\n     }\n }"}, {"sha": "be56240af4767454c3a5dd1285987d6dffaa7357", "filename": "tests/compile-fail/oom.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1dc961c5a2aa2516d93e8e126052361a03394c9/tests%2Fcompile-fail%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1dc961c5a2aa2516d93e8e126052361a03394c9/tests%2Fcompile-fail%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom.rs?ref=f1dc961c5a2aa2516d93e8e126052361a03394c9", "patch": "@@ -6,6 +6,6 @@ fn bar() {\n     assert_eq!(x, 6);\n }\n \n-fn main() { //~ ERROR tried to allocate 4 more bytes, but only 0 bytes are free of the 0 byte memory\n-    bar();\n+fn main() {\n+    bar(); //~ ERROR tried to allocate 4 more bytes, but only 0 bytes are free of the 0 byte memory\n }"}]}