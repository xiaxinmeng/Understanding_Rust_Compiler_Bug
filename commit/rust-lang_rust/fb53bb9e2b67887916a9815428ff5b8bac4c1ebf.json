{"sha": "fb53bb9e2b67887916a9815428ff5b8bac4c1ebf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNTNiYjllMmI2Nzg4NzkxNmE5ODE1NDI4ZmY1YjhiYWM0YzFlYmY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-19T04:33:44Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: move Debug impls from ppaux to ty::structural_impls.", "tree": {"sha": "eac4294b4610e085fb1cc4f3daf96ffa961782de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eac4294b4610e085fb1cc4f3daf96ffa961782de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb53bb9e2b67887916a9815428ff5b8bac4c1ebf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb53bb9e2b67887916a9815428ff5b8bac4c1ebf", "html_url": "https://github.com/rust-lang/rust/commit/fb53bb9e2b67887916a9815428ff5b8bac4c1ebf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb53bb9e2b67887916a9815428ff5b8bac4c1ebf/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c424850e8b342eb348c4a8cbb95704f51aedac3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c424850e8b342eb348c4a8cbb95704f51aedac3", "html_url": "https://github.com/rust-lang/rust/commit/9c424850e8b342eb348c4a8cbb95704f51aedac3"}], "stats": {"total": 575, "additions": 288, "deletions": 287}, "files": [{"sha": "45db95e2b0f0f0526f982b90fece6eef2d3e5f79", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/fb53bb9e2b67887916a9815428ff5b8bac4c1ebf/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb53bb9e2b67887916a9815428ff5b8bac4c1ebf/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=fb53bb9e2b67887916a9815428ff5b8bac4c1ebf", "patch": "@@ -3,17 +3,287 @@\n //! hand, though we've recently added some macros (e.g.,\n //! `BraceStructLiftImpl!`) to help with the tedium.\n \n+use crate::hir::def::Namespace;\n use crate::mir::ProjectionKind;\n use crate::mir::interpret::ConstValue;\n use crate::ty::{self, Lift, Ty, TyCtxt, ConstVid, InferConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::print::{FmtPrinter, PrintCx, Printer};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use smallvec::SmallVec;\n use crate::mir::interpret;\n \n+use std::fmt;\n+use std::iter;\n use std::marker::PhantomData;\n use std::rc::Rc;\n \n+impl fmt::Debug for ty::GenericParamDef {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let type_name = match self.kind {\n+            ty::GenericParamDefKind::Lifetime => \"Lifetime\",\n+            ty::GenericParamDefKind::Type {..} => \"Type\",\n+            ty::GenericParamDefKind::Const => \"Const\",\n+        };\n+        write!(f, \"{}({}, {:?}, {})\",\n+               type_name,\n+               self.name,\n+               self.def_id,\n+               self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::TraitDef {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n+            cx.print_def_path(self.def_id, None, iter::empty())?;\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl fmt::Debug for ty::AdtDef {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n+            cx.print_def_path(self.did, None, iter::empty())?;\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl fmt::Debug for ty::ClosureUpvar<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"ClosureUpvar({:?},{:?})\",\n+               self.def,\n+               self.ty)\n+    }\n+}\n+\n+impl fmt::Debug for ty::UpvarId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let name = ty::tls::with(|tcx| {\n+            tcx.hir().name_by_hir_id(self.var_path.hir_id)\n+        });\n+        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n+            self.var_path.hir_id,\n+            name,\n+            self.closure_expr_id)\n+    }\n+}\n+\n+impl fmt::Debug for ty::UpvarBorrow<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"UpvarBorrow({:?}, {:?})\",\n+               self.kind, self.region)\n+    }\n+}\n+\n+impl fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?} -> {}\", self.kind, self.target)\n+    }\n+}\n+\n+impl fmt::Debug for ty::BoundRegion {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n+            ty::BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n+            ty::BrNamed(did, name) => {\n+                write!(f, \"BrNamed({:?}:{:?}, {})\",\n+                        did.krate, did.index, name)\n+            }\n+            ty::BrEnv => write!(f, \"BrEnv\"),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::RegionKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::ReEarlyBound(ref data) => {\n+                write!(f, \"ReEarlyBound({}, {})\",\n+                        data.index,\n+                        data.name)\n+            }\n+\n+            ty::ReClosureBound(ref vid) => {\n+                write!(f, \"ReClosureBound({:?})\", vid)\n+            }\n+\n+            ty::ReLateBound(binder_id, ref bound_region) => {\n+                write!(f, \"ReLateBound({:?}, {:?})\", binder_id, bound_region)\n+            }\n+\n+            ty::ReFree(ref fr) => fr.fmt(f),\n+\n+            ty::ReScope(id) => write!(f, \"ReScope({:?})\", id),\n+\n+            ty::ReStatic => write!(f, \"ReStatic\"),\n+\n+            ty::ReVar(ref vid) => vid.fmt(f),\n+\n+            ty::RePlaceholder(placeholder) => {\n+                write!(f, \"RePlaceholder({:?})\", placeholder)\n+            }\n+\n+            ty::ReEmpty => write!(f, \"ReEmpty\"),\n+\n+            ty::ReErased => write!(f, \"ReErased\"),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::FreeRegion {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"ReFree({:?}, {:?})\", self.scope, self.bound_region)\n+    }\n+}\n+\n+impl fmt::Debug for ty::Variance {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match *self {\n+            ty::Covariant => \"+\",\n+            ty::Contravariant => \"-\",\n+            ty::Invariant => \"o\",\n+            ty::Bivariant => \"*\",\n+        })\n+    }\n+}\n+\n+impl fmt::Debug for ty::FnSig<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"({:?}; c_variadic: {})->{:?}\",\n+                self.inputs(), self.c_variadic, self.output())\n+    }\n+}\n+\n+impl fmt::Debug for ty::TyVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}t\", self.index)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::ConstVid<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}c\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::IntVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}i\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::FloatVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}f\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::RegionVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"'_#{}r\", self.index())\n+    }\n+}\n+\n+impl fmt::Debug for ty::InferTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::TyVar(ref v) => v.fmt(f),\n+            ty::IntVar(ref v) => v.fmt(f),\n+            ty::FloatVar(ref v) => v.fmt(f),\n+            ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n+            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n+            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::IntVarValue {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::IntType(ref v) => v.fmt(f),\n+            ty::UintType(ref v) => v.fmt(f),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::FloatVarValue {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+impl fmt::Debug for ty::TraitRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // HACK(eddyb) this is used across the compiler to print\n+        // a `TraitRef` qualified (with the Self type explicit),\n+        // instead of having a different way to make that choice.\n+        write!(f, \"<{} as {}>\", self.self_ty(), self)\n+    }\n+}\n+\n+impl fmt::Debug for Ty<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Debug for ty::ParamTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}/#{}\", self.name, self.idx)\n+    }\n+}\n+\n+impl fmt::Debug for ty::ParamConst {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}/#{}\", self.name, self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::TraitPredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"TraitPredicate({:?})\", self.trait_ref)\n+    }\n+}\n+\n+impl fmt::Debug for ty::ProjectionPredicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"ProjectionPredicate({:?}, {:?})\", self.projection_ty, self.ty)\n+    }\n+}\n+\n+impl fmt::Debug for ty::Predicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::Predicate::Trait(ref a) => a.fmt(f),\n+            ty::Predicate::Subtype(ref pair) => pair.fmt(f),\n+            ty::Predicate::RegionOutlives(ref pair) => pair.fmt(f),\n+            ty::Predicate::TypeOutlives(ref pair) => pair.fmt(f),\n+            ty::Predicate::Projection(ref pair) => pair.fmt(f),\n+            ty::Predicate::WellFormed(ty) => write!(f, \"WellFormed({:?})\", ty),\n+            ty::Predicate::ObjectSafe(trait_def_id) => {\n+                write!(f, \"ObjectSafe({:?})\", trait_def_id)\n+            }\n+            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                write!(f, \"ClosureKind({:?}, {:?}, {:?})\",\n+                    closure_def_id, closure_substs, kind)\n+            }\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n+            }\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Atomic structs\n //"}, {"sha": "846428656146917250b4104c0ff83bd09710e45b", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb53bb9e2b67887916a9815428ff5b8bac4c1ebf/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb53bb9e2b67887916a9815428ff5b8bac4c1ebf/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=fb53bb9e2b67887916a9815428ff5b8bac4c1ebf", "patch": "@@ -12,6 +12,7 @@ use smallvec::SmallVec;\n use rustc_macros::HashStable;\n \n use core::intrinsics;\n+use std::fmt;\n use std::cmp::Ordering;\n use std::marker::PhantomData;\n use std::mem;\n@@ -69,6 +70,16 @@ impl<'tcx> UnpackedKind<'tcx> {\n     }\n }\n \n+impl fmt::Debug for Kind<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(lt) => lt.fmt(f),\n+            UnpackedKind::Type(ty) => ty.fmt(f),\n+            UnpackedKind::Const(ct) => ct.fmt(f),\n+        }\n+    }\n+}\n+\n impl<'tcx> Ord for Kind<'tcx> {\n     fn cmp(&self, other: &Kind<'_>) -> Ordering {\n         self.unpack().cmp(&other.unpack())"}, {"sha": "2e11a3741369e0454ecbd427f0a5be0f8f9904f7", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 287, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/fb53bb9e2b67887916a9815428ff5b8bac4c1ebf/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb53bb9e2b67887916a9815428ff5b8bac4c1ebf/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fb53bb9e2b67887916a9815428ff5b8bac4c1ebf", "patch": "@@ -2,16 +2,20 @@ use crate::hir;\n use crate::hir::def::Namespace;\n use crate::ty::subst::{Kind, UnpackedKind};\n use crate::ty::{self, ParamConst, Ty};\n-use crate::ty::print::{FmtPrinter, PrettyPrinter, PrintCx, Print, Printer};\n+use crate::ty::print::{FmtPrinter, PrettyPrinter, PrintCx, Print};\n use crate::mir::interpret::ConstValue;\n \n-use std::fmt::{self, Write as _};\n+use std::fmt;\n use std::iter;\n \n use rustc_target::spec::abi::Abi;\n \n macro_rules! define_print {\n-    (@display $target:ty, ($self:ident, $cx:ident) $disp:block) => {\n+    ([$($target:ty),+] $vars:tt $def:tt) => {\n+        $(define_print!($target, $vars $def);)+\n+    };\n+\n+    ($target:ty, ($self:ident, $cx:ident) { display $disp:block }) => {\n         impl<P: PrettyPrinter> Print<'tcx, P> for $target {\n             type Output = P;\n             type Error = fmt::Error;\n@@ -34,38 +38,6 @@ macro_rules! define_print {\n             }\n         }\n     };\n-\n-    (@debug $target:ty, ($self:ident, $cx:ident) $dbg:block) => {\n-        impl fmt::Debug for $target {\n-            fn fmt(&$self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::TypeNS), |$cx| {\n-                    #[allow(unused_mut)]\n-                    let mut $cx = $cx;\n-                    define_scoped_cx!($cx);\n-                    let _: () = $dbg;\n-                    let _ = $cx;\n-                    Ok(())\n-                })\n-            }\n-        }\n-    };\n-\n-    ([$($target:ty),+] $vars:tt $def:tt) => {\n-        $(define_print!($target, $vars $def);)+\n-    };\n-\n-    ($target:ty, $vars:tt {\n-        display $disp:block\n-        debug $dbg:block\n-    }) => {\n-        define_print!(@display $target, $vars $disp);\n-        define_print!(@debug $target, $vars $dbg);\n-    };\n-    ($target:ty, $vars:tt {\n-        display $disp:block\n-    }) => {\n-        define_print!(@display $target, $vars $disp);\n-    };\n }\n \n macro_rules! nest {\n@@ -160,67 +132,6 @@ define_print! {\n     }\n }\n \n-impl fmt::Debug for ty::GenericParamDef {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let type_name = match self.kind {\n-            ty::GenericParamDefKind::Lifetime => \"Lifetime\",\n-            ty::GenericParamDefKind::Type { .. } => \"Type\",\n-            ty::GenericParamDefKind::Const => \"Const\",\n-        };\n-        write!(f, \"{}({}, {:?}, {})\",\n-               type_name,\n-               self.name,\n-               self.def_id,\n-               self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::TraitDef {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n-            cx.print_def_path(self.def_id, None, iter::empty())?;\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl fmt::Debug for ty::AdtDef {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n-            cx.print_def_path(self.did, None, iter::empty())?;\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"ClosureUpvar({:?},{:?})\",\n-               self.def,\n-               self.ty)\n-    }\n-}\n-\n-impl fmt::Debug for ty::UpvarId {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::ValueNS), |mut cx| {\n-            define_scoped_cx!(cx);\n-            p!(write(\"UpvarId({:?};`{}`;{:?})\",\n-                self.var_path.hir_id,\n-                cx.tcx.hir().name_by_hir_id(self.var_path.hir_id),\n-                self.closure_expr_id));\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"UpvarBorrow({:?}, {:?})\",\n-               self.kind, self.region)\n-    }\n-}\n-\n define_print! {\n     &'tcx ty::List<Ty<'tcx>>, (self, cx) {\n         display {\n@@ -260,91 +171,11 @@ define_print! {\n     }\n }\n \n-impl fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?} -> {}\", self.kind, self.target)\n-    }\n-}\n-\n-impl fmt::Debug for ty::BoundRegion {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ty::BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n-            ty::BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n-            ty::BrNamed(did, name) => {\n-                write!(f, \"BrNamed({:?}:{:?}, {})\",\n-                        did.krate, did.index, name)\n-            }\n-            ty::BrEnv => write!(f, \"BrEnv\"),\n-        }\n-    }\n-}\n-\n define_print! {\n     ty::RegionKind, (self, cx) {\n         display {\n             return cx.print_region(self);\n         }\n-        debug {\n-            match *self {\n-                ty::ReEarlyBound(ref data) => {\n-                    p!(write(\"ReEarlyBound({}, {})\",\n-                           data.index,\n-                           data.name))\n-                }\n-\n-                ty::ReClosureBound(ref vid) => {\n-                    p!(write(\"ReClosureBound({:?})\", vid))\n-                }\n-\n-                ty::ReLateBound(binder_id, ref bound_region) => {\n-                    p!(write(\"ReLateBound({:?}, {:?})\", binder_id, bound_region))\n-                }\n-\n-                ty::ReFree(ref fr) => p!(write(\"{:?}\", fr)),\n-\n-                ty::ReScope(id) => {\n-                    p!(write(\"ReScope({:?})\", id))\n-                }\n-\n-                ty::ReStatic => p!(write(\"ReStatic\")),\n-\n-                ty::ReVar(ref vid) => {\n-                    p!(write(\"{:?}\", vid));\n-                }\n-\n-                ty::RePlaceholder(placeholder) => {\n-                    p!(write(\"RePlaceholder({:?})\", placeholder))\n-                }\n-\n-                ty::ReEmpty => p!(write(\"ReEmpty\")),\n-\n-                ty::ReErased => p!(write(\"ReErased\"))\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::FreeRegion {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"ReFree({:?}, {:?})\", self.scope, self.bound_region)\n-    }\n-}\n-\n-impl fmt::Debug for ty::Variance {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(match *self {\n-            ty::Covariant => \"+\",\n-            ty::Contravariant => \"-\",\n-            ty::Invariant => \"o\",\n-            ty::Bivariant => \"*\",\n-        })\n     }\n }\n \n@@ -362,40 +193,6 @@ define_print! {\n             p!(write(\"fn\"));\n             nest!(|cx| cx.pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n         }\n-        debug {\n-            p!(write(\"({:?}; c_variadic: {})->{:?}\",\n-                self.inputs(), self.c_variadic, self.output()))\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::TyVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}t\", self.index)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::ConstVid<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}f\", self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::IntVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}i\", self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::FloatVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}f\", self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::RegionVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"'_#{}r\", self.index())\n     }\n }\n \n@@ -415,31 +212,6 @@ define_print! {\n                 ty::FreshFloatTy(v) => p!(write(\"FreshFloatTy({})\", v))\n             }\n         }\n-        debug {\n-            match *self {\n-                ty::TyVar(ref v) => p!(write(\"{:?}\", v)),\n-                ty::IntVar(ref v) => p!(write(\"{:?}\", v)),\n-                ty::FloatVar(ref v) => p!(write(\"{:?}\", v)),\n-                ty::FreshTy(v) => p!(write(\"FreshTy({:?})\", v)),\n-                ty::FreshIntTy(v) => p!(write(\"FreshIntTy({:?})\", v)),\n-                ty::FreshFloatTy(v) => p!(write(\"FreshFloatTy({:?})\", v))\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::IntVarValue {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ty::IntType(ref v) => v.fmt(f),\n-            ty::UintType(ref v) => v.fmt(f),\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::FloatVarValue {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0.fmt(f)\n     }\n }\n \n@@ -478,12 +250,6 @@ define_print! {\n         display {\n             nest!(|cx| cx.print_def_path(self.def_id, Some(self.substs), iter::empty()));\n         }\n-        debug {\n-            // HACK(eddyb) this is used across the compiler to print\n-            // a `TraitRef` qualified (with the Self type explicit),\n-            // instead of having a different way to make that choice.\n-            p!(write(\"<{} as {}>\", self.self_ty(), self))\n-        }\n     }\n }\n \n@@ -495,12 +261,6 @@ define_print! {\n     }\n }\n \n-impl fmt::Debug for Ty<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n define_print! {\n     ConstValue<'tcx>, (self, cx) {\n         display {\n@@ -538,9 +298,6 @@ define_print! {\n         display {\n             p!(write(\"{}\", self.name))\n         }\n-        debug {\n-            p!(write(\"{}/#{}\", self.name, self.idx))\n-        }\n     }\n }\n \n@@ -549,9 +306,6 @@ define_print! {\n         display {\n             p!(write(\"{}\", self.name))\n         }\n-        debug {\n-            p!(write(\"{}/#{}\", self.name, self.index))\n-        }\n     }\n }\n \n@@ -581,10 +335,6 @@ define_print! {\n         display {\n             p!(print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n         }\n-        debug {\n-            p!(write(\"TraitPredicate({:?})\",\n-                   self.trait_ref))\n-        }\n     }\n }\n \n@@ -593,9 +343,6 @@ define_print! {\n         display {\n             p!(print(self.projection_ty), write(\" == \"), print(self.ty))\n         }\n-        debug {\n-            p!(write(\"ProjectionPredicate({:?}, {:?})\", self.projection_ty, self.ty))\n-        }\n     }\n }\n \n@@ -646,26 +393,6 @@ define_print! {\n                 }\n             }\n         }\n-        debug {\n-            match *self {\n-                ty::Predicate::Trait(ref a) => p!(write(\"{:?}\", a)),\n-                ty::Predicate::Subtype(ref pair) => p!(write(\"{:?}\", pair)),\n-                ty::Predicate::RegionOutlives(ref pair) => p!(write(\"{:?}\", pair)),\n-                ty::Predicate::TypeOutlives(ref pair) => p!(write(\"{:?}\", pair)),\n-                ty::Predicate::Projection(ref pair) => p!(write(\"{:?}\", pair)),\n-                ty::Predicate::WellFormed(ty) => p!(write(\"WellFormed({:?})\", ty)),\n-                ty::Predicate::ObjectSafe(trait_def_id) => {\n-                    p!(write(\"ObjectSafe({:?})\", trait_def_id))\n-                }\n-                ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                    p!(write(\"ClosureKind({:?}, {:?}, {:?})\",\n-                        closure_def_id, closure_substs, kind))\n-                }\n-                ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                    p!(write(\"ConstEvaluatable({:?}, {:?})\", def_id, substs))\n-                }\n-            }\n-        }\n     }\n }\n \n@@ -678,12 +405,5 @@ define_print! {\n                 UnpackedKind::Const(ct) => p!(print(ct)),\n             }\n         }\n-        debug {\n-            match self.unpack() {\n-                UnpackedKind::Lifetime(lt) => p!(write(\"{:?}\", lt)),\n-                UnpackedKind::Type(ty) => p!(write(\"{:?}\", ty)),\n-                UnpackedKind::Const(ct) => p!(write(\"{:?}\", ct)),\n-            }\n-        }\n     }\n }"}]}