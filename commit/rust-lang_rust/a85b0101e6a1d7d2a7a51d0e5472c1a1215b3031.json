{"sha": "a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031", "node_id": "C_kwDOAAsO6NoAKGE4NWIwMTAxZTZhMWQ3ZDJhN2E1MWQwZTU0NzJjMWExMjE1YjMwMzE", "commit": {"author": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-02-11T23:05:11Z"}, "committer": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-02-11T23:05:16Z"}, "message": "make `relate`'s const ty assertion use semantic equality", "tree": {"sha": "c0f0d1458421d9e1be0d75a990594f76630bfeb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0f0d1458421d9e1be0d75a990594f76630bfeb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031", "html_url": "https://github.com/rust-lang/rust/commit/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dabf5da9e0318f8c324dc224ad49dc91472c2ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dabf5da9e0318f8c324dc224ad49dc91472c2ec", "html_url": "https://github.com/rust-lang/rust/commit/8dabf5da9e0318f8c324dc224ad49dc91472c2ec"}], "stats": {"total": 259, "additions": 237, "deletions": 22}, "files": [{"sha": "76834c3b36841f6edb8d5fe48f16de8020cc2844", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031", "patch": "@@ -31,6 +31,7 @@ use super::{InferCtxt, MiscVariable, TypeTrace};\n use crate::traits::{Obligation, PredicateObligations};\n use rustc_data_structures::sso::SsoHashMap;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::infer::canonical::OriginalQueryValues;\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::traits::ObligationCause;\n@@ -152,6 +153,33 @@ impl<'tcx> InferCtxt<'tcx> {\n         let a = self.shallow_resolve(a);\n         let b = self.shallow_resolve(b);\n \n+        // We should never have to relate the `ty` field on `Const` as it is checked elsewhere that consts have the\n+        // correct type for the generic param they are an argument for. However there have been a number of cases\n+        // historically where asserting that the types are equal has found bugs in the compiler so this is valuable\n+        // to check even if it is a bit nasty impl wise :(\n+        //\n+        // This probe is probably not strictly necessary but it seems better to be safe and not accidentally find\n+        // ourselves with a check to find bugs being required for code to compile because it made inference progress.\n+        self.probe(|_| {\n+            if a.ty() == b.ty() {\n+                return;\n+            }\n+\n+            // We don't have access to trait solving machinery in `rustc_infer` so the logic for determining if the\n+            // two const param's types are able to be equal has to go through a canonical query with the actual logic\n+            // in `rustc_trait_selection`.\n+            let canonical = self.canonicalize_query(\n+                (relation.param_env(), a.ty(), b.ty()),\n+                &mut OriginalQueryValues::default(),\n+            );\n+            if let Err(()) = self.tcx.check_const_param_definitely_unequal(canonical) {\n+                self.tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    &format!(\"cannot relate consts of different types (a={:?}, b={:?})\", a, b,),\n+                );\n+            }\n+        });\n+\n         match (a.kind(), b.kind()) {\n             (\n                 ty::ConstKind::Infer(InferConst::Var(a_vid)),"}, {"sha": "d8f7614c56f427a88f5a3de48d9c5ddc3a324f75", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031", "patch": "@@ -2168,4 +2168,11 @@ rustc_queries! {\n         desc { \"traits in scope for documentation links for a module\" }\n         separate_provide_extern\n     }\n+\n+    /// Used in `super_combine_consts` to ICE if the type of the two consts are definitely not going to end up being\n+    /// equal to eachother. This might return `Ok` even if the types are unequal, but will never return `Err` if\n+    /// the types might be equal.\n+    query check_const_param_definitely_unequal(arg: Canonical<'tcx, (ty::ParamEnv<'tcx>, Ty<'tcx>, Ty<'tcx>)>) -> Result<(), ()> {\n+        desc { \"check whether two const param are definitely not equal to eachother\"}\n+    }\n }"}, {"sha": "da6b9e3ed23d9b273ffd9e39407cb18f3bc9d2e9", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031", "patch": "@@ -9,7 +9,6 @@ use crate::ty::{self, Expr, ImplSubject, Term, TermKind, Ty, TyCtxt, TypeFoldabl\n use crate::ty::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_hir as ast;\n use rustc_hir::def_id::DefId;\n-use rustc_span::DUMMY_SP;\n use rustc_target::spec::abi;\n use std::iter;\n \n@@ -594,25 +593,6 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     debug!(\"{}.super_relate_consts(a = {:?}, b = {:?})\", relation.tag(), a, b);\n     let tcx = relation.tcx();\n \n-    let a_ty;\n-    let b_ty;\n-    if relation.tcx().features().adt_const_params {\n-        a_ty = tcx.normalize_erasing_regions(relation.param_env(), a.ty());\n-        b_ty = tcx.normalize_erasing_regions(relation.param_env(), b.ty());\n-    } else {\n-        a_ty = tcx.erase_regions(a.ty());\n-        b_ty = tcx.erase_regions(b.ty());\n-    }\n-    if a_ty != b_ty {\n-        relation.tcx().sess.delay_span_bug(\n-            DUMMY_SP,\n-            &format!(\n-                \"cannot relate constants ({:?}, {:?}) of different types: {} != {}\",\n-                a, b, a_ty, b_ty\n-            ),\n-        );\n-    }\n-\n     // HACK(const_generics): We still need to eagerly evaluate consts when\n     // relating them because during `normalize_param_env_or_error`,\n     // we may relate an evaluated constant in a obligation against"}, {"sha": "39654258dcda97ac3a7afc0b65eb534895f23717", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031", "patch": "@@ -1,12 +1,14 @@\n //! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n-use crate::traits::{self, ObligationCause};\n+use crate::traits::{self, ObligationCause, ObligationCtxt};\n \n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n+use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::infer::{RegionResolutionError, TyCtxtInferExt};\n use rustc_infer::{infer::outlives::env::OutlivesEnvironment, traits::FulfillmentError};\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, TypeVisitable};\n+use rustc_span::DUMMY_SP;\n \n use super::outlives_bounds::InferCtxtExt;\n \n@@ -131,3 +133,19 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n \n     Ok(())\n }\n+\n+pub fn check_const_param_definitely_unequal<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    canonical: Canonical<'tcx, (ParamEnv<'tcx>, Ty<'tcx>, Ty<'tcx>)>,\n+) -> Result<(), ()> {\n+    let (infcx, (param_env, ty_a, ty_b), _) =\n+        tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical);\n+    let ocx = ObligationCtxt::new(&infcx);\n+\n+    let result = ocx.eq(&ObligationCause::dummy(), param_env, ty_a, ty_b);\n+    // use `select_where_possible` instead of `select_all_or_error` so that\n+    // we don't get errors from obligations being ambiguous.\n+    let errors = ocx.select_where_possible();\n+\n+    if errors.len() > 0 || result.is_err() { Err(()) } else { Ok(()) }\n+}"}, {"sha": "f34d55531e767809e7055fa94f8e7f379443e800", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031", "patch": "@@ -554,6 +554,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n         subst_and_check_impossible_predicates,\n+        check_const_param_definitely_unequal: misc::check_const_param_definitely_unequal,\n         is_impossible_method,\n         ..*providers\n     };"}, {"sha": "1e248411830cd103162246c322c690c115b70bf9", "filename": "tests/ui/const-generics/generic_const_exprs/const_kind_expr/relate_ty_with_infer_1.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Frelate_ty_with_infer_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Frelate_ty_with_infer_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Frelate_ty_with_infer_1.rs?ref=a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031", "patch": "@@ -0,0 +1,30 @@\n+// check-pass\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+// issue #107899\n+// We end up relating `Const(ty: size_of<?0>, kind: Value(Branch([])))` with\n+// `Const(ty: size_of<T>, kind: Value(Branch([])))` which if you were to `==`\n+// the `ty` fields would return `false` and ICE. This test checks that we use\n+// actual semantic equality that takes into account aliases and infer vars.\n+\n+use std::mem::size_of;\n+\n+trait X<T> {\n+    fn f(self);\n+    fn g(self);\n+}\n+\n+struct Y;\n+\n+impl<T> X<T> for Y\n+where\n+    [(); size_of::<T>()]: Sized,\n+{\n+    fn f(self) {\n+        self.g();\n+    }\n+    fn g(self) {}\n+}\n+\n+fn main() {}"}, {"sha": "91a8a7c4a01215d9e92f3091871c2e87e118cf67", "filename": "tests/ui/const-generics/generic_const_exprs/const_kind_expr/relate_ty_with_infer_2.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Frelate_ty_with_infer_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Frelate_ty_with_infer_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Frelate_ty_with_infer_2.rs?ref=a85b0101e6a1d7d2a7a51d0e5472c1a1215b3031", "patch": "@@ -0,0 +1,151 @@\n+// check-pass\n+#![feature(inline_const, generic_const_exprs)]\n+#![allow(incomplete_features)]\n+use std::marker::PhantomData;\n+\n+pub struct Equal<const T: usize, const R: usize>();\n+pub trait True {}\n+impl<const T: usize> True for Equal<T, T> {}\n+\n+// replacement for generativity\n+pub struct Id<'id>(PhantomData<fn(&'id ()) -> &'id ()>);\n+pub struct Guard<'id>(Id<'id>);\n+fn make_guard<'id>(i: &'id Id<'id>) -> Guard<'id> {\n+    Guard(Id(PhantomData))\n+}\n+\n+impl<'id> Into<Id<'id>> for Guard<'id> {\n+    fn into(self) -> Id<'id> {\n+        self.0\n+    }\n+}\n+\n+pub struct Arena<'life> {\n+    bytes: *mut [u8],\n+    //bitmap: RefCell<RoaringBitmap>,\n+    _token: PhantomData<Id<'life>>,\n+}\n+\n+#[repr(transparent)]\n+pub struct Item<'life, T> {\n+    data: T,\n+    _phantom: PhantomData<Id<'life>>,\n+}\n+\n+#[repr(transparent)]\n+pub struct Token<'life, 'borrow, 'compact, 'reborrow, T>\n+where\n+    'life: 'reborrow,\n+    T: Tokenize<'life, 'borrow, 'compact, 'reborrow>,\n+{\n+    //ptr: *mut <T as Tokenize>::Tokenized,\n+    ptr: core::ptr::NonNull<T::Tokenized>,\n+    _phantom: PhantomData<Id<'life>>,\n+    _compact: PhantomData<&'borrow Guard<'compact>>,\n+    _result: PhantomData<&'reborrow T::Untokenized>,\n+}\n+\n+impl<'life> Arena<'life> {\n+    pub fn tokenize<'before, 'compact, 'borrow, 'reborrow, T, U>(\n+        &self,\n+        guard: &'borrow Guard<'compact>,\n+        item: Item<'life, &'before mut T>,\n+    ) -> Token<'life, 'borrow, 'compact, 'reborrow, U>\n+    where\n+        T: Tokenize<'life, 'borrow, 'compact, 'reborrow, Untokenized = U>,\n+        T::Untokenized: Tokenize<'life, 'borrow, 'compact, 'reborrow>,\n+        Equal<{ core::mem::size_of::<T>() }, { core::mem::size_of::<U>() }>: True,\n+        'compact: 'borrow,\n+        'life: 'reborrow,\n+        'life: 'compact,\n+        'life: 'borrow,\n+        // 'borrow: 'before ??\n+    {\n+        let dst = item.data as *mut T as *mut T::Tokenized;\n+        Token {\n+            ptr: core::ptr::NonNull::new(dst as *mut _).unwrap(),\n+            _phantom: PhantomData,\n+            _compact: PhantomData,\n+            _result: PhantomData,\n+        }\n+    }\n+}\n+\n+pub trait Tokenize<'life, 'borrow, 'compact, 'reborrow>\n+where\n+    'compact: 'borrow,\n+    'life: 'reborrow,\n+    'life: 'borrow,\n+    'life: 'compact,\n+{\n+    type Tokenized;\n+    type Untokenized;\n+    const TO: fn(&Arena<'life>, &'borrow Guard<'compact>, Self) -> Self::Tokenized;\n+    const FROM: fn(&'reborrow Arena<'life>, Self::Tokenized) -> Self::Untokenized;\n+}\n+\n+macro_rules! tokenize {\n+    ($to:expr, $from:expr) => {\n+        const TO: fn(&Arena<'life>, &'borrow Guard<'compact>, Self) -> Self::Tokenized = $to;\n+        const FROM: fn(&'reborrow Arena<'life>, Self::Tokenized) -> Self::Untokenized = $from;\n+    };\n+}\n+\n+struct Foo<'life, 'borrow>(Option<Item<'life, &'borrow mut Bar>>);\n+struct TokenFoo<'life, 'borrow, 'compact, 'reborrow>(\n+    Option<Token<'life, 'borrow, 'compact, 'reborrow, Bar>>,\n+);\n+struct Bar(u8);\n+\n+impl<'life, 'before, 'borrow, 'compact, 'reborrow> Tokenize<'life, 'borrow, 'compact, 'reborrow>\n+    for Foo<'life, 'before>\n+where\n+    'compact: 'borrow,\n+    'life: 'reborrow,\n+    'life: 'borrow,\n+    'life: 'compact,\n+{\n+    type Tokenized = TokenFoo<'life, 'borrow, 'compact, 'reborrow>;\n+    type Untokenized = Foo<'life, 'reborrow>;\n+    tokenize!(foo_to, foo_from);\n+}\n+\n+impl<'life, 'borrow, 'compact, 'reborrow> Tokenize<'life, 'borrow, 'compact, 'reborrow> for Bar\n+where\n+    'compact: 'borrow,\n+    'life: 'reborrow,\n+    'life: 'borrow,\n+    'life: 'compact,\n+{\n+    type Tokenized = Bar;\n+    type Untokenized = Bar;\n+    tokenize!(bar_to, bar_from);\n+}\n+\n+fn bar_to<'life, 'borrow, 'compact>(\n+    arena: &Arena<'life>,\n+    guard: &'borrow Guard<'compact>,\n+    s: Bar,\n+) -> Bar {\n+    s\n+}\n+fn bar_from<'life, 'reborrow>(arena: &'reborrow Arena<'life>, s: Bar) -> Bar {\n+    s\n+}\n+\n+fn foo_to<'life, 'borrow, 'compact, 'reborrow, 'before>(\n+    arena: &'before Arena<'life>,\n+    guard: &'borrow Guard<'compact>,\n+    s: Foo<'life, 'before>,\n+) -> TokenFoo<'life, 'borrow, 'compact, 'reborrow> {\n+    let Foo(bar) = s;\n+    TokenFoo(bar.map(|bar| arena.tokenize(guard, bar)))\n+}\n+fn foo_from<'life, 'borrow, 'compact, 'reborrow>(\n+    arena: &'reborrow Arena<'life>,\n+    s: TokenFoo<'life, 'borrow, 'compact, 'reborrow>,\n+) -> Foo<'life, 'reborrow> {\n+    Foo(s.0.map(|bar| panic!()))\n+}\n+\n+fn main() {}"}]}