{"sha": "0f70daa9b06882d7fb684a60160e4949d2861136", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNzBkYWE5YjA2ODgyZDdmYjY4NGE2MDE2MGU0OTQ5ZDI4NjExMzY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-01-12T10:29:00Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-01-16T18:59:11Z"}, "message": "resolve: Move privacy error reporting into a separate method\n\nGive named fields to `struct PrivacyError`\nMove `fn report_ambiguity_error` to `diagnostics.rs`", "tree": {"sha": "f066c6fc8b297c8c5908b315b7aaa5130cc8523a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f066c6fc8b297c8c5908b315b7aaa5130cc8523a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f70daa9b06882d7fb684a60160e4949d2861136", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f70daa9b06882d7fb684a60160e4949d2861136", "html_url": "https://github.com/rust-lang/rust/commit/0f70daa9b06882d7fb684a60160e4949d2861136", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f70daa9b06882d7fb684a60160e4949d2861136/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "117ceeba400e69aa7b8ba5155acd1c8c0cdf7f7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/117ceeba400e69aa7b8ba5155acd1c8c0cdf7f7f", "html_url": "https://github.com/rust-lang/rust/commit/117ceeba400e69aa7b8ba5155acd1c8c0cdf7f7f"}], "stats": {"total": 321, "additions": 166, "deletions": 155}, "files": [{"sha": "f83daa1636752d276286ed46cd2b054c3e0cfc66", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 151, "deletions": 2, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/0f70daa9b06882d7fb684a60160e4949d2861136/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f70daa9b06882d7fb684a60160e4949d2861136/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=0f70daa9b06882d7fb684a60160e4949d2861136", "patch": "@@ -8,7 +8,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n-use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n+use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::SourceMap;\n@@ -20,8 +20,9 @@ use syntax::util::lev_distance::find_best_match_for_name;\n \n use crate::imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n use crate::path_names_to_string;\n-use crate::VisResolutionError;\n+use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n+use crate::{NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n use rustc_error_codes::*;\n@@ -802,6 +803,154 @@ impl<'a> Resolver<'a> {\n         }\n         false\n     }\n+\n+    fn binding_description(&self, b: &NameBinding<'_>, ident: Ident, from_prelude: bool) -> String {\n+        let res = b.res();\n+        if b.span.is_dummy() {\n+            let add_built_in = match b.res() {\n+                // These already contain the \"built-in\" prefix or look bad with it.\n+                Res::NonMacroAttr(..) | Res::PrimTy(..) | Res::ToolMod => false,\n+                _ => true,\n+            };\n+            let (built_in, from) = if from_prelude {\n+                (\"\", \" from prelude\")\n+            } else if b.is_extern_crate()\n+                && !b.is_import()\n+                && self.session.opts.externs.get(&ident.as_str()).is_some()\n+            {\n+                (\"\", \" passed with `--extern`\")\n+            } else if add_built_in {\n+                (\" built-in\", \"\")\n+            } else {\n+                (\"\", \"\")\n+            };\n+\n+            let article = if built_in.is_empty() { res.article() } else { \"a\" };\n+            format!(\n+                \"{a}{built_in} {thing}{from}\",\n+                a = article,\n+                thing = res.descr(),\n+                built_in = built_in,\n+                from = from\n+            )\n+        } else {\n+            let introduced = if b.is_import() { \"imported\" } else { \"defined\" };\n+            format!(\"the {thing} {introduced} here\", thing = res.descr(), introduced = introduced)\n+        }\n+    }\n+\n+    crate fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError<'_>) {\n+        let AmbiguityError { kind, ident, b1, b2, misc1, misc2 } = *ambiguity_error;\n+        let (b1, b2, misc1, misc2, swapped) = if b2.span.is_dummy() && !b1.span.is_dummy() {\n+            // We have to print the span-less alternative first, otherwise formatting looks bad.\n+            (b2, b1, misc2, misc1, true)\n+        } else {\n+            (b1, b2, misc1, misc2, false)\n+        };\n+\n+        let mut err = struct_span_err!(\n+            self.session,\n+            ident.span,\n+            E0659,\n+            \"`{ident}` is ambiguous ({why})\",\n+            ident = ident,\n+            why = kind.descr()\n+        );\n+        err.span_label(ident.span, \"ambiguous name\");\n+\n+        let mut could_refer_to = |b: &NameBinding<'_>, misc: AmbiguityErrorMisc, also: &str| {\n+            let what = self.binding_description(b, ident, misc == AmbiguityErrorMisc::FromPrelude);\n+            let note_msg = format!(\n+                \"`{ident}` could{also} refer to {what}\",\n+                ident = ident,\n+                also = also,\n+                what = what\n+            );\n+\n+            let thing = b.res().descr();\n+            let mut help_msgs = Vec::new();\n+            if b.is_glob_import()\n+                && (kind == AmbiguityKind::GlobVsGlob\n+                    || kind == AmbiguityKind::GlobVsExpanded\n+                    || kind == AmbiguityKind::GlobVsOuter && swapped != also.is_empty())\n+            {\n+                help_msgs.push(format!(\n+                    \"consider adding an explicit import of \\\n+                     `{ident}` to disambiguate\",\n+                    ident = ident\n+                ))\n+            }\n+            if b.is_extern_crate() && ident.span.rust_2018() {\n+                help_msgs.push(format!(\n+                    \"use `::{ident}` to refer to this {thing} unambiguously\",\n+                    ident = ident,\n+                    thing = thing,\n+                ))\n+            }\n+            if misc == AmbiguityErrorMisc::SuggestCrate {\n+                help_msgs.push(format!(\n+                    \"use `crate::{ident}` to refer to this {thing} unambiguously\",\n+                    ident = ident,\n+                    thing = thing,\n+                ))\n+            } else if misc == AmbiguityErrorMisc::SuggestSelf {\n+                help_msgs.push(format!(\n+                    \"use `self::{ident}` to refer to this {thing} unambiguously\",\n+                    ident = ident,\n+                    thing = thing,\n+                ))\n+            }\n+\n+            err.span_note(b.span, &note_msg);\n+            for (i, help_msg) in help_msgs.iter().enumerate() {\n+                let or = if i == 0 { \"\" } else { \"or \" };\n+                err.help(&format!(\"{}{}\", or, help_msg));\n+            }\n+        };\n+\n+        could_refer_to(b1, misc1, \"\");\n+        could_refer_to(b2, misc2, \" also\");\n+        err.emit();\n+    }\n+\n+    crate fn report_privacy_error(&self, privacy_error: &PrivacyError<'_>) {\n+        let PrivacyError { ident, binding, .. } = *privacy_error;\n+        let session = &self.session;\n+        let mk_struct_span_error = |is_constructor| {\n+            struct_span_err!(\n+                session,\n+                ident.span,\n+                E0603,\n+                \"{}{} `{}` is private\",\n+                binding.res().descr(),\n+                if is_constructor { \" constructor\" } else { \"\" },\n+                ident.name,\n+            )\n+        };\n+\n+        let mut err = if let NameBindingKind::Res(\n+            Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), ctor_def_id),\n+            _,\n+        ) = binding.kind\n+        {\n+            let def_id = (&*self).parent(ctor_def_id).expect(\"no parent for a constructor\");\n+            if let Some(fields) = self.field_names.get(&def_id) {\n+                let mut err = mk_struct_span_error(true);\n+                let first_field = fields.first().expect(\"empty field list in the map\");\n+                err.span_label(\n+                    fields.iter().fold(first_field.span, |acc, field| acc.to(field.span)),\n+                    \"a constructor is private if any of the fields is private\",\n+                );\n+                err\n+            } else {\n+                mk_struct_span_error(false)\n+            }\n+        } else {\n+            mk_struct_span_error(false)\n+        };\n+\n+        err.emit();\n+    }\n }\n \n impl<'a, 'b> ImportResolver<'a, 'b> {"}, {"sha": "9f459834175c126a2584b81db962baefae7de960", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f70daa9b06882d7fb684a60160e4949d2861136/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f70daa9b06882d7fb684a60160e4949d2861136/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=0f70daa9b06882d7fb684a60160e4949d2861136", "patch": "@@ -319,7 +319,11 @@ impl<'a> Resolver<'a> {\n                        // Remove this together with `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n                        !(self.last_import_segment && binding.is_extern_crate())\n                         {\n-                            self.privacy_errors.push(PrivacyError(path_span, ident, binding));\n+                            self.privacy_errors.push(PrivacyError {\n+                                ident,\n+                                binding,\n+                                dedup_span: path_span,\n+                            });\n                         }\n \n                         Ok(binding)"}, {"sha": "60a0049f5da379c29d990ca6913dc4fcb4e20c11", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 10, "deletions": 152, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/0f70daa9b06882d7fb684a60160e4949d2861136/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f70daa9b06882d7fb684a60160e4949d2861136/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0f70daa9b06882d7fb684a60160e4949d2861136", "patch": "@@ -2,12 +2,9 @@\n //!\n //! Module structure of the crate is built here.\n //! Paths in macros, imports, expressions, types, patterns are resolved here.\n-//! Label names are resolved here as well.\n+//! Label and lifetime names are resolved here as well.\n //!\n //! Type-relative name resolution (methods, fields, associated items) happens in `librustc_typeck`.\n-//! Lifetime names are resolved in `librustc/middle/resolve_lifetime.rs`.\n-\n-// ignore-tidy-filelength\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(bool_to_option)]\n@@ -33,7 +30,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def::Namespace::*;\n-use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n+use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy::{self, Bool, Char, Float, Int, Str, Uint};\n use rustc_hir::{GlobMap, TraitMap};\n@@ -604,7 +601,11 @@ impl<'a> NameBindingKind<'a> {\n     }\n }\n \n-struct PrivacyError<'a>(Span, Ident, &'a NameBinding<'a>);\n+struct PrivacyError<'a> {\n+    ident: Ident,\n+    binding: &'a NameBinding<'a>,\n+    dedup_span: Span,\n+}\n \n struct UseError<'a> {\n     err: DiagnosticBuilder<'a>,\n@@ -2446,115 +2447,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn binding_description(&self, b: &NameBinding<'_>, ident: Ident, from_prelude: bool) -> String {\n-        let res = b.res();\n-        if b.span.is_dummy() {\n-            let add_built_in = match b.res() {\n-                // These already contain the \"built-in\" prefix or look bad with it.\n-                Res::NonMacroAttr(..) | Res::PrimTy(..) | Res::ToolMod => false,\n-                _ => true,\n-            };\n-            let (built_in, from) = if from_prelude {\n-                (\"\", \" from prelude\")\n-            } else if b.is_extern_crate()\n-                && !b.is_import()\n-                && self.session.opts.externs.get(&ident.as_str()).is_some()\n-            {\n-                (\"\", \" passed with `--extern`\")\n-            } else if add_built_in {\n-                (\" built-in\", \"\")\n-            } else {\n-                (\"\", \"\")\n-            };\n-\n-            let article = if built_in.is_empty() { res.article() } else { \"a\" };\n-            format!(\n-                \"{a}{built_in} {thing}{from}\",\n-                a = article,\n-                thing = res.descr(),\n-                built_in = built_in,\n-                from = from\n-            )\n-        } else {\n-            let introduced = if b.is_import() { \"imported\" } else { \"defined\" };\n-            format!(\"the {thing} {introduced} here\", thing = res.descr(), introduced = introduced)\n-        }\n-    }\n-\n-    fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError<'_>) {\n-        let AmbiguityError { kind, ident, b1, b2, misc1, misc2 } = *ambiguity_error;\n-        let (b1, b2, misc1, misc2, swapped) = if b2.span.is_dummy() && !b1.span.is_dummy() {\n-            // We have to print the span-less alternative first, otherwise formatting looks bad.\n-            (b2, b1, misc2, misc1, true)\n-        } else {\n-            (b1, b2, misc1, misc2, false)\n-        };\n-\n-        let mut err = struct_span_err!(\n-            self.session,\n-            ident.span,\n-            E0659,\n-            \"`{ident}` is ambiguous ({why})\",\n-            ident = ident,\n-            why = kind.descr()\n-        );\n-        err.span_label(ident.span, \"ambiguous name\");\n-\n-        let mut could_refer_to = |b: &NameBinding<'_>, misc: AmbiguityErrorMisc, also: &str| {\n-            let what = self.binding_description(b, ident, misc == AmbiguityErrorMisc::FromPrelude);\n-            let note_msg = format!(\n-                \"`{ident}` could{also} refer to {what}\",\n-                ident = ident,\n-                also = also,\n-                what = what\n-            );\n-\n-            let thing = b.res().descr();\n-            let mut help_msgs = Vec::new();\n-            if b.is_glob_import()\n-                && (kind == AmbiguityKind::GlobVsGlob\n-                    || kind == AmbiguityKind::GlobVsExpanded\n-                    || kind == AmbiguityKind::GlobVsOuter && swapped != also.is_empty())\n-            {\n-                help_msgs.push(format!(\n-                    \"consider adding an explicit import of \\\n-                     `{ident}` to disambiguate\",\n-                    ident = ident\n-                ))\n-            }\n-            if b.is_extern_crate() && ident.span.rust_2018() {\n-                help_msgs.push(format!(\n-                    \"use `::{ident}` to refer to this {thing} unambiguously\",\n-                    ident = ident,\n-                    thing = thing,\n-                ))\n-            }\n-            if misc == AmbiguityErrorMisc::SuggestCrate {\n-                help_msgs.push(format!(\n-                    \"use `crate::{ident}` to refer to this {thing} unambiguously\",\n-                    ident = ident,\n-                    thing = thing,\n-                ))\n-            } else if misc == AmbiguityErrorMisc::SuggestSelf {\n-                help_msgs.push(format!(\n-                    \"use `self::{ident}` to refer to this {thing} unambiguously\",\n-                    ident = ident,\n-                    thing = thing,\n-                ))\n-            }\n-\n-            err.span_note(b.span, &note_msg);\n-            for (i, help_msg) in help_msgs.iter().enumerate() {\n-                let or = if i == 0 { \"\" } else { \"or \" };\n-                err.help(&format!(\"{}{}\", or, help_msg));\n-            }\n-        };\n-\n-        could_refer_to(b1, misc1, \"\");\n-        could_refer_to(b2, misc2, \" also\");\n-        err.emit();\n-    }\n-\n     fn report_errors(&mut self, krate: &Crate) {\n         self.report_with_use_injections(krate);\n \n@@ -2575,43 +2467,9 @@ impl<'a> Resolver<'a> {\n         }\n \n         let mut reported_spans = FxHashSet::default();\n-        for &PrivacyError(dedup_span, ident, binding) in &self.privacy_errors {\n-            if reported_spans.insert(dedup_span) {\n-                let session = &self.session;\n-                let mk_struct_span_error = |is_constructor| {\n-                    struct_span_err!(\n-                        session,\n-                        ident.span,\n-                        E0603,\n-                        \"{}{} `{}` is private\",\n-                        binding.res().descr(),\n-                        if is_constructor { \" constructor\" } else { \"\" },\n-                        ident.name,\n-                    )\n-                };\n-\n-                let mut err = if let NameBindingKind::Res(\n-                    Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), ctor_def_id),\n-                    _,\n-                ) = binding.kind\n-                {\n-                    let def_id = (&*self).parent(ctor_def_id).expect(\"no parent for a constructor\");\n-                    if let Some(fields) = self.field_names.get(&def_id) {\n-                        let mut err = mk_struct_span_error(true);\n-                        let first_field = fields.first().expect(\"empty field list in the map\");\n-                        err.span_label(\n-                            fields.iter().fold(first_field.span, |acc, field| acc.to(field.span)),\n-                            \"a constructor is private if any of the fields is private\",\n-                        );\n-                        err\n-                    } else {\n-                        mk_struct_span_error(false)\n-                    }\n-                } else {\n-                    mk_struct_span_error(false)\n-                };\n-\n-                err.emit();\n+        for error in &self.privacy_errors {\n+            if reported_spans.insert(error.dedup_span) {\n+                self.report_privacy_error(error);\n             }\n         }\n     }"}]}