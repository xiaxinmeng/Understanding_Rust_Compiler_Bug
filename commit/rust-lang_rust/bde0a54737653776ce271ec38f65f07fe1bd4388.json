{"sha": "bde0a54737653776ce271ec38f65f07fe1bd4388", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZTBhNTQ3Mzc2NTM3NzZjZTI3MWVjMzhmNjVmMDdmZTFiZDQzODg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-09-15T19:48:38Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-09-15T19:48:38Z"}, "message": "Revert \"Auto merge of #53527 - Emerentius:test_all, r=nrc\"\n\nThis reverts commit 9f53c87b4b1f097e111c9525d60470ed22631018, reversing\nchanges made to cba0fdf43c22795822e1d7c751a69e6c85007221.", "tree": {"sha": "b987e0eddbd091477ef786182dd789a910ca0894", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b987e0eddbd091477ef786182dd789a910ca0894"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bde0a54737653776ce271ec38f65f07fe1bd4388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bde0a54737653776ce271ec38f65f07fe1bd4388", "html_url": "https://github.com/rust-lang/rust/commit/bde0a54737653776ce271ec38f65f07fe1bd4388", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bde0a54737653776ce271ec38f65f07fe1bd4388/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4529d10636911ad5b8f13dec2401040bc85645e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4529d10636911ad5b8f13dec2401040bc85645e5", "html_url": "https://github.com/rust-lang/rust/commit/4529d10636911ad5b8f13dec2401040bc85645e5"}], "stats": {"total": 200, "additions": 81, "deletions": 119}, "files": [{"sha": "6ffa6e9be937d134c91b661134d31a00b8603f18", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 81, "deletions": 119, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/bde0a54737653776ce271ec38f65f07fe1bd4388/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde0a54737653776ce271ec38f65f07fe1bd4388/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=bde0a54737653776ce271ec38f65f07fe1bd4388", "patch": "@@ -81,7 +81,7 @@ const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in qu\n // to be used by rustc to compile tests in libtest\n pub mod test {\n     pub use {assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n-             Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, ShouldPanic,\n+             Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, ShouldPanic,\n              StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName,\n              TestOpts, TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk};\n }\n@@ -349,19 +349,12 @@ pub enum OutputFormat {\n     Json,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum RunIgnored {\n-    Yes,\n-    No,\n-    Only,\n-}\n-\n #[derive(Debug)]\n pub struct TestOpts {\n     pub list: bool,\n     pub filter: Option<String>,\n     pub filter_exact: bool,\n-    pub run_ignored: RunIgnored,\n+    pub run_ignored: bool,\n     pub run_tests: bool,\n     pub bench_benchmarks: bool,\n     pub logfile: Option<PathBuf>,\n@@ -380,7 +373,7 @@ impl TestOpts {\n             list: false,\n             filter: None,\n             filter_exact: false,\n-            run_ignored: RunIgnored::No,\n+            run_ignored: false,\n             run_tests: false,\n             bench_benchmarks: false,\n             logfile: None,\n@@ -399,8 +392,7 @@ pub type OptRes = Result<TestOpts, String>;\n \n fn optgroups() -> getopts::Options {\n     let mut opts = getopts::Options::new();\n-    opts.optflag(\"\", \"include-ignored\", \"Run ignored and not ignored tests\")\n-        .optflag(\"\", \"ignored\", \"Run only ignored tests\")\n+    opts.optflag(\"\", \"ignored\", \"Run ignored tests\")\n         .optflag(\"\", \"test\", \"Run tests and not benchmarks\")\n         .optflag(\"\", \"bench\", \"Run benchmarks instead of tests\")\n         .optflag(\"\", \"list\", \"List all tests and benchmarks\")\n@@ -499,8 +491,8 @@ Test Attributes:\n                      contain: #[should_panic(expected = \"foo\")].\n     #[ignore]      - When applied to a function which is already attributed as a\n                      test, then the test runner will ignore these tests during\n-                     normal test runs. Running with --ignored or --include-ignored will run\n-                     these tests.\"#,\n+                     normal test runs. Running with --ignored will run these\n+                     tests.\"#,\n         usage = options.usage(&message)\n     );\n }\n@@ -553,21 +545,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         None\n     };\n \n-    let include_ignored = matches.opt_present(\"include-ignored\");\n-    if !allow_unstable && include_ignored {\n-        return Some(Err(\n-            \"The \\\"include-ignored\\\" flag is only accepted on the nightly compiler\".into()\n-        ));\n-    }\n-\n-    let run_ignored = match (include_ignored, matches.opt_present(\"ignored\")) {\n-        (true, true) => return Some(Err(\n-            \"the options --include-ignored and --ignored are mutually exclusive\".into()\n-        )),\n-        (true, false) => RunIgnored::Yes,\n-        (false, true) => RunIgnored::Only,\n-        (false, false) => RunIgnored::No,\n-    };\n+    let run_ignored = matches.opt_present(\"ignored\");\n     let quiet = matches.opt_present(\"quiet\");\n     let exact = matches.opt_present(\"exact\");\n     let list = matches.opt_present(\"list\");\n@@ -1319,36 +1297,55 @@ fn get_concurrency() -> usize {\n \n pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n     let mut filtered = tests;\n-    let matches_filter = |test: &TestDescAndFn, filter: &str| {\n-        let test_name = test.desc.name.as_slice();\n-\n-        match opts.filter_exact {\n-            true => test_name == filter,\n-            false => test_name.contains(filter),\n-        }\n-    };\n-\n     // Remove tests that don't match the test filter\n-    if let Some(ref filter) = opts.filter {\n-        filtered.retain(|test| matches_filter(test, filter));\n-    }\n+    filtered = match opts.filter {\n+        None => filtered,\n+        Some(ref filter) => filtered\n+            .into_iter()\n+            .filter(|test| {\n+                if opts.filter_exact {\n+                    test.desc.name.as_slice() == &filter[..]\n+                } else {\n+                    test.desc.name.as_slice().contains(&filter[..])\n+                }\n+            })\n+            .collect(),\n+    };\n \n     // Skip tests that match any of the skip filters\n-    filtered.retain(|test| {\n-        !opts.skip.iter().any(|sf| matches_filter(test, sf))\n-    });\n-\n-    // maybe unignore tests\n-    match opts.run_ignored {\n-        RunIgnored::Yes => {\n-            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n-        },\n-        RunIgnored::Only => {\n-            filtered.retain(|test| test.desc.ignore);\n-            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n+    filtered = filtered\n+        .into_iter()\n+        .filter(|t| {\n+            !opts.skip.iter().any(|sf| {\n+                if opts.filter_exact {\n+                    t.desc.name.as_slice() == &sf[..]\n+                } else {\n+                    t.desc.name.as_slice().contains(&sf[..])\n+                }\n+            })\n+        })\n+        .collect();\n+\n+    // Maybe pull out the ignored test and unignore them\n+    filtered = if !opts.run_ignored {\n+        filtered\n+    } else {\n+        fn filter(test: TestDescAndFn) -> Option<TestDescAndFn> {\n+            if test.desc.ignore {\n+                let TestDescAndFn { desc, testfn } = test;\n+                Some(TestDescAndFn {\n+                    desc: TestDesc {\n+                        ignore: false,\n+                        ..desc\n+                    },\n+                    testfn,\n+                })\n+            } else {\n+                None\n+            }\n         }\n-        RunIgnored::No => {}\n-    }\n+        filtered.into_iter().filter_map(filter).collect()\n+    };\n \n     // Sort the tests alphabetically\n     filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(t2.desc.name.as_slice()));\n@@ -1737,37 +1734,13 @@ pub mod bench {\n \n #[cfg(test)]\n mod tests {\n-    use test::{filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n-               ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed,\n-               TrFailedMsg, TrIgnored, TrOk};\n+    use test::{filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, ShouldPanic,\n+               StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n+               TrIgnored, TrOk};\n     use std::sync::mpsc::channel;\n     use bench;\n     use Bencher;\n \n-\n-    fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n-        vec![\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"1\"),\n-                    ignore: true,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {})),\n-            },\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"2\"),\n-                    ignore: false,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {})),\n-            },\n-        ]\n-    }\n-\n     #[test]\n     pub fn do_not_run_ignored_tests() {\n         fn f() {\n@@ -1893,20 +1866,11 @@ mod tests {\n             \"filter\".to_string(),\n             \"--ignored\".to_string(),\n         ];\n-        let opts = parse_opts(&args).unwrap().unwrap();\n-        assert_eq!(opts.run_ignored, RunIgnored::Only);\n-    }\n-\n-    #[test]\n-    fn parse_include_ignored_flag() {\n-        let args = vec![\n-            \"progname\".to_string(),\n-            \"filter\".to_string(),\n-            \"-Zunstable-options\".to_string(),\n-            \"--include-ignored\".to_string(),\n-        ];\n-        let opts = parse_opts(&args).unwrap().unwrap();\n-        assert_eq!(opts.run_ignored, RunIgnored::Yes);\n+        let opts = match parse_opts(&args) {\n+            Some(Ok(o)) => o,\n+            _ => panic!(\"Malformed arg in parse_ignored_flag\"),\n+        };\n+        assert!((opts.run_ignored));\n     }\n \n     #[test]\n@@ -1916,33 +1880,35 @@ mod tests {\n \n         let mut opts = TestOpts::new();\n         opts.run_tests = true;\n-        opts.run_ignored = RunIgnored::Only;\n+        opts.run_ignored = true;\n \n-        let tests = one_ignored_one_unignored_test();\n+        let tests = vec![\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"1\"),\n+                    ignore: true,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"2\"),\n+                    ignore: false,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+        ];\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n         assert_eq!(filtered[0].desc.name.to_string(), \"1\");\n         assert!(!filtered[0].desc.ignore);\n     }\n \n-    #[test]\n-    pub fn run_include_ignored_option() {\n-        // When we \"--include-ignored\" tests, the ignore flag should be set to false on\n-        // all tests and no test filtered out\n-\n-        let mut opts = TestOpts::new();\n-        opts.run_tests = true;\n-        opts.run_ignored = RunIgnored::Yes;\n-\n-        let tests = one_ignored_one_unignored_test();\n-        let filtered = filter_tests(&opts, tests);\n-\n-        assert_eq!(filtered.len(), 2);\n-        assert!(!filtered[0].desc.ignore);\n-        assert!(!filtered[1].desc.ignore);\n-    }\n-\n     #[test]\n     pub fn exact_filter_match() {\n         fn tests() -> Vec<TestDescAndFn> {\n@@ -2050,9 +2016,7 @@ mod tests {\n             \"test::ignored_tests_result_in_ignored\".to_string(),\n             \"test::first_free_arg_should_be_a_filter\".to_string(),\n             \"test::parse_ignored_flag\".to_string(),\n-            \"test::parse_include_ignored_flag\".to_string(),\n             \"test::filter_for_ignored_option\".to_string(),\n-            \"test::run_include_ignored_option\".to_string(),\n             \"test::sort_tests\".to_string(),\n         ];\n         let tests = {\n@@ -2083,8 +2047,6 @@ mod tests {\n             \"test::first_free_arg_should_be_a_filter\".to_string(),\n             \"test::ignored_tests_result_in_ignored\".to_string(),\n             \"test::parse_ignored_flag\".to_string(),\n-            \"test::parse_include_ignored_flag\".to_string(),\n-            \"test::run_include_ignored_option\".to_string(),\n             \"test::sort_tests\".to_string(),\n         ];\n "}]}