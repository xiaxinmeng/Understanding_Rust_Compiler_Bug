{"sha": "ee59aacac490edd619db1c4e2fcd848f793bc3b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNTlhYWNhYzQ5MGVkZDYxOWRiMWM0ZTJmY2Q4NDhmNzkzYmMzYjk=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-10T01:48:01Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-10T01:48:01Z"}, "message": "Merge remote-tracking branch 'remotes/origin/master' into remove-str-trailing-nulls", "tree": {"sha": "d4f01cefe67f55b80cfaca641a03b581823eb200", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4f01cefe67f55b80cfaca641a03b581823eb200"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee59aacac490edd619db1c4e2fcd848f793bc3b9", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee59aacac490edd619db1c4e2fcd848f793bc3b9", "html_url": "https://github.com/rust-lang/rust/commit/ee59aacac490edd619db1c4e2fcd848f793bc3b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee59aacac490edd619db1c4e2fcd848f793bc3b9/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cab6d46e58ea6f7535d8e454f0345eccfae183c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cab6d46e58ea6f7535d8e454f0345eccfae183c4", "html_url": "https://github.com/rust-lang/rust/commit/cab6d46e58ea6f7535d8e454f0345eccfae183c4"}, {"sha": "6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338", "html_url": "https://github.com/rust-lang/rust/commit/6f6dce7bbcfb104a8a1e23b0b93d83cbb770f338"}], "stats": {"total": 2849, "additions": 1740, "deletions": 1109}, "files": [{"sha": "d285253ffe200158075a3e305131aec574079966", "filename": "doc/rust.md", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -744,7 +744,7 @@ There are several kinds of view item:\n ##### Extern mod declarations\n \n ~~~~~~~~ {.ebnf .gram}\n-extern_mod_decl : \"extern\" \"mod\" ident [ '(' link_attrs ')' ] ? ;\n+extern_mod_decl : \"extern\" \"mod\" ident [ '(' link_attrs ')' ] ? [ '=' string_lit ] ? ;\n link_attrs : link_attr [ ',' link_attrs ] + ;\n link_attr : ident '=' literal ;\n ~~~~~~~~\n@@ -755,20 +755,34 @@ as the `ident` provided in the `extern_mod_decl`.\n \n The external crate is resolved to a specific `soname` at compile time,\n and a runtime linkage requirement to that `soname` is passed to the linker for\n-loading at runtime. The `soname` is resolved at compile time by scanning the\n-compiler's library path and matching the `link_attrs` provided in the\n-`use_decl` against any `#link` attributes that were declared on the external\n-crate when it was compiled. If no `link_attrs` are provided, a default `name`\n-attribute is assumed, equal to the `ident` given in the `use_decl`.\n-\n-Three examples of `extern mod` declarations:\n+loading at runtime.\n+The `soname` is resolved at compile time by scanning the compiler's library path\n+and matching the `link_attrs` provided in the `use_decl` against any `#link` attributes that\n+were declared on the external crate when it was compiled.\n+If no `link_attrs` are provided,\n+a default `name` attribute is assumed,\n+equal to the `ident` given in the `use_decl`.\n+\n+Optionally, an identifier in an `extern mod` declaration may be followed by an equals sign,\n+then a string literal denoting a relative path on the filesystem.\n+This path should exist in one of the directories in the Rust path,\n+which by default contains the `.rust` subdirectory of the current directory and each of its parents,\n+as well as any directories in the colon-separated (or semicolon-separated on Windows)\n+list of paths that is the `RUST_PATH` environment variable.\n+The meaning of `extern mod a = \"b/c/d\";`, supposing that `/a` is in the RUST_PATH,\n+is that the name `a` should be taken as a reference to the crate whose absolute location is\n+`/a/b/c/d`.\n+\n+Four examples of `extern mod` declarations:\n \n ~~~~~~~~{.xfail-test}\n extern mod pcre (uuid = \"54aba0f8-a7b1-4beb-92f1-4cf625264841\");\n \n extern mod extra; // equivalent to: extern mod extra ( name = \"extra\" );\n \n extern mod rustextra (name = \"extra\"); // linking to 'extra' under another name\n+\n+extern mod complicated_mod = \"some-file/in/the-rust/path\";\n ~~~~~~~~\n \n ##### Use declarations"}, {"sha": "4b50c5aa7963f2d3ddea4107a5bd800913a183e9", "filename": "mk/install.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -199,7 +199,7 @@ endef\n $(foreach target,$(CFG_TARGET_TRIPLES), \\\n   $(if $(findstring $(target),\"arm-linux-androideabi\"), \\\n     $(if $(findstring adb,$(CFG_ADB)), \\\n-      $(if $(findstring device,$(shell adb devices 2>/dev/null | grep -E '^[_A-Za-z0-9-]+[[:blank:]]+device')), \\\n+      $(if $(findstring device,$(shell $(CFG_ADB) devices 2>/dev/null | grep -E '^[_A-Za-z0-9-]+[[:blank:]]+device')), \\\n         $(info install: install-runtime-target for $(target) enabled \\\n           $(info install: android device attached) \\\n           $(eval $(call DEF_ADB_DEVICE_STATUS, true))), \\"}, {"sha": "349ffc63d9701362a37ba726dfba2c1b49996ecb", "filename": "mk/tests.mk", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -123,7 +123,7 @@ endef\n $(foreach target,$(CFG_TARGET_TRIPLES), \\\n   $(if $(findstring $(target),\"arm-linux-androideabi\"), \\\n     $(if $(findstring adb,$(CFG_ADB)), \\\n-      $(if $(findstring device,$(shell adb devices 2>/dev/null | grep -E '^[_A-Za-z0-9-]+[[:blank:]]+device')), \\\n+      $(if $(findstring device,$(shell $(CFG_ADB) devices 2>/dev/null | grep -E '^[_A-Za-z0-9-]+[[:blank:]]+device')), \\\n         $(info check: $(target) test enabled \\\n           $(info check: android device attached) \\\n           $(eval $(call DEF_ADB_DEVICE_STATUS, true))), \\\n@@ -348,7 +348,9 @@ $(3)/stage$(1)/test/rustpkgtest-$(2)$$(X_$(2)):\t\t\t\t\t\\\n \t\t$$(RUSTPKG_LIB) $$(RUSTPKG_INPUTS)\t\t\\\n \t\t$$(SREQ$(1)_T_$(2)_H_$(3)) \\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBSYNTAX_$(2)) \\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC_$(2))\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC_$(2)) \\\n+\t\t$$(TBIN$(1)_T_$(2)_H_$(3))/rustpkg$$(X_$(2)) \\\n+\t\t$$(TBIN$(1)_T_$(2)_H_$(3))/rustc$$(X_$(2))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n "}, {"sha": "f79e01b6f28b296d031de972c042cb7a6a655035", "filename": "src/libextra/time.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -57,9 +57,6 @@ impl Ord for Timespec {\n         self.sec < other.sec ||\n             (self.sec == other.sec && self.nsec < other.nsec)\n     }\n-    fn le(&self, other: &Timespec) -> bool { !other.lt(self) }\n-    fn ge(&self, other: &Timespec) -> bool { !self.lt(other) }\n-    fn gt(&self, other: &Timespec) -> bool { !self.le(other) }\n }\n \n /**"}, {"sha": "fbe17fb0d1c9e0ddf9a0904f1e1544d6db04e61e", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -16,7 +16,7 @@ use lib::llvm::llvm;\n use lib::llvm::ModuleRef;\n use lib;\n use metadata::common::LinkMeta;\n-use metadata::{encoder, csearch, cstore};\n+use metadata::{encoder, csearch, cstore, filesearch};\n use middle::trans::context::CrateContext;\n use middle::trans::common::gensym_name;\n use middle::ty;\n@@ -500,35 +500,40 @@ pub fn build_link_meta(sess: Session,\n     struct ProvidedMetas {\n         name: Option<@str>,\n         vers: Option<@str>,\n+        pkg_id: Option<@str>,\n         cmh_items: ~[@ast::MetaItem]\n     }\n \n     fn provided_link_metas(sess: Session, c: &ast::Crate) ->\n        ProvidedMetas {\n         let mut name = None;\n         let mut vers = None;\n+        let mut pkg_id = None;\n         let mut cmh_items = ~[];\n         let linkage_metas = attr::find_linkage_metas(c.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for meta in linkage_metas.iter() {\n             match meta.name_str_pair() {\n                 Some((n, value)) if \"name\" == n => name = Some(value),\n                 Some((n, value)) if \"vers\" == n => vers = Some(value),\n+                Some((n, value)) if \"package_id\" == n => pkg_id = Some(value),\n                 _ => cmh_items.push(*meta)\n             }\n         }\n \n         ProvidedMetas {\n             name: name,\n             vers: vers,\n+            pkg_id: pkg_id,\n             cmh_items: cmh_items\n         }\n     }\n \n     // This calculates CMH as defined above\n     fn crate_meta_extras_hash(symbol_hasher: &mut hash::State,\n                               cmh_items: ~[@ast::MetaItem],\n-                              dep_hashes: ~[@str]) -> @str {\n+                              dep_hashes: ~[@str],\n+                              pkg_id: Option<@str>) -> @str {\n         fn len_and_str(s: &str) -> ~str {\n             fmt!(\"%u_%s\", s.len(), s)\n         }\n@@ -566,7 +571,10 @@ pub fn build_link_meta(sess: Session,\n             write_string(symbol_hasher, len_and_str(*dh));\n         }\n \n-    // tjc: allocation is unfortunate; need to change std::hash\n+        for p in pkg_id.iter() {\n+            write_string(symbol_hasher, len_and_str(*p));\n+        }\n+\n         return truncated_hash_result(symbol_hasher).to_managed();\n     }\n \n@@ -608,18 +616,20 @@ pub fn build_link_meta(sess: Session,\n     let ProvidedMetas {\n         name: opt_name,\n         vers: opt_vers,\n+        pkg_id: opt_pkg_id,\n         cmh_items: cmh_items\n     } = provided_link_metas(sess, c);\n     let name = crate_meta_name(sess, output, opt_name);\n     let vers = crate_meta_vers(sess, opt_vers);\n     let dep_hashes = cstore::get_dep_hashes(sess.cstore);\n     let extras_hash =\n         crate_meta_extras_hash(symbol_hasher, cmh_items,\n-                               dep_hashes);\n+                               dep_hashes, opt_pkg_id);\n \n     LinkMeta {\n         name: name,\n         vers: vers,\n+        package_id: opt_pkg_id,\n         extras_hash: extras_hash\n     }\n }\n@@ -942,6 +952,11 @@ pub fn link_args(sess: Session,\n         args.push(~\"-L\" + path.to_str());\n     }\n \n+    let rustpath = filesearch::rust_path();\n+    for path in rustpath.iter() {\n+        args.push(~\"-L\" + path.to_str());\n+    }\n+\n     // The names of the extern libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n     for l in used_libs.iter() { args.push(~\"-l\" + *l); }"}, {"sha": "5dc92dbc5e6222af6342eae9ad0372cd4a84bd5b", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 13, "deletions": 113, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -14,10 +14,7 @@ use metadata::cstore;\n use metadata::filesearch;\n \n use std::hashmap::HashSet;\n-use std::num;\n-use std::os;\n-use std::util;\n-use std::vec;\n+use std::{num, os, path, uint, util, vec};\n \n fn not_win32(os: session::os) -> bool {\n   os != session::os_win32\n@@ -122,42 +119,7 @@ pub fn get_rpath_relative_to_output(os: session::os,\n         session::os_win32 => util::unreachable()\n     };\n \n-    Path(prefix).push_rel(&get_relative_to(&os::make_absolute(output),\n-                                           &os::make_absolute(lib)))\n-}\n-\n-// Find the relative path from one file to another\n-pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n-    assert!(abs1.is_absolute);\n-    assert!(abs2.is_absolute);\n-    let abs1 = abs1.normalize();\n-    let abs2 = abs2.normalize();\n-    debug!(\"finding relative path from %s to %s\",\n-           abs1.to_str(), abs2.to_str());\n-    let split1: &[~str] = abs1.components;\n-    let split2: &[~str] = abs2.components;\n-    let len1 = split1.len();\n-    let len2 = split2.len();\n-    assert!(len1 > 0);\n-    assert!(len2 > 0);\n-\n-    let max_common_path = num::min(len1, len2) - 1;\n-    let mut start_idx = 0;\n-    while start_idx < max_common_path\n-        && split1[start_idx] == split2[start_idx] {\n-        start_idx += 1;\n-    }\n-\n-    let mut path = ~[];\n-    for _ in range(start_idx, len1 - 1) { path.push(~\"..\"); };\n-\n-    path.push_all(split2.slice(start_idx, len2 - 1));\n-\n-    return if !path.is_empty() {\n-        Path(\"\").push_many(path)\n-    } else {\n-        Path(\".\")\n-    }\n+    Path(prefix).push_rel(&os::make_absolute(output).get_relative_to(&os::make_absolute(lib)))\n }\n \n fn get_absolute_rpaths(libs: &[Path]) -> ~[Path] {\n@@ -168,6 +130,7 @@ pub fn get_absolute_rpath(lib: &Path) -> Path {\n     os::make_absolute(lib).dir_path()\n }\n \n+#[cfg(stage0)]\n pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n     let install_prefix = env!(\"CFG_PREFIX\");\n \n@@ -179,6 +142,14 @@ pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n     os::make_absolute(&Path(install_prefix).push_rel(&tlib))\n }\n \n+#[cfg(not(stage0))]\n+pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n+    let install_prefix = env!(\"CFG_PREFIX\");\n+\n+    let tlib = filesearch::relative_target_lib_path(target_triple);\n+    os::make_absolute(&Path(install_prefix).push_rel(&tlib))\n+}\n+\n pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n     let mut set = HashSet::new();\n     let mut minimized = ~[];\n@@ -199,8 +170,7 @@ mod test {\n     #[cfg(test)]\n     #[cfg(test)]\n     use back::rpath::{get_absolute_rpath, get_install_prefix_rpath};\n-    use back::rpath::{get_relative_to, get_rpath_relative_to_output};\n-    use back::rpath::{minimize_rpaths, rpaths_to_flags};\n+    use back::rpath::{minimize_rpaths, rpaths_to_flags, get_rpath_relative_to_output};\n     use driver::session;\n \n     #[test]\n@@ -244,78 +214,9 @@ mod test {\n         assert_eq!(res, ~[Path(\"1a\"), Path(\"2\"), Path(\"4a\"), Path(\"3\")]);\n     }\n \n-    #[test]\n-    fn test_relative_to1() {\n-        let p1 = Path(\"/usr/bin/rustc\");\n-        let p2 = Path(\"/usr/lib/mylib\");\n-        let res = get_relative_to(&p1, &p2);\n-        assert_eq!(res, Path(\"../lib\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to2() {\n-        let p1 = Path(\"/usr/bin/rustc\");\n-        let p2 = Path(\"/usr/bin/../lib/mylib\");\n-        let res = get_relative_to(&p1, &p2);\n-        assert_eq!(res, Path(\"../lib\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to3() {\n-        let p1 = Path(\"/usr/bin/whatever/rustc\");\n-        let p2 = Path(\"/usr/lib/whatever/mylib\");\n-        let res = get_relative_to(&p1, &p2);\n-        assert_eq!(res, Path(\"../../lib/whatever\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to4() {\n-        let p1 = Path(\"/usr/bin/whatever/../rustc\");\n-        let p2 = Path(\"/usr/lib/whatever/mylib\");\n-        let res = get_relative_to(&p1, &p2);\n-        assert_eq!(res, Path(\"../lib/whatever\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to5() {\n-        let p1 = Path(\"/usr/bin/whatever/../rustc\");\n-        let p2 = Path(\"/usr/lib/whatever/../mylib\");\n-        let res = get_relative_to(&p1, &p2);\n-        assert_eq!(res, Path(\"../lib\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to6() {\n-        let p1 = Path(\"/1\");\n-        let p2 = Path(\"/2/3\");\n-        let res = get_relative_to(&p1, &p2);\n-        assert_eq!(res, Path(\"2\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to7() {\n-        let p1 = Path(\"/1/2\");\n-        let p2 = Path(\"/3\");\n-        let res = get_relative_to(&p1, &p2);\n-        assert_eq!(res, Path(\"..\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to8() {\n-        let p1 = Path(\"/home/brian/Dev/rust/build/\").push_rel(\n-            &Path(\"stage2/lib/rustc/i686-unknown-linux-gnu/lib/librustc.so\"));\n-        let p2 = Path(\"/home/brian/Dev/rust/build/stage2/bin/..\").push_rel(\n-            &Path(\"lib/rustc/i686-unknown-linux-gnu/lib/libstd.so\"));\n-        let res = get_relative_to(&p1, &p2);\n-        debug!(\"test_relative_tu8: %s vs. %s\",\n-               res.to_str(),\n-               Path(\".\").to_str());\n-        assert_eq!(res, Path(\".\"));\n-    }\n-\n     #[test]\n     #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"andorid\")]\n+    #[cfg(target_os = \"android\")]\n     fn test_rpath_relative() {\n       let o = session::os_linux;\n       let res = get_rpath_relative_to_output(o,\n@@ -335,7 +236,6 @@ mod test {\n     #[test]\n     #[cfg(target_os = \"macos\")]\n     fn test_rpath_relative() {\n-        // this is why refinements would be nice\n         let o = session::os_macos;\n         let res = get_rpath_relative_to_output(o,\n                                                &Path(\"bin/rustc\"),"}, {"sha": "e349502d143c0b0432104190834e75621dc25d0f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -578,6 +578,7 @@ pub fn build_target_config(sopts: @session::options,\n     return target_cfg;\n }\n \n+#[cfg(stage0)]\n pub fn host_triple() -> ~str {\n     // Get the host triple out of the build environment. This ensures that our\n     // idea of the host triple is the same as for the set of libraries we've\n@@ -595,6 +596,19 @@ pub fn host_triple() -> ~str {\n         };\n }\n \n+#[cfg(not(stage0))]\n+pub fn host_triple() -> ~str {\n+    // Get the host triple out of the build environment. This ensures that our\n+    // idea of the host triple is the same as for the set of libraries we've\n+    // actually built.  We can't just take LLVM's host triple because they\n+    // normalize all ix86 architectures to i386.\n+    //\n+    // Instead of grabbing the host triple (for the current host), we grab (at\n+    // compile time) the target triple that this rustc is built with and\n+    // calling that (at runtime) the host triple.\n+    (env!(\"CFG_COMPILER_TRIPLE\")).to_owned()\n+}\n+\n pub fn build_session_options(binary: @str,\n                              matches: &getopts::Matches,\n                              demitter: diagnostic::Emitter)\n@@ -821,7 +835,8 @@ pub fn optgroups() -> ~[getopts::groups::OptGroup] {\n   optmulti(\"\", \"cfg\", \"Configure the compilation\n                           environment\", \"SPEC\"),\n   optflag(\"\",  \"emit-llvm\",\n-                        \"Produce an LLVM bitcode file\"),\n+                        \"Produce an LLVM assembly file if used with -S option;\n+                         produce an LLVM bitcode file otherwise\"),\n   optflag(\"h\", \"help\",\"Display this message\"),\n   optmulti(\"L\", \"\",   \"Add a directory to the library search path\",\n                               \"PATH\"),"}, {"sha": "2a61ea28e0c6b3452c6118b4faf403e4db10cbc6", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -47,7 +47,7 @@ fn inject_libstd_ref(sess: Session, crate: &ast::Crate) -> @ast::Crate {\n             let n1 = sess.next_node_id();\n             let vi1 = ast::view_item {\n                 node: ast::view_item_extern_mod(\n-                        sess.ident_of(\"std\"), ~[], n1),\n+                        sess.ident_of(\"std\"), None, ~[], n1),\n                 attrs: ~[\n                     attr::mk_attr(\n                         attr::mk_name_value_item_str(@\"vers\", STD_VERSION.to_managed()))"}, {"sha": "c6b1bdbe51ba1299fc7a6dfcc1d01403cd3ab925", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -282,7 +282,7 @@ fn mk_std(cx: &TestCtxt) -> ast::view_item {\n                                             cx.sess.next_node_id()))])\n     } else {\n         let mi = attr::mk_name_value_item_str(@\"vers\", @\"0.8-pre\");\n-        ast::view_item_extern_mod(id_extra, ~[mi], cx.sess.next_node_id())\n+        ast::view_item_extern_mod(id_extra, None, ~[mi], cx.sess.next_node_id())\n     };\n     ast::view_item {\n         node: vi,"}, {"sha": "f2d8b68faa6f3b7a655e5e6637830c5a0bb6e58a", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -185,5 +185,7 @@ pub static tag_item_impl_vtables: uint = 0x82;\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,\n+    // Optional package ID\n+    package_id: Option<@str>, // non-None if this was a URL-like package ID\n     extras_hash: @str\n }"}, {"sha": "0a9e8490f22dcce28a5d3320d9403093b6d8a58e", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -18,6 +18,7 @@ use metadata::loader;\n \n use std::hashmap::HashMap;\n use syntax::ast;\n+use std::vec;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{span, dummy_sp};\n@@ -137,18 +138,33 @@ fn visit_crate(e: &Env, c: &ast::Crate) {\n \n fn visit_view_item(e: @mut Env, i: &ast::view_item) {\n     match i.node {\n-      ast::view_item_extern_mod(ident, ref meta_items, id) => {\n-        debug!(\"resolving extern mod stmt. ident: %?, meta: %?\",\n-               ident, *meta_items);\n-        let cnum = resolve_crate(e,\n-                                 ident,\n-                                 (*meta_items).clone(),\n-                                 @\"\",\n-                                 i.span);\n-        cstore::add_extern_mod_stmt_cnum(e.cstore, id, cnum);\n+      ast::view_item_extern_mod(ident, path_opt, ref meta_items, id) => {\n+          let ident = token::ident_to_str(&ident);\n+          let meta_items = match path_opt {\n+              None => meta_items.clone(),\n+              Some(p) => {\n+                  let p_path = Path(p);\n+                  match p_path.filestem() {\n+                      Some(s) =>\n+                          vec::append(\n+                              ~[attr::mk_name_value_item_str(@\"package_id\", p),\n+                               attr::mk_name_value_item_str(@\"name\", s.to_managed())],\n+                              *meta_items),\n+                      None => e.diag.span_bug(i.span, \"Bad package path in `extern mod` item\")\n+                  }\n+            }\n+          };\n+          debug!(\"resolving extern mod stmt. ident: %?, meta: %?\",\n+                 ident, meta_items);\n+          let cnum = resolve_crate(e,\n+                                   ident,\n+                                   meta_items,\n+                                   @\"\",\n+                                   i.span);\n+          cstore::add_extern_mod_stmt_cnum(e.cstore, id, cnum);\n       }\n       _ => ()\n-    }\n+  }\n }\n \n fn visit_item(e: &Env, i: @ast::item) {\n@@ -233,12 +249,12 @@ fn existing_match(e: &Env, metas: &[@ast::MetaItem], hash: &str)\n }\n \n fn resolve_crate(e: @mut Env,\n-                 ident: ast::ident,\n+                 ident: @str,\n                  metas: ~[@ast::MetaItem],\n                  hash: @str,\n                  span: span)\n               -> ast::CrateNum {\n-    let metas = metas_with_ident(token::ident_to_str(&ident), metas);\n+    let metas = metas_with_ident(ident, metas);\n \n     match existing_match(e, metas, hash) {\n       None => {\n@@ -279,7 +295,7 @@ fn resolve_crate(e: @mut Env,\n             match attr::last_meta_item_value_str_by_name(load_ctxt.metas,\n                                                          \"name\") {\n                 Some(v) => v,\n-                None => token::ident_to_str(&ident),\n+                None => ident\n             };\n         let cmeta = @cstore::crate_metadata {\n             name: cname,\n@@ -308,7 +324,6 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     let r = decoder::get_crate_deps(cdata);\n     for dep in r.iter() {\n         let extrn_cnum = dep.cnum;\n-        let cname = dep.name;\n         let cname_str = token::ident_to_str(&dep.name);\n         let cmetas = metas_with(dep.vers, @\"vers\", ~[]);\n         debug!(\"resolving dep crate %s ver: %s hash: %s\",\n@@ -327,7 +342,7 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span.\n             let fake_span = dummy_sp();\n-            let local_cnum = resolve_crate(e, cname, cmetas, dep.hash,\n+            let local_cnum = resolve_crate(e, cname_str, cmetas, dep.hash,\n                                            fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }"}, {"sha": "81a2e863bde00613392089509de365aaf8774149", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -51,20 +51,20 @@ type cmd = @crate_metadata;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: uint) ->\n+fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: u64) ->\n    Option<ebml::Doc> {\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n-    let hash_pos = table.start + hash % 256u * 4u;\n-    let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4u) as uint;\n+    let hash_pos = table.start + (hash % 256 * 4) as uint;\n+    let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4) as uint;\n     let tagged_doc = reader::doc_at(d.data, pos);\n \n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n     do reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n-        let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n-        if eq_fn(elt.data.slice(elt.start + 4u, elt.end)) {\n+        let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4) as uint;\n+        if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n             ret = Some(reader::doc_at(d.data, pos).doc);\n             false\n         } else {\n@@ -84,7 +84,7 @@ pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     }\n     lookup_hash(items,\n                 |a| eq_item(a, item_id),\n-                item_id.hash() as uint)\n+                (item_id as i64).hash())\n }\n \n fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {"}, {"sha": "c4919e7f263213335ade8a94d45a0030f0a9ae45", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -319,7 +319,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             id: NodeId,\n                             variants: &[variant],\n                             path: &[ast_map::path_elt],\n-                            index: @mut ~[entry<int>],\n+                            index: @mut ~[entry<i64>],\n                             generics: &ast::Generics) {\n     debug!(\"encode_enum_variant_info(id=%?)\", id);\n \n@@ -329,7 +329,8 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                                ast::def_id { crate: LOCAL_CRATE, node: id });\n     for variant in variants.iter() {\n         let def_id = local_def(variant.node.id);\n-        index.push(entry {val: variant.node.id, pos: ebml_w.writer.tell()});\n+        index.push(entry {val: variant.node.id as i64,\n+                          pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'v');\n@@ -677,8 +678,8 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n                           path: &[ast_map::path_elt],\n                           fields: &[@struct_field],\n-                          global_index: @mut ~[entry<int>])\n-                          -> ~[entry<int>] {\n+                          global_index: @mut ~[entry<i64>])\n+                          -> ~[entry<i64>] {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n     let mut index = ~[];\n@@ -692,8 +693,8 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         };\n \n         let id = field.node.id;\n-        index.push(entry {val: id, pos: ebml_w.writer.tell()});\n-        global_index.push(entry {val: id, pos: ebml_w.writer.tell()});\n+        index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n+        global_index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing %s %d\",\n                tcx.sess.str_of(nm), id);\n@@ -712,8 +713,8 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                path: &[ast_map::path_elt],\n                                name: ast::ident,\n                                ctor_id: NodeId,\n-                               index: @mut ~[entry<int>]) {\n-    index.push(entry { val: ctor_id, pos: ebml_w.writer.tell() });\n+                               index: @mut ~[entry<i64>]) {\n+    index.push(entry { val: ctor_id as i64, pos: ebml_w.writer.tell() });\n \n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(ctor_id));\n@@ -815,13 +816,13 @@ fn should_inline(attrs: &[Attribute]) -> bool {\n fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         item: @item,\n-                        index: @mut ~[entry<int>],\n+                        index: @mut ~[entry<i64>],\n                         path: &[ast_map::path_elt]) {\n     let tcx = ecx.tcx;\n \n     fn add_to_index_(item: @item, ebml_w: &writer::Encoder,\n-                     index: @mut ~[entry<int>]) {\n-        index.push(entry { val: item.id, pos: ebml_w.writer.tell() });\n+                     index: @mut ~[entry<i64>]) {\n+        index.push(entry { val: item.id as i64, pos: ebml_w.writer.tell() });\n     }\n     let add_to_index: &fn() = || add_to_index_(item, ebml_w, index);\n \n@@ -969,7 +970,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         /* Each class has its own index -- encode it */\n         let bkts = create_index(idx);\n-        encode_index(ebml_w, bkts, write_int);\n+        encode_index(ebml_w, bkts, write_i64);\n         ebml_w.end_tag();\n \n         // If this is a tuple- or enum-like struct, encode the type of the\n@@ -1040,7 +1041,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 Some(ast_methods[i])\n             } else { None };\n \n-            index.push(entry {val: m.def_id.node, pos: ebml_w.writer.tell()});\n+            index.push(entry {val: m.def_id.node as i64,\n+                              pos: ebml_w.writer.tell()});\n             encode_info_for_method(ecx,\n                                    ebml_w,\n                                    *m,\n@@ -1086,7 +1088,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             let method_ty = ty::method(tcx, method_def_id);\n \n-            index.push(entry {val: method_def_id.node, pos: ebml_w.writer.tell()});\n+            index.push(entry {val: method_def_id.node as i64,\n+                              pos: ebml_w.writer.tell()});\n \n             ebml_w.start_tag(tag_items_data_item);\n \n@@ -1145,10 +1148,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 ebml_w: &mut writer::Encoder,\n                                 nitem: @foreign_item,\n-                                index: @mut ~[entry<int>],\n+                                index: @mut ~[entry<i64>],\n                                 path: &ast_map::path,\n                                 abi: AbiSet) {\n-    index.push(entry { val: nitem.id, pos: ebml_w.writer.tell() });\n+    index.push(entry { val: nitem.id as i64, pos: ebml_w.writer.tell() });\n \n     ebml_w.start_tag(tag_items_data_item);\n     match nitem.node {\n@@ -1184,10 +1187,10 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n fn encode_info_for_items(ecx: &EncodeContext,\n                          ebml_w: &mut writer::Encoder,\n                          crate: &Crate)\n-                         -> ~[entry<int>] {\n+                         -> ~[entry<i64>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n-    index.push(entry { val: CRATE_NODE_ID, pos: ebml_w.writer.tell() });\n+    index.push(entry { val: CRATE_NODE_ID as i64, pos: ebml_w.writer.tell() });\n     encode_info_for_mod(ecx,\n                         ebml_w,\n                         &crate.module,\n@@ -1304,7 +1307,7 @@ fn write_str(writer: @io::Writer, s: ~str) {\n     writer.write_str(s);\n }\n \n-fn write_int(writer: @io::Writer, &n: &int) {\n+fn write_i64(writer: @io::Writer, &n: &i64) {\n     assert!(n < 0x7fff_ffff);\n     writer.write_be_u32(n as u32);\n }\n@@ -1623,7 +1626,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n \n     i = *wr.pos;\n     let items_buckets = create_index(items_index);\n-    encode_index(&mut ebml_w, items_buckets, write_int);\n+    encode_index(&mut ebml_w, items_buckets, write_i64);\n     ecx.stats.index_bytes = *wr.pos - i;\n     ebml_w.end_tag();\n "}, {"sha": "2b44d793a9d381ac12904954de04845412fe03ba", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 86, "deletions": 65, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,12 +11,15 @@\n \n use std::option;\n use std::os;\n-use std::result;\n+use std::{result, str};\n+use std::hashmap::HashSet;\n \n // A module for searching for libraries\n // FIXME (#2658): I'm not happy how this module turned out. Should\n // probably just be folded into cstore.\n \n+/// Functions with type `pick` take a parent directory as well as\n+/// a file found in that directory.\n pub type pick<'self, T> = &'self fn(path: &Path) -> Option<T>;\n \n pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n@@ -46,28 +49,33 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n     impl FileSearch for FileSearchImpl {\n         fn sysroot(&self) -> @Path { self.sysroot }\n         fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) -> bool {\n+            let mut visited_dirs = HashSet::new();\n+\n             debug!(\"filesearch: searching additional lib search paths [%?]\",\n                    self.addl_lib_search_paths.len());\n-            // a little weird\n-            self.addl_lib_search_paths.iter().advance(|path| f(path));\n+            for path in self.addl_lib_search_paths.iter() {\n+                f(path);\n+                visited_dirs.insert(path.to_str());\n+            }\n \n             debug!(\"filesearch: searching target lib path\");\n-            if !f(&make_target_lib_path(self.sysroot,\n-                                        self.target_triple)) {\n-                return false;\n-            }\n-            debug!(\"filesearch: searching rustpkg lib path nearest\");\n-            if match get_rustpkg_lib_path_nearest() {\n-                    result::Ok(ref p) => f(p),\n-                    result::Err(_) => true\n-                } {\n-                    return true;\n+            let tlib_path = make_target_lib_path(self.sysroot,\n+                                        self.target_triple);\n+            if !visited_dirs.contains(&tlib_path.to_str()) {\n+                if !f(&tlib_path) {\n+                    return false;\n                 }\n-           debug!(\"filesearch: searching rustpkg lib path\");\n-           match get_rustpkg_lib_path() {\n-              result::Ok(ref p) => f(p),\n-              result::Err(_) => true\n-           }\n+            }\n+            visited_dirs.insert(tlib_path.to_str());\n+            // Try RUST_PATH\n+            let rustpath = rust_path();\n+            for path in rustpath.iter() {\n+                    if !visited_dirs.contains(&path.push(\"lib\").to_str()) {\n+                        f(&path.push(\"lib\"));\n+                        visited_dirs.insert(path.push(\"lib\").to_str());\n+                    }\n+            }\n+            true\n         }\n         fn get_target_lib_path(&self) -> Path {\n             make_target_lib_path(self.sysroot, self.target_triple)\n@@ -94,12 +102,15 @@ pub fn search<T>(filesearch: @FileSearch, pick: pick<T>) -> Option<T> {\n         for path in r.iter() {\n             debug!(\"testing %s\", path.to_str());\n             let maybe_picked = pick(path);\n-            if maybe_picked.is_some() {\n-                debug!(\"picked %s\", path.to_str());\n-                rslt = maybe_picked;\n-                break;\n-            } else {\n-                debug!(\"rejected %s\", path.to_str());\n+            match maybe_picked {\n+                Some(_) => {\n+                    debug!(\"picked %s\", path.to_str());\n+                    rslt = maybe_picked;\n+                    break;\n+                }\n+                None => {\n+                    debug!(\"rejected %s\", path.to_str());\n+                }\n             }\n         }\n         rslt.is_none()\n@@ -132,64 +143,74 @@ fn get_sysroot(maybe_sysroot: &Option<@Path>) -> @Path {\n     }\n }\n \n-pub fn get_rustpkg_sysroot() -> Result<Path, ~str> {\n-    result::Ok(get_or_default_sysroot().push_many([libdir(), ~\"rustpkg\"]))\n+#[cfg(windows)]\n+static PATH_ENTRY_SEPARATOR: &'static str = \";\";\n+#[cfg(not(windows))]\n+static PATH_ENTRY_SEPARATOR: &'static str = \":\";\n+\n+/// Returns RUST_PATH as a string, without default paths added\n+pub fn get_rust_path() -> Option<~str> {\n+    os::getenv(\"RUST_PATH\")\n }\n \n-pub fn get_rustpkg_root() -> Result<Path, ~str> {\n-    match os::getenv(\"RUSTPKG_ROOT\") {\n-        Some(ref _p) => result::Ok(Path((*_p))),\n-        None => match os::homedir() {\n-          Some(ref _q) => result::Ok((*_q).push(\".rustpkg\")),\n-          None => result::Err(~\"no RUSTPKG_ROOT or home directory\")\n+/// Returns the value of RUST_PATH, as a list\n+/// of Paths. Includes default entries for, if they exist:\n+/// $HOME/.rust\n+/// DIR/.rust for any DIR that's the current working directory\n+/// or an ancestor of it\n+pub fn rust_path() -> ~[Path] {\n+    let mut env_rust_path: ~[Path] = match get_rust_path() {\n+        Some(env_path) => {\n+            let env_path_components: ~[&str] =\n+                env_path.split_str_iter(PATH_ENTRY_SEPARATOR).collect();\n+            env_path_components.map(|&s| Path(s))\n         }\n+        None => ~[]\n+    };\n+    let cwd = os::getcwd();\n+    // now add in default entries\n+    let cwd_dot_rust = cwd.push(\".rust\");\n+    if !env_rust_path.contains(&cwd_dot_rust) {\n+        env_rust_path.push(cwd_dot_rust);\n     }\n-}\n-\n-pub fn get_rustpkg_root_nearest() -> Result<Path, ~str> {\n-    do get_rustpkg_root().chain |p| {\n-        let cwd = os::getcwd();\n-        let cwd_rustpkg = cwd.push(\".rustpkg\");\n-        let rustpkg_is_non_root_file =\n-            !os::path_is_dir(&cwd_rustpkg) && cwd_rustpkg != p;\n-        let mut par_rustpkg = cwd.pop().push(\".rustpkg\");\n-        let mut rslt = result::Ok(cwd_rustpkg);\n-\n-        if rustpkg_is_non_root_file {\n-            while par_rustpkg != p {\n-                if os::path_is_dir(&par_rustpkg) {\n-                    rslt = result::Ok(par_rustpkg);\n-                    break;\n-                }\n-                if par_rustpkg.components.len() == 1 {\n-                    // We just checked /.rustpkg, stop now.\n-                    break;\n-                }\n-                par_rustpkg = par_rustpkg.pop().pop().push(\".rustpkg\");\n-            }\n+    if !env_rust_path.contains(&cwd) {\n+        env_rust_path.push(cwd.clone());\n+    }\n+    do cwd.each_parent() |p| {\n+        if !env_rust_path.contains(&p.push(\".rust\")) {\n+            push_if_exists(&mut env_rust_path, p);\n         }\n-        rslt\n     }\n-}\n-\n-fn get_rustpkg_lib_path() -> Result<Path, ~str> {\n-    do get_rustpkg_root().chain |p| {\n-        result::Ok(p.push(libdir()))\n+    let h = os::homedir();\n+    for h in h.iter() {\n+        if !env_rust_path.contains(&h.push(\".rust\")) {\n+            push_if_exists(&mut env_rust_path, h);\n+        }\n     }\n+    env_rust_path\n }\n \n-fn get_rustpkg_lib_path_nearest() -> Result<Path, ~str> {\n-    do get_rustpkg_root_nearest().chain |p| {\n-        result::Ok(p.push(libdir()))\n+\n+/// Adds p/.rust into vec, only if it exists\n+fn push_if_exists(vec: &mut ~[Path], p: &Path) {\n+    let maybe_dir = p.push(\".rust\");\n+    if os::path_exists(&maybe_dir) {\n+        vec.push(maybe_dir);\n     }\n }\n \n // The name of the directory rustc expects libraries to be located.\n // On Unix should be \"lib\", on windows \"bin\"\n+#[cfg(stage0)]\n pub fn libdir() -> ~str {\n    let libdir = env!(\"CFG_LIBDIR\");\n    if libdir.is_empty() {\n       fail!(\"rustc compiled without CFG_LIBDIR environment variable\");\n    }\n    libdir.to_owned()\n }\n+\n+#[cfg(not(stage0))]\n+pub fn libdir() -> ~str {\n+    (env!(\"CFG_LIBDIR\")).to_owned()\n+}"}, {"sha": "704a22ec979252c2f27f1746d5cbaf240339bff1", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 45, "deletions": 33, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -18,7 +18,6 @@ use metadata::filesearch::FileSearch;\n use metadata::filesearch;\n use syntax::codemap::span;\n use syntax::diagnostic::span_handler;\n-use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::print::pprust;\n use syntax::{ast, attr};\n@@ -47,7 +46,7 @@ pub struct Context {\n     diag: @span_handler,\n     filesearch: @FileSearch,\n     span: span,\n-    ident: ast::ident,\n+    ident: @str,\n     metas: ~[@ast::MetaItem],\n     hash: @str,\n     os: os,\n@@ -61,7 +60,7 @@ pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n       None => {\n         cx.diag.span_fatal(cx.span,\n                            fmt!(\"can't find crate for `%s`\",\n-                                token::ident_to_str(&cx.ident)));\n+                                cx.ident));\n       }\n     }\n }\n@@ -90,37 +89,38 @@ fn find_library_crate_aux(\n     filesearch: @filesearch::FileSearch\n ) -> Option<(~str, @~[u8])> {\n     let crate_name = crate_name_from_metas(cx.metas);\n-    let prefix = prefix + crate_name + \"-\";\n-\n+    // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n+    let prefix = fmt!(\"%s%s-\", prefix, crate_name);\n     let mut matches = ~[];\n     filesearch::search(filesearch, |path| -> Option<()> {\n-        debug!(\"inspecting file %s\", path.to_str());\n-        match path.filename() {\n-            Some(ref f) if f.starts_with(prefix) && f.ends_with(suffix) => {\n-                debug!(\"%s is a candidate\", path.to_str());\n-                match get_metadata_section(cx.os, path) {\n-                    Some(cvec) =>\n-                        if !crate_matches(cvec, cx.metas, cx.hash) {\n-                            debug!(\"skipping %s, metadata doesn't match\",\n-                                   path.to_str());\n-                            None\n-                        } else {\n-                            debug!(\"found %s with matching metadata\", path.to_str());\n-                            matches.push((path.to_str(), cvec));\n-                            None\n-                        },\n-                    _ => {\n-                        debug!(\"could not load metadata for %s\", path.to_str());\n-                        None\n-                    }\n-                }\n-            }\n-            _ => {\n-                debug!(\"skipping %s, doesn't look like %s*%s\", path.to_str(),\n-                       prefix, suffix);\n-                None\n-            }\n-        }});\n+      let path_str = path.filename();\n+      match path_str {\n+          None => None,\n+          Some(path_str) =>\n+              if path_str.starts_with(prefix) && path_str.ends_with(suffix) {\n+                  debug!(\"%s is a candidate\", path.to_str());\n+                  match get_metadata_section(cx.os, path) {\n+                      Some(cvec) =>\n+                          if !crate_matches(cvec, cx.metas, cx.hash) {\n+                              debug!(\"skipping %s, metadata doesn't match\",\n+                                  path.to_str());\n+                              None\n+                          } else {\n+                              debug!(\"found %s with matching metadata\", path.to_str());\n+                              matches.push((path.to_str(), cvec));\n+                              None\n+                          },\n+                      _ => {\n+                          debug!(\"could not load metadata for %s\", path.to_str());\n+                          None\n+                      }\n+                  }\n+               }\n+               else {\n+                   None\n+               }\n+      }\n+    });\n \n     match matches.len() {\n         0 => None,\n@@ -138,8 +138,8 @@ fn find_library_crate_aux(\n                 }\n                 cx.diag.handler().abort_if_errors();\n                 None\n-            }\n         }\n+    }\n }\n \n pub fn crate_name_from_metas(metas: &[@ast::MetaItem]) -> @str {\n@@ -152,6 +152,16 @@ pub fn crate_name_from_metas(metas: &[@ast::MetaItem]) -> @str {\n     fail!(\"expected to find the crate name\")\n }\n \n+pub fn package_id_from_metas(metas: &[@ast::MetaItem]) -> Option<@str> {\n+    for m in metas.iter() {\n+        match m.name_str_pair() {\n+            Some((name, s)) if \"package_id\" == name => { return Some(s); }\n+            _ => {}\n+        }\n+    }\n+    None\n+}\n+\n pub fn note_linkage_attrs(intr: @ident_interner,\n                           diag: @span_handler,\n                           attrs: ~[ast::Attribute]) {\n@@ -176,6 +186,8 @@ fn crate_matches(crate_data: @~[u8],\n pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n                         local_metas: &[@ast::MetaItem]) -> bool {\n \n+// extern_metas: metas we read from the crate\n+// local_metas: metas we're looking for\n     debug!(\"matching %u metadata requirements against %u items\",\n            local_metas.len(), extern_metas.len());\n "}, {"sha": "7d892d976769f56179a59af7cc6d49c55e3be6ee", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -1487,9 +1487,10 @@ impl Resolver {\n                 }\n             }\n \n-            view_item_extern_mod(name, _, node_id) => {\n+            view_item_extern_mod(name, _, _, node_id) => {\n+                // n.b. we don't need to look at the path option here, because cstore already did\n                 match find_extern_mod_stmt_cnum(self.session.cstore,\n-                                                node_id) {\n+                                                        node_id) {\n                     Some(crate_id) => {\n                         let def_id = def_id { crate: crate_id, node: 0 };\n                         let parent_link = ModuleParentLink\n@@ -4994,7 +4995,9 @@ impl Resolver {\n                             if self.structs.contains(&class_id) => {\n                         self.record_def(expr.id, definition);\n                     }\n-                    _ => {\n+                    result => {\n+                        debug!(\"(resolving expression) didn't find struct \\\n+                                def: %?\", result);\n                         self.session.span_err(\n                             path.span,\n                             fmt!(\"`%s` does not name a structure\","}, {"sha": "327d2e698c1e181915f6bcc41a555479ca967694", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 77, "deletions": 62, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -183,23 +183,23 @@ use syntax::codemap::{span, dummy_sp};\n \n // An option identifying a literal: either a unit-like struct or an\n // expression.\n-pub enum Lit {\n+enum Lit {\n     UnitLikeStructLit(ast::NodeId),    // the node ID of the pattern\n     ExprLit(@ast::expr),\n     ConstLit(ast::def_id),              // the def ID of the constant\n }\n \n // An option identifying a branch (either a literal, a enum variant or a\n // range)\n-pub enum Opt {\n+enum Opt {\n     lit(Lit),\n     var(/* disr val */ uint, @adt::Repr),\n     range(@ast::expr, @ast::expr),\n     vec_len_eq(uint),\n     vec_len_ge(uint, /* slice */uint)\n }\n \n-pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n+fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     match (a, b) {\n         (&lit(a), &lit(b)) => {\n             match (a, b) {\n@@ -258,7 +258,7 @@ pub enum opt_result {\n     lower_bound(Result),\n     range_result(Result, Result),\n }\n-pub fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n+fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n     let _icx = push_ctxt(\"match::trans_opt\");\n     let ccx = bcx.ccx();\n     let bcx = bcx;\n@@ -292,7 +292,7 @@ pub fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n     }\n }\n \n-pub fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n+fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n     -> Opt {\n     let ccx = bcx.ccx();\n     match ccx.tcx.def_map.get_copy(&pat_id) {\n@@ -317,7 +317,7 @@ pub fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n }\n \n #[deriving(Clone)]\n-pub enum TransBindingMode {\n+enum TransBindingMode {\n     TrByValue(/*llbinding:*/ ValueRef),\n     TrByRef,\n }\n@@ -331,24 +331,24 @@ pub enum TransBindingMode {\n  * - `id` is the node id of the binding\n  * - `ty` is the Rust type of the binding */\n  #[deriving(Clone)]\n-pub struct BindingInfo {\n+struct BindingInfo {\n     llmatch: ValueRef,\n     trmode: TransBindingMode,\n     id: ast::NodeId,\n     ty: ty::t,\n }\n \n-pub type BindingsMap = HashMap<ident, BindingInfo>;\n+type BindingsMap = HashMap<ident, BindingInfo>;\n \n #[deriving(Clone)]\n-pub struct ArmData<'self> {\n+struct ArmData<'self> {\n     bodycx: @mut Block,\n     arm: &'self ast::arm,\n     bindings_map: @BindingsMap\n }\n \n #[deriving(Clone)]\n-pub struct Match<'self> {\n+struct Match<'self> {\n     pats: ~[@ast::pat],\n     data: ArmData<'self>\n }\n@@ -364,7 +364,7 @@ impl<'self> Repr for Match<'self> {\n     }\n }\n \n-pub fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n+fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     for br in m.iter() {\n         match br.pats[col].node {\n           ast::pat_ident(_, _, Some(_)) => return true,\n@@ -374,7 +374,7 @@ pub fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     return false;\n }\n \n-pub fn expand_nested_bindings<'r>(bcx: @mut Block,\n+fn expand_nested_bindings<'r>(bcx: @mut Block,\n                                   m: &[Match<'r>],\n                                   col: uint,\n                                   val: ValueRef)\n@@ -409,7 +409,7 @@ pub fn expand_nested_bindings<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::pat) {\n+fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::pat) {\n     if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n         bcx.sess().span_bug(\n             p.span,\n@@ -418,9 +418,9 @@ pub fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::pat) {\n     }\n }\n \n-pub type enter_pat<'self> = &'self fn(@ast::pat) -> Option<~[@ast::pat]>;\n+type enter_pat<'self> = &'self fn(@ast::pat) -> Option<~[@ast::pat]>;\n \n-pub fn enter_match<'r>(bcx: @mut Block,\n+fn enter_match<'r>(bcx: @mut Block,\n                        dm: DefMap,\n                        m: &[Match<'r>],\n                        col: uint,\n@@ -470,7 +470,7 @@ pub fn enter_match<'r>(bcx: @mut Block,\n     return result;\n }\n \n-pub fn enter_default<'r>(bcx: @mut Block,\n+fn enter_default<'r>(bcx: @mut Block,\n                          dm: DefMap,\n                          m: &[Match<'r>],\n                          col: uint,\n@@ -485,7 +485,7 @@ pub fn enter_default<'r>(bcx: @mut Block,\n \n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_wild | ast::pat_tup(_) | ast::pat_struct(*) => Some(~[]),\n+          ast::pat_wild | ast::pat_tup(_) => Some(~[]),\n           ast::pat_ident(_, _, None) if pat_is_binding(dm, p) => Some(~[]),\n           _ => None\n         }\n@@ -516,7 +516,7 @@ pub fn enter_default<'r>(bcx: @mut Block,\n // <nmatsakis> so all patterns must either be records (resp. tuples) or\n //             wildcards\n \n-pub fn enter_opt<'r>(bcx: @mut Block,\n+fn enter_opt<'r>(bcx: @mut Block,\n                      m: &[Match<'r>],\n                      opt: &Opt,\n                      col: uint,\n@@ -628,7 +628,7 @@ pub fn enter_opt<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_rec_or_struct<'r>(bcx: @mut Block,\n+fn enter_rec_or_struct<'r>(bcx: @mut Block,\n                                dm: DefMap,\n                                m: &[Match<'r>],\n                                col: uint,\n@@ -663,7 +663,7 @@ pub fn enter_rec_or_struct<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_tup<'r>(bcx: @mut Block,\n+fn enter_tup<'r>(bcx: @mut Block,\n                      dm: DefMap,\n                      m: &[Match<'r>],\n                      col: uint,\n@@ -689,7 +689,7 @@ pub fn enter_tup<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_tuple_struct<'r>(bcx: @mut Block,\n+fn enter_tuple_struct<'r>(bcx: @mut Block,\n                               dm: DefMap,\n                               m: &[Match<'r>],\n                               col: uint,\n@@ -715,7 +715,7 @@ pub fn enter_tuple_struct<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_box<'r>(bcx: @mut Block,\n+fn enter_box<'r>(bcx: @mut Block,\n                      dm: DefMap,\n                      m: &[Match<'r>],\n                      col: uint,\n@@ -742,7 +742,7 @@ pub fn enter_box<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_uniq<'r>(bcx: @mut Block,\n+fn enter_uniq<'r>(bcx: @mut Block,\n                       dm: DefMap,\n                       m: &[Match<'r>],\n                       col: uint,\n@@ -769,7 +769,7 @@ pub fn enter_uniq<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_region<'r>(bcx: @mut Block,\n+fn enter_region<'r>(bcx: @mut Block,\n                         dm: DefMap,\n                         m: &[Match<'r>],\n                         col: uint,\n@@ -799,7 +799,7 @@ pub fn enter_region<'r>(bcx: @mut Block,\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-pub fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n+fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n     fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n@@ -865,12 +865,12 @@ pub fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n     return found;\n }\n \n-pub struct ExtractedBlock {\n+struct ExtractedBlock {\n     vals: ~[ValueRef],\n     bcx: @mut Block\n }\n \n-pub fn extract_variant_args(bcx: @mut Block,\n+fn extract_variant_args(bcx: @mut Block,\n                             repr: &adt::Repr,\n                             disr_val: uint,\n                             val: ValueRef)\n@@ -893,7 +893,7 @@ fn match_datum(bcx: @mut Block, val: ValueRef, pat_id: ast::NodeId) -> Datum {\n }\n \n \n-pub fn extract_vec_elems(bcx: @mut Block,\n+fn extract_vec_elems(bcx: @mut Block,\n                          pat_span: span,\n                          pat_id: ast::NodeId,\n                          elem_count: uint,\n@@ -947,24 +947,37 @@ pub fn extract_vec_elems(bcx: @mut Block,\n     ExtractedBlock { vals: elems, bcx: bcx }\n }\n \n-// NB: This function does not collect fields from struct-like enum variants.\n-pub fn collect_record_or_struct_fields(bcx: @mut Block,\n+/// Checks every pattern in `m` at `col` column.\n+/// If there are a struct pattern among them function\n+/// returns list of all fields that are matched in these patterns.\n+/// Function returns None if there is no struct pattern.\n+/// Function doesn't collect fields from struct-like enum variants.\n+/// Function can return empty list if there is only wildcard struct pattern.\n+fn collect_record_or_struct_fields(bcx: @mut Block,\n                                        m: &[Match],\n                                        col: uint)\n-                                    -> ~[ast::ident] {\n+                                    -> Option<~[ast::ident]> {\n     let mut fields: ~[ast::ident] = ~[];\n+    let mut found = false;\n     for br in m.iter() {\n         match br.pats[col].node {\n           ast::pat_struct(_, ref fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n-              ty::ty_struct(*) => extend(&mut fields, *fs),\n+              ty::ty_struct(*) => {\n+                   extend(&mut fields, *fs);\n+                   found = true;\n+              }\n               _ => ()\n             }\n           }\n           _ => ()\n         }\n     }\n-    return fields;\n+    if found {\n+        return Some(fields);\n+    } else {\n+        return None;\n+    }\n \n     fn extend(idents: &mut ~[ast::ident], field_pats: &[ast::field_pat]) {\n         for field_pat in field_pats.iter() {\n@@ -976,7 +989,7 @@ pub fn collect_record_or_struct_fields(bcx: @mut Block,\n     }\n }\n \n-pub fn pats_require_rooting(bcx: @mut Block,\n+fn pats_require_rooting(bcx: @mut Block,\n                             m: &[Match],\n                             col: uint)\n                          -> bool {\n@@ -987,7 +1000,7 @@ pub fn pats_require_rooting(bcx: @mut Block,\n     }\n }\n \n-pub fn root_pats_as_necessary(mut bcx: @mut Block,\n+fn root_pats_as_necessary(mut bcx: @mut Block,\n                               m: &[Match],\n                               col: uint,\n                               val: ValueRef)\n@@ -1018,23 +1031,23 @@ macro_rules! any_pat (\n     )\n )\n \n-pub fn any_box_pat(m: &[Match], col: uint) -> bool {\n+fn any_box_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_box(_))\n }\n \n-pub fn any_uniq_pat(m: &[Match], col: uint) -> bool {\n+fn any_uniq_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_uniq(_))\n }\n \n-pub fn any_region_pat(m: &[Match], col: uint) -> bool {\n+fn any_region_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_region(_))\n }\n \n-pub fn any_tup_pat(m: &[Match], col: uint) -> bool {\n+fn any_tup_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_tup(_))\n }\n \n-pub fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n+fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n     do m.iter().any |br| {\n         let pat = br.pats[col];\n         match pat.node {\n@@ -1050,9 +1063,9 @@ pub fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n     }\n }\n \n-pub type mk_fail = @fn() -> BasicBlockRef;\n+type mk_fail = @fn() -> BasicBlockRef;\n \n-pub fn pick_col(m: &[Match]) -> uint {\n+fn pick_col(m: &[Match]) -> uint {\n     fn score(p: &ast::pat) -> uint {\n         match p.node {\n           ast::pat_lit(_) | ast::pat_enum(_, _) | ast::pat_range(_, _) => 1u,\n@@ -1088,7 +1101,7 @@ pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n // Compiles a comparison between two things.\n //\n // NB: This must produce an i1, not a Rust bool (i8).\n-pub fn compare_values(cx: @mut Block,\n+fn compare_values(cx: @mut Block,\n                       lhs: ValueRef,\n                       rhs: ValueRef,\n                       rhs_t: ty::t)\n@@ -1204,7 +1217,7 @@ fn insert_lllocals(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn compile_guard(bcx: @mut Block,\n+fn compile_guard(bcx: @mut Block,\n                      guard_expr: @ast::expr,\n                      data: &ArmData,\n                      m: &[Match],\n@@ -1261,7 +1274,7 @@ pub fn compile_guard(bcx: @mut Block,\n     }\n }\n \n-pub fn compile_submatch(bcx: @mut Block,\n+fn compile_submatch(bcx: @mut Block,\n                         m: &[Match],\n                         vals: &[ValueRef],\n                         chk: Option<mk_fail>) {\n@@ -1336,22 +1349,24 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n     // required to root any values.\n     assert!(any_box_pat(m, col) || !pats_require_rooting(bcx, m, col));\n \n-    let rec_fields = collect_record_or_struct_fields(bcx, m, col);\n-    if rec_fields.len() > 0 {\n-        let pat_ty = node_id_type(bcx, pat_id);\n-        let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n-        do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n-            let rec_vals = rec_fields.map(|field_name| {\n-                let ix = ty::field_idx_strict(tcx, *field_name, field_tys);\n-                adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n-            });\n-            compile_submatch(\n-                bcx,\n-                enter_rec_or_struct(bcx, dm, m, col, rec_fields, val),\n-                vec::append(rec_vals, vals_left),\n-                chk);\n+    match collect_record_or_struct_fields(bcx, m, col) {\n+        Some(ref rec_fields) => {\n+            let pat_ty = node_id_type(bcx, pat_id);\n+            let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n+            do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n+                let rec_vals = rec_fields.map(|field_name| {\n+                        let ix = ty::field_idx_strict(tcx, *field_name, field_tys);\n+                        adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n+                        });\n+                compile_submatch(\n+                        bcx,\n+                        enter_rec_or_struct(bcx, dm, m, col, *rec_fields, val),\n+                        vec::append(rec_vals, vals_left),\n+                        chk);\n+            }\n+            return;\n         }\n-        return;\n+        None => {}\n     }\n \n     if any_tup_pat(m, col) {\n@@ -1670,7 +1685,7 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::pat) -> BindingsMap {\n     return bindings_map;\n }\n \n-pub fn trans_match_inner(scope_cx: @mut Block,\n+fn trans_match_inner(scope_cx: @mut Block,\n                          discr_expr: @ast::expr,\n                          arms: &[ast::arm],\n                          dest: Dest) -> @mut Block {\n@@ -1752,7 +1767,7 @@ pub fn trans_match_inner(scope_cx: @mut Block,\n     }\n }\n \n-pub enum IrrefutablePatternBindingMode {\n+enum IrrefutablePatternBindingMode {\n     // Stores the association between node ID and LLVM value in `lllocals`.\n     BindLocal,\n     // Stores the association between node ID and LLVM value in `llargs`."}, {"sha": "369045500ad9bad0950e2bd6681abfc742e9bf7d", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -117,6 +117,7 @@ mod std {\n }\n */\n \n+#[cfg(stage0)]\n pub fn version(argv0: &str) {\n     let mut vers = ~\"unknown version\";\n     let env_vers = env!(\"CFG_VERSION\");\n@@ -125,6 +126,16 @@ pub fn version(argv0: &str) {\n     printfln!(\"host: %s\", host_triple());\n }\n \n+#[cfg(not(stage0))]\n+pub fn version(argv0: &str) {\n+    let vers = match option_env!(\"CFG_VERSION\") {\n+        Some(vers) => vers,\n+        None => \"unknown version\"\n+    };\n+    printfln!(\"%s %s\", argv0, vers);\n+    printfln!(\"host: %s\", host_triple());\n+}\n+\n pub fn usage(argv0: &str) {\n     let message = fmt!(\"Usage: %s [OPTIONS] INPUT\", argv0);\n     printfln!(\"%s\\"}, {"sha": "2da66baa412b57914b7d27e535ffac99d36505dd", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -23,33 +23,30 @@ fn default_ctxt(p: @Path) -> Ctx {\n     Ctx { sysroot_opt: Some(p), json: false, dep_cache: @mut HashMap::new() }\n }\n \n-pub fn build_lib(sysroot: @Path, root: Path, dest: Path, name: ~str, version: Version,\n+pub fn build_lib(sysroot: @Path, root: Path, name: ~str, version: Version,\n                  lib: Path) {\n \n     let pkg_src = PkgSrc {\n         root: root,\n-        dst_dir: dest.clone(),\n-        id: PkgId{ version: version, ..PkgId::new(name, &dest.pop())},\n+        id: PkgId{ version: version, ..PkgId::new(name)},\n         libs: ~[mk_crate(lib)],\n         mains: ~[],\n         tests: ~[],\n         benchs: ~[]\n     };\n-    pkg_src.build(&default_ctxt(sysroot), pkg_src.dst_dir, ~[]);\n+    pkg_src.build(&default_ctxt(sysroot), ~[]);\n }\n \n-pub fn build_exe(sysroot: @Path, root: Path, dest: Path, name: ~str, version: Version,\n-                 main: Path) {\n+pub fn build_exe(sysroot: @Path, root: Path, name: ~str, version: Version, main: Path) {\n     let pkg_src = PkgSrc {\n         root: root,\n-        dst_dir: dest.clone(),\n-        id: PkgId{ version: version, ..PkgId::new(name, &dest.pop())},\n+        id: PkgId{ version: version, ..PkgId::new(name)},\n         libs: ~[],\n         mains: ~[mk_crate(main)],\n         tests: ~[],\n         benchs: ~[]\n     };\n-    pkg_src.build(&default_ctxt(sysroot), pkg_src.dst_dir, ~[]);\n+    pkg_src.build(&default_ctxt(sysroot), ~[]);\n \n }\n \n@@ -62,26 +59,23 @@ pub fn install_lib(sysroot: @Path,\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     debug!(\"workspace = %s\", workspace.to_str());\n     // make a PkgSrc\n-    let pkg_id = PkgId{ version: version, ..PkgId::new(name, &workspace)};\n-    let build_dir = workspace.push(\"build\");\n-    let dst_dir = build_dir.push_rel(&*pkg_id.local_path);\n+    let pkg_id = PkgId{ version: version, ..PkgId::new(name)};\n     let pkg_src = PkgSrc {\n         root: workspace.clone(),\n-        dst_dir: dst_dir.clone(),\n         id: pkg_id.clone(),\n         libs: ~[mk_crate(lib_path)],\n         mains: ~[],\n         tests: ~[],\n         benchs: ~[]\n     };\n     let cx = default_ctxt(sysroot);\n-    pkg_src.build(&cx, dst_dir, ~[]);\n+    pkg_src.build(&cx, ~[]);\n     cx.install_no_build(&workspace, &pkg_id);\n }\n \n pub fn install_exe(sysroot: @Path, workspace: Path, name: ~str, version: Version) {\n     default_ctxt(sysroot).install(&workspace, &PkgId{ version: version,\n-                                            ..PkgId::new(name, &workspace)});\n+                                            ..PkgId::new(name)});\n \n }\n "}, {"sha": "f051be25f266da111c12f204e41b992200fc0c2e", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -12,6 +12,7 @@\n \n \n use std::hashmap::HashMap;\n+use std::os;\n \n pub struct Ctx {\n     // Sysroot -- if this is None, uses rustc filesearch's\n@@ -23,3 +24,26 @@ pub struct Ctx {\n     // though I'm not sure why the value is a bool\n     dep_cache: @mut HashMap<~str, bool>,\n }\n+\n+impl Ctx {\n+    /// Debugging\n+    pub fn sysroot_opt_str(&self) -> ~str {\n+        match self.sysroot_opt {\n+            None => ~\"[none]\",\n+            Some(p) => p.to_str()\n+        }\n+    }\n+}\n+\n+/// We assume that if ../../rustc exists, then we're running\n+/// rustpkg from a Rust target directory. This is part of a\n+/// kludgy hack used to adjust the sysroot.\n+pub fn in_target(sysroot_opt: Option<@Path>) -> bool {\n+    match sysroot_opt {\n+        None => false,\n+        Some(p) => {\n+            debug!(\"Checking whether %s is in target\", p.to_str());\n+            os::path_is_dir(&p.pop().pop().push(\"rustc\"))\n+        }\n+    }\n+}"}, {"sha": "7c3cde655173b49454d8cdfaf4cd5138b73744f8", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -10,6 +10,7 @@\n \n // Listing installed packages\n \n+use rustc::metadata::filesearch::rust_path;\n use path_util::*;\n use std::os;\n \n@@ -20,21 +21,46 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n         for exec in binfiles.iter() {\n             let exec_path = Path(*exec).filestem();\n             do exec_path.iter().advance |s| {\n-                f(&PkgId::new(*s, p))\n+                f(&PkgId::new(*s))\n             };\n         }\n         let libfiles = os::list_dir(&p.push(\"lib\"));\n         for lib in libfiles.iter() {\n-            debug!(\"Full name: %s\", *lib);\n-            let lib_path = Path(*lib).filestem();\n-            do lib_path.iter().advance |s| {\n-                f(&PkgId::new(*s, p))\n-            };\n-        }\n+            let lib = Path(*lib);\n+            debug!(\"Full name: %s\", lib.to_str());\n+            match has_library(&lib) {\n+                Some(basename) => {\n+                    debug!(\"parent = %s, child = %s\",\n+                           p.push(\"lib\").to_str(), lib.to_str());\n+                    let rel_p = p.push(\"lib/\").get_relative_to(&lib);\n+                    debug!(\"Rel: %s\", rel_p.to_str());\n+                    let rel_path = rel_p.push(basename).to_str();\n+                    debug!(\"Rel name: %s\", rel_path);\n+                    f(&PkgId::new(rel_path));\n+                }\n+                None => ()\n+            }\n+        };\n     }\n     true\n }\n \n+pub fn has_library(p: &Path) -> Option<~str> {\n+    let files = os::list_dir(p);\n+    for q in files.iter() {\n+        let as_path = Path(*q);\n+        if as_path.filetype() == Some(os::consts::DLL_SUFFIX.to_owned()) {\n+            let stuff : ~str = as_path.filestem().expect(\"has_library: weird path\");\n+            let mut stuff2 = stuff.split_str_iter(&\"-\");\n+            let stuff3: ~[&str] = stuff2.collect();\n+            // argh\n+            let chars_to_drop = os::consts::DLL_PREFIX.len();\n+            return Some(stuff3[0].slice(chars_to_drop, stuff3[0].len()).to_owned());\n+        }\n+    }\n+    None\n+}\n+\n pub fn package_is_installed(p: &PkgId) -> bool {\n     let mut is_installed = false;\n     do list_installed_packages() |installed| {\n@@ -44,4 +70,4 @@ pub fn package_is_installed(p: &PkgId) -> bool {\n         false\n     };\n     is_installed\n-}\n\\ No newline at end of file\n+}"}, {"sha": "e3b3252587a082662f9258e33f98885a3302cfa1", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -8,44 +8,45 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use package_path::{RemotePath, LocalPath, normalize, hash};\n use version::{try_getting_version, try_getting_local_version,\n               Version, NoVersion, split_version};\n+use std::rt::io::Writer;\n+use std::hash::Streaming;\n+use std::hash;\n \n /// Path-fragment identifier of a package such as\n /// 'github.com/graydon/test'; path must be a relative\n /// path with >=1 component.\n #[deriving(Clone)]\n pub struct PkgId {\n-    /// Remote path: for example, github.com/mozilla/quux-whatever\n-    remote_path: RemotePath,\n-    /// Local path: for example, /home/quux/github.com/mozilla/quux_whatever\n-    /// Note that '-' normalizes to '_' when mapping a remote path\n-    /// onto a local path\n-    /// Also, this will change when we implement #6407, though we'll still\n-    /// need to keep track of separate local and remote paths\n-    local_path: LocalPath,\n-    /// Short name. This is the local path's filestem, but we store it\n+    /// This is a path, on the local filesystem, referring to where the\n+    /// files for this package live. For example:\n+    /// github.com/mozilla/quux-whatever (it's assumed that if we're\n+    /// working with a package ID of this form, rustpkg has already cloned\n+    /// the sources into a local directory in the RUST_PATH).\n+    path: Path,\n+    /// Short name. This is the path's filestem, but we store it\n     /// redundantly so as to not call get() everywhere (filestem() returns an\n     /// option)\n+    /// The short name does not need to be a valid Rust identifier.\n+    /// Users can write: `extern mod foo = \"...\";` to get around the issue\n+    /// of package IDs whose short names aren't valid Rust identifiers.\n     short_name: ~str,\n+    /// The requested package version.\n     version: Version\n }\n \n impl Eq for PkgId {\n     fn eq(&self, p: &PkgId) -> bool {\n-        *p.local_path == *self.local_path && p.version == self.version\n+        p.path == self.path && p.version == self.version\n     }\n     fn ne(&self, p: &PkgId) -> bool {\n         !(self.eq(p))\n     }\n }\n \n impl PkgId {\n-    // The PkgId constructor takes a Path argument so as\n-    // to be able to infer the version if the path refers\n-    // to a local git repository\n-    pub fn new(s: &str, work_dir: &Path) -> PkgId {\n+    pub fn new(s: &str) -> PkgId {\n         use conditions::bad_pkg_id::cond;\n \n         let mut given_version = None;\n@@ -63,51 +64,64 @@ impl PkgId {\n             }\n         };\n \n-        let p = Path(s);\n-        if p.is_absolute {\n-            return cond.raise((p, ~\"absolute pkgid\"));\n+        let path = Path(s);\n+        if path.is_absolute {\n+            return cond.raise((path, ~\"absolute pkgid\"));\n         }\n-        if p.components.len() < 1 {\n-            return cond.raise((p, ~\"0-length pkgid\"));\n+        if path.components.len() < 1 {\n+            return cond.raise((path, ~\"0-length pkgid\"));\n         }\n-        let remote_path = RemotePath(p);\n-        let local_path = normalize(remote_path.clone());\n-        let short_name = local_path.clone().filestem().expect(fmt!(\"Strange path! %s\", s));\n+        let short_name = path.clone().filestem().expect(fmt!(\"Strange path! %s\", s));\n \n         let version = match given_version {\n             Some(v) => v,\n-            None => match try_getting_local_version(&work_dir.push_rel(&*local_path)) {\n+            None => match try_getting_local_version(&path) {\n                 Some(v) => v,\n-                None => match try_getting_version(&remote_path) {\n+                None => match try_getting_version(&path) {\n                     Some(v) => v,\n                     None => NoVersion\n                 }\n             }\n         };\n \n-        debug!(\"local_path = %s, remote_path = %s\", local_path.to_str(), remote_path.to_str());\n+        debug!(\"path = %s\", path.to_str());\n         PkgId {\n-            local_path: local_path,\n-            remote_path: remote_path,\n+            path: path,\n             short_name: short_name,\n             version: version\n         }\n     }\n \n     pub fn hash(&self) -> ~str {\n-        fmt!(\"%s-%s-%s\", self.remote_path.to_str(),\n-             hash(self.remote_path.to_str() + self.version.to_str()),\n+        fmt!(\"%s-%s-%s\", self.path.to_str(),\n+             hash(self.path.to_str() + self.version.to_str()),\n              self.version.to_str())\n     }\n \n     pub fn short_name_with_version(&self) -> ~str {\n         fmt!(\"%s%s\", self.short_name, self.version.to_str())\n     }\n+\n+    /// True if the ID has multiple components\n+    pub fn is_complex(&self) -> bool {\n+        self.short_name != self.path.to_str()\n+     }\n }\n \n impl ToStr for PkgId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n-        fmt!(\"%s-%s\", self.local_path.to_str(), self.version.to_str())\n+        fmt!(\"%s-%s\", self.path.to_str(), self.version.to_str())\n     }\n }\n+\n+\n+pub fn write<W: Writer>(writer: &mut W, string: &str) {\n+    writer.write(string.as_bytes());\n+}\n+\n+pub fn hash(data: ~str) -> ~str {\n+    let hasher = &mut hash::default_state();\n+    write(hasher, data);\n+    hasher.result_str()\n+}"}, {"sha": "4ba9c8066e4f3ac9e88e2e57faae8f1648c8fa20", "filename": "src/librustpkg/package_path.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cab6d46e58ea6f7535d8e454f0345eccfae183c4/src%2Flibrustpkg%2Fpackage_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab6d46e58ea6f7535d8e454f0345eccfae183c4/src%2Flibrustpkg%2Fpackage_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_path.rs?ref=cab6d46e58ea6f7535d8e454f0345eccfae183c4", "patch": "@@ -1,68 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// rustpkg utilities having to do with local and remote paths\n-\n-use std::clone::Clone;\n-use std::hash::Streaming;\n-use std::hash;\n-use std::option::Some;\n-use std::path::Path;\n-use std::rt::io::Writer;\n-\n-/// Wrappers to prevent local and remote paths from getting confused\n-/// (These will go away after #6407)\n-pub struct RemotePath (Path);\n-\n-impl Clone for RemotePath {\n-    fn clone(&self) -> RemotePath {\n-        RemotePath((**self).clone())\n-    }\n-}\n-\n-pub struct LocalPath (Path);\n-\n-impl Clone for LocalPath {\n-    fn clone(&self) -> LocalPath {\n-        LocalPath((**self).clone())\n-    }\n-}\n-\n-\n-// normalize should be the only way to construct a LocalPath\n-// (though this isn't enforced)\n-/// Replace all occurrences of '-' in the stem part of path with '_'\n-/// This is because we treat rust-foo-bar-quux and rust_foo_bar_quux\n-/// as the same name\n-pub fn normalize(p_: RemotePath) -> LocalPath {\n-    let RemotePath(p) = p_;\n-    match p.filestem() {\n-        None => LocalPath(p),\n-        Some(st) => {\n-            let replaced = st.replace(\"-\", \"_\");\n-            if replaced != st {\n-                LocalPath(p.with_filestem(replaced))\n-            }\n-            else {\n-                LocalPath(p)\n-            }\n-        }\n-    }\n-}\n-\n-pub fn write<W: Writer>(writer: &mut W, string: &str) {\n-    writer.write(string.as_bytes());\n-}\n-\n-pub fn hash(data: ~str) -> ~str {\n-    let hasher = &mut hash::default_state();\n-    write(hasher, data);\n-    hasher.result_str()\n-}"}, {"sha": "9833e18e016b63cf4d862a74d05c33096581d7a8", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 19, "deletions": 40, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -11,7 +11,7 @@\n use target::*;\n use package_id::PkgId;\n use std::path::Path;\n-use std::{os, str};\n+use std::os;\n use context::*;\n use crate::Crate;\n use messages::*;\n@@ -23,7 +23,6 @@ use util::compile_crate;\n // This contains a list of files found in the source workspace.\n pub struct PkgSrc {\n     root: Path, // root of where the package source code lives\n-    dst_dir: Path, // directory where we will put the compiled output\n     id: PkgId,\n     libs: ~[Crate],\n     mains: ~[Crate],\n@@ -37,11 +36,9 @@ condition! {\n \n impl PkgSrc {\n \n-    pub fn new(src_dir: &Path, dst_dir: &Path,\n-                  id: &PkgId) -> PkgSrc {\n+    pub fn new(src_dir: &Path, id: &PkgId) -> PkgSrc {\n         PkgSrc {\n             root: (*src_dir).clone(),\n-            dst_dir: (*dst_dir).clone(),\n             id: (*id).clone(),\n             libs: ~[],\n             mains: ~[],\n@@ -54,8 +51,7 @@ impl PkgSrc {\n     fn check_dir(&self) -> Path {\n         use conditions::nonexistent_package::cond;\n \n-        debug!(\"Pushing onto root: %s | %s\", self.id.remote_path.to_str(),\n-               self.root.to_str());\n+        debug!(\"Pushing onto root: %s | %s\", self.id.path.to_str(), self.root.to_str());\n         let dir;\n         let dirs = pkgid_src_in_workspace(&self.id, &self.root);\n         debug!(\"Checking dirs: %?\", dirs);\n@@ -89,18 +85,18 @@ impl PkgSrc {\n         os::remove_dir_recursive(&local);\n \n         debug!(\"Checking whether %s exists locally. Cwd = %s, does it? %?\",\n-               self.id.local_path.to_str(),\n+               self.id.path.to_str(),\n                os::getcwd().to_str(),\n-               os::path_exists(&*self.id.local_path));\n+               os::path_exists(&self.id.path));\n \n-        if os::path_exists(&*self.id.local_path) {\n+        if os::path_exists(&self.id.path) {\n             debug!(\"%s exists locally! Cloning it into %s\",\n-                   self.id.local_path.to_str(), local.to_str());\n-            git_clone(&*self.id.local_path, &local, &self.id.version);\n+                   self.id.path.to_str(), local.to_str());\n+            git_clone(&self.id.path, &local, &self.id.version);\n             return Some(local);\n         }\n \n-        let url = fmt!(\"https://%s\", self.id.remote_path.to_str());\n+        let url = fmt!(\"https://%s\", self.id.path.to_str());\n         note(fmt!(\"Fetching package: git clone %s %s [version=%s]\",\n                   url, local.to_str(), self.id.version.to_str()));\n         if git_clone_general(url, &local, &self.id.version) {\n@@ -125,25 +121,8 @@ impl PkgSrc {\n     }\n \n     /// True if the given path's stem is self's pkg ID's stem\n-    /// or if the pkg ID's stem is <rust-foo> and the given path's\n-    /// stem is foo\n-    /// Requires that dashes in p have already been normalized to\n-    /// underscores\n     fn stem_matches(&self, p: &Path) -> bool {\n-        let self_id = self.id.local_path.filestem();\n-        if self_id == p.filestem() {\n-            return true;\n-        }\n-        else {\n-            for pth in self_id.iter() {\n-                if pth.starts_with(\"rust_\") // because p is already normalized\n-                    && match p.filestem() {\n-                           Some(s) => str::eq_slice(s, pth.slice(5, pth.len())),\n-                           None => false\n-                       } { return true; }\n-            }\n-        }\n-        false\n+        p.filestem().map_default(false, |p| { p == &self.id.short_name })\n     }\n \n     fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n@@ -164,7 +143,7 @@ impl PkgSrc {\n         let dir = self.check_dir();\n         debug!(\"Called check_dir, I'm in %s\", dir.to_str());\n         let prefix = dir.components.len();\n-        debug!(\"Matching against %?\", self.id.local_path.filestem());\n+        debug!(\"Matching against %?\", self.id.short_name);\n         do os::walk_dir(&dir) |pth| {\n             match pth.filename() {\n                 Some(~\"lib.rs\") => PkgSrc::push_crate(&mut self.libs,\n@@ -202,20 +181,20 @@ impl PkgSrc {\n \n     fn build_crates(&self,\n                     ctx: &Ctx,\n-                    dst_dir: &Path,\n                     src_dir: &Path,\n                     crates: &[Crate],\n                     cfgs: &[~str],\n                     what: OutputType) {\n         for crate in crates.iter() {\n             let path = &src_dir.push_rel(&crate.file).normalize();\n             note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n-            note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));\n+            note(fmt!(\"build_crates: using as workspace %s\", self.root.to_str()));\n \n             let result = compile_crate(ctx,\n                                        &self.id,\n                                        path,\n-                                       dst_dir,\n+                                       // compile_crate wants the workspace\n+                                       &self.root,\n                                        crate.flags,\n                                        crate.cfgs + cfgs,\n                                        false,\n@@ -229,15 +208,15 @@ impl PkgSrc {\n         }\n     }\n \n-    pub fn build(&self, ctx: &Ctx, dst_dir: Path, cfgs: ~[~str]) {\n+    pub fn build(&self, ctx: &Ctx, cfgs: ~[~str]) {\n         let dir = self.check_dir();\n         debug!(\"Building libs in %s\", dir.to_str());\n-        self.build_crates(ctx, &dst_dir, &dir, self.libs, cfgs, Lib);\n+        self.build_crates(ctx, &dir, self.libs, cfgs, Lib);\n         debug!(\"Building mains\");\n-        self.build_crates(ctx, &dst_dir, &dir, self.mains, cfgs, Main);\n+        self.build_crates(ctx, &dir, self.mains, cfgs, Main);\n         debug!(\"Building tests\");\n-        self.build_crates(ctx, &dst_dir, &dir, self.tests, cfgs, Test);\n+        self.build_crates(ctx, &dir, self.tests, cfgs, Test);\n         debug!(\"Building benches\");\n-        self.build_crates(ctx, &dst_dir, &dir, self.benchs, cfgs, Bench);\n+        self.build_crates(ctx, &dir, self.benchs, cfgs, Bench);\n     }\n }"}, {"sha": "bbe84b2ecac4f8ddfa7539d5ca5961c3b102d3dd", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 42, "deletions": 95, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -10,65 +10,17 @@\n \n // rustpkg utilities having to do with paths and directories\n \n-pub use package_path::{RemotePath, LocalPath, normalize};\n pub use package_id::PkgId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n pub use version::{Version, NoVersion, split_version_general};\n+pub use rustc::metadata::filesearch::rust_path;\n+\n use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use std::os::mkdir_recursive;\n use std::os;\n-use std::iterator::IteratorUtil;\n use messages::*;\n use package_id::*;\n \n-fn push_if_exists(vec: &mut ~[Path], p: &Path) {\n-    let maybe_dir = p.push(\".rust\");\n-    if os::path_exists(&maybe_dir) {\n-        vec.push(maybe_dir);\n-    }\n-}\n-\n-#[cfg(windows)]\n-static PATH_ENTRY_SEPARATOR: &'static str = \";\";\n-#[cfg(not(windows))]\n-static PATH_ENTRY_SEPARATOR: &'static str = \":\";\n-\n-/// Returns RUST_PATH as a string, without default paths added\n-pub fn get_rust_path() -> Option<~str> {\n-    os::getenv(\"RUST_PATH\")\n-}\n-\n-/// Returns the value of RUST_PATH, as a list\n-/// of Paths. Includes default entries for, if they exist:\n-/// $HOME/.rust\n-/// DIR/.rust for any DIR that's the current working directory\n-/// or an ancestor of it\n-pub fn rust_path() -> ~[Path] {\n-    let mut env_rust_path: ~[Path] = match get_rust_path() {\n-        Some(env_path) => {\n-            let env_path_components: ~[&str] =\n-                env_path.split_str_iter(PATH_ENTRY_SEPARATOR).collect();\n-            env_path_components.map(|&s| Path(s))\n-        }\n-        None => ~[]\n-    };\n-    debug!(\"RUST_PATH entries from environment: %?\", env_rust_path);\n-    let cwd = os::getcwd();\n-    // now add in default entries\n-    env_rust_path.push(cwd.clone());\n-    do cwd.each_parent() |p| { push_if_exists(&mut env_rust_path, p) };\n-    let h = os::homedir();\n-    // Avoid adding duplicates\n-    // could still add dups if someone puts one of these in the RUST_PATH\n-    // manually, though...\n-    for hdir in h.iter() {\n-        if !(cwd.is_ancestor_of(hdir) || hdir.is_ancestor_of(&cwd)) {\n-            push_if_exists(&mut env_rust_path, hdir);\n-        }\n-    }\n-    env_rust_path\n-}\n-\n pub fn default_workspace() -> Path {\n     let p = rust_path();\n     if p.is_empty() {\n@@ -99,39 +51,39 @@ pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, U_RWX) }\n /// pkgid's short name\n pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n     let src_dir = workspace.push(\"src\");\n-    let dirs = os::list_dir(&src_dir);\n-    for p in dirs.iter() {\n-        let p = Path((*p).clone());\n+    let mut found = false;\n+    do os::walk_dir(&src_dir) |p| {\n         debug!(\"=> p = %s\", p.to_str());\n-        if !os::path_is_dir(&src_dir.push_rel(&p)) {\n-            loop;\n-        }\n-        debug!(\"p = %s, remote_path = %s\", p.to_str(), pkgid.remote_path.to_str());\n+        if os::path_is_dir(p) {\n+            debug!(\"p = %s, path = %s [%s]\", p.to_str(), pkgid.path.to_str(),\n+            src_dir.push_rel(&pkgid.path).to_str());\n \n-        if p == *pkgid.remote_path {\n-            return true;\n-        }\n-        else {\n-            let pf = p.filename();\n-            for pf in pf.iter() {\n-                let f_ = (*pf).clone();\n-                let g = f_.to_str();\n-                match split_version_general(g, '-') {\n-                    Some((ref might_match, ref vers)) => {\n-                        debug!(\"might_match = %s, vers = %s\", *might_match,\n+            if *p == src_dir.push_rel(&pkgid.path) {\n+                found = true;\n+            }\n+            else {\n+                let pf = p.filename();\n+                for pf in pf.iter() {\n+                    let f_ = (*pf).clone();\n+                    let g = f_.to_str();\n+                    match split_version_general(g, '-') {\n+                        Some((ref might_match, ref vers)) => {\n+                            debug!(\"might_match = %s, vers = %s\", *might_match,\n                                vers.to_str());\n-                        if *might_match == pkgid.short_name\n-                            && (*vers == pkgid.version || pkgid.version == NoVersion)\n-                        {\n-                            return true;\n+                            if *might_match == pkgid.short_name\n+                                 && (*vers == pkgid.version || pkgid.version == NoVersion)\n+                            {\n+                                  found = true;\n+                            }\n                         }\n-                    }\n-                    None => ()\n+                        None => ()\n+                     }\n                 }\n             }\n         }\n-    }\n-    false\n+        true\n+    };\n+    found\n }\n \n /// Returns a list of possible directories\n@@ -141,9 +93,9 @@ pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n pub fn pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> ~[Path] {\n     let mut results = ~[];\n     let result = workspace.push(\"src\").push(fmt!(\"%s-%s\",\n-                     pkgid.local_path.to_str(), pkgid.version.to_str()));\n+                     pkgid.path.to_str(), pkgid.version.to_str()));\n     results.push(result);\n-    results.push(workspace.push(\"src\").push_rel(&*pkgid.remote_path));\n+    results.push(workspace.push(\"src\").push_rel(&pkgid.path));\n     results\n }\n \n@@ -163,7 +115,7 @@ pub fn first_pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<P\n pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let mut result = workspace.push(\"build\");\n     // should use a target-specific subdirectory\n-    result = mk_output_path(Main, Build, pkgid, &result);\n+    result = mk_output_path(Main, Build, pkgid, result);\n     debug!(\"built_executable_in_workspace: checking whether %s exists\",\n            result.to_str());\n     if os::path_exists(&result) {\n@@ -191,7 +143,7 @@ pub fn built_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path>\n fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Option<Path> {\n     let mut result = workspace.push(\"build\");\n     // should use a target-specific subdirectory\n-    result = mk_output_path(what, Build, pkgid, &result);\n+    result = mk_output_path(what, Build, pkgid, result);\n     debug!(\"output_in_workspace: checking whether %s exists\",\n            result.to_str());\n     if os::path_exists(&result) {\n@@ -206,22 +158,20 @@ fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Opt\n /// Figure out what the library name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n-    library_in_workspace(&pkgid.local_path, pkgid.short_name,\n-                         Build, workspace, \"build\")\n+    library_in_workspace(&pkgid.path, pkgid.short_name, Build, workspace, \"build\")\n }\n \n /// Does the actual searching stuff\n pub fn installed_library_in_workspace(short_name: &str, workspace: &Path) -> Option<Path> {\n-    library_in_workspace(&normalize(RemotePath(Path(short_name))),\n-                         short_name, Install, workspace, \"lib\")\n+    library_in_workspace(&Path(short_name), short_name, Install, workspace, \"lib\")\n }\n \n \n /// This doesn't take a PkgId, so we can use it for `extern mod` inference, where we\n /// don't know the entire package ID.\n /// `workspace` is used to figure out the directory to search.\n /// `short_name` is taken as the link name of the library.\n-pub fn library_in_workspace(path: &LocalPath, short_name: &str, where: Target,\n+pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n                         workspace: &Path, prefix: &str) -> Option<Path> {\n     debug!(\"library_in_workspace: checking whether a library named %s exists\",\n            short_name);\n@@ -233,7 +183,7 @@ pub fn library_in_workspace(path: &LocalPath, short_name: &str, where: Target,\n             prefix = %s\", short_name, where, workspace.to_str(), prefix);\n \n     let dir_to_search = match where {\n-        Build => workspace.push(prefix).push_rel(&**path),\n+        Build => workspace.push(prefix).push_rel(path),\n         Install => workspace.push(prefix)\n     };\n     debug!(\"Listing directory %s\", dir_to_search.to_str());\n@@ -349,15 +299,15 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n     // Artifacts in the build directory live in a package-ID-specific subdirectory,\n     // but installed ones don't.\n     let result = match where {\n-                Build => workspace.push(subdir).push_rel(&*pkgid.local_path),\n+                Build => workspace.push(subdir).push_rel(&pkgid.path),\n                 _     => workspace.push(subdir)\n     };\n     if !os::path_exists(&result) && !mkdir_recursive(&result, U_RWX) {\n         cond.raise((result.clone(), fmt!(\"target_file_in_workspace couldn't \\\n             create the %s dir (pkgid=%s, workspace=%s, what=%?, where=%?\",\n             subdir, pkgid.to_str(), workspace.to_str(), what, where)));\n     }\n-    mk_output_path(what, where, pkgid, &result)\n+    mk_output_path(what, where, pkgid, result)\n }\n \n /// Return the directory for <pkgid>'s build artifacts in <workspace>.\n@@ -368,7 +318,7 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     let mut result = workspace.push(\"build\");\n     // n.b. Should actually use a target-specific\n     // subdirectory of build/\n-    result = result.push_rel(&*pkgid.local_path);\n+    result = result.push_rel(&pkgid.path);\n     if os::path_exists(&result) || os::mkdir_recursive(&result, U_RWX) {\n         result\n     }\n@@ -380,19 +330,16 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n /// Return the output file for a given directory name,\n /// given whether we're building a library and whether we're building tests\n pub fn mk_output_path(what: OutputType, where: Target,\n-                      pkg_id: &PkgId, workspace: &Path) -> Path {\n+                      pkg_id: &PkgId, workspace: Path) -> Path {\n     let short_name_with_version = fmt!(\"%s-%s\", pkg_id.short_name,\n                                        pkg_id.version.to_str());\n     // Not local_path.dir_path()! For package foo/bar/blat/, we want\n     // the executable blat-0.5 to live under blat/\n     let dir = match where {\n         // If we're installing, it just goes under <workspace>...\n-        Install => {\n-            // bad copy, but I just couldn't make the borrow checker happy\n-            (*workspace).clone()\n-        }\n+        Install => workspace,\n         // and if we're just building, it goes in a package-specific subdir\n-        Build => workspace.push_rel(&*pkg_id.local_path)\n+        Build => workspace.push_rel(&pkg_id.path)\n     };\n     debug!(\"[%?:%?] mk_output_path: short_name = %s, path = %s\", what, where,\n            if what == Lib { short_name_with_version.clone() } else { pkg_id.short_name.clone() },"}, {"sha": "26dab4120fda452d5ec1964549fce1518bf600d2", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 39, "deletions": 50, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -33,12 +33,13 @@ use std::hashmap::HashMap;\n \n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n+use rustc::metadata::filesearch::rust_path;\n use extra::{getopts};\n use syntax::{ast, diagnostic};\n use util::*;\n use messages::*;\n use path_util::{build_pkg_id_in_workspace, first_pkgid_src_in_workspace};\n-use path_util::{U_RWX, rust_path, in_rust_path};\n+use path_util::{U_RWX, in_rust_path};\n use path_util::{built_executable_in_workspace, built_library_in_workspace, default_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n use source_control::is_git_dir;\n@@ -54,7 +55,6 @@ mod crate;\n mod installed_packages;\n mod messages;\n mod package_id;\n-mod package_path;\n mod package_source;\n mod path_util;\n mod search;\n@@ -138,35 +138,28 @@ impl<'self> PkgScript<'self> {\n         let crate = util::ready_crate(sess, self.crate);\n         debug!(\"Building output filenames with script name %s\",\n                driver::source_name(&self.input));\n-        match filesearch::get_rustpkg_sysroot() {\n-            Ok(r) => {\n-                let root = r.pop().pop().pop().pop(); // :-\\\n-                debug!(\"Root is %s, calling compile_rest\", root.to_str());\n-                let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n-                util::compile_crate_from_input(&self.input,\n-                                               &self.build_dir,\n-                                               sess,\n-                                               crate);\n-                debug!(\"Running program: %s %s %s %s\", exe.to_str(),\n-                       sysroot.to_str(), root.to_str(), \"install\");\n-                // FIXME #7401 should support commands besides `install`\n-                let status = run::process_status(exe.to_str(), [sysroot.to_str(), ~\"install\"]);\n-                if status != 0 {\n-                    return (~[], status);\n-                }\n-                else {\n-                    debug!(\"Running program (configs): %s %s %s\",\n-                           exe.to_str(), root.to_str(), \"configs\");\n-                    let output = run::process_output(exe.to_str(), [root.to_str(), ~\"configs\"]);\n-                    // Run the configs() function to get the configs\n-                    let cfgs = str::from_bytes_slice(output.output).word_iter()\n-                        .transform(|w| w.to_owned()).collect();\n-                    (cfgs, output.status)\n-                }\n-            }\n-            Err(e) => {\n-                fail!(\"Running package script, couldn't find rustpkg sysroot (%s)\", e)\n-            }\n+        let root = filesearch::get_or_default_sysroot().pop().pop(); // :-\\\n+        debug!(\"Root is %s, calling compile_rest\", root.to_str());\n+        let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n+        util::compile_crate_from_input(&self.input,\n+                                       &self.build_dir,\n+                                       sess,\n+                                       crate);\n+        debug!(\"Running program: %s %s %s %s\", exe.to_str(),\n+               sysroot.to_str(), root.to_str(), \"install\");\n+        // FIXME #7401 should support commands besides `install`\n+        let status = run::process_status(exe.to_str(), [sysroot.to_str(), ~\"install\"]);\n+        if status != 0 {\n+            return (~[], status);\n+        }\n+        else {\n+            debug!(\"Running program (configs): %s %s %s\",\n+                   exe.to_str(), root.to_str(), \"configs\");\n+            let output = run::process_output(exe.to_str(), [root.to_str(), ~\"configs\"]);\n+            // Run the configs() function to get the configs\n+            let cfgs = str::from_bytes_slice(output.output).word_iter()\n+                .transform(|w| w.to_owned()).collect();\n+            (cfgs, output.status)\n         }\n     }\n \n@@ -205,7 +198,7 @@ impl CtxMethods for Ctx {\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n-                    let pkgid = PkgId::new(args[0].clone(), &os::getcwd());\n+                    let pkgid = PkgId::new(args[0].clone());\n                     do each_pkg_parent_workspace(&pkgid) |workspace| {\n                         debug!(\"found pkg %s in workspace %s, trying to build\",\n                                pkgid.to_str(), workspace.to_str());\n@@ -228,7 +221,7 @@ impl CtxMethods for Ctx {\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n-                    let pkgid = PkgId::new(args[0].clone(), &os::getcwd());\n+                    let pkgid = PkgId::new(args[0].clone());\n                     let cwd = os::getcwd();\n                     self.clean(&cwd, &pkgid); // tjc: should use workspace, not cwd\n                 }\n@@ -254,13 +247,12 @@ impl CtxMethods for Ctx {\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n-                    let pkgid = PkgId::new(args[0], &os::getcwd());\n+                    let pkgid = PkgId::new(args[0]);\n                     let workspaces = pkg_parent_workspaces(&pkgid);\n                     if workspaces.is_empty() {\n                         let rp = rust_path();\n                         assert!(!rp.is_empty());\n-                        let src = PkgSrc::new(&rp[0], &build_pkg_id_in_workspace(&pkgid, &rp[0]),\n-                                              &pkgid);\n+                        let src = PkgSrc::new(&rp[0], &pkgid);\n                         src.fetch_git();\n                         self.install(&rp[0], &pkgid);\n                     }\n@@ -275,7 +267,7 @@ impl CtxMethods for Ctx {\n             \"list\" => {\n                 io::println(\"Installed packages:\");\n                 do installed_packages::list_installed_packages |pkg_id| {\n-                    println(pkg_id.local_path.to_str());\n+                    println(pkg_id.path.to_str());\n                     true\n                 };\n             }\n@@ -294,7 +286,7 @@ impl CtxMethods for Ctx {\n                     return usage::uninstall();\n                 }\n \n-                let pkgid = PkgId::new(args[0], &os::getcwd()); // ??\n+                let pkgid = PkgId::new(args[0]);\n                 if !installed_packages::package_is_installed(&pkgid) {\n                     warn(fmt!(\"Package %s doesn't seem to be installed! Doing nothing.\", args[0]));\n                     return;\n@@ -329,20 +321,18 @@ impl CtxMethods for Ctx {\n     fn build(&self, workspace: &Path, pkgid: &PkgId) {\n         debug!(\"build: workspace = %s (in Rust path? %? is git dir? %? \\\n                 pkgid = %s\", workspace.to_str(),\n-               in_rust_path(workspace), is_git_dir(&workspace.push_rel(&*pkgid.local_path)),\n+               in_rust_path(workspace), is_git_dir(&workspace.push_rel(&pkgid.path)),\n                pkgid.to_str());\n         let src_dir   = first_pkgid_src_in_workspace(pkgid, workspace);\n-        let build_dir = build_pkg_id_in_workspace(pkgid, workspace);\n-        debug!(\"Destination dir = %s\", build_dir.to_str());\n \n         // If workspace isn't in the RUST_PATH, and it's a git repo,\n         // then clone it into the first entry in RUST_PATH, and repeat\n         debug!(\"%? %? %s\", in_rust_path(workspace),\n-               is_git_dir(&workspace.push_rel(&*pkgid.local_path)),\n+               is_git_dir(&workspace.push_rel(&pkgid.path)),\n                workspace.to_str());\n-        if !in_rust_path(workspace) && is_git_dir(&workspace.push_rel(&*pkgid.local_path)) {\n-            let out_dir = default_workspace().push(\"src\").push_rel(&*pkgid.local_path);\n-            source_control::git_clone(&workspace.push_rel(&*pkgid.local_path),\n+        if !in_rust_path(workspace) && is_git_dir(&workspace.push_rel(&pkgid.path)) {\n+            let out_dir = default_workspace().push(\"src\").push_rel(&pkgid.path);\n+            source_control::git_clone(&workspace.push_rel(&pkgid.path),\n                                       &out_dir, &pkgid.version);\n             let default_ws = default_workspace();\n             debug!(\"Calling build recursively with %? and %?\", default_ws.to_str(),\n@@ -351,7 +341,7 @@ impl CtxMethods for Ctx {\n         }\n \n         // Create the package source\n-        let mut src = PkgSrc::new(workspace, &build_dir, pkgid);\n+        let mut src = PkgSrc::new(workspace, pkgid);\n         debug!(\"Package src = %?\", src);\n \n         // Is there custom build logic? If so, use it\n@@ -385,7 +375,7 @@ impl CtxMethods for Ctx {\n             // Find crates inside the workspace\n             src.find_crates();\n             // Build it!\n-            src.build(self, build_dir, cfgs);\n+            src.build(self, cfgs);\n         }\n     }\n \n@@ -444,6 +434,7 @@ impl CtxMethods for Ctx {\n         for lib in maybe_library.iter() {\n             let target_lib = target_lib.clone().expect(fmt!(\"I built %s but apparently \\\n                                                 didn't install it!\", lib.to_str()));\n+            let target_lib = target_lib.pop().push(lib.filename().expect(\"weird target lib\"));\n             debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());\n             if !(os::mkdir_recursive(&target_lib.dir_path(), U_RWX) &&\n                  os::copy_file(lib, &target_lib)) {\n@@ -518,9 +509,7 @@ pub fn main() {\n         };\n     }\n \n-    let sroot = match filesearch::get_rustpkg_sysroot() {\n-        Ok(r) => Some(@r.pop().pop()), Err(_) => None\n-    };\n+    let sroot = Some(@filesearch::get_or_default_sysroot());\n     debug!(\"Using sysroot: %?\", sroot);\n     Ctx {\n         sysroot_opt: sroot, // Currently, only tests override this"}, {"sha": "caa004a53b22879363807268745510a0926659bf", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -10,7 +10,7 @@\n \n // Utils for working with version control repositories. Just git right now.\n \n-use std::{os, run, str};\n+use std::{io, os, run, str};\n use std::run::{ProcessOutput, ProcessOptions, Process};\n use version::*;\n \n@@ -19,14 +19,37 @@ pub fn git_clone(source: &Path, target: &Path, v: &Version) {\n     assert!(os::path_is_dir(source));\n     assert!(is_git_dir(source));\n     if !os::path_exists(target) {\n-        debug!(\"Running: git clone %s %s\", source.to_str(),\n-               target.to_str());\n-        assert!(git_clone_general(source.to_str(), target, v));\n+        debug!(\"Running: git clone %s %s\", source.to_str(), target.to_str());\n+        let outp = run::process_output(\"git\", [~\"clone\", source.to_str(), target.to_str()]);\n+        if outp.status != 0 {\n+            io::println(str::from_bytes_owned(outp.output.clone()));\n+            io::println(str::from_bytes_owned(outp.error));\n+            fail!(\"Couldn't `git clone` %s\", source.to_str());\n+        }\n+        else {\n+            match v {\n+                &ExactRevision(ref s) => {\n+                    debug!(\"`Running: git --work-tree=%s --git-dir=%s checkout %s\",\n+                           *s, target.to_str(), target.push(\".git\").to_str());\n+                    let outp = run::process_output(\"git\",\n+                                   [fmt!(\"--work-tree=%s\", target.to_str()),\n+                                    fmt!(\"--git-dir=%s\", target.push(\".git\").to_str()),\n+                                    ~\"checkout\", fmt!(\"%s\", *s)]);\n+                    if outp.status != 0 {\n+                        io::println(str::from_bytes_owned(outp.output.clone()));\n+                        io::println(str::from_bytes_owned(outp.error));\n+                        fail!(\"Couldn't `git checkout %s` in %s\",\n+                              *s, target.to_str());\n+                    }\n+                }\n+                _ => ()\n+            }\n+        }\n     }\n     else {\n-        // Pull changes\n-        // Note that this ignores tags, which is probably wrong. There are no tests for\n-        // it, though.\n+        // Check that no version was specified. There's no reason to not handle the\n+        // case where a version was requested, but I haven't implemented it.\n+        assert!(*v == NoVersion);\n         debug!(\"Running: git --work-tree=%s --git-dir=%s pull --no-edit %s\",\n                target.to_str(), target.push(\".git\").to_str(), source.to_str());\n         let outp = run::process_output(\"git\", [fmt!(\"--work-tree=%s\", target.to_str()),"}, {"sha": "121dcf40150211f56aea9e52f9036b227a5a42df", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 187, "deletions": 155, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -12,19 +12,20 @@\n \n use context::Ctx;\n use std::hashmap::HashMap;\n-use std::{io, libc, os, result, run, str};\n+use std::{io, libc, os, run, str};\n use extra::tempfile::mkdtemp;\n use std::run::ProcessOutput;\n use installed_packages::list_installed_packages;\n-use package_path::*;\n use package_id::{PkgId};\n use version::{ExactRevision, NoVersion, Version, Tagged};\n use path_util::{target_executable_in_workspace, target_library_in_workspace,\n                target_test_in_workspace, target_bench_in_workspace,\n                make_dir_rwx, U_RWX, library_in_workspace,\n                built_bench_in_workspace, built_test_in_workspace,\n                built_library_in_workspace, built_executable_in_workspace,\n-                installed_library_in_workspace, rust_path};\n+                installed_library_in_workspace};\n+use rustc::metadata::filesearch::rust_path;\n+use rustc::driver::driver::host_triple;\n use target::*;\n \n /// Returns the last-modified date as an Option\n@@ -42,31 +43,25 @@ fn fake_ctxt(sysroot_opt: Option<@Path>) -> Ctx {\n \n fn fake_pkg() -> PkgId {\n     let sn = ~\"bogus\";\n-    let remote = RemotePath(Path(sn));\n     PkgId {\n-        local_path: normalize(remote.clone()),\n-        remote_path: remote,\n+        path: Path(sn),\n         short_name: sn,\n         version: NoVersion\n     }\n }\n \n fn git_repo_pkg() -> PkgId {\n-    let remote = RemotePath(Path(\"mockgithub.com/catamorphism/test-pkg\"));\n     PkgId {\n-        local_path: normalize(remote.clone()),\n-        remote_path: remote,\n-        short_name: ~\"test_pkg\",\n+        path: Path(\"mockgithub.com/catamorphism/test-pkg\"),\n+        short_name: ~\"test-pkg\",\n         version: NoVersion\n     }\n }\n \n fn git_repo_pkg_with_tag(a_tag: ~str) -> PkgId {\n-    let remote = RemotePath(Path(\"mockgithub.com/catamorphism/test-pkg\"));\n     PkgId {\n-        local_path: normalize(remote.clone()),\n-        remote_path: remote,\n-        short_name: ~\"test_pkg\",\n+        path: Path(\"mockgithub.com/catamorphism/test-pkg\"),\n+        short_name: ~\"test-pkg\",\n         version: Tagged(a_tag)\n     }\n }\n@@ -76,21 +71,21 @@ fn writeFile(file_path: &Path, contents: &str) {\n     out.write_line(contents);\n }\n \n-fn mk_empty_workspace(short_name: &LocalPath, version: &Version) -> Path {\n+fn mk_empty_workspace(short_name: &Path, version: &Version) -> Path {\n     let workspace_dir = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n     mk_workspace(&workspace_dir, short_name, version);\n     workspace_dir\n }\n \n-fn mk_workspace(workspace: &Path, short_name: &LocalPath, version: &Version) -> Path {\n+fn mk_workspace(workspace: &Path, short_name: &Path, version: &Version) -> Path {\n     // include version number in directory name\n     let package_dir = workspace.push(\"src\").push(fmt!(\"%s-%s\",\n                                                       short_name.to_str(), version.to_str()));\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     package_dir\n }\n \n-fn mk_temp_workspace(short_name: &LocalPath, version: &Version) -> Path {\n+fn mk_temp_workspace(short_name: &Path, version: &Version) -> Path {\n     let package_dir = mk_empty_workspace(short_name,\n                                          version).push(\"src\").push(fmt!(\"%s-%s\",\n                                                             short_name.to_str(),\n@@ -116,6 +111,22 @@ fn mk_temp_workspace(short_name: &LocalPath, version: &Version) -> Path {\n     package_dir\n }\n \n+fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &str) {\n+    let cwd = (*cwd).clone();\n+    let mut prog = run::Process::new(\"git\", args, run::ProcessOptions {\n+        env: env.map(|v| v.slice(0, v.len())),\n+        dir: Some(&cwd),\n+        in_fd: None,\n+        out_fd: None,\n+        err_fd: None\n+    });\n+    let rslt = prog.finish_with_output();\n+    if rslt.status != 0 {\n+        fail!(\"%s [git returned %?, output = %s, error = %s]\", err_msg,\n+           rslt.status, str::from_bytes(rslt.output), str::from_bytes(rslt.error));\n+    }\n+}\n+\n /// Should create an empty git repo in p, relative to the tmp dir, and return the new\n /// absolute path\n fn init_git_repo(p: &Path) -> Path {\n@@ -125,37 +136,14 @@ fn init_git_repo(p: &Path) -> Path {\n     let work_dir_for_opts = work_dir.clone();\n     assert!(os::mkdir_recursive(&work_dir, U_RWX));\n     debug!(\"Running: git init in %s\", work_dir.to_str());\n-    let opts = run::ProcessOptions {\n-        env: None,\n-        dir: Some(&work_dir_for_opts),\n-        in_fd: None,\n-        out_fd: None,\n-        err_fd: None\n-    };\n-    let mut prog = run::Process::new(\"git\", [~\"init\"], opts);\n-    let mut output = prog.finish_with_output();\n-    if output.status == 0 {\n-        // Add stuff to the dir so that git tag succeeds\n-        writeFile(&work_dir.push(\"README\"), \"\");\n-        prog = run::Process::new(\"git\", [~\"add\", ~\"README\"], opts);\n-        output = prog.finish_with_output();\n-        if output.status == 0 {\n-            prog = run::Process::new(\"git\", [~\"commit\", ~\"-m\", ~\"whatever\"], opts);\n-            output = prog.finish_with_output();\n-            if output.status == 0 {\n-                tmp\n-            }\n-            else {\n-                fail!(\"Couldn't commit in %s\", work_dir.to_str());\n-            }\n-        }\n-        else {\n-            fail!(\"Couldn't add in %s\", work_dir.to_str());\n-        }\n-    }\n-    else {\n-        fail!(\"Couldn't initialize git repository in %s\", work_dir.to_str())\n-    }\n+    let ws = work_dir.to_str();\n+    run_git([~\"init\"], None, &work_dir_for_opts,\n+        fmt!(\"Couldn't initialize git repository in %s\", ws));\n+    // Add stuff to the dir so that git tag succeeds\n+    writeFile(&work_dir.push(\"README\"), \"\");\n+    run_git([~\"add\", ~\"README\"], None, &work_dir_for_opts, fmt!(\"Couldn't add in %s\", ws));\n+    git_commit(&work_dir_for_opts, ~\"whatever\");\n+    tmp\n }\n \n fn add_all_and_commit(repo: &Path) {\n@@ -164,51 +152,20 @@ fn add_all_and_commit(repo: &Path) {\n }\n \n fn git_commit(repo: &Path, msg: ~str) {\n-    let mut prog = run::Process::new(\"git\", [~\"commit\", ~\"-m\", msg],\n-                                     run::ProcessOptions { env: None,\n-                                                          dir: Some(repo),\n-                                                          in_fd: None,\n-                                                          out_fd: None,\n-                                                          err_fd: None\n-                                                         });\n-    let output = prog.finish_with_output();\n-    if output.status != 0 {\n-        fail!(\"Couldn't commit in %s: output was %s\", repo.to_str(),\n-              str::from_bytes(output.output + output.error))\n-    }\n-\n+    run_git([~\"commit\", ~\"--author=tester <test@mozilla.com>\", ~\"-m\", msg],\n+            None, repo, fmt!(\"Couldn't commit in %s\", repo.to_str()));\n }\n \n fn git_add_all(repo: &Path) {\n-    let mut prog = run::Process::new(\"git\", [~\"add\", ~\"-A\"],\n-                                     run::ProcessOptions { env: None,\n-                                                          dir: Some(repo),\n-                                                          in_fd: None,\n-                                                          out_fd: None,\n-                                                          err_fd: None\n-                                                         });\n-    let output = prog.finish_with_output();\n-    if output.status != 0 {\n-        fail!(\"Couldn't add all files in %s: output was %s\",\n-              repo.to_str(), str::from_bytes(output.output + output.error))\n-    }\n+    run_git([~\"add\", ~\"-A\"], None, repo, fmt!(\"Couldn't add all files in %s\", repo.to_str()));\n }\n \n fn add_git_tag(repo: &Path, tag: ~str) {\n     assert!(repo.is_absolute());\n     git_add_all(repo);\n     git_commit(repo, ~\"whatever\");\n-    let mut prog = run::Process::new(\"git\", [~\"tag\", tag.clone()],\n-                                     run::ProcessOptions { env: None,\n-                                                          dir: Some(repo),\n-                                                          in_fd: None,\n-                                                          out_fd: None,\n-                                                          err_fd: None\n-                                                         });\n-    let output = prog.finish_with_output();\n-    if output.status != 0 {\n-        fail!(\"Couldn't add git tag %s in %s\", tag, repo.to_str())\n-    }\n+    run_git([~\"tag\", tag.clone()], None, repo,\n+            fmt!(\"Couldn't add git tag %s in %s\", tag, repo.to_str()));\n }\n \n fn is_rwx(p: &Path) -> bool {\n@@ -231,6 +188,25 @@ fn test_sysroot() -> Path {\n     self_path.pop()\n }\n \n+// Returns the path to rustpkg\n+fn rustpkg_exec() -> Path {\n+    // Ugh\n+    let first_try = test_sysroot().push(\"lib\").push(\"rustc\")\n+        .push(host_triple()).push(\"bin\").push(\"rustpkg\");\n+    if is_executable(&first_try) {\n+        first_try\n+    }\n+    else {\n+        let second_try = test_sysroot().push(\"bin\").push(\"rustpkg\");\n+        if is_executable(&second_try) {\n+            second_try\n+        }\n+        else {\n+            fail!(\"in rustpkg test, can't find an installed rustpkg\");\n+        }\n+    }\n+}\n+\n fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n     command_line_test_with_env(args, cwd, None)\n }\n@@ -240,8 +216,9 @@ fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n /// Returns the process's output.\n fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~str)]>)\n     -> ProcessOutput {\n-    let cmd = test_sysroot().push(\"bin\").push(\"rustpkg\").to_str();\n-    debug!(\"About to run command: %? %? in %s\", cmd, args, cwd.to_str());\n+    let cmd = rustpkg_exec().to_str();\n+    debug!(\"cd %s; %s %s\",\n+           cwd.to_str(), cmd, args.connect(\" \"));\n     assert!(os::path_is_dir(&*cwd));\n     let cwd = (*cwd).clone();\n     let mut prog = run::Process::new(cmd, args, run::ProcessOptions {\n@@ -263,14 +240,15 @@ So tests that use this need to check the existence of a file\n to make sure the command succeeded\n */\n     if output.status != 0 {\n-        fail!(\"Command %s %? failed with exit code %?\",\n-              cmd, args, output.status);\n+        fail!(\"Command %s %? failed with exit code %?; its output was {{{ %s }}}\",\n+              cmd, args, output.status,\n+              str::from_bytes(output.output) + str::from_bytes(output.error));\n     }\n     output\n }\n \n fn create_local_package(pkgid: &PkgId) -> Path {\n-    let parent_dir = mk_temp_workspace(&pkgid.local_path, &pkgid.version);\n+    let parent_dir = mk_temp_workspace(&pkgid.path, &pkgid.version);\n     debug!(\"Created empty package dir for %s, returning %s\", pkgid.to_str(), parent_dir.to_str());\n     parent_dir.pop().pop()\n }\n@@ -327,26 +305,26 @@ fn create_local_package_with_custom_build_hook(pkgid: &PkgId,\n \n }\n \n-fn assert_lib_exists(repo: &Path, short_name: &str, v: Version) {\n+fn assert_lib_exists(repo: &Path, short_name: &str, _v: Version) { // ??? version?\n     debug!(\"assert_lib_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n-    let lib = target_library_in_workspace(&(PkgId {\n-        version: v, ..PkgId::new(short_name, repo)}\n-                                           ), repo);\n-    debug!(\"assert_lib_exists: checking whether %s exists\", lib.to_str());\n-    assert!(os::path_exists(&lib));\n-    assert!(is_rwx(&lib));\n+    let lib = installed_library_in_workspace(short_name, repo);\n+    debug!(\"assert_lib_exists: checking whether %? exists\", lib);\n+    assert!(lib.is_some());\n+    let libname = lib.get_ref();\n+    assert!(os::path_exists(libname));\n+    assert!(is_rwx(libname));\n }\n \n fn assert_executable_exists(repo: &Path, short_name: &str) {\n     debug!(\"assert_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n-    let exec = target_executable_in_workspace(&PkgId::new(short_name, repo), repo);\n+    let exec = target_executable_in_workspace(&PkgId::new(short_name), repo);\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n }\n \n fn assert_built_executable_exists(repo: &Path, short_name: &str) {\n     debug!(\"assert_built_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n-    let exec = built_executable_in_workspace(&PkgId::new(short_name, repo),\n+    let exec = built_executable_in_workspace(&PkgId::new(short_name),\n                                              repo).expect(\"assert_built_executable_exists failed\");\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n@@ -372,11 +350,11 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n     result\n }\n \n-// assumes short_name and local_path are one and the same -- I should fix\n+// assumes short_name and path are one and the same -- I should fix\n fn lib_output_file_name(workspace: &Path, parent: &str, short_name: &str) -> Path {\n     debug!(\"lib_output_file_name: given %s and parent %s and short name %s\",\n            workspace.to_str(), parent, short_name);\n-    library_in_workspace(&normalize(RemotePath(Path(short_name))),\n+    library_in_workspace(&Path(short_name),\n                          short_name,\n                          Build,\n                          workspace,\n@@ -451,7 +429,7 @@ fn test_install_valid() {\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     let ctxt = fake_ctxt(Some(@sysroot));\n     let temp_pkg_id = fake_pkg();\n-    let temp_workspace = mk_temp_workspace(&temp_pkg_id.local_path, &NoVersion).pop().pop();\n+    let temp_workspace = mk_temp_workspace(&temp_pkg_id.path, &NoVersion).pop().pop();\n     debug!(\"temp_workspace = %s\", temp_workspace.to_str());\n     // should have test, bench, lib, and main\n     ctxt.install(&temp_workspace, &temp_pkg_id);\n@@ -504,7 +482,7 @@ fn test_install_git() {\n     let sysroot = test_sysroot();\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     let temp_pkg_id = git_repo_pkg();\n-    let repo = init_git_repo(&Path(temp_pkg_id.local_path.to_str()));\n+    let repo = init_git_repo(&temp_pkg_id.path);\n     let repo_subdir = repo.push(\"mockgithub.com\").push(\"catamorphism\").push(\"test_pkg\");\n     writeFile(&repo_subdir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -517,9 +495,9 @@ fn test_install_git() {\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n     debug!(\"test_install_git: calling rustpkg install %s in %s\",\n-           temp_pkg_id.local_path.to_str(), repo.to_str());\n+           temp_pkg_id.path.to_str(), repo.to_str());\n     // should have test, bench, lib, and main\n-    command_line_test([~\"install\", temp_pkg_id.local_path.to_str()], &repo);\n+    command_line_test([~\"install\", temp_pkg_id.path.to_str()], &repo);\n     // Check that all files exist\n     debug!(\"Checking for files in %s\", repo.to_str());\n     let exec = target_executable_in_workspace(&temp_pkg_id, &repo);\n@@ -563,18 +541,18 @@ fn test_package_ids_must_be_relative_path_like() {\n \n     */\n \n-    let whatever = PkgId::new(\"foo\", &os::getcwd());\n+    let whatever = PkgId::new(\"foo\");\n \n     assert_eq!(~\"foo-0.1\", whatever.to_str());\n-    assert!(\"github.com/catamorphism/test_pkg-0.1\" ==\n-            PkgId::new(\"github.com/catamorphism/test-pkg\", &os::getcwd()).to_str());\n+    assert!(\"github.com/catamorphism/test-pkg-0.1\" ==\n+            PkgId::new(\"github.com/catamorphism/test-pkg\").to_str());\n \n     do cond.trap(|(p, e)| {\n         assert!(\"\" == p.to_str());\n         assert!(\"0-length pkgid\" == e);\n         whatever.clone()\n     }).inside {\n-        let x = PkgId::new(\"\", &os::getcwd());\n+        let x = PkgId::new(\"\");\n         assert_eq!(~\"foo-0.1\", x.to_str());\n     }\n \n@@ -583,8 +561,7 @@ fn test_package_ids_must_be_relative_path_like() {\n         assert!(\"absolute pkgid\" == e);\n         whatever.clone()\n     }).inside {\n-        let z = PkgId::new(os::make_absolute(&Path(\"foo/bar/quux\")).to_str(),\n-                           &os::getcwd());\n+        let z = PkgId::new(os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n         assert_eq!(~\"foo-0.1\", z.to_str());\n     }\n \n@@ -607,7 +584,7 @@ fn test_package_version() {\n               \"#[bench] pub fn f() { (); }\");\n     add_git_tag(&repo_subdir, ~\"0.4\");\n \n-    let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version\", &repo);\n+    let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version\");\n     match temp_pkg_id.version {\n         ExactRevision(~\"0.4\") => (),\n         _ => fail!(fmt!(\"test_package_version: package version was %?, expected Some(0.4)\",\n@@ -656,7 +633,7 @@ fn test_package_request_version() {\n         }\n         None    => false\n     });\n-    let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version#0.3\", &repo);\n+    let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version#0.3\");\n     assert!(target_executable_in_workspace(&temp_pkg_id, &repo.push(\".rust\"))\n             == repo.push(\".rust\").push(\"bin\").push(\"test_pkg_version\"));\n \n@@ -696,12 +673,12 @@ fn rustpkg_library_target() {\n \n     add_git_tag(&package_dir, ~\"1.0\");\n     command_line_test([~\"install\", ~\"foo\"], &foo_repo);\n-    assert_lib_exists(&foo_repo, \"foo\", ExactRevision(~\"1.0\"));\n+    assert_lib_exists(&foo_repo.push(\".rust\"), \"foo\", ExactRevision(~\"1.0\"));\n }\n \n #[test]\n fn rustpkg_local_pkg() {\n-    let dir = create_local_package(&PkgId::new(\"foo\", &os::getcwd()));\n+    let dir = create_local_package(&PkgId::new(\"foo\"));\n     command_line_test([~\"install\", ~\"foo\"], &dir);\n     assert_executable_exists(&dir, \"foo\");\n }\n@@ -711,7 +688,7 @@ fn rustpkg_local_pkg() {\n #[test]\n #[ignore]\n fn package_script_with_default_build() {\n-    let dir = create_local_package(&PkgId::new(\"fancy-lib\", &os::getcwd()));\n+    let dir = create_local_package(&PkgId::new(\"fancy-lib\"));\n     debug!(\"dir = %s\", dir.to_str());\n     let source = test_sysroot().pop().pop().pop().push(\"src\").push(\"librustpkg\").\n         push(\"testsuite\").push(\"pass\").push(\"src\").push(\"fancy-lib\").push(\"pkg.rs\");\n@@ -763,22 +740,21 @@ fn rustpkg_clean_no_arg() {\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n     command_line_test([~\"clean\"], &package_dir);\n-    assert!(!built_executable_in_workspace(&PkgId::new(\"foo\", &package_dir),\n+    assert!(!built_executable_in_workspace(&PkgId::new(\"foo\"),\n                 &tmp).map_default(false, |m| { os::path_exists(m) }));\n }\n \n #[test]\n #[ignore (reason = \"Specifying env doesn't work -- see #8028\")]\n fn rust_path_test() {\n     let dir_for_path = mkdtemp(&os::tmpdir(), \"more_rust\").expect(\"rust_path_test failed\");\n-    let dir = mk_workspace(&dir_for_path, &normalize(RemotePath(Path(\"foo\"))), &NoVersion);\n+    let dir = mk_workspace(&dir_for_path, &Path(\"foo\"), &NoVersion);\n     debug!(\"dir = %s\", dir.to_str());\n     writeFile(&dir.push(\"main.rs\"), \"fn main() { let _x = (); }\");\n \n     let cwd = os::getcwd();\n     debug!(\"cwd = %s\", cwd.to_str());\n-    debug!(\"Running command: cd %s; RUST_LOG=rustpkg RUST_PATH=%s rustpkg install foo\",\n-           cwd.to_str(), dir_for_path.to_str());\n+                                     // use command_line_test_with_env\n     let mut prog = run::Process::new(\"rustpkg\",\n                                      [~\"install\", ~\"foo\"],\n                                      run::ProcessOptions { env: Some(&[(~\"RUST_LOG\",\n@@ -830,39 +806,38 @@ fn rust_path_parse() {\n #[test]\n fn test_list() {\n     let dir = mkdtemp(&os::tmpdir(), \"test_list\").expect(\"test_list failed\");\n-    let foo = PkgId::new(\"foo\", &dir);\n+    let foo = PkgId::new(\"foo\");\n     create_local_package_in(&foo, &dir);\n-    let bar = PkgId::new(\"bar\", &dir);\n+    let bar = PkgId::new(\"bar\");\n     create_local_package_in(&bar, &dir);\n-    let quux = PkgId::new(\"quux\", &dir);\n+    let quux = PkgId::new(\"quux\");\n     create_local_package_in(&quux, &dir);\n \n-// NOTE Not really great output, though...\n-// NOTE do any tests need to be unignored?\n+// list doesn't output very much right now...\n     command_line_test([~\"install\", ~\"foo\"], &dir);\n     let env_arg = ~[(~\"RUST_PATH\", dir.to_str())];\n     debug!(\"RUST_PATH = %s\", dir.to_str());\n     let list_output = command_line_test_output_with_env([~\"list\"], env_arg.clone());\n-    assert!(list_output.iter().any(|x| x.starts_with(\"libfoo_\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n \n     command_line_test([~\"install\", ~\"bar\"], &dir);\n     let list_output = command_line_test_output_with_env([~\"list\"], env_arg.clone());\n-    assert!(list_output.iter().any(|x| x.starts_with(\"libfoo_\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"libbar_\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"bar\")));\n \n     command_line_test([~\"install\", ~\"quux\"], &dir);\n     let list_output = command_line_test_output_with_env([~\"list\"], env_arg);\n-    assert!(list_output.iter().any(|x| x.starts_with(\"libfoo_\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"libbar_\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"libquux_\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"bar\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"quux\")));\n }\n \n #[test]\n fn install_remove() {\n     let dir = mkdtemp(&os::tmpdir(), \"install_remove\").expect(\"install_remove\");\n-    let foo = PkgId::new(\"foo\", &dir);\n-    let bar = PkgId::new(\"bar\", &dir);\n-    let quux = PkgId::new(\"quux\", &dir);\n+    let foo = PkgId::new(\"foo\");\n+    let bar = PkgId::new(\"bar\");\n+    let quux = PkgId::new(\"quux\");\n     create_local_package_in(&foo, &dir);\n     create_local_package_in(&bar, &dir);\n     create_local_package_in(&quux, &dir);\n@@ -887,15 +862,15 @@ fn install_check_duplicates() {\n     // (\"Is already installed -- doing nothing\")\n     // check invariant that there are no dups in the pkg database\n     let dir = mkdtemp(&os::tmpdir(), \"install_remove\").expect(\"install_remove\");\n-    let foo = PkgId::new(\"foo\", &dir);\n+    let foo = PkgId::new(\"foo\");\n     create_local_package_in(&foo, &dir);\n \n     command_line_test([~\"install\", ~\"foo\"], &dir);\n     command_line_test([~\"install\", ~\"foo\"], &dir);\n     let mut contents = ~[];\n     let check_dups = |p: &PkgId| {\n         if contents.contains(p) {\n-            fail!(\"package %s appears in `list` output more than once\", p.local_path.to_str());\n+            fail!(\"package %s appears in `list` output more than once\", p.path.to_str());\n         }\n         else {\n             contents.push((*p).clone());\n@@ -908,7 +883,7 @@ fn install_check_duplicates() {\n #[test]\n #[ignore(reason = \"Workcache not yet implemented -- see #7075\")]\n fn no_rebuilding() {\n-    let p_id = PkgId::new(\"foo\", &os::getcwd());\n+    let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let date = datestamp(&built_library_in_workspace(&p_id,\n@@ -922,8 +897,8 @@ fn no_rebuilding() {\n #[test]\n #[ignore(reason = \"Workcache not yet implemented -- see #7075\")]\n fn no_rebuilding_dep() {\n-    let p_id = PkgId::new(\"foo\", &os::getcwd());\n-    let dep_id = PkgId::new(\"bar\", &os::getcwd());\n+    let p_id = PkgId::new(\"foo\");\n+    let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let bar_date = datestamp(&lib_output_file_name(&workspace,\n@@ -935,8 +910,8 @@ fn no_rebuilding_dep() {\n \n #[test]\n fn do_rebuild_dep_dates_change() {\n-    let p_id = PkgId::new(\"foo\", &os::getcwd());\n-    let dep_id = PkgId::new(\"bar\", &os::getcwd());\n+    let p_id = PkgId::new(\"foo\");\n+    let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n@@ -948,8 +923,8 @@ fn do_rebuild_dep_dates_change() {\n \n #[test]\n fn do_rebuild_dep_only_contents_change() {\n-    let p_id = PkgId::new(\"foo\", &os::getcwd());\n-    let dep_id = PkgId::new(\"bar\", &os::getcwd());\n+    let p_id = PkgId::new(\"foo\");\n+    let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n@@ -962,8 +937,8 @@ fn do_rebuild_dep_only_contents_change() {\n \n #[test]\n fn test_versions() {\n-    let workspace = create_local_package(&PkgId::new(\"foo#0.1\", &os::getcwd()));\n-    create_local_package(&PkgId::new(\"foo#0.2\", &os::getcwd()));\n+    let workspace = create_local_package(&PkgId::new(\"foo#0.1\"));\n+    create_local_package(&PkgId::new(\"foo#0.2\"));\n     command_line_test([~\"install\", ~\"foo#0.1\"], &workspace);\n     let output = command_line_test_output([~\"list\"]);\n     // make sure output includes versions\n@@ -973,7 +948,7 @@ fn test_versions() {\n #[test]\n #[ignore(reason = \"do not yet implemented\")]\n fn test_build_hooks() {\n-    let workspace = create_local_package_with_custom_build_hook(&PkgId::new(\"foo\", &os::getcwd()),\n+    let workspace = create_local_package_with_custom_build_hook(&PkgId::new(\"foo\"),\n                                                                 \"frob\");\n     command_line_test([~\"do\", ~\"foo\", ~\"frob\"], &workspace);\n }\n@@ -983,7 +958,7 @@ fn test_build_hooks() {\n #[ignore(reason = \"info not yet implemented\")]\n fn test_info() {\n     let expected_info = ~\"package foo\"; // fill in\n-    let workspace = create_local_package(&PkgId::new(\"foo\", &os::getcwd()));\n+    let workspace = create_local_package(&PkgId::new(\"foo\"));\n     let output = command_line_test([~\"info\", ~\"foo\"], &workspace);\n     assert_eq!(str::from_bytes(output.output), expected_info);\n }\n@@ -992,15 +967,15 @@ fn test_info() {\n #[ignore(reason = \"test not yet implemented\")]\n fn test_rustpkg_test() {\n     let expected_results = ~\"1 out of 1 tests passed\"; // fill in\n-    let workspace = create_local_package_with_test(&PkgId::new(\"foo\", &os::getcwd()));\n+    let workspace = create_local_package_with_test(&PkgId::new(\"foo\"));\n     let output = command_line_test([~\"test\", ~\"foo\"], &workspace);\n     assert_eq!(str::from_bytes(output.output), expected_results);\n }\n \n #[test]\n #[ignore(reason = \"test not yet implemented\")]\n fn test_uninstall() {\n-    let workspace = create_local_package(&PkgId::new(\"foo\", &os::getcwd()));\n+    let workspace = create_local_package(&PkgId::new(\"foo\"));\n     let _output = command_line_test([~\"info\", ~\"foo\"], &workspace);\n     command_line_test([~\"uninstall\", ~\"foo\"], &workspace);\n     let output = command_line_test([~\"list\"], &workspace);\n@@ -1010,8 +985,8 @@ fn test_uninstall() {\n #[test]\n fn test_non_numeric_tag() {\n     let temp_pkg_id = git_repo_pkg();\n-    let repo = init_git_repo(&Path(temp_pkg_id.local_path.to_str()));\n-    let repo_subdir = repo.push(\"mockgithub.com\").push(\"catamorphism\").push(\"test_pkg\");\n+    let repo = init_git_repo(&temp_pkg_id.path);\n+    let repo_subdir = repo.push(\"mockgithub.com\").push(\"catamorphism\").push(\"test-pkg\");\n     writeFile(&repo_subdir.push(\"foo\"), \"foo\");\n     writeFile(&repo_subdir.push(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n@@ -1021,13 +996,70 @@ fn test_non_numeric_tag() {\n     writeFile(&repo_subdir.push(\"not_on_testbranch_only\"), \"bye bye\");\n     add_all_and_commit(&repo_subdir);\n \n-\n-    command_line_test([~\"install\", fmt!(\"%s#testbranch\", temp_pkg_id.remote_path.to_str())],\n-                      &repo);\n+    command_line_test([~\"install\", fmt!(\"%s#testbranch\", temp_pkg_id.path.to_str())], &repo);\n     let file1 = repo.push_many([\"mockgithub.com\", \"catamorphism\",\n-                                \"test_pkg\", \"testbranch_only\"]);\n-    let file2 = repo.push_many([\"mockgithub.com\", \"catamorphism\", \"test_pkg\",\n+                                \"test-pkg\", \"testbranch_only\"]);\n+    let file2 = repo.push_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\",\n                                 \"master_only\"]);\n     assert!(os::path_exists(&file1));\n     assert!(!os::path_exists(&file2));\n }\n+\n+#[test]\n+fn test_extern_mod() {\n+    let dir = mkdtemp(&os::tmpdir(), \"test_extern_mod\").expect(\"test_extern_mod\");\n+    let main_file = dir.push(\"main.rs\");\n+    let lib_depend_dir = mkdtemp(&os::tmpdir(), \"foo\").expect(\"test_extern_mod\");\n+    let aux_dir = lib_depend_dir.push_many([\"src\", \"mockgithub.com\", \"catamorphism\", \"test_pkg\"]);\n+    assert!(os::mkdir_recursive(&aux_dir, U_RWX));\n+    let aux_pkg_file = aux_dir.push(\"lib.rs\");\n+\n+    writeFile(&aux_pkg_file, \"pub mod bar { pub fn assert_true() {  assert!(true); } }\\n\");\n+    assert!(os::path_exists(&aux_pkg_file));\n+\n+    writeFile(&main_file,\n+              \"extern mod test = \\\"mockgithub.com/catamorphism/test_pkg\\\";\\nuse test::bar;\\\n+               fn main() { bar::assert_true(); }\\n\");\n+\n+    command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg\"], &lib_depend_dir);\n+\n+    let exec_file = dir.push(\"out\");\n+    // Be sure to extend the existing environment\n+    let env = Some([(~\"RUST_PATH\", lib_depend_dir.to_str())] + os::env());\n+    let rustpkg_exec = rustpkg_exec();\n+    let rustc = rustpkg_exec.with_filename(\"rustc\");\n+    debug!(\"RUST_PATH=%s %s %s \\n --sysroot %s -o %s\",\n+                     lib_depend_dir.to_str(),\n+                     rustc.to_str(),\n+                     main_file.to_str(),\n+                     test_sysroot().to_str(),\n+                     exec_file.to_str());\n+\n+    let mut prog = run::Process::new(rustc.to_str(), [main_file.to_str(),\n+                                                      ~\"--sysroot\", test_sysroot().to_str(),\n+                                               ~\"-o\", exec_file.to_str()],\n+                                     run::ProcessOptions {\n+        env: env.map(|v| v.slice(0, v.len())),\n+        dir: Some(&dir),\n+        in_fd: None,\n+        out_fd: None,\n+        err_fd: None\n+    });\n+    let outp = prog.finish_with_output();\n+    if outp.status != 0 {\n+        fail!(\"output was %s, error was %s\",\n+              str::from_bytes(outp.output),\n+              str::from_bytes(outp.error));\n+    }\n+    assert!(os::path_exists(&exec_file) && is_executable(&exec_file));\n+}\n+\n+/// Returns true if p exists and is executable\n+fn is_executable(p: &Path) -> bool {\n+    use std::libc::consts::os::posix88::{S_IXUSR};\n+\n+    match p.get_mode() {\n+        None => false,\n+        Some(mode) => mode & S_IXUSR as uint == S_IXUSR as uint\n+    }\n+}"}, {"sha": "afac9423fba66027da5112787412f681a96f3bb2", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 64, "deletions": 42, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{os, result};\n+use std::os;\n use rustc::driver::{driver, session};\n-use rustc::metadata::filesearch;\n use extra::getopts::groups::getopts;\n use syntax::ast_util::*;\n use syntax::codemap::{dummy_sp, spanned};\n@@ -19,10 +18,10 @@ use syntax::{ast, attr, codemap, diagnostic, fold};\n use syntax::attr::AttrMetaMethods;\n use rustc::back::link::output_type_exe;\n use rustc::driver::session::{lib_crate, bin_crate};\n-use context::Ctx;\n+use context::{Ctx, in_target};\n use package_id::PkgId;\n use search::find_library_in_search_path;\n-use path_util::target_library_in_workspace;\n+use path_util::{target_library_in_workspace, U_RWX};\n pub use target::{OutputType, Main, Lib, Bench, Test};\n \n // It would be nice to have the list of commands in just one place -- for example,\n@@ -47,13 +46,6 @@ impl ToStr for Pkg {\n     }\n }\n \n-pub fn root() -> Path {\n-    match filesearch::get_rustpkg_root() {\n-        result::Ok(path) => path,\n-        result::Err(err) => fail!(err)\n-    }\n-}\n-\n pub fn is_cmd(cmd: &str) -> bool {\n     COMMANDS.iter().any(|&c| c == cmd)\n }\n@@ -162,25 +154,25 @@ pub fn ready_crate(sess: session::Session,\n pub fn compile_input(ctxt: &Ctx,\n                      pkg_id: &PkgId,\n                      in_file: &Path,\n-                     out_dir: &Path,\n+                     workspace: &Path,\n                      flags: &[~str],\n                      cfgs: &[~str],\n                      opt: bool,\n                      what: OutputType) -> bool {\n \n-    let workspace = out_dir.pop().pop();\n-\n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input((*in_file).clone());\n     debug!(\"compile_input: %s / %?\", in_file.to_str(), what);\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n+    let out_dir = workspace.push(\"build\").push_rel(&pkg_id.path);\n+\n     let binary = os::args()[0].to_managed();\n \n     debug!(\"flags: %s\", flags.connect(\" \"));\n     debug!(\"cfgs: %s\", cfgs.connect(\" \"));\n-    debug!(\"compile_input's sysroot = %?\", ctxt.sysroot_opt);\n+    debug!(\"out_dir = %s\", out_dir.to_str());\n \n     let crate_type = match what {\n         Lib => lib_crate,\n@@ -196,12 +188,22 @@ pub fn compile_input(ctxt: &Ctx,\n                           + flags\n                           + cfgs.flat_map(|c| { ~[~\"--cfg\", (*c).clone()] }),\n                           driver::optgroups()).unwrap();\n+    // Hack so that rustpkg can run either out of a rustc target dir,\n+    // or the host dir\n+    let sysroot_to_use = if !in_target(ctxt.sysroot_opt) {\n+        ctxt.sysroot_opt\n+    }\n+    else {\n+        ctxt.sysroot_opt.map(|p| { @p.pop().pop().pop() })\n+    };\n+    debug!(\"compile_input's sysroot = %?\", ctxt.sysroot_opt_str());\n+    debug!(\"sysroot_to_use = %?\", sysroot_to_use);\n     let options = @session::options {\n         crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: what == Test || what == Bench,\n-        maybe_sysroot: ctxt.sysroot_opt,\n-        addl_lib_search_paths: @mut (~[(*out_dir).clone()]),\n+        maybe_sysroot: sysroot_to_use,\n+        addl_lib_search_paths: @mut (~[out_dir.clone()]),\n         // output_type should be conditional\n         output_type: output_type_exe, // Use this to get a library? That's weird\n         .. (*driver::build_session_options(binary, &matches, diagnostic::emit)).clone()\n@@ -211,7 +213,12 @@ pub fn compile_input(ctxt: &Ctx,\n     // Make sure all the library directories actually exist, since the linker will complain\n     // otherwise\n     for p in addl_lib_search_paths.iter() {\n-        assert!(os::path_is_dir(p));\n+        if os::path_exists(p) {\n+            assert!(os::path_is_dir(p));\n+        }\n+        else {\n+            assert!(os::mkdir_recursive(p, U_RWX));\n+        }\n     }\n \n     let sess = driver::build_session(options, diagnostic::emit);\n@@ -224,35 +231,44 @@ pub fn compile_input(ctxt: &Ctx,\n \n     // Not really right. Should search other workspaces too, and the installed\n     // database (which doesn't exist yet)\n-    find_and_install_dependencies(ctxt, sess, &workspace, crate,\n+    find_and_install_dependencies(ctxt, sess, workspace, crate,\n                                   |p| {\n                                       debug!(\"a dependency: %s\", p.to_str());\n                                       // Pass the directory containing a dependency\n                                       // as an additional lib search path\n-                                      addl_lib_search_paths.push(p);\n+                                      if !addl_lib_search_paths.contains(&p) {\n+                                          // Might be inefficient, but this set probably\n+                                          // won't get too large -- tjc\n+                                          addl_lib_search_paths.push(p);\n+                                      }\n                                   });\n \n     // Inject the link attributes so we get the right package name and version\n     if attr::find_linkage_metas(crate.attrs).is_empty() {\n-        let short_name_to_use = match what {\n-            Test  => fmt!(\"%stest\", pkg_id.short_name),\n-            Bench => fmt!(\"%sbench\", pkg_id.short_name),\n-            _     => pkg_id.short_name.clone()\n+        let name_to_use = match what {\n+            Test  => fmt!(\"%stest\", pkg_id.short_name).to_managed(),\n+            Bench => fmt!(\"%sbench\", pkg_id.short_name).to_managed(),\n+            _     => pkg_id.short_name.to_managed()\n         };\n-        debug!(\"Injecting link name: %s\", short_name_to_use);\n+        debug!(\"Injecting link name: %s\", name_to_use);\n         let link_options =\n-            ~[attr::mk_name_value_item_str(@\"name\", short_name_to_use.to_managed()),\n-              attr::mk_name_value_item_str(@\"vers\", pkg_id.version.to_str().to_managed())];\n-\n+            ~[attr::mk_name_value_item_str(@\"name\", name_to_use),\n+              attr::mk_name_value_item_str(@\"vers\", pkg_id.version.to_str().to_managed())] +\n+                        if pkg_id.is_complex() {\n+                        ~[attr::mk_name_value_item_str(@\"package_id\",\n+                                                       pkg_id.path.to_str().to_managed())]\n+                } else { ~[] };\n+\n+        debug!(\"link options: %?\", link_options);\n         crate = @ast::Crate {\n             attrs: ~[attr::mk_attr(attr::mk_list_item(@\"link\", link_options))],\n             .. (*crate).clone()\n-        };\n+        }\n     }\n \n-    debug!(\"calling compile_crate_from_input, out_dir = %s,\n+    debug!(\"calling compile_crate_from_input, workspace = %s,\n            building_library = %?\", out_dir.to_str(), sess.building_library);\n-    compile_crate_from_input(&input, out_dir, sess, crate);\n+    compile_crate_from_input(&input, &out_dir, sess, crate);\n     true\n }\n \n@@ -262,17 +278,22 @@ pub fn compile_input(ctxt: &Ctx,\n // call compile_upto and return the crate\n // also, too many arguments\n pub fn compile_crate_from_input(input: &driver::input,\n-                                build_dir: &Path,\n+ // should be of the form <workspace>/build/<pkg id's path>\n+                                out_dir: &Path,\n                                 sess: session::Session,\n                                 crate: @ast::Crate) {\n     debug!(\"Calling build_output_filenames with %s, building library? %?\",\n-           build_dir.to_str(), sess.building_library);\n+           out_dir.to_str(), sess.building_library);\n \n     // bad copy\n-    let outputs = driver::build_output_filenames(input, &Some((*build_dir).clone()), &None,\n+    debug!(\"out_dir = %s\", out_dir.to_str());\n+    let outputs = driver::build_output_filenames(input, &Some(out_dir.clone()), &None,\n                                                  crate.attrs, sess);\n \n-    debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n+    debug!(\"Outputs are out_filename: %s and obj_filename: %s and output type = %?\",\n+           outputs.out_filename.to_str(),\n+           outputs.obj_filename.to_str(),\n+           sess.opts.output_type);\n     debug!(\"additional libraries:\");\n     for lib in sess.opts.addl_lib_search_paths.iter() {\n         debug!(\"an additional library: %s\", lib.to_str());\n@@ -298,15 +319,15 @@ pub fn exe_suffix() -> ~str { ~\"\" }\n // Called by build_crates\n // FIXME (#4432): Use workcache to only compile when needed\n pub fn compile_crate(ctxt: &Ctx, pkg_id: &PkgId,\n-                     crate: &Path, dir: &Path,\n+                     crate: &Path, workspace: &Path,\n                      flags: &[~str], cfgs: &[~str], opt: bool,\n                      what: OutputType) -> bool {\n-    debug!(\"compile_crate: crate=%s, dir=%s\", crate.to_str(), dir.to_str());\n+    debug!(\"compile_crate: crate=%s, workspace=%s\", crate.to_str(), workspace.to_str());\n     debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n     for fl in flags.iter() {\n         debug!(\"+++ %s\", *fl);\n     }\n-    compile_input(ctxt, pkg_id, crate, dir, flags, cfgs, opt, what)\n+    compile_input(ctxt, pkg_id, crate, workspace, flags, cfgs, opt, what)\n }\n \n \n@@ -327,19 +348,20 @@ pub fn find_and_install_dependencies(ctxt: &Ctx,\n         debug!(\"A view item!\");\n         match vi.node {\n             // ignore metadata, I guess\n-            ast::view_item_extern_mod(lib_ident, _, _) => {\n+            ast::view_item_extern_mod(lib_ident, path_opt, _, _) => {\n                 match my_ctxt.sysroot_opt {\n-                    Some(ref x) => debug!(\"sysroot: %s\", x.to_str()),\n+                    Some(ref x) => debug!(\"*** sysroot: %s\", x.to_str()),\n                     None => debug!(\"No sysroot given\")\n                 };\n-                let lib_name = sess.str_of(lib_ident);\n+                let lib_name = match path_opt { // ???\n+                    Some(p) => p, None => sess.str_of(lib_ident) };\n                 match find_library_in_search_path(my_ctxt.sysroot_opt, lib_name) {\n                     Some(installed_path) => {\n                         debug!(\"It exists: %s\", installed_path.to_str());\n                     }\n                     None => {\n                         // Try to install it\n-                        let pkg_id = PkgId::new(lib_name, &os::getcwd());\n+                        let pkg_id = PkgId::new(lib_name);\n                         my_ctxt.install(&my_workspace, &pkg_id);\n                         // Also, add an additional search path\n                         debug!(\"let installed_path...\")"}, {"sha": "ab4f47ba69abcf600ec6c0b030c901480c27b69b", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -15,8 +15,8 @@ extern mod std;\n \n use extra::semver;\n use std::{char, os, result, run, str};\n-use package_path::RemotePath;\n use extra::tempfile::mkdtemp;\n+use path_util::rust_path;\n \n #[deriving(Clone)]\n pub enum Version {\n@@ -92,34 +92,42 @@ pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n     }\n }\n \n-/// If `local_path` is a git repo, and the most recent tag in that repo denotes a version,\n-/// return it; otherwise, `None`\n+/// If `local_path` is a git repo in the RUST_PATH, and the most recent tag\n+/// in that repo denotes a version, return it; otherwise, `None`\n pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n-    debug!(\"in try_getting_local_version\");\n-    let outp = run::process_output(\"git\",\n+    let rustpath = rust_path();\n+    for rp in rustpath.iter() {\n+        let local_path = rp.push_rel(local_path);\n+        debug!(\"in try_getting_local_version\");\n+        let outp = run::process_output(\"git\",\n                                    [fmt!(\"--git-dir=%s\", local_path.push(\".git\").to_str()),\n                                     ~\"tag\", ~\"-l\"]);\n \n-    debug!(\"git --git-dir=%s tag -l ~~~> %?\", local_path.push(\".git\").to_str(), outp.status);\n+        debug!(\"git --git-dir=%s tag -l ~~~> %?\", local_path.push(\".git\").to_str(), outp.status);\n \n-    if outp.status != 0 {\n-        return None;\n-    }\n+        if outp.status != 0 {\n+            loop;\n+        }\n \n     let mut output = None;\n     let output_text = str::from_bytes(outp.output);\n     for l in output_text.line_iter() {\n         if !l.is_whitespace() {\n             output = Some(l);\n         }\n+        match output.chain(try_parsing_version) {\n+            Some(v) => return Some(v),\n+            None    => ()\n+        }\n     }\n-    output.chain(try_parsing_version)\n+  }\n+  None\n }\n \n /// If `remote_path` refers to a git repo that can be downloaded,\n /// and the most recent tag in that repo denotes a version, return it;\n /// otherwise, `None`\n-pub fn try_getting_version(remote_path: &RemotePath) -> Option<Version> {\n+pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n     debug!(\"try_getting_version: %s\", remote_path.to_str());\n     if is_url_like(remote_path) {\n         debug!(\"Trying to fetch its sources..\");\n@@ -190,7 +198,7 @@ fn try_parsing_version(s: &str) -> Option<Version> {\n }\n \n /// Just an approximation\n-fn is_url_like(p: &RemotePath) -> bool {\n+fn is_url_like(p: &Path) -> bool {\n     let str = p.to_str();\n     str.split_iter('/').len_() > 2\n }"}, {"sha": "3e0e08dfe2d7c3d7efc5c7b1c74e3962fc788897", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -12,9 +12,11 @@\n \n use std::os;\n use std::path::Path;\n-use path_util::{rust_path, workspace_contains_package_id};\n+use path_util::workspace_contains_package_id;\n use package_id::PkgId;\n \n+use rustc::metadata::filesearch::rust_path;\n+\n pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n     // Using the RUST_PATH, find workspaces that contain\n     // this package ID\n@@ -23,7 +25,7 @@ pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> b\n         // tjc: make this a condition\n         fail!(\"Package %s not found in any of \\\n                     the following workspaces: %s\",\n-                   pkgid.remote_path.to_str(),\n+                   pkgid.path.to_str(),\n                    rust_path().to_str());\n     }\n     for ws in workspaces.iter() {\n@@ -58,5 +60,5 @@ pub fn cwd_to_workspace() -> (Path, PkgId) {\n     let ws = cwd.pop().pop();\n     let cwd_ = cwd.clone();\n     let pkgid = cwd_.components.last().to_str();\n-    (ws, PkgId::new(pkgid, &cwd))\n+    (ws, PkgId::new(pkgid))\n }"}, {"sha": "598e808061839f683c0fac6a3d8ec74afb54b4ac", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -284,12 +284,6 @@ impl Not<bool> for bool {\n impl Ord for bool {\n     #[inline]\n     fn lt(&self, other: &bool) -> bool { to_bit(*self) < to_bit(*other) }\n-    #[inline]\n-    fn le(&self, other: &bool) -> bool { to_bit(*self) <= to_bit(*other) }\n-    #[inline]\n-    fn gt(&self, other: &bool) -> bool { to_bit(*self) > to_bit(*other) }\n-    #[inline]\n-    fn ge(&self, other: &bool) -> bool { to_bit(*self) >= to_bit(*other) }\n }\n \n #[cfg(not(test))]"}, {"sha": "9c55e22b1f833794a0cd70548de8140c757021d8", "filename": "src/libstd/char.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -322,12 +322,6 @@ impl Eq for char {\n impl Ord for char {\n     #[inline]\n     fn lt(&self, other: &char) -> bool { *self < *other }\n-    #[inline]\n-    fn le(&self, other: &char) -> bool { *self <= *other }\n-    #[inline]\n-    fn gt(&self, other: &char) -> bool { *self > *other }\n-    #[inline]\n-    fn ge(&self, other: &char) -> bool { *self >= *other }\n }\n \n #[cfg(not(test))]"}, {"sha": "28d45abb6881f0dc8190c96f5a97865273f031f5", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -101,12 +101,6 @@ impl TotalOrd for Ordering {\n impl Ord for Ordering {\n     #[inline]\n     fn lt(&self, other: &Ordering) -> bool { (*self as int) < (*other as int) }\n-    #[inline]\n-    fn le(&self, other: &Ordering) -> bool { (*self as int) <= (*other as int) }\n-    #[inline]\n-    fn gt(&self, other: &Ordering) -> bool { (*self as int) > (*other as int) }\n-    #[inline]\n-    fn ge(&self, other: &Ordering) -> bool { (*self as int) >= (*other as int) }\n }\n \n macro_rules! totalord_impl(\n@@ -174,8 +168,11 @@ pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n #[lang=\"ord\"]\n pub trait Ord {\n     fn lt(&self, other: &Self) -> bool;\n+    #[inline]\n     fn le(&self, other: &Self) -> bool { !other.lt(self) }\n+    #[inline]\n     fn gt(&self, other: &Self) -> bool {  other.lt(self) }\n+    #[inline]\n     fn ge(&self, other: &Self) -> bool { !self.lt(other) }\n }\n "}, {"sha": "3507dc9d2b233543bdf76c6f2cb31f43d2cfd548", "filename": "src/libstd/nil.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fnil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fnil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnil.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -33,12 +33,6 @@ impl Eq for () {\n impl Ord for () {\n     #[inline]\n     fn lt(&self, _other: &()) -> bool { false }\n-    #[inline]\n-    fn le(&self, _other: &()) -> bool { true }\n-    #[inline]\n-    fn ge(&self, _other: &()) -> bool { true }\n-    #[inline]\n-    fn gt(&self, _other: &()) -> bool { false }\n }\n \n #[cfg(not(test))]"}, {"sha": "41da9a6ccbe481a3a559e588a9bc4de5d642ca55", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -130,12 +130,6 @@ impl Num for $T {}\n impl Ord for $T {\n     #[inline]\n     fn lt(&self, other: &$T) -> bool { return (*self) < (*other); }\n-    #[inline]\n-    fn le(&self, other: &$T) -> bool { return (*self) <= (*other); }\n-    #[inline]\n-    fn ge(&self, other: &$T) -> bool { return (*self) >= (*other); }\n-    #[inline]\n-    fn gt(&self, other: &$T) -> bool { return (*self) > (*other); }\n }\n \n #[cfg(not(test))]"}, {"sha": "86b5b4ddfc09f4318f5fd94dc2f9ad859014c5ac", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -131,12 +131,6 @@ impl Num for $T {}\n impl Ord for $T {\n     #[inline]\n     fn lt(&self, other: &$T) -> bool { (*self) < (*other) }\n-    #[inline]\n-    fn le(&self, other: &$T) -> bool { (*self) <= (*other) }\n-    #[inline]\n-    fn ge(&self, other: &$T) -> bool { (*self) >= (*other) }\n-    #[inline]\n-    fn gt(&self, other: &$T) -> bool { (*self) > (*other) }\n }\n \n #[cfg(not(test))]"}, {"sha": "7def75907f8c18dbf82b7ac4ba48920f833cfb06", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -1152,9 +1152,9 @@ pub fn real_args() -> ~[~str] {\n #[cfg(target_os = \"freebsd\")]\n pub fn real_args() -> ~[~str] {\n     use rt;\n-    use rt::TaskContext;\n+    use rt::NewRtContext;\n \n-    if rt::context() == TaskContext {\n+    if rt::context() == NewRtContext {\n         match rt::args::clone() {\n             Some(args) => args,\n             None => fail!(\"process arguments not initialized\")"}, {"sha": "14844e24006c5364b5f6d809bd557e0c28dc5ff4", "filename": "src/libstd/path.rs", "status": "modified", "additions": 163, "deletions": 2, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -21,13 +21,14 @@ use c_str;\n use clone::Clone;\n use cmp::Eq;\n use container::Container;\n-use iterator::{Iterator, IteratorUtil};\n+use iterator::{Iterator, IteratorUtil, range};\n use libc;\n+use num;\n use option::{None, Option, Some};\n use str::{OwnedStr, Str, StrSlice, StrVector};\n use to_str::ToStr;\n use ascii::{AsciiCast, AsciiStr};\n-use vec::{OwnedVector, ImmutableVector};\n+use vec::{OwnedVector, ImmutableVector, OwnedCopyableVector};\n \n #[cfg(windows)]\n pub use Path = self::WindowsPath;\n@@ -126,6 +127,43 @@ pub trait GenericPath {\n \n     /// True if `self` is an ancestor of `other`. See `test_is_ancestor_of` for examples\n     fn is_ancestor_of(&self, (&Self)) -> bool;\n+\n+    /// Find the relative path from one file to another\n+    fn get_relative_to(&self, abs2: (&Self)) -> Self {\n+        assert!(self.is_absolute());\n+        assert!(abs2.is_absolute());\n+        let abs1 = self.normalize();\n+        let abs2 = abs2.normalize();\n+\n+        let split1: &[~str] = abs1.components();\n+        let split2: &[~str] = abs2.components();\n+        let len1 = split1.len();\n+        let len2 = split2.len();\n+        assert!(len1 > 0);\n+        assert!(len2 > 0);\n+\n+        let max_common_path = num::min(len1, len2) - 1;\n+        let mut start_idx = 0;\n+        while start_idx < max_common_path\n+            && split1[start_idx] == split2[start_idx] {\n+            start_idx += 1;\n+        }\n+\n+        let mut path: ~[~str] = ~[];\n+        for _ in range(start_idx, len1 - 1) { path.push(~\"..\"); };\n+\n+        path.push_all(split2.slice(start_idx, len2 - 1));\n+\n+        let mut result: Self = GenericPath::from_str(\".\");\n+        if !path.is_empty() {\n+            // Without this type hint, the typechecker doesn't seem to like it\n+            let p: Self = GenericPath::from_str(\"\");\n+            result = p.push_many(path);\n+        };\n+        result\n+    }\n+\n+    fn components(self) -> ~[~str];\n }\n \n #[cfg(target_os = \"linux\")]\n@@ -711,6 +749,7 @@ impl GenericPath for PosixPath {\n              self.is_ancestor_of(&other.pop()))\n     }\n \n+   fn components(self) -> ~[~str] { self.components }\n }\n \n \n@@ -998,6 +1037,8 @@ impl GenericPath for WindowsPath {\n             (!other.components.is_empty() && !(self.components.is_empty() && !self.is_absolute) &&\n              self.is_ancestor_of(&other.pop()))\n     }\n+\n+   fn components(self) -> ~[~str] { self.components }\n }\n \n pub fn normalize(components: &[~str]) -> ~[~str] {\n@@ -1354,4 +1395,124 @@ mod tests {\n \n     }\n \n+    #[test]\n+    fn test_relative_to1() {\n+        let p1 = PosixPath(\"/usr/bin/rustc\");\n+        let p2 = PosixPath(\"/usr/lib/mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, PosixPath(\"../lib\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\usr\\\\bin\\\\rustc\");\n+        let p2 = WindowsPath(\"C:\\\\usr\\\\lib\\\\mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, WindowsPath(\"..\\\\lib\"));\n+\n+    }\n+\n+    #[test]\n+    fn test_relative_to2() {\n+        let p1 = PosixPath(\"/usr/bin/rustc\");\n+        let p2 = PosixPath(\"/usr/bin/../lib/mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, PosixPath(\"../lib\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\usr\\\\bin\\\\rustc\");\n+        let p2 = WindowsPath(\"C:\\\\usr\\\\bin\\\\..\\\\lib\\\\mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, WindowsPath(\"..\\\\lib\"));\n+    }\n+\n+    #[test]\n+    fn test_relative_to3() {\n+        let p1 = PosixPath(\"/usr/bin/whatever/rustc\");\n+        let p2 = PosixPath(\"/usr/lib/whatever/mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, PosixPath(\"../../lib/whatever\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\usr\\\\bin\\\\whatever\\\\rustc\");\n+        let p2 = WindowsPath(\"C:\\\\usr\\\\lib\\\\whatever\\\\mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, WindowsPath(\"..\\\\..\\\\lib\\\\whatever\"));\n+\n+    }\n+\n+    #[test]\n+    fn test_relative_to4() {\n+        let p1 = PosixPath(\"/usr/bin/whatever/../rustc\");\n+        let p2 = PosixPath(\"/usr/lib/whatever/mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, PosixPath(\"../lib/whatever\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\usr\\\\bin\\\\whatever\\\\..\\\\rustc\");\n+        let p2 = WindowsPath(\"C:\\\\usr\\\\lib\\\\whatever\\\\mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, WindowsPath(\"..\\\\lib\\\\whatever\"));\n+\n+    }\n+\n+    #[test]\n+    fn test_relative_to5() {\n+        let p1 = PosixPath(\"/usr/bin/whatever/../rustc\");\n+        let p2 = PosixPath(\"/usr/lib/whatever/../mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, PosixPath(\"../lib\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\usr\\\\bin/whatever\\\\..\\\\rustc\");\n+        let p2 = WindowsPath(\"C:\\\\usr\\\\lib\\\\whatever\\\\..\\\\mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, WindowsPath(\"..\\\\lib\"));\n+    }\n+\n+    #[test]\n+    fn test_relative_to6() {\n+        let p1 = PosixPath(\"/1\");\n+        let p2 = PosixPath(\"/2/3\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, PosixPath(\"2\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\1\");\n+        let p2 = WindowsPath(\"C:\\\\2\\\\3\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, WindowsPath(\"2\"));\n+\n+    }\n+\n+    #[test]\n+    fn test_relative_to7() {\n+        let p1 = PosixPath(\"/1/2\");\n+        let p2 = PosixPath(\"/3\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, PosixPath(\"..\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\1\\\\2\");\n+        let p2 = WindowsPath(\"C:\\\\3\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, WindowsPath(\"..\"));\n+\n+    }\n+\n+    #[test]\n+    fn test_relative_to8() {\n+        let p1 = PosixPath(\"/home/brian/Dev/rust/build/\").push_rel(\n+            &PosixPath(\"stage2/lib/rustc/i686-unknown-linux-gnu/lib/librustc.so\"));\n+        let p2 = PosixPath(\"/home/brian/Dev/rust/build/stage2/bin/..\").push_rel(\n+            &PosixPath(\"lib/rustc/i686-unknown-linux-gnu/lib/libstd.so\"));\n+        let res = p1.get_relative_to(&p2);\n+        debug!(\"test_relative_to8: %s vs. %s\",\n+               res.to_str(),\n+               PosixPath(\".\").to_str());\n+        assert_eq!(res, PosixPath(\".\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\home\\\\brian\\\\Dev\\\\rust\\\\build\\\\\").push_rel(\n+            &WindowsPath(\"stage2\\\\lib\\\\rustc\\\\i686-unknown-linux-gnu\\\\lib\\\\librustc.so\"));\n+        let p2 = WindowsPath(\"\\\\home\\\\brian\\\\Dev\\\\rust\\\\build\\\\stage2\\\\bin\\\\..\").push_rel(\n+            &WindowsPath(\"lib\\\\rustc\\\\i686-unknown-linux-gnu\\\\lib\\\\libstd.so\"));\n+        let res = p1.get_relative_to(&p2);\n+        debug!(\"test_relative_to8: %s vs. %s\",\n+               res.to_str(),\n+               WindowsPath(\".\").to_str());\n+        assert_eq!(res, WindowsPath(\".\"));\n+\n+    }\n+\n }"}, {"sha": "793e244bec7b937276096033741de9751dc5cf53", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -15,6 +15,7 @@ use cast;\n use ops::Drop;\n use rt::kill::BlockedTask;\n use kinds::Send;\n+use rt;\n use rt::sched::Scheduler;\n use rt::local::Local;\n use rt::select::{Select, SelectPort};\n@@ -24,7 +25,6 @@ use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n use cell::Cell;\n use clone::Clone;\n-use rt::{context, SchedulerContext};\n use tuple::ImmutableTuple;\n \n /// A combined refcount / BlockedTask-as-uint pointer.\n@@ -113,7 +113,7 @@ impl<T> ChanOne<T> {\n     // 'do_resched' configures whether the scheduler immediately switches to\n     // the receiving task, or leaves the sending task still running.\n     fn try_send_inner(self, val: T, do_resched: bool) -> bool {\n-        rtassert!(context() != SchedulerContext);\n+        rtassert!(!rt::in_sched_context());\n \n         let mut this = self;\n         let mut recvr_active = true;"}, {"sha": "77176088801de7fc4f5c08e42451ad9af570239f", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 373, "deletions": 1, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -9,7 +9,11 @@\n // except according to those terms.\n \n use num::FromStrRadix;\n+use vec::MutableCloneableVector;\n use to_str::ToStr;\n+use from_str::FromStr;\n+use option::{Option, None, Some};\n+\n \n type Port = u16;\n \n@@ -39,7 +43,7 @@ impl ToStr for IpAddr {\n             }\n \n             // Ipv4-Mapped address\n-            Ipv6Addr(0, 0, 0, 0, 0, 1, g, h) => {\n+            Ipv6Addr(0, 0, 0, 0, 0, 0xFFFF, g, h) => {\n                 let a = fmt!(\"%04x\", g as uint);\n                 let b = FromStrRadix::from_str_radix(a.slice(2, 4), 16).unwrap();\n                 let a = FromStrRadix::from_str_radix(a.slice(0, 2), 16).unwrap();\n@@ -73,3 +77,371 @@ impl ToStr for SocketAddr {\n         }\n     }\n }\n+\n+struct Parser<'self> {\n+    // parsing as ASCII, so can use byte array\n+    s: &'self [u8],\n+    pos: uint,\n+}\n+\n+impl<'self> Parser<'self> {\n+    fn new(s: &'self str) -> Parser<'self> {\n+        Parser {\n+            s: s.as_bytes(),\n+            pos: 0,\n+        }\n+    }\n+\n+    fn is_eof(&self) -> bool {\n+        self.pos == self.s.len()\n+    }\n+\n+    // Commit only if parser returns Some\n+    fn read_atomically<T>(&mut self, cb: &fn(&mut Parser) -> Option<T>) -> Option<T> {\n+        let pos = self.pos;\n+        let r = cb(self);\n+        if r.is_none() {\n+            self.pos = pos;\n+        }\n+        r\n+    }\n+\n+    // Commit only if parser read till EOF\n+    fn read_till_eof<T>(&mut self, cb: &fn(&mut Parser) -> Option<T>) -> Option<T> {\n+        do self.read_atomically |p| {\n+            cb(p).filtered(|_| p.is_eof())\n+        }\n+    }\n+\n+    // Return result of first successful parser\n+    fn read_or<T>(&mut self, parsers: &[&fn(&mut Parser) -> Option<T>]) -> Option<T> {\n+        for pf in parsers.iter() {\n+            match self.read_atomically(|p: &mut Parser| (*pf)(p)) {\n+                Some(r) => return Some(r),\n+                None => {}\n+            }\n+        }\n+        None\n+    }\n+\n+    // Apply 3 parsers sequentially\n+    fn read_seq_3<A, B, C>(&mut self,\n+            pa: &fn(&mut Parser) -> Option<A>,\n+            pb: &fn(&mut Parser) -> Option<B>,\n+            pc: &fn(&mut Parser) -> Option<C>\n+        ) -> Option<(A, B, C)>\n+    {\n+        do self.read_atomically |p| {\n+            let a = pa(p);\n+            let b = if a.is_some() { pb(p) } else { None };\n+            let c = if b.is_some() { pc(p) } else { None };\n+            match (a, b, c) {\n+                (Some(a), Some(b), Some(c)) => Some((a, b, c)),\n+                _ => None\n+            }\n+        }\n+    }\n+\n+    // Read next char\n+    fn read_char(&mut self) -> Option<char> {\n+        if self.is_eof() {\n+            None\n+        } else {\n+            let r = self.s[self.pos] as char;\n+            self.pos += 1;\n+            Some(r)\n+        }\n+    }\n+\n+    // Return char and advance iff next char is equal to requested\n+    fn read_given_char(&mut self, c: char) -> Option<char> {\n+        do self.read_atomically |p| {\n+            p.read_char().filtered(|&next| next == c)\n+        }\n+    }\n+\n+    // Read digit\n+    fn read_digit(&mut self, radix: u8) -> Option<u8> {\n+        fn parse_digit(c: char, radix: u8) -> Option<u8> {\n+            // assuming radix is either 10 or 16\n+            if c >= '0' && c <= '9' {\n+                Some((c - '0') as u8)\n+            } else if radix > 10 && c >= 'a' && c < 'a' + (radix - 10) as char {\n+                Some((c - 'a' + (10 as char)) as u8)\n+            } else if radix > 10 && c >= 'A' && c < 'A' + (radix - 10) as char {\n+                Some((c - 'A' + (10 as char)) as u8)\n+            } else {\n+                None\n+            }\n+        }\n+\n+        do self.read_atomically |p| {\n+            p.read_char().chain(|c| parse_digit(c, radix))\n+        }\n+    }\n+\n+    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n+        let mut r = 0u32;\n+        let mut digit_count = 0;\n+        loop {\n+            match self.read_digit(radix) {\n+                Some(d) => {\n+                    r = r * (radix as u32) + (d as u32);\n+                    digit_count += 1;\n+                    if digit_count > max_digits || r >= upto {\n+                        return None\n+                    }\n+                }\n+                None => {\n+                    if digit_count == 0 {\n+                        return None\n+                    } else {\n+                        return Some(r)\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n+    // Read number, failing if max_digits of number value exceeded\n+    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n+        do self.read_atomically |p| {\n+            p.read_number_impl(radix, max_digits, upto)\n+        }\n+    }\n+\n+    fn read_ipv4_addr_impl(&mut self) -> Option<IpAddr> {\n+        let mut bs = [0u8, ..4];\n+        let mut i = 0;\n+        while i < 4 {\n+            if i != 0 && self.read_given_char('.').is_none() {\n+                return None;\n+            }\n+\n+            let octet = self.read_number(10, 3, 0x100).map(|&n| n as u8);\n+            match octet {\n+                Some(d) => bs[i] = d,\n+                None => return None,\n+            };\n+            i += 1;\n+        }\n+        Some(Ipv4Addr(bs[0], bs[1], bs[2], bs[3]))\n+    }\n+\n+    // Read IPv4 address\n+    fn read_ipv4_addr(&mut self) -> Option<IpAddr> {\n+        do self.read_atomically |p| {\n+            p.read_ipv4_addr_impl()\n+        }\n+    }\n+\n+    fn read_ipv6_addr_impl(&mut self) -> Option<IpAddr> {\n+        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> IpAddr {\n+            assert!(head.len() + tail.len() <= 8);\n+            let mut gs = [0u16, ..8];\n+            gs.copy_from(head);\n+            gs.mut_slice(8 - tail.len(), 8).copy_from(tail);\n+            Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n+        }\n+\n+        fn read_groups(p: &mut Parser, groups: &mut [u16, ..8], limit: uint) -> (uint, bool) {\n+            let mut i = 0;\n+            while i < limit {\n+                if i < limit - 1 {\n+                    let ipv4 = do p.read_atomically |p| {\n+                        if i == 0 || p.read_given_char(':').is_some() {\n+                            p.read_ipv4_addr()\n+                        } else {\n+                            None\n+                        }\n+                    };\n+                    match ipv4 {\n+                        Some(Ipv4Addr(a, b, c, d)) => {\n+                            groups[i + 0] = (a as u16 << 8) | (b as u16);\n+                            groups[i + 1] = (c as u16 << 8) | (d as u16);\n+                            return (i + 2, true);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+\n+                let group = do p.read_atomically |p| {\n+                    if i == 0 || p.read_given_char(':').is_some() {\n+                        p.read_number(16, 4, 0x10000).map(|&n| n as u16)\n+                    } else {\n+                        None\n+                    }\n+                };\n+                match group {\n+                    Some(g) => groups[i] = g,\n+                    None => return (i, false)\n+                }\n+                i += 1;\n+            }\n+            (i, false)\n+        }\n+\n+        let mut head = [0u16, ..8];\n+        let (head_size, head_ipv4) = read_groups(self, &mut head, 8);\n+\n+        if head_size == 8 {\n+            return Some(Ipv6Addr(\n+                head[0], head[1], head[2], head[3],\n+                head[4], head[5], head[6], head[7]))\n+        }\n+\n+        // IPv4 part is not allowed before `::`\n+        if head_ipv4 {\n+            return None\n+        }\n+\n+        // read `::` if previous code parsed less than 8 groups\n+        if !self.read_given_char(':').is_some() || !self.read_given_char(':').is_some() {\n+            return None;\n+        }\n+\n+        let mut tail = [0u16, ..8];\n+        let (tail_size, _) = read_groups(self, &mut tail, 8 - head_size);\n+        Some(ipv6_addr_from_head_tail(head.slice(0, head_size), tail.slice(0, tail_size)))\n+    }\n+\n+    fn read_ipv6_addr(&mut self) -> Option<IpAddr> {\n+        do self.read_atomically |p| {\n+            p.read_ipv6_addr_impl()\n+        }\n+    }\n+\n+    fn read_ip_addr(&mut self) -> Option<IpAddr> {\n+        let ipv4_addr = |p: &mut Parser| p.read_ipv4_addr();\n+        let ipv6_addr = |p: &mut Parser| p.read_ipv6_addr();\n+        self.read_or([ipv4_addr, ipv6_addr])\n+    }\n+\n+    fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n+        let ip_addr = |p: &mut Parser| {\n+            let ipv4_p = |p: &mut Parser| p.read_ip_addr();\n+            let ipv6_p = |p: &mut Parser| {\n+                let open_br = |p: &mut Parser| p.read_given_char('[');\n+                let ip_addr = |p: &mut Parser| p.read_ipv6_addr();\n+                let clos_br = |p: &mut Parser| p.read_given_char(']');\n+                p.read_seq_3::<char, IpAddr, char>(open_br, ip_addr, clos_br)\n+                        .map(|&t| match t { (_, ip, _) => ip })\n+            };\n+            p.read_or([ipv4_p, ipv6_p])\n+        };\n+        let colon = |p: &mut Parser| p.read_given_char(':');\n+        let port  = |p: &mut Parser| p.read_number(10, 5, 0x10000).map(|&n| n as u16);\n+\n+        // host, colon, port\n+        self.read_seq_3::<IpAddr, char, u16>(ip_addr, colon, port)\n+                .map(|&t| match t { (ip, _, port) => SocketAddr { ip: ip, port: port } })\n+    }\n+}\n+\n+impl FromStr for IpAddr {\n+    fn from_str(s: &str) -> Option<IpAddr> {\n+        do Parser::new(s).read_till_eof |p| {\n+            p.read_ip_addr()\n+        }\n+    }\n+}\n+\n+impl FromStr for SocketAddr {\n+    fn from_str(s: &str) -> Option<SocketAddr> {\n+        do Parser::new(s).read_till_eof |p| {\n+            p.read_socket_addr()\n+        }\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use from_str::FromStr;\n+    use option::{Some, None};\n+\n+    #[test]\n+    fn test_from_str_ipv4() {\n+        assert_eq!(Some(Ipv4Addr(127, 0, 0, 1)), FromStr::from_str(\"127.0.0.1\"));\n+        assert_eq!(Some(Ipv4Addr(255, 255, 255, 255)), FromStr::from_str(\"255.255.255.255\"));\n+        assert_eq!(Some(Ipv4Addr(0, 0, 0, 0)), FromStr::from_str(\"0.0.0.0\"));\n+\n+        // out of range\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"256.0.0.1\"));\n+        // too short\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"255.0.0\"));\n+        // too long\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"255.0.0.1.2\"));\n+        // no number between dots\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"255.0..1\"));\n+    }\n+\n+    #[test]\n+    fn test_from_str_ipv6() {\n+        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), FromStr::from_str(\"0:0:0:0:0:0:0:0\"));\n+        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), FromStr::from_str(\"0:0:0:0:0:0:0:1\"));\n+\n+        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), FromStr::from_str(\"::1\"));\n+        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), FromStr::from_str(\"::\"));\n+\n+        assert_eq!(Some(Ipv6Addr(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n+                FromStr::from_str(\"2a02:6b8::11:11\"));\n+\n+        // too long group\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"::00000\"));\n+        // too short\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2:3:4:5:6:7\"));\n+        // too long\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2:3:4:5:6:7:8:9\"));\n+        // triple colon\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2:::6:7:8\"));\n+        // two double colons\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2::6::8\"));\n+    }\n+\n+    #[test]\n+    fn test_from_str_ipv4_in_ipv6() {\n+        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 49152, 545)),\n+                FromStr::from_str(\"::192.0.2.33\"));\n+        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n+                FromStr::from_str(\"::FFFF:192.0.2.33\"));\n+        assert_eq!(Some(Ipv6Addr(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n+                FromStr::from_str(\"64:ff9b::192.0.2.33\"));\n+        assert_eq!(Some(Ipv6Addr(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n+                FromStr::from_str(\"2001:db8:122:c000:2:2100:192.0.2.33\"));\n+\n+        // colon after v4\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"::127.0.0.1:\"));\n+        // not enought groups\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1.2.3.4.5:127.0.0.1\"));\n+        // too many groups\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1.2.3.4.5:6:7:127.0.0.1\"));\n+    }\n+\n+    #[test]\n+    fn test_from_str_socket_addr() {\n+        assert_eq!(Some(SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 80 }),\n+                FromStr::from_str(\"77.88.21.11:80\"));\n+        assert_eq!(Some(SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 }),\n+                FromStr::from_str(\"[2a02:6b8:0:1::1]:53\"));\n+        assert_eq!(Some(SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0x7F00, 1), port: 22 }),\n+                FromStr::from_str(\"[::127.0.0.1]:22\"));\n+\n+        // without port\n+        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"127.0.0.1\"));\n+        // without port\n+        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"127.0.0.1:\"));\n+        // wrong brackets around v4\n+        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"[127.0.0.1]:22\"));\n+        // port out of range\n+        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"127.0.0.1:123456\"));\n+    }\n+\n+    #[test]\n+    fn ipv6_addr_to_str() {\n+        let a1 = Ipv6Addr(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n+        assert!(a1.to_str() == ~\"::ffff:192.0.2.128\" || a1.to_str() == ~\"::FFFF:192.0.2.128\");\n+    }\n+\n+}"}, {"sha": "8832597f40c452ee8b021d32f5150268f69b60f0", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -13,6 +13,7 @@\n use libc;\n use libc::{c_void, uintptr_t, size_t};\n use ops::Drop;\n+use option::{Some, None};\n use rt;\n use rt::OldTaskContext;\n use rt::local::Local;\n@@ -86,20 +87,19 @@ impl Drop for LocalHeap {\n \n // A little compatibility function\n pub unsafe fn local_free(ptr: *libc::c_char) {\n-    match rt::context() {\n-        OldTaskContext => {\n+    // XXX: Unsafe borrow for speed. Lame.\n+    match Local::try_unsafe_borrow::<Task>() {\n+        Some(task) => {\n+            (*task).heap.free(ptr as *libc::c_void);\n+        }\n+        None => {\n             rust_upcall_free_noswitch(ptr);\n \n             extern {\n                 #[fast_ffi]\n                 fn rust_upcall_free_noswitch(ptr: *libc::c_char);\n             }\n         }\n-        _ => {\n-            do Local::borrow::<Task,()> |task| {\n-                task.heap.free(ptr as *libc::c_void);\n-            }\n-        }\n     }\n }\n \n@@ -119,20 +119,28 @@ pub fn live_allocs() -> *raw::Box<()> {\n }\n \n extern {\n+    #[fast_ffi]\n     fn rust_new_memory_region(synchronized: uintptr_t,\n                                detailed_leaks: uintptr_t,\n                                poison_on_free: uintptr_t) -> *MemoryRegion;\n+    #[fast_ffi]\n     fn rust_delete_memory_region(region: *MemoryRegion);\n+    #[fast_ffi]\n     fn rust_new_boxed_region(region: *MemoryRegion,\n                              poison_on_free: uintptr_t) -> *BoxedRegion;\n+    #[fast_ffi]\n     fn rust_delete_boxed_region(region: *BoxedRegion);\n+    #[fast_ffi]\n     fn rust_boxed_region_malloc(region: *BoxedRegion,\n                                 td: *TypeDesc,\n                                 size: size_t) -> *OpaqueBox;\n+    #[fast_ffi]\n     fn rust_boxed_region_realloc(region: *BoxedRegion,\n                                  ptr: *OpaqueBox,\n                                  size: size_t) -> *OpaqueBox;\n+    #[fast_ffi]\n     fn rust_boxed_region_free(region: *BoxedRegion, box: *OpaqueBox);\n+    #[fast_ffi]\n     fn rust_current_boxed_region() -> *BoxedRegion;\n }\n "}, {"sha": "be71bc651df5902abccc2b90852e8a29a934d631", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -407,14 +407,10 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n /// or the old scheduler.\n #[deriving(Eq)]\n pub enum RuntimeContext {\n-    // Only the exchange heap is available\n-    GlobalContext,\n-    // The scheduler may be accessed\n-    SchedulerContext,\n-    // Full task services, e.g. local heap, unwinding\n-    TaskContext,\n     // Running in an old-style task\n-    OldTaskContext\n+    OldTaskContext,\n+    // Not old task context\n+    NewRtContext\n }\n \n /// Determine the current RuntimeContext\n@@ -424,23 +420,40 @@ pub fn context() -> RuntimeContext {\n \n     if unsafe { rust_try_get_task().is_not_null() } {\n         return OldTaskContext;\n-    } else if Local::exists::<Task>() {\n-        // In this case we know it is a new runtime context, but we\n-        // need to check which one. Going to try borrowing task to\n-        // check. Task should always be in TLS, so hopefully this\n-        // doesn't conflict with other ops that borrow.\n-        return do Local::borrow::<Task,RuntimeContext> |task| {\n-            match task.task_type {\n-                SchedTask => SchedulerContext,\n-                GreenTask(_) => TaskContext\n-            }\n-        };\n     } else {\n-        return GlobalContext;\n+        return NewRtContext;\n     }\n \n     extern {\n         #[rust_stack]\n         pub fn rust_try_get_task() -> *rust_task;\n     }\n }\n+\n+pub fn in_sched_context() -> bool {\n+    unsafe {\n+        match Local::try_unsafe_borrow::<Task>() {\n+            Some(task) => {\n+                match (*task).task_type {\n+                    SchedTask => true,\n+                    _ => false\n+                }\n+            }\n+            None => false\n+        }\n+    }\n+}\n+\n+pub fn in_green_task_context() -> bool {\n+    unsafe {\n+        match Local::try_unsafe_borrow::<Task>() {\n+            Some(task) => {\n+                match (*task).task_type {\n+                    GreenTask(_) => true,\n+                    _ => false\n+                }\n+            }\n+            None => false\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "c8b3d41a78d79b65e8b5316e77dcc98aa38cd529", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 2, "deletions": 70, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -20,7 +20,6 @@ use rt::uv::last_uv_error;\n use vec;\n use str;\n use from_str::{FromStr};\n-use num;\n \n pub enum UvSocketAddr {\n     UvIpv4SocketAddr(*sockaddr_in),\n@@ -85,77 +84,10 @@ fn uv_socket_addr_as_socket_addr<T>(addr: UvSocketAddr, f: &fn(SocketAddr) -> T)\n         port as u16\n     };\n     let ip_str = str::from_bytes_slice(ip_name).trim_right_chars(&'\\x00');\n-    let ip = match addr {\n-        UvIpv4SocketAddr(*) => {\n-            let ip: ~[u8] =\n-                ip_str.split_iter('.')\n-                      .transform(|s: &str| -> u8 { FromStr::from_str(s).unwrap() })\n-                      .collect();\n-            assert_eq!(ip.len(), 4);\n-            SocketAddr {\n-                ip: Ipv4Addr(ip[0], ip[1], ip[2], ip[3]),\n-                port: ip_port\n-            }\n-        },\n-        UvIpv6SocketAddr(*) => {\n-            let ip: ~[u16] = {\n-                let expand_shorthand_and_convert = |s: &str| -> ~[~[u16]] {\n-                    let convert_each_segment = |s: &str| -> ~[u16] {\n-                        let read_hex_segment = |s: &str| -> u16 {\n-                            num::FromStrRadix::from_str_radix(s, 16u).unwrap()\n-                        };\n-                        match s {\n-                            \"\" => ~[],\n-                            // IPv4-Mapped/Compatible IPv6 Address?\n-                            s if s.find('.').is_some() => {\n-                                let i = s.rfind(':').unwrap_or_default(-1);\n-\n-                                let b = s.slice(i + 1, s.len()); // the ipv4 part\n-\n-                                let h = b.split_iter('.')\n-                                   .transform(|s: &str| -> u8 { FromStr::from_str(s).unwrap() })\n-                                   .transform(|s: u8| -> ~str { fmt!(\"%02x\", s as uint) })\n-                                   .collect::<~[~str]>();\n-\n-                                if i == -1 {\n-                                    // Ipv4 Compatible Address (::x.x.x.x)\n-                                    // first 96 bits are zero leaving 32 bits\n-                                    // for the ipv4 part\n-                                    // (i.e ::127.0.0.1 == ::7F00:1)\n-                                    ~[num::FromStrRadix::from_str_radix(h[0] + h[1], 16).unwrap(),\n-                                      num::FromStrRadix::from_str_radix(h[2] + h[3], 16).unwrap()]\n-                                } else {\n-                                    // Ipv4-Mapped Address (::FFFF:x.x.x.x)\n-                                    // first 80 bits are zero, followed by all ones\n-                                    // for the next 16 bits, leaving 32 bits for\n-                                    // the ipv4 part\n-                                    // (i.e ::FFFF:127.0.0.1 == ::FFFF:7F00:1)\n-                                    ~[1,\n-                                      num::FromStrRadix::from_str_radix(h[0] + h[1], 16).unwrap(),\n-                                      num::FromStrRadix::from_str_radix(h[2] + h[3], 16).unwrap()]\n-                                }\n-                            },\n-                            s => s.split_iter(':').transform(read_hex_segment).collect()\n-                        }\n-                    };\n-                    s.split_str_iter(\"::\").transform(convert_each_segment).collect()\n-                };\n-                match expand_shorthand_and_convert(ip_str) {\n-                    [x] => x, // no shorthand found\n-                    [l, r] => l + vec::from_elem(8 - l.len() - r.len(), 0u16) + r, // fill the gap\n-                    _ => fail!(), // impossible. only one shorthand allowed.\n-                }\n-            };\n-            assert_eq!(ip.len(), 8);\n-            SocketAddr {\n-                ip: Ipv6Addr(ip[0], ip[1], ip[2], ip[3], ip[4], ip[5], ip[6], ip[7]),\n-                port: ip_port\n-            }\n-        },\n-    };\n+    let ip_addr = FromStr::from_str(ip_str).unwrap();\n \n     // finally run the closure\n-    f(ip)\n+    f(SocketAddr { ip: ip_addr, port: ip_port })\n }\n \n pub fn uv_socket_addr_to_socket_addr(addr: UvSocketAddr) -> SocketAddr {"}, {"sha": "31e317604c77e073ba75edde11acddec9d970e13", "filename": "src/libstd/run.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -1329,11 +1329,11 @@ mod tests {\n         let output = str::from_bytes(prog.finish_with_output().output);\n \n         let r = os::env();\n-        for &(k, v) in r.iter() {\n+        for &(ref k, ref v) in r.iter() {\n             // don't check android RANDOM variables\n-            if k != ~\"RANDOM\" {\n-                assert!(output.contains(fmt!(\"%s=%s\", k, v)) ||\n-                        output.contains(fmt!(\"%s=\\'%s\\'\", k, v)));\n+            if *k != ~\"RANDOM\" {\n+                assert!(output.contains(fmt!(\"%s=%s\", *k, *v)) ||\n+                        output.contains(fmt!(\"%s=\\'%s\\'\", *k, *v)));\n             }\n         }\n     }"}, {"sha": "b72e5a87c6d48f052044629d907c32502c91948f", "filename": "src/libstd/str.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -1243,34 +1243,16 @@ pub mod traits {\n     impl<'self> Ord for &'self str {\n         #[inline]\n         fn lt(&self, other: & &'self str) -> bool { self.cmp(other) == Less }\n-        #[inline]\n-        fn le(&self, other: & &'self str) -> bool { self.cmp(other) != Greater }\n-        #[inline]\n-        fn ge(&self, other: & &'self str) -> bool { self.cmp(other) != Less }\n-        #[inline]\n-        fn gt(&self, other: & &'self str) -> bool { self.cmp(other) == Greater }\n     }\n \n     impl Ord for ~str {\n         #[inline]\n         fn lt(&self, other: &~str) -> bool { self.cmp(other) == Less }\n-        #[inline]\n-        fn le(&self, other: &~str) -> bool { self.cmp(other) != Greater }\n-        #[inline]\n-        fn ge(&self, other: &~str) -> bool { self.cmp(other) != Less }\n-        #[inline]\n-        fn gt(&self, other: &~str) -> bool { self.cmp(other) == Greater }\n     }\n \n     impl Ord for @str {\n         #[inline]\n         fn lt(&self, other: &@str) -> bool { self.cmp(other) == Less }\n-        #[inline]\n-        fn le(&self, other: &@str) -> bool { self.cmp(other) != Greater }\n-        #[inline]\n-        fn ge(&self, other: &@str) -> bool { self.cmp(other) != Less }\n-        #[inline]\n-        fn gt(&self, other: &@str) -> bool { self.cmp(other) == Greater }\n     }\n \n     impl<'self, S: Str> Equiv<S> for &'self str {"}, {"sha": "3add87bbd1d257b277a0910525bb779ff62c5556", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -136,7 +136,7 @@ impl FailWithCause for &'static str {\n pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     use either::Left;\n     use option::{Some, None};\n-    use rt::{context, OldTaskContext, TaskContext};\n+    use rt::{context, OldTaskContext, in_green_task_context};\n     use rt::task::Task;\n     use rt::local::Local;\n     use rt::logging::Logger;\n@@ -158,7 +158,7 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n \n                 // XXX: Logging doesn't work correctly in non-task context because it\n                 // invokes the local heap\n-                if context == TaskContext {\n+                if in_green_task_context() {\n                     // XXX: Logging doesn't work here - the check to call the log\n                     // function never passes - so calling the log function directly.\n                     do Local::borrow::<Task, ()> |task| {"}, {"sha": "269c828a9845f7bc23ddba2e54360b1bbc183344", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -42,7 +42,7 @@ use cmp::Eq;\n use comm::{stream, Chan, GenericChan, GenericPort, Port};\n use result::Result;\n use result;\n-use rt::{context, OldTaskContext, TaskContext};\n+use rt::{context, OldTaskContext, in_green_task_context};\n use rt::local::Local;\n use unstable::finally::Finally;\n use util;\n@@ -527,14 +527,15 @@ pub fn try<T:Send>(f: ~fn() -> T) -> Result<T,()> {\n pub fn with_task_name<U>(blk: &fn(Option<&str>) -> U) -> U {\n     use rt::task::Task;\n \n-    match context() {\n-        TaskContext => do Local::borrow::<Task, U> |task| {\n+    if in_green_task_context() {\n+        do Local::borrow::<Task, U> |task| {\n             match task.name {\n                 Some(ref name) => blk(Some(name.as_slice())),\n                 None => blk(None)\n             }\n-        },\n-        _ => fail!(\"no task name exists in %?\", context()),\n+        }\n+    } else {\n+        fail!(\"no task name exists in %?\", context())\n     }\n }\n \n@@ -614,7 +615,7 @@ pub fn unkillable<U>(f: &fn() -> U) -> U {\n                     rt::rust_task_allow_kill(t);\n                 }\n             }\n-            TaskContext => {\n+            _ if in_green_task_context() => {\n                 // The inhibits/allows might fail and need to borrow the task.\n                 let t = Local::unsafe_borrow::<Task>();\n                 do (|| {\n@@ -645,7 +646,7 @@ pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n                 rt::rust_task_inhibit_kill(t);\n             }\n         }\n-        TaskContext => {\n+        _ if in_green_task_context() => {\n             let t = Local::unsafe_borrow::<Task>();\n             do (|| {\n                 (*t).death.allow_kill((*t).unwinder.unwinding);"}, {"sha": "314377b8dc9c17c9e065e617bb42492f84c504ec", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -91,7 +91,7 @@ use to_bytes::IterBytes;\n use uint;\n use util;\n use unstable::sync::Exclusive;\n-use rt::{OldTaskContext, TaskContext, SchedulerContext, GlobalContext, context};\n+use rt::{OldTaskContext, NewRtContext, context, in_green_task_context};\n use rt::local::Local;\n use rt::task::{Task, Sched};\n use rt::kill::KillHandle;\n@@ -526,7 +526,7 @@ impl RuntimeGlue {\n                 let me = rt::rust_get_task();\n                 blk(OldTask(me), rt::rust_task_is_unwinding(me))\n             },\n-            TaskContext => unsafe {\n+            NewRtContext if in_green_task_context() => unsafe {\n                 // Can't use safe borrow, because the taskgroup destructor needs to\n                 // access the scheduler again to send kill signals to other tasks.\n                 let me = Local::unsafe_borrow::<Task>();\n@@ -535,7 +535,7 @@ impl RuntimeGlue {\n                 blk(NewTask((*me).death.kill_handle.get_ref().clone()),\n                     (*me).unwinder.unwinding)\n             },\n-            SchedulerContext | GlobalContext => rtabort!(\"task dying in bad context\"),\n+            NewRtContext => rtabort!(\"task dying in bad context\"),\n         }\n     }\n \n@@ -563,7 +563,7 @@ impl RuntimeGlue {\n                     }\n                 }\n             },\n-            TaskContext => unsafe {\n+            NewRtContext if in_green_task_context() => unsafe {\n                 // Can't use safe borrow, because creating new hashmaps for the\n                 // tasksets requires an rng, which needs to borrow the sched.\n                 let me = Local::unsafe_borrow::<Task>();\n@@ -588,7 +588,7 @@ impl RuntimeGlue {\n                     Some(ref group) => group,\n                 })\n             },\n-            SchedulerContext | GlobalContext => rtabort!(\"spawning in bad context\"),\n+            NewRtContext => rtabort!(\"spawning in bad context\"),\n         }\n     }\n }\n@@ -666,10 +666,9 @@ fn enlist_many(child: TaskHandle, child_arc: &TaskGroupArc,\n \n pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n     match context() {\n-        OldTaskContext   => spawn_raw_oldsched(opts, f),\n-        TaskContext      => spawn_raw_newsched(opts, f),\n-        SchedulerContext => fail!(\"can't spawn from scheduler context\"),\n-        GlobalContext    => fail!(\"can't spawn from global context\"),\n+        OldTaskContext => spawn_raw_oldsched(opts, f),\n+        _ if in_green_task_context() => spawn_raw_newsched(opts, f),\n+        _ => fail!(\"can't spawn from this context\")\n     }\n }\n "}, {"sha": "457f640033cb9f2ce8d25bc20911410eaf7699b0", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -13,9 +13,9 @@\n use c_str::ToCStr;\n use cast::transmute;\n use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int};\n+use option::{Some, None};\n use str;\n use sys;\n-use rt::{context, OldTaskContext};\n use rt::task::Task;\n use rt::local::Local;\n use rt::borrowck;\n@@ -57,16 +57,13 @@ pub fn fail_bounds_check(file: *c_char, line: size_t,\n \n #[lang=\"malloc\"]\n pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    match context() {\n-        OldTaskContext => {\n-            return rustrt::rust_upcall_malloc_noswitch(td, size);\n+    // XXX: Unsafe borrow for speed. Lame.\n+    match Local::try_unsafe_borrow::<Task>() {\n+        Some(task) => {\n+            (*task).heap.alloc(td as *c_void, size as uint) as *c_char\n         }\n-        _ => {\n-            let mut alloc = ::ptr::null();\n-            do Local::borrow::<Task,()> |task| {\n-                alloc = task.heap.alloc(td as *c_void, size as uint) as *c_char;\n-            }\n-            return alloc;\n+        None => {\n+            rustrt::rust_upcall_malloc_noswitch(td, size)\n         }\n     }\n }"}, {"sha": "a8d942a46b3152503a6d833dce5b0f7f24263424", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -282,7 +282,7 @@ pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n     use rt::task::Task;\n     use task::rt;\n     use rt::local::Local;\n-    use rt::{context, OldTaskContext, TaskContext};\n+    use rt::{context, OldTaskContext};\n \n     match context() {\n         OldTaskContext => {\n@@ -296,17 +296,23 @@ pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n                 rt::rust_task_allow_kill(t);\n             }\n         }\n-        TaskContext => {\n-            let t = Local::unsafe_borrow::<Task>();\n-            do (|| {\n-                (*t).death.inhibit_yield();\n-                f()\n-            }).finally {\n-                (*t).death.allow_yield();\n+        _ => {\n+            let t = Local::try_unsafe_borrow::<Task>();\n+            match t {\n+                Some(t) => {\n+                    do (|| {\n+                        (*t).death.inhibit_yield();\n+                        f()\n+                    }).finally {\n+                        (*t).death.allow_yield();\n+                    }\n+                }\n+                None => {\n+                    // FIXME(#3095): As in unkillable().\n+                    f()\n+                }\n             }\n         }\n-        // FIXME(#3095): As in unkillable().\n-        _ => f()\n     }\n }\n "}, {"sha": "17247222c3ff954783b8d5f67d39f2b29d12f5e0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -951,7 +951,11 @@ pub struct view_item {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum view_item_ {\n-    view_item_extern_mod(ident, ~[@MetaItem], NodeId),\n+    // ident: name used to refer to this crate in the code\n+    // optional @str: if present, this is a location (containing\n+    // arbitrary characters) from which to fetch the crate sources\n+    // For example, extern mod whatever = \"github.com/mozilla/rust\"\n+    view_item_extern_mod(ident, Option<@str>, ~[@MetaItem], NodeId),\n     view_item_use(~[@view_path]),\n }\n "}, {"sha": "9a8a3bc25d8a3a2051d9742087f9ad293799e18b", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -419,7 +419,7 @@ impl Visitor<()> for IdVisitor {\n \n     fn visit_view_item(@mut self, view_item: &view_item, env: ()) {\n         match view_item.node {\n-            view_item_extern_mod(_, _, node_id) => {\n+            view_item_extern_mod(_, _, _, node_id) => {\n                 (self.visit_callback)(node_id)\n             }\n             view_item_use(ref view_paths) => {"}, {"sha": "b5d97427baf29737216b2d2d472c9fd296d18bef", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -59,7 +59,7 @@ pub fn expand_asm(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n         match state {\n             Asm => {\n                 asm = expr_to_str(cx, p.parse_expr(),\n-                                  ~\"inline assembly must be a string literal.\");\n+                                  \"inline assembly must be a string literal.\");\n             }\n             Outputs => {\n                 while *p.token != token::EOF &&"}, {"sha": "1e696451701726593cfccd1b6deda0ebf1fcd72e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -148,7 +148,9 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n         intern(&\"auto_decode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_decode)));\n     syntax_expanders.insert(intern(&\"env\"),\n-                            builtin_normal_tt(ext::env::expand_syntax_ext));\n+                            builtin_normal_tt(ext::env::expand_env));\n+    syntax_expanders.insert(intern(&\"option_env\"),\n+                            builtin_normal_tt(ext::env::expand_option_env));\n     syntax_expanders.insert(intern(\"bytes\"),\n                             builtin_normal_tt(ext::bytes::expand_syntax_ext));\n     syntax_expanders.insert(intern(\"concat_idents\"),\n@@ -313,7 +315,7 @@ impl ExtCtxt {\n     }\n }\n \n-pub fn expr_to_str(cx: @ExtCtxt, expr: @ast::expr, err_msg: ~str) -> @str {\n+pub fn expr_to_str(cx: @ExtCtxt, expr: @ast::expr, err_msg: &str) -> @str {\n     match expr.node {\n       ast::expr_lit(l) => match l.node {\n         ast::lit_str(s) => s,\n@@ -538,8 +540,8 @@ mod test {\n         a.insert (@\"abc\",@15);\n         let m = MapChain::new(~a);\n         m.insert (@\"def\",@16);\n-        // FIXME: #4492 (ICE)  assert_eq!(m.find(&@\"abc\"),Some(@15));\n-        //  ....               assert_eq!(m.find(&@\"def\"),Some(@16));\n+        assert_eq!(m.find(&@\"abc\"),Some(@15));\n+        assert_eq!(m.find(&@\"def\"),Some(@16));\n         assert_eq!(*(m.find(&@\"abc\").unwrap()),15);\n         assert_eq!(*(m.find(&@\"def\").unwrap()),16);\n         let n = m.push_frame();\n@@ -551,8 +553,8 @@ mod test {\n         assert_eq!(*(n.find(&@\"abc\").unwrap()),15);\n         assert_eq!(*(n.find(&@\"def\").unwrap()),17);\n         // ... but m still has the old ones\n-        // FIXME: #4492: assert_eq!(m.find(&@\"abc\"),Some(@15));\n-        // FIXME: #4492: assert_eq!(m.find(&@\"def\"),Some(@16));\n+        assert_eq!(m.find(&@\"abc\"),Some(@15));\n+        assert_eq!(m.find(&@\"def\"),Some(@16));\n         assert_eq!(*(m.find(&@\"abc\").unwrap()),15);\n         assert_eq!(*(m.find(&@\"def\").unwrap()),16);\n     }"}, {"sha": "c9e01b0f0d596d3ed1a41f645b9538d052641418", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -22,17 +22,35 @@ use ext::build::AstBuilder;\n \n use std::os;\n \n-pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_option_env(ext_cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n+    let var = get_single_str_from_tts(ext_cx, sp, tts, \"option_env!\");\n \n-    let var = get_single_str_from_tts(cx, sp, tts, \"env!\");\n+    let e = match os::getenv(var) {\n+      None => quote_expr!(::std::option::None),\n+      Some(s) => quote_expr!(::std::option::Some($s))\n+    };\n+    MRExpr(e)\n+}\n \n-    // FIXME (#2248): if this was more thorough it would manufacture an\n-    // Option<str> rather than just an maybe-empty string.\n+pub fn expand_env(ext_cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+    -> base::MacResult {\n+    let exprs = get_exprs_from_tts(ext_cx, sp, tts);\n+\n+    if exprs.len() == 0 {\n+        ext_cx.span_fatal(sp, \"env! takes 1 or 2 arguments\");\n+    }\n+\n+    let var = expr_to_str(ext_cx, exprs[0], \"expected string literal\");\n+    let msg = match exprs.len() {\n+        1 => fmt!(\"Environment variable %s not defined\", var).to_managed(),\n+        2 => expr_to_str(ext_cx, exprs[1], \"expected string literal\"),\n+        _ => ext_cx.span_fatal(sp, \"env! takes 1 or 2 arguments\")\n+    };\n \n     let e = match os::getenv(var) {\n-      None => cx.expr_str(sp, @\"\"),\n-      Some(s) => cx.expr_str(sp, s.to_managed())\n+        None => ext_cx.span_fatal(sp, msg),\n+        Some(s) => ext_cx.expr_str(sp, s.to_managed())\n     };\n     MRExpr(e)\n }"}, {"sha": "008545c9729b15390d367b7951af3a19c7f00b68", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -32,7 +32,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     }\n     let fmt =\n         expr_to_str(cx, args[0],\n-                    ~\"first argument to fmt! must be a string literal.\");\n+                    \"first argument to fmt! must be a string literal.\");\n     let fmtspan = args[0].span;\n     debug!(\"Format string: %s\", fmt);\n     fn parse_fmt_err_(cx: @ExtCtxt, sp: span, msg: &str) -> ! {"}, {"sha": "ddb0e3bfa689f8724fcbcff93b50cee31192efbd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -4181,8 +4181,16 @@ impl Parser {\n                                  self.this_token_to_str()));\n         }\n \n-        let (sort, ident) = match *self.token {\n-            token::IDENT(*) => (ast::named, self.parse_ident()),\n+        let (sort, maybe_path, ident) = match *self.token {\n+            token::IDENT(*) => {\n+                let the_ident = self.parse_ident();\n+                let path = if *self.token == token::EQ {\n+                    self.bump();\n+                    Some(self.parse_str())\n+                }\n+                else { None };\n+                (ast::named, path, the_ident)\n+            }\n             _ => {\n                 if must_be_named_mod {\n                     self.span_fatal(*self.span,\n@@ -4191,7 +4199,7 @@ impl Parser {\n                                          self.this_token_to_str()));\n                 }\n \n-                (ast::anonymous,\n+                (ast::anonymous, None,\n                  special_idents::clownshoes_foreign_mod)\n             }\n         };\n@@ -4230,7 +4238,7 @@ impl Parser {\n         let metadata = self.parse_optional_meta();\n         self.expect(&token::SEMI);\n         iovi_view_item(ast::view_item {\n-            node: view_item_extern_mod(ident, metadata, self.get_id()),\n+            node: view_item_extern_mod(ident, maybe_path, metadata, self.get_id()),\n             attrs: attrs,\n             vis: visibility,\n             span: mk_sp(lo, self.last_span.hi)\n@@ -4812,8 +4820,13 @@ impl Parser {\n         } else if self.eat_keyword(keywords::Extern) {\n             self.expect_keyword(keywords::Mod);\n             let ident = self.parse_ident();\n+            let path = if *self.token == token::EQ {\n+                self.bump();\n+                Some(self.parse_str())\n+            }\n+            else { None };\n             let metadata = self.parse_optional_meta();\n-            view_item_extern_mod(ident, metadata, self.get_id())\n+            view_item_extern_mod(ident, path, metadata, self.get_id())\n         } else {\n             self.bug(\"expected view item\");\n         };"}, {"sha": "ffe9575a8644eaada860dbfd552cdd76e5487a70", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -1856,9 +1856,13 @@ pub fn print_view_item(s: @ps, item: &ast::view_item) {\n     print_outer_attributes(s, item.attrs);\n     print_visibility(s, item.vis);\n     match item.node {\n-        ast::view_item_extern_mod(id, ref mta, _) => {\n+        ast::view_item_extern_mod(id, ref optional_path, ref mta, _) => {\n             head(s, \"extern mod\");\n             print_ident(s, id);\n+            for p in optional_path.iter() {\n+                word(s.s, \"=\");\n+                print_string(s, *p);\n+            }\n             if !mta.is_empty() {\n                 popen(s);\n                 commasep(s, consistent, *mta, |p, &i| print_meta_item(p, i));"}, {"sha": "c2362689721ace56198d1533f25cba82b7ad2319", "filename": "src/test/compile-fail/extenv-arg-2-not-string-literal.rs", "status": "renamed", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextenv-arg-2-not-string-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextenv-arg-2-not-string-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-arg-2-not-string-literal.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -8,9 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Just a test that new-style extern mods parse\n-\n-// xfail-test FIXME #6407\n-extern mod test = \"github.com/catamorphism/test-pkg\";\n-\n-fn main() {}\n+fn main() { env!(\"one\", 10); } //~ ERROR: expected string literal", "previous_filename": "src/test/run-pass/extern-mod-url.rs"}, {"sha": "afa47dbe744661ca773ba0c271f28eaa5d700c65", "filename": "src/test/compile-fail/extenv-no-args.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,6 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: env! takes 1 argument\n-\n-fn main() { env!(); }\n+fn main() { env!(); } //~ ERROR: env! takes 1 or 2 arguments"}, {"sha": "485b6c09f0a49389ecd83826e25274fe229e3e23", "filename": "src/test/compile-fail/extenv-not-defined-custom.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextenv-not-defined-custom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextenv-not-defined-custom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-not-defined-custom.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() { env!(\"__HOPEFULLY_NOT_DEFINED__\", \"my error message\"); } //~ ERROR: my error message"}, {"sha": "d7a543c045a9024aeecfab061efe1a191e3b0ae0", "filename": "src/test/compile-fail/extenv-not-defined-default.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextenv-not-defined-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextenv-not-defined-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-not-defined-default.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() { env!(\"__HOPEFULLY_NOT_DEFINED__\"); } //~ ERROR: Environment variable __HOPEFULLY_NOT_DEFINED__ not defined"}, {"sha": "07ce47a14d83d5aa39cc4e33e8abf633a957829d", "filename": "src/test/compile-fail/extenv-not-string-literal.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,6 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:requires a string\n-\n-fn main() { env!(10); }\n+fn main() { env!(10, \"two\"); } //~ ERROR: expected string literal"}, {"sha": "c6c4f0ec6b8076c8ca0b7320ea175c4abd2d0488", "filename": "src/test/compile-fail/extenv-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -8,6 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: env! takes 1 argument\n-\n-fn main() { env!(\"one\", \"two\"); }\n+fn main() { env!(\"one\", \"two\", \"three\"); } //~ ERROR: env! takes 1 or 2 arguments"}, {"sha": "fd56756584ae353c0d9e6e599a141dfac12e40a7", "filename": "src/test/compile-fail/extoption_env-no-args.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextoption_env-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextoption_env-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextoption_env-no-args.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() { option_env!(); } //~ ERROR: option_env! takes 1 argument"}, {"sha": "10f6c34980e486596f97f127721f5241af410a4d", "filename": "src/test/compile-fail/extoption_env-not-string-literal.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextoption_env-not-string-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextoption_env-not-string-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextoption_env-not-string-literal.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() { option_env!(10); } //~ ERROR: requires a string"}, {"sha": "b31e857c14e13704a36bace315cbb9f399caa6a7", "filename": "src/test/compile-fail/extoption_env-too-many-args.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextoption_env-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Fcompile-fail%2Fextoption_env-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextoption_env-too-many-args.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() { option_env!(\"one\", \"two\"); } //~ ERROR: option_env! takes 1 argument"}, {"sha": "412efcc25a877434ae6379c71a53d4627b0bacaf", "filename": "src/test/run-pass/extoption_env-not-defined.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Frun-pass%2Fextoption_env-not-defined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Frun-pass%2Fextoption_env-not-defined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextoption_env-not-defined.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let opt: Option<&'static str> = option_env!(\"__HOPEFULLY_DOESNT_EXIST__\");\n+    assert!(opt.is_none());\n+}"}, {"sha": "8e55ad90c70441bd6091fc36d2b84d50f0cbfe2d", "filename": "src/test/run-pass/issue-5530.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Frun-pass%2Fissue-5530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Frun-pass%2Fissue-5530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5530.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n-\n enum Enum {\n     Foo { foo: uint },\n     Bar { bar: uint }"}, {"sha": "365729ec86054d5f372e80deb7bea4aa655210c9", "filename": "src/test/run-pass/match-enum-struct-0.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-0.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// regression test for issue #5625\n+\n+enum E {\n+    Foo{f : int},\n+    Bar\n+}\n+\n+pub fn main() {\n+    let e = Bar;\n+    match e {\n+        Foo{f: _f} => fail!(),\n+        _ => (),\n+    }\n+}"}, {"sha": "15d24c41a3d08953f7c415bcc50aa976bbec9344", "filename": "src/test/run-pass/match-enum-struct-1.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-1.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum E {\n+    Foo{f : int},\n+    Bar\n+}\n+\n+pub fn main() {\n+    let e = Foo{f: 1};\n+    match e {\n+        Foo{_} => (),\n+        _ => fail!(),\n+    }\n+    match e {\n+        Foo{f: _f} => (),\n+        _ => fail!(),\n+    }\n+}"}, {"sha": "67e844c519ee8c8740f02ea40e14bbfb2cc357c0", "filename": "src/test/run-pass/match-struct-0.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Frun-pass%2Fmatch-struct-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee59aacac490edd619db1c4e2fcd848f793bc3b9/src%2Ftest%2Frun-pass%2Fmatch-struct-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-struct-0.rs?ref=ee59aacac490edd619db1c4e2fcd848f793bc3b9", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo{\n+    f : int,\n+}\n+\n+pub fn main() {\n+    let f = Foo{f: 1};\n+    match f {\n+        Foo{f: 0} => fail!(),\n+        Foo{_} => (),\n+    }\n+    match f {\n+        Foo{f: 0} => fail!(),\n+        Foo{f: _f} => (),\n+    }\n+    match f {\n+        Foo{f: 0} => fail!(),\n+        _ => (),\n+    }\n+}"}]}