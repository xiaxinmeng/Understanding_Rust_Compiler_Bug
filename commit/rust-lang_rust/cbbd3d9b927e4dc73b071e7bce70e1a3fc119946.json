{"sha": "cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiYmQzZDliOTI3ZTRkYzczYjA3MWU3YmNlNzBlMWEzZmMxMTk5NDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-09T13:25:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-09T13:25:48Z"}, "message": "Auto merge of #31631 - jonas-schievink:agoraphobia, r=nrc\n\n[breaking-batch] Move more uses of `panictry!` out of libsyntax", "tree": {"sha": "b5c96ae5be805b96c7d02e0c42ae7a6081153598", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5c96ae5be805b96c7d02e0c42ae7a6081153598"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "html_url": "https://github.com/rust-lang/rust/commit/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b868411afee1208cfb18f7440df991b9f94265f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b868411afee1208cfb18f7440df991b9f94265f", "html_url": "https://github.com/rust-lang/rust/commit/4b868411afee1208cfb18f7440df991b9f94265f"}, {"sha": "11e0ba43401b0fcf4d61a4e91ad8d7020da74994", "url": "https://api.github.com/repos/rust-lang/rust/commits/11e0ba43401b0fcf4d61a4e91ad8d7020da74994", "html_url": "https://github.com/rust-lang/rust/commit/11e0ba43401b0fcf4d61a4e91ad8d7020da74994"}], "stats": {"total": 248, "additions": 129, "deletions": 119}, "files": [{"sha": "43160ab355858251573a0dd1df7808f768e2bb2e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "patch": "@@ -48,12 +48,10 @@ use std::fs;\n use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n use syntax::ast::{self, NodeIdAssigner};\n-use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::attr::{self, AttrMetaMethods};\n use syntax::diagnostics;\n use syntax::fold::Folder;\n-use syntax::parse;\n-use syntax::parse::token;\n+use syntax::parse::{self, PResult, token};\n use syntax::util::node_count::NodeCounter;\n use syntax::visit;\n use syntax;\n@@ -86,7 +84,13 @@ pub fn compile_input(sess: &Session,\n     // possible to keep the peak memory usage low\n     let (outputs, trans) = {\n         let (outputs, expanded_crate, id) = {\n-            let krate = phase_1_parse_input(sess, cfg, input);\n+            let krate = match phase_1_parse_input(sess, cfg, input) {\n+                Ok(krate) => krate,\n+                Err(mut parse_error) => {\n+                    parse_error.emit();\n+                    return Err(1);\n+                }\n+            };\n \n             controller_entry_point!(after_parse,\n                                     sess,\n@@ -415,17 +419,20 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n     }\n }\n \n-pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input) -> ast::Crate {\n+pub fn phase_1_parse_input<'a>(sess: &'a Session,\n+                               cfg: ast::CrateConfig,\n+                               input: &Input)\n+                               -> PResult<'a, ast::Crate> {\n     // These may be left in an incoherent state after a previous compile.\n     // `clear_tables` and `get_ident_interner().clear()` can be used to free\n     // memory, but they do not restore the initial state.\n     syntax::ext::mtwt::reset_tables();\n     token::reset_ident_interner();\n \n-    let krate = time(sess.time_passes(), \"parsing\", || {\n+    let krate = try!(time(sess.time_passes(), \"parsing\", || {\n         match *input {\n             Input::File(ref file) => {\n-                parse::parse_crate_from_file(&(*file), cfg.clone(), &sess.parse_sess)\n+                parse::parse_crate_from_file(file, cfg.clone(), &sess.parse_sess)\n             }\n             Input::Str(ref src) => {\n                 parse::parse_crate_from_source_str(anon_src().to_string(),\n@@ -434,7 +441,7 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n                                                    &sess.parse_sess)\n             }\n         }\n-    });\n+    }));\n \n     if sess.opts.debugging_opts.ast_json_noexpand {\n         println!(\"{}\", json::as_json(&krate));\n@@ -449,7 +456,7 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n         syntax::show_span::run(sess.diagnostic(), s, &krate);\n     }\n \n-    krate\n+    Ok(krate)\n }\n \n fn count_nodes(krate: &ast::Crate) -> usize {"}, {"sha": "d1c287b1e39325c1af71e8efdd74a495684e1f82", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "patch": "@@ -89,7 +89,7 @@ use std::thread;\n use rustc::session::{early_error, early_warn};\n \n use syntax::ast;\n-use syntax::parse;\n+use syntax::parse::{self, PResult};\n use syntax::errors;\n use syntax::errors::emitter::Emitter;\n use syntax::diagnostics;\n@@ -531,7 +531,19 @@ impl RustcDefaultCalls {\n             return Compilation::Continue;\n         }\n \n-        let attrs = input.map(|input| parse_crate_attrs(sess, input));\n+        let attrs = match input {\n+            None => None,\n+            Some(input) => {\n+                let result = parse_crate_attrs(sess, input);\n+                match result {\n+                    Ok(attrs) => Some(attrs),\n+                    Err(mut parse_error) => {\n+                        parse_error.emit();\n+                        return Compilation::Stop;\n+                    }\n+                }\n+            }\n+        };\n         for req in &sess.opts.prints {\n             match *req {\n                 PrintRequest::TargetList => {\n@@ -977,8 +989,8 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     Some(matches)\n }\n \n-fn parse_crate_attrs(sess: &Session, input: &Input) -> Vec<ast::Attribute> {\n-    let result = match *input {\n+fn parse_crate_attrs<'a>(sess: &'a Session, input: &Input) -> PResult<'a, Vec<ast::Attribute>> {\n+    match *input {\n         Input::File(ref ifile) => {\n             parse::parse_crate_attrs_from_file(ifile, Vec::new(), &sess.parse_sess)\n         }\n@@ -988,8 +1000,7 @@ fn parse_crate_attrs(sess: &Session, input: &Input) -> Vec<ast::Attribute> {\n                                                      Vec::new(),\n                                                      &sess.parse_sess)\n         }\n-    };\n-    result.into_iter().collect()\n+    }\n }\n \n /// Run a procedure which will detect panics in the compiler and print nicer"}, {"sha": "9f9824eae35102a62b40fafe4b594a33973f0d04", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "patch": "@@ -686,7 +686,7 @@ pub fn pretty_print_input(sess: Session,\n                           ppm: PpMode,\n                           opt_uii: Option<UserIdentifiedItem>,\n                           ofile: Option<PathBuf>) {\n-    let krate = driver::phase_1_parse_input(&sess, cfg, input);\n+    let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, input));\n \n     let krate = if let PpmSource(PpmEveryBodyLoops) = ppm {\n         let mut fold = ReplaceBodyWithLoop::new();"}, {"sha": "5c3c5beafad5d7e9e64035fdf676800c8ca9e069", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "patch": "@@ -114,7 +114,7 @@ fn test_env<F>(source_string: &str,\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let krate_config = Vec::new();\n     let input = config::Input::Str(source_string.to_string());\n-    let krate = driver::phase_1_parse_input(&sess, krate_config, &input);\n+    let krate = driver::phase_1_parse_input(&sess, krate_config, &input).unwrap();\n     let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate, \"test\", None)\n                     .expect(\"phase 2 aborted\");\n "}, {"sha": "5a6fe060eb80b0769f08c13524f1d708938d7ab2", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "patch": "@@ -133,7 +133,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let mut cfg = config::build_configuration(&sess);\n     target_features::add_configuration(&mut cfg, &sess);\n \n-    let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n+    let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, &input));\n \n     let name = link::find_crate_name(Some(&sess), &krate.attrs,\n                                      &input);"}, {"sha": "21df784b098742d711c71601597180afc0e2675b", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "patch": "@@ -43,7 +43,7 @@ extern crate rustc_back;\n extern crate rustc_front;\n extern crate rustc_metadata;\n extern crate serialize;\n-extern crate syntax;\n+#[macro_use] extern crate syntax;\n extern crate test as testing;\n extern crate rustc_unicode;\n #[macro_use] extern crate log;"}, {"sha": "6294b676651fe59c000f3a06ee09bb1a09709048", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "patch": "@@ -91,7 +91,7 @@ pub fn run(input: &str,\n \n     let mut cfg = config::build_configuration(&sess);\n     cfg.extend(config::parse_cfgspecs(cfgs.clone()));\n-    let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n+    let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, &input));\n     let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate,\n                                                      \"rustdoc-test\", None)\n         .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");"}, {"sha": "a8bea2da833496675a2b1bd76070b6fff9023265", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "patch": "@@ -458,7 +458,7 @@ pub struct WhereEqPredicate {\n \n /// The set of MetaItems that define the compilation environment of the crate,\n /// used to drive conditional compilation\n-pub type CrateConfig = Vec<P<MetaItem>> ;\n+pub type CrateConfig = Vec<P<MetaItem>>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Crate {"}, {"sha": "f5794f7219bcf224c7c1ae1a3f08f208de9b480f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "patch": "@@ -1519,7 +1519,7 @@ mod tests {\n         let crate_ast = parse::parse_crate_from_source_str(\n             \"<test>\".to_string(),\n             src,\n-            Vec::new(), &sess);\n+            Vec::new(), &sess).unwrap();\n         // should fail:\n         let mut gated_cfgs = vec![];\n         let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut gated_cfgs);\n@@ -1535,7 +1535,7 @@ mod tests {\n         let crate_ast = parse::parse_crate_from_source_str(\n             \"<test>\".to_string(),\n             src,\n-            Vec::new(), &sess);\n+            Vec::new(), &sess).unwrap();\n         let mut gated_cfgs = vec![];\n         let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut gated_cfgs);\n         expand_crate(ecx, vec![], vec![], crate_ast);\n@@ -1549,7 +1549,7 @@ mod tests {\n         let crate_ast = parse::parse_crate_from_source_str(\n             \"<test>\".to_string(),\n             src,\n-            Vec::new(), &sess);\n+            Vec::new(), &sess).unwrap();\n         let mut gated_cfgs = vec![];\n         let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut gated_cfgs);\n         expand_crate(ecx, vec![], vec![], crate_ast);"}, {"sha": "38da478b5edaf4fd60881a7d12d4c1065e63a3c8", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "patch": "@@ -18,12 +18,12 @@ use parse::token::*;\n use parse::token;\n use ptr::P;\n \n-///  Quasiquoting works via token trees.\n+/// Quasiquoting works via token trees.\n ///\n-///  This is registered as a set of expression syntax extension called quote!\n-///  that lifts its argument token-tree to an AST representing the\n-///  construction of the same token tree, with token::SubstNt interpreted\n-///  as antiquotes (splices).\n+/// This is registered as a set of expression syntax extension called quote!\n+/// that lifts its argument token-tree to an AST representing the\n+/// construction of the same token tree, with token::SubstNt interpreted\n+/// as antiquotes (splices).\n \n pub mod rt {\n     use ast;\n@@ -319,34 +319,36 @@ pub mod rt {\n     }\n \n     impl<'a> ExtParseUtils for ExtCtxt<'a> {\n-\n         fn parse_item(&self, s: String) -> P<ast::Item> {\n-            parse::parse_item_from_source_str(\n+            panictry!(parse::parse_item_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n                 self.cfg(),\n-                self.parse_sess()).expect(\"parse error\")\n+                self.parse_sess())).expect(\"parse error\")\n         }\n \n         fn parse_stmt(&self, s: String) -> ast::Stmt {\n-            parse::parse_stmt_from_source_str(\"<quote expansion>\".to_string(),\n-                                              s,\n-                                              self.cfg(),\n-                                              self.parse_sess()).expect(\"parse error\")\n+            panictry!(parse::parse_stmt_from_source_str(\n+                \"<quote expansion>\".to_string(),\n+                s,\n+                self.cfg(),\n+                self.parse_sess())).expect(\"parse error\")\n         }\n \n         fn parse_expr(&self, s: String) -> P<ast::Expr> {\n-            parse::parse_expr_from_source_str(\"<quote expansion>\".to_string(),\n-                                              s,\n-                                              self.cfg(),\n-                                              self.parse_sess())\n+            panictry!(parse::parse_expr_from_source_str(\n+                \"<quote expansion>\".to_string(),\n+                s,\n+                self.cfg(),\n+                self.parse_sess()))\n         }\n \n         fn parse_tts(&self, s: String) -> Vec<TokenTree> {\n-            parse::parse_tts_from_source_str(\"<quote expansion>\".to_string(),\n-                                             s,\n-                                             self.cfg(),\n-                                             self.parse_sess())\n+            panictry!(parse::parse_tts_from_source_str(\n+                \"<quote expansion>\".to_string(),\n+                s,\n+                self.cfg(),\n+                self.parse_sess()))\n         }\n     }\n }"}, {"sha": "ea5d6739e6dd3db8561699ebbc13d908dadb098e", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 62, "deletions": 72, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "patch": "@@ -71,95 +71,97 @@ impl ParseSess {\n // uses a HOF to parse anything, and <source> includes file and\n // source_str.\n \n-pub fn parse_crate_from_file(\n-    input: &Path,\n-    cfg: ast::CrateConfig,\n-    sess: &ParseSess\n-) -> ast::Crate {\n+pub fn parse_crate_from_file<'a>(input: &Path,\n+                                 cfg: ast::CrateConfig,\n+                                 sess: &'a ParseSess)\n+                                 -> PResult<'a, ast::Crate> {\n     let mut parser = new_parser_from_file(sess, cfg, input);\n-    abort_if_errors(parser.parse_crate_mod(), &parser)\n+    parser.parse_crate_mod()\n }\n \n-pub fn parse_crate_attrs_from_file(\n-    input: &Path,\n-    cfg: ast::CrateConfig,\n-    sess: &ParseSess\n-) -> Vec<ast::Attribute> {\n+pub fn parse_crate_attrs_from_file<'a>(input: &Path,\n+                                       cfg: ast::CrateConfig,\n+                                       sess: &'a ParseSess)\n+                                       -> PResult<'a, Vec<ast::Attribute>> {\n     let mut parser = new_parser_from_file(sess, cfg, input);\n-    abort_if_errors(parser.parse_inner_attributes(), &parser)\n+    parser.parse_inner_attributes()\n }\n \n-pub fn parse_crate_from_source_str(name: String,\n-                                   source: String,\n-                                   cfg: ast::CrateConfig,\n-                                   sess: &ParseSess)\n-                                   -> ast::Crate {\n+pub fn parse_crate_from_source_str<'a>(name: String,\n+                                       source: String,\n+                                       cfg: ast::CrateConfig,\n+                                       sess: &'a ParseSess)\n+                                       -> PResult<'a, ast::Crate> {\n     let mut p = new_parser_from_source_str(sess,\n                                            cfg,\n                                            name,\n                                            source);\n-    panictry!(p.parse_crate_mod())\n+    p.parse_crate_mod()\n }\n \n-pub fn parse_crate_attrs_from_source_str(name: String,\n-                                         source: String,\n-                                         cfg: ast::CrateConfig,\n-                                         sess: &ParseSess)\n-                                         -> Vec<ast::Attribute> {\n+pub fn parse_crate_attrs_from_source_str<'a>(name: String,\n+                                             source: String,\n+                                             cfg: ast::CrateConfig,\n+                                             sess: &'a ParseSess)\n+                                             -> PResult<'a, Vec<ast::Attribute>> {\n     let mut p = new_parser_from_source_str(sess,\n                                            cfg,\n                                            name,\n                                            source);\n-    panictry!(p.parse_inner_attributes())\n+    p.parse_inner_attributes()\n }\n \n-pub fn parse_expr_from_source_str(name: String,\n-                                  source: String,\n-                                  cfg: ast::CrateConfig,\n-                                  sess: &ParseSess)\n-                                  -> P<ast::Expr> {\n+pub fn parse_expr_from_source_str<'a>(name: String,\n+                                      source: String,\n+                                      cfg: ast::CrateConfig,\n+                                      sess: &'a ParseSess)\n+                                      -> PResult<'a, P<ast::Expr>> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    panictry!(p.parse_expr())\n+    p.parse_expr()\n }\n \n-pub fn parse_item_from_source_str(name: String,\n-                                  source: String,\n-                                  cfg: ast::CrateConfig,\n-                                  sess: &ParseSess)\n-                                  -> Option<P<ast::Item>> {\n+/// Parses an item.\n+///\n+/// Returns `Ok(Some(item))` when successful, `Ok(None)` when no item was found, and`Err`\n+/// when a syntax error occurred.\n+pub fn parse_item_from_source_str<'a>(name: String,\n+                                      source: String,\n+                                      cfg: ast::CrateConfig,\n+                                      sess: &'a ParseSess)\n+                                      -> PResult<'a, Option<P<ast::Item>>> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    panictry!(p.parse_item())\n+    p.parse_item()\n }\n \n-pub fn parse_meta_from_source_str(name: String,\n-                                  source: String,\n-                                  cfg: ast::CrateConfig,\n-                                  sess: &ParseSess)\n-                                  -> P<ast::MetaItem> {\n+pub fn parse_meta_from_source_str<'a>(name: String,\n+                                      source: String,\n+                                      cfg: ast::CrateConfig,\n+                                      sess: &'a ParseSess)\n+                                      -> PResult<'a, P<ast::MetaItem>> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    panictry!(p.parse_meta_item())\n+    p.parse_meta_item()\n }\n \n-pub fn parse_stmt_from_source_str(name: String,\n-                                  source: String,\n-                                  cfg: ast::CrateConfig,\n-                                  sess: &ParseSess)\n-                                  -> Option<ast::Stmt> {\n+pub fn parse_stmt_from_source_str<'a>(name: String,\n+                                      source: String,\n+                                      cfg: ast::CrateConfig,\n+                                      sess: &'a ParseSess)\n+                                      -> PResult<'a, Option<ast::Stmt>> {\n     let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n         name,\n         source\n     );\n-    panictry!(p.parse_stmt())\n+    p.parse_stmt()\n }\n \n // Warning: This parses with quote_depth > 0, which is not the default.\n-pub fn parse_tts_from_source_str(name: String,\n-                                 source: String,\n-                                 cfg: ast::CrateConfig,\n-                                 sess: &ParseSess)\n-                                 -> Vec<ast::TokenTree> {\n+pub fn parse_tts_from_source_str<'a>(name: String,\n+                                     source: String,\n+                                     cfg: ast::CrateConfig,\n+                                     sess: &'a ParseSess)\n+                                     -> PResult<'a, Vec<ast::TokenTree>> {\n     let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -168,7 +170,7 @@ pub fn parse_tts_from_source_str(name: String,\n     );\n     p.quote_depth += 1;\n     // right now this is re-creating the token trees from ... token trees.\n-    panictry!(p.parse_all_token_trees())\n+    p.parse_all_token_trees()\n }\n \n // Create a new parser from a source string\n@@ -265,20 +267,6 @@ pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n     p\n }\n \n-\n-fn abort_if_errors<'a, T>(result: PResult<'a, T>, p: &Parser) -> T {\n-    match result {\n-        Ok(c) => {\n-            c\n-        }\n-        Err(mut e) => {\n-            e.emit();\n-            p.abort_if_errors();\n-            unreachable!();\n-        }\n-    }\n-}\n-\n /// Parse a string representing a character literal into its final form.\n /// Rather than just accepting/rejecting a given literal, unescapes it as\n /// well. Can take any slice prefixed by a character escape. Returns the\n@@ -1078,19 +1066,21 @@ mod tests {\n \n         let name = \"<source>\".to_string();\n         let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n-        let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n+        let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess)\n+            .unwrap().unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n         assert_eq!(&doc[..], \"/// doc comment\");\n \n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n-        let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n+        let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess)\n+            .unwrap().unwrap();\n         let docs = item.attrs.iter().filter(|a| &*a.name() == \"doc\")\n                     .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n         assert_eq!(&docs[..], b);\n \n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n-        let item = parse_item_from_source_str(name, source, Vec::new(), &sess).unwrap();\n+        let item = parse_item_from_source_str(name, source, Vec::new(), &sess).unwrap().unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n         assert_eq!(&doc[..], \"/** doc comment\\n *  with CRLF */\");\n     }\n@@ -1099,7 +1089,7 @@ mod tests {\n     fn ttdelim_span() {\n         let sess = ParseSess::new();\n         let expr = parse::parse_expr_from_source_str(\"foo\".to_string(),\n-            \"foo!( fn main() { body } )\".to_string(), vec![], &sess);\n+            \"foo!( fn main() { body } )\".to_string(), vec![], &sess).unwrap();\n \n         let tts = match expr.node {\n             ast::ExprKind::Mac(ref mac) => mac.node.tts.clone(),"}, {"sha": "29063c5a607e59c0dcf3dea14c96ac24c38184ef", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd3d9b927e4dc73b071e7bce70e1a3fc119946/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=cbbd3d9b927e4dc73b071e7bce70e1a3fc119946", "patch": "@@ -18,7 +18,7 @@ extern crate rustc_front;\n extern crate rustc_lint;\n extern crate rustc_metadata;\n extern crate rustc_resolve;\n-extern crate syntax;\n+#[macro_use] extern crate syntax;\n \n use std::ffi::{CStr, CString};\n use std::mem::transmute;\n@@ -230,7 +230,7 @@ fn compile_program(input: &str, sysroot: PathBuf)\n \n         let id = \"input\".to_string();\n \n-        let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n+        let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, &input));\n \n         let krate = driver::phase_2_configure_and_expand(&sess, &cstore, krate, &id, None)\n             .expect(\"phase_2 returned `None`\");"}]}