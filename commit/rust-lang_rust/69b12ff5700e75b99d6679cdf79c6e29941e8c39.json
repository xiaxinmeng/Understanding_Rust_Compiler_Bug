{"sha": "69b12ff5700e75b99d6679cdf79c6e29941e8c39", "node_id": "C_kwDOAAsO6NoAKDY5YjEyZmY1NzAwZTc1Yjk5ZDY2NzljZGY3OWM2ZTI5OTQxZThjMzk", "commit": {"author": {"name": "Mads Ravn", "email": "madsravn@gmail.com", "date": "2023-04-10T07:11:45Z"}, "committer": {"name": "Mads Ravn", "email": "madsravn@gmail.com", "date": "2023-04-10T07:11:45Z"}, "message": "Merge remote-tracking branch 'upstream/master'", "tree": {"sha": "88d6c5923565987843ac9b15a30cc059c1f101de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88d6c5923565987843ac9b15a30cc059c1f101de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69b12ff5700e75b99d6679cdf79c6e29941e8c39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69b12ff5700e75b99d6679cdf79c6e29941e8c39", "html_url": "https://github.com/rust-lang/rust/commit/69b12ff5700e75b99d6679cdf79c6e29941e8c39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69b12ff5700e75b99d6679cdf79c6e29941e8c39/comments", "author": {"login": "madsravn", "id": 399452, "node_id": "MDQ6VXNlcjM5OTQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/399452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/madsravn", "html_url": "https://github.com/madsravn", "followers_url": "https://api.github.com/users/madsravn/followers", "following_url": "https://api.github.com/users/madsravn/following{/other_user}", "gists_url": "https://api.github.com/users/madsravn/gists{/gist_id}", "starred_url": "https://api.github.com/users/madsravn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/madsravn/subscriptions", "organizations_url": "https://api.github.com/users/madsravn/orgs", "repos_url": "https://api.github.com/users/madsravn/repos", "events_url": "https://api.github.com/users/madsravn/events{/privacy}", "received_events_url": "https://api.github.com/users/madsravn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "madsravn", "id": 399452, "node_id": "MDQ6VXNlcjM5OTQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/399452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/madsravn", "html_url": "https://github.com/madsravn", "followers_url": "https://api.github.com/users/madsravn/followers", "following_url": "https://api.github.com/users/madsravn/following{/other_user}", "gists_url": "https://api.github.com/users/madsravn/gists{/gist_id}", "starred_url": "https://api.github.com/users/madsravn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/madsravn/subscriptions", "organizations_url": "https://api.github.com/users/madsravn/orgs", "repos_url": "https://api.github.com/users/madsravn/repos", "events_url": "https://api.github.com/users/madsravn/events{/privacy}", "received_events_url": "https://api.github.com/users/madsravn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9aa3f053d705502e60a5167afedbbcfe1d36cded", "url": "https://api.github.com/repos/rust-lang/rust/commits/9aa3f053d705502e60a5167afedbbcfe1d36cded", "html_url": "https://github.com/rust-lang/rust/commit/9aa3f053d705502e60a5167afedbbcfe1d36cded"}, {"sha": "749b487be49b793dd713c429042b33262208f4f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/749b487be49b793dd713c429042b33262208f4f9", "html_url": "https://github.com/rust-lang/rust/commit/749b487be49b793dd713c429042b33262208f4f9"}], "stats": {"total": 625, "additions": 446, "deletions": 179}, "files": [{"sha": "80f497333a632933a764385bfc771ec573c4f415", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -53,7 +53,7 @@ pub fn inject(krate: &mut ast::Crate, sess: &Session, resolver: &mut dyn Resolve\n     // even in non-test builds\n     let test_runner = get_test_runner(span_diagnostic, &krate);\n \n-    if sess.opts.test {\n+    if sess.is_test_crate() {\n         let panic_strategy = match (panic_strategy, sess.opts.unstable_opts.panic_abort_tests) {\n             (PanicStrategy::Abort, true) => PanicStrategy::Abort,\n             (PanicStrategy::Abort, false) => {"}, {"sha": "7a5fa5a370cb9af889e177adaf1bf8c92df764ec", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -2301,7 +2301,7 @@ fn add_native_libs_from_crate(\n                         || (whole_archive == None\n                             && bundle\n                             && cnum == LOCAL_CRATE\n-                            && sess.opts.test);\n+                            && sess.is_test_crate());\n \n                     if bundle && cnum != LOCAL_CRATE {\n                         if let Some(filename) = lib.filename {"}, {"sha": "1d7965ff5f66e544361e4ebb1a6e027a936a0fc7", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -189,3 +189,39 @@ hir_analysis_return_type_notation_equality_bound =\n \n hir_analysis_return_type_notation_missing_method =\n     cannot find associated function `{$assoc_name}` in trait `{$trait_name}`\n+\n+hir_analysis_placeholder_not_allowed_item_signatures = the placeholder `_` is not allowed within types on item signatures for {$kind}\n+    .label = not allowed in type signatures\n+\n+hir_analysis_associated_type_trait_uninferred_generic_params = cannot use the associated type of a trait with uninferred generic parameters\n+    .suggestion = use a fully qualified path with inferred lifetimes\n+\n+hir_analysis_associated_type_trait_uninferred_generic_params_multipart_suggestion = use a fully qualified path with explicit lifetimes\n+\n+hir_analysis_enum_discriminant_overflowed = enum discriminant overflowed\n+    .label = overflowed on value after {$discr}\n+    .note = explicitly set `{$item_name} = {$wrapped_discr}` if that is desired outcome\n+\n+hir_analysis_paren_sugar_attribute = the `#[rustc_paren_sugar]` attribute is a temporary means of controlling which traits can use parenthetical notation\n+    .help = add `#![feature(unboxed_closures)]` to the crate attributes to use it\n+\n+hir_analysis_must_implement_one_of_attribute = the `#[rustc_must_implement_one_of]` attribute must be used with at least 2 args\n+\n+hir_analysis_must_be_name_of_associated_function = must be a name of an associated function\n+\n+hir_analysis_function_not_have_default_implementation = function doesn't have a default implementation\n+    .note = required by this annotation\n+\n+hir_analysis_must_implement_not_function = not a function\n+\n+hir_analysis_must_implement_not_function_span_note = required by this annotation\n+\n+hir_analysis_must_implement_not_function_note = all `#[rustc_must_implement_one_of]` arguments must be associated function names\n+\n+hir_analysis_function_not_found_in_trait = function not found in this trait\n+\n+hir_analysis_functions_names_duplicated = functions names are duplicated\n+    .note = all `#[rustc_must_implement_one_of]` arguments must be unique\n+\n+hir_analysis_simd_ffi_highly_experimental = use of SIMD type{$snip} in FFI is highly experimental and may result in invalid code\n+    .help = add `#![feature(simd_ffi)]` to the crate attributes to enable"}, {"sha": "50862e3426238420bbe1d563c02ee13a8e924955", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 55, "deletions": 110, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -20,7 +20,7 @@ use crate::errors;\n use hir::def::DefKind;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, StashKey};\n+use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n@@ -333,17 +333,7 @@ fn bad_placeholder<'tcx>(\n     let kind = if kind.ends_with('s') { format!(\"{}es\", kind) } else { format!(\"{}s\", kind) };\n \n     spans.sort();\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        spans.clone(),\n-        E0121,\n-        \"the placeholder `_` is not allowed within types on item signatures for {}\",\n-        kind\n-    );\n-    for span in spans {\n-        err.span_label(span, \"not allowed in type signatures\");\n-    }\n-    err\n+    tcx.sess.create_err(errors::PlaceholderNotAllowedItemSignatures { spans, kind })\n }\n \n impl<'tcx> ItemCtxt<'tcx> {\n@@ -419,13 +409,8 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n             self.tcx().mk_projection(item_def_id, item_substs)\n         } else {\n             // There are no late-bound regions; we can just ignore the binder.\n-            let mut err = struct_span_err!(\n-                self.tcx().sess,\n-                span,\n-                E0212,\n-                \"cannot use the associated type of a trait \\\n-                 with uninferred generic parameters\"\n-            );\n+            let (mut mpart_sugg, mut inferred_sugg) = (None, None);\n+            let mut bound = String::new();\n \n             match self.node() {\n                 hir::Node::Field(_) | hir::Node::Ctor(_) | hir::Node::Variant(_) => {\n@@ -444,31 +429,25 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n                                     (bound.span.shrink_to_lo(), format!(\"{}, \", lt_name))\n                                 }\n                             };\n-                            let suggestions = vec![\n-                                (lt_sp, sugg),\n-                                (\n-                                    span.with_hi(item_segment.ident.span.lo()),\n-                                    format!(\n-                                        \"{}::\",\n-                                        // Replace the existing lifetimes with a new named lifetime.\n-                                        self.tcx.replace_late_bound_regions_uncached(\n-                                            poly_trait_ref,\n-                                            |_| {\n-                                                self.tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n-                                                    def_id: item_def_id,\n-                                                    index: 0,\n-                                                    name: Symbol::intern(&lt_name),\n-                                                })\n-                                            }\n-                                        ),\n+                            mpart_sugg = Some(errors::AssociatedTypeTraitUninferredGenericParamsMultipartSuggestion {\n+                                fspan: lt_sp,\n+                                first: sugg,\n+                                sspan: span.with_hi(item_segment.ident.span.lo()),\n+                                second: format!(\n+                                    \"{}::\",\n+                                    // Replace the existing lifetimes with a new named lifetime.\n+                                    self.tcx.replace_late_bound_regions_uncached(\n+                                        poly_trait_ref,\n+                                        |_| {\n+                                            self.tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n+                                                def_id: item_def_id,\n+                                                index: 0,\n+                                                name: Symbol::intern(&lt_name),\n+                                            })\n+                                        }\n                                     ),\n                                 ),\n-                            ];\n-                            err.multipart_suggestion(\n-                                \"use a fully qualified path with explicit lifetimes\",\n-                                suggestions,\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                            });\n                         }\n                         _ => {}\n                     }\n@@ -482,20 +461,23 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n                 | hir::Node::ForeignItem(_)\n                 | hir::Node::TraitItem(_)\n                 | hir::Node::ImplItem(_) => {\n-                    err.span_suggestion_verbose(\n-                        span.with_hi(item_segment.ident.span.lo()),\n-                        \"use a fully qualified path with inferred lifetimes\",\n-                        format!(\n-                            \"{}::\",\n-                            // Erase named lt, we want `<A as B<'_>::C`, not `<A as B<'a>::C`.\n-                            self.tcx.anonymize_bound_vars(poly_trait_ref).skip_binder(),\n-                        ),\n-                        Applicability::MaybeIncorrect,\n+                    inferred_sugg = Some(span.with_hi(item_segment.ident.span.lo()));\n+                    bound = format!(\n+                        \"{}::\",\n+                        // Erase named lt, we want `<A as B<'_>::C`, not `<A as B<'a>::C`.\n+                        self.tcx.anonymize_bound_vars(poly_trait_ref).skip_binder(),\n                     );\n                 }\n                 _ => {}\n             }\n-            self.tcx().ty_error(err.emit())\n+            self.tcx().ty_error(self.tcx().sess.emit_err(\n+                errors::AssociatedTypeTraitUninferredGenericParams {\n+                    span,\n+                    inferred_sugg,\n+                    bound,\n+                    mpart_sugg,\n+                },\n+            ))\n         }\n     }\n \n@@ -763,14 +745,12 @@ fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId) {\n                 Some(discr)\n             } else {\n                 let span = tcx.def_span(variant.def_id);\n-                struct_span_err!(tcx.sess, span, E0370, \"enum discriminant overflowed\")\n-                    .span_label(span, format!(\"overflowed on value after {}\", prev_discr.unwrap()))\n-                    .note(&format!(\n-                        \"explicitly set `{} = {}` if that is desired outcome\",\n-                        tcx.item_name(variant.def_id),\n-                        wrapped_discr\n-                    ))\n-                    .emit();\n+                tcx.sess.emit_err(errors::EnumDiscriminantOverflowed {\n+                    span,\n+                    discr: prev_discr.unwrap().to_string(),\n+                    item_name: tcx.item_name(variant.def_id),\n+                    wrapped_discr: wrapped_discr.to_string(),\n+                });\n                 None\n             }\n             .unwrap_or(wrapped_discr),\n@@ -915,14 +895,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n \n     let paren_sugar = tcx.has_attr(def_id, sym::rustc_paren_sugar);\n     if paren_sugar && !tcx.features().unboxed_closures {\n-        tcx.sess\n-            .struct_span_err(\n-                item.span,\n-                \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n-                 which traits can use parenthetical notation\",\n-            )\n-            .help(\"add `#![feature(unboxed_closures)]` to the crate attributes to use it\")\n-            .emit();\n+        tcx.sess.emit_err(errors::ParenSugarAttribute { span: item.span });\n     }\n \n     let is_marker = tcx.has_attr(def_id, sym::marker);\n@@ -942,13 +915,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n         // and that they are all identifiers\n         .and_then(|attr| match attr.meta_item_list() {\n             Some(items) if items.len() < 2 => {\n-                tcx.sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"the `#[rustc_must_implement_one_of]` attribute must be \\\n-                         used with at least 2 args\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(errors::MustImplementOneOfAttribute { span: attr.span });\n \n                 None\n             }\n@@ -957,9 +924,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n                 .map(|item| item.ident().ok_or(item.span()))\n                 .collect::<Result<Box<[_]>, _>>()\n                 .map_err(|span| {\n-                    tcx.sess\n-                        .struct_span_err(span, \"must be a name of an associated function\")\n-                        .emit();\n+                    tcx.sess.emit_err(errors::MustBeNameOfAssociatedFunction { span });\n                 })\n                 .ok()\n                 .zip(Some(attr.span)),\n@@ -975,33 +940,25 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n                 match item {\n                     Some(item) if matches!(item.kind, hir::AssocItemKind::Fn { .. }) => {\n                         if !tcx.impl_defaultness(item.id.owner_id).has_value() {\n-                            tcx.sess\n-                                .struct_span_err(\n-                                    item.span,\n-                                    \"function doesn't have a default implementation\",\n-                                )\n-                                .span_note(attr_span, \"required by this annotation\")\n-                                .emit();\n+                            tcx.sess.emit_err(errors::FunctionNotHaveDefaultImplementation {\n+                                span: item.span,\n+                                note_span: attr_span,\n+                            });\n \n                             return Some(());\n                         }\n \n                         return None;\n                     }\n                     Some(item) => {\n-                        tcx.sess\n-                            .struct_span_err(item.span, \"not a function\")\n-                            .span_note(attr_span, \"required by this annotation\")\n-                            .note(\n-                                \"all `#[rustc_must_implement_one_of]` arguments must be associated \\\n-                                 function names\",\n-                            )\n-                            .emit();\n+                        tcx.sess.emit_err(errors::MustImplementNotFunction {\n+                            span: item.span,\n+                            span_note: errors::MustImplementNotFunctionSpanNote { span: attr_span },\n+                            note: errors::MustImplementNotFunctionNote {},\n+                        });\n                     }\n                     None => {\n-                        tcx.sess\n-                            .struct_span_err(ident.span, \"function not found in this trait\")\n-                            .emit();\n+                        tcx.sess.emit_err(errors::FunctionNotFoundInTrait { span: ident.span });\n                     }\n                 }\n \n@@ -1018,9 +975,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::TraitDef {\n             for ident in &*list {\n                 if let Some(dup) = set.insert(ident.name, ident.span) {\n                     tcx.sess\n-                        .struct_span_err(vec![dup, ident.span], \"functions names are duplicated\")\n-                        .note(\"all `#[rustc_must_implement_one_of]` arguments must be unique\")\n-                        .emit();\n+                        .emit_err(errors::FunctionNamesDuplicated { spans: vec![dup, ident.span] });\n \n                     no_dups = false;\n                 }\n@@ -1485,17 +1440,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n                     .source_map()\n                     .span_to_snippet(ast_ty.span)\n                     .map_or_else(|_| String::new(), |s| format!(\" `{}`\", s));\n-                tcx.sess\n-                    .struct_span_err(\n-                        ast_ty.span,\n-                        &format!(\n-                            \"use of SIMD type{} in FFI is highly experimental and \\\n-                             may result in invalid code\",\n-                            snip\n-                        ),\n-                    )\n-                    .help(\"add `#![feature(simd_ffi)]` to the crate attributes to enable\")\n-                    .emit();\n+                tcx.sess.emit_err(errors::SIMDFFIHighlyExperimental { span: ast_ty.span, snip });\n             }\n         };\n         for (input, ty) in iter::zip(decl.inputs, fty.inputs().skip_binder()) {"}, {"sha": "2a3a683489ddd21b5a5dcff9c175c9d741a7b7c2", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -507,3 +507,127 @@ pub(crate) struct ReturnTypeNotationMissingMethod {\n     pub trait_name: Symbol,\n     pub assoc_name: Symbol,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_placeholder_not_allowed_item_signatures, code = \"E0121\")]\n+pub(crate) struct PlaceholderNotAllowedItemSignatures {\n+    #[primary_span]\n+    #[label]\n+    pub spans: Vec<Span>,\n+    pub kind: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_associated_type_trait_uninferred_generic_params, code = \"E0212\")]\n+pub(crate) struct AssociatedTypeTraitUninferredGenericParams {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(style = \"verbose\", applicability = \"maybe-incorrect\", code = \"{bound}\")]\n+    pub inferred_sugg: Option<Span>,\n+    pub bound: String,\n+    #[subdiagnostic]\n+    pub mpart_sugg: Option<AssociatedTypeTraitUninferredGenericParamsMultipartSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    hir_analysis_associated_type_trait_uninferred_generic_params_multipart_suggestion,\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub(crate) struct AssociatedTypeTraitUninferredGenericParamsMultipartSuggestion {\n+    #[suggestion_part(code = \"{first}\")]\n+    pub fspan: Span,\n+    pub first: String,\n+    #[suggestion_part(code = \"{second}\")]\n+    pub sspan: Span,\n+    pub second: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_enum_discriminant_overflowed, code = \"E0370\")]\n+#[note]\n+pub(crate) struct EnumDiscriminantOverflowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub discr: String,\n+    pub item_name: Symbol,\n+    pub wrapped_discr: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_paren_sugar_attribute)]\n+#[help]\n+pub(crate) struct ParenSugarAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_must_implement_one_of_attribute)]\n+pub(crate) struct MustImplementOneOfAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_must_be_name_of_associated_function)]\n+pub(crate) struct MustBeNameOfAssociatedFunction {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_function_not_have_default_implementation)]\n+pub(crate) struct FunctionNotHaveDefaultImplementation {\n+    #[primary_span]\n+    pub span: Span,\n+    #[note]\n+    pub note_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_must_implement_not_function)]\n+pub(crate) struct MustImplementNotFunction {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub span_note: MustImplementNotFunctionSpanNote,\n+    #[subdiagnostic]\n+    pub note: MustImplementNotFunctionNote,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(hir_analysis_must_implement_not_function_span_note)]\n+pub(crate) struct MustImplementNotFunctionSpanNote {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(hir_analysis_must_implement_not_function_note)]\n+pub(crate) struct MustImplementNotFunctionNote {}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_function_not_found_in_trait)]\n+pub(crate) struct FunctionNotFoundInTrait {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_functions_names_duplicated)]\n+#[note]\n+pub(crate) struct FunctionNamesDuplicated {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_simd_ffi_highly_experimental)]\n+#[help]\n+pub(crate) struct SIMDFFIHighlyExperimental {\n+    #[primary_span]\n+    pub span: Span,\n+    pub snip: String,\n+}"}, {"sha": "4258a100d986671e3d97ea2f1d9b0719b855efa9", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -793,6 +793,14 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // a `&self` method will wind up with an argument type like `&dyn Trait`.\n         let trait_ref = principal.with_self_ty(self.tcx, self_ty);\n         self.elaborate_bounds(iter::once(trait_ref), |this, new_trait_ref, item| {\n+            if new_trait_ref.has_non_region_late_bound() {\n+                this.tcx.sess.delay_span_bug(\n+                    this.span,\n+                    \"tried to select method from HRTB with non-lifetime bound vars\",\n+                );\n+                return;\n+            }\n+\n             let new_trait_ref = this.erase_late_bound_regions(new_trait_ref);\n \n             let (xform_self_ty, xform_ret_ty) =\n@@ -843,18 +851,15 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         });\n \n         self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {\n-            let trait_ref = this.erase_late_bound_regions(poly_trait_ref);\n+            let trait_ref = this.instantiate_binder_with_fresh_vars(\n+                this.span,\n+                infer::LateBoundRegionConversionTime::FnCall,\n+                poly_trait_ref,\n+            );\n \n             let (xform_self_ty, xform_ret_ty) =\n                 this.xform_self_ty(item, trait_ref.self_ty(), trait_ref.substs);\n \n-            // Because this trait derives from a where-clause, it\n-            // should not contain any inference variables or other\n-            // artifacts. This means it is safe to put into the\n-            // `WhereClauseCandidate` and (eventually) into the\n-            // `WhereClausePick`.\n-            assert!(!trait_ref.substs.needs_infer());\n-\n             this.push_candidate(\n                 Candidate {\n                     xform_self_ty,\n@@ -964,7 +969,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                             bound_trait_ref.def_id(),\n                         ));\n                     } else {\n-                        let new_trait_ref = self.erase_late_bound_regions(bound_trait_ref);\n+                        let new_trait_ref = self.instantiate_binder_with_fresh_vars(\n+                            self.span,\n+                            infer::LateBoundRegionConversionTime::FnCall,\n+                            bound_trait_ref,\n+                        );\n \n                         let (xform_self_ty, xform_ret_ty) =\n                             self.xform_self_ty(item, new_trait_ref.self_ty(), new_trait_ref.substs);"}, {"sha": "af0bd26dec5f91983a811c2735b41e07d7be92f5", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -37,6 +37,10 @@ pointers. If you encounter this error you should try to avoid dereferencing the\n You can read more about trait objects in the Trait Objects section of the Reference: \\\n https://doc.rust-lang.org/reference/types.html#trait-objects\";\n \n+fn is_number(text: &str) -> bool {\n+    text.chars().all(|c: char| c.is_digit(10))\n+}\n+\n /// Information about the expected type at the top level of type checking a pattern.\n ///\n /// **NOTE:** This is only for use by diagnostics. Do NOT use for type checking logic!\n@@ -1673,7 +1677,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fields: &'tcx [hir::PatField<'tcx>],\n         variant: &ty::VariantDef,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        if let (Some(CtorKind::Fn), PatKind::Struct(qpath, ..)) = (variant.ctor_kind(), &pat.kind) {\n+        if let (Some(CtorKind::Fn), PatKind::Struct(qpath, pattern_fields, ..)) =\n+            (variant.ctor_kind(), &pat.kind)\n+        {\n+            let is_tuple_struct_match = !pattern_fields.is_empty()\n+                && pattern_fields.iter().map(|field| field.ident.name.as_str()).all(is_number);\n+            if is_tuple_struct_match {\n+                return None;\n+            }\n+\n             let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n                 s.print_qpath(qpath, false)\n             });\n@@ -1895,7 +1907,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 prefix,\n                 unmentioned_fields\n                     .iter()\n-                    .map(|(_, name)| name.to_string())\n+                    .map(|(_, name)| {\n+                        let field_name = name.to_string();\n+                        if is_number(&field_name) {\n+                            format!(\"{}: _\", field_name)\n+                        } else {\n+                            field_name\n+                        }\n+                    })\n                     .collect::<Vec<_>>()\n                     .join(\", \"),\n                 if have_inaccessible_fields { \", ..\" } else { \"\" },"}, {"sha": "0e4e20c7cd1d4de48821d8d2369de0c3dc87dcb1", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -230,7 +230,7 @@ fn configure_and_expand(\n             features: Some(features),\n             recursion_limit,\n             trace_mac: sess.opts.unstable_opts.trace_macros,\n-            should_test: sess.opts.test,\n+            should_test: sess.is_test_crate(),\n             span_debug: sess.opts.unstable_opts.span_debug,\n             proc_macro_backtrace: sess.opts.unstable_opts.proc_macro_backtrace,\n             ..rustc_expand::expand::ExpansionConfig::default(crate_name.to_string())\n@@ -292,7 +292,7 @@ fn configure_and_expand(\n     }\n \n     sess.time(\"maybe_create_a_macro_crate\", || {\n-        let is_test_crate = sess.opts.test;\n+        let is_test_crate = sess.is_test_crate();\n         rustc_builtin_macros::proc_macro_harness::inject(\n             &mut krate,\n             sess,"}, {"sha": "4a35c6794663e09e8d1b927fdfb39df29bcd4e6b", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -530,7 +530,7 @@ struct MissingStabilityAnnotations<'tcx> {\n impl<'tcx> MissingStabilityAnnotations<'tcx> {\n     fn check_missing_stability(&self, def_id: LocalDefId, span: Span) {\n         let stab = self.tcx.stability().local_stability(def_id);\n-        if !self.tcx.sess.opts.test\n+        if !self.tcx.sess.is_test_crate()\n             && stab.is_none()\n             && self.effective_visibilities.is_reachable(def_id)\n         {"}, {"sha": "ae3fd0ede6cffba21b839fc13b7db32adc6812b6", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -393,7 +393,7 @@ impl Resolver<'_, '_> {\n             // If we are in the `--test` mode, suppress a help that adds the `#[cfg(test)]`\n             // attribute; however, if not, suggest adding the attribute. There is no way to\n             // retrieve attributes here because we do not have a `TyCtxt` yet.\n-            let test_module_span = if tcx.sess.opts.test {\n+            let test_module_span = if tcx.sess.is_test_crate() {\n                 None\n             } else {\n                 let parent_module = visitor.r.get_nearest_non_block_module("}, {"sha": "613abaa8e3cd168d86acf8cec0e82b7d9ede20b6", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -1258,7 +1258,7 @@ pub fn build_configuration(sess: &Session, mut user_cfg: CrateConfig) -> CrateCo\n     // some default and generated configuration items.\n     let default_cfg = default_configuration(sess);\n     // If the user wants a test runner, then add the test cfg.\n-    if sess.opts.test {\n+    if sess.is_test_crate() {\n         user_cfg.insert((sym::test, None));\n     }\n     user_cfg.extend(default_cfg.iter().cloned());"}, {"sha": "340bb158e1791e593e97b7185cb6de22fbc913e2", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -294,6 +294,11 @@ impl Session {\n         self.crate_types.get().unwrap().as_slice()\n     }\n \n+    /// Returns true if the crate is a testing one.\n+    pub fn is_test_crate(&self) -> bool {\n+        self.opts.test\n+    }\n+\n     pub fn needs_crate_hash(&self) -> bool {\n         // Why is the crate hash needed for these configurations?\n         // - debug_assertions: for the \"fingerprint the result\" check in"}, {"sha": "a1e97bb95bc690bb8346b80d0f5aa7f7b606a285", "filename": "compiler/rustc_ty_utils/messages.ftl", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_ty_utils%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_ty_utils%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fmessages.ftl?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -45,3 +45,13 @@ ty_utils_control_flow_not_supported = control flow is not supported in generic c\n ty_utils_inline_asm_not_supported = assembly is not supported in generic constants\n \n ty_utils_operation_not_supported = unsupported operation in generic constants\n+\n+ty_utils_unexpected_fnptr_associated_item = `FnPtr` trait with unexpected associated item\n+\n+ty_utils_zero_length_simd_type = monomorphising SIMD type `{$ty}` of zero length\n+\n+ty_utils_multiple_array_fields_simd_type = monomorphising SIMD type `{$ty}` with more than one array field\n+\n+ty_utils_oversized_simd_type = monomorphising SIMD type `{$ty}` of length greater than {$max_lanes}\n+\n+ty_utils_non_primative_simd_type = monomorphising SIMD type `{$ty}` with a non-primitive-scalar (integer/float/pointer) element type `{$e_ty}`"}, {"sha": "3db3c98e9e28ed5b483a4fd5a6b562b37d152787", "filename": "compiler/rustc_ty_utils/src/errors.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -67,3 +67,36 @@ pub enum GenericConstantTooComplexSub {\n     #[label(ty_utils_operation_not_supported)]\n     OperationNotSupported(#[primary_span] Span),\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(ty_utils_unexpected_fnptr_associated_item)]\n+pub struct UnexpectedFnPtrAssociatedItem {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ty_utils_zero_length_simd_type)]\n+pub struct ZeroLengthSimdType<'tcx> {\n+    pub ty: Ty<'tcx>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ty_utils_multiple_array_fields_simd_type)]\n+pub struct MultipleArrayFieldsSimdType<'tcx> {\n+    pub ty: Ty<'tcx>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ty_utils_oversized_simd_type)]\n+pub struct OversizedSimdType<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub max_lanes: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ty_utils_non_primative_simd_type)]\n+pub struct NonPrimitiveSimdType<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub e_ty: Ty<'tcx>,\n+}"}, {"sha": "0a6c118093e50657237e62cd9a3a177a67e13657", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -8,6 +8,8 @@ use rustc_span::sym;\n use rustc_trait_selection::traits;\n use traits::{translate_substs, Reveal};\n \n+use crate::errors::UnexpectedFnPtrAssociatedItem;\n+\n fn resolve_instance<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, (DefId, SubstsRef<'tcx>)>,\n@@ -282,10 +284,9 @@ fn resolve_associated_item<'tcx>(\n                         substs: rcvr_substs,\n                     })\n                 } else {\n-                    tcx.sess.span_fatal(\n-                        tcx.def_span(trait_item_id),\n-                        \"`FnPtrAddr` trait with unexpected assoc item\",\n-                    )\n+                    tcx.sess.emit_fatal(UnexpectedFnPtrAssociatedItem {\n+                        span: tcx.def_span(trait_item_id),\n+                    })\n                 }\n             } else {\n                 None"}, {"sha": "63eb34f7d5529415083358904c166b3774451ead", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -17,6 +17,9 @@ use rustc_target::abi::*;\n use std::fmt::Debug;\n use std::iter;\n \n+use crate::errors::{\n+    MultipleArrayFieldsSimdType, NonPrimitiveSimdType, OversizedSimdType, ZeroLengthSimdType,\n+};\n use crate::layout_sanity_check::sanity_check_layout;\n \n pub fn provide(providers: &mut ty::query::Providers) {\n@@ -294,6 +297,8 @@ fn layout_of_uncached<'tcx>(\n                 return Err(LayoutError::Unknown(ty));\n             }\n \n+            let fields = &def.non_enum_variant().fields;\n+\n             // Supported SIMD vectors are homogeneous ADTs with at least one field:\n             //\n             // * #[repr(simd)] struct S(T, T, T, T);\n@@ -304,18 +309,22 @@ fn layout_of_uncached<'tcx>(\n \n             // SIMD vectors with zero fields are not supported.\n             // (should be caught by typeck)\n-            if def.non_enum_variant().fields.is_empty() {\n-                tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` of zero length\", ty));\n+            if fields.is_empty() {\n+                tcx.sess.emit_fatal(ZeroLengthSimdType { ty })\n             }\n \n             // Type of the first ADT field:\n-            let f0_ty = def.non_enum_variant().fields[FieldIdx::from_u32(0)].ty(tcx, substs);\n+            let f0_ty = fields[FieldIdx::from_u32(0)].ty(tcx, substs);\n \n             // Heterogeneous SIMD vectors are not supported:\n             // (should be caught by typeck)\n-            for fi in &def.non_enum_variant().fields {\n+            for fi in fields {\n                 if fi.ty(tcx, substs) != f0_ty {\n-                    tcx.sess.fatal(&format!(\"monomorphising heterogeneous SIMD type `{}`\", ty));\n+                    tcx.sess.delay_span_bug(\n+                        DUMMY_SP,\n+                        \"#[repr(simd)] was applied to an ADT with hetrogeneous field type\",\n+                    );\n+                    return Err(LayoutError::Unknown(ty));\n                 }\n             }\n \n@@ -330,12 +339,9 @@ fn layout_of_uncached<'tcx>(\n                 // First ADT field is an array:\n \n                 // SIMD vectors with multiple array fields are not supported:\n-                // (should be caught by typeck)\n+                // Can't be caught by typeck with a generic simd type.\n                 if def.non_enum_variant().fields.len() != 1 {\n-                    tcx.sess.fatal(&format!(\n-                        \"monomorphising SIMD type `{}` with more than one array field\",\n-                        ty\n-                    ));\n+                    tcx.sess.emit_fatal(MultipleArrayFieldsSimdType { ty });\n                 }\n \n                 // Extract the number of elements from the layout of the array field:\n@@ -355,24 +361,17 @@ fn layout_of_uncached<'tcx>(\n             //\n             // Can't be caught in typeck if the array length is generic.\n             if e_len == 0 {\n-                tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` of zero length\", ty));\n+                tcx.sess.emit_fatal(ZeroLengthSimdType { ty });\n             } else if e_len > MAX_SIMD_LANES {\n-                tcx.sess.fatal(&format!(\n-                    \"monomorphising SIMD type `{}` of length greater than {}\",\n-                    ty, MAX_SIMD_LANES,\n-                ));\n+                tcx.sess.emit_fatal(OversizedSimdType { ty, max_lanes: MAX_SIMD_LANES });\n             }\n \n             // Compute the ABI of the element type:\n             let e_ly = cx.layout_of(e_ty)?;\n             let Abi::Scalar(e_abi) = e_ly.abi else {\n                 // This error isn't caught in typeck, e.g., if\n                 // the element type of the vector is generic.\n-                tcx.sess.fatal(&format!(\n-                    \"monomorphising SIMD type `{}` with a non-primitive-scalar \\\n-                    (integer/float/pointer) element type `{}`\",\n-                    ty, e_ty\n-                ))\n+                tcx.sess.emit_fatal(NonPrimitiveSimdType { ty, e_ty });\n             };\n \n             // Compute the size and alignment of the vector:"}, {"sha": "2613445f39bec0a28040e6609bd50a00afb1342b", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -10,6 +10,8 @@\n #![feature(never_type)]\n #![feature(box_patterns)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_middle;"}, {"sha": "74dd22df9e0627770ce1ba3446ea7f93179f34e1", "filename": "src/bootstrap/CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/src%2Fbootstrap%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/src%2Fbootstrap%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCHANGELOG.md?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -17,6 +17,7 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n - `remote-test-server`'s `remote` argument has been removed in favor of the `--bind` flag. Use `--bind 0.0.0.0:12345` to replicate the behavior of the `remote` argument.\n - `x.py fmt` now formats only files modified between the merge-base of HEAD and the last commit in the master branch of the rust-lang repository and the current working directory. To restore old behaviour, use `x.py fmt .`. The check mode is not affected by this change. [#105702](https://github.com/rust-lang/rust/pull/105702)\n - The `llvm.version-check` config option has been removed. Older versions were never supported. If you still need to support older versions (e.g. you are applying custom patches), patch `check_llvm_version` in bootstrap to change the minimum version. [#108619](https://github.com/rust-lang/rust/pull/108619)\n+- The `rust.ignore-git` option has been renamed to `rust.omit-git-hash`. [#110059](https://github.com/rust-lang/rust/pull/110059)\n \n ### Non-breaking changes\n "}, {"sha": "8ce220c86478145cb229e71da91702d77d68556d", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -1488,7 +1488,7 @@ impl Step for Extended {\n \n         let xform = |p: &Path| {\n             let mut contents = t!(fs::read_to_string(p));\n-            for tool in &[\"rust-demangler\", \"miri\"] {\n+            for tool in &[\"rust-demangler\", \"miri\", \"rust-docs\"] {\n                 if !built_tools.contains(tool) {\n                     contents = filter(&contents, tool);\n                 }\n@@ -1585,11 +1585,10 @@ impl Step for Extended {\n             prepare(\"rustc\");\n             prepare(\"cargo\");\n             prepare(\"rust-analysis\");\n-            prepare(\"rust-docs\");\n             prepare(\"rust-std\");\n             prepare(\"clippy\");\n             prepare(\"rust-analyzer\");\n-            for tool in &[\"rust-demangler\", \"miri\"] {\n+            for tool in &[\"rust-docs\", \"rust-demangler\", \"miri\"] {\n                 if built_tools.contains(tool) {\n                     prepare(tool);\n                 }\n@@ -1624,23 +1623,25 @@ impl Step for Extended {\n                     .arg(\"-out\")\n                     .arg(exe.join(\"RustcGroup.wxs\")),\n             );\n-            builder.run(\n-                Command::new(&heat)\n-                    .current_dir(&exe)\n-                    .arg(\"dir\")\n-                    .arg(\"rust-docs\")\n-                    .args(&heat_flags)\n-                    .arg(\"-cg\")\n-                    .arg(\"DocsGroup\")\n-                    .arg(\"-dr\")\n-                    .arg(\"Docs\")\n-                    .arg(\"-var\")\n-                    .arg(\"var.DocsDir\")\n-                    .arg(\"-out\")\n-                    .arg(exe.join(\"DocsGroup.wxs\"))\n-                    .arg(\"-t\")\n-                    .arg(etc.join(\"msi/squash-components.xsl\")),\n-            );\n+            if built_tools.contains(\"rust-docs\") {\n+                builder.run(\n+                    Command::new(&heat)\n+                        .current_dir(&exe)\n+                        .arg(\"dir\")\n+                        .arg(\"rust-docs\")\n+                        .args(&heat_flags)\n+                        .arg(\"-cg\")\n+                        .arg(\"DocsGroup\")\n+                        .arg(\"-dr\")\n+                        .arg(\"Docs\")\n+                        .arg(\"-var\")\n+                        .arg(\"var.DocsDir\")\n+                        .arg(\"-out\")\n+                        .arg(exe.join(\"DocsGroup.wxs\"))\n+                        .arg(\"-t\")\n+                        .arg(etc.join(\"msi/squash-components.xsl\")),\n+                );\n+            }\n             builder.run(\n                 Command::new(&heat)\n                     .current_dir(&exe)\n@@ -1787,7 +1788,6 @@ impl Step for Extended {\n                 cmd.current_dir(&exe)\n                     .arg(\"-nologo\")\n                     .arg(\"-dRustcDir=rustc\")\n-                    .arg(\"-dDocsDir=rust-docs\")\n                     .arg(\"-dCargoDir=cargo\")\n                     .arg(\"-dStdDir=rust-std\")\n                     .arg(\"-dAnalysisDir=rust-analysis\")\n@@ -1799,6 +1799,9 @@ impl Step for Extended {\n                     .arg(&input);\n                 add_env(builder, &mut cmd, target);\n \n+                if built_tools.contains(\"rust-docs\") {\n+                    cmd.arg(\"-dDocsDir=rust-docs\");\n+                }\n                 if built_tools.contains(\"rust-demangler\") {\n                     cmd.arg(\"-dRustDemanglerDir=rust-demangler\");\n                 }\n@@ -1817,7 +1820,9 @@ impl Step for Extended {\n             candle(&etc.join(\"msi/ui.wxs\"));\n             candle(&etc.join(\"msi/rustwelcomedlg.wxs\"));\n             candle(\"RustcGroup.wxs\".as_ref());\n-            candle(\"DocsGroup.wxs\".as_ref());\n+            if built_tools.contains(\"rust-docs\") {\n+                candle(\"DocsGroup.wxs\".as_ref());\n+            }\n             candle(\"CargoGroup.wxs\".as_ref());\n             candle(\"StdGroup.wxs\".as_ref());\n             candle(\"ClippyGroup.wxs\".as_ref());\n@@ -1854,7 +1859,6 @@ impl Step for Extended {\n                 .arg(\"ui.wixobj\")\n                 .arg(\"rustwelcomedlg.wixobj\")\n                 .arg(\"RustcGroup.wixobj\")\n-                .arg(\"DocsGroup.wixobj\")\n                 .arg(\"CargoGroup.wixobj\")\n                 .arg(\"StdGroup.wixobj\")\n                 .arg(\"AnalysisGroup.wixobj\")\n@@ -1870,6 +1874,9 @@ impl Step for Extended {\n             if built_tools.contains(\"rust-demangler\") {\n                 cmd.arg(\"RustDemanglerGroup.wixobj\");\n             }\n+            if built_tools.contains(\"rust-docs\") {\n+                cmd.arg(\"DocsGroup.wixobj\");\n+            }\n \n             if target.ends_with(\"windows-gnu\") {\n                 cmd.arg(\"GccGroup.wixobj\");"}, {"sha": "9f4e4fd0611df6a7569f1ad0b1c9dc93d22a15c5", "filename": "src/etc/installer/msi/rust.wxs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -167,7 +167,9 @@\n                     <?if $(env.CFG_MINGW)=\"1\" ?>\n                         <Directory Id=\"Gcc\" Name=\".\" />\n                     <?endif?>\n+                    <!-- tool-rust-docs-start -->\n                     <Directory Id=\"Docs\" Name=\".\" />\n+                    <!-- tool-rust-docs-end -->\n                     <Directory Id=\"Cargo\" Name=\".\" />\n                     <Directory Id=\"Std\" Name=\".\" />\n                 </Directory>\n@@ -209,6 +211,7 @@\n                         <RegistryValue Root=\"HKMU\" Key=\"$(var.BaseRegKey)\" Name=\"RustShell\" Type=\"integer\" Value=\"1\" KeyPath=\"yes\" />\n                         <RemoveFolder Id=\"ApplicationProgramsFolder1\" On=\"uninstall\" />\n                     </Component>\n+                    <!-- tool-rust-docs-start -->\n                     <Component Id=\"DocIndexShortcut\" Guid=\"*\">\n                         <Shortcut Id=\"RustDocs\"\n                                   Name=\"$(var.ProductName) Documentation\"\n@@ -217,6 +220,7 @@\n                         <RegistryValue Root=\"HKMU\" Key=\"$(var.BaseRegKey)\" Name=\"RustDocs\" Type=\"integer\" Value=\"1\" KeyPath=\"yes\" />\n                         <RemoveFolder Id=\"ApplicationProgramsFolder2\" On=\"uninstall\" />\n                     </Component>\n+                    <!-- tool-rust-docs-end -->\n                 </Directory>\n             </Directory>\n \n@@ -256,6 +260,7 @@\n                      <ComponentGroupRef Id=\"GccGroup\" />\n             </Feature>\n         <?endif?>\n+        <!-- tool-rust-docs-start -->\n         <Feature Id=\"Docs\"\n                  Title=\"HTML documentation\"\n                  Display=\"5\"\n@@ -264,6 +269,7 @@\n                  <ComponentGroupRef Id=\"DocsGroup\" />\n                  <ComponentRef Id=\"DocIndexShortcut\" />\n         </Feature>\n+        <!-- tool-rust-docs-end -->\n         <Feature Id=\"Path\"\n                  Title=\"Add to PATH\"\n                  Description=\"Add Rust to PATH environment variable\""}, {"sha": "1643fc8364b64a3b806b08fbb01d48d7da146f8e", "filename": "src/etc/installer/pkg/Distribution.xml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/src%2Fetc%2Finstaller%2Fpkg%2FDistribution.xml", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/src%2Fetc%2Finstaller%2Fpkg%2FDistribution.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fpkg%2FDistribution.xml?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -15,7 +15,9 @@\n       <line choice=\"rustc\"/>\n       <line choice=\"rust-std\"/>\n       <line choice=\"cargo\"/>\n+      <!-- tool-rust-docs-start -->\n       <line choice=\"rust-docs\"/>\n+      <!-- tool-rust-docs-end -->\n       </line>\n       <line choice=\"uninstall\" />\n     </choices-outline>\n@@ -55,15 +57,19 @@\n         >\n         <pkg-ref id=\"org.rust-lang.rust-std\"/>\n     </choice>\n+    <!-- tool-rust-docs-start -->\n     <choice id=\"rust-docs\" visible=\"true\"\n         title=\"Documentation\" description=\"HTML documentation.\"\n         selected=\"(!choices.uninstall.selected &amp;&amp; choices['rust-docs'].selected) || (choices.uninstall.selected &amp;&amp; choices.install.selected)\"\n         >\n         <pkg-ref id=\"org.rust-lang.rust-docs\"/>\n     </choice>\n+    <!-- tool-rust-docs-end -->\n     <pkg-ref id=\"org.rust-lang.rustc\" version=\"0\" onConclusion=\"none\">rustc.pkg</pkg-ref>\n     <pkg-ref id=\"org.rust-lang.cargo\" version=\"0\" onConclusion=\"none\">cargo.pkg</pkg-ref>\n+    <!-- tool-rust-docs-start -->\n     <pkg-ref id=\"org.rust-lang.rust-docs\" version=\"0\" onConclusion=\"none\">rust-docs.pkg</pkg-ref>\n+    <!-- tool-rust-docs-end -->\n     <pkg-ref id=\"org.rust-lang.rust-std\" version=\"0\" onConclusion=\"none\">rust-std.pkg</pkg-ref>\n     <pkg-ref id=\"org.rust-lang.uninstall\" version=\"0\" onConclusion=\"none\">uninstall.pkg</pkg-ref>\n     <background file=\"rust-logo.png\" mime-type=\"image/png\""}, {"sha": "e55c82c4b6340d01688d66b618c23e26733bacff", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -2135,15 +2135,15 @@ impl<'test> TestCx<'test> {\n             if let Some(ref p) = self.config.nodejs {\n                 args.push(p.clone());\n             } else {\n-                self.fatal(\"no NodeJS binary found (--nodejs)\");\n+                self.fatal(\"emscripten target requested and no NodeJS binary found (--nodejs)\");\n             }\n         // If this is otherwise wasm, then run tests under nodejs with our\n         // shim\n         } else if self.config.target.contains(\"wasm32\") {\n             if let Some(ref p) = self.config.nodejs {\n                 args.push(p.clone());\n             } else {\n-                self.fatal(\"no NodeJS binary found (--nodejs)\");\n+                self.fatal(\"wasm32 target requested and no NodeJS binary found (--nodejs)\");\n             }\n \n             let src = self"}, {"sha": "42e380dbb779bb70ec42d5cb28eb3e9871b42ff4", "filename": "tests/ui/simd/monomorphize-heterogeneous.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/tests%2Fui%2Fsimd%2Fmonomorphize-heterogeneous.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/tests%2Fui%2Fsimd%2Fmonomorphize-heterogeneous.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsimd%2Fmonomorphize-heterogeneous.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -0,0 +1,9 @@\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct I64F64(i64, f64);\n+//~^ ERROR SIMD vector should be homogeneous\n+\n+static X: I64F64 = I64F64(1, 2.0);\n+\n+fn main() {}"}, {"sha": "e7b41cd787cd2de21c25198cb0a174df21624e48", "filename": "tests/ui/simd/monomorphize-heterogeneous.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/tests%2Fui%2Fsimd%2Fmonomorphize-heterogeneous.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/tests%2Fui%2Fsimd%2Fmonomorphize-heterogeneous.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsimd%2Fmonomorphize-heterogeneous.stderr?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -0,0 +1,9 @@\n+error[E0076]: SIMD vector should be homogeneous\n+  --> $DIR/monomorphize-heterogeneous.rs:4:1\n+   |\n+LL | struct I64F64(i64, f64);\n+   | ^^^^^^^^^^^^^ SIMD elements must have the same type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0076`."}, {"sha": "33f264aa25091739096eaddeafd24349cacf58c9", "filename": "tests/ui/structs/struct-tuple-field-names.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/tests%2Fui%2Fstructs%2Fstruct-tuple-field-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/tests%2Fui%2Fstructs%2Fstruct-tuple-field-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstructs%2Fstruct-tuple-field-names.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -12,4 +12,7 @@ fn main() {\n     match y {\n         S { } => {} //~ ERROR: tuple variant `S` written as struct variant [E0769]\n     }\n+\n+    if let E::S { 0: a } = x { //~ ERROR: pattern does not mention field `1`\n+    }\n }"}, {"sha": "0b837a47a82542d278e640b61333c6fa71c51500", "filename": "tests/ui/structs/struct-tuple-field-names.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/tests%2Fui%2Fstructs%2Fstruct-tuple-field-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/tests%2Fui%2Fstructs%2Fstruct-tuple-field-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstructs%2Fstruct-tuple-field-names.stderr?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -20,6 +20,22 @@ help: use the tuple variant pattern syntax instead\n LL |         S(_, _) => {}\n    |          ~~~~~~\n \n-error: aborting due to 2 previous errors\n+error[E0027]: pattern does not mention field `1`\n+  --> $DIR/struct-tuple-field-names.rs:16:12\n+   |\n+LL |     if let E::S { 0: a } = x {\n+   |            ^^^^^^^^^^^^^ missing field `1`\n+   |\n+help: include the missing field in the pattern\n+   |\n+LL |     if let E::S { 0: a, 1: _ } = x {\n+   |                       ~~~~~~~~\n+help: if you don't care about this missing field, you can explicitly ignore it\n+   |\n+LL |     if let E::S { 0: a, .. } = x {\n+   |                       ~~~~~~\n+\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0769`.\n+Some errors have detailed explanations: E0027, E0769.\n+For more information about an error, try `rustc --explain E0027`."}, {"sha": "8df240c2082b723e4b1f274fb534a177322ab52d", "filename": "tests/ui/traits/non_lifetime_binders/method-probe.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fmethod-probe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fmethod-probe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fmethod-probe.rs?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+#![feature(non_lifetime_binders)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+\n+trait Foo: for<T> Bar<T> {}\n+\n+trait Bar<T> {\n+    fn method() -> T;\n+}\n+\n+fn x<T: Foo>() {\n+    let _: i32 = T::method();\n+}\n+\n+fn main() {}"}, {"sha": "8f61792e6ce7fe61382d822a2a7ab1d74c1e45c9", "filename": "tests/ui/traits/non_lifetime_binders/method-probe.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/69b12ff5700e75b99d6679cdf79c6e29941e8c39/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fmethod-probe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69b12ff5700e75b99d6679cdf79c6e29941e8c39/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fmethod-probe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fmethod-probe.stderr?ref=69b12ff5700e75b99d6679cdf79c6e29941e8c39", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/method-probe.rs:3:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #108185 <https://github.com/rust-lang/rust/issues/108185> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: 1 warning emitted\n+"}]}