{"sha": "8c59d920a12fe40398a0033438ff426bb3387fd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNTlkOTIwYTEyZmU0MDM5OGEwMDMzNDM4ZmY0MjZiYjMzODdmZDA=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T13:57:41Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T14:08:57Z"}, "message": "std: basic documentation for the new str methods", "tree": {"sha": "e5e2b1c038d4385ec88ef5bbfc0a1814347e4ad0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5e2b1c038d4385ec88ef5bbfc0a1814347e4ad0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c59d920a12fe40398a0033438ff426bb3387fd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c59d920a12fe40398a0033438ff426bb3387fd0", "html_url": "https://github.com/rust-lang/rust/commit/8c59d920a12fe40398a0033438ff426bb3387fd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c59d920a12fe40398a0033438ff426bb3387fd0/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccd0ac59e9a918f3c2a174e31213286dc6867d37", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd0ac59e9a918f3c2a174e31213286dc6867d37", "html_url": "https://github.com/rust-lang/rust/commit/ccd0ac59e9a918f3c2a174e31213286dc6867d37"}], "stats": {"total": 88, "additions": 68, "deletions": 20}, "files": [{"sha": "a7fe102738d39b993c0983ae367202bb287fb5ef", "filename": "src/libstd/str.rs", "status": "modified", "additions": 68, "deletions": 20, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8c59d920a12fe40398a0033438ff426bb3387fd0/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c59d920a12fe40398a0033438ff426bb3387fd0/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=8c59d920a12fe40398a0033438ff426bb3387fd0", "patch": "@@ -155,9 +155,7 @@ pub fn from_chars(chs: &[char]) -> ~str {\n     buf\n }\n \n-/// A function version of the `.push_str`, required for `fmt!` during\n-/// the bootstrap. Use `lhs.push_str(rhs)` instead of this.\n-#[doc=\"hidden\"]\n+#[doc(hidden)]\n pub fn push_str(lhs: &mut ~str, rhs: &str) {\n     lhs.push_str(rhs)\n }\n@@ -1604,25 +1602,9 @@ pub trait StrSlice<'self> {\n     fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> StrCharSplitIterator<'self, Sep>;\n     fn split_options_iter<Sep: CharEq>(&self, sep: Sep, count: uint, allow_trailing_empty: bool)\n         -> StrCharSplitIterator<'self, Sep>;\n-    /// An iterator over the start and end indices of each match of\n-    /// `sep` within `self`.\n     fn matches_index_iter(&self, sep: &'self str) -> StrMatchesIndexIterator<'self>;\n-    /**\n-     * An iterator over the substrings of `self` separated by `sep`.\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     * let v: ~[&str] = \".XXX.YYY.\".split_str_iter(\".\").collect()\n-     * assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n-     * ~~~\n-     */\n     fn split_str_iter(&self, &'self str) -> StrStrSplitIterator<'self>;\n-    /// An iterator over the lines of a string (subsequences separated\n-    /// by `\\n`).\n     fn line_iter(&self) -> StrCharSplitIterator<'self, char>;\n-    /// An iterator over the words of a string (subsequences separated\n-    /// by any sequence of whitespace).\n     fn word_iter(&self) -> WordIterator<'self>;\n     fn ends_with(&self, needle: &str) -> bool;\n     fn is_empty(&self) -> bool;\n@@ -1681,14 +1663,23 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn contains_char(&self, needle: char) -> bool {\n         self.find(needle).is_some()\n     }\n-\n+    /// An iterator over the characters of `self`. Note, this iterates\n+    /// over unicode code-points, not unicode graphemes.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let v: ~[char] = \"abc \u00e5\u00e4\u00f6\".iter().collect();\n+    /// assert_eq!(v, ~['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n+    /// ~~~\n     #[inline]\n     fn iter(&self) -> StrCharIterator<'self> {\n         StrCharIterator {\n             index: 0,\n             string: *self\n         }\n     }\n+    /// An iterator over the characters of `self`, in reverse order.\n     #[inline]\n     fn rev_iter(&self) -> StrCharRevIterator<'self> {\n         StrCharRevIterator {\n@@ -1697,20 +1688,47 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n+    /// An iterator over the bytes of `self`\n+    #[inline]\n     fn bytes_iter(&self) -> StrBytesIterator<'self> {\n         StrBytesIterator { it: as_bytes_slice(*self).iter() }\n     }\n+    /// An iterator over the bytes of `self`, in reverse order\n+    #[inline]\n     fn bytes_rev_iter(&self) -> StrBytesRevIterator<'self> {\n         StrBytesRevIterator { it: as_bytes_slice(*self).rev_iter() }\n     }\n \n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let v: ~[&str] = \"Mary had a little lamb\".split_iter(' ').collect();\n+    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    ///\n+    /// let v: ~[&str] = \"abc1def2ghi\".split_iter(|c: char| c.is_digit()).collect();\n+    /// assert_eq!(v, ~[\"abc\", \"def\", \"ghi\"]);\n+    /// ~~~\n+    #[inline]\n     fn split_iter<Sep: CharEq>(&self, sep: Sep) -> StrCharSplitIterator<'self, Sep> {\n         self.split_options_iter(sep, self.len(), true)\n     }\n \n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`, restricted to splitting at most `count`\n+    /// times.\n+    #[inline]\n     fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> StrCharSplitIterator<'self, Sep> {\n         self.split_options_iter(sep, count, true)\n     }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`, splitting at most `count` times, and\n+    /// possibly not including the trailing empty substring, if it\n+    /// exists.\n+    #[inline]\n     fn split_options_iter<Sep: CharEq>(&self, sep: Sep, count: uint, allow_trailing_empty: bool)\n         -> StrCharSplitIterator<'self, Sep> {\n         let only_ascii = sep.only_ascii();\n@@ -1724,6 +1742,9 @@ impl<'self> StrSlice<'self> for &'self str {\n             only_ascii: only_ascii\n         }\n     }\n+    /// An iterator over the start and end indices of each match of\n+    /// `sep` within `self`.\n+    #[inline]\n     fn matches_index_iter(&self, sep: &'self str) -> StrMatchesIndexIterator<'self> {\n         assert!(!sep.is_empty())\n         StrMatchesIndexIterator {\n@@ -1732,6 +1753,17 @@ impl<'self> StrSlice<'self> for &'self str {\n             position: 0\n         }\n     }\n+    /**\n+     * An iterator over the substrings of `self` separated by `sep`.\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n+     * let v: ~[&str] = \"abcXXXabcYYYabc\".split_str_iter(\"abc\").collect()\n+     * assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n+     * ~~~\n+     */\n+    #[inline]\n     fn split_str_iter(&self, sep: &'self str) -> StrStrSplitIterator<'self> {\n         StrStrSplitIterator {\n             it: self.matches_index_iter(sep),\n@@ -1740,9 +1772,15 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n+    /// An iterator over the lines of a string (subsequences separated\n+    /// by `\\n`).\n+    #[inline]\n     fn line_iter(&self) -> StrCharSplitIterator<'self, char> {\n         self.split_options_iter('\\n', self.len(), false)\n     }\n+    /// An iterator over the words of a string (subsequences separated\n+    /// by any sequence of whitespace).\n+    #[inline]\n     fn word_iter(&self) -> WordIterator<'self> {\n         self.split_iter(char::is_whitespace).filter(|s| !s.is_empty())\n     }\n@@ -1791,14 +1829,24 @@ impl<'self> StrSlice<'self> for &'self str {\n         assert!(self.is_char_boundary(end));\n         unsafe { raw::slice_bytes(*self, begin, end) }\n     }\n+    /// Returns a slice of the string from `begin` to its end.\n+    ///\n+    /// Fails when `begin` does not point to a valid character, or is\n+    /// out of bounds.\n     #[inline]\n     fn slice_from(&self, begin: uint) -> &'self str {\n         self.slice(begin, self.len())\n     }\n+    /// Returns a slice of the string from the beginning to byte\n+    /// `end`.\n+    ///\n+    /// Fails when `end` does not point to a valid character, or is\n+    /// out of bounds.\n     #[inline]\n     fn slice_to(&self, end: uint) -> &'self str {\n         self.slice(0, end)\n     }\n+    /// Checks if `needle` is a prefix of the string.\n     #[inline]\n     fn starts_with<'a>(&self, needle: &'a str) -> bool {\n         starts_with(*self, needle)"}]}