{"sha": "0e64a756f84041e7c33acb052db9df9c9576e6d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNjRhNzU2Zjg0MDQxZTdjMzNhY2IwNTJkYjlkZjljOTU3NmU2ZDQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-07T16:21:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:04:51Z"}, "message": "integrate -Znll-dump-cause into borrowck", "tree": {"sha": "3d6bd561cf157588aeea08a0a5a77047d6594b6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d6bd561cf157588aeea08a0a5a77047d6594b6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e64a756f84041e7c33acb052db9df9c9576e6d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e64a756f84041e7c33acb052db9df9c9576e6d4", "html_url": "https://github.com/rust-lang/rust/commit/0e64a756f84041e7c33acb052db9df9c9576e6d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e64a756f84041e7c33acb052db9df9c9576e6d4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "741ef41e41e61ae107145d03ffcb263ffec5ca1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/741ef41e41e61ae107145d03ffcb263ffec5ca1f", "html_url": "https://github.com/rust-lang/rust/commit/741ef41e41e61ae107145d03ffcb263ffec5ca1f"}], "stats": {"total": 182, "additions": 145, "deletions": 37}, "files": [{"sha": "971b5eb22752c4fef3a9877a9652af7fa3e69d69", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 108, "deletions": 28, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/0e64a756f84041e7c33acb052db9df9c9576e6d4/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e64a756f84041e7c33acb052db9df9c9576e6d4/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=0e64a756f84041e7c33acb052db9df9c9576e6d4", "patch": "@@ -14,6 +14,7 @@ use rustc::mir::{BorrowKind, Field, Local, Location, Operand};\n use rustc::mir::{Place, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::ty::{self, RegionKind};\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_errors::DiagnosticBuilder;\n \n use std::rc::Rc;\n \n@@ -88,7 +89,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     pub(super) fn report_move_out_while_borrowed(\n         &mut self,\n-        _context: Context,\n+        context: Context,\n         (place, span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n@@ -100,23 +101,23 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n         };\n-        self.tcx\n-            .cannot_move_when_borrowed(\n-                span,\n-                &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-                Origin::Mir,\n-            )\n-            .span_label(\n-                self.retrieve_borrow_span(borrow),\n-                format!(\"borrow of {} occurs here\", borrow_msg),\n-            )\n-            .span_label(span, format!(\"move out of {} occurs here\", value_msg))\n-            .emit();\n+        let mut err = self.tcx.cannot_move_when_borrowed(\n+            span,\n+            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+            Origin::Mir,\n+        );\n+        err.span_label(\n+            self.retrieve_borrow_span(borrow),\n+            format!(\"borrow of {} occurs here\", borrow_msg),\n+        );\n+        err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n+        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n+        err.emit();\n     }\n \n     pub(super) fn report_use_while_mutably_borrowed(\n         &mut self,\n-        _context: Context,\n+        context: Context,\n         (place, span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n@@ -128,9 +129,24 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Origin::Mir,\n         );\n \n+        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n+\n         err.emit();\n     }\n \n+    fn explain_why_borrow_contains_point(\n+        &self,\n+        context: Context,\n+        borrow: &BorrowData<'_>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n+        if let Some(regioncx) = &self.nonlexical_regioncx {\n+            if let Some(cause) = regioncx.why_region_contains_point(borrow.region, context.loc) {\n+                cause.label_diagnostic(self.mir, err);\n+            }\n+        }\n+    }\n+\n     /// Finds the span of arguments of a closure (within `maybe_closure_span`) and its usage of\n     /// the local assigned at `location`.\n     /// This is done by searching in statements succeeding `location`\n@@ -313,12 +329,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             );\n         }\n \n+        self.explain_why_borrow_contains_point(context, issued_borrow, &mut err);\n+\n         err.emit();\n     }\n \n     pub(super) fn report_borrowed_value_does_not_live_long_enough(\n         &mut self,\n-        _: Context,\n+        context: Context,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n         borrows: &ActiveBorrows<'cx, 'gcx, 'tcx>\n@@ -357,27 +375,57 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match (borrow.region, &self.describe_place(&borrow.borrowed_place)) {\n             (RegionKind::ReScope(_), Some(name)) => {\n                 self.report_scoped_local_value_does_not_live_long_enough(\n-                    name, &scope_tree, &borrow, drop_span, borrow_span, proper_span, end_span);\n+                    context,\n+                    name,\n+                    &scope_tree,\n+                    &borrow,\n+                    drop_span,\n+                    borrow_span,\n+                    proper_span,\n+                    end_span\n+                );\n             },\n             (RegionKind::ReScope(_), None) => {\n                 self.report_scoped_temporary_value_does_not_live_long_enough(\n-                    &scope_tree, &borrow, drop_span, borrow_span, proper_span, end_span);\n+                    context,\n+                    &scope_tree,\n+                    &borrow,\n+                    drop_span,\n+                    borrow_span,\n+                    proper_span,\n+                    end_span\n+                );\n             },\n             (RegionKind::ReEarlyBound(_), Some(name)) |\n             (RegionKind::ReFree(_), Some(name)) |\n             (RegionKind::ReStatic, Some(name)) |\n             (RegionKind::ReEmpty, Some(name)) |\n             (RegionKind::ReVar(_), Some(name)) => {\n                 self.report_unscoped_local_value_does_not_live_long_enough(\n-                    name, &scope_tree, &borrow, drop_span, borrow_span, proper_span, end_span);\n+                    context,\n+                    name,\n+                    &scope_tree,\n+                    &borrow,\n+                    drop_span,\n+                    borrow_span,\n+                    proper_span,\n+                    end_span,\n+                );\n             },\n             (RegionKind::ReEarlyBound(_), None) |\n             (RegionKind::ReFree(_), None) |\n             (RegionKind::ReStatic, None) |\n             (RegionKind::ReEmpty, None) |\n             (RegionKind::ReVar(_), None) => {\n                 self.report_unscoped_temporary_value_does_not_live_long_enough(\n-                    &scope_tree, &borrow, drop_span, borrow_span, proper_span, end_span);\n+                    context,\n+                    &scope_tree,\n+                    &borrow,\n+                    drop_span,\n+                    borrow_span,\n+                    proper_span,\n+                    end_span,\n+                );\n             },\n             (RegionKind::ReLateBound(_, _), _) |\n             (RegionKind::ReSkolemized(_, _), _) |\n@@ -389,8 +437,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     fn report_scoped_local_value_does_not_live_long_enough(\n-        &mut self, name: &String, _scope_tree: &Rc<ScopeTree>, _borrow: &BorrowData<'tcx>,\n-        drop_span: Span, borrow_span: Span, _proper_span: Span, end_span: Option<Span>\n+        &mut self,\n+        context: Context,\n+        name: &String,\n+        _scope_tree: &Rc<ScopeTree>,\n+        borrow: &BorrowData<'tcx>,\n+        drop_span: Span,\n+        borrow_span: Span,\n+        _proper_span: Span,\n+        end_span: Option<Span>,\n     ) {\n         let mut err = self.tcx.path_does_not_live_long_enough(borrow_span,\n                                                               &format!(\"`{}`\", name),\n@@ -400,12 +455,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let Some(end) = end_span {\n             err.span_label(end, \"borrowed value needs to live until here\");\n         }\n+        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n         err.emit();\n     }\n \n     fn report_scoped_temporary_value_does_not_live_long_enough(\n-        &mut self, _scope_tree: &Rc<ScopeTree>, _borrow: &BorrowData<'tcx>,\n-        drop_span: Span, _borrow_span: Span, proper_span: Span, end_span: Option<Span>\n+        &mut self,\n+        context: Context,\n+        _scope_tree: &Rc<ScopeTree>,\n+        borrow: &BorrowData<'tcx>,\n+        drop_span: Span,\n+        _borrow_span: Span,\n+        proper_span: Span,\n+        end_span: Option<Span>,\n     ) {\n         let mut err = self.tcx.path_does_not_live_long_enough(proper_span,\n                                                               \"borrowed value\",\n@@ -416,12 +478,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let Some(end) = end_span {\n             err.span_label(end, \"temporary value needs to live until here\");\n         }\n+        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n         err.emit();\n     }\n \n     fn report_unscoped_local_value_does_not_live_long_enough(\n-        &mut self, name: &String, scope_tree: &Rc<ScopeTree>, borrow: &BorrowData<'tcx>,\n-        drop_span: Span, borrow_span: Span, _proper_span: Span, _end_span: Option<Span>\n+        &mut self,\n+        context: Context,\n+        name: &String,\n+        scope_tree: &Rc<ScopeTree>,\n+        borrow: &BorrowData<'tcx>,\n+        drop_span: Span,\n+        borrow_span: Span,\n+        _proper_span: Span,\n+        _end_span: Option<Span>,\n     ) {\n         let mut err = self.tcx.path_does_not_live_long_enough(borrow_span,\n                                                               &format!(\"`{}`\", name),\n@@ -431,12 +501,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         self.tcx.note_and_explain_region(scope_tree, &mut err,\n                                          \"borrowed value must be valid for \",\n                                          borrow.region, \"...\");\n+        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n         err.emit();\n     }\n \n     fn report_unscoped_temporary_value_does_not_live_long_enough(\n-        &mut self, scope_tree: &Rc<ScopeTree>, borrow: &BorrowData<'tcx>,\n-        drop_span: Span, _borrow_span: Span, proper_span: Span, _end_span: Option<Span>\n+        &mut self,\n+        context: Context,\n+        scope_tree: &Rc<ScopeTree>,\n+        borrow: &BorrowData<'tcx>,\n+        drop_span: Span,\n+        _borrow_span: Span,\n+        proper_span: Span,\n+        _end_span: Option<Span>\n     ) {\n         let mut err = self.tcx.path_does_not_live_long_enough(proper_span,\n                                                               \"borrowed value\",\n@@ -446,12 +523,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         self.tcx.note_and_explain_region(scope_tree, &mut err,\n                                          \"borrowed value must be valid for \",\n                                          borrow.region, \"...\");\n+        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n         err.emit();\n     }\n \n     pub(super) fn report_illegal_mutation_of_borrowed(\n         &mut self,\n-        _: Context,\n+        context: Context,\n         (place, span): (&Place<'tcx>, Span),\n         loan: &BorrowData,\n     ) {\n@@ -462,6 +540,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Origin::Mir,\n         );\n \n+        self.explain_why_borrow_contains_point(context, loan, &mut err);\n+\n         err.emit();\n     }\n "}, {"sha": "46e97d95f493ff351b9d6133d6c8bccee540ebe3", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e64a756f84041e7c33acb052db9df9c9576e6d4/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e64a756f84041e7c33acb052db9df9c9576e6d4/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0e64a756f84041e7c33acb052db9df9c9576e6d4", "patch": "@@ -10,6 +10,7 @@\n \n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n+use borrow_check::nll::region_infer::RegionInferenceContext;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n@@ -224,6 +225,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         storage_dead_or_drop_error_reported_l: FxHashSet(),\n         storage_dead_or_drop_error_reported_s: FxHashSet(),\n         reservation_error_reported: FxHashSet(),\n+        nonlexical_regioncx: opt_regioncx.clone(),\n     };\n \n     let borrows = Borrows::new(tcx, mir, opt_regioncx, def_id, body_id);\n@@ -299,6 +301,10 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// but it is currently inconvenient to track down the BorrowIndex\n     /// at the time we detect and report a reservation error.\n     reservation_error_reported: FxHashSet<Place<'tcx>>,\n+    /// Non-lexical region inference context, if NLL is enabled.  This\n+    /// contains the results from region inference and lets us e.g.\n+    /// find out which CFG points are contained in each borrow region.\n+    nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n }\n \n // Check that:"}, {"sha": "33a6c9e2d1cbfd5331b3748185429857bcd2e5cc", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e64a756f84041e7c33acb052db9df9c9576e6d4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e64a756f84041e7c33acb052db9df9c9576e6d4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=0e64a756f84041e7c33acb052db9df9c9576e6d4", "patch": "@@ -285,19 +285,25 @@ fn for_each_region_constraint(\n /// This is reasonable because in our MIR we replace all universal regions\n /// with inference variables.\n pub trait ToRegionVid {\n-    fn to_region_vid(&self) -> RegionVid;\n+    fn to_region_vid(self) -> RegionVid;\n }\n \n-impl ToRegionVid for RegionKind {\n-    fn to_region_vid(&self) -> RegionVid {\n-        if let &ty::ReVar(vid) = self {\n-            vid\n+impl<'tcx> ToRegionVid for &'tcx RegionKind {\n+    fn to_region_vid(self) -> RegionVid {\n+        if let ty::ReVar(vid) = self {\n+            *vid\n         } else {\n             bug!(\"region is not an ReVar: {:?}\", self)\n         }\n     }\n }\n \n+impl ToRegionVid for RegionVid {\n+    fn to_region_vid(self) -> RegionVid {\n+        self\n+    }\n+}\n+\n fn live_variable_set(regular: &LocalSet, drops: &LocalSet) -> String {\n     // sort and deduplicate:\n     let all_locals: BTreeSet<_> = regular.iter().chain(drops.iter()).collect();"}, {"sha": "9f7219b1f55059a6228254f9d97699f03cc6f93d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0e64a756f84041e7c33acb052db9df9c9576e6d4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e64a756f84041e7c33acb052db9df9c9576e6d4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=0e64a756f84041e7c33acb052db9df9c9576e6d4", "patch": "@@ -35,6 +35,8 @@ mod graphviz;\n mod values;\n use self::values::{RegionValueElements, RegionValues};\n \n+use super::ToRegionVid;\n+\n pub struct RegionInferenceContext<'tcx> {\n     /// Contains the definition for every region variable.  Region\n     /// variables are identified by their index (`RegionVid`). The\n@@ -330,11 +332,25 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Returns true if the region `r` contains the point `p`.\n     ///\n     /// Panics if called before `solve()` executes,\n-    pub fn region_contains_point(&self, r: RegionVid, p: Location) -> bool {\n+    pub fn region_contains_point<R>(&self, r: R, p: Location) -> bool\n+    where\n+        R: ToRegionVid,\n+    {\n+        let inferred_values = self.inferred_values\n+            .as_ref()\n+            .expect(\"region values not yet inferred\");\n+        inferred_values.contains(r.to_region_vid(), p)\n+    }\n+\n+    /// Returns the *reason* that the region `r` contains the given point.\n+    pub(crate) fn why_region_contains_point<R>(&self, r: R, p: Location) -> Option<Rc<Cause>>\n+    where\n+        R: ToRegionVid,\n+    {\n         let inferred_values = self.inferred_values\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n-        inferred_values.contains(r, p)\n+        inferred_values.cause(r.to_region_vid(), p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes."}, {"sha": "7cd92de88ee5217f4f97153a98b2353bddbe4061", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e64a756f84041e7c33acb052db9df9c9576e6d4/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e64a756f84041e7c33acb052db9df9c9576e6d4/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=0e64a756f84041e7c33acb052db9df9c9576e6d4", "patch": "@@ -75,7 +75,7 @@ pub trait BorrowckErrors {\n                                 -> DiagnosticBuilder<'a>;\n \n     fn cannot_move_when_borrowed(&self, span: Span, desc: &str, o: Origin)\n-                                 -> DiagnosticBuilder\n+                                 -> DiagnosticBuilder<'_>\n     {\n         let err = struct_span_err!(self, span, E0505,\n                                    \"cannot move out of `{}` because it is borrowed{OGN}\",\n@@ -89,7 +89,7 @@ pub trait BorrowckErrors {\n                                         borrow_span: Span,\n                                         borrow_desc: &str,\n                                         o: Origin)\n-                                        -> DiagnosticBuilder\n+                                        -> DiagnosticBuilder<'_>\n     {\n         let mut err = struct_span_err!(self, span, E0503,\n                          \"cannot use `{}` because it was mutably borrowed{OGN}\","}]}