{"sha": "a07f213974cee627a621c82e303b00ddaa8359e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwN2YyMTM5NzRjZWU2MjdhNjIxYzgyZTMwM2IwMGRkYWE4MzU5ZTU=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-07-17T10:13:38Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-07-17T11:24:50Z"}, "message": "Rollup merge of #52338 - RalfJung:miri, r=oli-obk\n\nupdate miri", "tree": {"sha": "f5af8ce17c126464e91d6cc7c6f5c9ce4472a477", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5af8ce17c126464e91d6cc7c6f5c9ce4472a477"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a07f213974cee627a621c82e303b00ddaa8359e5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAltN0gQACgkQ/vbIBR0O\nATw0qBAAweXnEGQ8cobd0giX63nq+r/enHPWgxljMQT1UER1xrKrlH93TpsoTYnr\ncrgDE/voj+O6HPcTmtFvLe8MsQQeYwAAm1b0VenEKh1ck2vPg5AL5Xc4TKlcsAj2\ny7xsQaPXARU/QLLsYn9itow+w54066vGvjMmvOmkzBcPsVo+wccFM1qWRvt1dMlS\nJS98C6i3ADTw+YG+o6xmONKtSOMeT6wroDpEZDpDihNiiRdxyi+GWoWUuN5D1zDV\nsm3+moMbveeLsP5252qAwivOmCH4Zg8qnXWvYKxKw08JX5+SAnBWo5W8E3xT8Ldd\ngjDNGnM+Mth842M7lklqMKaJZRQklFwBqJo5Vav+2KOAIEO4okSh90eZ40HuTfRk\nccSlZJW+M25nebL4jsjKQcvAl+DLu7gFLaC2hqv7WZvGmkSdsF5IiF3tWcq6zNcs\nKPYtcxJU7woo8TPV2Ci4yWoaohCE1XVoef/YlaVhrSUJGuHDsT518NA+tPHpQ51O\nN1kmmPi/WqnRYnD4284ZDK8GJVa3Nj7sDVEYfo3XU/nKZvw2ppgfiyQnwsgEC5oZ\nxkUl19lYEYsvi9HnN0PUaw+Q1XTJSWnc5c80VIwJuu07BQ15bNLDESRNisrrqY4N\nKQejhzBkjmBUY8X+1UkkovRT2SVFPJke80Uy/BfMk4hDkZh27pw=\n=lxMy\n-----END PGP SIGNATURE-----", "payload": "tree f5af8ce17c126464e91d6cc7c6f5c9ce4472a477\nparent 6af3e2d707230cf4d0879dc81ceccc83e72fed25\nparent 9e10b12f332a027a6397e3aa6b58effc2d64bb38\nauthor kennytm <kennytm@gmail.com> 1531822418 +0800\ncommitter kennytm <kennytm@gmail.com> 1531826690 +0800\n\nRollup merge of #52338 - RalfJung:miri, r=oli-obk\n\nupdate miri\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a07f213974cee627a621c82e303b00ddaa8359e5", "html_url": "https://github.com/rust-lang/rust/commit/a07f213974cee627a621c82e303b00ddaa8359e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a07f213974cee627a621c82e303b00ddaa8359e5/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6af3e2d707230cf4d0879dc81ceccc83e72fed25", "url": "https://api.github.com/repos/rust-lang/rust/commits/6af3e2d707230cf4d0879dc81ceccc83e72fed25", "html_url": "https://github.com/rust-lang/rust/commit/6af3e2d707230cf4d0879dc81ceccc83e72fed25"}, {"sha": "9e10b12f332a027a6397e3aa6b58effc2d64bb38", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e10b12f332a027a6397e3aa6b58effc2d64bb38", "html_url": "https://github.com/rust-lang/rust/commit/9e10b12f332a027a6397e3aa6b58effc2d64bb38"}], "stats": {"total": 14405, "additions": 11902, "deletions": 2503}, "files": [{"sha": "ccc1ccce87aae03967494c2e873c4aebc54fad0e", "filename": "src/Cargo.lock", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -243,6 +243,18 @@ dependencies = [\n  \"serde_json 1.0.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"cargo_metadata\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.69 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.69 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"cargotest2\"\n version = \"0.1.0\"\n@@ -629,6 +641,14 @@ dependencies = [\n  \"backtrace 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"error-chain\"\n+version = \"0.12.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"backtrace 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"error_index_generator\"\n version = \"0.0.0\"\n@@ -1216,12 +1236,13 @@ name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n  \"byteorder 1.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cargo_metadata 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cargo_metadata 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"colored 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiletest_rs 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -3031,6 +3052,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f2f382711e76b9de6c744cc00d0497baba02fb00a787f088c879f01d09468e32\"\n \"checksum byteorder 1.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"74c0b906e9446b0a2e4f760cdb3fa4b2c48cdc6db8766a845c54b6ff063fd2e9\"\n \"checksum cargo_metadata 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1efca0b863ca03ed4c109fb1c55e0bc4bbeb221d3e103d86251046b06a526bd0\"\n+\"checksum cargo_metadata 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d6809b327f87369e6f3651efd2c5a96c49847a3ed2559477ecba79014751ee1\"\n \"checksum cc 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49ec142f5768efb5b7622aebc3fdbdbb8950a4b9ba996393cb76ef7466e8747d\"\n \"checksum cfg-if 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"efe5c877e17a9c717a0bf3613b2709f723202c4e4675cc8f12926ded29bcb17e\"\n \"checksum chalk-engine 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a146c19172c7eea48ea55a7123ac95da786639bc665097f1e14034ee5f1d8699\"\n@@ -3062,6 +3084,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum env_logger 0.5.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e6e40ebb0e66918a37b38c7acab4e10d299e0463fe2af5d29b9cc86710cfd2a\"\n \"checksum environment 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f4b14e20978669064c33b4c1e0fb4083412e40fe56cbea2eae80fd7591503ee\"\n \"checksum error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff511d5dc435d703f4971bc399647c9bc38e20cb41452e3b9feb4765419ed3f3\"\n+\"checksum error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07e791d3be96241c77c43846b665ef1384606da2cd2a48730abe606a12906e02\"\n \"checksum failure 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"934799b6c1de475a012a02dab0ace1ace43789ee4b99bcfbf1a2e3e8ced5de82\"\n \"checksum failure_derive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c7cdda555bb90c9bb67a3b670a0f42de8e73f5981524123ad8578aafec8ddb8b\"\n \"checksum filetime 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"da4b9849e77b13195302c174324b5ba73eec9b236b24c221a61000daefb95c5f\""}, {"sha": "1bd8c41629eea01712d001f940d2e797ee47138f", "filename": "src/doc/unstable-book/src/language-features/proc-macro.md", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/6af3e2d707230cf4d0879dc81ceccc83e72fed25/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md", "raw_url": "https://github.com/rust-lang/rust/raw/6af3e2d707230cf4d0879dc81ceccc83e72fed25/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md?ref=6af3e2d707230cf4d0879dc81ceccc83e72fed25", "patch": "@@ -1,241 +0,0 @@\n-# `proc_macro`\n-\n-The tracking issue for this feature is: [#38356]\n-\n-[#38356]: https://github.com/rust-lang/rust/issues/38356\n-\n-------------------------\n-\n-This feature flag guards the new procedural macro features as laid out by [RFC 1566], which alongside the now-stable \n-[custom derives], provide stabilizable alternatives to the compiler plugin API (which requires the use of \n-perma-unstable internal APIs) for programmatically modifying Rust code at compile-time.\n-\n-The two new procedural macro kinds are:\n- \n-* Function-like procedural macros which are invoked like regular declarative macros, and:\n-\n-* Attribute-like procedural macros which can be applied to any item which built-in attributes can\n-be applied to, and which can take arguments in their invocation as well.\n-\n-Additionally, this feature flag implicitly enables the [`use_extern_macros`](language-features/use-extern-macros.html) feature,\n-which allows macros to be imported like any other item with `use` statements, as compared to \n-applying `#[macro_use]` to an `extern crate` declaration. It is important to note that procedural macros may\n-**only** be imported in this manner, and will throw an error otherwise.\n-\n-You **must** declare the `proc_macro` feature in both the crate declaring these new procedural macro kinds as well as \n-in any crates that use them.\n-\n-### Common Concepts\n-\n-As with custom derives, procedural macros may only be declared in crates of the `proc-macro` type, and must be public\n-functions. No other public items may be declared in `proc-macro` crates, but private items are fine.\n-\n-To declare your crate as a `proc-macro` crate, simply add:\n-\n-```toml\n-[lib]\n-proc-macro = true\n-```\n-\n-to your `Cargo.toml`. \n-\n-Unlike custom derives, however, the name of the function implementing the procedural macro is used directly as the \n-procedural macro's name, so choose carefully.\n-\n-Additionally, both new kinds of procedural macros return a `TokenStream` which *wholly* replaces the original \n-invocation and its input.\n-\n-#### Importing\n-\n-As referenced above, the new procedural macros are not meant to be imported via `#[macro_use]` and will throw an \n-error if they are. Instead, they are meant to be imported like any other item in Rust, with `use` statements:\n-\n-```rust,ignore\n-#![feature(proc_macro)]\n-\n-// Where `my_proc_macros` is some crate of type `proc_macro`\n-extern crate my_proc_macros;\n-\n-// And declares a `#[proc_macro] pub fn my_bang_macro()` at its root.\n-use my_proc_macros::my_bang_macro;\n-\n-fn main() {\n-    println!(\"{}\", my_bang_macro!());\n-}\n-```\n-\n-#### Error Reporting\n-\n-Any panics in a procedural macro implementation will be caught by the compiler and turned into an error message pointing \n-to the problematic invocation. Thus, it is important to make your panic messages as informative as possible: use \n-`Option::expect` instead of `Option::unwrap` and `Result::expect` instead of `Result::unwrap`, and inform the user of \n-the error condition as unambiguously as you can.\n- \n-#### `TokenStream`\n-\n-The `proc_macro::TokenStream` type is hardcoded into the signatures of procedural macro functions for both input and \n-output. It is a wrapper around the compiler's internal representation for a given chunk of Rust code.\n-\n-### Function-like Procedural Macros\n-\n-These are procedural macros that are invoked like regular declarative macros. They are declared as public functions in \n-crates of the `proc_macro` type and using the `#[proc_macro]` attribute. The name of the declared function becomes the \n-name of the macro as it is to be imported and used. The function must be of the kind `fn(TokenStream) -> TokenStream` \n-where the sole argument is the input to the macro and the return type is the macro's output.\n-\n-This kind of macro can expand to anything that is valid for the context it is invoked in, including expressions and\n-statements, as well as items.\n-\n-**Note**: invocations of this kind of macro require a wrapping `[]`, `{}` or `()` like regular macros, but these do not \n-appear in the input, only the tokens between them. The tokens between the braces do not need to be valid Rust syntax.\n-\n-<span class=\"filename\">my_macro_crate/src/lib.rs</span>\n-\n-```rust,ignore\n-#![feature(proc_macro)]\n-\n-// This is always necessary to get the `TokenStream` typedef.\n-extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n-\n-#[proc_macro]\n-pub fn say_hello(_input: TokenStream) -> TokenStream {\n-    // This macro will accept any input because it ignores it. \n-    // To enforce correctness in macros which don't take input,\n-    // you may want to add `assert!(_input.to_string().is_empty());`.\n-    \"println!(\\\"Hello, world!\\\")\".parse().unwrap()\n-}\n-```\n-\n-<span class=\"filename\">my_macro_user/Cargo.toml</span>\n-\n-```toml\n-[dependencies]\n-my_macro_crate = { path = \"<relative path to my_macro_crate>\" }\n-```\n-\n-<span class=\"filename\">my_macro_user/src/lib.rs</span>\n-\n-```rust,ignore\n-#![feature(proc_macro)]\n-\n-extern crate my_macro_crate;\n-\n-use my_macro_crate::say_hello;\n-\n-fn main() {\n-    say_hello!();\n-}\n-```\n-\n-As expected, this prints `Hello, world!`.\n-\n-### Attribute-like Procedural Macros\n-\n-These are arguably the most powerful flavor of procedural macro as they can be applied anywhere attributes are allowed. \n-\n-They are declared as public functions in crates of the `proc-macro` type, using the `#[proc_macro_attribute]` attribute. \n-The name of the function becomes the name of the attribute as it is to be imported and used. The function must be of the \n-kind `fn(TokenStream, TokenStream) -> TokenStream` where:\n-\n-The first argument represents any metadata for the attribute (see [the reference chapter on attributes][refr-attr]). \n-Only the metadata itself will appear in this argument, for example:\n- \n- * `#[my_macro]` will get an empty string.\n- * `#[my_macro = \"string\"]` will get `= \"string\"`.\n- * `#[my_macro(ident)]` will get `(ident)`.\n- * etc.\n- \n-The second argument is the item that the attribute is applied to. It can be a function, a type definition, \n-an impl block, an `extern` block, or a module\u2014attribute invocations can take the inner form (`#![my_attr]`) \n-or outer form (`#[my_attr]`).\n-\n-The return type is the output of the macro which *wholly* replaces the item it was applied to. Thus, if your intention\n-is to merely modify an item, it *must* be copied to the output. The output must be an item; expressions, statements\n-and bare blocks are not allowed.\n-\n-There is no restriction on how many items an attribute-like procedural macro can emit as long as they are valid in \n-the given context.\n-\n-<span class=\"filename\">my_macro_crate/src/lib.rs</span>\n-\n-```rust,ignore\n-#![feature(proc_macro)]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n-\n-/// Adds a `/// ### Panics` docstring to the end of the input's documentation\n-///\n-/// Does not assert that its receiver is a function or method.\n-#[proc_macro_attribute]\n-pub fn panics_note(args: TokenStream, input: TokenStream) -> TokenStream {\n-    let args = args.to_string();\n-    let mut input = input.to_string();\n-\n-    assert!(args.starts_with(\"= \\\"\"), \"`#[panics_note]` requires an argument of the form \\\n-                                       `#[panics_note = \\\"panic note here\\\"]`\");\n-\n-    // Get just the bare note string\n-    let panics_note = args.trim_matches(&['=', ' ', '\"'][..]);\n-\n-    // The input will include all docstrings regardless of where the attribute is placed,\n-    // so we need to find the last index before the start of the item\n-    let insert_idx = idx_after_last_docstring(&input);\n-\n-    // And insert our `### Panics` note there so it always appears at the end of an item's docs\n-    input.insert_str(insert_idx, &format!(\"/// # Panics \\n/// {}\\n\", panics_note));\n-\n-    input.parse().unwrap()\n-}\n-\n-// `proc-macro` crates can contain any kind of private item still\n-fn idx_after_last_docstring(input: &str) -> usize {\n-    // Skip docstring lines to find the start of the item proper\n-    input.lines().skip_while(|line| line.trim_left().starts_with(\"///\")).next()\n-        // Find the index of the first non-docstring line in the input\n-        // Note: assumes this exact line is unique in the input\n-        .and_then(|line_after| input.find(line_after))\n-        // No docstrings in the input\n-        .unwrap_or(0)\n-}\n-```\n-\n-<span class=\"filename\">my_macro_user/Cargo.toml</span>\n-\n-```toml\n-[dependencies]\n-my_macro_crate = { path = \"<relative path to my_macro_crate>\" }\n-```\n-\n-<span class=\"filename\">my_macro_user/src/lib.rs</span>\n-\n-```rust,ignore\n-#![feature(proc_macro)]\n-\n-extern crate my_macro_crate;\n-\n-use my_macro_crate::panics_note;\n-\n-/// Do the `foo` thing.\n-#[panics_note = \"Always.\"]\n-pub fn foo() {\n-    panic!()\n-}\n-```\n-\n-Then the rendered documentation for `pub fn foo` will look like this:\n-\n-> `pub fn foo()`\n-> \n-> ----\n-> Do the `foo` thing.\n-> # Panics\n-> Always.\n-\n-[RFC 1566]: https://github.com/rust-lang/rfcs/blob/master/text/1566-proc-macros.md\n-[custom derives]: https://doc.rust-lang.org/book/procedural-macros.html\n-[rust-lang/rust#41430]: https://github.com/rust-lang/rust/issues/41430\n-[refr-attr]: https://doc.rust-lang.org/reference/attributes.html"}, {"sha": "06939a9d1e1cbbcecfa7ed70b2ab340e09fa2599", "filename": "src/libproc_macro/diagnostic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fdiagnostic.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -13,7 +13,7 @@ use Span;\n use rustc_errors as rustc;\n \n /// An enum representing a diagnostic level.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_diagnostic\", issue = \"38356\")]\n #[derive(Copy, Clone, Debug)]\n pub enum Level {\n     /// An error.\n@@ -30,7 +30,7 @@ pub enum Level {\n \n /// A structure representing a diagnostic message and associated children\n /// messages.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_diagnostic\", issue = \"38356\")]\n #[derive(Clone, Debug)]\n pub struct Diagnostic {\n     level: Level,\n@@ -43,15 +43,15 @@ macro_rules! diagnostic_child_methods {\n     ($spanned:ident, $regular:ident, $level:expr) => (\n         /// Add a new child diagnostic message to `self` with the level\n         /// identified by this methods name with the given `span` and `message`.\n-        #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+        #[unstable(feature = \"proc_macro_diagnostic\", issue = \"38356\")]\n         pub fn $spanned<T: Into<String>>(mut self, span: Span, message: T) -> Diagnostic {\n             self.children.push(Diagnostic::spanned(span, $level, message));\n             self\n         }\n \n         /// Add a new child diagnostic message to `self` with the level\n         /// identified by this method's name with the given `message`.\n-        #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+        #[unstable(feature = \"proc_macro_diagnostic\", issue = \"38356\")]\n         pub fn $regular<T: Into<String>>(mut self, message: T) -> Diagnostic {\n             self.children.push(Diagnostic::new($level, message));\n             self\n@@ -61,7 +61,7 @@ macro_rules! diagnostic_child_methods {\n \n impl Diagnostic {\n     /// Create a new diagnostic with the given `level` and `message`.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_diagnostic\", issue = \"38356\")]\n     pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n         Diagnostic {\n             level: level,\n@@ -73,7 +73,7 @@ impl Diagnostic {\n \n     /// Create a new diagnostic with the given `level` and `message` pointing to\n     /// the given `span`.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_diagnostic\", issue = \"38356\")]\n     pub fn spanned<T: Into<String>>(span: Span, level: Level, message: T) -> Diagnostic {\n         Diagnostic {\n             level: level,\n@@ -89,13 +89,13 @@ impl Diagnostic {\n     diagnostic_child_methods!(span_help, help, Level::Help);\n \n     /// Returns the diagnostic `level` for `self`.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_diagnostic\", issue = \"38356\")]\n     pub fn level(&self) -> Level {\n         self.level\n     }\n \n     /// Emit the diagnostic.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_diagnostic\", issue = \"38356\")]\n     pub fn emit(self) {\n         ::__internal::with_sess(move |sess, _| {\n             let handler = &sess.span_diagnostic;"}, {"sha": "f5a7c88a1b71a274a857e8f4545284dd02baa22f", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 122, "deletions": 100, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -46,7 +46,7 @@ extern crate rustc_data_structures;\n \n mod diagnostic;\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_diagnostic\", issue = \"38356\")]\n pub use diagnostic::{Diagnostic, Level};\n \n use std::{ascii, fmt, iter};\n@@ -94,13 +94,13 @@ impl !Sync for LexError {}\n \n impl TokenStream {\n     /// Returns an empty `TokenStream` containing no token trees.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new() -> TokenStream {\n         TokenStream(tokenstream::TokenStream::empty())\n     }\n \n     /// Checks if this `TokenStream` is empty.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn is_empty(&self) -> bool {\n         self.0.is_empty()\n     }\n@@ -146,15 +146,15 @@ impl fmt::Debug for TokenStream {\n }\n \n /// Creates a token stream containing a single token tree.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n         TokenStream(tree.to_internal())\n     }\n }\n \n /// Collects a number of token trees into a single stream.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl iter::FromIterator<TokenTree> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n         trees.into_iter().map(TokenStream::from).collect()\n@@ -175,7 +175,7 @@ impl iter::FromIterator<TokenStream> for TokenStream {\n }\n \n /// Public implementation details for the `TokenStream` type, such as iterators.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub mod token_stream {\n     use syntax::tokenstream;\n     use {TokenTree, TokenStream, Delimiter};\n@@ -184,13 +184,13 @@ pub mod token_stream {\n     /// The iteration is \"shallow\", e.g. the iterator doesn't recurse into delimited groups,\n     /// and returns whole groups as token trees.\n     #[derive(Clone)]\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub struct IntoIter {\n         cursor: tokenstream::Cursor,\n         stack: Vec<TokenTree>,\n     }\n \n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     impl Iterator for IntoIter {\n         type Item = TokenTree;\n \n@@ -219,7 +219,7 @@ pub mod token_stream {\n         }\n     }\n \n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     impl IntoIterator for TokenStream {\n         type Item = TokenTree;\n         type IntoIter = IntoIter;\n@@ -238,7 +238,7 @@ pub mod token_stream {\n /// To quote `$` itself, use `$$`.\n ///\n /// This is a dummy macro, the actual implementation is in quote::Quoter\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_quote\", issue = \"38356\")]\n #[macro_export]\n macro_rules! quote { () => {} }\n \n@@ -248,26 +248,26 @@ mod quote;\n \n /// Quote a `Span` into a `TokenStream`.\n /// This is needed to implement a custom quoter.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_quote\", issue = \"38356\")]\n pub fn quote_span(span: Span) -> TokenStream {\n     quote::Quote::quote(span)\n }\n \n /// A region of source code, along with macro expansion information.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n #[derive(Copy, Clone)]\n pub struct Span(syntax_pos::Span);\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Send for Span {}\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Sync for Span {}\n \n macro_rules! diagnostic_method {\n     ($name:ident, $level:expr) => (\n         /// Create a new `Diagnostic` with the given `message` at the span\n         /// `self`.\n-        #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+        #[unstable(feature = \"proc_macro_diagnostic\", issue = \"38356\")]\n         pub fn $name<T: Into<String>>(self, message: T) -> Diagnostic {\n             Diagnostic::spanned(self, $level, message)\n         }\n@@ -276,7 +276,7 @@ macro_rules! diagnostic_method {\n \n impl Span {\n     /// A span that resolves at the macro definition site.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn def_site() -> Span {\n         ::__internal::with_sess(|_, data| data.def_site)\n     }\n@@ -285,13 +285,13 @@ impl Span {\n     /// Identifiers created with this span will be resolved as if they were written\n     /// directly at the macro call location (call-site hygiene) and other code\n     /// at the macro call site will be able to refer to them as well.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn call_site() -> Span {\n         ::__internal::with_sess(|_, data| data.call_site)\n     }\n \n     /// The original source file into which this span points.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn source_file(&self) -> SourceFile {\n         SourceFile {\n             filemap: __internal::lookup_char_pos(self.0.lo()).file,\n@@ -300,21 +300,21 @@ impl Span {\n \n     /// The `Span` for the tokens in the previous macro expansion from which\n     /// `self` was generated from, if any.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn parent(&self) -> Option<Span> {\n         self.0.parent().map(Span)\n     }\n \n     /// The span for the origin source code that `self` was generated from. If\n     /// this `Span` wasn't generated from other macro expansions then the return\n     /// value is the same as `*self`.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn source(&self) -> Span {\n         Span(self.0.source_callsite())\n     }\n \n     /// Get the starting line/column in the source file for this span.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn start(&self) -> LineColumn {\n         let loc = __internal::lookup_char_pos(self.0.lo());\n         LineColumn {\n@@ -324,7 +324,7 @@ impl Span {\n     }\n \n     /// Get the ending line/column in the source file for this span.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn end(&self) -> LineColumn {\n         let loc = __internal::lookup_char_pos(self.0.hi());\n         LineColumn {\n@@ -336,7 +336,7 @@ impl Span {\n     /// Create a new span encompassing `self` and `other`.\n     ///\n     /// Returns `None` if `self` and `other` are from different files.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn join(&self, other: Span) -> Option<Span> {\n         let self_loc = __internal::lookup_char_pos(self.0.lo());\n         let other_loc = __internal::lookup_char_pos(other.0.lo());\n@@ -348,20 +348,20 @@ impl Span {\n \n     /// Creates a new span with the same line/column information as `self` but\n     /// that resolves symbols as though it were at `other`.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn resolved_at(&self, other: Span) -> Span {\n         Span(self.0.with_ctxt(other.0.ctxt()))\n     }\n \n     /// Creates a new span with the same name resolution behavior as `self` but\n     /// with the line/column information of `other`.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn located_at(&self, other: Span) -> Span {\n         other.resolved_at(*self)\n     }\n \n     /// Compares to spans to see if they're equal.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn eq(&self, other: &Span) -> bool {\n         self.0 == other.0\n     }\n@@ -373,7 +373,7 @@ impl Span {\n }\n \n /// Prints a span in a form convenient for debugging.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Span {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{:?} bytes({}..{})\",\n@@ -384,33 +384,33 @@ impl fmt::Debug for Span {\n }\n \n /// A line-column pair representing the start or end of a `Span`.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct LineColumn {\n     /// The 1-indexed line in the source file on which the span starts or ends (inclusive).\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub line: usize,\n     /// The 0-indexed column (in UTF-8 characters) in the source file on which\n     /// the span starts or ends (inclusive).\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub column: usize\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n impl !Send for LineColumn {}\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n impl !Sync for LineColumn {}\n \n /// The source file of a given `Span`.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n #[derive(Clone)]\n pub struct SourceFile {\n     filemap: Lrc<FileMap>,\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n impl !Send for SourceFile {}\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n impl !Sync for SourceFile {}\n \n impl SourceFile {\n@@ -424,14 +424,14 @@ impl SourceFile {\n     /// the command line, the path as given may not actually be valid.\n     ///\n     /// [`is_real`]: #method.is_real\n-    # [unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn path(&self) -> &FileName {\n         &self.filemap.name\n     }\n \n     /// Returns `true` if this source file is a real source file, and not generated by an external\n     /// macro's expansion.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn is_real(&self) -> bool {\n         // This is a hack until intercrate spans are implemented and we can have real source files\n         // for spans generated in external macros.\n@@ -440,14 +440,14 @@ impl SourceFile {\n     }\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n impl AsRef<FileName> for SourceFile {\n     fn as_ref(&self) -> &FileName {\n         self.path()\n     }\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n impl fmt::Debug for SourceFile {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"SourceFile\")\n@@ -457,46 +457,62 @@ impl fmt::Debug for SourceFile {\n     }\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n impl PartialEq for SourceFile {\n     fn eq(&self, other: &Self) -> bool {\n         Lrc::ptr_eq(&self.filemap, &other.filemap)\n     }\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n impl Eq for SourceFile {}\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n impl PartialEq<FileName> for SourceFile {\n     fn eq(&self, other: &FileName) -> bool {\n         self.as_ref() == other\n     }\n }\n \n /// A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`).\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n #[derive(Clone)]\n pub enum TokenTree {\n     /// A token stream surrounded by bracket delimiters.\n-    Group(Group),\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n+    Group(\n+        #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n+        Group\n+    ),\n     /// An identifier.\n-    Ident(Ident),\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n+    Ident(\n+        #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n+        Ident\n+    ),\n     /// A single punctuation character (`+`, `,`, `$`, etc.).\n-    Punct(Punct),\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n+    Punct(\n+        #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n+        Punct\n+    ),\n     /// A literal character (`'a'`), string (`\"hello\"`), number (`2.3`), etc.\n-    Literal(Literal),\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n+    Literal(\n+        #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n+        Literal\n+    ),\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Send for TokenTree {}\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Sync for TokenTree {}\n \n impl TokenTree {\n     /// Returns the span of this tree, delegating to the `span` method of\n     /// the contained token or a delimited stream.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n         match *self {\n             TokenTree::Group(ref t) => t.span(),\n@@ -511,7 +527,7 @@ impl TokenTree {\n     /// Note that if this token is a `Group` then this method will not configure\n     /// the span of each of the internal tokens, this will simply delegate to\n     /// the `set_span` method of each variant.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n         match *self {\n             TokenTree::Group(ref mut t) => t.set_span(span),\n@@ -523,7 +539,7 @@ impl TokenTree {\n }\n \n /// Prints token treee in a form convenient for debugging.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for TokenTree {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Each of these has the name in the struct type in the derived debug,\n@@ -537,28 +553,28 @@ impl fmt::Debug for TokenTree {\n     }\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl From<Group> for TokenTree {\n     fn from(g: Group) -> TokenTree {\n         TokenTree::Group(g)\n     }\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl From<Ident> for TokenTree {\n     fn from(g: Ident) -> TokenTree {\n         TokenTree::Ident(g)\n     }\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl From<Punct> for TokenTree {\n     fn from(g: Punct) -> TokenTree {\n         TokenTree::Punct(g)\n     }\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl From<Literal> for TokenTree {\n     fn from(g: Literal) -> TokenTree {\n         TokenTree::Literal(g)\n@@ -568,7 +584,7 @@ impl From<Literal> for TokenTree {\n /// Prints the token tree as a string that is supposed to be losslessly convertible back\n /// into the same token tree (modulo spans), except for possibly `TokenTree::Group`s\n /// with `Delimiter::None` delimiters and negative numeric literals.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for TokenTree {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -584,33 +600,37 @@ impl fmt::Display for TokenTree {\n ///\n /// A `Group` internally contains a `TokenStream` which is surrounded by `Delimiter`s.\n #[derive(Clone, Debug)]\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub struct Group {\n     delimiter: Delimiter,\n     stream: TokenStream,\n     span: Span,\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Send for Group {}\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Sync for Group {}\n \n /// Describes how a sequence of token trees is delimited.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub enum Delimiter {\n     /// `( ... )`\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     Parenthesis,\n     /// `{ ... }`\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     Brace,\n     /// `[ ... ]`\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     Bracket,\n     /// `\u00d8 ... \u00d8`\n     /// An implicit delimiter, that may, for example, appear around tokens coming from a\n     /// \"macro variable\" `$var`. It is important to preserve operator priorities in cases like\n     /// `$var * 3` where `$var` is `1 + 2`.\n     /// Implicit delimiters may not survive roundtrip of a token stream through a string.\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     None,\n }\n \n@@ -620,7 +640,7 @@ impl Group {\n     /// This constructor will set the span for this group to\n     /// `Span::call_site()`. To change the span you can use the `set_span`\n     /// method below.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group {\n         Group {\n             delimiter: delimiter,\n@@ -630,7 +650,7 @@ impl Group {\n     }\n \n     /// Returns the delimiter of this `Group`\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn delimiter(&self) -> Delimiter {\n         self.delimiter\n     }\n@@ -639,14 +659,14 @@ impl Group {\n     ///\n     /// Note that the returned token stream does not include the delimiter\n     /// returned above.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn stream(&self) -> TokenStream {\n         self.stream.clone()\n     }\n \n     /// Returns the span for the delimiters of this token stream, spanning the\n     /// entire `Group`.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n         self.span\n     }\n@@ -657,7 +677,7 @@ impl Group {\n     /// This method will **not** set the span of all the internal tokens spanned\n     /// by this group, but rather it will only set the span of the delimiter\n     /// tokens at the level of the `Group`.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n         self.span = span;\n     }\n@@ -666,7 +686,7 @@ impl Group {\n /// Prints the group as a string that should be losslessly convertible back\n /// into the same group (modulo spans), except for possibly `TokenTree::Group`s\n /// with `Delimiter::None` delimiters.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Group {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n@@ -677,28 +697,30 @@ impl fmt::Display for Group {\n ///\n /// Multicharacter operators like `+=` are represented as two instances of `Punct` with different\n /// forms of `Spacing` returned.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n #[derive(Clone, Debug)]\n pub struct Punct {\n     ch: char,\n     spacing: Spacing,\n     span: Span,\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Send for Punct {}\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Sync for Punct {}\n \n /// Whether an `Punct` is followed immediately by another `Punct` or\n /// followed by another token or whitespace.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub enum Spacing {\n     /// E.g. `+` is `Alone` in `+ =`, `+ident` or `+()`.\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     Alone,\n     /// E.g. `+` is `Joint` in `+=` or `'#`.\n     /// Additionally, single quote `'` can join with identifiers to form lifetimes `'ident`.\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     Joint,\n }\n \n@@ -709,7 +731,7 @@ impl Punct {\n     ///\n     /// The returned `Punct` will have the default span of `Span::call_site()`\n     /// which can be further configured with the `set_span` method below.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(ch: char, spacing: Spacing) -> Punct {\n         const LEGAL_CHARS: &[char] = &['=', '<', '>', '!', '~', '+', '-', '*', '/', '%', '^',\n                                        '&', '|', '@', '.', ',', ';', ':', '#', '$', '?', '\\''];\n@@ -724,7 +746,7 @@ impl Punct {\n     }\n \n     /// Returns the value of this punctuation character as `char`.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn as_char(&self) -> char {\n         self.ch\n     }\n@@ -733,27 +755,27 @@ impl Punct {\n     /// followed by another `Punct` in the token stream, so they can potentially be combined into\n     /// a multicharacter operator (`Joint`), or it's followed by some other token or whitespace\n     /// (`Alone`) so the operator has certainly ended.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn spacing(&self) -> Spacing {\n         self.spacing\n     }\n \n     /// Returns the span for this punctuation character.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n         self.span\n     }\n \n     /// Configure the span for this punctuation character.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n         self.span = span;\n     }\n }\n \n /// Prints the punctuation character as a string that should be losslessly convertible\n /// back into the same character.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Punct {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n@@ -762,16 +784,16 @@ impl fmt::Display for Punct {\n \n /// An identifier (`ident`).\n #[derive(Clone, Debug)]\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub struct Ident {\n     sym: Symbol,\n     span: Span,\n     is_raw: bool,\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Send for Ident {}\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Sync for Ident {}\n \n impl Ident {\n@@ -794,7 +816,7 @@ impl Ident {\n     ///\n     /// Due to the current importance of hygiene this constructor, unlike other\n     /// tokens, requires a `Span` to be specified at construction.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(string: &str, span: Span) -> Ident {\n         if !lexer::is_valid_ident(string) {\n             panic!(\"`{:?}` is not a valid identifier\", string)\n@@ -807,7 +829,7 @@ impl Ident {\n     }\n \n     /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro_raw_ident\", issue = \"38356\")]\n     pub fn new_raw(string: &str, span: Span) -> Ident {\n         let mut ident = Ident::new(string, span);\n         if ident.sym == keywords::Underscore.name() ||\n@@ -820,21 +842,21 @@ impl Ident {\n \n     /// Returns the span of this `Ident`, encompassing the entire string returned\n     /// by `as_str`.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n         self.span\n     }\n \n     /// Configures the span of this `Ident`, possibly changing its hygiene context.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n         self.span = span;\n     }\n }\n \n /// Prints the identifier as a string that should be losslessly convertible\n /// back into the same identifier.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.is_raw {\n@@ -849,16 +871,16 @@ impl fmt::Display for Ident {\n /// with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`).\n /// Boolean literals like `true` and `false` do not belong here, they are `Ident`s.\n #[derive(Clone, Debug)]\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub struct Literal {\n     lit: token::Lit,\n     suffix: Option<ast::Name>,\n     span: Span,\n }\n \n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Send for Literal {}\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Sync for Literal {}\n \n macro_rules! suffixed_int_literals {\n@@ -874,7 +896,7 @@ macro_rules! suffixed_int_literals {\n         /// Literals created through this method have the `Span::call_site()`\n         /// span by default, which can be configured with the `set_span` method\n         /// below.\n-        #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+        #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n         pub fn $name(n: $kind) -> Literal {\n             Literal {\n                 lit: token::Lit::Integer(Symbol::intern(&n.to_string())),\n@@ -900,7 +922,7 @@ macro_rules! unsuffixed_int_literals {\n         /// Literals created through this method have the `Span::call_site()`\n         /// span by default, which can be configured with the `set_span` method\n         /// below.\n-        #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+        #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n         pub fn $name(n: $kind) -> Literal {\n             Literal {\n                 lit: token::Lit::Integer(Symbol::intern(&n.to_string())),\n@@ -954,7 +976,7 @@ impl Literal {\n     ///\n     /// This function requires that the specified float is finite, for\n     /// example if it is infinity or NaN this function will panic.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn f32_unsuffixed(n: f32) -> Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {}\", n);\n@@ -979,7 +1001,7 @@ impl Literal {\n     ///\n     /// This function requires that the specified float is finite, for\n     /// example if it is infinity or NaN this function will panic.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn f32_suffixed(n: f32) -> Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {}\", n);\n@@ -1003,7 +1025,7 @@ impl Literal {\n     ///\n     /// This function requires that the specified float is finite, for\n     /// example if it is infinity or NaN this function will panic.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn f64_unsuffixed(n: f64) -> Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {}\", n);\n@@ -1028,7 +1050,7 @@ impl Literal {\n     ///\n     /// This function requires that the specified float is finite, for\n     /// example if it is infinity or NaN this function will panic.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn f64_suffixed(n: f64) -> Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {}\", n);\n@@ -1041,7 +1063,7 @@ impl Literal {\n     }\n \n     /// String literal.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn string(string: &str) -> Literal {\n         let mut escaped = String::new();\n         for ch in string.chars() {\n@@ -1055,7 +1077,7 @@ impl Literal {\n     }\n \n     /// Character literal.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn character(ch: char) -> Literal {\n         let mut escaped = String::new();\n         escaped.extend(ch.escape_unicode());\n@@ -1067,7 +1089,7 @@ impl Literal {\n     }\n \n     /// Byte string literal.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn byte_string(bytes: &[u8]) -> Literal {\n         let string = bytes.iter().cloned().flat_map(ascii::escape_default)\n             .map(Into::<char>::into).collect::<String>();\n@@ -1079,21 +1101,21 @@ impl Literal {\n     }\n \n     /// Returns the span encompassing this literal.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n         self.span\n     }\n \n     /// Configures the span associated for this literal.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n         self.span = span;\n     }\n }\n \n /// Prints the literal as a string that should be losslessly convertible\n /// back into the same literal (except for possible rounding for floating point literals).\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Literal {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         TokenStream::from(TokenTree::from(self.clone())).fmt(f)"}, {"sha": "f1e27946915568a32451a1c5498cefc184a5ac57", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -111,13 +111,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n         let hir_id = self.tcx.hir.node_to_hir_id(stmt.node.id());\n         match stmt.node {\n-            hir::StmtDecl(ref decl, _) => {\n+            hir::StmtKind::Decl(ref decl, _) => {\n                 let exit = self.decl(&decl, pred);\n                 self.add_ast_node(hir_id.local_id, &[exit])\n             }\n \n-            hir::StmtExpr(ref expr, _) |\n-            hir::StmtSemi(ref expr, _) => {\n+            hir::StmtKind::Expr(ref expr, _) |\n+            hir::StmtKind::Semi(ref expr, _) => {\n                 let exit = self.expr(&expr, pred);\n                 self.add_ast_node(hir_id.local_id, &[exit])\n             }\n@@ -126,12 +126,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn decl(&mut self, decl: &hir::Decl, pred: CFGIndex) -> CFGIndex {\n         match decl.node {\n-            hir::DeclLocal(ref local) => {\n+            hir::DeclKind::Local(ref local) => {\n                 let init_exit = self.opt_expr(&local.init, pred);\n                 self.pat(&local.pat, init_exit)\n             }\n \n-            hir::DeclItem(_) => pred,\n+            hir::DeclKind::Item(_) => pred,\n         }\n     }\n \n@@ -179,12 +179,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn expr(&mut self, expr: &hir::Expr, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n-            hir::ExprBlock(ref blk, _) => {\n+            hir::ExprKind::Block(ref blk, _) => {\n                 let blk_exit = self.block(&blk, pred);\n                 self.add_ast_node(expr.hir_id.local_id, &[blk_exit])\n             }\n \n-            hir::ExprIf(ref cond, ref then, None) => {\n+            hir::ExprKind::If(ref cond, ref then, None) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -204,7 +204,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(expr.hir_id.local_id, &[cond_exit, then_exit])      // 3,4\n             }\n \n-            hir::ExprIf(ref cond, ref then, Some(ref otherwise)) => {\n+            hir::ExprKind::If(ref cond, ref then, Some(ref otherwise)) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -225,7 +225,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(expr.hir_id.local_id, &[then_exit, else_exit])      // 4, 5\n             }\n \n-            hir::ExprWhile(ref cond, ref body, _) => {\n+            hir::ExprKind::While(ref cond, ref body, _) => {\n                 //\n                 //         [pred]\n                 //           |\n@@ -267,7 +267,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 expr_exit\n             }\n \n-            hir::ExprLoop(ref body, _, _) => {\n+            hir::ExprKind::Loop(ref body, _, _) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -295,11 +295,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 expr_exit\n             }\n \n-            hir::ExprMatch(ref discr, ref arms, _) => {\n+            hir::ExprKind::Match(ref discr, ref arms, _) => {\n                 self.match_(expr.hir_id.local_id, &discr, &arms, pred)\n             }\n \n-            hir::ExprBinary(op, ref l, ref r) if op.node.is_lazy() => {\n+            hir::ExprKind::Binary(op, ref l, ref r) if op.node.is_lazy() => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -319,14 +319,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(expr.hir_id.local_id, &[l_exit, r_exit])            // 3,4\n             }\n \n-            hir::ExprRet(ref v) => {\n+            hir::ExprKind::Ret(ref v) => {\n                 let v_exit = self.opt_expr(v, pred);\n                 let b = self.add_ast_node(expr.hir_id.local_id, &[v_exit]);\n                 self.add_returning_edge(expr, b);\n                 self.add_unreachable_node()\n             }\n \n-            hir::ExprBreak(destination, ref opt_expr) => {\n+            hir::ExprKind::Break(destination, ref opt_expr) => {\n                 let v = self.opt_expr(opt_expr, pred);\n                 let (target_scope, break_dest) =\n                     self.find_scope_edge(expr, destination, ScopeCfKind::Break);\n@@ -335,74 +335,74 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_unreachable_node()\n             }\n \n-            hir::ExprContinue(destination) => {\n+            hir::ExprKind::Continue(destination) => {\n                 let (target_scope, cont_dest) =\n                     self.find_scope_edge(expr, destination, ScopeCfKind::Continue);\n                 let a = self.add_ast_node(expr.hir_id.local_id, &[pred]);\n                 self.add_exiting_edge(expr, a, target_scope, cont_dest);\n                 self.add_unreachable_node()\n             }\n \n-            hir::ExprArray(ref elems) => {\n+            hir::ExprKind::Array(ref elems) => {\n                 self.straightline(expr, pred, elems.iter().map(|e| &*e))\n             }\n \n-            hir::ExprCall(ref func, ref args) => {\n+            hir::ExprKind::Call(ref func, ref args) => {\n                 self.call(expr, pred, &func, args.iter().map(|e| &*e))\n             }\n \n-            hir::ExprMethodCall(.., ref args) => {\n+            hir::ExprKind::MethodCall(.., ref args) => {\n                 self.call(expr, pred, &args[0], args[1..].iter().map(|e| &*e))\n             }\n \n-            hir::ExprIndex(ref l, ref r) |\n-            hir::ExprBinary(_, ref l, ref r) if self.tables.is_method_call(expr) => {\n+            hir::ExprKind::Index(ref l, ref r) |\n+            hir::ExprKind::Binary(_, ref l, ref r) if self.tables.is_method_call(expr) => {\n                 self.call(expr, pred, &l, Some(&**r).into_iter())\n             }\n \n-            hir::ExprUnary(_, ref e) if self.tables.is_method_call(expr) => {\n+            hir::ExprKind::Unary(_, ref e) if self.tables.is_method_call(expr) => {\n                 self.call(expr, pred, &e, None::<hir::Expr>.iter())\n             }\n \n-            hir::ExprTup(ref exprs) => {\n+            hir::ExprKind::Tup(ref exprs) => {\n                 self.straightline(expr, pred, exprs.iter().map(|e| &*e))\n             }\n \n-            hir::ExprStruct(_, ref fields, ref base) => {\n+            hir::ExprKind::Struct(_, ref fields, ref base) => {\n                 let field_cfg = self.straightline(expr, pred, fields.iter().map(|f| &*f.expr));\n                 self.opt_expr(base, field_cfg)\n             }\n \n-            hir::ExprAssign(ref l, ref r) |\n-            hir::ExprAssignOp(_, ref l, ref r) => {\n+            hir::ExprKind::Assign(ref l, ref r) |\n+            hir::ExprKind::AssignOp(_, ref l, ref r) => {\n                 self.straightline(expr, pred, [r, l].iter().map(|&e| &**e))\n             }\n \n-            hir::ExprIndex(ref l, ref r) |\n-            hir::ExprBinary(_, ref l, ref r) => { // NB: && and || handled earlier\n+            hir::ExprKind::Index(ref l, ref r) |\n+            hir::ExprKind::Binary(_, ref l, ref r) => { // NB: && and || handled earlier\n                 self.straightline(expr, pred, [l, r].iter().map(|&e| &**e))\n             }\n \n-            hir::ExprBox(ref e) |\n-            hir::ExprAddrOf(_, ref e) |\n-            hir::ExprCast(ref e, _) |\n-            hir::ExprType(ref e, _) |\n-            hir::ExprUnary(_, ref e) |\n-            hir::ExprField(ref e, _) |\n-            hir::ExprYield(ref e) |\n-            hir::ExprRepeat(ref e, _) => {\n+            hir::ExprKind::Box(ref e) |\n+            hir::ExprKind::AddrOf(_, ref e) |\n+            hir::ExprKind::Cast(ref e, _) |\n+            hir::ExprKind::Type(ref e, _) |\n+            hir::ExprKind::Unary(_, ref e) |\n+            hir::ExprKind::Field(ref e, _) |\n+            hir::ExprKind::Yield(ref e) |\n+            hir::ExprKind::Repeat(ref e, _) => {\n                 self.straightline(expr, pred, Some(&**e).into_iter())\n             }\n \n-            hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n+            hir::ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n                 let post_outputs = self.exprs(outputs.iter().map(|e| &*e), pred);\n                 let post_inputs = self.exprs(inputs.iter().map(|e| &*e), post_outputs);\n                 self.add_ast_node(expr.hir_id.local_id, &[post_inputs])\n             }\n \n-            hir::ExprClosure(..) |\n-            hir::ExprLit(..) |\n-            hir::ExprPath(_) => {\n+            hir::ExprKind::Closure(..) |\n+            hir::ExprKind::Lit(..) |\n+            hir::ExprKind::Path(_) => {\n                 self.straightline(expr, pred, None::<hir::Expr>.iter())\n             }\n         }"}, {"sha": "3f6d34617c8320d9ef8ef88df1af509c70a27f10", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -38,13 +38,13 @@ enum Target {\n impl Target {\n     fn from_item(item: &hir::Item) -> Target {\n         match item.node {\n-            hir::ItemFn(..) => Target::Fn,\n-            hir::ItemStruct(..) => Target::Struct,\n-            hir::ItemUnion(..) => Target::Union,\n-            hir::ItemEnum(..) => Target::Enum,\n-            hir::ItemConst(..) => Target::Const,\n-            hir::ItemForeignMod(..) => Target::ForeignMod,\n-            hir::ItemStatic(..) => Target::Static,\n+            hir::ItemKind::Fn(..) => Target::Fn,\n+            hir::ItemKind::Struct(..) => Target::Struct,\n+            hir::ItemKind::Union(..) => Target::Union,\n+            hir::ItemKind::Enum(..) => Target::Enum,\n+            hir::ItemKind::Const(..) => Target::Const,\n+            hir::ItemKind::ForeignMod(..) => Target::ForeignMod,\n+            hir::ItemKind::Static(..) => Target::Static,\n             _ => Target::Other,\n         }\n     }\n@@ -264,7 +264,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n     fn check_stmt_attributes(&self, stmt: &hir::Stmt) {\n         // When checking statements ignore expressions, they will be checked later\n-        if let hir::Stmt_::StmtDecl(_, _) = stmt.node {\n+        if let hir::StmtKind::Decl(_, _) = stmt.node {\n             for attr in stmt.node.attrs() {\n                 if attr.check_name(\"inline\") {\n                     self.check_inline(attr, &stmt.span, Target::Statement);\n@@ -283,7 +283,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n     fn check_expr_attributes(&self, expr: &hir::Expr) {\n         let target = match expr.node {\n-            hir::ExprClosure(..) => Target::Closure,\n+            hir::ExprKind::Closure(..) => Target::Closure,\n             _ => Target::Expression,\n         };\n         for attr in expr.attrs.iter() {\n@@ -340,7 +340,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n }\n \n fn is_c_like_enum(item: &hir::Item) -> bool {\n-    if let hir::ItemEnum(ref def, _) = item.node {\n+    if let hir::ItemKind::Enum(ref def, _) = item.node {\n         for variant in &def.variants {\n             match variant.node.data {\n                 hir::VariantData::Unit(_) => { /* continue */ }"}, {"sha": "2fefd2b33189c9e3d289a5286a4fb2ad7542d1c4", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 69, "deletions": 62, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -50,6 +50,7 @@ use super::itemlikevisit::DeepVisitor;\n \n use std::cmp;\n use std::u32;\n+use std::result::Result::Err;\n \n #[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n@@ -462,23 +463,23 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_name(item.span, item.name);\n     match item.node {\n-        ItemExternCrate(orig_name) => {\n+        ItemKind::ExternCrate(orig_name) => {\n             visitor.visit_id(item.id);\n             if let Some(orig_name) = orig_name {\n                 visitor.visit_name(item.span, orig_name);\n             }\n         }\n-        ItemUse(ref path, _) => {\n+        ItemKind::Use(ref path, _) => {\n             visitor.visit_id(item.id);\n             visitor.visit_path(path, item.id);\n         }\n-        ItemStatic(ref typ, _, body) |\n-        ItemConst(ref typ, body) => {\n+        ItemKind::Static(ref typ, _, body) |\n+        ItemKind::Const(ref typ, body) => {\n             visitor.visit_id(item.id);\n             visitor.visit_ty(typ);\n             visitor.visit_nested_body(body);\n         }\n-        ItemFn(ref declaration, header, ref generics, body_id) => {\n+        ItemKind::Fn(ref declaration, header, ref generics, body_id) => {\n             visitor.visit_fn(FnKind::ItemFn(item.name,\n                                             generics,\n                                             header,\n@@ -489,55 +490,61 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                              item.span,\n                              item.id)\n         }\n-        ItemMod(ref module) => {\n+        ItemKind::Mod(ref module) => {\n             // visit_mod() takes care of visiting the Item's NodeId\n             visitor.visit_mod(module, item.span, item.id)\n         }\n-        ItemForeignMod(ref foreign_module) => {\n+        ItemKind::ForeignMod(ref foreign_module) => {\n             visitor.visit_id(item.id);\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n-        ItemGlobalAsm(_) => {\n+        ItemKind::GlobalAsm(_) => {\n             visitor.visit_id(item.id);\n         }\n-        ItemTy(ref typ, ref type_parameters) => {\n+        ItemKind::Ty(ref typ, ref type_parameters) => {\n             visitor.visit_id(item.id);\n             visitor.visit_ty(typ);\n             visitor.visit_generics(type_parameters)\n         }\n-        ItemExistential(ExistTy {ref generics, ref bounds, impl_trait_fn}) => {\n+        ItemKind::Existential(ExistTy {ref generics, ref bounds, impl_trait_fn}) => {\n             visitor.visit_id(item.id);\n             walk_generics(visitor, generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n             if let Some(impl_trait_fn) = impl_trait_fn {\n                 visitor.visit_def_mention(Def::Fn(impl_trait_fn))\n             }\n         }\n-        ItemEnum(ref enum_definition, ref type_parameters) => {\n+        ItemKind::Enum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters);\n             // visit_enum_def() takes care of visiting the Item's NodeId\n             visitor.visit_enum_def(enum_definition, type_parameters, item.id, item.span)\n         }\n-        ItemImpl(.., ref type_parameters, ref opt_trait_reference, ref typ, ref impl_item_refs) => {\n+        ItemKind::Impl(\n+            ..,\n+            ref type_parameters,\n+            ref opt_trait_reference,\n+            ref typ,\n+            ref impl_item_refs\n+        ) => {\n             visitor.visit_id(item.id);\n             visitor.visit_generics(type_parameters);\n             walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n             visitor.visit_ty(typ);\n             walk_list!(visitor, visit_impl_item_ref, impl_item_refs);\n         }\n-        ItemStruct(ref struct_definition, ref generics) |\n-        ItemUnion(ref struct_definition, ref generics) => {\n+        ItemKind::Struct(ref struct_definition, ref generics) |\n+        ItemKind::Union(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_id(item.id);\n             visitor.visit_variant_data(struct_definition, item.name, generics, item.id, item.span);\n         }\n-        ItemTrait(.., ref generics, ref bounds, ref trait_item_refs) => {\n+        ItemKind::Trait(.., ref generics, ref bounds, ref trait_item_refs) => {\n             visitor.visit_id(item.id);\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_trait_item_ref, trait_item_refs);\n         }\n-        ItemTraitAlias(ref generics, ref bounds) => {\n+        ItemKind::TraitAlias(ref generics, ref bounds) => {\n             visitor.visit_id(item.id);\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n@@ -576,41 +583,41 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     visitor.visit_id(typ.id);\n \n     match typ.node {\n-        TySlice(ref ty) => {\n+        TyKind::Slice(ref ty) => {\n             visitor.visit_ty(ty)\n         }\n-        TyPtr(ref mutable_type) => {\n+        TyKind::Ptr(ref mutable_type) => {\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyRptr(ref lifetime, ref mutable_type) => {\n+        TyKind::Rptr(ref lifetime, ref mutable_type) => {\n             visitor.visit_lifetime(lifetime);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyNever => {},\n-        TyTup(ref tuple_element_types) => {\n+        TyKind::Never => {},\n+        TyKind::Tup(ref tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n-        TyBareFn(ref function_declaration) => {\n+        TyKind::BareFn(ref function_declaration) => {\n             walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);\n             visitor.visit_fn_decl(&function_declaration.decl);\n         }\n-        TyPath(ref qpath) => {\n+        TyKind::Path(ref qpath) => {\n             visitor.visit_qpath(qpath, typ.id, typ.span);\n         }\n-        TyArray(ref ty, ref length) => {\n+        TyKind::Array(ref ty, ref length) => {\n             visitor.visit_ty(ty);\n             visitor.visit_anon_const(length)\n         }\n-        TyTraitObject(ref bounds, ref lifetime) => {\n+        TyKind::TraitObject(ref bounds, ref lifetime) => {\n             for bound in bounds {\n                 visitor.visit_poly_trait_ref(bound, TraitBoundModifier::None);\n             }\n             visitor.visit_lifetime(lifetime);\n         }\n-        TyTypeof(ref expression) => {\n+        TyKind::Typeof(ref expression) => {\n             visitor.visit_anon_const(expression)\n         }\n-        TyInfer | TyErr => {}\n+        TyKind::Infer | TyKind::Err => {}\n     }\n }\n \n@@ -709,15 +716,15 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n     visitor.visit_name(foreign_item.span, foreign_item.name);\n \n     match foreign_item.node {\n-        ForeignItemFn(ref function_declaration, ref param_names, ref generics) => {\n+        ForeignItemKind::Fn(ref function_declaration, ref param_names, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_fn_decl(function_declaration);\n             for &param_name in param_names {\n                 visitor.visit_ident(param_name);\n             }\n         }\n-        ForeignItemStatic(ref typ, _) => visitor.visit_ty(typ),\n-        ForeignItemType => (),\n+        ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n+        ForeignItemKind::Type => (),\n     }\n \n     walk_list!(visitor, visit_attribute, &foreign_item.attrs);\n@@ -935,12 +942,12 @@ pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n \n pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n     match statement.node {\n-        StmtDecl(ref declaration, id) => {\n+        StmtKind::Decl(ref declaration, id) => {\n             visitor.visit_id(id);\n             visitor.visit_decl(declaration)\n         }\n-        StmtExpr(ref expression, id) |\n-        StmtSemi(ref expression, id) => {\n+        StmtKind::Expr(ref expression, id) |\n+        StmtKind::Semi(ref expression, id) => {\n             visitor.visit_id(id);\n             visitor.visit_expr(expression)\n         }\n@@ -949,8 +956,8 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n \n pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n     match declaration.node {\n-        DeclLocal(ref local) => visitor.visit_local(local),\n-        DeclItem(item) => visitor.visit_nested_item(item),\n+        DeclKind::Local(ref local) => visitor.visit_local(local),\n+        DeclKind::Item(item) => visitor.visit_nested_item(item),\n     }\n }\n \n@@ -963,17 +970,17 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     visitor.visit_id(expression.id);\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n     match expression.node {\n-        ExprBox(ref subexpression) => {\n+        ExprKind::Box(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprArray(ref subexpressions) => {\n+        ExprKind::Array(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprRepeat(ref element, ref count) => {\n+        ExprKind::Repeat(ref element, ref count) => {\n             visitor.visit_expr(element);\n             visitor.visit_anon_const(count)\n         }\n-        ExprStruct(ref qpath, ref fields, ref optional_base) => {\n+        ExprKind::Struct(ref qpath, ref fields, ref optional_base) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n             for field in fields {\n                 visitor.visit_id(field.id);\n@@ -982,78 +989,78 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             }\n             walk_list!(visitor, visit_expr, optional_base);\n         }\n-        ExprTup(ref subexpressions) => {\n+        ExprKind::Tup(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprCall(ref callee_expression, ref arguments) => {\n+        ExprKind::Call(ref callee_expression, ref arguments) => {\n             visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprMethodCall(ref segment, _, ref arguments) => {\n+        ExprKind::MethodCall(ref segment, _, ref arguments) => {\n             visitor.visit_path_segment(expression.span, segment);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprBinary(_, ref left_expression, ref right_expression) => {\n+        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression)\n         }\n-        ExprAddrOf(_, ref subexpression) | ExprUnary(_, ref subexpression) => {\n+        ExprKind::AddrOf(_, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprLit(_) => {}\n-        ExprCast(ref subexpression, ref typ) | ExprType(ref subexpression, ref typ) => {\n+        ExprKind::Lit(_) => {}\n+        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n         }\n-        ExprIf(ref head_expression, ref if_block, ref optional_else) => {\n+        ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n             visitor.visit_expr(head_expression);\n             visitor.visit_expr(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprWhile(ref subexpression, ref block, ref opt_label) => {\n+        ExprKind::While(ref subexpression, ref block, ref opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }\n-        ExprLoop(ref block, ref opt_label, _) => {\n+        ExprKind::Loop(ref block, ref opt_label, _) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n-        ExprMatch(ref subexpression, ref arms, _) => {\n+        ExprKind::Match(ref subexpression, ref arms, _) => {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n-        ExprClosure(_, ref function_declaration, body, _fn_decl_span, _gen) => {\n+        ExprKind::Closure(_, ref function_declaration, body, _fn_decl_span, _gen) => {\n             visitor.visit_fn(FnKind::Closure(&expression.attrs),\n                              function_declaration,\n                              body,\n                              expression.span,\n                              expression.id)\n         }\n-        ExprBlock(ref block, ref opt_label) => {\n+        ExprKind::Block(ref block, ref opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n-        ExprAssign(ref left_hand_expression, ref right_hand_expression) => {\n+        ExprKind::Assign(ref left_hand_expression, ref right_hand_expression) => {\n             visitor.visit_expr(right_hand_expression);\n             visitor.visit_expr(left_hand_expression)\n         }\n-        ExprAssignOp(_, ref left_expression, ref right_expression) => {\n+        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n             visitor.visit_expr(right_expression);\n             visitor.visit_expr(left_expression)\n         }\n-        ExprField(ref subexpression, ident) => {\n+        ExprKind::Field(ref subexpression, ident) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ident(ident);\n         }\n-        ExprIndex(ref main_expression, ref index_expression) => {\n+        ExprKind::Index(ref main_expression, ref index_expression) => {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)\n         }\n-        ExprPath(ref qpath) => {\n+        ExprKind::Path(ref qpath) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n         }\n-        ExprBreak(ref destination, ref opt_expr) => {\n+        ExprKind::Break(ref destination, ref opt_expr) => {\n             if let Some(ref label) = destination.label {\n                 visitor.visit_label(label);\n                 match destination.target_id {\n@@ -1063,7 +1070,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             }\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprContinue(ref destination) => {\n+        ExprKind::Continue(ref destination) => {\n             if let Some(ref label) = destination.label {\n                 visitor.visit_label(label);\n                 match destination.target_id {\n@@ -1072,18 +1079,18 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n                 };\n             }\n         }\n-        ExprRet(ref optional_expression) => {\n+        ExprKind::Ret(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprInlineAsm(_, ref outputs, ref inputs) => {\n+        ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n             for output in outputs {\n                 visitor.visit_expr(output)\n             }\n             for input in inputs {\n                 visitor.visit_expr(input)\n             }\n         }\n-        ExprYield(ref subexpression) => {\n+        ExprKind::Yield(ref subexpression) => {\n             visitor.visit_expr(subexpression);\n         }\n     }"}, {"sha": "722934ac39a530f8767cb7427fbe8d22dafa12bc", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 151, "deletions": 139, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -384,8 +384,8 @@ impl<'a> LoweringContext<'a> {\n \n                 if item_lowered {\n                     let item_generics = match self.lctx.items.get(&item.id).unwrap().node {\n-                        hir::Item_::ItemImpl(_, _, _, ref generics, ..)\n-                        | hir::Item_::ItemTrait(_, _, ref generics, ..) => {\n+                        hir::ItemKind::Impl(_, _, _, ref generics, ..)\n+                        | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n                             generics.params.clone()\n                         }\n                         _ => HirVec::new(),\n@@ -853,7 +853,7 @@ impl<'a> LoweringContext<'a> {\n         closure_node_id: NodeId,\n         ret_ty: Option<&Ty>,\n         body: impl FnOnce(&mut LoweringContext) -> hir::Expr,\n-    ) -> hir::Expr_ {\n+    ) -> hir::ExprKind {\n         let prev_is_generator = mem::replace(&mut self.is_generator, true);\n         let body_expr = body(self);\n         let span = body_expr.span;\n@@ -875,7 +875,7 @@ impl<'a> LoweringContext<'a> {\n         let generator = hir::Expr {\n             id: closure_node_id,\n             hir_id: closure_hir_id,\n-            node: hir::ExprClosure(capture_clause, decl, body_id, span,\n+            node: hir::ExprKind::Closure(capture_clause, decl, body_id, span,\n                 Some(hir::GeneratorMovability::Static)),\n             span,\n             attrs: ThinVec::new(),\n@@ -884,7 +884,7 @@ impl<'a> LoweringContext<'a> {\n         let unstable_span = self.allow_internal_unstable(CompilerDesugaringKind::Async, span);\n         let gen_future = self.expr_std_path(\n             unstable_span, &[\"future\", \"from_generator\"], None, ThinVec::new());\n-        hir::ExprCall(P(gen_future), hir_vec![generator])\n+        hir::ExprKind::Call(P(gen_future), hir_vec![generator])\n     }\n \n     fn lower_body<F>(&mut self, decl: Option<&FnDecl>, f: F) -> hir::BodyId\n@@ -1080,25 +1080,25 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_ty_direct(&mut self, t: &Ty, mut itctx: ImplTraitContext) -> hir::Ty {\n         let kind = match t.node {\n-            TyKind::Infer => hir::TyInfer,\n-            TyKind::Err => hir::TyErr,\n-            TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty, itctx)),\n-            TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt, itctx)),\n+            TyKind::Infer => hir::TyKind::Infer,\n+            TyKind::Err => hir::TyKind::Err,\n+            TyKind::Slice(ref ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n+            TyKind::Ptr(ref mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n             TyKind::Rptr(ref region, ref mt) => {\n                 let span = t.span.shrink_to_lo();\n                 let lifetime = match *region {\n                     Some(ref lt) => self.lower_lifetime(lt),\n                     None => self.elided_ref_lifetime(span),\n                 };\n-                hir::TyRptr(lifetime, self.lower_mt(mt, itctx))\n+                hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n             }\n             TyKind::BareFn(ref f) => self.with_in_scope_lifetime_defs(\n                 &f.generic_params,\n                 |this| {\n                     this.with_anonymous_lifetime_mode(\n                         AnonymousLifetimeMode::PassThrough,\n                         |this| {\n-                            hir::TyBareFn(P(hir::BareFnTy {\n+                            hir::TyKind::BareFn(P(hir::BareFnTy {\n                                 generic_params: this.lower_generic_params(\n                                     &f.generic_params,\n                                     &NodeMap(),\n@@ -1113,9 +1113,9 @@ impl<'a> LoweringContext<'a> {\n                     )\n                 },\n             ),\n-            TyKind::Never => hir::TyNever,\n+            TyKind::Never => hir::TyKind::Never,\n             TyKind::Tup(ref tys) => {\n-                hir::TyTup(tys.iter().map(|ty| {\n+                hir::TyKind::Tup(tys.iter().map(|ty| {\n                     self.lower_ty_direct(ty, itctx.reborrow())\n                 }).collect())\n             }\n@@ -1126,12 +1126,12 @@ impl<'a> LoweringContext<'a> {\n                 let id = self.lower_node_id(t.id);\n                 let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit, itctx);\n                 let ty = self.ty_path(id, t.span, qpath);\n-                if let hir::TyTraitObject(..) = ty.node {\n+                if let hir::TyKind::TraitObject(..) = ty.node {\n                     self.maybe_lint_bare_trait(t.span, t.id, qself.is_none() && path.is_global());\n                 }\n                 return ty;\n             }\n-            TyKind::ImplicitSelf => hir::TyPath(hir::QPath::Resolved(\n+            TyKind::ImplicitSelf => hir::TyKind::Path(hir::QPath::Resolved(\n                 None,\n                 P(hir::Path {\n                     def: self.expect_full_def(t.id),\n@@ -1140,10 +1140,10 @@ impl<'a> LoweringContext<'a> {\n                 }),\n             )),\n             TyKind::Array(ref ty, ref length) => {\n-                hir::TyArray(self.lower_ty(ty, itctx), self.lower_anon_const(length))\n+                hir::TyKind::Array(self.lower_ty(ty, itctx), self.lower_anon_const(length))\n             }\n             TyKind::Typeof(ref expr) => {\n-                hir::TyTypeof(self.lower_anon_const(expr))\n+                hir::TyKind::Typeof(self.lower_anon_const(expr))\n             }\n             TyKind::TraitObject(ref bounds, kind) => {\n                 let mut lifetime_bound = None;\n@@ -1167,7 +1167,7 @@ impl<'a> LoweringContext<'a> {\n                 if kind != TraitObjectSyntax::Dyn {\n                     self.maybe_lint_bare_trait(t.span, t.id, false);\n                 }\n-                hir::TyTraitObject(bounds, lifetime_bound)\n+                hir::TyKind::TraitObject(bounds, lifetime_bound)\n             }\n             TyKind::ImplTrait(def_node_id, ref bounds) => {\n                 let span = t.span;\n@@ -1206,7 +1206,7 @@ impl<'a> LoweringContext<'a> {\n                             }\n                         });\n \n-                        hir::TyPath(hir::QPath::Resolved(\n+                        hir::TyKind::Path(hir::QPath::Resolved(\n                             None,\n                             P(hir::Path {\n                                 span,\n@@ -1223,7 +1223,7 @@ impl<'a> LoweringContext<'a> {\n                             \"`impl Trait` not allowed outside of function \\\n                              and inherent method return types\"\n                         );\n-                        hir::TyErr\n+                        hir::TyKind::Err\n                     }\n                 }\n             }\n@@ -1245,7 +1245,7 @@ impl<'a> LoweringContext<'a> {\n         fn_def_id: DefId,\n         exist_ty_node_id: NodeId,\n         lower_bounds: impl FnOnce(&mut LoweringContext) -> hir::GenericBounds,\n-    ) -> hir::Ty_ {\n+    ) -> hir::TyKind {\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n         // desugaring that explicitly states that we don't want to track that.\n@@ -1274,7 +1274,7 @@ impl<'a> LoweringContext<'a> {\n         );\n \n         self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n-            let exist_ty_item_kind = hir::ItemExistential(hir::ExistTy {\n+            let exist_ty_item_kind = hir::ItemKind::Existential(hir::ExistTy {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n                     where_clause: hir::WhereClause {\n@@ -1320,7 +1320,7 @@ impl<'a> LoweringContext<'a> {\n                     }))\n                 }],\n             });\n-            hir::TyPath(hir::QPath::Resolved(None, path))\n+            hir::TyKind::Path(hir::QPath::Resolved(None, path))\n         })\n     }\n \n@@ -1365,7 +1365,7 @@ impl<'a> LoweringContext<'a> {\n \n             fn visit_ty(&mut self, t: &'v hir::Ty) {\n                 // Don't collect elided lifetimes used inside of `fn()` syntax\n-                if let hir::Ty_::TyBareFn(_) = t.node {\n+                if let hir::TyKind::BareFn(_) = t.node {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n                     self.collect_elided_lifetimes = false;\n \n@@ -1507,7 +1507,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant {\n         Spanned {\n-            node: hir::Variant_ {\n+            node: hir::VariantKind {\n                 name: v.node.ident.name,\n                 attrs: self.lower_attrs(&v.node.attrs),\n                 data: self.lower_variant_data(&v.node.data),\n@@ -1805,7 +1805,7 @@ impl<'a> LoweringContext<'a> {\n                 let inputs = inputs.iter().map(|ty| this.lower_ty_direct(ty, DISALLOWED)).collect();\n                 let mk_tup = |this: &mut Self, tys, span| {\n                     let LoweredNodeId { node_id, hir_id } = this.next_id();\n-                    hir::Ty { node: hir::TyTup(tys), id: node_id, hir_id, span }\n+                    hir::Ty { node: hir::TyKind::Tup(tys), id: node_id, hir_id, span }\n                 };\n \n                 (\n@@ -1985,7 +1985,7 @@ impl<'a> LoweringContext<'a> {\n \n             fn visit_ty(&mut self, t: &'v hir::Ty) {\n                 // Don't collect elided lifetimes used inside of `fn()` syntax\n-                if let &hir::Ty_::TyBareFn(_) = &t.node {\n+                if let &hir::TyKind::BareFn(_) = &t.node {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n                     self.collect_elided_lifetimes = false;\n \n@@ -2105,7 +2105,7 @@ impl<'a> LoweringContext<'a> {\n                     P(hir::Ty {\n                         id: node_id,\n                         hir_id: hir_id,\n-                        node: hir::TyTup(hir_vec![]),\n+                        node: hir::TyKind::Tup(hir_vec![]),\n                         span: *span,\n                     })\n                 }\n@@ -2575,9 +2575,9 @@ impl<'a> LoweringContext<'a> {\n         attrs: &hir::HirVec<Attribute>,\n         vis: &mut hir::Visibility,\n         i: &ItemKind,\n-    ) -> hir::Item_ {\n+    ) -> hir::ItemKind {\n         match *i {\n-            ItemKind::ExternCrate(orig_name) => hir::ItemExternCrate(orig_name),\n+            ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(orig_name),\n             ItemKind::Use(ref use_tree) => {\n                 // Start with an empty prefix\n                 let prefix = Path {\n@@ -2589,15 +2589,15 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n-                hir::ItemStatic(\n+                hir::ItemKind::Static(\n                     self.lower_ty(t, ImplTraitContext::Disallowed),\n                     self.lower_mutability(m),\n                     value,\n                 )\n             }\n             ItemKind::Const(ref t, ref e) => {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n-                hir::ItemConst(self.lower_ty(t, ImplTraitContext::Disallowed), value)\n+                hir::ItemKind::Const(self.lower_ty(t, ImplTraitContext::Disallowed), value)\n             }\n             ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n@@ -2617,22 +2617,22 @@ impl<'a> LoweringContext<'a> {\n                             decl, Some((fn_def_id, idty)), true, header.asyncness.opt_return_id()),\n                     );\n \n-                    hir::ItemFn(\n+                    hir::ItemKind::Fn(\n                         fn_decl,\n                         this.lower_fn_header(header),\n                         generics,\n                         body_id,\n                     )\n                 })\n             }\n-            ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n-            ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n-            ItemKind::GlobalAsm(ref ga) => hir::ItemGlobalAsm(self.lower_global_asm(ga)),\n-            ItemKind::Ty(ref t, ref generics) => hir::ItemTy(\n+            ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n+            ItemKind::ForeignMod(ref nm) => hir::ItemKind::ForeignMod(self.lower_foreign_mod(nm)),\n+            ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n+            ItemKind::Ty(ref t, ref generics) => hir::ItemKind::Ty(\n                 self.lower_ty(t, ImplTraitContext::Disallowed),\n                 self.lower_generics(generics, ImplTraitContext::Disallowed),\n             ),\n-            ItemKind::Enum(ref enum_definition, ref generics) => hir::ItemEnum(\n+            ItemKind::Enum(ref enum_definition, ref generics) => hir::ItemKind::Enum(\n                 hir::EnumDef {\n                     variants: enum_definition\n                         .variants\n@@ -2644,14 +2644,14 @@ impl<'a> LoweringContext<'a> {\n             ),\n             ItemKind::Struct(ref struct_def, ref generics) => {\n                 let struct_def = self.lower_variant_data(struct_def);\n-                hir::ItemStruct(\n+                hir::ItemKind::Struct(\n                     struct_def,\n                     self.lower_generics(generics, ImplTraitContext::Disallowed),\n                 )\n             }\n             ItemKind::Union(ref vdata, ref generics) => {\n                 let vdata = self.lower_variant_data(vdata);\n-                hir::ItemUnion(\n+                hir::ItemKind::Union(\n                     vdata,\n                     self.lower_generics(generics, ImplTraitContext::Disallowed),\n                 )\n@@ -2711,7 +2711,7 @@ impl<'a> LoweringContext<'a> {\n                     },\n                 );\n \n-                hir::ItemImpl(\n+                hir::ItemKind::Impl(\n                     self.lower_unsafety(unsafety),\n                     self.lower_impl_polarity(polarity),\n                     self.lower_defaultness(defaultness, true /* [1] */),\n@@ -2727,15 +2727,15 @@ impl<'a> LoweringContext<'a> {\n                     .iter()\n                     .map(|item| self.lower_trait_item_ref(item))\n                     .collect();\n-                hir::ItemTrait(\n+                hir::ItemKind::Trait(\n                     self.lower_is_auto(is_auto),\n                     self.lower_unsafety(unsafety),\n                     self.lower_generics(generics, ImplTraitContext::Disallowed),\n                     bounds,\n                     items,\n                 )\n             }\n-            ItemKind::TraitAlias(ref generics, ref bounds) => hir::ItemTraitAlias(\n+            ItemKind::TraitAlias(ref generics, ref bounds) => hir::ItemKind::TraitAlias(\n                 self.lower_generics(generics, ImplTraitContext::Disallowed),\n                 self.lower_param_bounds(bounds, ImplTraitContext::Disallowed),\n             ),\n@@ -2754,7 +2754,7 @@ impl<'a> LoweringContext<'a> {\n         vis: &mut hir::Visibility,\n         name: &mut Name,\n         attrs: &hir::HirVec<Attribute>,\n-    ) -> hir::Item_ {\n+    ) -> hir::ItemKind {\n         let path = &tree.prefix;\n \n         match tree.kind {\n@@ -2804,7 +2804,7 @@ impl<'a> LoweringContext<'a> {\n                     self.with_hir_id_owner(new_node_id, |this| {\n                         let new_id = this.lower_node_id(new_node_id);\n                         let path = this.lower_path_extra(def, &path, None, ParamMode::Explicit);\n-                        let item = hir::ItemUse(P(path), hir::UseKind::Single);\n+                        let item = hir::ItemKind::Use(P(path), hir::UseKind::Single);\n                         let vis_kind = match vis.node {\n                             hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n                             hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n@@ -2835,7 +2835,7 @@ impl<'a> LoweringContext<'a> {\n                 }\n \n                 let path = P(self.lower_path_extra(ret_def, &path, None, ParamMode::Explicit));\n-                hir::ItemUse(path, hir::UseKind::Single)\n+                hir::ItemKind::Use(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n                 let path = P(self.lower_path(\n@@ -2851,7 +2851,7 @@ impl<'a> LoweringContext<'a> {\n                     },\n                     ParamMode::Explicit,\n                 ));\n-                hir::ItemUse(path, hir::UseKind::Glob)\n+                hir::ItemKind::Use(path, hir::UseKind::Glob)\n             }\n             UseTreeKind::Nested(ref trees) => {\n                 let prefix = Path {\n@@ -2912,7 +2912,7 @@ impl<'a> LoweringContext<'a> {\n                 // a re-export by accident when `pub`, e.g. in documentation.\n                 let path = P(self.lower_path(id, &prefix, ParamMode::Explicit));\n                 *vis = respan(prefix.span.shrink_to_lo(), hir::VisibilityKind::Inherited);\n-                hir::ItemUse(path, hir::UseKind::ListStem)\n+                hir::ItemKind::Use(path, hir::UseKind::ListStem)\n             }\n         }\n     }\n@@ -3230,12 +3230,12 @@ impl<'a> LoweringContext<'a> {\n                         },\n                     );\n \n-                    hir::ForeignItemFn(fn_dec, fn_args, generics)\n+                    hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n                 ForeignItemKind::Static(ref t, m) => {\n-                    hir::ForeignItemStatic(self.lower_ty(t, ImplTraitContext::Disallowed), m)\n+                    hir::ForeignItemKind::Static(self.lower_ty(t, ImplTraitContext::Disallowed), m)\n                 }\n-                ForeignItemKind::Ty => hir::ForeignItemType,\n+                ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n                 ForeignItemKind::Macro(_) => panic!(\"shouldn't exist here\"),\n             },\n             vis: self.lower_visibility(&i.vis, None),\n@@ -3314,24 +3314,24 @@ impl<'a> LoweringContext<'a> {\n     fn lower_binop(&mut self, b: BinOp) -> hir::BinOp {\n         Spanned {\n             node: match b.node {\n-                BinOpKind::Add => hir::BiAdd,\n-                BinOpKind::Sub => hir::BiSub,\n-                BinOpKind::Mul => hir::BiMul,\n-                BinOpKind::Div => hir::BiDiv,\n-                BinOpKind::Rem => hir::BiRem,\n-                BinOpKind::And => hir::BiAnd,\n-                BinOpKind::Or => hir::BiOr,\n-                BinOpKind::BitXor => hir::BiBitXor,\n-                BinOpKind::BitAnd => hir::BiBitAnd,\n-                BinOpKind::BitOr => hir::BiBitOr,\n-                BinOpKind::Shl => hir::BiShl,\n-                BinOpKind::Shr => hir::BiShr,\n-                BinOpKind::Eq => hir::BiEq,\n-                BinOpKind::Lt => hir::BiLt,\n-                BinOpKind::Le => hir::BiLe,\n-                BinOpKind::Ne => hir::BiNe,\n-                BinOpKind::Ge => hir::BiGe,\n-                BinOpKind::Gt => hir::BiGt,\n+                BinOpKind::Add => hir::BinOpKind::Add,\n+                BinOpKind::Sub => hir::BinOpKind::Sub,\n+                BinOpKind::Mul => hir::BinOpKind::Mul,\n+                BinOpKind::Div => hir::BinOpKind::Div,\n+                BinOpKind::Rem => hir::BinOpKind::Rem,\n+                BinOpKind::And => hir::BinOpKind::And,\n+                BinOpKind::Or => hir::BinOpKind::Or,\n+                BinOpKind::BitXor => hir::BinOpKind::BitXor,\n+                BinOpKind::BitAnd => hir::BinOpKind::BitAnd,\n+                BinOpKind::BitOr => hir::BinOpKind::BitOr,\n+                BinOpKind::Shl => hir::BinOpKind::Shl,\n+                BinOpKind::Shr => hir::BinOpKind::Shr,\n+                BinOpKind::Eq => hir::BinOpKind::Eq,\n+                BinOpKind::Lt => hir::BinOpKind::Lt,\n+                BinOpKind::Le => hir::BinOpKind::Le,\n+                BinOpKind::Ne => hir::BinOpKind::Ne,\n+                BinOpKind::Ge => hir::BinOpKind::Ge,\n+                BinOpKind::Gt => hir::BinOpKind::Gt,\n             },\n             span: b.span,\n         }\n@@ -3468,25 +3468,25 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_expr(&mut self, e: &Expr) -> hir::Expr {\n         let kind = match e.node {\n-            ExprKind::Box(ref inner) => hir::ExprBox(P(self.lower_expr(inner))),\n+            ExprKind::Box(ref inner) => hir::ExprKind::Box(P(self.lower_expr(inner))),\n             ExprKind::ObsoleteInPlace(..) => {\n                 self.sess.abort_if_errors();\n                 span_bug!(e.span, \"encountered ObsoleteInPlace expr during lowering\");\n             }\n             ExprKind::Array(ref exprs) => {\n-                hir::ExprArray(exprs.iter().map(|x| self.lower_expr(x)).collect())\n+                hir::ExprKind::Array(exprs.iter().map(|x| self.lower_expr(x)).collect())\n             }\n             ExprKind::Repeat(ref expr, ref count) => {\n                 let expr = P(self.lower_expr(expr));\n                 let count = self.lower_anon_const(count);\n-                hir::ExprRepeat(expr, count)\n+                hir::ExprKind::Repeat(expr, count)\n             }\n             ExprKind::Tup(ref elts) => {\n-                hir::ExprTup(elts.iter().map(|x| self.lower_expr(x)).collect())\n+                hir::ExprKind::Tup(elts.iter().map(|x| self.lower_expr(x)).collect())\n             }\n             ExprKind::Call(ref f, ref args) => {\n                 let f = P(self.lower_expr(f));\n-                hir::ExprCall(f, args.iter().map(|x| self.lower_expr(x)).collect())\n+                hir::ExprKind::Call(f, args.iter().map(|x| self.lower_expr(x)).collect())\n             }\n             ExprKind::MethodCall(ref seg, ref args) => {\n                 let hir_seg = self.lower_path_segment(\n@@ -3498,32 +3498,32 @@ impl<'a> LoweringContext<'a> {\n                     ImplTraitContext::Disallowed,\n                 );\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n-                hir::ExprMethodCall(hir_seg, seg.ident.span, args)\n+                hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args)\n             }\n             ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                 let binop = self.lower_binop(binop);\n                 let lhs = P(self.lower_expr(lhs));\n                 let rhs = P(self.lower_expr(rhs));\n-                hir::ExprBinary(binop, lhs, rhs)\n+                hir::ExprKind::Binary(binop, lhs, rhs)\n             }\n             ExprKind::Unary(op, ref ohs) => {\n                 let op = self.lower_unop(op);\n                 let ohs = P(self.lower_expr(ohs));\n-                hir::ExprUnary(op, ohs)\n+                hir::ExprKind::Unary(op, ohs)\n             }\n-            ExprKind::Lit(ref l) => hir::ExprLit(P((**l).clone())),\n+            ExprKind::Lit(ref l) => hir::ExprKind::Lit(P((**l).clone())),\n             ExprKind::Cast(ref expr, ref ty) => {\n                 let expr = P(self.lower_expr(expr));\n-                hir::ExprCast(expr, self.lower_ty(ty, ImplTraitContext::Disallowed))\n+                hir::ExprKind::Cast(expr, self.lower_ty(ty, ImplTraitContext::Disallowed))\n             }\n             ExprKind::Type(ref expr, ref ty) => {\n                 let expr = P(self.lower_expr(expr));\n-                hir::ExprType(expr, self.lower_ty(ty, ImplTraitContext::Disallowed))\n+                hir::ExprKind::Type(expr, self.lower_ty(ty, ImplTraitContext::Disallowed))\n             }\n             ExprKind::AddrOf(m, ref ohs) => {\n                 let m = self.lower_mutability(m);\n                 let ohs = P(self.lower_expr(ohs));\n-                hir::ExprAddrOf(m, ohs)\n+                hir::ExprKind::AddrOf(m, ohs)\n             }\n             // More complicated than you might expect because the else branch\n             // might be `if let`.\n@@ -3554,17 +3554,17 @@ impl<'a> LoweringContext<'a> {\n                 let then_blk = self.lower_block(blk, false);\n                 let then_expr = self.expr_block(then_blk, ThinVec::new());\n \n-                hir::ExprIf(P(self.lower_expr(cond)), P(then_expr), else_opt)\n+                hir::ExprKind::If(P(self.lower_expr(cond)), P(then_expr), else_opt)\n             }\n             ExprKind::While(ref cond, ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n-                hir::ExprWhile(\n+                hir::ExprKind::While(\n                     this.with_loop_condition_scope(|this| P(this.lower_expr(cond))),\n                     this.lower_block(body, false),\n                     this.lower_label(opt_label),\n                 )\n             }),\n             ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n-                hir::ExprLoop(\n+                hir::ExprKind::Loop(\n                     this.lower_block(body, false),\n                     this.lower_label(opt_label),\n                     hir::LoopSource::Loop,\n@@ -3582,7 +3582,7 @@ impl<'a> LoweringContext<'a> {\n                             hir::Expr {\n                                 id: node_id,\n                                 span,\n-                                node: hir::ExprTup(hir_vec![]),\n+                                node: hir::ExprKind::Tup(hir_vec![]),\n                                 attrs: ThinVec::new(),\n                                 hir_id,\n                             }\n@@ -3591,10 +3591,10 @@ impl<'a> LoweringContext<'a> {\n                     );\n                     block.expr = Some(this.wrap_in_try_constructor(\n                         \"from_ok\", tail, unstable_span));\n-                    hir::ExprBlock(P(block), None)\n+                    hir::ExprKind::Block(P(block), None)\n                 })\n             }\n-            ExprKind::Match(ref expr, ref arms) => hir::ExprMatch(\n+            ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n                 P(self.lower_expr(expr)),\n                 arms.iter().map(|x| self.lower_arm(x)).collect(),\n                 hir::MatchSource::Normal,\n@@ -3652,7 +3652,7 @@ impl<'a> LoweringContext<'a> {\n                                 });\n                             this.expr(fn_decl_span, async_body, ThinVec::new())\n                         });\n-                        hir::ExprClosure(\n+                        hir::ExprKind::Closure(\n                             this.lower_capture_clause(capture_clause),\n                             fn_decl,\n                             body_id,\n@@ -3696,7 +3696,7 @@ impl<'a> LoweringContext<'a> {\n                             }\n                             None\n                         };\n-                        hir::ExprClosure(\n+                        hir::ExprKind::Closure(\n                             this.lower_capture_clause(capture_clause),\n                             fn_decl,\n                             body_id,\n@@ -3707,21 +3707,21 @@ impl<'a> LoweringContext<'a> {\n                 }\n             }\n             ExprKind::Block(ref blk, opt_label) => {\n-                hir::ExprBlock(self.lower_block(blk,\n+                hir::ExprKind::Block(self.lower_block(blk,\n                                                 opt_label.is_some()),\n                                                 self.lower_label(opt_label))\n             }\n             ExprKind::Assign(ref el, ref er) => {\n-                hir::ExprAssign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n+                hir::ExprKind::Assign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }\n-            ExprKind::AssignOp(op, ref el, ref er) => hir::ExprAssignOp(\n+            ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n                 self.lower_binop(op),\n                 P(self.lower_expr(el)),\n                 P(self.lower_expr(er)),\n             ),\n-            ExprKind::Field(ref el, ident) => hir::ExprField(P(self.lower_expr(el)), ident),\n+            ExprKind::Field(ref el, ident) => hir::ExprKind::Field(P(self.lower_expr(el)), ident),\n             ExprKind::Index(ref el, ref er) => {\n-                hir::ExprIndex(P(self.lower_expr(el)), P(self.lower_expr(er)))\n+                hir::ExprKind::Index(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }\n             // Desugar `<start>..=<end>` to `std::ops::RangeInclusive::new(<start>, <end>)`\n             ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n@@ -3734,8 +3734,8 @@ impl<'a> LoweringContext<'a> {\n                 let ty = P(self.ty_path(id, span, hir::QPath::Resolved(None, ty_path)));\n                 let new_seg = P(hir::PathSegment::from_ident(Ident::from_str(\"new\")));\n                 let new_path = hir::QPath::TypeRelative(ty, new_seg);\n-                let new = P(self.expr(span, hir::ExprPath(new_path), ThinVec::new()));\n-                hir::ExprCall(new, hir_vec![e1, e2])\n+                let new = P(self.expr(span, hir::ExprKind::Path(new_path), ThinVec::new()));\n+                hir::ExprKind::Call(new, hir_vec![e1, e2])\n             }\n             ExprKind::Range(ref e1, ref e2, lims) => {\n                 use syntax::ast::RangeLimits::*;\n@@ -3779,15 +3779,15 @@ impl<'a> LoweringContext<'a> {\n                     id: node_id,\n                     hir_id,\n                     node: if is_unit {\n-                        hir::ExprPath(struct_path)\n+                        hir::ExprKind::Path(struct_path)\n                     } else {\n-                        hir::ExprStruct(struct_path, fields, None)\n+                        hir::ExprKind::Struct(struct_path, fields, None)\n                     },\n                     span: unstable_span,\n                     attrs: e.attrs.clone(),\n                 };\n             }\n-            ExprKind::Path(ref qself, ref path) => hir::ExprPath(self.lower_qpath(\n+            ExprKind::Path(ref qself, ref path) => hir::ExprKind::Path(self.lower_qpath(\n                 e.id,\n                 qself,\n                 path,\n@@ -3803,13 +3803,13 @@ impl<'a> LoweringContext<'a> {\n                 } else {\n                     self.lower_loop_destination(opt_label.map(|label| (e.id, label)))\n                 };\n-                hir::ExprBreak(\n+                hir::ExprKind::Break(\n                     destination,\n                     opt_expr.as_ref().map(|x| P(self.lower_expr(x))),\n                 )\n             }\n             ExprKind::Continue(opt_label) => {\n-                hir::ExprContinue(if self.is_in_loop_condition && opt_label.is_none() {\n+                hir::ExprKind::Continue(if self.is_in_loop_condition && opt_label.is_none() {\n                     hir::Destination {\n                         label: None,\n                         target_id: Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n@@ -3818,7 +3818,7 @@ impl<'a> LoweringContext<'a> {\n                     self.lower_loop_destination(opt_label.map(|label| (e.id, label)))\n                 })\n             }\n-            ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n+            ExprKind::Ret(ref e) => hir::ExprKind::Ret(e.as_ref().map(|x| P(self.lower_expr(x)))),\n             ExprKind::InlineAsm(ref asm) => {\n                 let hir_asm = hir::InlineAsm {\n                     inputs: asm.inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n@@ -3846,9 +3846,9 @@ impl<'a> LoweringContext<'a> {\n                     .iter()\n                     .map(|&(_, ref input)| self.lower_expr(input))\n                     .collect();\n-                hir::ExprInlineAsm(P(hir_asm), outputs, inputs)\n+                hir::ExprKind::InlineAsm(P(hir_asm), outputs, inputs)\n             }\n-            ExprKind::Struct(ref path, ref fields, ref maybe_expr) => hir::ExprStruct(\n+            ExprKind::Struct(ref path, ref fields, ref maybe_expr) => hir::ExprKind::Struct(\n                 self.lower_qpath(\n                     e.id,\n                     &None,\n@@ -3877,8 +3877,10 @@ impl<'a> LoweringContext<'a> {\n                 let expr = opt_expr\n                     .as_ref()\n                     .map(|x| self.lower_expr(x))\n-                    .unwrap_or_else(|| self.expr(e.span, hir::ExprTup(hir_vec![]), ThinVec::new()));\n-                hir::ExprYield(P(expr))\n+                    .unwrap_or_else(||\n+                    self.expr(e.span, hir::ExprKind::Tup(hir_vec![]), ThinVec::new())\n+                );\n+                hir::ExprKind::Yield(P(expr))\n             }\n \n             // Desugar ExprIfLet\n@@ -3917,7 +3919,7 @@ impl<'a> LoweringContext<'a> {\n \n                 let sub_expr = P(self.lower_expr(sub_expr));\n \n-                hir::ExprMatch(\n+                hir::ExprKind::Match(\n                     sub_expr,\n                     arms.into(),\n                     hir::MatchSource::IfLetDesugar {\n@@ -3965,13 +3967,13 @@ impl<'a> LoweringContext<'a> {\n                 let arms = hir_vec![pat_arm, break_arm];\n                 let match_expr = self.expr(\n                     sub_expr.span,\n-                    hir::ExprMatch(sub_expr, arms, hir::MatchSource::WhileLetDesugar),\n+                    hir::ExprKind::Match(sub_expr, arms, hir::MatchSource::WhileLetDesugar),\n                     ThinVec::new(),\n                 );\n \n                 // `[opt_ident]: loop { ... }`\n                 let loop_block = P(self.block_expr(P(match_expr)));\n-                let loop_expr = hir::ExprLoop(\n+                let loop_expr = hir::ExprKind::Loop(\n                     loop_block,\n                     self.lower_label(opt_label),\n                     hir::LoopSource::WhileLet,\n@@ -3995,7 +3997,7 @@ impl<'a> LoweringContext<'a> {\n                 //             ::std::option::Option::None => break\n                 //           };\n                 //           let <pat> = __next;\n-                //           StmtExpr(<body>);\n+                //           StmtKind::Expr(<body>);\n                 //         }\n                 //       }\n                 //     };\n@@ -4023,7 +4025,7 @@ impl<'a> LoweringContext<'a> {\n                     let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat.id));\n                     let assign = P(self.expr(\n                         pat.span,\n-                        hir::ExprAssign(next_expr, val_expr),\n+                        hir::ExprKind::Assign(next_expr, val_expr),\n                         ThinVec::new(),\n                     ));\n                     let some_pat = self.pat_some(pat.span, val_pat);\n@@ -4053,11 +4055,18 @@ impl<'a> LoweringContext<'a> {\n \n                     P(self.expr(\n                         head_sp,\n-                        hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n+                        hir::ExprKind::Match(\n+                            next_expr,\n+                            arms,\n+                            hir::MatchSource::ForLoopDesugar\n+                        ),\n                         ThinVec::new(),\n                     ))\n                 };\n-                let match_stmt = respan(head_sp, hir::StmtExpr(match_expr, self.next_id().node_id));\n+                let match_stmt = respan(\n+                    head_sp,\n+                    hir::StmtKind::Expr(match_expr, self.next_id().node_id)\n+                );\n \n                 let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat.id));\n \n@@ -4076,7 +4085,10 @@ impl<'a> LoweringContext<'a> {\n \n                 let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n                 let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n-                let body_stmt = respan(body.span, hir::StmtExpr(body_expr, self.next_id().node_id));\n+                let body_stmt = respan(\n+                    body.span,\n+                    hir::StmtKind::Expr(body_expr, self.next_id().node_id)\n+                );\n \n                 let loop_block = P(self.block_all(\n                     e.span,\n@@ -4085,7 +4097,7 @@ impl<'a> LoweringContext<'a> {\n                 ));\n \n                 // `[opt_ident]: loop { ... }`\n-                let loop_expr = hir::ExprLoop(\n+                let loop_expr = hir::ExprKind::Loop(\n                     loop_block,\n                     self.lower_label(opt_label),\n                     hir::LoopSource::ForLoop,\n@@ -4205,7 +4217,7 @@ impl<'a> LoweringContext<'a> {\n                     let ret_expr = if let Some(catch_node) = catch_scope {\n                         P(self.expr(\n                             e.span,\n-                            hir::ExprBreak(\n+                            hir::ExprKind::Break(\n                                 hir::Destination {\n                                     label: None,\n                                     target_id: Ok(catch_node),\n@@ -4215,14 +4227,14 @@ impl<'a> LoweringContext<'a> {\n                             thin_attrs,\n                         ))\n                     } else {\n-                        P(self.expr(e.span, hir::Expr_::ExprRet(Some(from_err_expr)), thin_attrs))\n+                        P(self.expr(e.span, hir::ExprKind::Ret(Some(from_err_expr)), thin_attrs))\n                     };\n \n                     let err_pat = self.pat_err(e.span, err_local);\n                     self.arm(hir_vec![err_pat], ret_expr)\n                 };\n \n-                hir::ExprMatch(\n+                hir::ExprKind::Match(\n                     discr,\n                     hir_vec![err_arm, ok_arm],\n                     hir::MatchSource::TryDesugar,\n@@ -4246,9 +4258,9 @@ impl<'a> LoweringContext<'a> {\n     fn lower_stmt(&mut self, s: &Stmt) -> SmallVector<hir::Stmt> {\n         SmallVector::one(match s.node {\n             StmtKind::Local(ref l) => Spanned {\n-                node: hir::StmtDecl(\n+                node: hir::StmtKind::Decl(\n                     P(Spanned {\n-                        node: hir::DeclLocal(self.lower_local(l)),\n+                        node: hir::DeclKind::Local(self.lower_local(l)),\n                         span: s.span,\n                     }),\n                     self.lower_node_id(s.id).node_id,\n@@ -4261,9 +4273,9 @@ impl<'a> LoweringContext<'a> {\n                 return self.lower_item_id(it)\n                     .into_iter()\n                     .map(|item_id| Spanned {\n-                        node: hir::StmtDecl(\n+                        node: hir::StmtKind::Decl(\n                             P(Spanned {\n-                                node: hir::DeclItem(item_id),\n+                                node: hir::DeclKind::Item(item_id),\n                                 span: s.span,\n                             }),\n                             id.take()\n@@ -4275,11 +4287,11 @@ impl<'a> LoweringContext<'a> {\n                     .collect();\n             }\n             StmtKind::Expr(ref e) => Spanned {\n-                node: hir::StmtExpr(P(self.lower_expr(e)), self.lower_node_id(s.id).node_id),\n+                node: hir::StmtKind::Expr(P(self.lower_expr(e)), self.lower_node_id(s.id).node_id),\n                 span: s.span,\n             },\n             StmtKind::Semi(ref e) => Spanned {\n-                node: hir::StmtSemi(P(self.lower_expr(e)), self.lower_node_id(s.id).node_id),\n+                node: hir::StmtKind::Semi(P(self.lower_expr(e)), self.lower_node_id(s.id).node_id),\n                 span: s.span,\n             },\n             StmtKind::Mac(..) => panic!(\"Shouldn't exist here\"),\n@@ -4390,7 +4402,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        let expr_break = hir::ExprBreak(self.lower_loop_destination(None), None);\n+        let expr_break = hir::ExprKind::Break(self.lower_loop_destination(None), None);\n         P(self.expr(span, expr_break, attrs))\n     }\n \n@@ -4400,7 +4412,7 @@ impl<'a> LoweringContext<'a> {\n         e: P<hir::Expr>,\n         args: hir::HirVec<hir::Expr>,\n     ) -> hir::Expr {\n-        self.expr(span, hir::ExprCall(e, args), ThinVec::new())\n+        self.expr(span, hir::ExprKind::Call(e, args), ThinVec::new())\n     }\n \n     fn expr_ident(&mut self, span: Span, ident: Ident, binding: NodeId) -> hir::Expr {\n@@ -4414,7 +4426,7 @@ impl<'a> LoweringContext<'a> {\n         binding: NodeId,\n         attrs: ThinVec<Attribute>,\n     ) -> hir::Expr {\n-        let expr_path = hir::ExprPath(hir::QPath::Resolved(\n+        let expr_path = hir::ExprKind::Path(hir::QPath::Resolved(\n             None,\n             P(hir::Path {\n                 span,\n@@ -4427,7 +4439,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n-        self.expr(span, hir::ExprAddrOf(hir::MutMutable, e), ThinVec::new())\n+        self.expr(span, hir::ExprKind::AddrOf(hir::MutMutable, e), ThinVec::new())\n     }\n \n     fn expr_std_path(\n@@ -4440,7 +4452,7 @@ impl<'a> LoweringContext<'a> {\n         let path = self.std_path(span, components, params, true);\n         self.expr(\n             span,\n-            hir::ExprPath(hir::QPath::Resolved(None, P(path))),\n+            hir::ExprKind::Path(hir::QPath::Resolved(None, P(path))),\n             attrs,\n         )\n     }\n@@ -4452,18 +4464,18 @@ impl<'a> LoweringContext<'a> {\n         arms: hir::HirVec<hir::Arm>,\n         source: hir::MatchSource,\n     ) -> hir::Expr {\n-        self.expr(span, hir::ExprMatch(arg, arms, source), ThinVec::new())\n+        self.expr(span, hir::ExprKind::Match(arg, arms, source), ThinVec::new())\n     }\n \n     fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinVec<Attribute>) -> hir::Expr {\n-        self.expr(b.span, hir::ExprBlock(b, None), attrs)\n+        self.expr(b.span, hir::ExprKind::Block(b, None), attrs)\n     }\n \n     fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<hir::Expr>) -> P<hir::Expr> {\n-        P(self.expr(sp, hir::ExprTup(exprs), ThinVec::new()))\n+        P(self.expr(sp, hir::ExprKind::Tup(exprs), ThinVec::new()))\n     }\n \n-    fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> hir::Expr {\n+    fn expr(&mut self, span: Span, node: hir::ExprKind, attrs: ThinVec<Attribute>) -> hir::Expr {\n         let LoweredNodeId { node_id, hir_id } = self.next_id();\n         hir::Expr {\n             id: node_id,\n@@ -4493,8 +4505,8 @@ impl<'a> LoweringContext<'a> {\n             attrs: ThinVec::new(),\n             source,\n         });\n-        let decl = respan(sp, hir::DeclLocal(local));\n-        respan(sp, hir::StmtDecl(P(decl), self.next_id().node_id))\n+        let decl = respan(sp, hir::DeclKind::Local(local));\n+        respan(sp, hir::StmtKind::Decl(P(decl), self.next_id().node_id))\n     }\n \n     fn stmt_let(\n@@ -4624,7 +4636,7 @@ impl<'a> LoweringContext<'a> {\n         let mut id = id;\n         let node = match qpath {\n             hir::QPath::Resolved(None, path) => {\n-                // Turn trait object paths into `TyTraitObject` instead.\n+                // Turn trait object paths into `TyKind::TraitObject` instead.\n                 if let Def::Trait(_) = path.def {\n                     let principal = hir::PolyTraitRef {\n                         bound_generic_params: hir::HirVec::new(),\n@@ -4638,12 +4650,12 @@ impl<'a> LoweringContext<'a> {\n                     // The original ID is taken by the `PolyTraitRef`,\n                     // so the `Ty` itself needs a different one.\n                     id = self.next_id();\n-                    hir::TyTraitObject(hir_vec![principal], self.elided_dyn_bound(span))\n+                    hir::TyKind::TraitObject(hir_vec![principal], self.elided_dyn_bound(span))\n                 } else {\n-                    hir::TyPath(hir::QPath::Resolved(None, path))\n+                    hir::TyKind::Path(hir::QPath::Resolved(None, path))\n                 }\n             }\n-            _ => hir::TyPath(qpath),\n+            _ => hir::TyKind::Path(qpath),\n         };\n         hir::Ty {\n             id: id.node_id,"}, {"sha": "5a595d14db7aa5970452c520221835f7cbd38a46", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -34,7 +34,7 @@ use syntax_pos::Span;\n /// More specifically, it is one of either:\n ///\n ///   - A function item,\n-///   - A closure expr (i.e. an ExprClosure), or\n+///   - A closure expr (i.e. an ExprKind::Closure), or\n ///   - The default implementation for a trait method.\n ///\n /// To construct one, use the `Code::from_node` function.\n@@ -47,7 +47,7 @@ pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n \n impl MaybeFnLike for ast::Item {\n     fn is_fn_like(&self) -> bool {\n-        match self.node { ast::ItemFn(..) => true, _ => false, }\n+        match self.node { ast::ItemKind::Fn(..) => true, _ => false, }\n     }\n }\n \n@@ -63,7 +63,7 @@ impl MaybeFnLike for ast::TraitItem {\n impl MaybeFnLike for ast::Expr {\n     fn is_fn_like(&self) -> bool {\n         match self.node {\n-            ast::ExprClosure(..) => true,\n+            ast::ExprKind::Closure(..) => true,\n             _ => false,\n         }\n     }\n@@ -229,7 +229,7 @@ impl<'a> FnLikeNode<'a> {\n     {\n         match self.node {\n             map::NodeItem(i) => match i.node {\n-                ast::ItemFn(ref decl, header, ref generics, block) =>\n+                ast::ItemKind::Fn(ref decl, header, ref generics, block) =>\n                     item_fn(ItemFnParts {\n                         id: i.id,\n                         name: i.name,\n@@ -260,7 +260,7 @@ impl<'a> FnLikeNode<'a> {\n                 }\n             },\n             map::NodeExpr(e) => match e.node {\n-                ast::ExprClosure(_, ref decl, block, _fn_decl_span, _gen) =>\n+                ast::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) =>\n                     closure(ClosureParts::new(&decl, block, e.id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },"}, {"sha": "0150ba659c900dcb8ea2a32e05d82926c5f04567", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -329,7 +329,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n             this.insert(i.id, NodeItem(i));\n             this.with_parent(i.id, |this| {\n                 match i.node {\n-                    ItemStruct(ref struct_def, _) => {\n+                    ItemKind::Struct(ref struct_def, _) => {\n                         // If this is a tuple-like struct, register the constructor.\n                         if !struct_def.is_struct() {\n                             this.insert(struct_def.id(), NodeStructCtor(struct_def));"}, {"sha": "656f325b4dd89e4fc5616b55869fe74425869f65", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -179,7 +179,7 @@ impl<'a, 'hir: 'a> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n \n     fn visit_impl_item_ref(&mut self, _: &'hir hir::ImplItemRef) {\n         // Explicitly do nothing here. ImplItemRefs contain hir::Visibility\n-        // values that actually belong to an ImplItem instead of the ItemImpl\n+        // values that actually belong to an ImplItem instead of the ItemKind::Impl\n         // we are currently in. So for those it's correct that they have a\n         // different owner.\n     }"}, {"sha": "d413a544c4e410e5e535bc7808808eb23491e33e", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 62, "deletions": 61, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -33,6 +33,7 @@ use hir::svh::Svh;\n use util::nodemap::FxHashMap;\n \n use std::io;\n+use std::result::Result::Err;\n use ty::TyCtxt;\n \n pub mod blocks;\n@@ -174,7 +175,7 @@ impl<'hir> MapEntry<'hir> {\n         match self {\n             EntryItem(_, _, ref item) => {\n                 match item.node {\n-                    ItemFn(ref fn_decl, _, _, _) => Some(&fn_decl),\n+                    ItemKind::Fn(ref fn_decl, _, _, _) => Some(&fn_decl),\n                     _ => None,\n                 }\n             }\n@@ -195,7 +196,7 @@ impl<'hir> MapEntry<'hir> {\n \n             EntryExpr(_, _, ref expr) => {\n                 match expr.node {\n-                    ExprClosure(_, ref fn_decl, ..) => Some(&fn_decl),\n+                    ExprKind::Closure(_, ref fn_decl, ..) => Some(&fn_decl),\n                     _ => None,\n                 }\n             }\n@@ -208,9 +209,9 @@ impl<'hir> MapEntry<'hir> {\n         match self {\n             EntryItem(_, _, item) => {\n                 match item.node {\n-                    ItemConst(_, body) |\n-                    ItemStatic(.., body) |\n-                    ItemFn(_, _, _, body) => Some(body),\n+                    ItemKind::Const(_, body) |\n+                    ItemKind::Static(.., body) |\n+                    ItemKind::Fn(_, _, _, body) => Some(body),\n                     _ => None,\n                 }\n             }\n@@ -235,7 +236,7 @@ impl<'hir> MapEntry<'hir> {\n \n             EntryExpr(_, _, expr) => {\n                 match expr.node {\n-                    ExprClosure(.., body, _, _) => Some(body),\n+                    ExprKind::Closure(.., body, _, _) => Some(body),\n                     _ => None,\n                 }\n             }\n@@ -426,33 +427,33 @@ impl<'hir> Map<'hir> {\n                 };\n \n                 match item.node {\n-                    ItemStatic(_, m, _) => Some(Def::Static(def_id(),\n+                    ItemKind::Static(_, m, _) => Some(Def::Static(def_id(),\n                                                             m == MutMutable)),\n-                    ItemConst(..) => Some(Def::Const(def_id())),\n-                    ItemFn(..) => Some(Def::Fn(def_id())),\n-                    ItemMod(..) => Some(Def::Mod(def_id())),\n-                    ItemGlobalAsm(..) => Some(Def::GlobalAsm(def_id())),\n-                    ItemExistential(..) => Some(Def::Existential(def_id())),\n-                    ItemTy(..) => Some(Def::TyAlias(def_id())),\n-                    ItemEnum(..) => Some(Def::Enum(def_id())),\n-                    ItemStruct(..) => Some(Def::Struct(def_id())),\n-                    ItemUnion(..) => Some(Def::Union(def_id())),\n-                    ItemTrait(..) => Some(Def::Trait(def_id())),\n-                    ItemTraitAlias(..) => {\n+                    ItemKind::Const(..) => Some(Def::Const(def_id())),\n+                    ItemKind::Fn(..) => Some(Def::Fn(def_id())),\n+                    ItemKind::Mod(..) => Some(Def::Mod(def_id())),\n+                    ItemKind::GlobalAsm(..) => Some(Def::GlobalAsm(def_id())),\n+                    ItemKind::Existential(..) => Some(Def::Existential(def_id())),\n+                    ItemKind::Ty(..) => Some(Def::TyAlias(def_id())),\n+                    ItemKind::Enum(..) => Some(Def::Enum(def_id())),\n+                    ItemKind::Struct(..) => Some(Def::Struct(def_id())),\n+                    ItemKind::Union(..) => Some(Def::Union(def_id())),\n+                    ItemKind::Trait(..) => Some(Def::Trait(def_id())),\n+                    ItemKind::TraitAlias(..) => {\n                         bug!(\"trait aliases are not yet implemented (see issue #41517)\")\n                     },\n-                    ItemExternCrate(_) |\n-                    ItemUse(..) |\n-                    ItemForeignMod(..) |\n-                    ItemImpl(..) => None,\n+                    ItemKind::ExternCrate(_) |\n+                    ItemKind::Use(..) |\n+                    ItemKind::ForeignMod(..) |\n+                    ItemKind::Impl(..) => None,\n                 }\n             }\n             NodeForeignItem(item) => {\n                 let def_id = self.local_def_id(item.id);\n                 match item.node {\n-                    ForeignItemFn(..) => Some(Def::Fn(def_id)),\n-                    ForeignItemStatic(_, m) => Some(Def::Static(def_id, m)),\n-                    ForeignItemType => Some(Def::TyForeign(def_id)),\n+                    ForeignItemKind::Fn(..) => Some(Def::Fn(def_id)),\n+                    ForeignItemKind::Static(_, m) => Some(Def::Static(def_id, m)),\n+                    ForeignItemKind::Type => Some(Def::TyForeign(def_id)),\n                 }\n             }\n             NodeTraitItem(item) => {\n@@ -586,13 +587,13 @@ impl<'hir> Map<'hir> {\n \n     pub fn body_owner_kind(&self, id: NodeId) -> BodyOwnerKind {\n         match self.get(id) {\n-            NodeItem(&Item { node: ItemConst(..), .. }) |\n+            NodeItem(&Item { node: ItemKind::Const(..), .. }) |\n             NodeTraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n             NodeImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) |\n             NodeAnonConst(_) => {\n                 BodyOwnerKind::Const\n             }\n-            NodeItem(&Item { node: ItemStatic(_, m, _), .. }) => {\n+            NodeItem(&Item { node: ItemKind::Static(_, m, _), .. }) => {\n                 BodyOwnerKind::Static(m)\n             }\n             // Default to function if it's not a constant or static.\n@@ -602,7 +603,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n         match self.get(id) {\n-            NodeItem(&Item { node: ItemTrait(..), .. }) => id,\n+            NodeItem(&Item { node: ItemKind::Trait(..), .. }) => id,\n             NodeGenericParam(_) => self.get_parent_node(id),\n             _ => {\n                 bug!(\"ty_param_owner: {} not a type parameter\",\n@@ -613,7 +614,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n-            NodeItem(&Item { node: ItemTrait(..), .. }) => {\n+            NodeItem(&Item { node: ItemKind::Trait(..), .. }) => {\n                 keywords::SelfType.name()\n             }\n             NodeGenericParam(param) => param.name.ident().name,\n@@ -671,14 +672,14 @@ impl<'hir> Map<'hir> {\n                 NodeTraitItem(ref trait_item) => Some(&trait_item.generics),\n                 NodeItem(ref item) => {\n                     match item.node {\n-                        ItemFn(_, _, ref generics, _) |\n-                        ItemTy(_, ref generics) |\n-                        ItemEnum(_, ref generics) |\n-                        ItemStruct(_, ref generics) |\n-                        ItemUnion(_, ref generics) |\n-                        ItemTrait(_, _, ref generics, ..) |\n-                        ItemTraitAlias(ref generics, _) |\n-                        ItemImpl(_, _, _, ref generics, ..) => Some(generics),\n+                        ItemKind::Fn(_, _, ref generics, _) |\n+                        ItemKind::Ty(_, ref generics) |\n+                        ItemKind::Enum(_, ref generics) |\n+                        ItemKind::Struct(_, ref generics) |\n+                        ItemKind::Union(_, ref generics) |\n+                        ItemKind::Trait(_, _, ref generics, ..) |\n+                        ItemKind::TraitAlias(ref generics, _) |\n+                        ItemKind::Impl(_, _, _, ref generics, ..) => Some(generics),\n                         _ => None,\n                     }\n                 }\n@@ -734,7 +735,7 @@ impl<'hir> Map<'hir> {\n             Some(NodeImplItem(_)) => true,\n             Some(NodeExpr(e)) => {\n                 match e.node {\n-                    ExprClosure(..) => true,\n+                    ExprKind::Closure(..) => true,\n                     _ => false,\n                 }\n             }\n@@ -821,7 +822,7 @@ impl<'hir> Map<'hir> {\n             match *node {\n                 NodeExpr(ref expr) => {\n                     match expr.node {\n-                        ExprWhile(..) | ExprLoop(..) => true,\n+                        ExprKind::While(..) | ExprKind::Loop(..) => true,\n                         _ => false,\n                     }\n                 }\n@@ -856,7 +857,7 @@ impl<'hir> Map<'hir> {\n     /// module parent is in this map.\n     pub fn get_module_parent(&self, id: NodeId) -> DefId {\n         let id = match self.walk_parent_nodes(id, |node| match *node {\n-            NodeItem(&Item { node: Item_::ItemMod(_), .. }) => true,\n+            NodeItem(&Item { node: ItemKind::Mod(_), .. }) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => id,\n@@ -892,7 +893,7 @@ impl<'hir> Map<'hir> {\n         let abi = match self.find_entry(parent) {\n             Some(EntryItem(_, _, i)) => {\n                 match i.node {\n-                    ItemForeignMod(ref nm) => Some(nm.abi),\n+                    ItemKind::ForeignMod(ref nm) => Some(nm.abi),\n                     _ => None\n                 }\n             }\n@@ -933,8 +934,8 @@ impl<'hir> Map<'hir> {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n                 match i.node {\n-                    ItemStruct(ref struct_def, _) |\n-                    ItemUnion(ref struct_def, _) => struct_def,\n+                    ItemKind::Struct(ref struct_def, _) |\n+                    ItemKind::Union(ref struct_def, _) => struct_def,\n                     _ => {\n                         bug!(\"struct ID bound to non-struct {}\",\n                              self.node_to_string(id));\n@@ -1128,7 +1129,7 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n \n             fn item_is_mod(item: &Item) -> bool {\n                 match item.node {\n-                    ItemMod(_) => true,\n+                    ItemKind::Mod(_) => true,\n                     _ => false,\n                 }\n             }\n@@ -1176,7 +1177,7 @@ impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() }\n \n impl Named for Item { fn name(&self) -> Name { self.name } }\n impl Named for ForeignItem { fn name(&self) -> Name { self.name } }\n-impl Named for Variant_ { fn name(&self) -> Name { self.name } }\n+impl Named for VariantKind { fn name(&self) -> Name { self.name } }\n impl Named for StructField { fn name(&self) -> Name { self.ident.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n@@ -1313,22 +1314,22 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n     match map.find(id) {\n         Some(NodeItem(item)) => {\n             let item_str = match item.node {\n-                ItemExternCrate(..) => \"extern crate\",\n-                ItemUse(..) => \"use\",\n-                ItemStatic(..) => \"static\",\n-                ItemConst(..) => \"const\",\n-                ItemFn(..) => \"fn\",\n-                ItemMod(..) => \"mod\",\n-                ItemForeignMod(..) => \"foreign mod\",\n-                ItemGlobalAsm(..) => \"global asm\",\n-                ItemTy(..) => \"ty\",\n-                ItemExistential(..) => \"existential\",\n-                ItemEnum(..) => \"enum\",\n-                ItemStruct(..) => \"struct\",\n-                ItemUnion(..) => \"union\",\n-                ItemTrait(..) => \"trait\",\n-                ItemTraitAlias(..) => \"trait alias\",\n-                ItemImpl(..) => \"impl\",\n+                ItemKind::ExternCrate(..) => \"extern crate\",\n+                ItemKind::Use(..) => \"use\",\n+                ItemKind::Static(..) => \"static\",\n+                ItemKind::Const(..) => \"const\",\n+                ItemKind::Fn(..) => \"fn\",\n+                ItemKind::Mod(..) => \"mod\",\n+                ItemKind::ForeignMod(..) => \"foreign mod\",\n+                ItemKind::GlobalAsm(..) => \"global asm\",\n+                ItemKind::Ty(..) => \"ty\",\n+                ItemKind::Existential(..) => \"existential\",\n+                ItemKind::Enum(..) => \"enum\",\n+                ItemKind::Struct(..) => \"struct\",\n+                ItemKind::Union(..) => \"union\",\n+                ItemKind::Trait(..) => \"trait\",\n+                ItemKind::TraitAlias(..) => \"trait alias\",\n+                ItemKind::Impl(..) => \"impl\",\n             };\n             format!(\"{} {}{}\", item_str, path_str(), id_str)\n         }"}, {"sha": "c1a885d80bf8b0e1f11c9ad3ab6e1ca8b2af503f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 239, "deletions": 241, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,18 +10,11 @@\n \n // The Rust HIR.\n \n-pub use self::BinOp_::*;\n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n-pub use self::Decl_::*;\n-pub use self::Expr_::*;\n pub use self::FunctionRetTy::*;\n-pub use self::ForeignItem_::*;\n-pub use self::Item_::*;\n pub use self::Mutability::*;\n pub use self::PrimTy::*;\n-pub use self::Stmt_::*;\n-pub use self::Ty_::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n \n@@ -443,7 +436,7 @@ impl GenericArgs {\n                 match arg {\n                     GenericArg::Lifetime(_) => {}\n                     GenericArg::Type(ref ty) => {\n-                        if let TyTup(ref tys) = ty.node {\n+                        if let TyKind::Tup(ref tys) = ty.node {\n                             return tys;\n                         }\n                         break;\n@@ -941,98 +934,103 @@ impl Mutability {\n }\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash)]\n-pub enum BinOp_ {\n+pub enum BinOpKind {\n     /// The `+` operator (addition)\n-    BiAdd,\n+    Add,\n     /// The `-` operator (subtraction)\n-    BiSub,\n+    Sub,\n     /// The `*` operator (multiplication)\n-    BiMul,\n+    Mul,\n     /// The `/` operator (division)\n-    BiDiv,\n+    Div,\n     /// The `%` operator (modulus)\n-    BiRem,\n+    Rem,\n     /// The `&&` operator (logical and)\n-    BiAnd,\n+    And,\n     /// The `||` operator (logical or)\n-    BiOr,\n+    Or,\n     /// The `^` operator (bitwise xor)\n-    BiBitXor,\n+    BitXor,\n     /// The `&` operator (bitwise and)\n-    BiBitAnd,\n+    BitAnd,\n     /// The `|` operator (bitwise or)\n-    BiBitOr,\n+    BitOr,\n     /// The `<<` operator (shift left)\n-    BiShl,\n+    Shl,\n     /// The `>>` operator (shift right)\n-    BiShr,\n+    Shr,\n     /// The `==` operator (equality)\n-    BiEq,\n+    Eq,\n     /// The `<` operator (less than)\n-    BiLt,\n+    Lt,\n     /// The `<=` operator (less than or equal to)\n-    BiLe,\n+    Le,\n     /// The `!=` operator (not equal to)\n-    BiNe,\n+    Ne,\n     /// The `>=` operator (greater than or equal to)\n-    BiGe,\n+    Ge,\n     /// The `>` operator (greater than)\n-    BiGt,\n+    Gt,\n }\n \n-impl BinOp_ {\n+impl BinOpKind {\n     pub fn as_str(self) -> &'static str {\n         match self {\n-            BiAdd => \"+\",\n-            BiSub => \"-\",\n-            BiMul => \"*\",\n-            BiDiv => \"/\",\n-            BiRem => \"%\",\n-            BiAnd => \"&&\",\n-            BiOr => \"||\",\n-            BiBitXor => \"^\",\n-            BiBitAnd => \"&\",\n-            BiBitOr => \"|\",\n-            BiShl => \"<<\",\n-            BiShr => \">>\",\n-            BiEq => \"==\",\n-            BiLt => \"<\",\n-            BiLe => \"<=\",\n-            BiNe => \"!=\",\n-            BiGe => \">=\",\n-            BiGt => \">\",\n+            BinOpKind::Add => \"+\",\n+            BinOpKind::Sub => \"-\",\n+            BinOpKind::Mul => \"*\",\n+            BinOpKind::Div => \"/\",\n+            BinOpKind::Rem => \"%\",\n+            BinOpKind::And => \"&&\",\n+            BinOpKind::Or => \"||\",\n+            BinOpKind::BitXor => \"^\",\n+            BinOpKind::BitAnd => \"&\",\n+            BinOpKind::BitOr => \"|\",\n+            BinOpKind::Shl => \"<<\",\n+            BinOpKind::Shr => \">>\",\n+            BinOpKind::Eq => \"==\",\n+            BinOpKind::Lt => \"<\",\n+            BinOpKind::Le => \"<=\",\n+            BinOpKind::Ne => \"!=\",\n+            BinOpKind::Ge => \">=\",\n+            BinOpKind::Gt => \">\",\n         }\n     }\n \n     pub fn is_lazy(self) -> bool {\n         match self {\n-            BiAnd | BiOr => true,\n+            BinOpKind::And | BinOpKind::Or => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_shift(self) -> bool {\n         match self {\n-            BiShl | BiShr => true,\n+            BinOpKind::Shl | BinOpKind::Shr => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_comparison(self) -> bool {\n         match self {\n-            BiEq | BiLt | BiLe | BiNe | BiGt | BiGe => true,\n-            BiAnd |\n-            BiOr |\n-            BiAdd |\n-            BiSub |\n-            BiMul |\n-            BiDiv |\n-            BiRem |\n-            BiBitXor |\n-            BiBitAnd |\n-            BiBitOr |\n-            BiShl |\n-            BiShr => false,\n+            BinOpKind::Eq |\n+            BinOpKind::Lt |\n+            BinOpKind::Le |\n+            BinOpKind::Ne |\n+            BinOpKind::Gt |\n+            BinOpKind::Ge => true,\n+            BinOpKind::And |\n+            BinOpKind::Or |\n+            BinOpKind::Add |\n+            BinOpKind::Sub |\n+            BinOpKind::Mul |\n+            BinOpKind::Div |\n+            BinOpKind::Rem |\n+            BinOpKind::BitXor |\n+            BinOpKind::BitAnd |\n+            BinOpKind::BitOr |\n+            BinOpKind::Shl |\n+            BinOpKind::Shr => false,\n         }\n     }\n \n@@ -1042,32 +1040,32 @@ impl BinOp_ {\n     }\n }\n \n-impl Into<ast::BinOpKind> for BinOp_ {\n+impl Into<ast::BinOpKind> for BinOpKind {\n     fn into(self) -> ast::BinOpKind {\n         match self {\n-            BiAdd => ast::BinOpKind::Add,\n-            BiSub => ast::BinOpKind::Sub,\n-            BiMul => ast::BinOpKind::Mul,\n-            BiDiv => ast::BinOpKind::Div,\n-            BiRem => ast::BinOpKind::Rem,\n-            BiAnd => ast::BinOpKind::And,\n-            BiOr => ast::BinOpKind::Or,\n-            BiBitXor => ast::BinOpKind::BitXor,\n-            BiBitAnd => ast::BinOpKind::BitAnd,\n-            BiBitOr => ast::BinOpKind::BitOr,\n-            BiShl => ast::BinOpKind::Shl,\n-            BiShr => ast::BinOpKind::Shr,\n-            BiEq => ast::BinOpKind::Eq,\n-            BiLt => ast::BinOpKind::Lt,\n-            BiLe => ast::BinOpKind::Le,\n-            BiNe => ast::BinOpKind::Ne,\n-            BiGe => ast::BinOpKind::Ge,\n-            BiGt => ast::BinOpKind::Gt,\n+            BinOpKind::Add => ast::BinOpKind::Add,\n+            BinOpKind::Sub => ast::BinOpKind::Sub,\n+            BinOpKind::Mul => ast::BinOpKind::Mul,\n+            BinOpKind::Div => ast::BinOpKind::Div,\n+            BinOpKind::Rem => ast::BinOpKind::Rem,\n+            BinOpKind::And => ast::BinOpKind::And,\n+            BinOpKind::Or => ast::BinOpKind::Or,\n+            BinOpKind::BitXor => ast::BinOpKind::BitXor,\n+            BinOpKind::BitAnd => ast::BinOpKind::BitAnd,\n+            BinOpKind::BitOr => ast::BinOpKind::BitOr,\n+            BinOpKind::Shl => ast::BinOpKind::Shl,\n+            BinOpKind::Shr => ast::BinOpKind::Shr,\n+            BinOpKind::Eq => ast::BinOpKind::Eq,\n+            BinOpKind::Lt => ast::BinOpKind::Lt,\n+            BinOpKind::Le => ast::BinOpKind::Le,\n+            BinOpKind::Ne => ast::BinOpKind::Ne,\n+            BinOpKind::Ge => ast::BinOpKind::Ge,\n+            BinOpKind::Gt => ast::BinOpKind::Gt,\n         }\n     }\n }\n \n-pub type BinOp = Spanned<BinOp_>;\n+pub type BinOp = Spanned<BinOpKind>;\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash)]\n pub enum UnOp {\n@@ -1098,9 +1096,9 @@ impl UnOp {\n }\n \n /// A statement\n-pub type Stmt = Spanned<Stmt_>;\n+pub type Stmt = Spanned<StmtKind>;\n \n-impl fmt::Debug for Stmt_ {\n+impl fmt::Debug for StmtKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Sadness.\n         let spanned = codemap::dummy_spanned(self.clone());\n@@ -1112,31 +1110,31 @@ impl fmt::Debug for Stmt_ {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub enum Stmt_ {\n+pub enum StmtKind {\n     /// Could be an item or a local (let) binding:\n-    StmtDecl(P<Decl>, NodeId),\n+    Decl(P<Decl>, NodeId),\n \n     /// Expr without trailing semi-colon (must have unit type):\n-    StmtExpr(P<Expr>, NodeId),\n+    Expr(P<Expr>, NodeId),\n \n     /// Expr with trailing semi-colon (may have any type):\n-    StmtSemi(P<Expr>, NodeId),\n+    Semi(P<Expr>, NodeId),\n }\n \n-impl Stmt_ {\n+impl StmtKind {\n     pub fn attrs(&self) -> &[Attribute] {\n         match *self {\n-            StmtDecl(ref d, _) => d.node.attrs(),\n-            StmtExpr(ref e, _) |\n-            StmtSemi(ref e, _) => &e.attrs,\n+            StmtKind::Decl(ref d, _) => d.node.attrs(),\n+            StmtKind::Expr(ref e, _) |\n+            StmtKind::Semi(ref e, _) => &e.attrs,\n         }\n     }\n \n     pub fn id(&self) -> NodeId {\n         match *self {\n-            StmtDecl(_, id) => id,\n-            StmtExpr(_, id) => id,\n-            StmtSemi(_, id) => id,\n+            StmtKind::Decl(_, id) => id,\n+            StmtKind::Expr(_, id) => id,\n+            StmtKind::Semi(_, id) => id,\n         }\n     }\n }\n@@ -1155,27 +1153,27 @@ pub struct Local {\n     pub source: LocalSource,\n }\n \n-pub type Decl = Spanned<Decl_>;\n+pub type Decl = Spanned<DeclKind>;\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum Decl_ {\n+pub enum DeclKind {\n     /// A local (let) binding:\n-    DeclLocal(P<Local>),\n+    Local(P<Local>),\n     /// An item binding:\n-    DeclItem(ItemId),\n+    Item(ItemId),\n }\n \n-impl Decl_ {\n+impl DeclKind {\n     pub fn attrs(&self) -> &[Attribute] {\n         match *self {\n-            DeclLocal(ref l) => &l.attrs,\n-            DeclItem(_) => &[]\n+            DeclKind::Local(ref l) => &l.attrs,\n+            DeclKind::Item(_) => &[]\n         }\n     }\n \n     pub fn is_local(&self) -> bool {\n         match *self {\n-            Decl_::DeclLocal(_) => true,\n+            DeclKind::Local(_) => true,\n             _ => false,\n         }\n     }\n@@ -1283,42 +1281,42 @@ pub struct AnonConst {\n pub struct Expr {\n     pub id: NodeId,\n     pub span: Span,\n-    pub node: Expr_,\n+    pub node: ExprKind,\n     pub attrs: ThinVec<Attribute>,\n     pub hir_id: HirId,\n }\n \n impl Expr {\n     pub fn precedence(&self) -> ExprPrecedence {\n         match self.node {\n-            ExprBox(_) => ExprPrecedence::Box,\n-            ExprArray(_) => ExprPrecedence::Array,\n-            ExprCall(..) => ExprPrecedence::Call,\n-            ExprMethodCall(..) => ExprPrecedence::MethodCall,\n-            ExprTup(_) => ExprPrecedence::Tup,\n-            ExprBinary(op, ..) => ExprPrecedence::Binary(op.node.into()),\n-            ExprUnary(..) => ExprPrecedence::Unary,\n-            ExprLit(_) => ExprPrecedence::Lit,\n-            ExprType(..) | ExprCast(..) => ExprPrecedence::Cast,\n-            ExprIf(..) => ExprPrecedence::If,\n-            ExprWhile(..) => ExprPrecedence::While,\n-            ExprLoop(..) => ExprPrecedence::Loop,\n-            ExprMatch(..) => ExprPrecedence::Match,\n-            ExprClosure(..) => ExprPrecedence::Closure,\n-            ExprBlock(..) => ExprPrecedence::Block,\n-            ExprAssign(..) => ExprPrecedence::Assign,\n-            ExprAssignOp(..) => ExprPrecedence::AssignOp,\n-            ExprField(..) => ExprPrecedence::Field,\n-            ExprIndex(..) => ExprPrecedence::Index,\n-            ExprPath(..) => ExprPrecedence::Path,\n-            ExprAddrOf(..) => ExprPrecedence::AddrOf,\n-            ExprBreak(..) => ExprPrecedence::Break,\n-            ExprContinue(..) => ExprPrecedence::Continue,\n-            ExprRet(..) => ExprPrecedence::Ret,\n-            ExprInlineAsm(..) => ExprPrecedence::InlineAsm,\n-            ExprStruct(..) => ExprPrecedence::Struct,\n-            ExprRepeat(..) => ExprPrecedence::Repeat,\n-            ExprYield(..) => ExprPrecedence::Yield,\n+            ExprKind::Box(_) => ExprPrecedence::Box,\n+            ExprKind::Array(_) => ExprPrecedence::Array,\n+            ExprKind::Call(..) => ExprPrecedence::Call,\n+            ExprKind::MethodCall(..) => ExprPrecedence::MethodCall,\n+            ExprKind::Tup(_) => ExprPrecedence::Tup,\n+            ExprKind::Binary(op, ..) => ExprPrecedence::Binary(op.node.into()),\n+            ExprKind::Unary(..) => ExprPrecedence::Unary,\n+            ExprKind::Lit(_) => ExprPrecedence::Lit,\n+            ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n+            ExprKind::If(..) => ExprPrecedence::If,\n+            ExprKind::While(..) => ExprPrecedence::While,\n+            ExprKind::Loop(..) => ExprPrecedence::Loop,\n+            ExprKind::Match(..) => ExprPrecedence::Match,\n+            ExprKind::Closure(..) => ExprPrecedence::Closure,\n+            ExprKind::Block(..) => ExprPrecedence::Block,\n+            ExprKind::Assign(..) => ExprPrecedence::Assign,\n+            ExprKind::AssignOp(..) => ExprPrecedence::AssignOp,\n+            ExprKind::Field(..) => ExprPrecedence::Field,\n+            ExprKind::Index(..) => ExprPrecedence::Index,\n+            ExprKind::Path(..) => ExprPrecedence::Path,\n+            ExprKind::AddrOf(..) => ExprPrecedence::AddrOf,\n+            ExprKind::Break(..) => ExprPrecedence::Break,\n+            ExprKind::Continue(..) => ExprPrecedence::Continue,\n+            ExprKind::Ret(..) => ExprPrecedence::Ret,\n+            ExprKind::InlineAsm(..) => ExprPrecedence::InlineAsm,\n+            ExprKind::Struct(..) => ExprPrecedence::Struct,\n+            ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n+            ExprKind::Yield(..) => ExprPrecedence::Yield,\n         }\n     }\n }\n@@ -1331,18 +1329,18 @@ impl fmt::Debug for Expr {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum Expr_ {\n+pub enum ExprKind {\n     /// A `box x` expression.\n-    ExprBox(P<Expr>),\n+    Box(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n-    ExprArray(HirVec<Expr>),\n+    Array(HirVec<Expr>),\n     /// A function call\n     ///\n-    /// The first field resolves to the function itself (usually an `ExprPath`),\n+    /// The first field resolves to the function itself (usually an `ExprKind::Path`),\n     /// and the second field is the list of arguments.\n     /// This also represents calling the constructor of\n     /// tuple-like ADTs such as tuple structs and enum variants.\n-    ExprCall(P<Expr>, HirVec<Expr>),\n+    Call(P<Expr>, HirVec<Expr>),\n     /// A method call (`x.foo::<'static, Bar, Baz>(a, b, c, d)`)\n     ///\n     /// The `PathSegment`/`Span` represent the method name and its generic arguments\n@@ -1352,83 +1350,83 @@ pub enum Expr_ {\n     /// and the remaining elements are the rest of the arguments.\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n-    ExprMethodCall(PathSegment, Span, HirVec<Expr>),\n+    MethodCall(PathSegment, Span, HirVec<Expr>),\n     /// A tuple (`(a, b, c ,d)`)\n-    ExprTup(HirVec<Expr>),\n+    Tup(HirVec<Expr>),\n     /// A binary operation (For example: `a + b`, `a * b`)\n-    ExprBinary(BinOp, P<Expr>, P<Expr>),\n+    Binary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (For example: `!x`, `*x`)\n-    ExprUnary(UnOp, P<Expr>),\n+    Unary(UnOp, P<Expr>),\n     /// A literal (For example: `1`, `\"foo\"`)\n-    ExprLit(P<Lit>),\n+    Lit(P<Lit>),\n     /// A cast (`foo as f64`)\n-    ExprCast(P<Expr>, P<Ty>),\n-    ExprType(P<Expr>, P<Ty>),\n+    Cast(P<Expr>, P<Ty>),\n+    Type(P<Expr>, P<Ty>),\n     /// An `if` block, with an optional else block\n     ///\n     /// `if expr { expr } else { expr }`\n-    ExprIf(P<Expr>, P<Expr>, Option<P<Expr>>),\n+    If(P<Expr>, P<Expr>, Option<P<Expr>>),\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n-    ExprWhile(P<Expr>, P<Block>, Option<Label>),\n+    While(P<Expr>, P<Block>, Option<Label>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    ExprLoop(P<Block>, Option<Label>, LoopSource),\n+    Loop(P<Block>, Option<Label>, LoopSource),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n-    ExprMatch(P<Expr>, HirVec<Arm>, MatchSource),\n+    Match(P<Expr>, HirVec<Arm>, MatchSource),\n     /// A closure (for example, `move |a, b, c| {a + b + c}`).\n     ///\n     /// The final span is the span of the argument block `|...|`\n     ///\n     /// This may also be a generator literal, indicated by the final boolean,\n     /// in that case there is an GeneratorClause.\n-    ExprClosure(CaptureClause, P<FnDecl>, BodyId, Span, Option<GeneratorMovability>),\n+    Closure(CaptureClause, P<FnDecl>, BodyId, Span, Option<GeneratorMovability>),\n     /// A block (`'label: { ... }`)\n-    ExprBlock(P<Block>, Option<Label>),\n+    Block(P<Block>, Option<Label>),\n \n     /// An assignment (`a = foo()`)\n-    ExprAssign(P<Expr>, P<Expr>),\n+    Assign(P<Expr>, P<Expr>),\n     /// An assignment with an operator\n     ///\n     /// For example, `a += 1`.\n-    ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n+    AssignOp(BinOp, P<Expr>, P<Expr>),\n     /// Access of a named (`obj.foo`) or unnamed (`obj.0`) struct or tuple field\n-    ExprField(P<Expr>, Ident),\n+    Field(P<Expr>, Ident),\n     /// An indexing operation (`foo[2]`)\n-    ExprIndex(P<Expr>, P<Expr>),\n+    Index(P<Expr>, P<Expr>),\n \n     /// Path to a definition, possibly containing lifetime or type parameters.\n-    ExprPath(QPath),\n+    Path(QPath),\n \n     /// A referencing operation (`&a` or `&mut a`)\n-    ExprAddrOf(Mutability, P<Expr>),\n+    AddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Destination, Option<P<Expr>>),\n+    Break(Destination, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n-    ExprContinue(Destination),\n+    Continue(Destination),\n     /// A `return`, with an optional value to be returned\n-    ExprRet(Option<P<Expr>>),\n+    Ret(Option<P<Expr>>),\n \n     /// Inline assembly (from `asm!`), with its outputs and inputs.\n-    ExprInlineAsm(P<InlineAsm>, HirVec<Expr>, HirVec<Expr>),\n+    InlineAsm(P<InlineAsm>, HirVec<Expr>, HirVec<Expr>),\n \n     /// A struct or struct-like variant literal expression.\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n-    ExprStruct(QPath, HirVec<Field>, Option<P<Expr>>),\n+    Struct(QPath, HirVec<Field>, Option<P<Expr>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n     /// For example, `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n-    ExprRepeat(P<Expr>, AnonConst),\n+    Repeat(P<Expr>, AnonConst),\n \n     /// A suspension point for generators. This is `yield <expr>` in Rust.\n-    ExprYield(P<Expr>),\n+    Yield(P<Expr>),\n }\n \n /// Optionally `Self`-qualified value/type path or associated extension.\n@@ -1447,7 +1445,7 @@ pub enum QPath {\n     ///\n     /// UFCS source paths can desugar into this, with `Vec::new` turning into\n     /// `<Vec>::new`, and `T::X::Y::method` into `<<<T>::X>::Y>::method`,\n-    /// the `X` and `Y` nodes each being a `TyPath(QPath::TypeRelative(..))`.\n+    /// the `X` and `Y` nodes each being a `TyKind::Path(QPath::TypeRelative(..))`.\n     TypeRelative(P<Ty>, P<PathSegment>)\n }\n \n@@ -1478,7 +1476,7 @@ pub enum MatchSource {\n     TryDesugar,\n }\n \n-/// The loop type that yielded an ExprLoop\n+/// The loop type that yielded an ExprKind::Loop\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum LoopSource {\n     /// A `loop { .. }` loop\n@@ -1637,7 +1635,7 @@ pub struct TypeBinding {\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Ty {\n     pub id: NodeId,\n-    pub node: Ty_,\n+    pub node: TyKind,\n     pub span: Span,\n     pub hir_id: HirId,\n }\n@@ -1678,36 +1676,36 @@ pub struct ExistTy {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n /// The different kinds of types recognized by the compiler\n-pub enum Ty_ {\n+pub enum TyKind {\n     /// A variable length slice (`[T]`)\n-    TySlice(P<Ty>),\n+    Slice(P<Ty>),\n     /// A fixed length array (`[T; n]`)\n-    TyArray(P<Ty>, AnonConst),\n+    Array(P<Ty>, AnonConst),\n     /// A raw pointer (`*const T` or `*mut T`)\n-    TyPtr(MutTy),\n+    Ptr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)\n-    TyRptr(Lifetime, MutTy),\n+    Rptr(Lifetime, MutTy),\n     /// A bare function (e.g. `fn(usize) -> bool`)\n-    TyBareFn(P<BareFnTy>),\n+    BareFn(P<BareFnTy>),\n     /// The never type (`!`)\n-    TyNever,\n+    Never,\n     /// A tuple (`(A, B, C, D,...)`)\n-    TyTup(HirVec<Ty>),\n+    Tup(HirVec<Ty>),\n     /// A path to a type definition (`module::module::...::Type`), or an\n     /// associated type, e.g. `<Vec<T> as Trait>::Type` or `<T>::Target`.\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n-    TyPath(QPath),\n+    Path(QPath),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n-    TyTraitObject(HirVec<PolyTraitRef>, Lifetime),\n+    TraitObject(HirVec<PolyTraitRef>, Lifetime),\n     /// Unused for now\n-    TyTypeof(AnonConst),\n-    /// TyInfer means the type should be inferred instead of it having been\n+    Typeof(AnonConst),\n+    /// TyKind::Infer means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n-    TyInfer,\n+    Infer,\n     /// Placeholder for a type that has failed to be defined.\n-    TyErr,\n+    Err,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -1876,15 +1874,15 @@ pub struct EnumDef {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct Variant_ {\n+pub struct VariantKind {\n     pub name: Name,\n     pub attrs: HirVec<Attribute>,\n     pub data: VariantData,\n     /// Explicit discriminant, eg `Foo = 1`\n     pub disr_expr: Option<AnonConst>,\n }\n \n-pub type Variant = Spanned<Variant_>;\n+pub type Variant = Spanned<VariantKind>;\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n pub enum UseKind {\n@@ -2041,7 +2039,7 @@ pub struct Item {\n     pub id: NodeId,\n     pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n-    pub node: Item_,\n+    pub node: ItemKind,\n     pub vis: Visibility,\n     pub span: Span,\n }\n@@ -2055,96 +2053,96 @@ pub struct FnHeader {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum Item_ {\n+pub enum ItemKind {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n     /// E.g. `extern crate foo` or `extern crate foo_bar as foo`\n-    ItemExternCrate(Option<Name>),\n+    ExternCrate(Option<Name>),\n \n     /// `use foo::bar::*;` or `use foo::bar::baz as quux;`\n     ///\n     /// or just\n     ///\n     /// `use foo::bar::baz;` (with `as baz` implicitly on the right)\n-    ItemUse(P<Path>, UseKind),\n+    Use(P<Path>, UseKind),\n \n     /// A `static` item\n-    ItemStatic(P<Ty>, Mutability, BodyId),\n+    Static(P<Ty>, Mutability, BodyId),\n     /// A `const` item\n-    ItemConst(P<Ty>, BodyId),\n+    Const(P<Ty>, BodyId),\n     /// A function declaration\n-    ItemFn(P<FnDecl>, FnHeader, Generics, BodyId),\n+    Fn(P<FnDecl>, FnHeader, Generics, BodyId),\n     /// A module\n-    ItemMod(Mod),\n+    Mod(Mod),\n     /// An external module\n-    ItemForeignMod(ForeignMod),\n+    ForeignMod(ForeignMod),\n     /// Module-level inline assembly (from global_asm!)\n-    ItemGlobalAsm(P<GlobalAsm>),\n+    GlobalAsm(P<GlobalAsm>),\n     /// A type alias, e.g. `type Foo = Bar<u8>`\n-    ItemTy(P<Ty>, Generics),\n+    Ty(P<Ty>, Generics),\n     /// A type alias, e.g. `type Foo = Bar<u8>`\n-    ItemExistential(ExistTy),\n+    Existential(ExistTy),\n     /// An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n-    ItemEnum(EnumDef, Generics),\n+    Enum(EnumDef, Generics),\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n-    ItemStruct(VariantData, Generics),\n+    Struct(VariantData, Generics),\n     /// A union definition, e.g. `union Foo<A, B> {x: A, y: B}`\n-    ItemUnion(VariantData, Generics),\n+    Union(VariantData, Generics),\n     /// Represents a Trait Declaration\n-    ItemTrait(IsAuto, Unsafety, Generics, GenericBounds, HirVec<TraitItemRef>),\n+    Trait(IsAuto, Unsafety, Generics, GenericBounds, HirVec<TraitItemRef>),\n     /// Represents a Trait Alias Declaration\n-    ItemTraitAlias(Generics, GenericBounds),\n+    TraitAlias(Generics, GenericBounds),\n \n     /// An implementation, eg `impl<A> Trait for Foo { .. }`\n-    ItemImpl(Unsafety,\n-             ImplPolarity,\n-             Defaultness,\n-             Generics,\n-             Option<TraitRef>, // (optional) trait this impl implements\n-             P<Ty>, // self\n-             HirVec<ImplItemRef>),\n+    Impl(Unsafety,\n+         ImplPolarity,\n+         Defaultness,\n+         Generics,\n+         Option<TraitRef>, // (optional) trait this impl implements\n+         P<Ty>, // self\n+         HirVec<ImplItemRef>),\n }\n \n-impl Item_ {\n+impl ItemKind {\n     pub fn descriptive_variant(&self) -> &str {\n         match *self {\n-            ItemExternCrate(..) => \"extern crate\",\n-            ItemUse(..) => \"use\",\n-            ItemStatic(..) => \"static item\",\n-            ItemConst(..) => \"constant item\",\n-            ItemFn(..) => \"function\",\n-            ItemMod(..) => \"module\",\n-            ItemForeignMod(..) => \"foreign module\",\n-            ItemGlobalAsm(..) => \"global asm\",\n-            ItemTy(..) => \"type alias\",\n-            ItemExistential(..) => \"existential type\",\n-            ItemEnum(..) => \"enum\",\n-            ItemStruct(..) => \"struct\",\n-            ItemUnion(..) => \"union\",\n-            ItemTrait(..) => \"trait\",\n-            ItemTraitAlias(..) => \"trait alias\",\n-            ItemImpl(..) => \"item\",\n+            ItemKind::ExternCrate(..) => \"extern crate\",\n+            ItemKind::Use(..) => \"use\",\n+            ItemKind::Static(..) => \"static item\",\n+            ItemKind::Const(..) => \"constant item\",\n+            ItemKind::Fn(..) => \"function\",\n+            ItemKind::Mod(..) => \"module\",\n+            ItemKind::ForeignMod(..) => \"foreign module\",\n+            ItemKind::GlobalAsm(..) => \"global asm\",\n+            ItemKind::Ty(..) => \"type alias\",\n+            ItemKind::Existential(..) => \"existential type\",\n+            ItemKind::Enum(..) => \"enum\",\n+            ItemKind::Struct(..) => \"struct\",\n+            ItemKind::Union(..) => \"union\",\n+            ItemKind::Trait(..) => \"trait\",\n+            ItemKind::TraitAlias(..) => \"trait alias\",\n+            ItemKind::Impl(..) => \"item\",\n         }\n     }\n \n     pub fn adt_kind(&self) -> Option<AdtKind> {\n         match *self {\n-            ItemStruct(..) => Some(AdtKind::Struct),\n-            ItemUnion(..) => Some(AdtKind::Union),\n-            ItemEnum(..) => Some(AdtKind::Enum),\n+            ItemKind::Struct(..) => Some(AdtKind::Struct),\n+            ItemKind::Union(..) => Some(AdtKind::Union),\n+            ItemKind::Enum(..) => Some(AdtKind::Enum),\n             _ => None,\n         }\n     }\n \n     pub fn generics(&self) -> Option<&Generics> {\n         Some(match *self {\n-            ItemFn(_, _, ref generics, _) |\n-            ItemTy(_, ref generics) |\n-            ItemEnum(_, ref generics) |\n-            ItemStruct(_, ref generics) |\n-            ItemUnion(_, ref generics) |\n-            ItemTrait(_, _, ref generics, _, _) |\n-            ItemImpl(_, _, _, ref generics, _, _, _)=> generics,\n+            ItemKind::Fn(_, _, ref generics, _) |\n+            ItemKind::Ty(_, ref generics) |\n+            ItemKind::Enum(_, ref generics) |\n+            ItemKind::Struct(_, ref generics) |\n+            ItemKind::Union(_, ref generics) |\n+            ItemKind::Trait(_, _, ref generics, _, _) |\n+            ItemKind::Impl(_, _, _, ref generics, _, _, _)=> generics,\n             _ => return None\n         })\n     }\n@@ -2192,30 +2190,30 @@ pub enum AssociatedItemKind {\n pub struct ForeignItem {\n     pub name: Name,\n     pub attrs: HirVec<Attribute>,\n-    pub node: ForeignItem_,\n+    pub node: ForeignItemKind,\n     pub id: NodeId,\n     pub span: Span,\n     pub vis: Visibility,\n }\n \n /// An item within an `extern` block\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum ForeignItem_ {\n+pub enum ForeignItemKind {\n     /// A foreign function\n-    ForeignItemFn(P<FnDecl>, HirVec<Ident>, Generics),\n+    Fn(P<FnDecl>, HirVec<Ident>, Generics),\n     /// A foreign static item (`static ext: u8`), with optional mutability\n     /// (the boolean is true when mutable)\n-    ForeignItemStatic(P<Ty>, bool),\n+    Static(P<Ty>, bool),\n     /// A foreign type\n-    ForeignItemType,\n+    Type,\n }\n \n-impl ForeignItem_ {\n+impl ForeignItemKind {\n     pub fn descriptive_variant(&self) -> &str {\n         match *self {\n-            ForeignItemFn(..) => \"foreign function\",\n-            ForeignItemStatic(..) => \"foreign static item\",\n-            ForeignItemType => \"foreign type\",\n+            ForeignItemKind::Fn(..) => \"foreign function\",\n+            ForeignItemKind::Static(..) => \"foreign static item\",\n+            ForeignItemKind::Type => \"foreign type\",\n         }\n     }\n }"}, {"sha": "e637a18d1cd0a2af9ad998c906f7ade6b87805cd", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 119, "deletions": 119, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -367,43 +367,43 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(ty.span.lo())?;\n         self.ibox(0)?;\n         match ty.node {\n-            hir::TySlice(ref ty) => {\n+            hir::TyKind::Slice(ref ty) => {\n                 self.s.word(\"[\")?;\n                 self.print_type(&ty)?;\n                 self.s.word(\"]\")?;\n             }\n-            hir::TyPtr(ref mt) => {\n+            hir::TyKind::Ptr(ref mt) => {\n                 self.s.word(\"*\")?;\n                 match mt.mutbl {\n                     hir::MutMutable => self.word_nbsp(\"mut\")?,\n                     hir::MutImmutable => self.word_nbsp(\"const\")?,\n                 }\n                 self.print_type(&mt.ty)?;\n             }\n-            hir::TyRptr(ref lifetime, ref mt) => {\n+            hir::TyKind::Rptr(ref lifetime, ref mt) => {\n                 self.s.word(\"&\")?;\n                 self.print_opt_lifetime(lifetime)?;\n                 self.print_mt(mt)?;\n             }\n-            hir::TyNever => {\n+            hir::TyKind::Never => {\n                 self.s.word(\"!\")?;\n             },\n-            hir::TyTup(ref elts) => {\n+            hir::TyKind::Tup(ref elts) => {\n                 self.popen()?;\n                 self.commasep(Inconsistent, &elts[..], |s, ty| s.print_type(&ty))?;\n                 if elts.len() == 1 {\n                     self.s.word(\",\")?;\n                 }\n                 self.pclose()?;\n             }\n-            hir::TyBareFn(ref f) => {\n+            hir::TyKind::BareFn(ref f) => {\n                 self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &f.generic_params,\n                                  &f.arg_names[..])?;\n             }\n-            hir::TyPath(ref qpath) => {\n+            hir::TyKind::Path(ref qpath) => {\n                 self.print_qpath(qpath, false)?\n             }\n-            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+            hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n                 let mut first = true;\n                 for bound in bounds {\n                     if first {\n@@ -420,22 +420,22 @@ impl<'a> State<'a> {\n                     self.print_lifetime(lifetime)?;\n                 }\n             }\n-            hir::TyArray(ref ty, ref length) => {\n+            hir::TyKind::Array(ref ty, ref length) => {\n                 self.s.word(\"[\")?;\n                 self.print_type(&ty)?;\n                 self.s.word(\"; \")?;\n                 self.print_anon_const(length)?;\n                 self.s.word(\"]\")?;\n             }\n-            hir::TyTypeof(ref e) => {\n+            hir::TyKind::Typeof(ref e) => {\n                 self.s.word(\"typeof(\")?;\n                 self.print_anon_const(e)?;\n                 self.s.word(\")\")?;\n             }\n-            hir::TyInfer => {\n+            hir::TyKind::Infer => {\n                 self.s.word(\"_\")?;\n             }\n-            hir::TyErr => {\n+            hir::TyKind::Err => {\n                 self.s.word(\"?\")?;\n             }\n         }\n@@ -447,7 +447,7 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(item.span.lo())?;\n         self.print_outer_attributes(&item.attrs)?;\n         match item.node {\n-            hir::ForeignItemFn(ref decl, ref arg_names, ref generics) => {\n+            hir::ForeignItemKind::Fn(ref decl, ref arg_names, ref generics) => {\n                 self.head(\"\")?;\n                 self.print_fn(decl,\n                               hir::FnHeader {\n@@ -465,7 +465,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end() // end the outer fn box\n             }\n-            hir::ForeignItemStatic(ref t, m) => {\n+            hir::ForeignItemKind::Static(ref t, m) => {\n                 self.head(&visibility_qualified(&item.vis, \"static\"))?;\n                 if m {\n                     self.word_space(\"mut\")?;\n@@ -477,7 +477,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the head-ibox\n                 self.end() // end the outer cbox\n             }\n-            hir::ForeignItemType => {\n+            hir::ForeignItemKind::Type => {\n                 self.head(&visibility_qualified(&item.vis, \"type\"))?;\n                 self.print_name(item.name)?;\n                 self.s.word(\";\")?;\n@@ -531,7 +531,7 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&item.attrs)?;\n         self.ann.pre(self, NodeItem(item))?;\n         match item.node {\n-            hir::ItemExternCrate(orig_name) => {\n+            hir::ItemKind::ExternCrate(orig_name) => {\n                 self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n                 if let Some(orig_name) = orig_name {\n                     self.print_name(orig_name)?;\n@@ -544,7 +544,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n-            hir::ItemUse(ref path, kind) => {\n+            hir::ItemKind::Use(ref path, kind) => {\n                 self.head(&visibility_qualified(&item.vis, \"use\"))?;\n                 self.print_path(path, false)?;\n \n@@ -563,7 +563,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n-            hir::ItemStatic(ref ty, m, expr) => {\n+            hir::ItemKind::Static(ref ty, m, expr) => {\n                 self.head(&visibility_qualified(&item.vis, \"static\"))?;\n                 if m == hir::MutMutable {\n                     self.word_space(\"mut\")?;\n@@ -579,7 +579,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            hir::ItemConst(ref ty, expr) => {\n+            hir::ItemKind::Const(ref ty, expr) => {\n                 self.head(&visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n@@ -592,7 +592,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            hir::ItemFn(ref decl, header, ref typarams, body) => {\n+            hir::ItemKind::Fn(ref decl, header, ref typarams, body) => {\n                 self.head(\"\")?;\n                 self.print_fn(decl,\n                               header,\n@@ -606,27 +606,27 @@ impl<'a> State<'a> {\n                 self.end()?; // need to close a box\n                 self.ann.nested(self, Nested::Body(body))?;\n             }\n-            hir::ItemMod(ref _mod) => {\n+            hir::ItemKind::Mod(ref _mod) => {\n                 self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n                 self.print_name(item.name)?;\n                 self.nbsp()?;\n                 self.bopen()?;\n                 self.print_mod(_mod, &item.attrs)?;\n                 self.bclose(item.span)?;\n             }\n-            hir::ItemForeignMod(ref nmod) => {\n+            hir::ItemKind::ForeignMod(ref nmod) => {\n                 self.head(\"extern\")?;\n                 self.word_nbsp(&nmod.abi.to_string())?;\n                 self.bopen()?;\n                 self.print_foreign_mod(nmod, &item.attrs)?;\n                 self.bclose(item.span)?;\n             }\n-            hir::ItemGlobalAsm(ref ga) => {\n+            hir::ItemKind::GlobalAsm(ref ga) => {\n                 self.head(&visibility_qualified(&item.vis, \"global asm\"))?;\n                 self.s.word(&ga.asm.as_str())?;\n                 self.end()?\n             }\n-            hir::ItemTy(ref ty, ref generics) => {\n+            hir::ItemKind::Ty(ref ty, ref generics) => {\n                 self.ibox(indent_unit)?;\n                 self.ibox(0)?;\n                 self.word_nbsp(&visibility_qualified(&item.vis, \"type\"))?;\n@@ -641,7 +641,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer ibox\n             }\n-            hir::ItemExistential(ref exist) => {\n+            hir::ItemKind::Existential(ref exist) => {\n                 self.ibox(indent_unit)?;\n                 self.ibox(0)?;\n                 self.word_nbsp(&visibility_qualified(&item.vis, \"existential type\"))?;\n@@ -666,18 +666,18 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer ibox\n             }\n-            hir::ItemEnum(ref enum_definition, ref params) => {\n+            hir::ItemKind::Enum(ref enum_definition, ref params) => {\n                 self.print_enum_def(enum_definition, params, item.name, item.span, &item.vis)?;\n             }\n-            hir::ItemStruct(ref struct_def, ref generics) => {\n+            hir::ItemKind::Struct(ref struct_def, ref generics) => {\n                 self.head(&visibility_qualified(&item.vis, \"struct\"))?;\n                 self.print_struct(struct_def, generics, item.name, item.span, true)?;\n             }\n-            hir::ItemUnion(ref struct_def, ref generics) => {\n+            hir::ItemKind::Union(ref struct_def, ref generics) => {\n                 self.head(&visibility_qualified(&item.vis, \"union\"))?;\n                 self.print_struct(struct_def, generics, item.name, item.span, true)?;\n             }\n-            hir::ItemImpl(unsafety,\n+            hir::ItemKind::Impl(unsafety,\n                           polarity,\n                           defaultness,\n                           ref generics,\n@@ -722,7 +722,7 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose(item.span)?;\n             }\n-            hir::ItemTrait(is_auto, unsafety, ref generics, ref bounds, ref trait_items) => {\n+            hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref trait_items) => {\n                 self.head(\"\")?;\n                 self.print_visibility(&item.vis)?;\n                 self.print_is_auto(is_auto)?;\n@@ -749,7 +749,7 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose(item.span)?;\n             }\n-            hir::ItemTraitAlias(ref generics, ref bounds) => {\n+            hir::ItemKind::TraitAlias(ref generics, ref bounds) => {\n                 self.head(\"\")?;\n                 self.print_visibility(&item.vis)?;\n                 self.word_nbsp(\"trait\")?;\n@@ -1001,14 +1001,14 @@ impl<'a> State<'a> {\n     pub fn print_stmt(&mut self, st: &hir::Stmt) -> io::Result<()> {\n         self.maybe_print_comment(st.span.lo())?;\n         match st.node {\n-            hir::StmtDecl(ref decl, _) => {\n+            hir::StmtKind::Decl(ref decl, _) => {\n                 self.print_decl(&decl)?;\n             }\n-            hir::StmtExpr(ref expr, _) => {\n+            hir::StmtKind::Expr(ref expr, _) => {\n                 self.space_if_not_bol()?;\n                 self.print_expr(&expr)?;\n             }\n-            hir::StmtSemi(ref expr, _) => {\n+            hir::StmtKind::Semi(ref expr, _) => {\n                 self.space_if_not_bol()?;\n                 self.print_expr(&expr)?;\n                 self.s.word(\";\")?;\n@@ -1080,7 +1080,7 @@ impl<'a> State<'a> {\n             Some(_else) => {\n                 match _else.node {\n                     // \"another else-if\"\n-                    hir::ExprIf(ref i, ref then, ref e) => {\n+                    hir::ExprKind::If(ref i, ref then, ref e) => {\n                         self.cbox(indent_unit - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else if \")?;\n@@ -1090,7 +1090,7 @@ impl<'a> State<'a> {\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n-                    hir::ExprBlock(ref b, _) => {\n+                    hir::ExprKind::Block(ref b, _) => {\n                         self.cbox(indent_unit - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else \")?;\n@@ -1162,9 +1162,9 @@ impl<'a> State<'a> {\n         let needs_par = match expr.node {\n             // These cases need parens due to the parse error observed in #26461: `if return {}`\n             // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n-            hir::ExprClosure(..) |\n-            hir::ExprRet(..) |\n-            hir::ExprBreak(..) => true,\n+            hir::ExprKind::Closure(..) |\n+            hir::ExprKind::Ret(..) |\n+            hir::ExprKind::Break(..) => true,\n \n             _ => contains_exterior_struct_lit(expr),\n         };\n@@ -1247,7 +1247,7 @@ impl<'a> State<'a> {\n     fn print_expr_call(&mut self, func: &hir::Expr, args: &[hir::Expr]) -> io::Result<()> {\n         let prec =\n             match func.node {\n-                hir::ExprField(..) => parser::PREC_FORCE_PAREN,\n+                hir::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n                 _ => parser::PREC_POSTFIX,\n             };\n \n@@ -1292,8 +1292,8 @@ impl<'a> State<'a> {\n             // These cases need parens: `x as i32 < y` has the parser thinking that `i32 < y` is\n             // the beginning of a path type. It starts trying to parse `x as (i32 < y ...` instead\n             // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n-            (&hir::ExprCast { .. }, hir::BinOp_::BiLt) |\n-            (&hir::ExprCast { .. }, hir::BinOp_::BiShl) => parser::PREC_FORCE_PAREN,\n+            (&hir::ExprKind::Cast { .. }, hir::BinOpKind::Lt) |\n+            (&hir::ExprKind::Cast { .. }, hir::BinOpKind::Shl) => parser::PREC_FORCE_PAREN,\n             _ => left_prec,\n         };\n \n@@ -1323,57 +1323,57 @@ impl<'a> State<'a> {\n         self.ibox(indent_unit)?;\n         self.ann.pre(self, NodeExpr(expr))?;\n         match expr.node {\n-            hir::ExprBox(ref expr) => {\n+            hir::ExprKind::Box(ref expr) => {\n                 self.word_space(\"box\")?;\n                 self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)?;\n             }\n-            hir::ExprArray(ref exprs) => {\n+            hir::ExprKind::Array(ref exprs) => {\n                 self.print_expr_vec(exprs)?;\n             }\n-            hir::ExprRepeat(ref element, ref count) => {\n+            hir::ExprKind::Repeat(ref element, ref count) => {\n                 self.print_expr_repeat(&element, count)?;\n             }\n-            hir::ExprStruct(ref qpath, ref fields, ref wth) => {\n+            hir::ExprKind::Struct(ref qpath, ref fields, ref wth) => {\n                 self.print_expr_struct(qpath, &fields[..], wth)?;\n             }\n-            hir::ExprTup(ref exprs) => {\n+            hir::ExprKind::Tup(ref exprs) => {\n                 self.print_expr_tup(exprs)?;\n             }\n-            hir::ExprCall(ref func, ref args) => {\n+            hir::ExprKind::Call(ref func, ref args) => {\n                 self.print_expr_call(&func, args)?;\n             }\n-            hir::ExprMethodCall(ref segment, _, ref args) => {\n+            hir::ExprKind::MethodCall(ref segment, _, ref args) => {\n                 self.print_expr_method_call(segment, args)?;\n             }\n-            hir::ExprBinary(op, ref lhs, ref rhs) => {\n+            hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n                 self.print_expr_binary(op, &lhs, &rhs)?;\n             }\n-            hir::ExprUnary(op, ref expr) => {\n+            hir::ExprKind::Unary(op, ref expr) => {\n                 self.print_expr_unary(op, &expr)?;\n             }\n-            hir::ExprAddrOf(m, ref expr) => {\n+            hir::ExprKind::AddrOf(m, ref expr) => {\n                 self.print_expr_addr_of(m, &expr)?;\n             }\n-            hir::ExprLit(ref lit) => {\n+            hir::ExprKind::Lit(ref lit) => {\n                 self.print_literal(&lit)?;\n             }\n-            hir::ExprCast(ref expr, ref ty) => {\n+            hir::ExprKind::Cast(ref expr, ref ty) => {\n                 let prec = AssocOp::As.precedence() as i8;\n                 self.print_expr_maybe_paren(&expr, prec)?;\n                 self.s.space()?;\n                 self.word_space(\"as\")?;\n                 self.print_type(&ty)?;\n             }\n-            hir::ExprType(ref expr, ref ty) => {\n+            hir::ExprKind::Type(ref expr, ref ty) => {\n                 let prec = AssocOp::Colon.precedence() as i8;\n                 self.print_expr_maybe_paren(&expr, prec)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n             }\n-            hir::ExprIf(ref test, ref blk, ref elseopt) => {\n+            hir::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n-            hir::ExprWhile(ref test, ref blk, opt_label) => {\n+            hir::ExprKind::While(ref test, ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n@@ -1383,7 +1383,7 @@ impl<'a> State<'a> {\n                 self.s.space()?;\n                 self.print_block(&blk)?;\n             }\n-            hir::ExprLoop(ref blk, opt_label, _) => {\n+            hir::ExprKind::Loop(ref blk, opt_label, _) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n@@ -1392,7 +1392,7 @@ impl<'a> State<'a> {\n                 self.s.space()?;\n                 self.print_block(&blk)?;\n             }\n-            hir::ExprMatch(ref expr, ref arms, _) => {\n+            hir::ExprKind::Match(ref expr, ref arms, _) => {\n                 self.cbox(indent_unit)?;\n                 self.ibox(4)?;\n                 self.word_nbsp(\"match\")?;\n@@ -1404,7 +1404,7 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose_(expr.span, indent_unit)?;\n             }\n-            hir::ExprClosure(capture_clause, ref decl, body, _fn_decl_span, _gen) => {\n+            hir::ExprKind::Closure(capture_clause, ref decl, body, _fn_decl_span, _gen) => {\n                 self.print_capture_clause(capture_clause)?;\n \n                 self.print_closure_args(&decl, body)?;\n@@ -1419,7 +1419,7 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 self.ibox(0)?;\n             }\n-            hir::ExprBlock(ref blk, opt_label) => {\n+            hir::ExprKind::Block(ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n@@ -1430,36 +1430,36 @@ impl<'a> State<'a> {\n                 self.ibox(0)?;\n                 self.print_block(&blk)?;\n             }\n-            hir::ExprAssign(ref lhs, ref rhs) => {\n+            hir::ExprKind::Assign(ref lhs, ref rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(&lhs, prec + 1)?;\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_expr_maybe_paren(&rhs, prec)?;\n             }\n-            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+            hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(&lhs, prec + 1)?;\n                 self.s.space()?;\n                 self.s.word(op.node.as_str())?;\n                 self.word_space(\"=\")?;\n                 self.print_expr_maybe_paren(&rhs, prec)?;\n             }\n-            hir::ExprField(ref expr, ident) => {\n+            hir::ExprKind::Field(ref expr, ident) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n                 self.print_ident(ident)?;\n             }\n-            hir::ExprIndex(ref expr, ref index) => {\n+            hir::ExprKind::Index(ref expr, ref index) => {\n                 self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\"[\")?;\n                 self.print_expr(&index)?;\n                 self.s.word(\"]\")?;\n             }\n-            hir::ExprPath(ref qpath) => {\n+            hir::ExprKind::Path(ref qpath) => {\n                 self.print_qpath(qpath, true)?\n             }\n-            hir::ExprBreak(destination, ref opt_expr) => {\n+            hir::ExprKind::Break(destination, ref opt_expr) => {\n                 self.s.word(\"break\")?;\n                 self.s.space()?;\n                 if let Some(label) = destination.label {\n@@ -1471,15 +1471,15 @@ impl<'a> State<'a> {\n                     self.s.space()?;\n                 }\n             }\n-            hir::ExprContinue(destination) => {\n+            hir::ExprKind::Continue(destination) => {\n                 self.s.word(\"continue\")?;\n                 self.s.space()?;\n                 if let Some(label) = destination.label {\n                     self.print_ident(label.ident)?;\n                     self.s.space()?\n                 }\n             }\n-            hir::ExprRet(ref result) => {\n+            hir::ExprKind::Ret(ref result) => {\n                 self.s.word(\"return\")?;\n                 match *result {\n                     Some(ref expr) => {\n@@ -1489,7 +1489,7 @@ impl<'a> State<'a> {\n                     _ => (),\n                 }\n             }\n-            hir::ExprInlineAsm(ref a, ref outputs, ref inputs) => {\n+            hir::ExprKind::InlineAsm(ref a, ref outputs, ref inputs) => {\n                 self.s.word(\"asm!\")?;\n                 self.popen()?;\n                 self.print_string(&a.asm.as_str(), a.asm_str_style)?;\n@@ -1554,7 +1554,7 @@ impl<'a> State<'a> {\n \n                 self.pclose()?;\n             }\n-            hir::ExprYield(ref expr) => {\n+            hir::ExprKind::Yield(ref expr) => {\n                 self.word_space(\"yield\")?;\n                 self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n             }\n@@ -1575,7 +1575,7 @@ impl<'a> State<'a> {\n     pub fn print_decl(&mut self, decl: &hir::Decl) -> io::Result<()> {\n         self.maybe_print_comment(decl.span.lo())?;\n         match decl.node {\n-            hir::DeclLocal(ref loc) => {\n+            hir::DeclKind::Local(ref loc) => {\n                 self.space_if_not_bol()?;\n                 self.ibox(indent_unit)?;\n                 self.word_nbsp(\"let\")?;\n@@ -1590,7 +1590,7 @@ impl<'a> State<'a> {\n                 }\n                 self.end()\n             }\n-            hir::DeclItem(item) => {\n+            hir::DeclKind::Item(item) => {\n                 self.ann.nested(self, Nested::Item(item))\n             }\n         }\n@@ -1959,7 +1959,7 @@ impl<'a> State<'a> {\n         self.word_space(\"=>\")?;\n \n         match arm.body.node {\n-            hir::ExprBlock(ref blk, opt_label) => {\n+            hir::ExprKind::Block(ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n@@ -2035,7 +2035,7 @@ impl<'a> State<'a> {\n             s.ann.nested(s, Nested::BodyArgPat(body_id, i))?;\n             i += 1;\n \n-            if let hir::TyInfer = ty.node {\n+            if let hir::TyKind::Infer = ty.node {\n                 // Print nothing\n             } else {\n                 s.s.word(\":\")?;\n@@ -2384,59 +2384,59 @@ impl<'a> State<'a> {\n /// isn't parsed as (if true {...} else {...} | x) | 5\n fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n     match e.node {\n-        hir::ExprIf(..) |\n-        hir::ExprMatch(..) |\n-        hir::ExprBlock(..) |\n-        hir::ExprWhile(..) |\n-        hir::ExprLoop(..) => false,\n+        hir::ExprKind::If(..) |\n+        hir::ExprKind::Match(..) |\n+        hir::ExprKind::Block(..) |\n+        hir::ExprKind::While(..) |\n+        hir::ExprKind::Loop(..) => false,\n         _ => true,\n     }\n }\n \n /// this statement requires a semicolon after it.\n /// note that in one case (stmt_semi), we've already\n /// seen the semicolon, and thus don't need another.\n-fn stmt_ends_with_semi(stmt: &hir::Stmt_) -> bool {\n+fn stmt_ends_with_semi(stmt: &hir::StmtKind) -> bool {\n     match *stmt {\n-        hir::StmtDecl(ref d, _) => {\n+        hir::StmtKind::Decl(ref d, _) => {\n             match d.node {\n-                hir::DeclLocal(_) => true,\n-                hir::DeclItem(_) => false,\n+                hir::DeclKind::Local(_) => true,\n+                hir::DeclKind::Item(_) => false,\n             }\n         }\n-        hir::StmtExpr(ref e, _) => {\n+        hir::StmtKind::Expr(ref e, _) => {\n             expr_requires_semi_to_be_stmt(&e)\n         }\n-        hir::StmtSemi(..) => {\n+        hir::StmtKind::Semi(..) => {\n             false\n         }\n     }\n }\n \n-fn bin_op_to_assoc_op(op: hir::BinOp_) -> AssocOp {\n-    use hir::BinOp_::*;\n+fn bin_op_to_assoc_op(op: hir::BinOpKind) -> AssocOp {\n+    use hir::BinOpKind::*;\n     match op {\n-        BiAdd => AssocOp::Add,\n-        BiSub => AssocOp::Subtract,\n-        BiMul => AssocOp::Multiply,\n-        BiDiv => AssocOp::Divide,\n-        BiRem => AssocOp::Modulus,\n-\n-        BiAnd => AssocOp::LAnd,\n-        BiOr => AssocOp::LOr,\n-\n-        BiBitXor => AssocOp::BitXor,\n-        BiBitAnd => AssocOp::BitAnd,\n-        BiBitOr => AssocOp::BitOr,\n-        BiShl => AssocOp::ShiftLeft,\n-        BiShr => AssocOp::ShiftRight,\n-\n-        BiEq => AssocOp::Equal,\n-        BiLt => AssocOp::Less,\n-        BiLe => AssocOp::LessEqual,\n-        BiNe => AssocOp::NotEqual,\n-        BiGe => AssocOp::GreaterEqual,\n-        BiGt => AssocOp::Greater,\n+        Add => AssocOp::Add,\n+        Sub => AssocOp::Subtract,\n+        Mul => AssocOp::Multiply,\n+        Div => AssocOp::Divide,\n+        Rem => AssocOp::Modulus,\n+\n+        And => AssocOp::LAnd,\n+        Or => AssocOp::LOr,\n+\n+        BitXor => AssocOp::BitXor,\n+        BitAnd => AssocOp::BitAnd,\n+        BitOr => AssocOp::BitOr,\n+        Shl => AssocOp::ShiftLeft,\n+        Shr => AssocOp::ShiftRight,\n+\n+        Eq => AssocOp::Equal,\n+        Lt => AssocOp::Less,\n+        Le => AssocOp::LessEqual,\n+        Ne => AssocOp::NotEqual,\n+        Ge => AssocOp::GreaterEqual,\n+        Gt => AssocOp::Greater,\n     }\n }\n \n@@ -2445,24 +2445,24 @@ fn bin_op_to_assoc_op(op: hir::BinOp_) -> AssocOp {\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n     match value.node {\n-        hir::ExprStruct(..) => true,\n+        hir::ExprKind::Struct(..) => true,\n \n-        hir::ExprAssign(ref lhs, ref rhs) |\n-        hir::ExprAssignOp(_, ref lhs, ref rhs) |\n-        hir::ExprBinary(_, ref lhs, ref rhs) => {\n+        hir::ExprKind::Assign(ref lhs, ref rhs) |\n+        hir::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n+        hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n             // X { y: 1 } + X { y: 2 }\n             contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n         }\n-        hir::ExprUnary(_, ref x) |\n-        hir::ExprCast(ref x, _) |\n-        hir::ExprType(ref x, _) |\n-        hir::ExprField(ref x, _) |\n-        hir::ExprIndex(ref x, _) => {\n+        hir::ExprKind::Unary(_, ref x) |\n+        hir::ExprKind::Cast(ref x, _) |\n+        hir::ExprKind::Type(ref x, _) |\n+        hir::ExprKind::Field(ref x, _) |\n+        hir::ExprKind::Index(ref x, _) => {\n             // &X { y: 1 }, X { y: 1 }.y\n             contains_exterior_struct_lit(&x)\n         }\n \n-        hir::ExprMethodCall(.., ref exprs) => {\n+        hir::ExprKind::MethodCall(.., ref exprs) => {\n             // X { y: 1 }.bar(...)\n             contains_exterior_struct_lit(&exprs[0])\n         }"}, {"sha": "d1fb05ceafbfd28d62adc55103f2b467516b46e2", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 97, "deletions": 97, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -330,19 +330,19 @@ impl_stable_hash_for!(struct hir::ExistTy {\n     bounds\n });\n \n-impl_stable_hash_for!(enum hir::Ty_ {\n-    TySlice(t),\n-    TyArray(t, body_id),\n-    TyPtr(t),\n-    TyRptr(lifetime, t),\n-    TyBareFn(t),\n-    TyNever,\n-    TyTup(ts),\n-    TyPath(qpath),\n-    TyTraitObject(trait_refs, lifetime),\n-    TyTypeof(body_id),\n-    TyErr,\n-    TyInfer\n+impl_stable_hash_for!(enum hir::TyKind {\n+    Slice(t),\n+    Array(t, body_id),\n+    Ptr(t),\n+    Rptr(lifetime, t),\n+    BareFn(t),\n+    Never,\n+    Tup(ts),\n+    Path(qpath),\n+    TraitObject(trait_refs, lifetime),\n+    Typeof(body_id),\n+    Err,\n+    Infer\n });\n \n impl_stable_hash_for!(struct hir::FnDecl {\n@@ -437,36 +437,36 @@ impl_stable_hash_for!(enum hir::PatKind {\n     Slice(one, two, three)\n });\n \n-impl_stable_hash_for!(enum hir::BinOp_ {\n-    BiAdd,\n-    BiSub,\n-    BiMul,\n-    BiDiv,\n-    BiRem,\n-    BiAnd,\n-    BiOr,\n-    BiBitXor,\n-    BiBitAnd,\n-    BiBitOr,\n-    BiShl,\n-    BiShr,\n-    BiEq,\n-    BiLt,\n-    BiLe,\n-    BiNe,\n-    BiGe,\n-    BiGt\n-});\n-\n-impl_stable_hash_for_spanned!(hir::BinOp_);\n+impl_stable_hash_for!(enum hir::BinOpKind {\n+    Add,\n+    Sub,\n+    Mul,\n+    Div,\n+    Rem,\n+    And,\n+    Or,\n+    BitXor,\n+    BitAnd,\n+    BitOr,\n+    Shl,\n+    Shr,\n+    Eq,\n+    Lt,\n+    Le,\n+    Ne,\n+    Ge,\n+    Gt\n+});\n+\n+impl_stable_hash_for_spanned!(hir::BinOpKind);\n \n impl_stable_hash_for!(enum hir::UnOp {\n     UnDeref,\n     UnNot,\n     UnNeg\n });\n \n-impl_stable_hash_for_spanned!(hir::Stmt_);\n+impl_stable_hash_for_spanned!(hir::StmtKind);\n \n impl_stable_hash_for!(struct hir::Local {\n     pat,\n@@ -479,10 +479,10 @@ impl_stable_hash_for!(struct hir::Local {\n     source\n });\n \n-impl_stable_hash_for_spanned!(hir::Decl_);\n-impl_stable_hash_for!(enum hir::Decl_ {\n-    DeclLocal(local),\n-    DeclItem(item_id)\n+impl_stable_hash_for_spanned!(hir::DeclKind);\n+impl_stable_hash_for!(enum hir::DeclKind {\n+    Local(local),\n+    Item(item_id)\n });\n \n impl_stable_hash_for!(struct hir::Arm {\n@@ -541,36 +541,36 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::Expr_ {\n-    ExprBox(sub),\n-    ExprArray(subs),\n-    ExprCall(callee, args),\n-    ExprMethodCall(segment, span, args),\n-    ExprTup(fields),\n-    ExprBinary(op, lhs, rhs),\n-    ExprUnary(op, operand),\n-    ExprLit(value),\n-    ExprCast(expr, t),\n-    ExprType(expr, t),\n-    ExprIf(cond, then, els),\n-    ExprWhile(cond, body, label),\n-    ExprLoop(body, label, loop_src),\n-    ExprMatch(matchee, arms, match_src),\n-    ExprClosure(capture_clause, decl, body_id, span, gen),\n-    ExprBlock(blk, label),\n-    ExprAssign(lhs, rhs),\n-    ExprAssignOp(op, lhs, rhs),\n-    ExprField(owner, ident),\n-    ExprIndex(lhs, rhs),\n-    ExprPath(path),\n-    ExprAddrOf(mutability, sub),\n-    ExprBreak(destination, sub),\n-    ExprContinue(destination),\n-    ExprRet(val),\n-    ExprInlineAsm(asm, inputs, outputs),\n-    ExprStruct(path, fields, base),\n-    ExprRepeat(val, times),\n-    ExprYield(val)\n+impl_stable_hash_for!(enum hir::ExprKind {\n+    Box(sub),\n+    Array(subs),\n+    Call(callee, args),\n+    MethodCall(segment, span, args),\n+    Tup(fields),\n+    Binary(op, lhs, rhs),\n+    Unary(op, operand),\n+    Lit(value),\n+    Cast(expr, t),\n+    Type(expr, t),\n+    If(cond, then, els),\n+    While(cond, body, label),\n+    Loop(body, label, loop_src),\n+    Match(matchee, arms, match_src),\n+    Closure(capture_clause, decl, body_id, span, gen),\n+    Block(blk, label),\n+    Assign(lhs, rhs),\n+    AssignOp(op, lhs, rhs),\n+    Field(owner, ident),\n+    Index(lhs, rhs),\n+    Path(path),\n+    AddrOf(mutability, sub),\n+    Break(destination, sub),\n+    Continue(destination),\n+    Ret(val),\n+    InlineAsm(asm, inputs, outputs),\n+    Struct(path, fields, base),\n+    Repeat(val, times),\n+    Yield(val)\n });\n \n impl_stable_hash_for!(enum hir::LocalSource {\n@@ -793,14 +793,14 @@ impl_stable_hash_for!(struct hir::EnumDef {\n     variants\n });\n \n-impl_stable_hash_for!(struct hir::Variant_ {\n+impl_stable_hash_for!(struct hir::VariantKind {\n     name,\n     attrs,\n     data,\n     disr_expr\n });\n \n-impl_stable_hash_for_spanned!(hir::Variant_);\n+impl_stable_hash_for_spanned!(hir::VariantKind);\n \n impl_stable_hash_for!(enum hir::UseKind {\n     Single,\n@@ -847,23 +847,23 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::Item_ {\n-    ItemExternCrate(orig_name),\n-    ItemUse(path, use_kind),\n-    ItemStatic(ty, mutability, body_id),\n-    ItemConst(ty, body_id),\n-    ItemFn(fn_decl, header, generics, body_id),\n-    ItemMod(module),\n-    ItemForeignMod(foreign_mod),\n-    ItemGlobalAsm(global_asm),\n-    ItemTy(ty, generics),\n-    ItemExistential(exist),\n-    ItemEnum(enum_def, generics),\n-    ItemStruct(variant_data, generics),\n-    ItemUnion(variant_data, generics),\n-    ItemTrait(is_auto, unsafety, generics, bounds, item_refs),\n-    ItemTraitAlias(generics, bounds),\n-    ItemImpl(unsafety, impl_polarity, impl_defaultness, generics, trait_ref, ty, impl_item_refs)\n+impl_stable_hash_for!(enum hir::ItemKind {\n+    ExternCrate(orig_name),\n+    Use(path, use_kind),\n+    Static(ty, mutability, body_id),\n+    Const(ty, body_id),\n+    Fn(fn_decl, header, generics, body_id),\n+    Mod(module),\n+    ForeignMod(foreign_mod),\n+    GlobalAsm(global_asm),\n+    Ty(ty, generics),\n+    Existential(exist),\n+    Enum(enum_def, generics),\n+    Struct(variant_data, generics),\n+    Union(variant_data, generics),\n+    Trait(is_auto, unsafety, generics, bounds, item_refs),\n+    TraitAlias(generics, bounds),\n+    Impl(unsafety, impl_polarity, impl_defaultness, generics, trait_ref, ty, impl_item_refs)\n });\n \n impl_stable_hash_for!(struct hir::TraitItemRef {\n@@ -909,16 +909,16 @@ impl_stable_hash_for!(struct hir::ForeignItem {\n     vis\n });\n \n-impl_stable_hash_for!(enum hir::ForeignItem_ {\n-    ForeignItemFn(fn_decl, arg_names, generics),\n-    ForeignItemStatic(ty, is_mutbl),\n-    ForeignItemType\n+impl_stable_hash_for!(enum hir::ForeignItemKind {\n+    Fn(fn_decl, arg_names, generics),\n+    Static(ty, is_mutbl),\n+    Type\n });\n \n-impl_stable_hash_for!(enum hir::Stmt_ {\n-    StmtDecl(decl, id),\n-    StmtExpr(expr, id),\n-    StmtSemi(expr, id)\n+impl_stable_hash_for!(enum hir::StmtKind {\n+    Decl(decl, id),\n+    Expr(expr, id),\n+    Semi(expr, id)\n });\n \n impl_stable_hash_for!(struct hir::Arg {"}, {"sha": "2924016670bf8377b3d4af5b0a7506b46d9318d9", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -691,7 +691,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                     // ```\n                     if let Some(anon_node_id) = tcx.hir.as_local_node_id(def_id) {\n                         let anon_parent_def_id = match tcx.hir.expect_item(anon_node_id).node {\n-                            hir::ItemExistential(hir::ExistTy {\n+                            hir::ItemKind::Existential(hir::ExistTy {\n                                 impl_trait_fn: Some(parent),\n                                 ..\n                             }) => parent,"}, {"sha": "8da0dc365b04e0d1edded2db941b6908f12ae292", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -102,12 +102,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 let tag = match self.hir.find(scope.node_id(self, region_scope_tree)) {\n                     Some(hir_map::NodeBlock(_)) => \"block\",\n                     Some(hir_map::NodeExpr(expr)) => match expr.node {\n-                        hir::ExprCall(..) => \"call\",\n-                        hir::ExprMethodCall(..) => \"method call\",\n-                        hir::ExprMatch(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                        hir::ExprMatch(.., hir::MatchSource::WhileLetDesugar) => \"while let\",\n-                        hir::ExprMatch(.., hir::MatchSource::ForLoopDesugar) => \"for\",\n-                        hir::ExprMatch(..) => \"match\",\n+                        hir::ExprKind::Call(..) => \"call\",\n+                        hir::ExprKind::MethodCall(..) => \"method call\",\n+                        hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n+                        hir::ExprKind::Match(.., hir::MatchSource::WhileLetDesugar) => \"while let\",\n+                        hir::ExprKind::Match(.., hir::MatchSource::ForLoopDesugar) => \"for\",\n+                        hir::ExprKind::Match(..) => \"match\",\n                         _ => \"expression\",\n                     },\n                     Some(hir_map::NodeStmt(_)) => \"statement\",\n@@ -259,12 +259,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     fn item_scope_tag(item: &hir::Item) -> &'static str {\n         match item.node {\n-            hir::ItemImpl(..) => \"impl\",\n-            hir::ItemStruct(..) => \"struct\",\n-            hir::ItemUnion(..) => \"union\",\n-            hir::ItemEnum(..) => \"enum\",\n-            hir::ItemTrait(..) => \"trait\",\n-            hir::ItemFn(..) => \"function body\",\n+            hir::ItemKind::Impl(..) => \"impl\",\n+            hir::ItemKind::Struct(..) => \"struct\",\n+            hir::ItemKind::Union(..) => \"union\",\n+            hir::ItemKind::Enum(..) => \"enum\",\n+            hir::ItemKind::Trait(..) => \"trait\",\n+            hir::ItemKind::Fn(..) => \"function body\",\n             _ => \"item\",\n         }\n     }"}, {"sha": "21be09b0ba193f0d30e7e42b89cb8776aa948a47", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let fndecl = match self.tcx.hir.get(node_id) {\n                     hir_map::NodeItem(&hir::Item {\n-                        node: hir::ItemFn(ref fndecl, ..),\n+                        node: hir::ItemKind::Fn(ref fndecl, ..),\n                         ..\n                     }) => &fndecl,\n                     hir_map::NodeTraitItem(&hir::TraitItem {\n@@ -109,20 +109,20 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n \n     fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n         match arg.node {\n-            hir::TyBareFn(_) => {\n+            hir::TyKind::BareFn(_) => {\n                 self.current_index.shift_in(1);\n                 intravisit::walk_ty(self, arg);\n                 self.current_index.shift_out(1);\n                 return;\n             }\n \n-            hir::TyTraitObject(ref bounds, _) => for bound in bounds {\n+            hir::TyKind::TraitObject(ref bounds, _) => for bound in bounds {\n                 self.current_index.shift_in(1);\n                 self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                 self.current_index.shift_out(1);\n             },\n \n-            hir::TyRptr(ref lifetime, _) => {\n+            hir::TyKind::Rptr(ref lifetime, _) => {\n                 // the lifetime of the TyRptr\n                 let hir_id = self.tcx.hir.node_to_hir_id(lifetime.id);\n                 match (self.tcx.named_region(hir_id), self.bound_region) {\n@@ -190,8 +190,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            // Checks if it is of type `hir::TyPath` which corresponds to a struct.\n-            hir::TyPath(_) => {\n+            // Checks if it is of type `hir::TyKind::Path` which corresponds to a struct.\n+            hir::TyKind::Path(_) => {\n                 let subvisitor = &mut TyPathVisitor {\n                     tcx: self.tcx,\n                     found_it: false,\n@@ -213,7 +213,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n }\n \n // The visitor captures the corresponding `hir::Ty` of the anonymous region\n-// in the case of structs ie. `hir::TyPath`.\n+// in the case of structs ie. `hir::TyKind::Path`.\n // This visitor would be invoked for each lifetime corresponding to a struct,\n // and would walk the types like Vec<Ref> in the above example and Ref looking for the HIR\n // where that lifetime appears. This allows us to highlight the"}, {"sha": "f4ef197e5b4223c53e1ee9b1d9068159674f4a88", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -14,7 +14,7 @@\n use infer::error_reporting::nice_region_error::NiceRegionError;\n use infer::SubregionOrigin;\n use ty::RegionKind;\n-use hir::{Expr, ExprClosure};\n+use hir::{Expr, ExprKind::Closure};\n use hir::map::NodeExpr;\n use util::common::ErrorReported;\n use infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n@@ -60,7 +60,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                 if let Some(node_id) = hir.as_local_node_id(free_region.scope) {\n                     match hir.get(node_id) {\n                         NodeExpr(Expr {\n-                            node: ExprClosure(_, _, _, closure_span, None),\n+                            node: Closure(_, _, _, closure_span, None),\n                             ..\n                         }) => {\n                             let sup_sp = sup_origin.span();"}, {"sha": "da59bced760d405b06d163f40141a210f013a4fc", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -153,21 +153,21 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         match *node {\n             hir_map::NodeItem(item) => {\n                 match item.node {\n-                    hir::ItemStruct(..) | hir::ItemUnion(..) => {\n+                    hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n                         let def = self.tcx.adt_def(def_id);\n                         self.repr_has_repr_c = def.repr.c();\n \n                         intravisit::walk_item(self, &item);\n                     }\n-                    hir::ItemEnum(..) => {\n+                    hir::ItemKind::Enum(..) => {\n                         self.inherited_pub_visibility = item.vis.node.is_pub();\n                         intravisit::walk_item(self, &item);\n                     }\n-                    hir::ItemFn(..)\n-                    | hir::ItemTy(..)\n-                    | hir::ItemStatic(..)\n-                    | hir::ItemConst(..) => {\n+                    hir::ItemKind::Fn(..)\n+                    | hir::ItemKind::Ty(..)\n+                    | hir::ItemKind::Static(..)\n+                    | hir::ItemKind::Const(..) => {\n                         intravisit::walk_item(self, &item);\n                     }\n                     _ => ()\n@@ -225,17 +225,17 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprPath(ref qpath @ hir::QPath::TypeRelative(..)) => {\n+            hir::ExprKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n                 let def = self.tables.qpath_def(qpath, expr.hir_id);\n                 self.handle_definition(def);\n             }\n-            hir::ExprMethodCall(..) => {\n+            hir::ExprKind::MethodCall(..) => {\n                 self.lookup_and_handle_method(expr.hir_id);\n             }\n-            hir::ExprField(ref lhs, ..) => {\n+            hir::ExprKind::Field(ref lhs, ..) => {\n                 self.handle_field_access(&lhs, expr.id);\n             }\n-            hir::ExprStruct(_, ref fields, _) => {\n+            hir::ExprKind::Struct(_, ref fields, _) => {\n                 if let ty::TypeVariants::TyAdt(ref adt, _) = self.tables.expr_ty(expr).sty {\n                     self.mark_as_used_if_union(adt, fields);\n                 }\n@@ -349,11 +349,11 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n             self.worklist.push(item.id);\n         }\n         match item.node {\n-            hir::ItemEnum(ref enum_def, _) if allow_dead_code => {\n+            hir::ItemKind::Enum(ref enum_def, _) if allow_dead_code => {\n                 self.worklist.extend(enum_def.variants.iter()\n                                                       .map(|variant| variant.node.data.id()));\n             }\n-            hir::ItemTrait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n                     let trait_item = self.krate.trait_item(trait_item_ref.id);\n                     match trait_item.node {\n@@ -369,7 +369,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., ref opt_trait, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref opt_trait, _, ref impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if opt_trait.is_some() ||\n@@ -439,7 +439,7 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n     match item.node {\n-        hir::ItemStruct(ref struct_def, _) if !struct_def.is_struct() => {\n+        hir::ItemKind::Struct(ref struct_def, _) if !struct_def.is_struct() => {\n             Some(struct_def.id())\n         }\n         _ => None\n@@ -454,13 +454,13 @@ struct DeadVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     fn should_warn_about_item(&mut self, item: &hir::Item) -> bool {\n         let should_warn = match item.node {\n-            hir::ItemStatic(..)\n-            | hir::ItemConst(..)\n-            | hir::ItemFn(..)\n-            | hir::ItemTy(..)\n-            | hir::ItemEnum(..)\n-            | hir::ItemStruct(..)\n-            | hir::ItemUnion(..) => true,\n+            hir::ItemKind::Static(..)\n+            | hir::ItemKind::Const(..)\n+            | hir::ItemKind::Fn(..)\n+            | hir::ItemKind::Ty(..)\n+            | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Struct(..)\n+            | hir::ItemKind::Union(..) => true,\n             _ => false\n         };\n         let ctor_id = get_struct_ctor_id(item);\n@@ -475,7 +475,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             && !has_allow_dead_code_or_lang_attr(self.tcx, field.id, &field.attrs)\n     }\n \n-    fn should_warn_about_variant(&mut self, variant: &hir::Variant_) -> bool {\n+    fn should_warn_about_variant(&mut self, variant: &hir::VariantKind) -> bool {\n         !self.symbol_is_live(variant.data.id(), None)\n             && !has_allow_dead_code_or_lang_attr(self.tcx,\n                                                  variant.data.id(),\n@@ -492,7 +492,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     //            `None` otherwise.\n     // If the item is a struct_ctor, then either its `id` or\n     // `ctor_id` (unwrapped) is in the live_symbols set. More specifically,\n-    // DefMap maps the ExprPath of a struct_ctor to the node referred by\n+    // DefMap maps the ExprKind::Path of a struct_ctor to the node referred by\n     // `ctor_id`. On the other hand, in a statement like\n     // `type <ident> <generics> = <ty>;` where <ty> refers to a struct_ctor,\n     // DefMap maps <ty> to `id` instead.\n@@ -554,13 +554,13 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n             // For items that have a definition with a signature followed by a\n             // block, point only at the signature.\n             let span = match item.node {\n-                hir::ItemFn(..) |\n-                hir::ItemMod(..) |\n-                hir::ItemEnum(..) |\n-                hir::ItemStruct(..) |\n-                hir::ItemUnion(..) |\n-                hir::ItemTrait(..) |\n-                hir::ItemImpl(..) => self.tcx.sess.codemap().def_span(item.span),\n+                hir::ItemKind::Fn(..) |\n+                hir::ItemKind::Mod(..) |\n+                hir::ItemKind::Enum(..) |\n+                hir::ItemKind::Struct(..) |\n+                hir::ItemKind::Union(..) |\n+                hir::ItemKind::Trait(..) |\n+                hir::ItemKind::Impl(..) => self.tcx.sess.codemap().def_span(item.span),\n                 _ => item.span,\n             };\n             self.warn_dead_code("}, {"sha": "feeb508d676c94e726a119e9e3f045de07c602a8", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -16,7 +16,7 @@ use syntax::ast::NodeId;\n use syntax::attr;\n use syntax::entry::EntryPointType;\n use syntax_pos::Span;\n-use hir::{Item, ItemFn, ImplItem, TraitItem};\n+use hir::{Item, ItemKind, ImplItem, TraitItem};\n use hir::itemlikevisit::ItemLikeVisitor;\n \n struct EntryContext<'a, 'tcx: 'a> {\n@@ -91,7 +91,7 @@ pub fn find_entry_point(session: &Session,\n // them in sync.\n fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n     match item.node {\n-        ItemFn(..) => {\n+        ItemKind::Fn(..) => {\n             if attr::contains_name(&item.attrs, \"start\") {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {"}, {"sha": "5beafe2b601bf0749dcd7a84d933766a2d1ba9cf", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -392,51 +392,51 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.walk_adjustment(expr);\n \n         match expr.node {\n-            hir::ExprPath(_) => { }\n+            hir::ExprKind::Path(_) => { }\n \n-            hir::ExprType(ref subexpr, _) => {\n+            hir::ExprKind::Type(ref subexpr, _) => {\n                 self.walk_expr(&subexpr)\n             }\n \n-            hir::ExprUnary(hir::UnDeref, ref base) => {      // *base\n+            hir::ExprKind::Unary(hir::UnDeref, ref base) => {      // *base\n                 self.select_from_expr(&base);\n             }\n \n-            hir::ExprField(ref base, _) => {         // base.f\n+            hir::ExprKind::Field(ref base, _) => {         // base.f\n                 self.select_from_expr(&base);\n             }\n \n-            hir::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n+            hir::ExprKind::Index(ref lhs, ref rhs) => {       // lhs[rhs]\n                 self.select_from_expr(&lhs);\n                 self.consume_expr(&rhs);\n             }\n \n-            hir::ExprCall(ref callee, ref args) => {    // callee(args)\n+            hir::ExprKind::Call(ref callee, ref args) => {    // callee(args)\n                 self.walk_callee(expr, &callee);\n                 self.consume_exprs(args);\n             }\n \n-            hir::ExprMethodCall(.., ref args) => { // callee.m(args)\n+            hir::ExprKind::MethodCall(.., ref args) => { // callee.m(args)\n                 self.consume_exprs(args);\n             }\n \n-            hir::ExprStruct(_, ref fields, ref opt_with) => {\n+            hir::ExprKind::Struct(_, ref fields, ref opt_with) => {\n                 self.walk_struct_expr(fields, opt_with);\n             }\n \n-            hir::ExprTup(ref exprs) => {\n+            hir::ExprKind::Tup(ref exprs) => {\n                 self.consume_exprs(exprs);\n             }\n \n-            hir::ExprIf(ref cond_expr, ref then_expr, ref opt_else_expr) => {\n+            hir::ExprKind::If(ref cond_expr, ref then_expr, ref opt_else_expr) => {\n                 self.consume_expr(&cond_expr);\n                 self.walk_expr(&then_expr);\n                 if let Some(ref else_expr) = *opt_else_expr {\n                     self.consume_expr(&else_expr);\n                 }\n             }\n \n-            hir::ExprMatch(ref discr, ref arms, _) => {\n+            hir::ExprKind::Match(ref discr, ref arms, _) => {\n                 let discr_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&discr)));\n                 let r = self.tcx().types.re_empty;\n                 self.borrow_expr(&discr, r, ty::ImmBorrow, MatchDiscriminant);\n@@ -449,11 +449,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            hir::ExprArray(ref exprs) => {\n+            hir::ExprKind::Array(ref exprs) => {\n                 self.consume_exprs(exprs);\n             }\n \n-            hir::ExprAddrOf(m, ref base) => {   // &base\n+            hir::ExprKind::AddrOf(m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = return_if_err!(self.mc.expr_ty(expr));\n@@ -463,7 +463,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            hir::ExprInlineAsm(ref ia, ref outputs, ref inputs) => {\n+            hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n                 for (o, output) in ia.outputs.iter().zip(outputs) {\n                     if o.is_indirect {\n                         self.consume_expr(output);\n@@ -479,47 +479,47 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_exprs(inputs);\n             }\n \n-            hir::ExprContinue(..) |\n-            hir::ExprLit(..) => {}\n+            hir::ExprKind::Continue(..) |\n+            hir::ExprKind::Lit(..) => {}\n \n-            hir::ExprLoop(ref blk, _, _) => {\n+            hir::ExprKind::Loop(ref blk, _, _) => {\n                 self.walk_block(&blk);\n             }\n \n-            hir::ExprWhile(ref cond_expr, ref blk, _) => {\n+            hir::ExprKind::While(ref cond_expr, ref blk, _) => {\n                 self.consume_expr(&cond_expr);\n                 self.walk_block(&blk);\n             }\n \n-            hir::ExprUnary(_, ref lhs) => {\n+            hir::ExprKind::Unary(_, ref lhs) => {\n                 self.consume_expr(&lhs);\n             }\n \n-            hir::ExprBinary(_, ref lhs, ref rhs) => {\n+            hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n                 self.consume_expr(&lhs);\n                 self.consume_expr(&rhs);\n             }\n \n-            hir::ExprBlock(ref blk, _) => {\n+            hir::ExprKind::Block(ref blk, _) => {\n                 self.walk_block(&blk);\n             }\n \n-            hir::ExprBreak(_, ref opt_expr) | hir::ExprRet(ref opt_expr) => {\n+            hir::ExprKind::Break(_, ref opt_expr) | hir::ExprKind::Ret(ref opt_expr) => {\n                 if let Some(ref expr) = *opt_expr {\n                     self.consume_expr(&expr);\n                 }\n             }\n \n-            hir::ExprAssign(ref lhs, ref rhs) => {\n+            hir::ExprKind::Assign(ref lhs, ref rhs) => {\n                 self.mutate_expr(expr, &lhs, MutateMode::JustWrite);\n                 self.consume_expr(&rhs);\n             }\n \n-            hir::ExprCast(ref base, _) => {\n+            hir::ExprKind::Cast(ref base, _) => {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n+            hir::ExprKind::AssignOp(_, ref lhs, ref rhs) => {\n                 if self.mc.tables.is_method_call(expr) {\n                     self.consume_expr(lhs);\n                 } else {\n@@ -528,19 +528,19 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_expr(&rhs);\n             }\n \n-            hir::ExprRepeat(ref base, _) => {\n+            hir::ExprKind::Repeat(ref base, _) => {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprClosure(.., fn_decl_span, _) => {\n+            hir::ExprKind::Closure(.., fn_decl_span, _) => {\n                 self.walk_captures(expr, fn_decl_span)\n             }\n \n-            hir::ExprBox(ref base) => {\n+            hir::ExprKind::Box(ref base) => {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprYield(ref value) => {\n+            hir::ExprKind::Yield(ref value) => {\n                 self.consume_expr(&value);\n             }\n         }\n@@ -586,21 +586,21 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n     fn walk_stmt(&mut self, stmt: &hir::Stmt) {\n         match stmt.node {\n-            hir::StmtDecl(ref decl, _) => {\n+            hir::StmtKind::Decl(ref decl, _) => {\n                 match decl.node {\n-                    hir::DeclLocal(ref local) => {\n+                    hir::DeclKind::Local(ref local) => {\n                         self.walk_local(&local);\n                     }\n \n-                    hir::DeclItem(_) => {\n+                    hir::DeclKind::Item(_) => {\n                         // we don't visit nested items in this visitor,\n                         // only the fn body we were given.\n                     }\n                 }\n             }\n \n-            hir::StmtExpr(ref expr, _) |\n-            hir::StmtSemi(ref expr, _) => {\n+            hir::StmtKind::Expr(ref expr, _) |\n+            hir::StmtKind::Semi(ref expr, _) => {\n                 self.consume_expr(&expr);\n             }\n         }"}, {"sha": "668bac1e4795b6671a693cd3fbb85732bf30d138", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        let def = if let hir::ExprPath(ref qpath) = expr.node {\n+        let def = if let hir::ExprKind::Path(ref qpath) = expr.node {\n             self.tables.qpath_def(qpath, expr.hir_id)\n         } else {\n             Def::Err"}, {"sha": "b828b1bd30a94be2a587b49a75ea546f4d222238", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 83, "deletions": 65, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -454,14 +454,14 @@ fn visit_arm<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, arm: &'tcx hir::Arm) {\n fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n-      hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+      hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, path.def);\n         if let Def::Local(..) = path.def {\n             ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         }\n         intravisit::walk_expr(ir, expr);\n       }\n-      hir::ExprClosure(..) => {\n+      hir::ExprKind::Closure(..) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n         ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n@@ -486,25 +486,43 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n       }\n \n       // live nodes required for interesting control flow:\n-      hir::ExprIf(..) | hir::ExprMatch(..) | hir::ExprWhile(..) | hir::ExprLoop(..) => {\n+      hir::ExprKind::If(..) |\n+      hir::ExprKind::Match(..) |\n+      hir::ExprKind::While(..) |\n+      hir::ExprKind::Loop(..) => {\n         ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         intravisit::walk_expr(ir, expr);\n       }\n-      hir::ExprBinary(op, ..) if op.node.is_lazy() => {\n+      hir::ExprKind::Binary(op, ..) if op.node.is_lazy() => {\n         ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         intravisit::walk_expr(ir, expr);\n       }\n \n       // otherwise, live nodes are not required:\n-      hir::ExprIndex(..) | hir::ExprField(..) |\n-      hir::ExprArray(..) | hir::ExprCall(..) | hir::ExprMethodCall(..) |\n-      hir::ExprTup(..) | hir::ExprBinary(..) | hir::ExprAddrOf(..) |\n-      hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprBreak(..) |\n-      hir::ExprContinue(_) | hir::ExprLit(_) | hir::ExprRet(..) |\n-      hir::ExprBlock(..) | hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n-      hir::ExprStruct(..) | hir::ExprRepeat(..) |\n-      hir::ExprInlineAsm(..) | hir::ExprBox(..) | hir::ExprYield(..) |\n-      hir::ExprType(..) | hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n+      hir::ExprKind::Index(..) |\n+      hir::ExprKind::Field(..) |\n+      hir::ExprKind::Array(..) |\n+      hir::ExprKind::Call(..) |\n+      hir::ExprKind::MethodCall(..) |\n+      hir::ExprKind::Tup(..) |\n+      hir::ExprKind::Binary(..) |\n+      hir::ExprKind::AddrOf(..) |\n+      hir::ExprKind::Cast(..) |\n+      hir::ExprKind::Unary(..) |\n+      hir::ExprKind::Break(..) |\n+      hir::ExprKind::Continue(_) |\n+      hir::ExprKind::Lit(_) |\n+      hir::ExprKind::Ret(..) |\n+      hir::ExprKind::Block(..) |\n+      hir::ExprKind::Assign(..) |\n+      hir::ExprKind::AssignOp(..) |\n+      hir::ExprKind::Struct(..) |\n+      hir::ExprKind::Repeat(..) |\n+      hir::ExprKind::InlineAsm(..) |\n+      hir::ExprKind::Box(..) |\n+      hir::ExprKind::Yield(..) |\n+      hir::ExprKind::Type(..) |\n+      hir::ExprKind::Path(hir::QPath::TypeRelative(..)) => {\n           intravisit::walk_expr(ir, expr);\n       }\n     }\n@@ -860,11 +878,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn propagate_through_stmt(&mut self, stmt: &hir::Stmt, succ: LiveNode)\n                               -> LiveNode {\n         match stmt.node {\n-            hir::StmtDecl(ref decl, _) => {\n+            hir::StmtKind::Decl(ref decl, _) => {\n                 self.propagate_through_decl(&decl, succ)\n             }\n \n-            hir::StmtExpr(ref expr, _) | hir::StmtSemi(ref expr, _) => {\n+            hir::StmtKind::Expr(ref expr, _) | hir::StmtKind::Semi(ref expr, _) => {\n                 self.propagate_through_expr(&expr, succ)\n             }\n         }\n@@ -873,10 +891,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn propagate_through_decl(&mut self, decl: &hir::Decl, succ: LiveNode)\n                               -> LiveNode {\n         match decl.node {\n-            hir::DeclLocal(ref local) => {\n+            hir::DeclKind::Local(ref local) => {\n                 self.propagate_through_local(&local, succ)\n             }\n-            hir::DeclItem(_) => succ,\n+            hir::DeclKind::Item(_) => succ,\n         }\n     }\n \n@@ -920,16 +938,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n-          hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+          hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n               self.access_path(expr.hir_id, path, succ, ACC_READ | ACC_USE)\n           }\n \n-          hir::ExprField(ref e, _) => {\n+          hir::ExprKind::Field(ref e, _) => {\n               self.propagate_through_expr(&e, succ)\n           }\n \n-          hir::ExprClosure(.., blk_id, _, _) => {\n-              debug!(\"{} is an ExprClosure\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n+          hir::ExprKind::Closure(.., blk_id, _, _) => {\n+              debug!(\"{} is an ExprKind::Closure\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n \n               // The next-node for a break is the successor of the entire\n               // loop. The next-node for a continue is the top of this loop.\n@@ -956,7 +974,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               })\n           }\n \n-          hir::ExprIf(ref cond, ref then, ref els) => {\n+          hir::ExprKind::If(ref cond, ref then, ref els) => {\n             //\n             //     (cond)\n             //       |\n@@ -978,17 +996,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&cond, ln)\n           }\n \n-          hir::ExprWhile(ref cond, ref blk, _) => {\n+          hir::ExprKind::While(ref cond, ref blk, _) => {\n             self.propagate_through_loop(expr, WhileLoop(&cond), &blk, succ)\n           }\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n-          hir::ExprLoop(ref blk, _, _) => {\n+          hir::ExprKind::Loop(ref blk, _, _) => {\n             self.propagate_through_loop(expr, LoopLoop, &blk, succ)\n           }\n \n-          hir::ExprMatch(ref e, ref arms, _) => {\n+          hir::ExprKind::Match(ref e, ref arms, _) => {\n             //\n             //      (e)\n             //       |\n@@ -1023,13 +1041,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&e, ln)\n           }\n \n-          hir::ExprRet(ref o_e) => {\n+          hir::ExprKind::Ret(ref o_e) => {\n             // ignore succ and subst exit_ln:\n             let exit_ln = self.s.exit_ln;\n             self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n           }\n \n-          hir::ExprBreak(label, ref opt_expr) => {\n+          hir::ExprKind::Break(label, ref opt_expr) => {\n               // Find which label this break jumps to\n               let target = match label.target_id {\n                     Ok(node_id) => self.break_ln.get(&node_id),\n@@ -1045,7 +1063,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               }\n           }\n \n-          hir::ExprContinue(label) => {\n+          hir::ExprKind::Continue(label) => {\n               // Find which label this expr continues to\n               let sc = match label.target_id {\n                     Ok(node_id) => node_id,\n@@ -1061,15 +1079,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               }\n           }\n \n-          hir::ExprAssign(ref l, ref r) => {\n+          hir::ExprKind::Assign(ref l, ref r) => {\n             // see comment on places in\n             // propagate_through_place_components()\n             let succ = self.write_place(&l, succ, ACC_WRITE);\n             let succ = self.propagate_through_place_components(&l, succ);\n             self.propagate_through_expr(&r, succ)\n           }\n \n-          hir::ExprAssignOp(_, ref l, ref r) => {\n+          hir::ExprKind::AssignOp(_, ref l, ref r) => {\n             // an overloaded assign op is like a method call\n             if self.tables.is_method_call(expr) {\n                 let succ = self.propagate_through_expr(&l, succ);\n@@ -1085,18 +1103,18 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           // Uninteresting cases: just propagate in rev exec order\n \n-          hir::ExprArray(ref exprs) => {\n+          hir::ExprKind::Array(ref exprs) => {\n             self.propagate_through_exprs(exprs, succ)\n           }\n \n-          hir::ExprStruct(_, ref fields, ref with_expr) => {\n+          hir::ExprKind::Struct(_, ref fields, ref with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr.as_ref().map(|e| &**e), succ);\n             fields.iter().rev().fold(succ, |succ, field| {\n                 self.propagate_through_expr(&field.expr, succ)\n             })\n           }\n \n-          hir::ExprCall(ref f, ref args) => {\n+          hir::ExprKind::Call(ref f, ref args) => {\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n             let succ = if self.tables.expr_ty(expr).is_never() {\n                 self.s.exit_ln\n@@ -1107,7 +1125,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&f, succ)\n           }\n \n-          hir::ExprMethodCall(.., ref args) => {\n+          hir::ExprKind::MethodCall(.., ref args) => {\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n             let succ = if self.tables.expr_ty(expr).is_never() {\n                 self.s.exit_ln\n@@ -1117,11 +1135,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(args, succ)\n           }\n \n-          hir::ExprTup(ref exprs) => {\n+          hir::ExprKind::Tup(ref exprs) => {\n             self.propagate_through_exprs(exprs, succ)\n           }\n \n-          hir::ExprBinary(op, ref l, ref r) if op.node.is_lazy() => {\n+          hir::ExprKind::Binary(op, ref l, ref r) if op.node.is_lazy() => {\n             let r_succ = self.propagate_through_expr(&r, succ);\n \n             let ln = self.live_node(expr.hir_id, expr.span);\n@@ -1131,23 +1149,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&l, ln)\n           }\n \n-          hir::ExprIndex(ref l, ref r) |\n-          hir::ExprBinary(_, ref l, ref r) => {\n+          hir::ExprKind::Index(ref l, ref r) |\n+          hir::ExprKind::Binary(_, ref l, ref r) => {\n             let r_succ = self.propagate_through_expr(&r, succ);\n             self.propagate_through_expr(&l, r_succ)\n           }\n \n-          hir::ExprBox(ref e) |\n-          hir::ExprAddrOf(_, ref e) |\n-          hir::ExprCast(ref e, _) |\n-          hir::ExprType(ref e, _) |\n-          hir::ExprUnary(_, ref e) |\n-          hir::ExprYield(ref e) |\n-          hir::ExprRepeat(ref e, _) => {\n+          hir::ExprKind::Box(ref e) |\n+          hir::ExprKind::AddrOf(_, ref e) |\n+          hir::ExprKind::Cast(ref e, _) |\n+          hir::ExprKind::Type(ref e, _) |\n+          hir::ExprKind::Unary(_, ref e) |\n+          hir::ExprKind::Yield(ref e) |\n+          hir::ExprKind::Repeat(ref e, _) => {\n             self.propagate_through_expr(&e, succ)\n           }\n \n-          hir::ExprInlineAsm(ref ia, ref outputs, ref inputs) => {\n+          hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n             let succ = ia.outputs.iter().zip(outputs).rev().fold(succ, |succ, (o, output)| {\n                 // see comment on places\n                 // in propagate_through_place_components()\n@@ -1164,13 +1182,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(inputs, succ)\n           }\n \n-          hir::ExprLit(..) | hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n+          hir::ExprKind::Lit(..) | hir::ExprKind::Path(hir::QPath::TypeRelative(..)) => {\n             succ\n           }\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n-          hir::ExprBlock(ref blk, _) => {\n+          hir::ExprKind::Block(ref blk, _) => {\n             self.propagate_through_block(&blk, succ)\n           }\n         }\n@@ -1230,8 +1248,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // just ignore such cases and treat them as reads.\n \n         match expr.node {\n-            hir::ExprPath(_) => succ,\n-            hir::ExprField(ref e, _) => self.propagate_through_expr(&e, succ),\n+            hir::ExprKind::Path(_) => succ,\n+            hir::ExprKind::Field(ref e, _) => self.propagate_through_expr(&e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n         }\n     }\n@@ -1240,7 +1258,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn write_place(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                     -> LiveNode {\n         match expr.node {\n-          hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+          hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n               self.access_path(expr.hir_id, path, succ, acc)\n           }\n \n@@ -1393,21 +1411,21 @@ fn check_arm<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, arm: &'tcx hir::Arm) {\n \n fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n-      hir::ExprAssign(ref l, _) => {\n+      hir::ExprKind::Assign(ref l, _) => {\n         this.check_place(&l);\n \n         intravisit::walk_expr(this, expr);\n       }\n \n-      hir::ExprAssignOp(_, ref l, _) => {\n+      hir::ExprKind::AssignOp(_, ref l, _) => {\n         if !this.tables.is_method_call(expr) {\n             this.check_place(&l);\n         }\n \n         intravisit::walk_expr(this, expr);\n       }\n \n-      hir::ExprInlineAsm(ref ia, ref outputs, ref inputs) => {\n+      hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n         for input in inputs {\n           this.visit_expr(input);\n         }\n@@ -1424,16 +1442,16 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n       }\n \n       // no correctness conditions related to liveness\n-      hir::ExprCall(..) | hir::ExprMethodCall(..) | hir::ExprIf(..) |\n-      hir::ExprMatch(..) | hir::ExprWhile(..) | hir::ExprLoop(..) |\n-      hir::ExprIndex(..) | hir::ExprField(..) |\n-      hir::ExprArray(..) | hir::ExprTup(..) | hir::ExprBinary(..) |\n-      hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprRet(..) |\n-      hir::ExprBreak(..) | hir::ExprContinue(..) | hir::ExprLit(_) |\n-      hir::ExprBlock(..) | hir::ExprAddrOf(..) |\n-      hir::ExprStruct(..) | hir::ExprRepeat(..) |\n-      hir::ExprClosure(..) | hir::ExprPath(_) | hir::ExprYield(..) |\n-      hir::ExprBox(..) | hir::ExprType(..) => {\n+      hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) | hir::ExprKind::If(..) |\n+      hir::ExprKind::Match(..) | hir::ExprKind::While(..) | hir::ExprKind::Loop(..) |\n+      hir::ExprKind::Index(..) | hir::ExprKind::Field(..) |\n+      hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::Binary(..) |\n+      hir::ExprKind::Cast(..) | hir::ExprKind::Unary(..) | hir::ExprKind::Ret(..) |\n+      hir::ExprKind::Break(..) | hir::ExprKind::Continue(..) | hir::ExprKind::Lit(_) |\n+      hir::ExprKind::Block(..) | hir::ExprKind::AddrOf(..) |\n+      hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n+      hir::ExprKind::Closure(..) | hir::ExprKind::Path(_) | hir::ExprKind::Yield(..) |\n+      hir::ExprKind::Box(..) | hir::ExprKind::Type(..) => {\n         intravisit::walk_expr(this, expr);\n       }\n     }\n@@ -1442,7 +1460,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_place(&mut self, expr: &'tcx Expr) {\n         match expr.node {\n-            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+            hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 if let Def::Local(nid) = path.def {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually"}, {"sha": "0602dc55c43d608629025a5121ad29be61a9c362", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -639,7 +639,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         let expr_ty = self.expr_ty(expr)?;\n         match expr.node {\n-          hir::ExprUnary(hir::UnDeref, ref e_base) => {\n+          hir::ExprKind::Unary(hir::UnDeref, ref e_base) => {\n             if self.tables.is_method_call(expr) {\n                 self.cat_overloaded_place(expr, e_base, NoteNone)\n             } else {\n@@ -648,7 +648,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          hir::ExprField(ref base, f_ident) => {\n+          hir::ExprKind::Field(ref base, f_ident) => {\n             let base_cmt = Rc::new(self.cat_expr(&base)?);\n             debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n                    expr.id,\n@@ -658,7 +658,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             Ok(self.cat_field(expr, base_cmt, f_index, f_ident, expr_ty))\n           }\n \n-          hir::ExprIndex(ref base, _) => {\n+          hir::ExprKind::Index(ref base, _) => {\n             if self.tables.is_method_call(expr) {\n                 // If this is an index implemented by a method call, then it\n                 // will include an implicit deref of the result.\n@@ -672,26 +672,26 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          hir::ExprPath(ref qpath) => {\n+          hir::ExprKind::Path(ref qpath) => {\n               let def = self.tables.qpath_def(qpath, expr.hir_id);\n               self.cat_def(expr.hir_id, expr.span, expr_ty, def)\n           }\n \n-          hir::ExprType(ref e, _) => {\n+          hir::ExprKind::Type(ref e, _) => {\n             self.cat_expr(&e)\n           }\n \n-          hir::ExprAddrOf(..) | hir::ExprCall(..) |\n-          hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n-          hir::ExprClosure(..) | hir::ExprRet(..) |\n-          hir::ExprUnary(..) | hir::ExprYield(..) |\n-          hir::ExprMethodCall(..) | hir::ExprCast(..) |\n-          hir::ExprArray(..) | hir::ExprTup(..) | hir::ExprIf(..) |\n-          hir::ExprBinary(..) | hir::ExprWhile(..) |\n-          hir::ExprBlock(..) | hir::ExprLoop(..) | hir::ExprMatch(..) |\n-          hir::ExprLit(..) | hir::ExprBreak(..) |\n-          hir::ExprContinue(..) | hir::ExprStruct(..) | hir::ExprRepeat(..) |\n-          hir::ExprInlineAsm(..) | hir::ExprBox(..) => {\n+          hir::ExprKind::AddrOf(..) | hir::ExprKind::Call(..) |\n+          hir::ExprKind::Assign(..) | hir::ExprKind::AssignOp(..) |\n+          hir::ExprKind::Closure(..) | hir::ExprKind::Ret(..) |\n+          hir::ExprKind::Unary(..) | hir::ExprKind::Yield(..) |\n+          hir::ExprKind::MethodCall(..) | hir::ExprKind::Cast(..) |\n+          hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::If(..) |\n+          hir::ExprKind::Binary(..) | hir::ExprKind::While(..) |\n+          hir::ExprKind::Block(..) | hir::ExprKind::Loop(..) | hir::ExprKind::Match(..) |\n+          hir::ExprKind::Lit(..) | hir::ExprKind::Break(..) |\n+          hir::ExprKind::Continue(..) | hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n+          hir::ExprKind::InlineAsm(..) | hir::ExprKind::Box(..) => {\n             Ok(self.cat_rvalue_node(expr.hir_id, expr.span, expr_ty))\n           }\n         }"}, {"sha": "a504697008ef4b93de0fa81fca11b6f7088ef870", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -58,8 +58,8 @@ fn item_might_be_inlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     match item.node {\n-        hir::ItemImpl(..) |\n-        hir::ItemFn(..) => {\n+        hir::ItemKind::Impl(..) |\n+        hir::ItemKind::Fn(..) => {\n             let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n             generics_require_inlining(generics)\n         }\n@@ -116,10 +116,10 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         let def = match expr.node {\n-            hir::ExprPath(ref qpath) => {\n+            hir::ExprKind::Path(ref qpath) => {\n                 Some(self.tables.qpath_def(qpath, expr.hir_id))\n             }\n-            hir::ExprMethodCall(..) => {\n+            hir::ExprKind::MethodCall(..) => {\n                 self.tables.type_dependent_defs().get(expr.hir_id).cloned()\n             }\n             _ => None\n@@ -171,7 +171,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match self.tcx.hir.find(node_id) {\n             Some(hir_map::NodeItem(item)) => {\n                 match item.node {\n-                    hir::ItemFn(..) =>\n+                    hir::ItemKind::Fn(..) =>\n                         item_might_be_inlined(self.tcx, &item, self.tcx.codegen_fn_attrs(def_id)),\n                     _ => false,\n                 }\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // does too.\n                             let impl_node_id = self.tcx.hir.as_local_node_id(impl_did).unwrap();\n                             match self.tcx.hir.expect_item(impl_node_id).node {\n-                                hir::ItemImpl(..) => {\n+                                hir::ItemKind::Impl(..) => {\n                                     let generics = self.tcx.generics_of(impl_did);\n                                     generics_require_inlining(&generics)\n                                 }\n@@ -238,7 +238,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n             if let hir_map::NodeItem(item) = *node {\n-                let reachable = if let hir::ItemFn(_, header, ..) = item.node {\n+                let reachable = if let hir::ItemKind::Fn(_, header, ..) = item.node {\n                     header.abi != Abi::Rust\n                 } else {\n                     false\n@@ -260,7 +260,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match *node {\n             hir_map::NodeItem(item) => {\n                 match item.node {\n-                    hir::ItemFn(.., body) => {\n+                    hir::ItemKind::Fn(.., body) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n                         if item_might_be_inlined(self.tcx,\n                                                  &item,\n@@ -272,20 +272,27 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     // Reachable constants will be inlined into other crates\n                     // unconditionally, so we need to make sure that their\n                     // contents are also reachable.\n-                    hir::ItemConst(_, init) => {\n+                    hir::ItemKind::Const(_, init) => {\n                         self.visit_nested_body(init);\n                     }\n \n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n-                    hir::ItemExternCrate(_) | hir::ItemUse(..) |\n-                    hir::ItemExistential(..) |\n-                    hir::ItemTy(..) | hir::ItemStatic(..) |\n-                    hir::ItemMod(..) | hir::ItemForeignMod(..) |\n-                    hir::ItemImpl(..) | hir::ItemTrait(..) | hir::ItemTraitAlias(..) |\n-                    hir::ItemStruct(..) | hir::ItemEnum(..) |\n-                    hir::ItemUnion(..) |  hir::ItemGlobalAsm(..) => {}\n+                    hir::ItemKind::ExternCrate(_) |\n+                    hir::ItemKind::Use(..) |\n+                    hir::ItemKind::Existential(..) |\n+                    hir::ItemKind::Ty(..) |\n+                    hir::ItemKind::Static(..) |\n+                    hir::ItemKind::Mod(..) |\n+                    hir::ItemKind::ForeignMod(..) |\n+                    hir::ItemKind::Impl(..) |\n+                    hir::ItemKind::Trait(..) |\n+                    hir::ItemKind::TraitAlias(..) |\n+                    hir::ItemKind::Struct(..) |\n+                    hir::ItemKind::Enum(..) |\n+                    hir::ItemKind::Union(..) |\n+                    hir::ItemKind::GlobalAsm(..) => {}\n                 }\n             }\n             hir_map::NodeTraitItem(trait_method) => {\n@@ -315,7 +322,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Type(_) => {}\n                 }\n             }\n-            hir_map::NodeExpr(&hir::Expr { node: hir::ExprClosure(.., body, _, _), .. }) => {\n+            hir_map::NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n                 self.visit_nested_body(body);\n             }\n             // Nothing to recurse on for these\n@@ -356,7 +363,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n         }\n \n         // We need only trait impls here, not inherent impls, and only non-exported ones\n-        if let hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n+        if let hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n             if !self.access_levels.is_reachable(item.id) {\n                 for impl_item_ref in impl_item_refs {\n                     self.worklist.push(impl_item_ref.id.node_id);"}, {"sha": "ebdc9c922b1dff3b300289e393bbf88e35276032", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -858,8 +858,8 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n         // index information.)\n \n         for (i, statement) in blk.stmts.iter().enumerate() {\n-            if let hir::StmtDecl(..) = statement.node {\n-                // Each StmtDecl introduces a subscope for bindings\n+            if let hir::StmtKind::Decl(..) = statement.node {\n+                // Each StmtKind::Decl introduces a subscope for bindings\n                 // introduced by the declaration; this subscope covers\n                 // a suffix of the block . Each subscope in a block\n                 // has the previous subscope in the block as a parent,\n@@ -943,39 +943,39 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n             // scopes, meaning that temporaries cannot outlive them.\n             // This ensures fixed size stacks.\n \n-            hir::ExprBinary(codemap::Spanned { node: hir::BiAnd, .. }, _, ref r) |\n-            hir::ExprBinary(codemap::Spanned { node: hir::BiOr, .. }, _, ref r) => {\n+            hir::ExprKind::Binary(codemap::Spanned { node: hir::BinOpKind::And, .. }, _, ref r) |\n+            hir::ExprKind::Binary(codemap::Spanned { node: hir::BinOpKind::Or, .. }, _, ref r) => {\n                 // For shortcircuiting operators, mark the RHS as a terminating\n                 // scope since it only executes conditionally.\n                 terminating(r.hir_id.local_id);\n             }\n \n-            hir::ExprIf(ref expr, ref then, Some(ref otherwise)) => {\n+            hir::ExprKind::If(ref expr, ref then, Some(ref otherwise)) => {\n                 terminating(expr.hir_id.local_id);\n                 terminating(then.hir_id.local_id);\n                 terminating(otherwise.hir_id.local_id);\n             }\n \n-            hir::ExprIf(ref expr, ref then, None) => {\n+            hir::ExprKind::If(ref expr, ref then, None) => {\n                 terminating(expr.hir_id.local_id);\n                 terminating(then.hir_id.local_id);\n             }\n \n-            hir::ExprLoop(ref body, _, _) => {\n+            hir::ExprKind::Loop(ref body, _, _) => {\n                 terminating(body.hir_id.local_id);\n             }\n \n-            hir::ExprWhile(ref expr, ref body, _) => {\n+            hir::ExprKind::While(ref expr, ref body, _) => {\n                 terminating(expr.hir_id.local_id);\n                 terminating(body.hir_id.local_id);\n             }\n \n-            hir::ExprMatch(..) => {\n+            hir::ExprKind::Match(..) => {\n                 visitor.cx.var_parent = visitor.cx.parent;\n             }\n \n-            hir::ExprAssignOp(..) | hir::ExprIndex(..) |\n-            hir::ExprUnary(..) | hir::ExprCall(..) | hir::ExprMethodCall(..) => {\n+            hir::ExprKind::AssignOp(..) | hir::ExprKind::Index(..) |\n+            hir::ExprKind::Unary(..) | hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) => {\n                 // FIXME(https://github.com/rust-lang/rfcs/issues/811) Nested method calls\n                 //\n                 // The lifetimes for a call or method call look as follows:\n@@ -1003,7 +1003,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n     match expr.node {\n         // Manually recurse over closures, because they are the only\n         // case of nested bodies that share the parent environment.\n-        hir::ExprClosure(.., body, _, _) => {\n+        hir::ExprKind::Closure(.., body, _, _) => {\n             let body = visitor.tcx.hir.body(body);\n             visitor.visit_body(body);\n         }\n@@ -1015,7 +1015,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n \n     debug!(\"resolve_expr post-increment {}, expr = {:?}\", visitor.expr_and_pat_count, expr);\n \n-    if let hir::ExprYield(..) = expr.node {\n+    if let hir::ExprKind::Yield(..) = expr.node {\n         // Mark this expr's scope and all parent scopes as containing `yield`.\n         let mut scope = Scope::Node(expr.hir_id.local_id);\n         loop {\n@@ -1193,27 +1193,27 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         blk_id: Option<Scope>)\n     {\n         match expr.node {\n-            hir::ExprAddrOf(_, ref subexpr) => {\n+            hir::ExprKind::AddrOf(_, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 record_rvalue_scope(visitor, &subexpr, blk_id);\n             }\n-            hir::ExprStruct(_, ref fields, _) => {\n+            hir::ExprKind::Struct(_, ref fields, _) => {\n                 for field in fields {\n                     record_rvalue_scope_if_borrow_expr(\n                         visitor, &field.expr, blk_id);\n                 }\n             }\n-            hir::ExprArray(ref subexprs) |\n-            hir::ExprTup(ref subexprs) => {\n+            hir::ExprKind::Array(ref subexprs) |\n+            hir::ExprKind::Tup(ref subexprs) => {\n                 for subexpr in subexprs {\n                     record_rvalue_scope_if_borrow_expr(\n                         visitor, &subexpr, blk_id);\n                 }\n             }\n-            hir::ExprCast(ref subexpr, _) => {\n+            hir::ExprKind::Cast(ref subexpr, _) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id)\n             }\n-            hir::ExprBlock(ref block, _) => {\n+            hir::ExprKind::Block(ref block, _) => {\n                 if let Some(ref subexpr) = block.expr {\n                     record_rvalue_scope_if_borrow_expr(\n                         visitor, &subexpr, blk_id);\n@@ -1251,10 +1251,10 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n             visitor.scope_tree.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n \n             match expr.node {\n-                hir::ExprAddrOf(_, ref subexpr) |\n-                hir::ExprUnary(hir::UnDeref, ref subexpr) |\n-                hir::ExprField(ref subexpr, _) |\n-                hir::ExprIndex(ref subexpr, _) => {\n+                hir::ExprKind::AddrOf(_, ref subexpr) |\n+                hir::ExprKind::Unary(hir::UnDeref, ref subexpr) |\n+                hir::ExprKind::Field(ref subexpr, _) |\n+                hir::ExprKind::Index(ref subexpr, _) => {\n                     expr = &subexpr;\n                 }\n                 _ => {"}, {"sha": "05a6cd9c243d25c1e5d69a40c4ea5f4927a34820", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -476,49 +476,49 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            hir::ItemFn(ref decl, _, ref generics, _) => {\n+            hir::ItemKind::Fn(ref decl, _, ref generics, _) => {\n                 self.visit_early_late(None, decl, generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n             }\n \n-            hir::ItemExternCrate(_)\n-            | hir::ItemUse(..)\n-            | hir::ItemMod(..)\n-            | hir::ItemForeignMod(..)\n-            | hir::ItemGlobalAsm(..) => {\n+            hir::ItemKind::ExternCrate(_)\n+            | hir::ItemKind::Use(..)\n+            | hir::ItemKind::Mod(..)\n+            | hir::ItemKind::ForeignMod(..)\n+            | hir::ItemKind::GlobalAsm(..) => {\n                 // These sorts of items have no lifetime parameters at all.\n                 intravisit::walk_item(self, item);\n             }\n-            hir::ItemStatic(..) | hir::ItemConst(..) => {\n+            hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => {\n                 // No lifetime parameters, but implied 'static.\n                 let scope = Scope::Elision {\n                     elide: Elide::Exact(Region::Static),\n                     s: ROOT_SCOPE,\n                 };\n                 self.with(scope, |_, this| intravisit::walk_item(this, item));\n             }\n-            hir::ItemExistential(hir::ExistTy { impl_trait_fn: Some(_), .. }) => {\n+            hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: Some(_), .. }) => {\n                 // currently existential type declarations are just generated from impl Trait\n                 // items. doing anything on this node is irrelevant, as we currently don't need\n                 // it.\n             }\n-            hir::ItemTy(_, ref generics)\n-            | hir::ItemExistential(hir::ExistTy { impl_trait_fn: None, ref generics, .. })\n-            | hir::ItemEnum(_, ref generics)\n-            | hir::ItemStruct(_, ref generics)\n-            | hir::ItemUnion(_, ref generics)\n-            | hir::ItemTrait(_, _, ref generics, ..)\n-            | hir::ItemTraitAlias(ref generics, ..)\n-            | hir::ItemImpl(_, _, _, ref generics, ..) => {\n+            hir::ItemKind::Ty(_, ref generics)\n+            | hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: None, ref generics, .. })\n+            | hir::ItemKind::Enum(_, ref generics)\n+            | hir::ItemKind::Struct(_, ref generics)\n+            | hir::ItemKind::Union(_, ref generics)\n+            | hir::ItemKind::Trait(_, _, ref generics, ..)\n+            | hir::ItemKind::TraitAlias(ref generics, ..)\n+            | hir::ItemKind::Impl(_, _, _, ref generics, ..) => {\n                 // Impls permit `'_` to be used and it is equivalent to \"some fresh lifetime name\".\n                 // This is not true for other kinds of items.x\n                 let track_lifetime_uses = match item.node {\n-                    hir::ItemImpl(..) => true,\n+                    hir::ItemKind::Impl(..) => true,\n                     _ => false,\n                 };\n                 // These kinds of items have only early bound lifetime parameters.\n-                let mut index = if let hir::ItemTrait(..) = item.node {\n+                let mut index = if let hir::ItemKind::Trait(..) = item.node {\n                     1 // Self comes before lifetimes\n                 } else {\n                     0\n@@ -550,15 +550,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n         match item.node {\n-            hir::ForeignItemFn(ref decl, _, ref generics) => {\n+            hir::ForeignItemKind::Fn(ref decl, _, ref generics) => {\n                 self.visit_early_late(None, decl, generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n                 })\n             }\n-            hir::ForeignItemStatic(..) => {\n+            hir::ForeignItemKind::Static(..) => {\n                 intravisit::walk_foreign_item(self, item);\n             }\n-            hir::ForeignItemType => {\n+            hir::ForeignItemKind::Type => {\n                 intravisit::walk_foreign_item(self, item);\n             }\n         }\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         debug!(\"visit_ty: id={:?} ty={:?}\", ty.id, ty);\n         match ty.node {\n-            hir::TyBareFn(ref c) => {\n+            hir::TyKind::BareFn(ref c) => {\n                 let next_early_index = self.next_early_index();\n                 let was_in_fn_syntax = self.is_in_fn_syntax;\n                 self.is_in_fn_syntax = true;\n@@ -591,7 +591,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 });\n                 self.is_in_fn_syntax = was_in_fn_syntax;\n             }\n-            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+            hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n                 for bound in bounds {\n                     self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                 }\n@@ -617,15 +617,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::TyRptr(ref lifetime_ref, ref mt) => {\n+            hir::TyKind::Rptr(ref lifetime_ref, ref mt) => {\n                 self.visit_lifetime(lifetime_ref);\n                 let scope = Scope::ObjectLifetimeDefault {\n                     lifetime: self.map.defs.get(&lifetime_ref.id).cloned(),\n                     s: self.scope,\n                 };\n                 self.with(scope, |_, this| this.visit_ty(&mt.ty));\n             }\n-            hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n+            hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                 if let Def::Existential(exist_ty_did) = path.def {\n                     assert!(exist_ty_did.is_local());\n                     // Resolve the lifetimes that are applied to the existential type.\n@@ -675,7 +675,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     //                          ^            ^ this gets resolved in the scope of\n                     //                                         the exist_ty generics\n                     let (generics, bounds) = match self.tcx.hir.expect_item(id).node {\n-                        hir::ItemExistential(hir::ExistTy{ ref generics, ref bounds, .. }) => (\n+                        hir::ItemKind::Existential(\n+                            hir::ExistTy { ref generics, ref bounds, .. }\n+                        ) => (\n                             generics,\n                             bounds,\n                         ),\n@@ -1157,8 +1159,8 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n \n     fn expression_label(ex: &hir::Expr) -> Option<ast::Ident> {\n         match ex.node {\n-            hir::ExprWhile(.., Some(label)) |\n-            hir::ExprLoop(_, Some(label), _) => Some(label.ident),\n+            hir::ExprKind::While(.., Some(label)) |\n+            hir::ExprKind::Loop(_, Some(label), _) => Some(label.ident),\n             _ => None,\n         }\n     }\n@@ -1208,11 +1210,11 @@ fn compute_object_lifetime_defaults(\n     let mut map = NodeMap();\n     for item in tcx.hir.krate().items.values() {\n         match item.node {\n-            hir::ItemStruct(_, ref generics)\n-            | hir::ItemUnion(_, ref generics)\n-            | hir::ItemEnum(_, ref generics)\n-            | hir::ItemTy(_, ref generics)\n-            | hir::ItemTrait(_, _, ref generics, ..) => {\n+            hir::ItemKind::Struct(_, ref generics)\n+            | hir::ItemKind::Union(_, ref generics)\n+            | hir::ItemKind::Enum(_, ref generics)\n+            | hir::ItemKind::Ty(_, ref generics)\n+            | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n                 let result = object_lifetime_defaults_for_item(tcx, generics);\n \n                 // Debugging aid.\n@@ -1287,7 +1289,7 @@ fn object_lifetime_defaults_for_item(\n                 }\n \n                 let def = match data.bounded_ty.node {\n-                    hir::TyPath(hir::QPath::Resolved(None, ref path)) => path.def,\n+                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.def,\n                     _ => continue,\n                 };\n \n@@ -1485,12 +1487,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n             let parent = self.tcx.hir.expect_item(parent_id);\n-            if let hir::ItemTrait(..) = parent.node {\n+            if let hir::ItemKind::Trait(..) = parent.node {\n                 index += 1; // Self comes first.\n             }\n             match parent.node {\n-                hir::ItemTrait(_, _, ref generics, ..)\n-                | hir::ItemImpl(_, _, _, ref generics, ..) => {\n+                hir::ItemKind::Trait(_, _, ref generics, ..)\n+                | hir::ItemKind::Impl(_, _, _, ref generics, ..) => {\n                     index += generics.params.len() as u32;\n                 }\n                 _ => {}\n@@ -1609,7 +1611,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 let fn_id = self.tcx.hir.body_owner(body_id);\n                 match self.tcx.hir.get(fn_id) {\n                     hir::map::NodeItem(&hir::Item {\n-                        node: hir::ItemFn(..),\n+                        node: hir::ItemKind::Fn(..),\n                         ..\n                     })\n                     | hir::map::NodeTraitItem(&hir::TraitItem {\n@@ -1834,7 +1836,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let body = match self.tcx.hir.get(parent) {\n             // `fn` definitions and methods.\n             hir::map::NodeItem(&hir::Item {\n-                node: hir::ItemFn(.., body),\n+                node: hir::ItemKind::Fn(.., body),\n                 ..\n             }) => Some(body),\n \n@@ -1847,7 +1849,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     .expect_item(self.tcx.hir.get_parent(parent))\n                     .node\n                 {\n-                    hir::ItemTrait(.., ref trait_items) => {\n+                    hir::ItemKind::Trait(.., ref trait_items) => {\n                         assoc_item_kind = trait_items\n                             .iter()\n                             .find(|ti| ti.id.node_id == parent)\n@@ -1870,7 +1872,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     .expect_item(self.tcx.hir.get_parent(parent))\n                     .node\n                 {\n-                    hir::ItemImpl(.., ref self_ty, ref impl_items) => {\n+                    hir::ItemKind::Impl(.., ref self_ty, ref impl_items) => {\n                         impl_self = Some(self_ty);\n                         assoc_item_kind = impl_items\n                             .iter()\n@@ -1912,7 +1914,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 // Can't always rely on literal (or implied) `Self` due\n                 // to the way elision rules were originally specified.\n                 let impl_self = impl_self.map(|ty| &ty.node);\n-                if let Some(&hir::TyPath(hir::QPath::Resolved(None, ref path))) = impl_self {\n+                if let Some(&hir::TyKind::Path(hir::QPath::Resolved(None, ref path))) = impl_self {\n                     match path.def {\n                         // Whitelist the types that unambiguously always\n                         // result in the same type constructor being used\n@@ -1927,8 +1929,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 false\n             };\n \n-            if let hir::TyRptr(lifetime_ref, ref mt) = inputs[0].node {\n-                if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = mt.ty.node {\n+            if let hir::TyKind::Rptr(lifetime_ref, ref mt) = inputs[0].node {\n+                if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.node {\n                     if is_self_ty(path.def) {\n                         if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n                             let scope = Scope::Elision {\n@@ -2007,10 +2009,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             fn visit_ty(&mut self, ty: &hir::Ty) {\n-                if let hir::TyBareFn(_) = ty.node {\n+                if let hir::TyKind::BareFn(_) = ty.node {\n                     self.outer_index.shift_in(1);\n                 }\n-                if let hir::TyTraitObject(ref bounds, ref lifetime) = ty.node {\n+                if let hir::TyKind::TraitObject(ref bounds, ref lifetime) = ty.node {\n                     for bound in bounds {\n                         self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                     }\n@@ -2023,7 +2025,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 } else {\n                     intravisit::walk_ty(self, ty);\n                 }\n-                if let hir::TyBareFn(_) = ty.node {\n+                if let hir::TyKind::BareFn(_) = ty.node {\n                     self.outer_index.shift_out(1);\n                 }\n             }\n@@ -2578,14 +2580,14 @@ fn insert_late_bound_lifetimes(\n \n         fn visit_ty(&mut self, ty: &'v hir::Ty) {\n             match ty.node {\n-                hir::TyPath(hir::QPath::Resolved(Some(_), _))\n-                | hir::TyPath(hir::QPath::TypeRelative(..)) => {\n+                hir::TyKind::Path(hir::QPath::Resolved(Some(_), _))\n+                | hir::TyKind::Path(hir::QPath::TypeRelative(..)) => {\n                     // ignore lifetimes appearing in associated type\n                     // projections, as they are not *constrained*\n                     // (defined above)\n                 }\n \n-                hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n+                hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                     // consider only the lifetimes on the final\n                     // segment; I am not sure it's even currently\n                     // valid to have them elsewhere, but even if it"}, {"sha": "fdcae38fc6a7cfd6e1ad082390ac273b80c70c75", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -263,14 +263,14 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             // they don't have their own stability. They still can be annotated as unstable\n             // and propagate this unstability to children, but this annotation is completely\n             // optional. They inherit stability from their parents when unannotated.\n-            hir::ItemImpl(.., None, _, _) | hir::ItemForeignMod(..) => {\n+            hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {\n                 self.in_trait_impl = false;\n                 kind = AnnotationKind::Container;\n             }\n-            hir::ItemImpl(.., Some(_), _, _) => {\n+            hir::ItemKind::Impl(.., Some(_), _, _) => {\n                 self.in_trait_impl = true;\n             }\n-            hir::ItemStruct(ref sd, _) => {\n+            hir::ItemKind::Struct(ref sd, _) => {\n                 if !sd.is_struct() {\n                     self.annotate(sd.id(), &i.attrs, i.span, AnnotationKind::Required, |_| {})\n                 }\n@@ -353,7 +353,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n             // they don't have their own stability. They still can be annotated as unstable\n             // and propagate this unstability to children, but this annotation is completely\n             // optional. They inherit stability from their parents when unannotated.\n-            hir::ItemImpl(.., None, _, _) | hir::ItemForeignMod(..) => {}\n+            hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {}\n \n             _ => self.check_missing_stability(i.id, i.span)\n         }\n@@ -723,7 +723,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            hir::ItemExternCrate(_) => {\n+            hir::ItemKind::ExternCrate(_) => {\n                 // compiler-generated `extern crate` items have a dummy span.\n                 if item.span.is_dummy() { return }\n \n@@ -739,7 +739,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             // For implementations of traits, check the stability of each item\n             // individually as it's possible to have a stable trait with unstable\n             // items.\n-            hir::ItemImpl(.., Some(ref t), _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., Some(ref t), _, ref impl_item_refs) => {\n                 if let Def::Trait(trait_did) = t.path.def {\n                     for impl_item_ref in impl_item_refs {\n                         let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n             // There's no good place to insert stability check for non-Copy unions,\n             // so semi-randomly perform it here in stability.rs\n-            hir::ItemUnion(..) if !self.tcx.features().untagged_unions => {\n+            hir::ItemKind::Union(..) if !self.tcx.features().untagged_unions => {\n                 let def_id = self.tcx.hir.local_def_id(item.id);\n                 let adt_def = self.tcx.adt_def(def_id);\n                 let ty = self.tcx.type_of(def_id);"}, {"sha": "6876b1490f376d52e826f67438a66a14374497ff", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -256,24 +256,24 @@ impl BorrowKind {\n }\n \n impl BinOp {\n-    pub fn to_hir_binop(self) -> hir::BinOp_ {\n+    pub fn to_hir_binop(self) -> hir::BinOpKind {\n         match self {\n-            BinOp::Add => hir::BinOp_::BiAdd,\n-            BinOp::Sub => hir::BinOp_::BiSub,\n-            BinOp::Mul => hir::BinOp_::BiMul,\n-            BinOp::Div => hir::BinOp_::BiDiv,\n-            BinOp::Rem => hir::BinOp_::BiRem,\n-            BinOp::BitXor => hir::BinOp_::BiBitXor,\n-            BinOp::BitAnd => hir::BinOp_::BiBitAnd,\n-            BinOp::BitOr => hir::BinOp_::BiBitOr,\n-            BinOp::Shl => hir::BinOp_::BiShl,\n-            BinOp::Shr => hir::BinOp_::BiShr,\n-            BinOp::Eq => hir::BinOp_::BiEq,\n-            BinOp::Ne => hir::BinOp_::BiNe,\n-            BinOp::Lt => hir::BinOp_::BiLt,\n-            BinOp::Gt => hir::BinOp_::BiGt,\n-            BinOp::Le => hir::BinOp_::BiLe,\n-            BinOp::Ge => hir::BinOp_::BiGe,\n+            BinOp::Add => hir::BinOpKind::Add,\n+            BinOp::Sub => hir::BinOpKind::Sub,\n+            BinOp::Mul => hir::BinOpKind::Mul,\n+            BinOp::Div => hir::BinOpKind::Div,\n+            BinOp::Rem => hir::BinOpKind::Rem,\n+            BinOp::BitXor => hir::BinOpKind::BitXor,\n+            BinOp::BitAnd => hir::BinOpKind::BitAnd,\n+            BinOp::BitOr => hir::BinOpKind::BitOr,\n+            BinOp::Shl => hir::BinOpKind::Shl,\n+            BinOp::Shr => hir::BinOpKind::Shr,\n+            BinOp::Eq => hir::BinOpKind::Eq,\n+            BinOp::Ne => hir::BinOpKind::Ne,\n+            BinOp::Lt => hir::BinOpKind::Lt,\n+            BinOp::Gt => hir::BinOpKind::Gt,\n+            BinOp::Le => hir::BinOpKind::Le,\n+            BinOp::Ge => hir::BinOpKind::Ge,\n             BinOp::Offset => unreachable!()\n         }\n     }"}, {"sha": "df26ac670601c529f7d635dd51c62e80bc149acd", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -858,7 +858,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let parent_node = self.tcx.hir.get_parent_node(node_id);\n             if let Some(hir::map::NodeLocal(ref local)) = self.tcx.hir.find(parent_node) {\n                 if let Some(ref expr) = local.init {\n-                    if let hir::ExprIndex(_, _) = expr.node {\n+                    if let hir::ExprKind::Index(_, _) = expr.node {\n                         if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n                             err.span_suggestion_with_applicability(\n                                 expr.span,\n@@ -927,7 +927,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn get_fn_like_arguments(&self, node: hir::map::Node) -> (Span, Vec<ArgKind>) {\n         match node {\n             hir::map::NodeExpr(&hir::Expr {\n-                node: hir::ExprClosure(_, ref _decl, id, span, _),\n+                node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n                 (self.tcx.sess.codemap().def_span(span), self.tcx.hir.body(id).arguments.iter()\n@@ -955,7 +955,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n             hir::map::NodeItem(&hir::Item {\n                 span,\n-                node: hir::ItemFn(ref decl, ..),\n+                node: hir::ItemKind::Fn(ref decl, ..),\n                 ..\n             }) |\n             hir::map::NodeImplItem(&hir::ImplItem {\n@@ -970,7 +970,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }) => {\n                 (self.tcx.sess.codemap().def_span(span), decl.inputs.iter()\n                         .map(|arg| match arg.clone().node {\n-                    hir::TyTup(ref tys) => ArgKind::Tuple(\n+                    hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n                         Some(arg.span),\n                         tys.iter()\n                             .map(|_| (\"_\".to_owned(), \"_\".to_owned()))\n@@ -981,7 +981,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n             hir::map::NodeVariant(&hir::Variant {\n                 span,\n-                node: hir::Variant_ {\n+                node: hir::VariantKind {\n                     data: hir::VariantData::Tuple(ref fields, _),\n                     ..\n                 },"}, {"sha": "875c7199f6d11830e1179b19ad5b7afc0db0dced", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -534,7 +534,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self.hir.as_local_node_id(node_item_def_id) {\n             Some(node_id) => {\n                 let item = self.hir.expect_item(node_id);\n-                if let hir::ItemImpl(_, _, defaultness, ..) = item.node {\n+                if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.node {\n                     defaultness.is_default()\n                 } else {\n                     false"}, {"sha": "c7bb90bfcb09065b36e3869ce3cec94175fe93fc", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -627,7 +627,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn is_method_call(&self, expr: &hir::Expr) -> bool {\n         // Only paths and method calls/overloaded operators have\n         // entries in type_dependent_defs, ignore the former here.\n-        if let hir::ExprPath(_) = expr.node {\n+        if let hir::ExprKind::Path(_) = expr.node {\n             return false;\n         }\n "}, {"sha": "5aa6542a027da1996539e32fb9ba87dbe76e6e49", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -2757,7 +2757,7 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     let parent_def_id = tcx.hir.local_def_id(parent_id);\n     let parent_item = tcx.hir.expect_item(parent_id);\n     match parent_item.node {\n-        hir::ItemImpl(.., ref impl_item_refs) => {\n+        hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.node_id == id) {\n                 let assoc_item = tcx.associated_item_from_impl_item_ref(parent_def_id,\n                                                                         impl_item_ref);\n@@ -2766,7 +2766,7 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             }\n         }\n \n-        hir::ItemTrait(.., ref trait_item_refs) => {\n+        hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.node_id == id) {\n                 let assoc_item = tcx.associated_item_from_trait_item_ref(parent_def_id,\n                                                                          &parent_item.vis,\n@@ -2815,19 +2815,19 @@ fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let item = tcx.hir.expect_item(id);\n     let vec: Vec<_> = match item.node {\n-        hir::ItemTrait(.., ref trait_item_refs) => {\n+        hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             trait_item_refs.iter()\n                            .map(|trait_item_ref| trait_item_ref.id)\n                            .map(|id| tcx.hir.local_def_id(id.node_id))\n                            .collect()\n         }\n-        hir::ItemImpl(.., ref impl_item_refs) => {\n+        hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             impl_item_refs.iter()\n                           .map(|impl_item_ref| impl_item_ref.id)\n                           .map(|id| tcx.hir.local_def_id(id.node_id))\n                           .collect()\n         }\n-        hir::ItemTraitAlias(..) => vec![],\n+        hir::ItemKind::TraitAlias(..) => vec![],\n         _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\")\n     };\n     Lrc::new(vec)"}, {"sha": "d5425aff6ba69c09664fefc20c9b6ccde9e16340", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -605,10 +605,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if let Some(node) = self.hir.get_if_local(def_id) {\n             match node {\n                 Node::NodeItem(&hir::Item {\n-                    node: hir::ItemStatic(_, mutbl, _), ..\n+                    node: hir::ItemKind::Static(_, mutbl, _), ..\n                 }) => Some(mutbl),\n                 Node::NodeForeignItem(&hir::ForeignItem {\n-                    node: hir::ForeignItemStatic(_, is_mutbl), ..\n+                    node: hir::ForeignItemKind::Static(_, is_mutbl), ..\n                 }) =>\n                     Some(if is_mutbl {\n                         hir::Mutability::MutMutable"}, {"sha": "002e8697588fcdb113b5ea66ad85ff9dd81c0071", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -203,7 +203,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let node_id = bccx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let movable_generator = !match bccx.tcx.hir.get(node_id) {\n         hir::map::Node::NodeExpr(&hir::Expr {\n-            node: hir::ExprClosure(.., Some(hir::GeneratorMovability::Static)),\n+            node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => true,\n         _ => false,"}, {"sha": "7ce6863a7c986402d1abcd4eede1ef7bc253e931", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -63,7 +63,7 @@ fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> Patte\n         NodeExpr(ref e) => {\n             // the enclosing expression must be a `match` or something else\n             assert!(match e.node {\n-                        ExprMatch(..) => true,\n+                        ExprKind::Match(..) => true,\n                         _ => return PatternSource::Other,\n                     });\n             PatternSource::MatchExpr(e)"}, {"sha": "3ae1e5aac507611938bc57855c1d5f18200720db", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -409,7 +409,7 @@ fn closure_to_block(closure_id: LocalDefId,\n     let closure_id = tcx.hir.local_def_id_to_node_id(closure_id);\n     match tcx.hir.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n-            hir::ExprClosure(.., body_id, _, _) => {\n+            hir::ExprKind::Closure(.., body_id, _, _) => {\n                 body_id.node_id\n             }\n             _ => {\n@@ -722,7 +722,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n             move_data::Captured =>\n                 (match self.tcx.hir.expect_expr(node_id).node {\n-                    hir::ExprClosure(.., fn_decl_span, _) => fn_decl_span,\n+                    hir::ExprKind::Closure(.., fn_decl_span, _) => fn_decl_span,\n                     ref r => bug!(\"Captured({:?}) maps to non-closure: {:?}\",\n                                   the_move.id, r),\n                 }, \" (into closure)\"),\n@@ -1131,7 +1131,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     fn suggest_mut_for_immutable(&self, pty: &hir::Ty, is_implicit_self: bool) -> Option<String> {\n         // Check whether the argument is an immutable reference\n         debug!(\"suggest_mut_for_immutable({:?}, {:?})\", pty, is_implicit_self);\n-        if let hir::TyRptr(lifetime, hir::MutTy {\n+        if let hir::TyKind::Rptr(lifetime, hir::MutTy {\n             mutbl: hir::Mutability::MutImmutable,\n             ref ty\n         }) = pty.node {\n@@ -1259,7 +1259,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     // avoid suggesting `mut &self`.\n                     return\n                 }\n-                if let Some(&hir::TyRptr(\n+                if let Some(&hir::TyKind::Rptr(\n                     _,\n                     hir::MutTy {\n                         mutbl: hir::MutMutable,"}, {"sha": "94357f348497d96c3edd11f480f165475d95659c", "filename": "src/librustc_codegen_llvm/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -105,11 +105,11 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                 // Only consider nodes that actually have exported symbols.\n                 hir::map::NodeItem(&hir::Item {\n-                    node: hir::ItemStatic(..),\n+                    node: hir::ItemKind::Static(..),\n                     ..\n                 }) |\n                 hir::map::NodeItem(&hir::Item {\n-                    node: hir::ItemFn(..), ..\n+                    node: hir::ItemKind::Fn(..), ..\n                 }) |\n                 hir::map::NodeImplItem(&hir::ImplItem {\n                     node: hir::ImplItemKind::Method(..),"}, {"sha": "d4d0b67523e11a24898f573bb915f9f101e04fa4", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -124,16 +124,16 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     }\n }\n \n-pub fn bin_op_to_icmp_predicate(op: hir::BinOp_,\n+pub fn bin_op_to_icmp_predicate(op: hir::BinOpKind,\n                                 signed: bool)\n                                 -> llvm::IntPredicate {\n     match op {\n-        hir::BiEq => llvm::IntEQ,\n-        hir::BiNe => llvm::IntNE,\n-        hir::BiLt => if signed { llvm::IntSLT } else { llvm::IntULT },\n-        hir::BiLe => if signed { llvm::IntSLE } else { llvm::IntULE },\n-        hir::BiGt => if signed { llvm::IntSGT } else { llvm::IntUGT },\n-        hir::BiGe => if signed { llvm::IntSGE } else { llvm::IntUGE },\n+        hir::BinOpKind::Eq => llvm::IntEQ,\n+        hir::BinOpKind::Ne => llvm::IntNE,\n+        hir::BinOpKind::Lt => if signed { llvm::IntSLT } else { llvm::IntULT },\n+        hir::BinOpKind::Le => if signed { llvm::IntSLE } else { llvm::IntULE },\n+        hir::BinOpKind::Gt => if signed { llvm::IntSGT } else { llvm::IntUGT },\n+        hir::BinOpKind::Ge => if signed { llvm::IntSGE } else { llvm::IntUGE },\n         op => {\n             bug!(\"comparison_op_to_icmp_predicate: expected comparison operator, \\\n                   found {:?}\",\n@@ -142,14 +142,14 @@ pub fn bin_op_to_icmp_predicate(op: hir::BinOp_,\n     }\n }\n \n-pub fn bin_op_to_fcmp_predicate(op: hir::BinOp_) -> llvm::RealPredicate {\n+pub fn bin_op_to_fcmp_predicate(op: hir::BinOpKind) -> llvm::RealPredicate {\n     match op {\n-        hir::BiEq => llvm::RealOEQ,\n-        hir::BiNe => llvm::RealUNE,\n-        hir::BiLt => llvm::RealOLT,\n-        hir::BiLe => llvm::RealOLE,\n-        hir::BiGt => llvm::RealOGT,\n-        hir::BiGe => llvm::RealOGE,\n+        hir::BinOpKind::Eq => llvm::RealOEQ,\n+        hir::BinOpKind::Ne => llvm::RealUNE,\n+        hir::BinOpKind::Lt => llvm::RealOLT,\n+        hir::BinOpKind::Le => llvm::RealOLE,\n+        hir::BinOpKind::Gt => llvm::RealOGT,\n+        hir::BinOpKind::Ge => llvm::RealOGE,\n         op => {\n             bug!(\"comparison_op_to_fcmp_predicate: expected comparison operator, \\\n                   found {:?}\",\n@@ -164,7 +164,7 @@ pub fn compare_simd_types<'a, 'tcx>(\n     rhs: ValueRef,\n     t: Ty<'tcx>,\n     ret_ty: Type,\n-    op: hir::BinOp_\n+    op: hir::BinOpKind\n ) -> ValueRef {\n     let signed = match t.sty {\n         ty::TyFloat(_) => {\n@@ -332,12 +332,12 @@ pub fn coerce_unsized_into<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n }\n \n pub fn cast_shift_expr_rhs(\n-    cx: &Builder, op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef\n+    cx: &Builder, op: hir::BinOpKind, lhs: ValueRef, rhs: ValueRef\n ) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs, |a, b| cx.trunc(a, b), |a, b| cx.zext(a, b))\n }\n \n-fn cast_shift_rhs<F, G>(op: hir::BinOp_,\n+fn cast_shift_rhs<F, G>(op: hir::BinOpKind,\n                         lhs: ValueRef,\n                         rhs: ValueRef,\n                         trunc: F,"}, {"sha": "60bba635a7887bbe48fb81a5759eb8bca833fb13", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -350,7 +350,7 @@ pub fn build_unchecked_lshift<'a, 'tcx>(\n     lhs: ValueRef,\n     rhs: ValueRef\n ) -> ValueRef {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOp_::BiShl, lhs, rhs);\n+    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shl, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     bx.shl(lhs, rhs)\n@@ -359,7 +359,7 @@ pub fn build_unchecked_lshift<'a, 'tcx>(\n pub fn build_unchecked_rshift<'a, 'tcx>(\n     bx: &Builder<'a, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n ) -> ValueRef {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOp_::BiShr, lhs, rhs);\n+    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     let is_signed = lhs_t.is_signed();"}, {"sha": "6e3096d4cd5ba75ff74494cb6fc65786284d72f5", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -125,7 +125,7 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n         let llty = cx.layout_of(ty).llvm_type(cx);\n         let (g, attrs) = match cx.tcx.hir.get(id) {\n             hir_map::NodeItem(&hir::Item {\n-                ref attrs, span, node: hir::ItemStatic(..), ..\n+                ref attrs, span, node: hir::ItemKind::Static(..), ..\n             }) => {\n                 if declare::get_declared_value(cx, &sym[..]).is_some() {\n                     span_bug!(span, \"Conflicting symbol names for static?\");\n@@ -143,7 +143,7 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n             }\n \n             hir_map::NodeForeignItem(&hir::ForeignItem {\n-                ref attrs, span, node: hir::ForeignItemStatic(..), ..\n+                ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n             }) => {\n                 let g = if let Some(linkage) = cx.tcx.codegen_fn_attrs(def_id).linkage {\n                     // If this is a static with a linkage specified, then we need to handle"}, {"sha": "58a32ad9774f61c113d9a0df3a670540bfab3d4b", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -1022,12 +1022,12 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n     let in_len = arg_tys[0].simd_size(tcx);\n \n     let comparison = match name {\n-        \"simd_eq\" => Some(hir::BiEq),\n-        \"simd_ne\" => Some(hir::BiNe),\n-        \"simd_lt\" => Some(hir::BiLt),\n-        \"simd_le\" => Some(hir::BiLe),\n-        \"simd_gt\" => Some(hir::BiGt),\n-        \"simd_ge\" => Some(hir::BiGe),\n+        \"simd_eq\" => Some(hir::BinOpKind::Eq),\n+        \"simd_ne\" => Some(hir::BinOpKind::Ne),\n+        \"simd_lt\" => Some(hir::BinOpKind::Lt),\n+        \"simd_le\" => Some(hir::BinOpKind::Le),\n+        \"simd_gt\" => Some(hir::BinOpKind::Gt),\n+        \"simd_ge\" => Some(hir::BinOpKind::Ge),\n         _ => None\n     };\n "}, {"sha": "b512a6f1bb4b0faec4afc0ced337dc734d72905f", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -60,7 +60,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n             }\n             MonoItem::GlobalAsm(node_id) => {\n                 let item = cx.tcx.hir.expect_item(node_id);\n-                if let hir::ItemGlobalAsm(ref ga) = item.node {\n+                if let hir::ItemKind::GlobalAsm(ref ga) = item.node {\n                     asm::codegen_global_asm(cx, ga);\n                 } else {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and MonoItem type\")"}, {"sha": "5b2092ea9eb11fe17cdbdec653ef540d819b4e58", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -249,24 +249,24 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             }\n \n             return match it.node {\n-                hir::ItemUse(..) |\n-                hir::ItemExternCrate(..) |\n-                hir::ItemConst(..) |\n-                hir::ItemStatic(..) |\n-                hir::ItemFn(..) |\n-                hir::ItemForeignMod(..) |\n-                hir::ItemGlobalAsm(..) |\n-                hir::ItemExistential(..) |\n-                hir::ItemTy(..) => None,\n-\n-                hir::ItemEnum(..) |\n-                hir::ItemStruct(..) |\n-                hir::ItemUnion(..) |\n-                hir::ItemTrait(..) |\n-                hir::ItemTraitAlias(..) |\n-                hir::ItemImpl(..) => None,\n-\n-                hir::ItemMod(ref m) => search_mod(this, m, idx, names),\n+                hir::ItemKind::Use(..) |\n+                hir::ItemKind::ExternCrate(..) |\n+                hir::ItemKind::Const(..) |\n+                hir::ItemKind::Static(..) |\n+                hir::ItemKind::Fn(..) |\n+                hir::ItemKind::ForeignMod(..) |\n+                hir::ItemKind::GlobalAsm(..) |\n+                hir::ItemKind::Existential(..) |\n+                hir::ItemKind::Ty(..) => None,\n+\n+                hir::ItemKind::Enum(..) |\n+                hir::ItemKind::Struct(..) |\n+                hir::ItemKind::Union(..) |\n+                hir::ItemKind::Trait(..) |\n+                hir::ItemKind::TraitAlias(..) |\n+                hir::ItemKind::Impl(..) => None,\n+\n+                hir::ItemKind::Mod(ref m) => search_mod(this, m, idx, names),\n             };\n         }\n     }"}, {"sha": "39e674a6095b66392cce0ff05a89ef5c3ea8f0e7", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -29,7 +29,7 @@ use std::iter::FromIterator;\n use std::vec::Vec;\n use rustc::dep_graph::{DepNode, label_strs};\n use rustc::hir;\n-use rustc::hir::{Item_ as HirItem, ImplItemKind, TraitItemKind};\n+use rustc::hir::{ItemKind as HirItem, ImplItemKind, TraitItemKind};\n use rustc::hir::map::Node as HirNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -342,40 +342,40 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                     // FIXME(michaelwoerister): do commented out ones\n \n                     // // An `extern crate` item, with optional original crate name,\n-                    // HirItem::ItemExternCrate(..),  // intentionally no assertions\n+                    // HirItem::ExternCrate(..),  // intentionally no assertions\n \n                     // // `use foo::bar::*;` or `use foo::bar::baz as quux;`\n-                    // HirItem::ItemUse(..),  // intentionally no assertions\n+                    // HirItem::Use(..),  // intentionally no assertions\n \n                     // A `static` item\n-                    HirItem::ItemStatic(..) => (\"ItemStatic\", LABELS_CONST),\n+                    HirItem::Static(..) => (\"ItemStatic\", LABELS_CONST),\n \n                     // A `const` item\n-                    HirItem::ItemConst(..) => (\"ItemConst\", LABELS_CONST),\n+                    HirItem::Const(..) => (\"ItemConst\", LABELS_CONST),\n \n                     // A function declaration\n-                    HirItem::ItemFn(..) => (\"ItemFn\", LABELS_FN),\n+                    HirItem::Fn(..) => (\"ItemFn\", LABELS_FN),\n \n                     // // A module\n-                    HirItem::ItemMod(..) =>(\"ItemMod\", LABELS_HIR_ONLY),\n+                    HirItem::Mod(..) =>(\"ItemMod\", LABELS_HIR_ONLY),\n \n                     // // An external module\n-                    HirItem::ItemForeignMod(..) => (\"ItemForeignMod\", LABELS_HIR_ONLY),\n+                    HirItem::ForeignMod(..) => (\"ItemForeignMod\", LABELS_HIR_ONLY),\n \n                     // Module-level inline assembly (from global_asm!)\n-                    HirItem::ItemGlobalAsm(..) => (\"ItemGlobalAsm\", LABELS_HIR_ONLY),\n+                    HirItem::GlobalAsm(..) => (\"ItemGlobalAsm\", LABELS_HIR_ONLY),\n \n                     // A type alias, e.g. `type Foo = Bar<u8>`\n-                    HirItem::ItemTy(..) => (\"ItemTy\", LABELS_HIR_ONLY),\n+                    HirItem::Ty(..) => (\"ItemTy\", LABELS_HIR_ONLY),\n \n                     // An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n-                    HirItem::ItemEnum(..) => (\"ItemEnum\", LABELS_ADT),\n+                    HirItem::Enum(..) => (\"ItemEnum\", LABELS_ADT),\n \n                     // A struct definition, e.g. `struct Foo<A> {x: A}`\n-                    HirItem::ItemStruct(..) => (\"ItemStruct\", LABELS_ADT),\n+                    HirItem::Struct(..) => (\"ItemStruct\", LABELS_ADT),\n \n                     // A union definition, e.g. `union Foo<A, B> {x: A, y: B}`\n-                    HirItem::ItemUnion(..) => (\"ItemUnion\", LABELS_ADT),\n+                    HirItem::Union(..) => (\"ItemUnion\", LABELS_ADT),\n \n                     // Represents a Trait Declaration\n                     // FIXME(michaelwoerister): trait declaration is buggy because sometimes some of\n@@ -391,10 +391,10 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                     // However, this did not seem to work effectively and more bugs were hit.\n                     // Nebie @vitiral gave up :)\n                     //\n-                    //HirItem::ItemTrait(..) => (\"ItemTrait\", LABELS_TRAIT),\n+                    //HirItem::Trait(..) => (\"ItemTrait\", LABELS_TRAIT),\n \n                     // An implementation, eg `impl<A> Trait for Foo { .. }`\n-                    HirItem::ItemImpl(..) => (\"ItemImpl\", LABELS_IMPL),\n+                    HirItem::Impl(..) => (\"ItemKind::Impl\", LABELS_IMPL),\n \n                     _ => self.tcx.sess.span_fatal(\n                         attr.span,"}, {"sha": "fd5a152311ded98e505b6e7980e9747250563251", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -133,11 +133,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCamelCaseTypes {\n         }\n \n         match it.node {\n-            hir::ItemTy(..) |\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemUnion(..) => self.check_case(cx, \"type\", it.name, it.span),\n-            hir::ItemTrait(..) => self.check_case(cx, \"trait\", it.name, it.span),\n+            hir::ItemKind::Ty(..) |\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) => self.check_case(cx, \"type\", it.name, it.span),\n+            hir::ItemKind::Trait(..) => self.check_case(cx, \"trait\", it.name, it.span),\n             _ => (),\n         }\n     }\n@@ -296,7 +296,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        if let hir::ItemMod(_) = it.node {\n+        if let hir::ItemKind::Mod(_) = it.node {\n             self.check_snake_case(cx, \"module\", &it.name.as_str(), Some(it.span));\n         }\n     }\n@@ -369,13 +369,13 @@ impl LintPass for NonUpperCaseGlobals {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n-            hir::ItemStatic(..) => {\n+            hir::ItemKind::Static(..) => {\n                 if attr::find_by_name(&it.attrs, \"no_mangle\").is_some() {\n                     return;\n                 }\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", it.name, it.span);\n             }\n-            hir::ItemConst(..) => {\n+            hir::ItemKind::Const(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.name, it.span);\n             }\n             _ => {}"}, {"sha": "8a674449880b83b5b8b70e41e3bc38175a81e2c4", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -75,8 +75,8 @@ impl LintPass for WhileTrue {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for WhileTrue {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        if let hir::ExprWhile(ref cond, ..) = e.node {\n-            if let hir::ExprLit(ref lit) = cond.node {\n+        if let hir::ExprKind::While(ref cond, ..) = e.node {\n+            if let hir::ExprKind::Lit(ref lit) = cond.node {\n                 if let ast::LitKind::Bool(true) = lit.node {\n                     if lit.span.ctxt() == SyntaxContext::empty() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n@@ -120,11 +120,11 @@ impl LintPass for BoxPointers {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n-            hir::ItemFn(..) |\n-            hir::ItemTy(..) |\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemUnion(..) => {\n+            hir::ItemKind::Fn(..) |\n+            hir::ItemKind::Ty(..) |\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) => {\n                 let def_id = cx.tcx.hir.local_def_id(it.id);\n                 self.check_heap_type(cx, it.span, cx.tcx.type_of(def_id))\n             }\n@@ -133,8 +133,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n \n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n-            hir::ItemStruct(ref struct_def, _) |\n-            hir::ItemUnion(ref struct_def, _) => {\n+            hir::ItemKind::Struct(ref struct_def, _) |\n+            hir::ItemKind::Union(ref struct_def, _) => {\n                 for struct_field in struct_def.fields() {\n                     let def_id = cx.tcx.hir.local_def_id(struct_field.id);\n                     self.check_heap_type(cx, struct_field.span,\n@@ -226,7 +226,7 @@ impl UnsafeCode {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        if let hir::ExprBlock(ref blk, _) = e.node {\n+        if let hir::ExprKind::Block(ref blk, _) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             if blk.rules == hir::UnsafeBlock(hir::UserProvided) {\n                 self.report_unsafe(cx, blk.span, \"usage of an `unsafe` block\");\n@@ -236,11 +236,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n \n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n-            hir::ItemTrait(_, hir::Unsafety::Unsafe, ..) => {\n+            hir::ItemKind::Trait(_, hir::Unsafety::Unsafe, ..) => {\n                 self.report_unsafe(cx, it.span, \"declaration of an `unsafe` trait\")\n             }\n \n-            hir::ItemImpl(hir::Unsafety::Unsafe, ..) => {\n+            hir::ItemKind::Impl(hir::Unsafety::Unsafe, ..) => {\n                 self.report_unsafe(cx, it.span, \"implementation of an `unsafe` trait\")\n             }\n \n@@ -390,12 +390,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         let desc = match it.node {\n-            hir::ItemFn(..) => \"a function\",\n-            hir::ItemMod(..) => \"a module\",\n-            hir::ItemEnum(..) => \"an enum\",\n-            hir::ItemStruct(..) => \"a struct\",\n-            hir::ItemUnion(..) => \"a union\",\n-            hir::ItemTrait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Fn(..) => \"a function\",\n+            hir::ItemKind::Mod(..) => \"a module\",\n+            hir::ItemKind::Enum(..) => \"an enum\",\n+            hir::ItemKind::Struct(..) => \"a struct\",\n+            hir::ItemKind::Union(..) => \"a union\",\n+            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 // Issue #11592, traits are always considered exported, even when private.\n                 if let hir::VisibilityKind::Inherited = it.vis.node {\n                     self.private_traits.insert(it.id);\n@@ -406,8 +406,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 }\n                 \"a trait\"\n             }\n-            hir::ItemTy(..) => \"a type alias\",\n-            hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_item_refs) => {\n+            hir::ItemKind::Ty(..) => \"a type alias\",\n+            hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.def.def_id();\n@@ -425,8 +425,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 }\n                 return;\n             }\n-            hir::ItemConst(..) => \"a constant\",\n-            hir::ItemStatic(..) => \"a static\",\n+            hir::ItemKind::Const(..) => \"a constant\",\n+            hir::ItemKind::Static(..) => \"a static\",\n             _ => return,\n         };\n \n@@ -509,21 +509,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n             return;\n         }\n         let (def, ty) = match item.node {\n-            hir::ItemStruct(_, ref ast_generics) => {\n+            hir::ItemKind::Struct(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n                 let def = cx.tcx.adt_def(cx.tcx.hir.local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n-            hir::ItemUnion(_, ref ast_generics) => {\n+            hir::ItemKind::Union(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n                 let def = cx.tcx.adt_def(cx.tcx.hir.local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n-            hir::ItemEnum(_, ref ast_generics) => {\n+            hir::ItemKind::Enum(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n@@ -577,9 +577,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n         }\n \n         match item.node {\n-            hir::ItemStruct(..) |\n-            hir::ItemUnion(..) |\n-            hir::ItemEnum(..) => {}\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Enum(..) => {}\n             _ => return,\n         }\n \n@@ -960,8 +960,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n \n         fn expr_refers_to_this_fn(cx: &LateContext, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n             match cx.tcx.hir.get(id) {\n-                hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n-                    let def = if let hir::ExprPath(ref qpath) = callee.node {\n+                hir_map::NodeExpr(&hir::Expr { node: hir::ExprKind::Call(ref callee, _), .. }) => {\n+                    let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n                         cx.tables.qpath_def(qpath, callee.hir_id)\n                     } else {\n                         return false;\n@@ -1018,8 +1018,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n \n             // Check for calls to methods via explicit paths (e.g. `T::method()`).\n             match expr.node {\n-                hir::ExprCall(ref callee, _) => {\n-                    let def = if let hir::ExprPath(ref qpath) = callee.node {\n+                hir::ExprKind::Call(ref callee, _) => {\n+                    let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n                         cx.tables.qpath_def(qpath, callee.hir_id)\n                     } else {\n                         return false;\n@@ -1121,7 +1121,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PluginAsLibrary {\n         }\n \n         match it.node {\n-            hir::ItemExternCrate(..) => (),\n+            hir::ItemKind::ExternCrate(..) => (),\n             _ => return,\n         };\n \n@@ -1203,7 +1203,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n         };\n \n         match it.node {\n-            hir::ItemFn(.., ref generics, _) => {\n+            hir::ItemKind::Fn(.., ref generics, _) => {\n                 if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, \"no_mangle\") {\n                     if attr::contains_name(&it.attrs, \"linkage\") {\n                         return;\n@@ -1232,7 +1232,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                     }\n                 }\n             }\n-            hir::ItemStatic(..) => {\n+            hir::ItemKind::Static(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n                     !cx.access_levels.is_reachable(it.id) {\n                         let msg = \"static is marked #[no_mangle], but not exported\";\n@@ -1241,7 +1241,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                         err.emit();\n                     }\n             }\n-            hir::ItemConst(..) => {\n+            hir::ItemKind::Const(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n@@ -1300,7 +1300,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n             (cx: &LateContext<'a, 'tcx>,\n              expr: &hir::Expr)\n              -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n-            let def = if let hir::ExprPath(ref qpath) = expr.node {\n+            let def = if let hir::ExprKind::Path(ref qpath) = expr.node {\n                 cx.tables.qpath_def(qpath, expr.hir_id)\n             } else {\n                 return None;\n@@ -1369,7 +1369,7 @@ impl LintPass for UnionsWithDropFields {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n     fn check_item(&mut self, ctx: &LateContext, item: &hir::Item) {\n-        if let hir::ItemUnion(ref vdata, _) = item.node {\n+        if let hir::ItemKind::Union(ref vdata, _) = item.node {\n             for field in vdata.fields() {\n                 let field_ty = ctx.tcx.type_of(ctx.tcx.hir.local_def_id(field.id));\n                 if field_ty.needs_drop(ctx.tcx, ctx.param_env) {\n@@ -1475,7 +1475,7 @@ impl TypeAliasBounds {\n             hir::QPath::TypeRelative(ref ty, _) => {\n                 // If this is a type variable, we found a `T::Assoc`.\n                 match ty.node {\n-                    hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n+                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                         match path.def {\n                             Def::TyParam(_) => true,\n                             _ => false\n@@ -1523,7 +1523,7 @@ impl TypeAliasBounds {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n     fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         let (ty, type_alias_generics) = match item.node {\n-            hir::ItemTy(ref ty, ref generics) => (&*ty, generics),\n+            hir::ItemKind::Ty(ref ty, ref generics) => (&*ty, generics),\n             _ => return,\n         };\n         let mut suggested_changing_assoc_types = false;\n@@ -1605,10 +1605,10 @@ impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for UnusedBrokenConstVisitor<'a,\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedBrokenConst {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n-            hir::ItemConst(_, body_id) => {\n+            hir::ItemKind::Const(_, body_id) => {\n                 check_const(cx, body_id, \"constant\");\n             },\n-            hir::ItemTy(ref ty, _) => hir::intravisit::walk_ty(\n+            hir::ItemKind::Ty(ref ty, _) => hir::intravisit::walk_ty(\n                 &mut UnusedBrokenConstVisitor(cx),\n                 ty\n             ),\n@@ -1761,12 +1761,12 @@ impl LintPass for UnnameableTestFunctions {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestFunctions {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n-            hir::ItemFn(..) => {\n+            hir::ItemKind::Fn(..) => {\n                 for attr in &it.attrs {\n                     if attr.name() == \"test\" {\n                         let parent = cx.tcx.hir.get_parent(it.id);\n                         match cx.tcx.hir.find(parent) {\n-                            Some(hir_map::NodeItem(hir::Item {node: hir::ItemMod(_), ..})) |\n+                            Some(hir_map::NodeItem(hir::Item {node: hir::ItemKind::Mod(_), ..})) |\n                             None => {}\n                             _ => {\n                                 cx.struct_span_lint("}, {"sha": "ad4a4fbff649ca5cdd6ea6590ed743e066ba0b82", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -68,20 +68,20 @@ impl LintPass for TypeLimits {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n         match e.node {\n-            hir::ExprUnary(hir::UnNeg, ref expr) => {\n+            hir::ExprKind::Unary(hir::UnNeg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n                 if self.negated_expr_id != e.id {\n                     self.negated_expr_id = expr.id;\n                 }\n             }\n-            hir::ExprBinary(binop, ref l, ref r) => {\n+            hir::ExprKind::Binary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx, binop, &l, &r) {\n                     cx.span_lint(UNUSED_COMPARISONS,\n                                  e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n             }\n-            hir::ExprLit(ref lit) => {\n+            hir::ExprKind::Lit(ref lit) => {\n                 match cx.tables.node_id_to_type(e.hir_id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                         if lit_val < min || lit_val > max {\n                             let parent_id = cx.tcx.hir.get_parent_node(e.id);\n                             if let hir_map::NodeExpr(parent_expr) = cx.tcx.hir.get(parent_id) {\n-                                if let hir::ExprCast(..) = parent_expr.node {\n+                                if let hir::ExprKind::Cast(..) = parent_expr.node {\n                                     if let ty::TyChar = cx.tables.expr_ty(parent_expr).sty {\n                                         let mut err = cx.struct_span_lint(\n                                                              OVERFLOWING_LITERALS,\n@@ -194,22 +194,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n \n         fn is_valid<T: cmp::PartialOrd>(binop: hir::BinOp, v: T, min: T, max: T) -> bool {\n             match binop.node {\n-                hir::BiLt => v > min && v <= max,\n-                hir::BiLe => v >= min && v < max,\n-                hir::BiGt => v >= min && v < max,\n-                hir::BiGe => v > min && v <= max,\n-                hir::BiEq | hir::BiNe => v >= min && v <= max,\n+                hir::BinOpKind::Lt => v > min && v <= max,\n+                hir::BinOpKind::Le => v >= min && v < max,\n+                hir::BinOpKind::Gt => v >= min && v < max,\n+                hir::BinOpKind::Ge => v > min && v <= max,\n+                hir::BinOpKind::Eq | hir::BinOpKind::Ne => v >= min && v <= max,\n                 _ => bug!(),\n             }\n         }\n \n         fn rev_binop(binop: hir::BinOp) -> hir::BinOp {\n             codemap::respan(binop.span,\n                             match binop.node {\n-                                hir::BiLt => hir::BiGt,\n-                                hir::BiLe => hir::BiGe,\n-                                hir::BiGt => hir::BiLt,\n-                                hir::BiGe => hir::BiLe,\n+                                hir::BinOpKind::Lt => hir::BinOpKind::Gt,\n+                                hir::BinOpKind::Le => hir::BinOpKind::Ge,\n+                                hir::BinOpKind::Gt => hir::BinOpKind::Lt,\n+                                hir::BinOpKind::Ge => hir::BinOpKind::Le,\n                                 _ => return binop,\n                             })\n         }\n@@ -244,8 +244,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                         r: &hir::Expr)\n                         -> bool {\n             let (lit, expr, swap) = match (&l.node, &r.node) {\n-                (&hir::ExprLit(_), _) => (l, r, true),\n-                (_, &hir::ExprLit(_)) => (r, l, false),\n+                (&hir::ExprKind::Lit(_), _) => (l, r, true),\n+                (_, &hir::ExprKind::Lit(_)) => (r, l, false),\n                 _ => return true,\n             };\n             // Normalize the binop so that the literal is always on the RHS in\n@@ -255,7 +255,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i128 = match lit.node {\n-                        hir::ExprLit(ref li) => {\n+                        hir::ExprKind::Lit(ref li) => {\n                             match li.node {\n                                 ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n                                 ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => v as i128,\n@@ -269,7 +269,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 ty::TyUint(uint_ty) => {\n                     let (min, max) :(u128, u128) = uint_ty_range(uint_ty);\n                     let lit_val: u128 = match lit.node {\n-                        hir::ExprLit(ref li) => {\n+                        hir::ExprKind::Lit(ref li) => {\n                             match li.node {\n                                 ast::LitKind::Int(v, _) => v,\n                                 _ => return true\n@@ -285,7 +285,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n \n         fn is_comparison(binop: hir::BinOp) -> bool {\n             match binop.node {\n-                hir::BiEq | hir::BiLt | hir::BiLe | hir::BiNe | hir::BiGe | hir::BiGt => true,\n+                hir::BinOpKind::Eq |\n+                hir::BinOpKind::Lt |\n+                hir::BinOpKind::Le |\n+                hir::BinOpKind::Ne |\n+                hir::BinOpKind::Ge |\n+                hir::BinOpKind::Gt => true,\n                 _ => false,\n             }\n         }\n@@ -782,17 +787,17 @@ impl LintPass for ImproperCTypes {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         let mut vis = ImproperCTypesVisitor { cx: cx };\n-        if let hir::ItemForeignMod(ref nmod) = it.node {\n+        if let hir::ItemKind::ForeignMod(ref nmod) = it.node {\n             if nmod.abi != Abi::RustIntrinsic && nmod.abi != Abi::PlatformIntrinsic {\n                 for ni in &nmod.items {\n                     match ni.node {\n-                        hir::ForeignItemFn(ref decl, _, _) => {\n+                        hir::ForeignItemKind::Fn(ref decl, _, _) => {\n                             vis.check_foreign_fn(ni.id, decl);\n                         }\n-                        hir::ForeignItemStatic(ref ty, _) => {\n+                        hir::ForeignItemKind::Static(ref ty, _) => {\n                             vis.check_foreign_static(ni.id, ty.span);\n                         }\n-                        hir::ForeignItemType => ()\n+                        hir::ForeignItemKind::Type => ()\n                     }\n                 }\n             }\n@@ -810,7 +815,7 @@ impl LintPass for VariantSizeDifferences {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        if let hir::ItemEnum(ref enum_definition, _) = it.node {\n+        if let hir::ItemKind::Enum(ref enum_definition, _) = it.node {\n             let item_def_id = cx.tcx.hir.local_def_id(it.id);\n             let generics = cx.tcx.generics_of(item_def_id);\n             for param in &generics.params {"}, {"sha": "3d64fa572d1e703adffa76939a3cf4cbdd6de4a0", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -49,11 +49,11 @@ impl LintPass for UnusedResults {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         let expr = match s.node {\n-            hir::StmtSemi(ref expr, _) => &**expr,\n+            hir::StmtKind::Semi(ref expr, _) => &**expr,\n             _ => return,\n         };\n \n-        if let hir::ExprRet(..) = expr.node {\n+        if let hir::ExprKind::Ret(..) = expr.node {\n             return;\n         }\n \n@@ -74,9 +74,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         let mut fn_warned = false;\n         let mut op_warned = false;\n         let maybe_def = match expr.node {\n-            hir::ExprCall(ref callee, _) => {\n+            hir::ExprKind::Call(ref callee, _) => {\n                 match callee.node {\n-                    hir::ExprPath(ref qpath) => {\n+                    hir::ExprKind::Path(ref qpath) => {\n                         let def = cx.tables.qpath_def(qpath, callee.hir_id);\n                         if let Def::Fn(_) = def {\n                             Some(def)\n@@ -87,7 +87,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                     _ => None\n                 }\n             },\n-            hir::ExprMethodCall(..) => {\n+            hir::ExprKind::MethodCall(..) => {\n                 cx.tables.type_dependent_defs().get(expr.hir_id).cloned()\n             },\n             _ => None\n@@ -100,23 +100,36 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             // Hardcoding operators here seemed more expedient than the\n             // refactoring that would be needed to look up the `#[must_use]`\n             // attribute which does exist on the comparison trait methods\n-            hir::ExprBinary(bin_op, ..)  => {\n+            hir::ExprKind::Binary(bin_op, ..)  => {\n                 match bin_op.node {\n-                    hir::BiEq | hir::BiLt | hir::BiLe | hir::BiNe | hir::BiGe | hir::BiGt => {\n+                    hir::BinOpKind::Eq |\n+                    hir::BinOpKind::Lt |\n+                    hir::BinOpKind::Le |\n+                    hir::BinOpKind::Ne |\n+                    hir::BinOpKind::Ge |\n+                    hir::BinOpKind::Gt => {\n                         Some(\"comparison\")\n                     },\n-                    hir::BiAdd | hir::BiSub | hir::BiDiv | hir::BiMul | hir::BiRem => {\n+                    hir::BinOpKind::Add |\n+                    hir::BinOpKind::Sub |\n+                    hir::BinOpKind::Div |\n+                    hir::BinOpKind::Mul |\n+                    hir::BinOpKind::Rem => {\n                         Some(\"arithmetic operation\")\n                     },\n-                    hir::BiAnd | hir::BiOr => {\n+                    hir::BinOpKind::And | hir::BinOpKind::Or => {\n                         Some(\"logical operation\")\n                     },\n-                    hir::BiBitXor | hir::BiBitAnd | hir::BiBitOr | hir::BiShl | hir::BiShr => {\n+                    hir::BinOpKind::BitXor |\n+                    hir::BinOpKind::BitAnd |\n+                    hir::BinOpKind::BitOr |\n+                    hir::BinOpKind::Shl |\n+                    hir::BinOpKind::Shr => {\n                         Some(\"bitwise operation\")\n                     },\n                 }\n             },\n-            hir::ExprUnary(..) => Some(\"unary operation\"),\n+            hir::ExprKind::Unary(..) => Some(\"unary operation\"),\n             _ => None\n         };\n \n@@ -166,8 +179,8 @@ impl LintPass for PathStatements {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n-        if let hir::StmtSemi(ref expr, _) = s.node {\n-            if let hir::ExprPath(_) = expr.node {\n+        if let hir::StmtKind::Semi(ref expr, _) = s.node {\n+            if let hir::ExprKind::Path(_) = expr.node {\n                 cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n             }\n         }\n@@ -447,7 +460,7 @@ impl LintPass for UnusedAllocation {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         match e.node {\n-            hir::ExprBox(_) => {}\n+            hir::ExprKind::Box(_) => {}\n             _ => return,\n         }\n "}, {"sha": "b9cb97ed7d0c53cb559063ba9212d45110f32560", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -1039,16 +1039,16 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_item({:?})\", def_id);\n \n         let kind = match item.node {\n-            hir::ItemStatic(_, hir::MutMutable, _) => EntryKind::MutStatic,\n-            hir::ItemStatic(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n-            hir::ItemConst(_, body_id) => {\n+            hir::ItemKind::Static(_, hir::MutMutable, _) => EntryKind::MutStatic,\n+            hir::ItemKind::Static(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n+            hir::ItemKind::Const(_, body_id) => {\n                 let mir = tcx.at(item.span).mir_const_qualif(def_id).0;\n                 EntryKind::Const(\n                     self.const_qualif(mir, body_id),\n                     self.encode_rendered_const_for_body(body_id)\n                 )\n             }\n-            hir::ItemFn(_, header, .., body) => {\n+            hir::ItemKind::Fn(_, header, .., body) => {\n                 let data = FnData {\n                     constness: header.constness,\n                     arg_names: self.encode_fn_arg_names_for_body(body),\n@@ -1057,15 +1057,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n                 EntryKind::Fn(self.lazy(&data))\n             }\n-            hir::ItemMod(ref m) => {\n+            hir::ItemKind::Mod(ref m) => {\n                 return self.encode_info_for_mod(FromId(item.id, (m, &item.attrs, &item.vis)));\n             }\n-            hir::ItemForeignMod(_) => EntryKind::ForeignMod,\n-            hir::ItemGlobalAsm(..) => EntryKind::GlobalAsm,\n-            hir::ItemTy(..) => EntryKind::Type,\n-            hir::ItemExistential(..) => EntryKind::Existential,\n-            hir::ItemEnum(..) => EntryKind::Enum(get_repr_options(&tcx, def_id)),\n-            hir::ItemStruct(ref struct_def, _) => {\n+            hir::ItemKind::ForeignMod(_) => EntryKind::ForeignMod,\n+            hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n+            hir::ItemKind::Ty(..) => EntryKind::Type,\n+            hir::ItemKind::Existential(..) => EntryKind::Existential,\n+            hir::ItemKind::Enum(..) => EntryKind::Enum(get_repr_options(&tcx, def_id)),\n+            hir::ItemKind::Struct(ref struct_def, _) => {\n                 let variant = tcx.adt_def(def_id).non_enum_variant();\n \n                 // Encode def_ids for each field and method\n@@ -1086,7 +1086,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     ctor_sig: None,\n                 }), repr_options)\n             }\n-            hir::ItemUnion(..) => {\n+            hir::ItemKind::Union(..) => {\n                 let variant = tcx.adt_def(def_id).non_enum_variant();\n                 let repr_options = get_repr_options(&tcx, def_id);\n \n@@ -1097,7 +1097,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     ctor_sig: None,\n                 }), repr_options)\n             }\n-            hir::ItemImpl(_, polarity, defaultness, ..) => {\n+            hir::ItemKind::Impl(_, polarity, defaultness, ..) => {\n                 let trait_ref = tcx.impl_trait_ref(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n                     let trait_def = tcx.trait_def(trait_ref.def_id);\n@@ -1132,7 +1132,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n                 EntryKind::Impl(self.lazy(&data))\n             }\n-            hir::ItemTrait(..) => {\n+            hir::ItemKind::Trait(..) => {\n                 let trait_def = tcx.trait_def(def_id);\n                 let data = TraitData {\n                     unsafety: trait_def.unsafety,\n@@ -1143,9 +1143,9 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n                 EntryKind::Trait(self.lazy(&data))\n             }\n-            hir::ItemExternCrate(_) |\n-            hir::ItemTraitAlias(..) |\n-            hir::ItemUse(..) => bug!(\"cannot encode info for item {:?}\", item),\n+            hir::ItemKind::ExternCrate(_) |\n+            hir::ItemKind::TraitAlias(..) |\n+            hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         };\n \n         Entry {\n@@ -1154,28 +1154,28 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             span: self.lazy(&item.span),\n             attributes: self.encode_attributes(&item.attrs),\n             children: match item.node {\n-                hir::ItemForeignMod(ref fm) => {\n+                hir::ItemKind::ForeignMod(ref fm) => {\n                     self.lazy_seq(fm.items\n                         .iter()\n                         .map(|foreign_item| tcx.hir.local_def_id(foreign_item.id).index))\n                 }\n-                hir::ItemEnum(..) => {\n+                hir::ItemKind::Enum(..) => {\n                     let def = self.tcx.adt_def(def_id);\n                     self.lazy_seq(def.variants.iter().map(|v| {\n                         assert!(v.did.is_local());\n                         v.did.index\n                     }))\n                 }\n-                hir::ItemStruct(..) |\n-                hir::ItemUnion(..) => {\n+                hir::ItemKind::Struct(..) |\n+                hir::ItemKind::Union(..) => {\n                     let def = self.tcx.adt_def(def_id);\n                     self.lazy_seq(def.non_enum_variant().fields.iter().map(|f| {\n                         assert!(f.did.is_local());\n                         f.did.index\n                     }))\n                 }\n-                hir::ItemImpl(..) |\n-                hir::ItemTrait(..) => {\n+                hir::ItemKind::Impl(..) |\n+                hir::ItemKind::Trait(..) => {\n                     self.lazy_seq(tcx.associated_item_def_ids(def_id).iter().map(|&def_id| {\n                         assert!(def_id.is_local());\n                         def_id.index\n@@ -1187,49 +1187,49 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: match item.node {\n-                hir::ItemStatic(..) |\n-                hir::ItemConst(..) |\n-                hir::ItemFn(..) |\n-                hir::ItemTy(..) |\n-                hir::ItemExistential(..) |\n-                hir::ItemEnum(..) |\n-                hir::ItemStruct(..) |\n-                hir::ItemUnion(..) |\n-                hir::ItemImpl(..) => Some(self.encode_item_type(def_id)),\n+                hir::ItemKind::Static(..) |\n+                hir::ItemKind::Const(..) |\n+                hir::ItemKind::Fn(..) |\n+                hir::ItemKind::Ty(..) |\n+                hir::ItemKind::Existential(..) |\n+                hir::ItemKind::Enum(..) |\n+                hir::ItemKind::Struct(..) |\n+                hir::ItemKind::Union(..) |\n+                hir::ItemKind::Impl(..) => Some(self.encode_item_type(def_id)),\n                 _ => None,\n             },\n             inherent_impls: self.encode_inherent_implementations(def_id),\n             variances: match item.node {\n-                hir::ItemEnum(..) |\n-                hir::ItemStruct(..) |\n-                hir::ItemUnion(..) |\n-                hir::ItemFn(..) => self.encode_variances_of(def_id),\n+                hir::ItemKind::Enum(..) |\n+                hir::ItemKind::Struct(..) |\n+                hir::ItemKind::Union(..) |\n+                hir::ItemKind::Fn(..) => self.encode_variances_of(def_id),\n                 _ => LazySeq::empty(),\n             },\n             generics: match item.node {\n-                hir::ItemStatic(..) |\n-                hir::ItemConst(..) |\n-                hir::ItemFn(..) |\n-                hir::ItemTy(..) |\n-                hir::ItemEnum(..) |\n-                hir::ItemStruct(..) |\n-                hir::ItemUnion(..) |\n-                hir::ItemImpl(..) |\n-                hir::ItemExistential(..) |\n-                hir::ItemTrait(..) => Some(self.encode_generics(def_id)),\n+                hir::ItemKind::Static(..) |\n+                hir::ItemKind::Const(..) |\n+                hir::ItemKind::Fn(..) |\n+                hir::ItemKind::Ty(..) |\n+                hir::ItemKind::Enum(..) |\n+                hir::ItemKind::Struct(..) |\n+                hir::ItemKind::Union(..) |\n+                hir::ItemKind::Impl(..) |\n+                hir::ItemKind::Existential(..) |\n+                hir::ItemKind::Trait(..) => Some(self.encode_generics(def_id)),\n                 _ => None,\n             },\n             predicates: match item.node {\n-                hir::ItemStatic(..) |\n-                hir::ItemConst(..) |\n-                hir::ItemFn(..) |\n-                hir::ItemTy(..) |\n-                hir::ItemEnum(..) |\n-                hir::ItemStruct(..) |\n-                hir::ItemUnion(..) |\n-                hir::ItemImpl(..) |\n-                hir::ItemExistential(..) |\n-                hir::ItemTrait(..) => Some(self.encode_predicates(def_id)),\n+                hir::ItemKind::Static(..) |\n+                hir::ItemKind::Const(..) |\n+                hir::ItemKind::Fn(..) |\n+                hir::ItemKind::Ty(..) |\n+                hir::ItemKind::Enum(..) |\n+                hir::ItemKind::Struct(..) |\n+                hir::ItemKind::Union(..) |\n+                hir::ItemKind::Impl(..) |\n+                hir::ItemKind::Existential(..) |\n+                hir::ItemKind::Trait(..) => Some(self.encode_predicates(def_id)),\n                 _ => None,\n             },\n \n@@ -1239,16 +1239,16 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             // hack. (No reason not to expand it in the future if\n             // necessary.)\n             predicates_defined_on: match item.node {\n-                hir::ItemTrait(..) => Some(self.encode_predicates_defined_on(def_id)),\n+                hir::ItemKind::Trait(..) => Some(self.encode_predicates_defined_on(def_id)),\n                 _ => None, // not *wrong* for other kinds of items, but not needed\n             },\n \n             mir: match item.node {\n-                hir::ItemStatic(..) => {\n+                hir::ItemKind::Static(..) => {\n                     self.encode_optimized_mir(def_id)\n                 }\n-                hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n-                hir::ItemFn(_, header, ..) => {\n+                hir::ItemKind::Const(..) => self.encode_optimized_mir(def_id),\n+                hir::ItemKind::Fn(_, header, ..) => {\n                     let generics = tcx.generics_of(def_id);\n                     let has_types = generics.params.iter().any(|param| match param.kind {\n                         ty::GenericParamDefKind::Type { .. } => true,\n@@ -1561,17 +1561,17 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_foreign_item({:?})\", def_id);\n \n         let kind = match nitem.node {\n-            hir::ForeignItemFn(_, ref names, _) => {\n+            hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n                     constness: hir::Constness::NotConst,\n                     arg_names: self.encode_fn_arg_names(names),\n                     sig: self.lazy(&tcx.fn_sig(def_id)),\n                 };\n                 EntryKind::ForeignFn(self.lazy(&data))\n             }\n-            hir::ForeignItemStatic(_, true) => EntryKind::ForeignMutStatic,\n-            hir::ForeignItemStatic(_, false) => EntryKind::ForeignImmStatic,\n-            hir::ForeignItemType => EntryKind::ForeignType,\n+            hir::ForeignItemKind::Static(_, true) => EntryKind::ForeignMutStatic,\n+            hir::ForeignItemKind::Static(_, false) => EntryKind::ForeignImmStatic,\n+            hir::ForeignItemKind::Type => EntryKind::ForeignType,\n         };\n \n         Entry {\n@@ -1586,7 +1586,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n             variances: match nitem.node {\n-                hir::ForeignItemFn(..) => self.encode_variances_of(def_id),\n+                hir::ForeignItemKind::Fn(..) => self.encode_variances_of(def_id),\n                 _ => LazySeq::empty(),\n             },\n             generics: Some(self.encode_generics(def_id)),\n@@ -1614,8 +1614,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         intravisit::walk_item(self, item);\n         let def_id = self.index.tcx.hir.local_def_id(item.id);\n         match item.node {\n-            hir::ItemExternCrate(_) |\n-            hir::ItemUse(..) => (), // ignore these\n+            hir::ItemKind::ExternCrate(_) |\n+            hir::ItemKind::Use(..) => (), // ignore these\n             _ => self.index.record(def_id, IsolatedEncoder::encode_info_for_item, (def_id, item)),\n         }\n         self.index.encode_addl_info_for_item(item);\n@@ -1678,7 +1678,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         match ty.node {\n-            hir::TyArray(_, ref length) => {\n+            hir::TyKind::Array(_, ref length) => {\n                 let def_id = self.tcx.hir.local_def_id(length.id);\n                 self.record(def_id, IsolatedEncoder::encode_info_for_anon_const, def_id);\n             }\n@@ -1688,7 +1688,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n-            hir::ExprClosure(..) => {\n+            hir::ExprKind::Closure(..) => {\n                 let def_id = self.tcx.hir.local_def_id(expr.id);\n                 self.record(def_id, IsolatedEncoder::encode_info_for_closure, def_id);\n             }\n@@ -1703,20 +1703,20 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n         let def_id = self.tcx.hir.local_def_id(item.id);\n         match item.node {\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) |\n-            hir::ItemFn(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemGlobalAsm(..) |\n-            hir::ItemExternCrate(..) |\n-            hir::ItemUse(..) |\n-            hir::ItemTy(..) |\n-            hir::ItemExistential(..) |\n-            hir::ItemTraitAlias(..) => {\n+            hir::ItemKind::Static(..) |\n+            hir::ItemKind::Const(..) |\n+            hir::ItemKind::Fn(..) |\n+            hir::ItemKind::Mod(..) |\n+            hir::ItemKind::ForeignMod(..) |\n+            hir::ItemKind::GlobalAsm(..) |\n+            hir::ItemKind::ExternCrate(..) |\n+            hir::ItemKind::Use(..) |\n+            hir::ItemKind::Ty(..) |\n+            hir::ItemKind::Existential(..) |\n+            hir::ItemKind::TraitAlias(..) => {\n                 // no sub-item recording needed in these cases\n             }\n-            hir::ItemEnum(..) => {\n+            hir::ItemKind::Enum(..) => {\n                 self.encode_fields(def_id);\n \n                 let def = self.tcx.adt_def(def_id);\n@@ -1726,7 +1726,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                                 (def_id, Untracked(i)));\n                 }\n             }\n-            hir::ItemStruct(ref struct_def, _) => {\n+            hir::ItemKind::Struct(ref struct_def, _) => {\n                 self.encode_fields(def_id);\n \n                 // If the struct has a constructor, encode it.\n@@ -1737,17 +1737,17 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                                 (def_id, ctor_def_id));\n                 }\n             }\n-            hir::ItemUnion(..) => {\n+            hir::ItemKind::Union(..) => {\n                 self.encode_fields(def_id);\n             }\n-            hir::ItemImpl(..) => {\n+            hir::ItemKind::Impl(..) => {\n                 for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.record(trait_item_def_id,\n                                 IsolatedEncoder::encode_info_for_impl_item,\n                                 trait_item_def_id);\n                 }\n             }\n-            hir::ItemTrait(..) => {\n+            hir::ItemKind::Trait(..) => {\n                 for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.record(item_def_id,\n                                 IsolatedEncoder::encode_info_for_trait_item,\n@@ -1765,7 +1765,7 @@ struct ImplVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemImpl(..) = item.node {\n+        if let hir::ItemKind::Impl(..) = item.node {\n             let impl_id = self.tcx.hir.local_def_id(item.id);\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n                 self.impls"}, {"sha": "e96d56fb3889351f9336403be121af06048282fb", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -30,7 +30,7 @@ struct Collector<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         let fm = match it.node {\n-            hir::ItemForeignMod(ref fm) => fm,\n+            hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n         };\n "}, {"sha": "008e1e363ff53881cc7eefd261aa04e37cadd856", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -37,7 +37,7 @@ struct Collector {\n impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         let fm = match it.node {\n-            hir::ItemForeignMod(ref fm) => fm,\n+            hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n         };\n         if fm.abi == Abi::Rust ||"}, {"sha": "327b2abc4d318b8829d4dff13d322576205e380a", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -45,7 +45,7 @@ struct Collector<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         let fm = match it.node {\n-            hir::ItemForeignMod(ref fm) => fm,\n+            hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n         };\n "}, {"sha": "c481d1d325b32dbf0141ca3de3121cf11bd7846e", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -207,7 +207,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         maybe_closure_span: Span,\n         location: Location,\n     ) -> Option<(Span, Span)> {\n-        use rustc::hir::ExprClosure;\n+        use rustc::hir::ExprKind::Closure;\n         use rustc::mir::AggregateKind;\n \n         let local = match self.mir[location.block]\n@@ -231,7 +231,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     debug!(\"find_closure_span: found closure {:?}\", places);\n \n                     return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                        let args_span = if let ExprClosure(_, _, _, span, _) =\n+                        let args_span = if let Closure(_, _, _, span, _) =\n                             self.tcx.hir.expect_expr(node_id).node\n                         {\n                             span"}, {"sha": "e7f00b577b39fa583503926129adcd0c36033960", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -232,7 +232,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n \n     let movable_generator = match tcx.hir.get(id) {\n         hir::map::Node::NodeExpr(&hir::Expr {\n-            node: hir::ExprClosure(.., Some(hir::GeneratorMovability::Static)),\n+            node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => false,\n         _ => true,"}, {"sha": "fc0e64d0a8a66aa3e4f54d8859e3181b6b01cf26", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -201,7 +201,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // This indicates a variable with no type annotation, like\n             // `|x|`... in that case, we can't highlight the type but\n             // must highlight the variable.\n-            hir::TyInfer => None,\n+            hir::TyKind::Infer => None,\n \n             _ => self.give_name_if_we_can_match_hir_ty(\n                 tcx,\n@@ -263,7 +263,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 //\n                 //     &\n                 //     - let's call the lifetime of this reference `'1`\n-                (ty::TyRef(region, referent_ty, _), hir::TyRptr(_lifetime, referent_hir_ty)) => {\n+                (\n+                    ty::TyRef(region, referent_ty, _),\n+                    hir::TyKind::Rptr(_lifetime, referent_hir_ty),\n+                ) => {\n                     if region.to_region_vid() == needle_fr {\n                         let region_name = self.synthesize_region_name(counter);\n \n@@ -287,7 +290,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n \n                 // Match up something like `Foo<'1>`\n-                (ty::TyAdt(_adt_def, substs), hir::TyPath(hir::QPath::Resolved(None, path))) => {\n+                (\n+                    ty::TyAdt(_adt_def, substs),\n+                    hir::TyKind::Path(hir::QPath::Resolved(None, path)),\n+                ) => {\n                     if let Some(last_segment) = path.segments.last() {\n                         if let Some(name) = self.match_adt_and_segment(\n                             substs,\n@@ -305,16 +311,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // The following cases don't have lifetimes, so we\n                 // just worry about trying to match up the rustc type\n                 // with the HIR types:\n-                (ty::TyTuple(elem_tys), hir::TyTup(elem_hir_tys)) => {\n+                (ty::TyTuple(elem_tys), hir::TyKind::Tup(elem_hir_tys)) => {\n                     search_stack.extend(elem_tys.iter().cloned().zip(elem_hir_tys));\n                 }\n \n-                (ty::TySlice(elem_ty), hir::TySlice(elem_hir_ty))\n-                | (ty::TyArray(elem_ty, _), hir::TyArray(elem_hir_ty, _)) => {\n+                (ty::TySlice(elem_ty), hir::TyKind::Slice(elem_hir_ty))\n+                | (ty::TyArray(elem_ty, _), hir::TyKind::Array(elem_hir_ty, _)) => {\n                     search_stack.push((elem_ty, elem_hir_ty));\n                 }\n \n-                (ty::TyRawPtr(mut_ty), hir::TyPtr(mut_hir_ty)) => {\n+                (ty::TyRawPtr(mut_ty), hir::TyKind::Ptr(mut_hir_ty)) => {\n                     search_stack.push((mut_ty.ty, &mut_hir_ty.ty));\n                 }\n "}, {"sha": "6c8b5d97b6ff314abb58ec95be28d7ed02c9998e", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -55,8 +55,8 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         let hir_id = cx.tcx.hir.node_to_hir_id(stmt.node.id());\n         let opt_dxn_ext = cx.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n         match stmt.node {\n-            hir::StmtExpr(ref expr, _) |\n-            hir::StmtSemi(ref expr, _) => {\n+            hir::StmtKind::Expr(ref expr, _) |\n+            hir::StmtKind::Semi(ref expr, _) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     kind: StmtKind::Expr {\n                         scope: region::Scope::Node(hir_id.local_id),\n@@ -65,12 +65,12 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     opt_destruction_scope: opt_dxn_ext,\n                 })))\n             }\n-            hir::StmtDecl(ref decl, _) => {\n+            hir::StmtKind::Decl(ref decl, _) => {\n                 match decl.node {\n-                    hir::DeclItem(..) => {\n+                    hir::DeclKind::Item(..) => {\n                         // ignore for purposes of the MIR\n                     }\n-                    hir::DeclLocal(ref local) => {\n+                    hir::DeclKind::Local(ref local) => {\n                         let remainder_scope = region::Scope::Remainder(BlockRemainder {\n                             block: block_id,\n                             first_statement_index: region::FirstStatementIndex::new(index),"}, {"sha": "13b2a0ab874191febe9820dfc9f12a2a202af9fd", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -200,7 +200,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     let kind = match expr.node {\n         // Here comes the interesting stuff:\n-        hir::ExprMethodCall(.., ref args) => {\n+        hir::ExprKind::MethodCall(.., ref args) => {\n             // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n             let expr = method_callee(cx, expr, None);\n             let args = args.iter()\n@@ -213,7 +213,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprCall(ref fun, ref args) => {\n+        hir::ExprKind::Call(ref fun, ref args) => {\n             if cx.tables().is_method_call(expr) {\n                 // The callee is something implementing Fn, FnMut, or FnOnce.\n                 // Find the actual method implementation being called and\n@@ -238,8 +238,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     args: vec![fun.to_ref(), tupled_args.to_ref()],\n                 }\n             } else {\n-                let adt_data = if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = fun.node {\n-                    // Tuple-like ADTs are represented as ExprCall. We convert them here.\n+                let adt_data = if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) =\n+                    fun.node\n+                {\n+                    // Tuple-like ADTs are represented as ExprKind::Call. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def| {\n                         match path.def {\n                             Def::VariantCtor(variant_id, CtorKind::Fn) => {\n@@ -280,7 +282,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprAddrOf(mutbl, ref expr) => {\n+        hir::ExprKind::AddrOf(mutbl, ref expr) => {\n             let region = match expr_ty.sty {\n                 ty::TyRef(r, _, _) => r,\n                 _ => span_bug!(expr.span, \"type of & not region\"),\n@@ -292,16 +294,16 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprBlock(ref blk, _) => ExprKind::Block { body: &blk },\n+        hir::ExprKind::Block(ref blk, _) => ExprKind::Block { body: &blk },\n \n-        hir::ExprAssign(ref lhs, ref rhs) => {\n+        hir::ExprKind::Assign(ref lhs, ref rhs) => {\n             ExprKind::Assign {\n                 lhs: lhs.to_ref(),\n                 rhs: rhs.to_ref(),\n             }\n         }\n \n-        hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+        hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n             if cx.tables().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![lhs.to_ref(), rhs.to_ref()])\n             } else {\n@@ -313,41 +315,41 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprLit(ref lit) => ExprKind::Literal {\n+        hir::ExprKind::Lit(ref lit) => ExprKind::Literal {\n             literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, false),\n         },\n \n-        hir::ExprBinary(op, ref lhs, ref rhs) => {\n+        hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n             if cx.tables().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![lhs.to_ref(), rhs.to_ref()])\n             } else {\n                 // FIXME overflow\n                 match (op.node, cx.constness) {\n                     // FIXME(eddyb) use logical ops in constants when\n                     // they can handle that kind of control-flow.\n-                    (hir::BinOp_::BiAnd, hir::Constness::Const) => {\n+                    (hir::BinOpKind::And, hir::Constness::Const) => {\n                         ExprKind::Binary {\n                             op: BinOp::BitAnd,\n                             lhs: lhs.to_ref(),\n                             rhs: rhs.to_ref(),\n                         }\n                     }\n-                    (hir::BinOp_::BiOr, hir::Constness::Const) => {\n+                    (hir::BinOpKind::Or, hir::Constness::Const) => {\n                         ExprKind::Binary {\n                             op: BinOp::BitOr,\n                             lhs: lhs.to_ref(),\n                             rhs: rhs.to_ref(),\n                         }\n                     }\n \n-                    (hir::BinOp_::BiAnd, hir::Constness::NotConst) => {\n+                    (hir::BinOpKind::And, hir::Constness::NotConst) => {\n                         ExprKind::LogicalOp {\n                             op: LogicalOp::And,\n                             lhs: lhs.to_ref(),\n                             rhs: rhs.to_ref(),\n                         }\n                     }\n-                    (hir::BinOp_::BiOr, hir::Constness::NotConst) => {\n+                    (hir::BinOpKind::Or, hir::Constness::NotConst) => {\n                         ExprKind::LogicalOp {\n                             op: LogicalOp::Or,\n                             lhs: lhs.to_ref(),\n@@ -367,7 +369,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprIndex(ref lhs, ref index) => {\n+        hir::ExprKind::Index(ref lhs, ref index) => {\n             if cx.tables().is_method_call(expr) {\n                 overloaded_place(cx, expr, expr_ty, None, vec![lhs.to_ref(), index.to_ref()])\n             } else {\n@@ -378,15 +380,15 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n+        hir::ExprKind::Unary(hir::UnOp::UnDeref, ref arg) => {\n             if cx.tables().is_method_call(expr) {\n                 overloaded_place(cx, expr, expr_ty, None, vec![arg.to_ref()])\n             } else {\n                 ExprKind::Deref { arg: arg.to_ref() }\n             }\n         }\n \n-        hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n+        hir::ExprKind::Unary(hir::UnOp::UnNot, ref arg) => {\n             if cx.tables().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n@@ -397,11 +399,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n+        hir::ExprKind::Unary(hir::UnOp::UnNeg, ref arg) => {\n             if cx.tables().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n-                if let hir::ExprLit(ref lit) = arg.node {\n+                if let hir::ExprKind::Lit(ref lit) = arg.node {\n                     ExprKind::Literal {\n                         literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n                     }\n@@ -414,7 +416,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprStruct(ref qpath, ref fields, ref base) => {\n+        hir::ExprKind::Struct(ref qpath, ref fields, ref base) => {\n             match expr_ty.sty {\n                 ty::TyAdt(adt, substs) => {\n                     match adt.adt_kind() {\n@@ -467,7 +469,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprClosure(..) => {\n+        hir::ExprKind::Closure(..) => {\n             let closure_ty = cx.tables().expr_ty(expr);\n             let (def_id, substs, movability) = match closure_ty.sty {\n                 ty::TyClosure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n@@ -492,12 +494,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprPath(ref qpath) => {\n+        hir::ExprKind::Path(ref qpath) => {\n             let def = cx.tables().qpath_def(qpath, expr.hir_id);\n             convert_path_expr(cx, expr, def)\n         }\n \n-        hir::ExprInlineAsm(ref asm, ref outputs, ref inputs) => {\n+        hir::ExprKind::InlineAsm(ref asm, ref outputs, ref inputs) => {\n             ExprKind::InlineAsm {\n                 asm,\n                 outputs: outputs.to_ref(),\n@@ -506,7 +508,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         // Now comes the rote stuff:\n-        hir::ExprRepeat(ref v, ref count) => {\n+        hir::ExprKind::Repeat(ref v, ref count) => {\n             let def_id = cx.tcx.hir.local_def_id(count.id);\n             let substs = Substs::identity_for_item(cx.tcx.global_tcx(), def_id);\n             let instance = ty::Instance::resolve(\n@@ -533,8 +535,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 count,\n             }\n         }\n-        hir::ExprRet(ref v) => ExprKind::Return { value: v.to_ref() },\n-        hir::ExprBreak(dest, ref value) => {\n+        hir::ExprKind::Ret(ref v) => ExprKind::Return { value: v.to_ref() },\n+        hir::ExprKind::Break(dest, ref value) => {\n             match dest.target_id {\n                 Ok(target_id) => ExprKind::Break {\n                     label: region::Scope::Node(cx.tcx.hir.node_to_hir_id(target_id).local_id),\n@@ -543,46 +545,46 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 Err(err) => bug!(\"invalid loop id for break: {}\", err)\n             }\n         }\n-        hir::ExprContinue(dest) => {\n+        hir::ExprKind::Continue(dest) => {\n             match dest.target_id {\n                 Ok(loop_id) => ExprKind::Continue {\n                     label: region::Scope::Node(cx.tcx.hir.node_to_hir_id(loop_id).local_id),\n                 },\n                 Err(err) => bug!(\"invalid loop id for continue: {}\", err)\n             }\n         }\n-        hir::ExprMatch(ref discr, ref arms, _) => {\n+        hir::ExprKind::Match(ref discr, ref arms, _) => {\n             ExprKind::Match {\n                 discriminant: discr.to_ref(),\n                 arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n             }\n         }\n-        hir::ExprIf(ref cond, ref then, ref otherwise) => {\n+        hir::ExprKind::If(ref cond, ref then, ref otherwise) => {\n             ExprKind::If {\n                 condition: cond.to_ref(),\n                 then: then.to_ref(),\n                 otherwise: otherwise.to_ref(),\n             }\n         }\n-        hir::ExprWhile(ref cond, ref body, _) => {\n+        hir::ExprKind::While(ref cond, ref body, _) => {\n             ExprKind::Loop {\n                 condition: Some(cond.to_ref()),\n                 body: block::to_expr_ref(cx, body),\n             }\n         }\n-        hir::ExprLoop(ref body, _, _) => {\n+        hir::ExprKind::Loop(ref body, _, _) => {\n             ExprKind::Loop {\n                 condition: None,\n                 body: block::to_expr_ref(cx, body),\n             }\n         }\n-        hir::ExprField(ref source, ..) => {\n+        hir::ExprKind::Field(ref source, ..) => {\n             ExprKind::Field {\n                 lhs: source.to_ref(),\n                 name: Field::new(cx.tcx.field_index(expr.id, cx.tables)),\n             }\n         }\n-        hir::ExprCast(ref source, _) => {\n+        hir::ExprKind::Cast(ref source, _) => {\n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n             if let Some(&TyCastKind::CoercionCast) = cx.tables()\n@@ -602,7 +604,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 // }\n                 // The correct solution would be to add symbolic computations to miri,\n                 // so we wouldn't have to compute and store the actual value\n-                let var = if let hir::ExprPath(ref qpath) = source.node {\n+                let var = if let hir::ExprKind::Path(ref qpath) = source.node {\n                     let def = cx.tables().qpath_def(qpath, source.hir_id);\n                     cx\n                         .tables()\n@@ -666,16 +668,16 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ExprKind::Cast { source }\n             }\n         }\n-        hir::ExprType(ref source, _) => return source.make_mirror(cx),\n-        hir::ExprBox(ref value) => {\n+        hir::ExprKind::Type(ref source, _) => return source.make_mirror(cx),\n+        hir::ExprKind::Box(ref value) => {\n             ExprKind::Box {\n                 value: value.to_ref(),\n             }\n         }\n-        hir::ExprArray(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n-        hir::ExprTup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n+        hir::ExprKind::Array(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n+        hir::ExprKind::Tup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n \n-        hir::ExprYield(ref v) => ExprKind::Yield { value: v.to_ref() },\n+        hir::ExprKind::Yield(ref v) => ExprKind::Yield { value: v.to_ref() },\n     };\n \n     Expr {\n@@ -930,24 +932,24 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n }\n \n \n-fn bin_op(op: hir::BinOp_) -> BinOp {\n+fn bin_op(op: hir::BinOpKind) -> BinOp {\n     match op {\n-        hir::BinOp_::BiAdd => BinOp::Add,\n-        hir::BinOp_::BiSub => BinOp::Sub,\n-        hir::BinOp_::BiMul => BinOp::Mul,\n-        hir::BinOp_::BiDiv => BinOp::Div,\n-        hir::BinOp_::BiRem => BinOp::Rem,\n-        hir::BinOp_::BiBitXor => BinOp::BitXor,\n-        hir::BinOp_::BiBitAnd => BinOp::BitAnd,\n-        hir::BinOp_::BiBitOr => BinOp::BitOr,\n-        hir::BinOp_::BiShl => BinOp::Shl,\n-        hir::BinOp_::BiShr => BinOp::Shr,\n-        hir::BinOp_::BiEq => BinOp::Eq,\n-        hir::BinOp_::BiLt => BinOp::Lt,\n-        hir::BinOp_::BiLe => BinOp::Le,\n-        hir::BinOp_::BiNe => BinOp::Ne,\n-        hir::BinOp_::BiGe => BinOp::Ge,\n-        hir::BinOp_::BiGt => BinOp::Gt,\n+        hir::BinOpKind::Add => BinOp::Add,\n+        hir::BinOpKind::Sub => BinOp::Sub,\n+        hir::BinOpKind::Mul => BinOp::Mul,\n+        hir::BinOpKind::Div => BinOp::Div,\n+        hir::BinOpKind::Rem => BinOp::Rem,\n+        hir::BinOpKind::BitXor => BinOp::BitXor,\n+        hir::BinOpKind::BitAnd => BinOp::BitAnd,\n+        hir::BinOpKind::BitOr => BinOp::BitOr,\n+        hir::BinOpKind::Shl => BinOp::Shl,\n+        hir::BinOpKind::Shr => BinOp::Shr,\n+        hir::BinOpKind::Eq => BinOp::Eq,\n+        hir::BinOpKind::Lt => BinOp::Lt,\n+        hir::BinOpKind::Le => BinOp::Le,\n+        hir::BinOpKind::Ne => BinOp::Ne,\n+        hir::BinOpKind::Ge => BinOp::Ge,\n+        hir::BinOpKind::Gt => BinOp::Gt,\n         _ => bug!(\"no equivalent for ast binop {:?}\", op),\n     }\n }"}, {"sha": "35f9dcee99f82b684c1852f4e01065b8518e434d", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, ex);\n \n         match ex.node {\n-            hir::ExprMatch(ref scrut, ref arms, source) => {\n+            hir::ExprKind::Match(ref scrut, ref arms, source) => {\n                 self.check_match(scrut, arms, source);\n             }\n             _ => {}"}, {"sha": "53511c1c127dd3a608813cf38a92c0f4cd58ed92", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -733,7 +733,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     /// afterwards.\n     fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatternKind<'tcx> {\n         match expr.node {\n-            hir::ExprLit(ref lit) => {\n+            hir::ExprKind::Lit(ref lit) => {\n                 let ty = self.tables.expr_ty(expr);\n                 match lit_to_const(&lit.node, self.tcx, ty, false) {\n                     Ok(val) => {\n@@ -751,11 +751,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     },\n                 }\n             },\n-            hir::ExprPath(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n-            hir::ExprUnary(hir::UnNeg, ref expr) => {\n+            hir::ExprKind::Path(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n+            hir::ExprKind::Unary(hir::UnNeg, ref expr) => {\n                 let ty = self.tables.expr_ty(expr);\n                 let lit = match expr.node {\n-                    hir::ExprLit(ref lit) => lit,\n+                    hir::ExprKind::Lit(ref lit) => lit,\n                     _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n                 };\n                 match lit_to_const(&lit.node, self.tcx, ty, true) {"}, {"sha": "a2d620db9243fe2a58ab4f7b1e470367b4c89686", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -945,28 +945,28 @@ struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemExternCrate(..) |\n-            hir::ItemUse(..)         |\n-            hir::ItemForeignMod(..)  |\n-            hir::ItemTy(..)          |\n-            hir::ItemTrait(..)       |\n-            hir::ItemTraitAlias(..)  |\n-            hir::ItemExistential(..) |\n-            hir::ItemMod(..)         => {\n+            hir::ItemKind::ExternCrate(..) |\n+            hir::ItemKind::Use(..)         |\n+            hir::ItemKind::ForeignMod(..)  |\n+            hir::ItemKind::Ty(..)          |\n+            hir::ItemKind::Trait(..)       |\n+            hir::ItemKind::TraitAlias(..)  |\n+            hir::ItemKind::Existential(..) |\n+            hir::ItemKind::Mod(..)         => {\n                 // Nothing to do, just keep recursing...\n             }\n \n-            hir::ItemImpl(..) => {\n+            hir::ItemKind::Impl(..) => {\n                 if self.mode == MonoItemCollectionMode::Eager {\n                     create_mono_items_for_default_impls(self.tcx,\n                                                         item,\n                                                         self.output);\n                 }\n             }\n \n-            hir::ItemEnum(_, ref generics) |\n-            hir::ItemStruct(_, ref generics) |\n-            hir::ItemUnion(_, ref generics) => {\n+            hir::ItemKind::Enum(_, ref generics) |\n+            hir::ItemKind::Struct(_, ref generics) |\n+            hir::ItemKind::Union(_, ref generics) => {\n                 if generics.params.is_empty() {\n                     if self.mode == MonoItemCollectionMode::Eager {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n@@ -978,19 +978,19 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                     }\n                 }\n             }\n-            hir::ItemGlobalAsm(..) => {\n-                debug!(\"RootCollector: ItemGlobalAsm({})\",\n+            hir::ItemKind::GlobalAsm(..) => {\n+                debug!(\"RootCollector: ItemKind::GlobalAsm({})\",\n                        def_id_to_string(self.tcx,\n                                         self.tcx.hir.local_def_id(item.id)));\n                 self.output.push(MonoItem::GlobalAsm(item.id));\n             }\n-            hir::ItemStatic(..) => {\n+            hir::ItemKind::Static(..) => {\n                 let def_id = self.tcx.hir.local_def_id(item.id);\n-                debug!(\"RootCollector: ItemStatic({})\",\n+                debug!(\"RootCollector: ItemKind::Static({})\",\n                        def_id_to_string(self.tcx, def_id));\n                 self.output.push(MonoItem::Static(def_id));\n             }\n-            hir::ItemConst(..) => {\n+            hir::ItemKind::Const(..) => {\n                 // const items only generate mono items if they are\n                 // actually used somewhere. Just declaring them is insufficient.\n \n@@ -1001,7 +1001,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                     self.output.push(MonoItem::CustomSection(def_id));\n                 }\n             }\n-            hir::ItemFn(..) => {\n+            hir::ItemKind::Fn(..) => {\n                 let def_id = self.tcx.hir.local_def_id(item.id);\n                 self.push_if_root(def_id);\n             }\n@@ -1102,7 +1102,7 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  item: &'tcx hir::Item,\n                                                  output: &mut Vec<MonoItem<'tcx>>) {\n     match item.node {\n-        hir::ItemImpl(_, _, _, ref generics, .., ref impl_item_refs) => {\n+        hir::ItemKind::Impl(_, _, _, ref generics, .., ref impl_item_refs) => {\n             for param in &generics.params {\n                 match param.kind {\n                     hir::GenericParamKind::Lifetime { .. } => {}"}, {"sha": "9c341b38e34f82b08d885e8614feb742662332a7", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -141,7 +141,7 @@ fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) ->\n             }\n             // Check if this is an unsafe block, or an item\n             match node {\n-                Node::NodeExpr(&hir::Expr { node: hir::ExprBlock(ref block, _), ..}) => {\n+                Node::NodeExpr(&hir::Expr { node: hir::ExprKind::Block(ref block, _), ..}) => {\n                     if block_is_unsafe(&*block) {\n                         // Found an unsafe block, we can bail out here.\n                         return true;"}, {"sha": "b4f0a7cd6c4b5e5a9366c3f4ac6126ffecf7c4d0", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -405,7 +405,7 @@ fn is_enclosed(tcx: TyCtxt,\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n         } else if let Some(hir::map::NodeItem(&hir::Item {\n-            node: hir::ItemFn(_, header, _, _),\n+            node: hir::ItemKind::Fn(_, header, _, _),\n             ..\n         })) = tcx.hir.find(parent_id) {\n             match header.unsafety {"}, {"sha": "8ef20126e035fdb48dc88d3584f0e18598d13600", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -78,23 +78,23 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n     fn visit_expr(&mut self, e: &'hir hir::Expr) {\n         match e.node {\n-            hir::ExprWhile(ref e, ref b, _) => {\n+            hir::ExprKind::While(ref e, ref b, _) => {\n                 self.with_context(Loop(LoopKind::WhileLoop), |v| {\n                     v.visit_expr(&e);\n                     v.visit_block(&b);\n                 });\n             }\n-            hir::ExprLoop(ref b, _, source) => {\n+            hir::ExprKind::Loop(ref b, _, source) => {\n                 self.with_context(Loop(LoopKind::Loop(source)), |v| v.visit_block(&b));\n             }\n-            hir::ExprClosure(_, ref function_decl, b, _, _) => {\n+            hir::ExprKind::Closure(_, ref function_decl, b, _, _) => {\n                 self.visit_fn_decl(&function_decl);\n                 self.with_context(Closure, |v| v.visit_nested_body(b));\n             }\n-            hir::ExprBlock(ref b, Some(_label)) => {\n+            hir::ExprKind::Block(ref b, Some(_label)) => {\n                 self.with_context(LabeledBlock, |v| v.visit_block(&b));\n             }\n-            hir::ExprBreak(label, ref opt_expr) => {\n+            hir::ExprKind::Break(label, ref opt_expr) => {\n                 opt_expr.as_ref().map(|e| self.visit_expr(e));\n \n                 if self.require_label_in_labeled_block(e.span, &label, \"break\") {\n@@ -125,8 +125,8 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                         None\n                     } else {\n                         Some(match self.hir_map.expect_expr(loop_id).node {\n-                            hir::ExprWhile(..) => LoopKind::WhileLoop,\n-                            hir::ExprLoop(_, _, source) => LoopKind::Loop(source),\n+                            hir::ExprKind::While(..) => LoopKind::WhileLoop,\n+                            hir::ExprKind::Loop(_, _, source) => LoopKind::Loop(source),\n                             ref r => span_bug!(e.span,\n                                                \"break label resolved to a non-loop: {:?}\", r),\n                         })\n@@ -153,7 +153,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 self.require_break_cx(\"break\", e.span);\n             }\n-            hir::ExprContinue(label) => {\n+            hir::ExprKind::Continue(label) => {\n                 self.require_label_in_labeled_block(e.span, &label, \"continue\");\n \n                 match label.target_id {"}, {"sha": "d223dc2a353356799375a9aa818905415b1c0879", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -261,9 +261,9 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     fn check_stmt(&mut self, stmt: &'tcx hir::Stmt) -> Promotability {\n         match stmt.node {\n-            hir::StmtDecl(ref decl, _node_id) => {\n+            hir::StmtKind::Decl(ref decl, _node_id) => {\n                 match &decl.node {\n-                    hir::DeclLocal(local) => {\n+                    hir::DeclKind::Local(local) => {\n                         if self.remove_mut_rvalue_borrow(&local.pat) {\n                             if let Some(init) = &local.init {\n                                 self.mut_rvalue_borrows.insert(init.id);\n@@ -277,11 +277,11 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n                         NotPromotable\n                     }\n                     // Item statements are allowed\n-                    hir::DeclItem(_) => Promotable\n+                    hir::DeclKind::Item(_) => Promotable\n                 }\n             }\n-            hir::StmtExpr(ref box_expr, _node_id) |\n-            hir::StmtSemi(ref box_expr, _node_id) => {\n+            hir::StmtKind::Expr(ref box_expr, _node_id) |\n+            hir::StmtKind::Semi(ref box_expr, _node_id) => {\n                 let _ = self.check_expr(box_expr);\n                 NotPromotable\n             }\n@@ -334,11 +334,11 @@ fn check_expr_kind<'a, 'tcx>(\n     };\n \n     let node_result = match e.node {\n-        hir::ExprBox(ref expr) => {\n+        hir::ExprKind::Box(ref expr) => {\n             let _ = v.check_expr(&expr);\n             NotPromotable\n         }\n-        hir::ExprUnary(op, ref expr) => {\n+        hir::ExprKind::Unary(op, ref expr) => {\n             let expr_promotability = v.check_expr(expr);\n             if v.tables.is_method_call(e) {\n                 return NotPromotable;\n@@ -348,24 +348,24 @@ fn check_expr_kind<'a, 'tcx>(\n             }\n             expr_promotability\n         }\n-        hir::ExprBinary(op, ref lhs, ref rhs) => {\n+        hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n             let lefty = v.check_expr(lhs);\n             let righty = v.check_expr(rhs);\n             if v.tables.is_method_call(e) {\n                 return NotPromotable;\n             }\n             match v.tables.node_id_to_type(lhs.hir_id).sty {\n                 ty::TyRawPtr(_) => {\n-                    assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n-                        op.node == hir::BiLe || op.node == hir::BiLt ||\n-                        op.node == hir::BiGe || op.node == hir::BiGt);\n+                    assert!(op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne ||\n+                        op.node == hir::BinOpKind::Le || op.node == hir::BinOpKind::Lt ||\n+                        op.node == hir::BinOpKind::Ge || op.node == hir::BinOpKind::Gt);\n \n                     NotPromotable\n                 }\n                 _ => lefty & righty\n             }\n         }\n-        hir::ExprCast(ref from, _) => {\n+        hir::ExprKind::Cast(ref from, _) => {\n             let expr_promotability = v.check_expr(from);\n             debug!(\"Checking const cast(id={})\", from.id);\n             match v.tables.cast_kinds().get(from.hir_id) {\n@@ -379,7 +379,7 @@ fn check_expr_kind<'a, 'tcx>(\n                 _ => expr_promotability\n             }\n         }\n-        hir::ExprPath(ref qpath) => {\n+        hir::ExprKind::Path(ref qpath) => {\n             let def = v.tables.qpath_def(qpath, e.hir_id);\n             match def {\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n@@ -426,23 +426,23 @@ fn check_expr_kind<'a, 'tcx>(\n                 _ => NotPromotable\n             }\n         }\n-        hir::ExprCall(ref callee, ref hirvec) => {\n+        hir::ExprKind::Call(ref callee, ref hirvec) => {\n             let mut call_result = v.check_expr(callee);\n             for index in hirvec.iter() {\n                 call_result = call_result & v.check_expr(index);\n             }\n             let mut callee = &**callee;\n             loop {\n                 callee = match callee.node {\n-                    hir::ExprBlock(ref block, _) => match block.expr {\n+                    hir::ExprKind::Block(ref block, _) => match block.expr {\n                         Some(ref tail) => &tail,\n                         None => break\n                     },\n                     _ => break\n                 };\n             }\n             // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n-            let def = if let hir::ExprPath(ref qpath) = callee.node {\n+            let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n                 v.tables.qpath_def(qpath, callee.hir_id)\n             } else {\n                 Def::Err\n@@ -465,7 +465,7 @@ fn check_expr_kind<'a, 'tcx>(\n             };\n             def_result & call_result\n         }\n-        hir::ExprMethodCall(ref _pathsegment, ref _span, ref hirvec) => {\n+        hir::ExprKind::MethodCall(ref _pathsegment, ref _span, ref hirvec) => {\n             let mut method_call_result = Promotable;\n             for index in hirvec.iter() {\n                 method_call_result = method_call_result & v.check_expr(index);\n@@ -484,7 +484,7 @@ fn check_expr_kind<'a, 'tcx>(\n             }\n             method_call_result\n         }\n-        hir::ExprStruct(ref _qpath, ref hirvec, ref option_expr) => {\n+        hir::ExprKind::Struct(ref _qpath, ref hirvec, ref option_expr) => {\n             let mut struct_result = Promotable;\n             for index in hirvec.iter() {\n                 struct_result = struct_result & v.check_expr(&index.expr);\n@@ -502,14 +502,14 @@ fn check_expr_kind<'a, 'tcx>(\n             struct_result\n         }\n \n-        hir::ExprLit(_) => Promotable,\n+        hir::ExprKind::Lit(_) => Promotable,\n \n-        hir::ExprAddrOf(_, ref expr) |\n-        hir::ExprRepeat(ref expr, _) => {\n+        hir::ExprKind::AddrOf(_, ref expr) |\n+        hir::ExprKind::Repeat(ref expr, _) => {\n             v.check_expr(&expr)\n         }\n \n-        hir::ExprClosure(_capture_clause, ref _box_fn_decl,\n+        hir::ExprKind::Closure(_capture_clause, ref _box_fn_decl,\n                          body_id, _span, _option_generator_movability) => {\n             let nested_body_promotable = v.check_nested_body(body_id);\n             // Paths in constant contexts cannot refer to local variables,\n@@ -521,7 +521,7 @@ fn check_expr_kind<'a, 'tcx>(\n             }\n         }\n \n-        hir::ExprField(ref expr, _ident) => {\n+        hir::ExprKind::Field(ref expr, _ident) => {\n             let expr_promotability = v.check_expr(&expr);\n             if let Some(def) = v.tables.expr_ty(expr).ty_adt_def() {\n                 if def.is_union() {\n@@ -531,11 +531,11 @@ fn check_expr_kind<'a, 'tcx>(\n             expr_promotability\n         }\n \n-        hir::ExprBlock(ref box_block, ref _option_label) => {\n+        hir::ExprKind::Block(ref box_block, ref _option_label) => {\n             v.check_block(box_block)\n         }\n \n-        hir::ExprIndex(ref lhs, ref rhs) => {\n+        hir::ExprKind::Index(ref lhs, ref rhs) => {\n             let lefty = v.check_expr(lhs);\n             let righty = v.check_expr(rhs);\n             if v.tables.is_method_call(e) {\n@@ -544,19 +544,19 @@ fn check_expr_kind<'a, 'tcx>(\n             lefty & righty\n         }\n \n-        hir::ExprArray(ref hirvec) => {\n+        hir::ExprKind::Array(ref hirvec) => {\n             let mut array_result = Promotable;\n             for index in hirvec.iter() {\n                 array_result = array_result & v.check_expr(index);\n             }\n             array_result\n         }\n \n-        hir::ExprType(ref expr, ref _ty) => {\n+        hir::ExprKind::Type(ref expr, ref _ty) => {\n             v.check_expr(&expr)\n         }\n \n-        hir::ExprTup(ref hirvec) => {\n+        hir::ExprKind::Tup(ref hirvec) => {\n             let mut tup_result = Promotable;\n             for index in hirvec.iter() {\n                 tup_result = tup_result & v.check_expr(index);\n@@ -566,7 +566,7 @@ fn check_expr_kind<'a, 'tcx>(\n \n \n         // Conditional control flow (possible to implement).\n-        hir::ExprMatch(ref expr, ref hirvec_arm, ref _match_source) => {\n+        hir::ExprKind::Match(ref expr, ref hirvec_arm, ref _match_source) => {\n             // Compute the most demanding borrow from all the arms'\n             // patterns and set that on the discriminator.\n             let mut mut_borrow = false;\n@@ -590,7 +590,7 @@ fn check_expr_kind<'a, 'tcx>(\n             NotPromotable\n         }\n \n-        hir::ExprIf(ref lhs, ref rhs, ref option_expr) => {\n+        hir::ExprKind::If(ref lhs, ref rhs, ref option_expr) => {\n             let _ = v.check_expr(lhs);\n             let _ = v.check_expr(rhs);\n             match option_expr {\n@@ -601,44 +601,44 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n \n         // Loops (not very meaningful in constants).\n-        hir::ExprWhile(ref expr, ref box_block, ref _option_label) => {\n+        hir::ExprKind::While(ref expr, ref box_block, ref _option_label) => {\n             let _ = v.check_expr(expr);\n             let _ = v.check_block(box_block);\n             NotPromotable\n         }\n \n-        hir::ExprLoop(ref box_block, ref _option_label, ref _loop_source) => {\n+        hir::ExprKind::Loop(ref box_block, ref _option_label, ref _loop_source) => {\n             let _ = v.check_block(box_block);\n             NotPromotable\n         }\n \n         // More control flow (also not very meaningful).\n-        hir::ExprBreak(_, ref option_expr) | hir::ExprRet(ref option_expr) => {\n+        hir::ExprKind::Break(_, ref option_expr) | hir::ExprKind::Ret(ref option_expr) => {\n             match *option_expr {\n                 Some(ref expr) => { let _ = v.check_expr(&expr); },\n                 None => {},\n             }\n             NotPromotable\n         }\n \n-        hir::ExprContinue(_) => {\n+        hir::ExprKind::Continue(_) => {\n             NotPromotable\n         }\n \n         // Generator expressions\n-        hir::ExprYield(ref expr) => {\n+        hir::ExprKind::Yield(ref expr) => {\n             let _ = v.check_expr(&expr);\n             NotPromotable\n         }\n \n         // Expressions with side-effects.\n-        hir::ExprAssignOp(_, ref lhs, ref rhs) | hir::ExprAssign(ref lhs, ref rhs) => {\n+        hir::ExprKind::AssignOp(_, ref lhs, ref rhs) | hir::ExprKind::Assign(ref lhs, ref rhs) => {\n             let _ = v.check_expr(lhs);\n             let _ = v.check_expr(rhs);\n             NotPromotable\n         }\n \n-        hir::ExprInlineAsm(ref _inline_asm, ref hirvec_lhs, ref hirvec_rhs) => {\n+        hir::ExprKind::InlineAsm(ref _inline_asm, ref hirvec_lhs, ref hirvec_rhs) => {\n             for index in hirvec_lhs.iter() {\n                 let _ = v.check_expr(index);\n             }"}, {"sha": "f2728593db4d9aa1aa551063ec657532aeaf85ad", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -24,7 +24,7 @@ struct RegistrarFinder {\n \n impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemFn(..) = item.node {\n+        if let hir::ItemKind::Fn(..) = item.node {\n             if attr::contains_name(&item.attrs,\n                                    \"plugin_registrar\") {\n                 self.registrars.push((item.id, item.span));"}, {"sha": "ab383287773a1e14e835ae559f168d18cd9175f4", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 66, "deletions": 59, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -149,21 +149,21 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n             // Impls inherit level from their types and traits\n-            hir::ItemImpl(..) => {\n+            hir::ItemKind::Impl(..) => {\n                 let def_id = self.tcx.hir.local_def_id(item.id);\n                 cmp::min(self.item_ty_level(def_id), self.impl_trait_level(def_id))\n             }\n             // Foreign mods inherit level from parents\n-            hir::ItemForeignMod(..) => {\n+            hir::ItemKind::ForeignMod(..) => {\n                 self.prev_level\n             }\n             // Other `pub` items inherit levels from parents\n-            hir::ItemConst(..) | hir::ItemEnum(..) | hir::ItemExternCrate(..) |\n-            hir::ItemGlobalAsm(..) | hir::ItemFn(..) | hir::ItemMod(..) |\n-            hir::ItemStatic(..) | hir::ItemStruct(..) |\n-            hir::ItemTrait(..) | hir::ItemTraitAlias(..) |\n-            hir::ItemExistential(..) |\n-            hir::ItemTy(..) | hir::ItemUnion(..) | hir::ItemUse(..) => {\n+            hir::ItemKind::Const(..) | hir::ItemKind::Enum(..) | hir::ItemKind::ExternCrate(..) |\n+            hir::ItemKind::GlobalAsm(..) | hir::ItemKind::Fn(..) | hir::ItemKind::Mod(..) |\n+            hir::ItemKind::Static(..) | hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..) |\n+            hir::ItemKind::Existential(..) |\n+            hir::ItemKind::Ty(..) | hir::ItemKind::Union(..) | hir::ItemKind::Use(..) => {\n                 if item.vis.node.is_pub() { self.prev_level } else { None }\n             }\n         };\n@@ -173,32 +173,32 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n \n         // Update levels of nested things\n         match item.node {\n-            hir::ItemEnum(ref def, _) => {\n+            hir::ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n                     let variant_level = self.update(variant.node.data.id(), item_level);\n                     for field in variant.node.data.fields() {\n                         self.update(field.id, variant_level);\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., None, _, ref impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n                     if impl_item_ref.vis.node.is_pub() {\n                         self.update(impl_item_ref.id.node_id, item_level);\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., Some(_), _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., Some(_), _, ref impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n                     self.update(impl_item_ref.id.node_id, item_level);\n                 }\n             }\n-            hir::ItemTrait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n                     self.update(trait_item_ref.id.node_id, item_level);\n                 }\n             }\n-            hir::ItemStruct(ref def, _) | hir::ItemUnion(ref def, _) => {\n+            hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n                 if !def.is_struct() {\n                     self.update(def.id(), item_level);\n                 }\n@@ -208,43 +208,49 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemForeignMod(ref foreign_mod) => {\n+            hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if foreign_item.vis.node.is_pub() {\n                         self.update(foreign_item.id, item_level);\n                     }\n                 }\n             }\n-            hir::ItemExistential(..) |\n-            hir::ItemUse(..) | hir::ItemStatic(..) | hir::ItemConst(..) |\n-            hir::ItemGlobalAsm(..) | hir::ItemTy(..) | hir::ItemMod(..) | hir::ItemTraitAlias(..) |\n-            hir::ItemFn(..) | hir::ItemExternCrate(..) => {}\n+            hir::ItemKind::Existential(..) |\n+            hir::ItemKind::Use(..) |\n+            hir::ItemKind::Static(..) |\n+            hir::ItemKind::Const(..) |\n+            hir::ItemKind::GlobalAsm(..) |\n+            hir::ItemKind::Ty(..) |\n+            hir::ItemKind::Mod(..) |\n+            hir::ItemKind::TraitAlias(..) |\n+            hir::ItemKind::Fn(..) |\n+            hir::ItemKind::ExternCrate(..) => {}\n         }\n \n         // Mark all items in interfaces of reachable items as reachable\n         match item.node {\n             // The interface is empty\n-            hir::ItemExternCrate(..) => {}\n+            hir::ItemKind::ExternCrate(..) => {}\n             // All nested items are checked by visit_item\n-            hir::ItemMod(..) => {}\n+            hir::ItemKind::Mod(..) => {}\n             // Re-exports are handled in visit_mod\n-            hir::ItemUse(..) => {}\n+            hir::ItemKind::Use(..) => {}\n             // The interface is empty\n-            hir::ItemGlobalAsm(..) => {}\n-            hir::ItemExistential(..) => {\n+            hir::ItemKind::GlobalAsm(..) => {}\n+            hir::ItemKind::Existential(..) => {\n                 if item_level.is_some() {\n                     // Reach the (potentially private) type and the API being exposed\n                     self.reach(item.id).ty().predicates();\n                 }\n             }\n             // Visit everything\n-            hir::ItemConst(..) | hir::ItemStatic(..) |\n-            hir::ItemFn(..) | hir::ItemTy(..) => {\n+            hir::ItemKind::Const(..) | hir::ItemKind::Static(..) |\n+            hir::ItemKind::Fn(..) | hir::ItemKind::Ty(..) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates().ty();\n                 }\n             }\n-            hir::ItemTrait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates();\n \n@@ -261,13 +267,13 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemTraitAlias(..) => {\n+            hir::ItemKind::TraitAlias(..) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items\n-            hir::ItemImpl(.., ref trait_ref, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates().impl_trait_ref();\n \n@@ -281,7 +287,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             }\n \n             // Visit everything, but enum variants have their own levels\n-            hir::ItemEnum(ref def, _) => {\n+            hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates();\n                 }\n@@ -297,16 +303,16 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                 }\n             }\n             // Visit everything, but foreign items have their own levels\n-            hir::ItemForeignMod(ref foreign_mod) => {\n+            hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if self.get(foreign_item.id).is_some() {\n                         self.reach(foreign_item.id).generics().predicates().ty();\n                     }\n                 }\n             }\n             // Visit everything except for private fields\n-            hir::ItemStruct(ref struct_def, _) |\n-            hir::ItemUnion(ref struct_def, _) => {\n+            hir::ItemKind::Struct(ref struct_def, _) |\n+            hir::ItemKind::Union(ref struct_def, _) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates();\n                     for field in struct_def.fields() {\n@@ -373,7 +379,8 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         loop {\n             let module = if module_id == ast::CRATE_NODE_ID {\n                 &self.tcx.hir.krate().module\n-            } else if let hir::ItemMod(ref module) = self.tcx.hir.expect_item(module_id).node {\n+            } else if let hir::ItemKind::Mod(ref module) = self.tcx.hir.expect_item(module_id).node\n+            {\n                 module\n             } else {\n                 unreachable!()\n@@ -568,7 +575,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprStruct(ref qpath, ref fields, ref base) => {\n+            hir::ExprKind::Struct(ref qpath, ref fields, ref base) => {\n                 let def = self.tables.qpath_def(qpath, expr.hir_id);\n                 let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n@@ -778,13 +785,13 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             return;\n         }\n         match expr.node {\n-            hir::ExprAssign(.., ref rhs) | hir::ExprMatch(ref rhs, ..) => {\n+            hir::ExprKind::Assign(.., ref rhs) | hir::ExprKind::Match(ref rhs, ..) => {\n                 // Do not report duplicate errors for `x = y` and `match x { ... }`.\n                 if self.check_expr_pat_type(rhs.hir_id, rhs.span) {\n                     return;\n                 }\n             }\n-            hir::ExprMethodCall(_, span, _) => {\n+            hir::ExprKind::MethodCall(_, span, _) => {\n                 // Method calls have to be checked specially.\n                 self.span = span;\n                 if let Some(def) = self.tables.type_dependent_defs().get(expr.hir_id) {\n@@ -1052,15 +1059,15 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n     }\n \n     fn visit_ty(&mut self, ty: &hir::Ty) {\n-        if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = ty.node {\n+        if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = ty.node {\n             if self.inner.path_is_private_type(path) {\n                 self.contains_private = true;\n                 // found what we're looking for so let's stop\n                 // working.\n                 return\n             }\n         }\n-        if let hir::TyPath(_) = ty.node {\n+        if let hir::TyKind::Path(_) = ty.node {\n             if self.at_outer_type {\n                 self.outer_type_is_public_path = true;\n             }\n@@ -1084,13 +1091,13 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         match item.node {\n             // contents of a private mod can be re-exported, so we need\n             // to check internals.\n-            hir::ItemMod(_) => {}\n+            hir::ItemKind::Mod(_) => {}\n \n             // An `extern {}` doesn't introduce a new privacy\n             // namespace (the contents have their own privacies).\n-            hir::ItemForeignMod(_) => {}\n+            hir::ItemKind::ForeignMod(_) => {}\n \n-            hir::ItemTrait(.., ref bounds, _) => {\n+            hir::ItemKind::Trait(.., ref bounds, _) => {\n                 if !self.trait_is_public(item.id) {\n                     return\n                 }\n@@ -1105,7 +1112,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // (i.e. we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n             // publicly visible).\n-            hir::ItemImpl(.., ref g, ref trait_ref, ref self_, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref g, ref trait_ref, ref self_, ref impl_item_refs) => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // impl [... for] Public<...>, but not `impl [... for]\n@@ -1245,7 +1252,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n             // `type ... = ...;` can contain private types, because\n             // we're introducing a new name.\n-            hir::ItemTy(..) => return,\n+            hir::ItemKind::Ty(..) => return,\n \n             // not at all public, so we don't care\n             _ if !self.item_is_public(&item.id, &item.vis) => {\n@@ -1293,7 +1300,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n-        if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = t.node {\n+        if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = t.node {\n             if self.path_is_private_type(path) {\n                 self.old_error_set.insert(t.id);\n             }\n@@ -1552,14 +1559,14 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n         match item.node {\n             // Crates are always public\n-            hir::ItemExternCrate(..) => {}\n+            hir::ItemKind::ExternCrate(..) => {}\n             // All nested items are checked by visit_item\n-            hir::ItemMod(..) => {}\n+            hir::ItemKind::Mod(..) => {}\n             // Checked in resolve\n-            hir::ItemUse(..) => {}\n+            hir::ItemKind::Use(..) => {}\n             // No subitems\n-            hir::ItemGlobalAsm(..) => {}\n-            hir::ItemExistential(..) => {\n+            hir::ItemKind::GlobalAsm(..) => {}\n+            hir::ItemKind::Existential(..) => {\n                 // Check the traits being exposed, as they're separate,\n                 // e.g. `impl Iterator<Item=T>` has two predicates,\n                 // `X: Iterator` and `<X as Iterator>::Item == T`,\n@@ -1569,15 +1576,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.check(item.id, item_visibility).predicates();\n             }\n             // Subitems of these items have inherited publicity\n-            hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n-            hir::ItemTy(..) => {\n+            hir::ItemKind::Const(..) | hir::ItemKind::Static(..) | hir::ItemKind::Fn(..) |\n+            hir::ItemKind::Ty(..) => {\n                 self.check(item.id, item_visibility).generics().predicates().ty();\n \n                 // Recurse for e.g. `impl Trait` (see `visit_ty`).\n                 self.inner_visibility = item_visibility;\n                 intravisit::walk_item(self, item);\n             }\n-            hir::ItemTrait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 self.check(item.id, item_visibility).generics().predicates();\n \n                 for trait_item_ref in trait_item_refs {\n@@ -1593,10 +1600,10 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                     }\n                 }\n             }\n-            hir::ItemTraitAlias(..) => {\n+            hir::ItemKind::TraitAlias(..) => {\n                 self.check(item.id, item_visibility).generics().predicates();\n             }\n-            hir::ItemEnum(ref def, _) => {\n+            hir::ItemKind::Enum(ref def, _) => {\n                 self.check(item.id, item_visibility).generics().predicates();\n \n                 for variant in &def.variants {\n@@ -1606,15 +1613,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 }\n             }\n             // Subitems of foreign modules have their own publicity\n-            hir::ItemForeignMod(ref foreign_mod) => {\n+            hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     let vis = ty::Visibility::from_hir(&foreign_item.vis, item.id, tcx);\n                     self.check(foreign_item.id, vis).generics().predicates().ty();\n                 }\n             }\n             // Subitems of structs and unions have their own publicity\n-            hir::ItemStruct(ref struct_def, _) |\n-            hir::ItemUnion(ref struct_def, _) => {\n+            hir::ItemKind::Struct(ref struct_def, _) |\n+            hir::ItemKind::Union(ref struct_def, _) => {\n                 self.check(item.id, item_visibility).generics().predicates();\n \n                 for field in struct_def.fields() {\n@@ -1624,7 +1631,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             }\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity\n-            hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., None, _, ref impl_item_refs) => {\n                 let ty_vis =\n                     self.check(item.id, ty::Visibility::Invisible).ty().min_visibility;\n                 self.check(item.id, ty_vis).generics().predicates();\n@@ -1643,7 +1650,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             }\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity\n-            hir::ItemImpl(.., Some(_), _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., Some(_), _, ref impl_item_refs) => {\n                 let vis = self.check(item.id, ty::Visibility::Invisible)\n                               .ty().impl_trait_ref().min_visibility;\n                 self.check(item.id, vis).generics().predicates();"}, {"sha": "f388b911feb6a5c6b02d435f31fd07b25ec9172d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -1412,9 +1412,6 @@ pub struct Resolver<'a> {\n     /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Name, Span>,\n \n-    /// If `#![feature(proc_macro)]` is set\n-    proc_macro_enabled: bool,\n-\n     /// A set of procedural macros imported by `#[macro_use]` that have already been warned about\n     warned_proc_macros: FxHashSet<Name>,\n \n@@ -1713,7 +1710,7 @@ impl<'a> Resolver<'a> {\n \n             // The `proc_macro` and `decl_macro` features imply `use_extern_macros`\n             use_extern_macros:\n-                features.use_extern_macros || features.proc_macro || features.decl_macro,\n+                features.use_extern_macros || features.decl_macro,\n \n             crate_loader,\n             macro_names: FxHashSet(),\n@@ -1727,7 +1724,6 @@ impl<'a> Resolver<'a> {\n             local_macro_def_scopes: FxHashMap(),\n             name_already_seen: FxHashMap(),\n             whitelisted_legacy_custom_derives: Vec::new(),\n-            proc_macro_enabled: features.proc_macro,\n             warned_proc_macros: FxHashSet(),\n             potentially_unused_imports: Vec::new(),\n             struct_constructors: DefIdMap(),\n@@ -4509,7 +4505,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn check_proc_macro_attrs(&mut self, attrs: &[ast::Attribute]) {\n-        if self.proc_macro_enabled { return; }\n+        if self.use_extern_macros { return; }\n \n         for attr in attrs {\n             if attr.path.segments.len() > 1 {"}, {"sha": "f076d884f60991a6eb8c8535268c012eb9d71dd5", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -429,7 +429,7 @@ impl<'a> Resolver<'a> {\n                         *item = mem::replace(item, dummy_item).map_attrs(|mut attrs| {\n                             let inert_attr = attr.take().unwrap();\n                             attr::mark_known(&inert_attr);\n-                            if self.proc_macro_enabled {\n+                            if self.use_extern_macros {\n                                 *attr = expand::find_attr_invoc(&mut attrs);\n                             }\n                             attrs.push(inert_attr);"}, {"sha": "f2620c04754b8ab2fd05fd30a64c3cfc11f4dbc0", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -420,7 +420,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             match self.tcx.impl_of_method(self.tcx.hir.local_def_id(id)) {\n                 Some(impl_id) => match self.tcx.hir.get_if_local(impl_id) {\n                     Some(Node::NodeItem(item)) => match item.node {\n-                        hir::ItemImpl(.., ref ty, _) => {\n+                        hir::ItemKind::Impl(.., ref ty, _) => {\n                             let mut qualname = String::from(\"<\");\n                             qualname.push_str(&self.tcx.hir.node_to_pretty_string(ty.id));\n \n@@ -630,18 +630,18 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Node::NodeTraitRef(tr) => tr.path.def,\n \n             Node::NodeItem(&hir::Item {\n-                node: hir::ItemUse(ref path, _),\n+                node: hir::ItemKind::Use(ref path, _),\n                 ..\n             }) |\n             Node::NodeVisibility(&Spanned {\n                 node: hir::VisibilityKind::Restricted { ref path, .. }, .. }) => path.def,\n \n             Node::NodeExpr(&hir::Expr {\n-                node: hir::ExprStruct(ref qpath, ..),\n+                node: hir::ExprKind::Struct(ref qpath, ..),\n                 ..\n             }) |\n             Node::NodeExpr(&hir::Expr {\n-                node: hir::ExprPath(ref qpath),\n+                node: hir::ExprKind::Path(ref qpath),\n                 ..\n             }) |\n             Node::NodePat(&hir::Pat {\n@@ -666,7 +666,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }) => HirDef::Local(canonical_id),\n \n             Node::NodeTy(ty) => if let hir::Ty {\n-                node: hir::TyPath(ref qpath),\n+                node: hir::TyKind::Path(ref qpath),\n                 ..\n             } = *ty\n             {"}, {"sha": "f85e7b0685889f35a8bf19dbf6ff569ad6577211", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -1117,75 +1117,75 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n \n         let result_ty = match ast_ty.node {\n-            hir::TySlice(ref ty) => {\n+            hir::TyKind::Slice(ref ty) => {\n                 tcx.mk_slice(self.ast_ty_to_ty(&ty))\n             }\n-            hir::TyPtr(ref mt) => {\n+            hir::TyKind::Ptr(ref mt) => {\n                 tcx.mk_ptr(ty::TypeAndMut {\n                     ty: self.ast_ty_to_ty(&mt.ty),\n                     mutbl: mt.mutbl\n                 })\n             }\n-            hir::TyRptr(ref region, ref mt) => {\n+            hir::TyKind::Rptr(ref region, ref mt) => {\n                 let r = self.ast_region_to_region(region, None);\n                 debug!(\"TyRef r={:?}\", r);\n                 let t = self.ast_ty_to_ty(&mt.ty);\n                 tcx.mk_ref(r, ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n             }\n-            hir::TyNever => {\n+            hir::TyKind::Never => {\n                 tcx.types.never\n             },\n-            hir::TyTup(ref fields) => {\n+            hir::TyKind::Tup(ref fields) => {\n                 tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(&t)))\n             }\n-            hir::TyBareFn(ref bf) => {\n+            hir::TyKind::BareFn(ref bf) => {\n                 require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n                 tcx.mk_fn_ptr(self.ty_of_fn(bf.unsafety, bf.abi, &bf.decl))\n             }\n-            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+            hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n             }\n-            hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n+            hir::TyKind::Path(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n                     self.ast_ty_to_ty(qself)\n                 });\n                 self.def_to_ty(opt_self_ty, path, false)\n             }\n-            hir::TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n+            hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n                 let ty = self.ast_ty_to_ty(qself);\n \n-                let def = if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = qself.node {\n+                let def = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.node {\n                     path.def\n                 } else {\n                     Def::Err\n                 };\n                 self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, def, segment).0\n             }\n-            hir::TyArray(ref ty, ref length) => {\n+            hir::TyKind::Array(ref ty, ref length) => {\n                 let length_def_id = tcx.hir.local_def_id(length.id);\n                 let substs = Substs::identity_for_item(tcx, length_def_id);\n                 let length = ty::Const::unevaluated(tcx, length_def_id, substs, tcx.types.usize);\n                 let array_ty = tcx.mk_ty(ty::TyArray(self.ast_ty_to_ty(&ty), length));\n                 self.normalize_ty(ast_ty.span, array_ty)\n             }\n-            hir::TyTypeof(ref _e) => {\n+            hir::TyKind::Typeof(ref _e) => {\n                 struct_span_err!(tcx.sess, ast_ty.span, E0516,\n                                  \"`typeof` is a reserved keyword but unimplemented\")\n                     .span_label(ast_ty.span, \"reserved keyword\")\n                     .emit();\n \n                 tcx.types.err\n             }\n-            hir::TyInfer => {\n+            hir::TyKind::Infer => {\n                 // TyInfer also appears as the type of arguments or return\n-                // values in a ExprClosure, or as\n+                // values in a ExprKind::Closure, or as\n                 // the type of local variables. Both of these cases are\n                 // handled specially and will not descend into this routine.\n                 self.ty_infer(ast_ty.span)\n             }\n-            hir::TyErr => {\n+            hir::TyKind::Err => {\n                 tcx.types.err\n             }\n         };\n@@ -1241,7 +1241,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                      -> Ty<'tcx>\n     {\n         match ty.node {\n-            hir::TyInfer if expected_ty.is_some() => {\n+            hir::TyKind::Infer if expected_ty.is_some() => {\n                 self.record_ty(ty.hir_id, expected_ty.unwrap(), ty.span);\n                 expected_ty.unwrap()\n             }"}, {"sha": "c9b5fd525dd82277a8eb286763fc8c74cd4256a1", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Byte string patterns behave the same way as array patterns\n                 // They can denote both statically and dynamically sized byte arrays\n                 let mut pat_ty = ty;\n-                if let hir::ExprLit(ref lt) = lt.node {\n+                if let hir::ExprKind::Lit(ref lt) = lt.node {\n                     if let ast::LitKind::ByteStr(_) = lt.node {\n                         let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                         if let ty::TyRef(_, r_ty, _) = expected_ty.sty {"}, {"sha": "ec127d26ab30763331f081eb1a87bc9ce9c76afa", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -214,7 +214,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let mut unit_variant = None;\n                 if let &ty::TyAdt(adt_def, ..) = t {\n                     if adt_def.is_enum() {\n-                        if let hir::ExprCall(ref expr, _) = call_expr.node {\n+                        if let hir::ExprKind::Call(ref expr, _) = call_expr.node {\n                             unit_variant = Some(self.tcx.hir.node_to_pretty_string(expr.id))\n                         }\n                     }\n@@ -240,8 +240,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         path.to_string());\n                 }\n \n-                if let hir::ExprCall(ref expr, _) = call_expr.node {\n-                    let def = if let hir::ExprPath(ref qpath) = expr.node {\n+                if let hir::ExprKind::Call(ref expr, _) = call_expr.node {\n+                    let def = if let hir::ExprKind::Path(ref qpath) = expr.node {\n                         self.tables.borrow().qpath_def(qpath, expr.hir_id)\n                     } else {\n                         Def::Err"}, {"sha": "220dd122b26795b6c7516fb11c3e8a71f800b070", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -429,8 +429,8 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n \n                 impl_m_iter.zip(trait_m_iter).find(|&(ref impl_arg, ref trait_arg)| {\n                     match (&impl_arg.node, &trait_arg.node) {\n-                        (&hir::TyRptr(_, ref impl_mt), &hir::TyRptr(_, ref trait_mt)) |\n-                        (&hir::TyPtr(ref impl_mt), &hir::TyPtr(ref trait_mt)) => {\n+                        (&hir::TyKind::Rptr(_, ref impl_mt), &hir::TyKind::Rptr(_, ref trait_mt)) |\n+                        (&hir::TyKind::Ptr(ref impl_mt), &hir::TyKind::Ptr(ref trait_mt)) => {\n                             impl_mt.mutbl != trait_mt.mutbl\n                         }\n                         _ => false,\n@@ -822,7 +822,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             fn visit_ty(&mut self, ty: &'v hir::Ty) {\n                                 hir::intravisit::walk_ty(self, ty);\n                                 match ty.node {\n-                                    hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n+                                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                                         if let hir::def::Def::TyParam(def_id) = path.def {\n                                             if def_id == self.1 {\n                                                 self.0 = Some(ty.span);"}, {"sha": "92b35bd50f3c37b2fb57865a641e536ec8f6fc56", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -18,7 +18,7 @@ use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::def::Def;\n use rustc::hir::map::{NodeItem, NodeExpr};\n-use rustc::hir::{Item, ItemConst, print};\n+use rustc::hir::{Item, ItemKind, print};\n use rustc::ty::{self, Ty, AssociatedItem};\n use rustc::ty::adjustment::AllowTwoPhase;\n use errors::{DiagnosticBuilder, CodeMapper};\n@@ -196,17 +196,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// opt.map(|arg| { takes_ref(arg) });\n     /// ```\n     fn can_use_as_ref(&self, expr: &hir::Expr) -> Option<(Span, &'static str, String)> {\n-        if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = expr.node {\n+        if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.node {\n             if let hir::def::Def::Local(id) = path.def {\n                 let parent = self.tcx.hir.get_parent_node(id);\n                 if let Some(NodeExpr(hir::Expr {\n                     id,\n-                    node: hir::ExprClosure(_, decl, ..),\n+                    node: hir::ExprKind::Closure(_, decl, ..),\n                     ..\n                 })) = self.tcx.hir.find(parent) {\n                     let parent = self.tcx.hir.get_parent_node(*id);\n                     if let (Some(NodeExpr(hir::Expr {\n-                        node: hir::ExprMethodCall(path, span, expr),\n+                        node: hir::ExprKind::MethodCall(path, span, expr),\n                         ..\n                     })), 1) = (self.tcx.hir.find(parent), decl.inputs.len()) {\n                         let self_ty = self.tables.borrow().node_id_to_type(expr[0].hir_id);\n@@ -262,7 +262,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (&ty::TyRef(_, exp, _), &ty::TyRef(_, check, _)) => match (&exp.sty, &check.sty) {\n                 (&ty::TyStr, &ty::TyArray(arr, _)) |\n                 (&ty::TyStr, &ty::TySlice(arr)) if arr == self.tcx.types.u8 => {\n-                    if let hir::ExprLit(_) = expr.node {\n+                    if let hir::ExprKind::Lit(_) = expr.node {\n                         if let Ok(src) = cm.span_to_snippet(sp) {\n                             if src.starts_with(\"b\\\"\") {\n                                 return Some((sp,\n@@ -274,7 +274,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 },\n                 (&ty::TyArray(arr, _), &ty::TyStr) |\n                 (&ty::TySlice(arr), &ty::TyStr) if arr == self.tcx.types.u8 => {\n-                    if let hir::ExprLit(_) = expr.node {\n+                    if let hir::ExprKind::Lit(_) = expr.node {\n                         if let Ok(src) = cm.span_to_snippet(sp) {\n                             if src.starts_with(\"\\\"\") {\n                                 return Some((sp,\n@@ -306,7 +306,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if self.can_coerce(ref_ty, expected) {\n                     if let Ok(src) = cm.span_to_snippet(sp) {\n                         let sugg_expr = match expr.node { // parenthesize if needed (Issue #46756)\n-                            hir::ExprCast(_, _) | hir::ExprBinary(_, _, _) => format!(\"({})\", src),\n+                            hir::ExprKind::Cast(_, _) |\n+                            hir::ExprKind::Binary(_, _, _) => format!(\"({})\", src),\n                             _ => src,\n                         };\n                         if let Some(sugg) = self.can_use_as_ref(expr) {\n@@ -336,7 +337,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                    sp.ctxt().outer().expn_info().is_none() {\n                     match expr.node {\n                         // Maybe remove `&`?\n-                        hir::ExprAddrOf(_, ref expr) => {\n+                        hir::ExprKind::AddrOf(_, ref expr) => {\n                             if !cm.span_to_filename(expr.span).is_real() {\n                                 return None;\n                             }\n@@ -376,7 +377,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match self.tcx.hir.find(parent_id) {\n             Some(parent) => {\n                 // Shouldn't suggest `.into()` on `const`s.\n-                if let NodeItem(Item { node: ItemConst(_, _), .. }) = parent {\n+                if let NodeItem(Item { node: ItemKind::Const(_, _), .. }) = parent {\n                     // FIXME(estebank): modify once we decide to suggest `as` casts\n                     return false;\n                 }"}, {"sha": "e26bf1b4f77cd0e05750275700c15f3647634a42", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -35,7 +35,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let def_id = tcx.hir.local_def_id(it.id);\n \n     match it.node {\n-        hir::ForeignItemFn(..) => {}\n+        hir::ForeignItemKind::Fn(..) => {}\n         _ => {\n             struct_span_err!(tcx.sess, it.span, E0622,\n                              \"intrinsic must be a function\")\n@@ -48,7 +48,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let i_n_tps = tcx.generics_of(def_id).own_counts().types;\n     if i_n_tps != n_tps {\n         let span = match it.node {\n-            hir::ForeignItemFn(_, _, ref generics) => generics.span,\n+            hir::ForeignItemKind::Fn(_, _, ref generics) => generics.span,\n             _ => bug!()\n         };\n "}, {"sha": "6c3e265619fea708e4766ee1f494971ab42d35d0", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -449,9 +449,9 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         loop {\n             let last = exprs[exprs.len() - 1];\n             match last.node {\n-                hir::ExprField(ref expr, _) |\n-                hir::ExprIndex(ref expr, _) |\n-                hir::ExprUnary(hir::UnDeref, ref expr) => exprs.push(&expr),\n+                hir::ExprKind::Field(ref expr, _) |\n+                hir::ExprKind::Index(ref expr, _) |\n+                hir::ExprKind::Unary(hir::UnDeref, ref expr) => exprs.push(&expr),\n                 _ => break,\n             }\n         }\n@@ -493,12 +493,12 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             }\n \n             match expr.node {\n-                hir::ExprIndex(ref base_expr, ref index_expr) => {\n+                hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n                     let index_expr_ty = self.node_ty(index_expr.hir_id);\n                     self.convert_place_op_to_mutable(\n                         PlaceOp::Index, expr, base_expr, &[index_expr_ty]);\n                 }\n-                hir::ExprUnary(hir::UnDeref, ref base_expr) => {\n+                hir::ExprKind::Unary(hir::UnDeref, ref base_expr) => {\n                     self.convert_place_op_to_mutable(\n                         PlaceOp::Deref, expr, base_expr, &[]);\n                 }"}, {"sha": "026a9de5052cb8e14b6bd89d43a6ea4804d72aca", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -245,7 +245,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             \"f32\"\n                         };\n                         match expr.node {\n-                            hir::ExprLit(ref lit) => {  // numeric literal\n+                            hir::ExprKind::Lit(ref lit) => {  // numeric literal\n                                 let snippet = tcx.sess.codemap().span_to_snippet(lit.span)\n                                     .unwrap_or(\"<numeric literal>\".to_string());\n \n@@ -257,7 +257,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                             snippet,\n                                                             concrete_type));\n                             }\n-                            hir::ExprPath(ref qpath) => {  // local binding\n+                            hir::ExprKind::Path(ref qpath) => {  // local binding\n                                 if let &hir::QPath::Resolved(_, ref path) = &qpath {\n                                     if let hir::def::Def::Local(node_id) = path.def {\n                                         let span = tcx.hir.span(node_id);\n@@ -389,7 +389,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(expr) = rcvr_expr {\n                         if let Ok(expr_string) = tcx.sess.codemap().span_to_snippet(expr.span) {\n                             report_function!(expr.span, expr_string);\n-                        } else if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = expr.node {\n+                        } else if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) =\n+                            expr.node\n+                        {\n                             if let Some(segment) = path.segments.last() {\n                                 report_function!(expr.span, segment.ident);\n                             }\n@@ -709,7 +711,7 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n         impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n             fn visit_item(&mut self, i: &'v hir::Item) {\n                 match i.node {\n-                    hir::ItemTrait(..) => {\n+                    hir::ItemKind::Trait(..) => {\n                         let def_id = self.map.local_def_id(i.id);\n                         self.traits.push(def_id);\n                     }\n@@ -810,7 +812,7 @@ impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, '\n         for item_id in &module.item_ids {\n             let item = self.tcx.hir.expect_item(item_id.id);\n             match item.node {\n-                hir::ItemUse(..) => {\n+                hir::ItemKind::Use(..) => {\n                     // don't suggest placing a use before the prelude\n                     // import or other generated ones\n                     if item.span.ctxt().outer().expn_info().is_none() {\n@@ -820,7 +822,7 @@ impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, '\n                     }\n                 },\n                 // don't place use before extern crate\n-                hir::ItemExternCrate(_) => {}\n+                hir::ItemKind::ExternCrate(_) => {}\n                 // but place them before the first other item\n                 _ => if self.span.map_or(true, |span| item.span < span ) {\n                     if item.span.ctxt().outer().expn_info().is_none() {"}, {"sha": "9f83f8a00b1f5143386fcc01b36a223f7edf4f43", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 106, "deletions": 106, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -132,7 +132,7 @@ use syntax_pos::{self, BytePos, Span, MultiSpan};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::map::Node;\n-use rustc::hir::{self, PatKind, Item_};\n+use rustc::hir::{self, PatKind, ItemKind};\n use rustc::middle::lang_items;\n \n mod autoderef;\n@@ -759,10 +759,10 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match tcx.hir.get(id) {\n         hir::map::NodeItem(item) => {\n             match item.node {\n-                hir::ItemConst(_, body) |\n-                hir::ItemStatic(_, _, body) =>\n+                hir::ItemKind::Const(_, body) |\n+                hir::ItemKind::Static(_, _, body) =>\n                     Some((body, None)),\n-                hir::ItemFn(ref decl, .., body) =>\n+                hir::ItemKind::Fn(ref decl, .., body) =>\n                     Some((body, Some(decl))),\n                 _ =>\n                     None,\n@@ -1165,7 +1165,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                     }\n \n                     if let Node::NodeItem(item) = fcx.tcx.hir.get(fn_id) {\n-                        if let Item_::ItemFn(_, _, ref generics, _) = item.node {\n+                        if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n                                     span,\n@@ -1213,7 +1213,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                     }\n \n                     if let Node::NodeItem(item) = fcx.tcx.hir.get(fn_id) {\n-                        if let Item_::ItemFn(_, _, ref generics, _) = item.node {\n+                        if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n                                     span,\n@@ -1269,25 +1269,25 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n     let _indenter = indenter();\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n-      hir::ItemStatic(..) => {\n+      hir::ItemKind::Static(..) => {\n         tcx.typeck_tables_of(tcx.hir.local_def_id(it.id));\n       }\n-      hir::ItemConst(..) => {\n+      hir::ItemKind::Const(..) => {\n         tcx.typeck_tables_of(tcx.hir.local_def_id(it.id));\n         if it.attrs.iter().any(|a| a.check_name(\"wasm_custom_section\")) {\n             let def_id = tcx.hir.local_def_id(it.id);\n             check_const_is_u8_array(tcx, def_id, it.span);\n         }\n       }\n-      hir::ItemEnum(ref enum_definition, _) => {\n+      hir::ItemKind::Enum(ref enum_definition, _) => {\n         check_enum(tcx,\n                    it.span,\n                    &enum_definition.variants,\n                    it.id);\n       }\n-      hir::ItemFn(..) => {} // entirely within check_item_body\n-      hir::ItemImpl(.., ref impl_item_refs) => {\n-          debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n+      hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n+      hir::ItemKind::Impl(.., ref impl_item_refs) => {\n+          debug!(\"ItemKind::Impl {} with id {}\", it.name, it.id);\n           let impl_def_id = tcx.hir.local_def_id(it.id);\n           if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n               check_impl_items_against_trait(tcx,\n@@ -1299,23 +1299,23 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n               check_on_unimplemented(tcx, trait_def_id, it);\n           }\n       }\n-      hir::ItemTrait(..) => {\n+      hir::ItemKind::Trait(..) => {\n         let def_id = tcx.hir.local_def_id(it.id);\n         check_on_unimplemented(tcx, def_id, it);\n       }\n-      hir::ItemStruct(..) => {\n+      hir::ItemKind::Struct(..) => {\n         check_struct(tcx, it.id, it.span);\n       }\n-      hir::ItemUnion(..) => {\n+      hir::ItemKind::Union(..) => {\n         check_union(tcx, it.id, it.span);\n       }\n-      hir::ItemTy(..) => {\n+      hir::ItemKind::Ty(..) => {\n         let def_id = tcx.hir.local_def_id(it.id);\n         let pty_ty = tcx.type_of(def_id);\n         let generics = tcx.generics_of(def_id);\n         check_bounds_are_used(tcx, &generics, pty_ty);\n       }\n-      hir::ItemForeignMod(ref m) => {\n+      hir::ItemKind::ForeignMod(ref m) => {\n         check_abi(tcx, it.span, m.abi);\n \n         if m.abi == Abi::RustIntrinsic {\n@@ -1340,7 +1340,7 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n                     err.emit();\n                 }\n \n-                if let hir::ForeignItemFn(ref fn_decl, _, _) = item.node {\n+                if let hir::ForeignItemKind::Fn(ref fn_decl, _, _) = item.node {\n                     require_c_abi_if_variadic(tcx, fn_decl, m.abi, item.span);\n                 }\n             }\n@@ -2347,52 +2347,52 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn is_place_expr(&self, expr: &hir::Expr) -> bool {\n          match expr.node {\n-            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+            hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 match path.def {\n                     Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n                     _ => false,\n                 }\n             }\n \n-            hir::ExprType(ref e, _) => {\n+            hir::ExprKind::Type(ref e, _) => {\n                 self.is_place_expr(e)\n             }\n \n-            hir::ExprUnary(hir::UnDeref, _) |\n-            hir::ExprField(..) |\n-            hir::ExprIndex(..) => {\n+            hir::ExprKind::Unary(hir::UnDeref, _) |\n+            hir::ExprKind::Field(..) |\n+            hir::ExprKind::Index(..) => {\n                 true\n             }\n \n             // Partially qualified paths in expressions can only legally\n             // refer to associated items which are always rvalues.\n-            hir::ExprPath(hir::QPath::TypeRelative(..)) |\n-\n-            hir::ExprCall(..) |\n-            hir::ExprMethodCall(..) |\n-            hir::ExprStruct(..) |\n-            hir::ExprTup(..) |\n-            hir::ExprIf(..) |\n-            hir::ExprMatch(..) |\n-            hir::ExprClosure(..) |\n-            hir::ExprBlock(..) |\n-            hir::ExprRepeat(..) |\n-            hir::ExprArray(..) |\n-            hir::ExprBreak(..) |\n-            hir::ExprContinue(..) |\n-            hir::ExprRet(..) |\n-            hir::ExprWhile(..) |\n-            hir::ExprLoop(..) |\n-            hir::ExprAssign(..) |\n-            hir::ExprInlineAsm(..) |\n-            hir::ExprAssignOp(..) |\n-            hir::ExprLit(_) |\n-            hir::ExprUnary(..) |\n-            hir::ExprBox(..) |\n-            hir::ExprAddrOf(..) |\n-            hir::ExprBinary(..) |\n-            hir::ExprYield(..) |\n-            hir::ExprCast(..) => {\n+            hir::ExprKind::Path(hir::QPath::TypeRelative(..)) |\n+\n+            hir::ExprKind::Call(..) |\n+            hir::ExprKind::MethodCall(..) |\n+            hir::ExprKind::Struct(..) |\n+            hir::ExprKind::Tup(..) |\n+            hir::ExprKind::If(..) |\n+            hir::ExprKind::Match(..) |\n+            hir::ExprKind::Closure(..) |\n+            hir::ExprKind::Block(..) |\n+            hir::ExprKind::Repeat(..) |\n+            hir::ExprKind::Array(..) |\n+            hir::ExprKind::Break(..) |\n+            hir::ExprKind::Continue(..) |\n+            hir::ExprKind::Ret(..) |\n+            hir::ExprKind::While(..) |\n+            hir::ExprKind::Loop(..) |\n+            hir::ExprKind::Assign(..) |\n+            hir::ExprKind::InlineAsm(..) |\n+            hir::ExprKind::AssignOp(..) |\n+            hir::ExprKind::Lit(_) |\n+            hir::ExprKind::Unary(..) |\n+            hir::ExprKind::Box(..) |\n+            hir::ExprKind::AddrOf(..) |\n+            hir::ExprKind::Binary(..) |\n+            hir::ExprKind::Yield(..) |\n+            hir::ExprKind::Cast(..) => {\n                 false\n             }\n         }\n@@ -2763,7 +2763,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 let is_closure = match arg.node {\n-                    hir::ExprClosure(..) => true,\n+                    hir::ExprKind::Closure(..) => true,\n                     _ => false\n                 };\n \n@@ -2915,7 +2915,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n             // Add help to type error if this is an `if` condition with an assignment\n             match (expected, &expr.node) {\n-                (ExpectIfCondition, &hir::ExprAssign(ref lhs, ref rhs)) => {\n+                (ExpectIfCondition, &hir::ExprKind::Assign(ref lhs, ref rhs)) => {\n                     let msg = \"try comparing for equality\";\n                     if let (Ok(left), Ok(right)) = (\n                         self.tcx.sess.codemap().span_to_snippet(lhs.span),\n@@ -3625,9 +3625,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Warn for non-block expressions with diverging children.\n         match expr.node {\n-            hir::ExprBlock(..) |\n-            hir::ExprLoop(..) | hir::ExprWhile(..) |\n-            hir::ExprIf(..) | hir::ExprMatch(..) => {}\n+            hir::ExprKind::Block(..) |\n+            hir::ExprKind::Loop(..) | hir::ExprKind::While(..) |\n+            hir::ExprKind::If(..) | hir::ExprKind::Match(..) => {}\n \n             _ => self.warn_if_unreachable(expr.id, expr.span, \"expression\")\n         }\n@@ -3659,7 +3659,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n         let id = expr.id;\n         match expr.node {\n-            hir::ExprBox(ref subexpr) => {\n+            hir::ExprKind::Box(ref subexpr) => {\n                 let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n                     match ty.sty {\n                         ty::TyAdt(def, _) if def.is_box()\n@@ -3671,16 +3671,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tcx.mk_box(referent_ty)\n             }\n \n-            hir::ExprLit(ref lit) => {\n+            hir::ExprKind::Lit(ref lit) => {\n                 self.check_lit(&lit, expected)\n             }\n-            hir::ExprBinary(op, ref lhs, ref rhs) => {\n+            hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n                 self.check_binop(expr, op, lhs, rhs)\n             }\n-            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+            hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 self.check_binop_assign(expr, op, lhs, rhs)\n             }\n-            hir::ExprUnary(unop, ref oprnd) => {\n+            hir::ExprKind::Unary(unop, ref oprnd) => {\n                 let expected_inner = match unop {\n                     hir::UnNot | hir::UnNeg => {\n                         expected\n@@ -3748,7 +3748,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 oprnd_t\n             }\n-            hir::ExprAddrOf(mutbl, ref oprnd) => {\n+            hir::ExprKind::AddrOf(mutbl, ref oprnd) => {\n                 let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n                     match ty.sty {\n                         ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n@@ -3788,7 +3788,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tcx.mk_ref(region, tm)\n                 }\n             }\n-            hir::ExprPath(ref qpath) => {\n+            hir::ExprKind::Path(ref qpath) => {\n                 let (def, opt_ty, segs) = self.resolve_ty_and_def_ufcs(qpath, expr.id, expr.span);\n                 let ty = if def != Def::Err {\n                     self.instantiate_value_path(segs, opt_ty, def, expr.span, id)\n@@ -3804,7 +3804,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 ty\n             }\n-            hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n+            hir::ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n                 for output in outputs {\n                     self.check_expr(output);\n                 }\n@@ -3813,7 +3813,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 tcx.mk_nil()\n             }\n-            hir::ExprBreak(destination, ref expr_opt) => {\n+            hir::ExprKind::Break(destination, ref expr_opt) => {\n                 if let Ok(target_id) = destination.target_id {\n                     let (e_ty, cause);\n                     if let Some(ref e) = *expr_opt {\n@@ -3886,7 +3886,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                         // ... except when we try to 'break rust;'.\n                         // ICE this expression in particular (see #43162).\n-                        if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = e.node {\n+                        if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = e.node {\n                             if path.segments.len() == 1 && path.segments[0].ident.name == \"rust\" {\n                                 fatally_break_rust(self.tcx.sess);\n                             }\n@@ -3897,15 +3897,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n             }\n-            hir::ExprContinue(destination) => {\n+            hir::ExprKind::Continue(destination) => {\n                 if let Ok(_) = destination.target_id {\n                     tcx.types.never\n                 } else {\n                     // There was an error, make typecheck fail\n                     tcx.types.err\n                 }\n             }\n-            hir::ExprRet(ref expr_opt) => {\n+            hir::ExprKind::Ret(ref expr_opt) => {\n                 if self.ret_coercion.is_none() {\n                     struct_span_err!(self.tcx.sess, expr.span, E0572,\n                                         \"return statement outside of function body\").emit();\n@@ -3918,7 +3918,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 tcx.types.never\n             }\n-            hir::ExprAssign(ref lhs, ref rhs) => {\n+            hir::ExprKind::Assign(ref lhs, ref rhs) => {\n                 let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n \n                 let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n@@ -3948,11 +3948,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tcx.mk_nil()\n                 }\n             }\n-            hir::ExprIf(ref cond, ref then_expr, ref opt_else_expr) => {\n+            hir::ExprKind::If(ref cond, ref then_expr, ref opt_else_expr) => {\n                 self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n                                     expr.span, expected)\n             }\n-            hir::ExprWhile(ref cond, ref body, _) => {\n+            hir::ExprKind::While(ref cond, ref body, _) => {\n                 let ctxt = BreakableCtxt {\n                     // cannot use break with a value from a while loop\n                     coerce: None,\n@@ -3976,7 +3976,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 self.tcx.mk_nil()\n             }\n-            hir::ExprLoop(ref body, _, source) => {\n+            hir::ExprKind::Loop(ref body, _, source) => {\n                 let coerce = match source {\n                     // you can only use break with a value from a normal `loop { }`\n                     hir::LoopSource::Loop => {\n@@ -4016,22 +4016,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 ctxt.coerce.map(|c| c.complete(self)).unwrap_or(self.tcx.mk_nil())\n             }\n-            hir::ExprMatch(ref discrim, ref arms, match_src) => {\n+            hir::ExprKind::Match(ref discrim, ref arms, match_src) => {\n                 self.check_match(expr, &discrim, arms, expected, match_src)\n             }\n-            hir::ExprClosure(capture, ref decl, body_id, _, gen) => {\n+            hir::ExprKind::Closure(capture, ref decl, body_id, _, gen) => {\n                 self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n             }\n-            hir::ExprBlock(ref body, _) => {\n+            hir::ExprKind::Block(ref body, _) => {\n                 self.check_block_with_expected(&body, expected)\n             }\n-            hir::ExprCall(ref callee, ref args) => {\n+            hir::ExprKind::Call(ref callee, ref args) => {\n                 self.check_call(expr, &callee, args, expected)\n             }\n-            hir::ExprMethodCall(ref segment, span, ref args) => {\n+            hir::ExprKind::MethodCall(ref segment, span, ref args) => {\n                 self.check_method_call(expr, segment, span, args, expected, needs)\n             }\n-            hir::ExprCast(ref e, ref t) => {\n+            hir::ExprKind::Cast(ref e, ref t) => {\n                 // Find the type of `e`. Supply hints based on the type we are casting to,\n                 // if appropriate.\n                 let t_cast = self.to_ty(t);\n@@ -4056,12 +4056,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprType(ref e, ref t) => {\n+            hir::ExprKind::Type(ref e, ref t) => {\n                 let ty = self.to_ty(&t);\n                 self.check_expr_eq_type(&e, ty);\n                 ty\n             }\n-            hir::ExprArray(ref args) => {\n+            hir::ExprKind::Array(ref args) => {\n                 let uty = expected.to_option(self).and_then(|uty| {\n                     match uty.sty {\n                         ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n@@ -4085,7 +4085,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 tcx.mk_array(element_ty, args.len() as u64)\n             }\n-            hir::ExprRepeat(ref element, ref count) => {\n+            hir::ExprKind::Repeat(ref element, ref count) => {\n                 let count_def_id = tcx.hir.local_def_id(count.id);\n                 let param_env = ty::ParamEnv::empty();\n                 let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n@@ -4148,7 +4148,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tcx.types.err\n                 }\n             }\n-            hir::ExprTup(ref elts) => {\n+            hir::ExprKind::Tup(ref elts) => {\n                 let flds = expected.only_has_type(self).and_then(|ty| {\n                     let ty = self.resolve_type_vars_with_obligations(ty);\n                     match ty.sty {\n@@ -4178,13 +4178,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tuple\n                 }\n             }\n-            hir::ExprStruct(ref qpath, ref fields, ref base_expr) => {\n+            hir::ExprKind::Struct(ref qpath, ref fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n-            hir::ExprField(ref base, field) => {\n+            hir::ExprKind::Field(ref base, field) => {\n                 self.check_field(expr, needs, &base, field)\n             }\n-            hir::ExprIndex(ref base, ref idx) => {\n+            hir::ExprKind::Index(ref base, ref idx) => {\n                 let base_t = self.check_expr_with_needs(&base, needs);\n                 let idx_t = self.check_expr(&idx);\n \n@@ -4210,7 +4210,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 let mut needs_note = true;\n                                 // If the index is an integer, we can show the actual\n                                 // fixed expression:\n-                                if let hir::ExprLit(ref lit) = idx.node {\n+                                if let hir::ExprKind::Lit(ref lit) = idx.node {\n                                     if let ast::LitKind::Int(i,\n                                             ast::LitIntType::Unsuffixed) = lit.node {\n                                         let snip = tcx.sess.codemap().span_to_snippet(base.span);\n@@ -4233,7 +4233,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprYield(ref value) => {\n+            hir::ExprKind::Yield(ref value) => {\n                 match self.yield_ty {\n                     Some(ty) => {\n                         self.check_expr_coercable_to_type(&value, ty);\n@@ -4265,7 +4265,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n-                let def = if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = qself.node {\n+                let def = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.node {\n                     path.def\n                 } else {\n                     Def::Err\n@@ -4377,15 +4377,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_stmt(&self, stmt: &'gcx hir::Stmt) {\n         // Don't do all the complex logic below for DeclItem.\n         match stmt.node {\n-            hir::StmtDecl(ref decl, _) => {\n+            hir::StmtKind::Decl(ref decl, _) => {\n                 match decl.node {\n-                    hir::DeclLocal(_) => {}\n-                    hir::DeclItem(_) => {\n+                    hir::DeclKind::Local(_) => {}\n+                    hir::DeclKind::Item(_) => {\n                         return;\n                     }\n                 }\n             }\n-            hir::StmtExpr(..) | hir::StmtSemi(..) => {}\n+            hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n         }\n \n         self.warn_if_unreachable(stmt.node.id(), stmt.span, \"statement\");\n@@ -4397,19 +4397,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.has_errors.set(false);\n \n         match stmt.node {\n-            hir::StmtDecl(ref decl, _) => {\n+            hir::StmtKind::Decl(ref decl, _) => {\n                 match decl.node {\n-                    hir::DeclLocal(ref l) => {\n+                    hir::DeclKind::Local(ref l) => {\n                         self.check_decl_local(&l);\n                     }\n-                    hir::DeclItem(_) => {/* ignore for now */}\n+                    hir::DeclKind::Item(_) => {/* ignore for now */}\n                 }\n             }\n-            hir::StmtExpr(ref expr, _) => {\n+            hir::StmtKind::Expr(ref expr, _) => {\n                 // Check with expected type of ()\n                 self.check_expr_has_type_or_error(&expr, self.tcx.mk_nil());\n             }\n-            hir::StmtSemi(ref expr, _) => {\n+            hir::StmtKind::Semi(ref expr, _) => {\n                 self.check_expr(&expr);\n             }\n         }\n@@ -4548,7 +4548,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let parent = self.tcx.hir.get(fn_id);\n \n             if let Node::NodeItem(&hir::Item {\n-                name, node: hir::ItemFn(ref decl, ..), ..\n+                name, node: hir::ItemKind::Fn(ref decl, ..), ..\n             }) = parent {\n                 decl.clone().and_then(|decl| {\n                     // This is less than ideal, it will not suggest a return type span on any\n@@ -4641,13 +4641,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // `BlockTailExpression` only relevant if the tail expr would be\n             // useful on its own.\n             match expression.node {\n-                hir::ExprCall(..) |\n-                hir::ExprMethodCall(..) |\n-                hir::ExprIf(..) |\n-                hir::ExprWhile(..) |\n-                hir::ExprLoop(..) |\n-                hir::ExprMatch(..) |\n-                hir::ExprBlock(..) => {\n+                hir::ExprKind::Call(..) |\n+                hir::ExprKind::MethodCall(..) |\n+                hir::ExprKind::If(..) |\n+                hir::ExprKind::While(..) |\n+                hir::ExprKind::Loop(..) |\n+                hir::ExprKind::Match(..) |\n+                hir::ExprKind::Block(..) => {\n                     let sp = self.tcx.sess.codemap().next_point(cause_span);\n                     err.span_suggestion(sp,\n                                         \"try adding a semicolon\",\n@@ -4733,7 +4733,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             None => return,\n         };\n         let last_expr = match last_stmt.node {\n-            hir::StmtSemi(ref e, _) => e,\n+            hir::StmtKind::Semi(ref e, _) => e,\n             _ => return,\n         };\n         let last_expr_ty = self.node_ty(last_expr.hir_id);\n@@ -5048,7 +5048,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match self.tcx.hir.get(self.tcx.hir.get_parent_node(node_id)) {\n             Node::NodeExpr(expr) => {\n                 match expr.node {\n-                    hir::ExprCall(ref callee, ..) => {\n+                    hir::ExprKind::Call(ref callee, ..) => {\n                         if callee.id == node_id {\n                             return\n                         }"}, {"sha": "46746d4bd298aad5ee0e050400f811e87b4880e1", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 77, "deletions": 74, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -285,20 +285,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 }\n                             }\n                             let missing_trait = match op.node {\n-                                hir::BiAdd    => Some(\"std::ops::AddAssign\"),\n-                                hir::BiSub    => Some(\"std::ops::SubAssign\"),\n-                                hir::BiMul    => Some(\"std::ops::MulAssign\"),\n-                                hir::BiDiv    => Some(\"std::ops::DivAssign\"),\n-                                hir::BiRem    => Some(\"std::ops::RemAssign\"),\n-                                hir::BiBitAnd => Some(\"std::ops::BitAndAssign\"),\n-                                hir::BiBitXor => Some(\"std::ops::BitXorAssign\"),\n-                                hir::BiBitOr  => Some(\"std::ops::BitOrAssign\"),\n-                                hir::BiShl    => Some(\"std::ops::ShlAssign\"),\n-                                hir::BiShr    => Some(\"std::ops::ShrAssign\"),\n+                                hir::BinOpKind::Add    => Some(\"std::ops::AddAssign\"),\n+                                hir::BinOpKind::Sub    => Some(\"std::ops::SubAssign\"),\n+                                hir::BinOpKind::Mul    => Some(\"std::ops::MulAssign\"),\n+                                hir::BinOpKind::Div    => Some(\"std::ops::DivAssign\"),\n+                                hir::BinOpKind::Rem    => Some(\"std::ops::RemAssign\"),\n+                                hir::BinOpKind::BitAnd => Some(\"std::ops::BitAndAssign\"),\n+                                hir::BinOpKind::BitXor => Some(\"std::ops::BitXorAssign\"),\n+                                hir::BinOpKind::BitOr  => Some(\"std::ops::BitOrAssign\"),\n+                                hir::BinOpKind::Shl    => Some(\"std::ops::ShlAssign\"),\n+                                hir::BinOpKind::Shr    => Some(\"std::ops::ShrAssign\"),\n                                 _             => None\n                             };\n                             if let Some(missing_trait) = missing_trait {\n-                                if op.node == hir::BiAdd &&\n+                                if op.node == hir::BinOpKind::Add &&\n                                     self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n                                                             rhs_ty, &mut err) {\n                                     // This has nothing here because it means we did string\n@@ -353,23 +353,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 }\n                             }\n                             let missing_trait = match op.node {\n-                                hir::BiAdd    => Some(\"std::ops::Add\"),\n-                                hir::BiSub    => Some(\"std::ops::Sub\"),\n-                                hir::BiMul    => Some(\"std::ops::Mul\"),\n-                                hir::BiDiv    => Some(\"std::ops::Div\"),\n-                                hir::BiRem    => Some(\"std::ops::Rem\"),\n-                                hir::BiBitAnd => Some(\"std::ops::BitAnd\"),\n-                                hir::BiBitXor => Some(\"std::ops::BitXor\"),\n-                                hir::BiBitOr  => Some(\"std::ops::BitOr\"),\n-                                hir::BiShl    => Some(\"std::ops::Shl\"),\n-                                hir::BiShr    => Some(\"std::ops::Shr\"),\n-                                hir::BiEq | hir::BiNe => Some(\"std::cmp::PartialEq\"),\n-                                hir::BiLt | hir::BiLe | hir::BiGt | hir::BiGe =>\n-                                    Some(\"std::cmp::PartialOrd\"),\n-                                _             => None\n+                                hir::BinOpKind::Add    => Some(\"std::ops::Add\"),\n+                                hir::BinOpKind::Sub    => Some(\"std::ops::Sub\"),\n+                                hir::BinOpKind::Mul    => Some(\"std::ops::Mul\"),\n+                                hir::BinOpKind::Div    => Some(\"std::ops::Div\"),\n+                                hir::BinOpKind::Rem    => Some(\"std::ops::Rem\"),\n+                                hir::BinOpKind::BitAnd => Some(\"std::ops::BitAnd\"),\n+                                hir::BinOpKind::BitXor => Some(\"std::ops::BitXor\"),\n+                                hir::BinOpKind::BitOr  => Some(\"std::ops::BitOr\"),\n+                                hir::BinOpKind::Shl    => Some(\"std::ops::Shl\"),\n+                                hir::BinOpKind::Shr    => Some(\"std::ops::Shr\"),\n+                                hir::BinOpKind::Eq |\n+                                hir::BinOpKind::Ne => Some(\"std::cmp::PartialEq\"),\n+                                hir::BinOpKind::Lt |\n+                                hir::BinOpKind::Le |\n+                                hir::BinOpKind::Gt |\n+                                hir::BinOpKind::Ge => Some(\"std::cmp::PartialOrd\"),\n+                                _ => None\n                             };\n                             if let Some(missing_trait) = missing_trait {\n-                                if op.node == hir::BiAdd &&\n+                                if op.node == hir::BinOpKind::Add &&\n                                     self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n                                                             rhs_ty, &mut err) {\n                                     // This has nothing here because it means we did string\n@@ -508,44 +511,44 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n         let (opname, trait_did) = if let Op::Binary(op, IsAssign::Yes) = op {\n             match op.node {\n-                hir::BiAdd => (\"add_assign\", lang.add_assign_trait()),\n-                hir::BiSub => (\"sub_assign\", lang.sub_assign_trait()),\n-                hir::BiMul => (\"mul_assign\", lang.mul_assign_trait()),\n-                hir::BiDiv => (\"div_assign\", lang.div_assign_trait()),\n-                hir::BiRem => (\"rem_assign\", lang.rem_assign_trait()),\n-                hir::BiBitXor => (\"bitxor_assign\", lang.bitxor_assign_trait()),\n-                hir::BiBitAnd => (\"bitand_assign\", lang.bitand_assign_trait()),\n-                hir::BiBitOr => (\"bitor_assign\", lang.bitor_assign_trait()),\n-                hir::BiShl => (\"shl_assign\", lang.shl_assign_trait()),\n-                hir::BiShr => (\"shr_assign\", lang.shr_assign_trait()),\n-                hir::BiLt | hir::BiLe |\n-                hir::BiGe | hir::BiGt |\n-                hir::BiEq | hir::BiNe |\n-                hir::BiAnd | hir::BiOr => {\n+                hir::BinOpKind::Add => (\"add_assign\", lang.add_assign_trait()),\n+                hir::BinOpKind::Sub => (\"sub_assign\", lang.sub_assign_trait()),\n+                hir::BinOpKind::Mul => (\"mul_assign\", lang.mul_assign_trait()),\n+                hir::BinOpKind::Div => (\"div_assign\", lang.div_assign_trait()),\n+                hir::BinOpKind::Rem => (\"rem_assign\", lang.rem_assign_trait()),\n+                hir::BinOpKind::BitXor => (\"bitxor_assign\", lang.bitxor_assign_trait()),\n+                hir::BinOpKind::BitAnd => (\"bitand_assign\", lang.bitand_assign_trait()),\n+                hir::BinOpKind::BitOr => (\"bitor_assign\", lang.bitor_assign_trait()),\n+                hir::BinOpKind::Shl => (\"shl_assign\", lang.shl_assign_trait()),\n+                hir::BinOpKind::Shr => (\"shr_assign\", lang.shr_assign_trait()),\n+                hir::BinOpKind::Lt | hir::BinOpKind::Le |\n+                hir::BinOpKind::Ge | hir::BinOpKind::Gt |\n+                hir::BinOpKind::Eq | hir::BinOpKind::Ne |\n+                hir::BinOpKind::And | hir::BinOpKind::Or => {\n                     span_bug!(span,\n                               \"impossible assignment operation: {}=\",\n                               op.node.as_str())\n                 }\n             }\n         } else if let Op::Binary(op, IsAssign::No) = op {\n             match op.node {\n-                hir::BiAdd => (\"add\", lang.add_trait()),\n-                hir::BiSub => (\"sub\", lang.sub_trait()),\n-                hir::BiMul => (\"mul\", lang.mul_trait()),\n-                hir::BiDiv => (\"div\", lang.div_trait()),\n-                hir::BiRem => (\"rem\", lang.rem_trait()),\n-                hir::BiBitXor => (\"bitxor\", lang.bitxor_trait()),\n-                hir::BiBitAnd => (\"bitand\", lang.bitand_trait()),\n-                hir::BiBitOr => (\"bitor\", lang.bitor_trait()),\n-                hir::BiShl => (\"shl\", lang.shl_trait()),\n-                hir::BiShr => (\"shr\", lang.shr_trait()),\n-                hir::BiLt => (\"lt\", lang.partial_ord_trait()),\n-                hir::BiLe => (\"le\", lang.partial_ord_trait()),\n-                hir::BiGe => (\"ge\", lang.partial_ord_trait()),\n-                hir::BiGt => (\"gt\", lang.partial_ord_trait()),\n-                hir::BiEq => (\"eq\", lang.eq_trait()),\n-                hir::BiNe => (\"ne\", lang.eq_trait()),\n-                hir::BiAnd | hir::BiOr => {\n+                hir::BinOpKind::Add => (\"add\", lang.add_trait()),\n+                hir::BinOpKind::Sub => (\"sub\", lang.sub_trait()),\n+                hir::BinOpKind::Mul => (\"mul\", lang.mul_trait()),\n+                hir::BinOpKind::Div => (\"div\", lang.div_trait()),\n+                hir::BinOpKind::Rem => (\"rem\", lang.rem_trait()),\n+                hir::BinOpKind::BitXor => (\"bitxor\", lang.bitxor_trait()),\n+                hir::BinOpKind::BitAnd => (\"bitand\", lang.bitand_trait()),\n+                hir::BinOpKind::BitOr => (\"bitor\", lang.bitor_trait()),\n+                hir::BinOpKind::Shl => (\"shl\", lang.shl_trait()),\n+                hir::BinOpKind::Shr => (\"shr\", lang.shr_trait()),\n+                hir::BinOpKind::Lt => (\"lt\", lang.partial_ord_trait()),\n+                hir::BinOpKind::Le => (\"le\", lang.partial_ord_trait()),\n+                hir::BinOpKind::Ge => (\"ge\", lang.partial_ord_trait()),\n+                hir::BinOpKind::Gt => (\"gt\", lang.partial_ord_trait()),\n+                hir::BinOpKind::Eq => (\"eq\", lang.eq_trait()),\n+                hir::BinOpKind::Ne => (\"ne\", lang.eq_trait()),\n+                hir::BinOpKind::And | hir::BinOpKind::Or => {\n                     span_bug!(span, \"&& and || are not overloadable\")\n                 }\n             }\n@@ -608,31 +611,31 @@ enum BinOpCategory {\n impl BinOpCategory {\n     fn from(op: hir::BinOp) -> BinOpCategory {\n         match op.node {\n-            hir::BiShl | hir::BiShr =>\n+            hir::BinOpKind::Shl | hir::BinOpKind::Shr =>\n                 BinOpCategory::Shift,\n \n-            hir::BiAdd |\n-            hir::BiSub |\n-            hir::BiMul |\n-            hir::BiDiv |\n-            hir::BiRem =>\n+            hir::BinOpKind::Add |\n+            hir::BinOpKind::Sub |\n+            hir::BinOpKind::Mul |\n+            hir::BinOpKind::Div |\n+            hir::BinOpKind::Rem =>\n                 BinOpCategory::Math,\n \n-            hir::BiBitXor |\n-            hir::BiBitAnd |\n-            hir::BiBitOr =>\n+            hir::BinOpKind::BitXor |\n+            hir::BinOpKind::BitAnd |\n+            hir::BinOpKind::BitOr =>\n                 BinOpCategory::Bitwise,\n \n-            hir::BiEq |\n-            hir::BiNe |\n-            hir::BiLt |\n-            hir::BiLe |\n-            hir::BiGe |\n-            hir::BiGt =>\n+            hir::BinOpKind::Eq |\n+            hir::BinOpKind::Ne |\n+            hir::BinOpKind::Lt |\n+            hir::BinOpKind::Le |\n+            hir::BinOpKind::Ge |\n+            hir::BinOpKind::Gt =>\n                 BinOpCategory::Comparison,\n \n-            hir::BiAnd |\n-            hir::BiOr =>\n+            hir::BinOpKind::And |\n+            hir::BinOpKind::Or =>\n                 BinOpCategory::Shortcircuit,\n         }\n     }"}, {"sha": "8aa5658d291db711a1b2bb60c0deaf26d3ceaf6b", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -495,9 +495,9 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // provided as arguments outlive the call.\n         if is_method_call {\n             let origin = match expr.node {\n-                hir::ExprMethodCall(..) =>\n+                hir::ExprKind::MethodCall(..) =>\n                     infer::ParameterOrigin::MethodCall,\n-                hir::ExprUnary(op, _) if op == hir::UnDeref =>\n+                hir::ExprKind::Unary(op, _) if op == hir::UnDeref =>\n                     infer::ParameterOrigin::OverloadedDeref,\n                 _ =>\n                     infer::ParameterOrigin::OverloadedOperator\n@@ -525,13 +525,13 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"regionck::visit_expr(e={:?}, repeating_scope={}) - visiting subexprs\",\n                expr, self.repeating_scope);\n         match expr.node {\n-            hir::ExprPath(_) => {\n+            hir::ExprKind::Path(_) => {\n                 let substs = self.tables.borrow().node_substs(expr.hir_id);\n                 let origin = infer::ParameterOrigin::Path;\n                 self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n             }\n \n-            hir::ExprCall(ref callee, ref args) => {\n+            hir::ExprKind::Call(ref callee, ref args) => {\n                 if is_method_call {\n                     self.constrain_call(expr, Some(&callee), args.iter().map(|e| &*e));\n                 } else {\n@@ -542,34 +542,34 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprMethodCall(.., ref args) => {\n+            hir::ExprKind::MethodCall(.., ref args) => {\n                 self.constrain_call(expr, Some(&args[0]), args[1..].iter().map(|e| &*e));\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n+            hir::ExprKind::AssignOp(_, ref lhs, ref rhs) => {\n                 if is_method_call {\n                     self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n                 }\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprIndex(ref lhs, ref rhs) if is_method_call => {\n+            hir::ExprKind::Index(ref lhs, ref rhs) if is_method_call => {\n                 self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n \n                 intravisit::walk_expr(self, expr);\n             },\n \n-            hir::ExprBinary(_, ref lhs, ref rhs) if is_method_call => {\n-                // As `ExprMethodCall`, but the call is via an overloaded op.\n+            hir::ExprKind::Binary(_, ref lhs, ref rhs) if is_method_call => {\n+                // As `ExprKind::MethodCall`, but the call is via an overloaded op.\n                 self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprBinary(_, ref lhs, ref rhs) => {\n+            hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n                 // If you do `x OP y`, then the types of `x` and `y` must\n                 // outlive the operation you are performing.\n                 let lhs_ty = self.resolve_expr_type_adjusted(&lhs);\n@@ -581,7 +581,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprUnary(hir::UnDeref, ref base) => {\n+            hir::ExprKind::Unary(hir::UnDeref, ref base) => {\n                 // For *a, the lifetime of a must enclose the deref\n                 if is_method_call {\n                     self.constrain_call(expr, Some(base), None::<hir::Expr>.iter());\n@@ -596,30 +596,30 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprUnary(_, ref lhs) if is_method_call => {\n+            hir::ExprKind::Unary(_, ref lhs) if is_method_call => {\n                 // As above.\n                 self.constrain_call(expr, Some(&lhs), None::<hir::Expr>.iter());\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprIndex(ref vec_expr, _) => {\n+            hir::ExprKind::Index(ref vec_expr, _) => {\n                 // For a[b], the lifetime of a must enclose the deref\n                 let vec_type = self.resolve_expr_type_adjusted(&vec_expr);\n                 self.constrain_index(expr, vec_type);\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprCast(ref source, _) => {\n+            hir::ExprKind::Cast(ref source, _) => {\n                 // Determine if we are casting `source` to a trait\n                 // instance.  If so, we have to be sure that the type of\n                 // the source obeys the trait's region bound.\n                 self.constrain_cast(expr, &source);\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprAddrOf(m, ref base) => {\n+            hir::ExprKind::AddrOf(m, ref base) => {\n                 self.link_addr_of(expr, m, &base);\n \n                 // Require that when you write a `&expr` expression, the\n@@ -635,23 +635,23 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprMatch(ref discr, ref arms, _) => {\n+            hir::ExprKind::Match(ref discr, ref arms, _) => {\n                 self.link_match(&discr, &arms[..]);\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprClosure(.., body_id, _, _) => {\n+            hir::ExprKind::Closure(.., body_id, _, _) => {\n                 self.check_expr_fn_block(expr, body_id);\n             }\n \n-            hir::ExprLoop(ref body, _, _) => {\n+            hir::ExprKind::Loop(ref body, _, _) => {\n                 let repeating_scope = self.set_repeating_scope(body.id);\n                 intravisit::walk_expr(self, expr);\n                 self.set_repeating_scope(repeating_scope);\n             }\n \n-            hir::ExprWhile(ref cond, ref body, _) => {\n+            hir::ExprKind::While(ref cond, ref body, _) => {\n                 let repeating_scope = self.set_repeating_scope(cond.id);\n                 self.visit_expr(&cond);\n \n@@ -661,9 +661,9 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 self.set_repeating_scope(repeating_scope);\n             }\n \n-            hir::ExprRet(Some(ref ret_expr)) => {\n+            hir::ExprKind::Ret(Some(ref ret_expr)) => {\n                 let call_site_scope = self.call_site_scope;\n-                debug!(\"visit_expr ExprRet ret_expr.id {} call_site_scope: {:?}\",\n+                debug!(\"visit_expr ExprKind::Ret ret_expr.id {} call_site_scope: {:?}\",\n                        ret_expr.id, call_site_scope);\n                 let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope.unwrap()));\n                 self.type_of_node_must_outlive(infer::CallReturn(ret_expr.span),"}, {"sha": "61fe90be2177420c9567dfe5a5ff9e30d221dbe0", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         match expr.node {\n-            hir::ExprClosure(cc, _, body_id, _, _) => {\n+            hir::ExprKind::Closure(cc, _, body_id, _, _) => {\n                 let body = self.fcx.tcx.hir.body(body_id);\n                 self.visit_body(body);\n                 self.fcx"}, {"sha": "d876f41ce13078ce37891c40ebe38e892dd49784", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -97,7 +97,7 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n         //\n         // won't be allowed unless there's an *explicit* implementation of `Send`\n         // for `T`\n-        hir::ItemImpl(_, polarity, defaultness, _, ref trait_ref, ref self_ty, _) => {\n+        hir::ItemKind::Impl(_, polarity, defaultness, _, ref trait_ref, ref self_ty, _) => {\n             let is_auto = tcx.impl_trait_ref(tcx.hir.local_def_id(item.id))\n                                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n             if let (hir::Defaultness::Default { .. }, true) = (defaultness, is_auto) {\n@@ -114,37 +114,37 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n                 }\n             }\n         }\n-        hir::ItemFn(..) => {\n+        hir::ItemKind::Fn(..) => {\n             check_item_fn(tcx, item);\n         }\n-        hir::ItemStatic(..) => {\n+        hir::ItemKind::Static(..) => {\n             check_item_type(tcx, item);\n         }\n-        hir::ItemConst(..) => {\n+        hir::ItemKind::Const(..) => {\n             check_item_type(tcx, item);\n         }\n-        hir::ItemStruct(ref struct_def, ref ast_generics) => {\n+        hir::ItemKind::Struct(ref struct_def, ref ast_generics) => {\n             check_type_defn(tcx, item, false, |fcx| {\n                 vec![fcx.non_enum_variant(struct_def)]\n             });\n \n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemUnion(ref struct_def, ref ast_generics) => {\n+        hir::ItemKind::Union(ref struct_def, ref ast_generics) => {\n             check_type_defn(tcx, item, true, |fcx| {\n                 vec![fcx.non_enum_variant(struct_def)]\n             });\n \n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemEnum(ref enum_def, ref ast_generics) => {\n+        hir::ItemKind::Enum(ref enum_def, ref ast_generics) => {\n             check_type_defn(tcx, item, true, |fcx| {\n                 fcx.enum_variants(enum_def)\n             });\n \n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemTrait(..) => {\n+        hir::ItemKind::Trait(..) => {\n             check_trait(tcx, item);\n         }\n         _ => {}"}, {"sha": "3207ac44948f471885937034d32a4d5716010b10", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -117,7 +117,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     // operating on scalars, we clear the overload.\n     fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n-            hir::ExprUnary(hir::UnNeg, ref inner) | hir::ExprUnary(hir::UnNot, ref inner) => {\n+            hir::ExprKind::Unary(hir::UnNeg, ref inner) |\n+            hir::ExprKind::Unary(hir::UnNot, ref inner) => {\n                 let inner_ty = self.fcx.node_ty(inner.hir_id);\n                 let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n \n@@ -127,8 +128,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     tables.node_substs_mut().remove(e.hir_id);\n                 }\n             }\n-            hir::ExprBinary(ref op, ref lhs, ref rhs)\n-            | hir::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n+            hir::ExprKind::Binary(ref op, ref lhs, ref rhs)\n+            | hir::ExprKind::AssignOp(ref op, ref lhs, ref rhs) => {\n                 let lhs_ty = self.fcx.node_ty(lhs.hir_id);\n                 let lhs_ty = self.fcx.resolve_type_vars_if_possible(&lhs_ty);\n \n@@ -141,14 +142,14 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     tables.node_substs_mut().remove(e.hir_id);\n \n                     match e.node {\n-                        hir::ExprBinary(..) => {\n+                        hir::ExprKind::Binary(..) => {\n                             if !op.node.is_by_value() {\n                                 let mut adjustments = tables.adjustments_mut();\n                                 adjustments.get_mut(lhs.hir_id).map(|a| a.pop());\n                                 adjustments.get_mut(rhs.hir_id).map(|a| a.pop());\n                             }\n                         }\n-                        hir::ExprAssignOp(..) => {\n+                        hir::ExprKind::AssignOp(..) => {\n                             tables\n                                 .adjustments_mut()\n                                 .get_mut(lhs.hir_id)\n@@ -167,7 +168,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     // to use builtin indexing because the index type is known to be\n     // usize-ish\n     fn fix_index_builtin_expr(&mut self, e: &hir::Expr) {\n-        if let hir::ExprIndex(ref base, ref index) = e.node {\n+        if let hir::ExprKind::Index(ref base, ref index) = e.node {\n             let mut tables = self.fcx.tables.borrow_mut();\n \n             match tables.expr_ty_adjusted(&base).sty {\n@@ -227,20 +228,20 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         self.visit_node_id(e.span, e.hir_id);\n \n         match e.node {\n-            hir::ExprClosure(_, _, body, _, _) => {\n+            hir::ExprKind::Closure(_, _, body, _, _) => {\n                 let body = self.fcx.tcx.hir.body(body);\n                 for arg in &body.arguments {\n                     self.visit_node_id(e.span, arg.hir_id);\n                 }\n \n                 self.visit_body(body);\n             }\n-            hir::ExprStruct(_, ref fields, _) => {\n+            hir::ExprKind::Struct(_, ref fields, _) => {\n                 for field in fields {\n                     self.visit_field_id(field.id);\n                 }\n             }\n-            hir::ExprField(..) => {\n+            hir::ExprKind::Field(..) => {\n                 self.visit_field_id(e.id);\n             }\n             _ => {}"}, {"sha": "1a57dfd745e3ac23c6342d74224d84567ece1e46", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n         if item.vis.node.is_pub() || item.span.is_dummy() {\n             return;\n         }\n-        if let hir::ItemUse(ref path, _) = item.node {\n+        if let hir::ItemKind::Use(ref path, _) = item.node {\n             self.check_import(item.id, path.span);\n         }\n     }\n@@ -196,7 +196,7 @@ struct ExternCrateToLint {\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemExternCrate(orig_name) = item.node {\n+        if let hir::ItemKind::ExternCrate(orig_name) = item.node {\n             let extern_crate_def_id = self.tcx.hir.local_def_id(item.id);\n             self.crates_to_lint.push(\n                 ExternCrateToLint {"}, {"sha": "4d9a4a03a6b50326bdc92c48f9dfdc8a3657dba3", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -24,7 +24,7 @@ use rustc::infer;\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n-use rustc::hir::{self, ItemImpl};\n+use rustc::hir::{self, ItemKind};\n \n pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n     Checker { tcx, trait_def_id }\n@@ -64,7 +64,7 @@ fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 match tcx.hir.find(impl_node_id) {\n                     Some(hir_map::NodeItem(item)) => {\n                         let span = match item.node {\n-                            ItemImpl(.., ref ty, _) => ty.span,\n+                            ItemKind::Impl(.., ref ty, _) => ty.span,\n                             _ => item.span,\n                         };\n                         struct_span_err!(tcx.sess,\n@@ -115,7 +115,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n             let item = tcx.hir.expect_item(impl_node_id);\n-            let span = if let ItemImpl(.., Some(ref tr), _, _) = item.node {\n+            let span = if let ItemKind::Impl(.., Some(ref tr), _, _) = item.node {\n                 tr.path.span\n             } else {\n                 span\n@@ -132,7 +132,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n             let item = tcx.hir.expect_item(impl_node_id);\n-            let span = if let ItemImpl(.., ref ty, _) = item.node {\n+            let span = if let ItemKind::Impl(.., ref ty, _) = item.node {\n                 ty.span\n             } else {\n                 span\n@@ -336,7 +336,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n                     let item = gcx.hir.expect_item(impl_node_id);\n-                    let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n+                    let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.node {\n                         t.path.span\n                     } else {\n                         gcx.hir.span(impl_node_id)"}, {"sha": "02a18fa47dff16fce4f66e35d574381b64a6a9e2", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -94,7 +94,7 @@ struct InherentCollect<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let ty = match item.node {\n-            hir::ItemImpl(.., None, ref ty, _) => ty,\n+            hir::ItemKind::Impl(.., None, ref ty, _) => ty,\n             _ => return\n         };\n "}, {"sha": "c0260d6714d0538695c1851b6b45c3c4059e9dd1", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -122,10 +122,10 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemTrait(..) |\n-            hir::ItemUnion(..) => {\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Trait(..) |\n+            hir::ItemKind::Union(..) => {\n                 let type_def_id = self.tcx.hir.local_def_id(item.id);\n                 self.check_for_overlapping_inherent_impls(type_def_id);\n             }"}, {"sha": "9be509b358807878b3a99dd6c8f15ac37a2b64ae", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -34,7 +34,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let def_id = self.tcx.hir.local_def_id(item.id);\n         match item.node {\n-            hir::ItemImpl(.., Some(_), _, _) => {\n+            hir::ItemKind::Impl(.., Some(_), _, _) => {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: trait impl {}\",\n                        self.tcx.hir.node_to_string(item.id));"}, {"sha": "9e19854a571fcba1dab34f98f7ed5e60b550fe24", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -84,7 +84,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemImpl(unsafety, polarity, _, ref generics, ..) => {\n+            hir::ItemKind::Impl(unsafety, polarity, _, ref generics, ..) => {\n                 self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);\n             }\n             _ => {}"}, {"sha": "4b628d6ffad75aa0aca69cdb7d8f9f7828e3c364", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 95, "deletions": 91, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprClosure(..) = expr.node {\n+        if let hir::ExprKind::Closure(..) = expr.node {\n             let def_id = self.tcx.hir.local_def_id(expr.id);\n             self.tcx.generics_of(def_id);\n             self.tcx.type_of(def_id);\n@@ -266,13 +266,13 @@ fn type_param_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemFn(.., ref generics, _) |\n-                ItemImpl(_, _, _, ref generics, ..) |\n-                ItemTy(_, ref generics) |\n-                ItemEnum(_, ref generics) |\n-                ItemStruct(_, ref generics) |\n-                ItemUnion(_, ref generics) => generics,\n-                ItemTrait(_, _, ref generics, ..) => {\n+                ItemKind::Fn(.., ref generics, _) |\n+                ItemKind::Impl(_, _, _, ref generics, ..) |\n+                ItemKind::Ty(_, ref generics) |\n+                ItemKind::Enum(_, ref generics) |\n+                ItemKind::Struct(_, ref generics) |\n+                ItemKind::Union(_, ref generics) => generics,\n+                ItemKind::Trait(_, _, ref generics, ..) => {\n                     // Implied `Self: Trait` and supertrait bounds.\n                     if param_id == item_node_id {\n                         result.predicates.push(\n@@ -287,7 +287,7 @@ fn type_param_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeForeignItem(item) => {\n             match item.node {\n-                ForeignItemFn(_, _, ref generics) => generics,\n+                ForeignItemKind::Fn(_, _, ref generics) => generics,\n                 _ => return result\n             }\n         }\n@@ -346,7 +346,7 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       param_id: ast::NodeId)\n                       -> bool\n {\n-    if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n+    if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n         match path.def {\n             Def::SelfTy(Some(def_id), None) |\n             Def::TyParam(def_id) => {\n@@ -365,45 +365,45 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n     let def_id = tcx.hir.local_def_id(item_id);\n     match it.node {\n         // These don't define types.\n-        hir::ItemExternCrate(_) |\n-        hir::ItemUse(..) |\n-        hir::ItemMod(_) |\n-        hir::ItemGlobalAsm(_) => {}\n-        hir::ItemForeignMod(ref foreign_mod) => {\n+        hir::ItemKind::ExternCrate(_) |\n+        hir::ItemKind::Use(..) |\n+        hir::ItemKind::Mod(_) |\n+        hir::ItemKind::GlobalAsm(_) => {}\n+        hir::ItemKind::ForeignMod(ref foreign_mod) => {\n             for item in &foreign_mod.items {\n                 let def_id = tcx.hir.local_def_id(item.id);\n                 tcx.generics_of(def_id);\n                 tcx.type_of(def_id);\n                 tcx.predicates_of(def_id);\n-                if let hir::ForeignItemFn(..) = item.node {\n+                if let hir::ForeignItemKind::Fn(..) = item.node {\n                     tcx.fn_sig(def_id);\n                 }\n             }\n         }\n-        hir::ItemEnum(ref enum_definition, _) => {\n+        hir::ItemKind::Enum(ref enum_definition, _) => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n             convert_enum_variant_types(tcx, def_id, &enum_definition.variants);\n         },\n-        hir::ItemImpl(..) => {\n+        hir::ItemKind::Impl(..) => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.impl_trait_ref(def_id);\n             tcx.predicates_of(def_id);\n         },\n-        hir::ItemTrait(..) => {\n+        hir::ItemKind::Trait(..) => {\n             tcx.generics_of(def_id);\n             tcx.trait_def(def_id);\n             tcx.at(it.span).super_predicates_of(def_id);\n             tcx.predicates_of(def_id);\n         },\n-        hir::ItemTraitAlias(..) => {\n+        hir::ItemKind::TraitAlias(..) => {\n             span_err!(tcx.sess, it.span, E0645,\n                       \"trait aliases are not yet implemented (see issue #41517)\");\n         },\n-        hir::ItemStruct(ref struct_def, _) |\n-        hir::ItemUnion(ref struct_def, _) => {\n+        hir::ItemKind::Struct(ref struct_def, _) |\n+        hir::ItemKind::Union(ref struct_def, _) => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n@@ -419,12 +419,15 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n                 convert_variant_ctor(tcx, struct_def.id());\n             }\n         },\n-        hir::ItemExistential(..) => {}\n-        hir::ItemTy(..) | hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) => {\n+        hir::ItemKind::Existential(..) => {}\n+        hir::ItemKind::Ty(..) |\n+        hir::ItemKind::Static(..) |\n+        hir::ItemKind::Const(..) |\n+        hir::ItemKind::Fn(..) => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n-            if let hir::ItemFn(..) = it.node {\n+            if let hir::ItemKind::Fn(..) = it.node {\n                 tcx.fn_sig(def_id);\n             }\n         }\n@@ -561,7 +564,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let repr = ReprOptions::new(tcx, def_id);\n     let (kind, variants) = match item.node {\n-        ItemEnum(ref def, _) => {\n+        ItemKind::Enum(ref def, _) => {\n             let mut distance_from_explicit = 0;\n             (AdtKind::Enum, def.variants.iter().map(|v| {\n                 let did = tcx.hir.local_def_id(v.node.data.id());\n@@ -576,7 +579,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 convert_struct_variant(tcx, did, v.node.name, discr, &v.node.data)\n             }).collect())\n         }\n-        ItemStruct(ref def, _) => {\n+        ItemKind::Struct(ref def, _) => {\n             // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n             let ctor_id = if !def.is_struct() {\n                 Some(tcx.hir.local_def_id(def.id()))\n@@ -588,7 +591,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        ty::VariantDiscr::Relative(0), def)\n             ])\n         }\n-        ItemUnion(ref def, _) => {\n+        ItemKind::Union(ref def, _) => {\n             (AdtKind::Union, vec![\n                 convert_struct_variant(tcx, def_id, item.name,\n                                        ty::VariantDiscr::Relative(0), def)\n@@ -614,8 +617,8 @@ fn super_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     let (generics, bounds) = match item.node {\n-        hir::ItemTrait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n-        hir::ItemTraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n+        hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n+        hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n         _ => span_bug!(item.span,\n                        \"super_predicates invoked on non-trait\"),\n     };\n@@ -658,8 +661,8 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let item = tcx.hir.expect_item(node_id);\n \n     let (is_auto, unsafety) = match item.node {\n-        hir::ItemTrait(is_auto, unsafety, ..) => (is_auto == hir::IsAuto::Yes, unsafety),\n-        hir::ItemTraitAlias(..) => (false, hir::Unsafety::Normal),\n+        hir::ItemKind::Trait(is_auto, unsafety, ..) => (is_auto == hir::IsAuto::Yes, unsafety),\n+        hir::ItemKind::TraitAlias(..) => (false, hir::Unsafety::Normal),\n         _ => span_bug!(item.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n \n@@ -701,7 +704,7 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n             if self.has_late_bound_regions.is_some() { return }\n             match ty.node {\n-                hir::TyBareFn(..) => {\n+                hir::TyKind::BareFn(..) => {\n                     self.outer_index.shift_in(1);\n                     intravisit::walk_ty(self, ty);\n                     self.outer_index.shift_out(1);\n@@ -774,12 +777,12 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             _ => None,\n         },\n         hir_map::NodeForeignItem(item) => match item.node {\n-            hir::ForeignItemFn(ref fn_decl, _, ref generics) =>\n+            hir::ForeignItemKind::Fn(ref fn_decl, _, ref generics) =>\n                 has_late_bound_regions(tcx, generics, fn_decl),\n             _ => None,\n         },\n         hir_map::NodeItem(item) => match item.node {\n-            hir::ItemFn(ref fn_decl, .., ref generics, _) =>\n+            hir::ItemKind::Fn(ref fn_decl, .., ref generics, _) =>\n                 has_late_bound_regions(tcx, generics, fn_decl),\n             _ => None,\n         },\n@@ -805,12 +808,12 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let parent_id = tcx.hir.get_parent(node_id);\n             Some(tcx.hir.local_def_id(parent_id))\n         }\n-        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+        NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(..), .. }) => {\n             Some(tcx.closure_base_def_id(def_id))\n         }\n         NodeItem(item) => {\n             match item.node {\n-                ItemExistential(hir::ExistTy { impl_trait_fn, .. }) => impl_trait_fn,\n+                ItemKind::Existential(hir::ExistTy { impl_trait_fn, .. }) => impl_trait_fn,\n                 _ => None,\n             }\n         },\n@@ -828,19 +831,20 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemFn(.., ref generics, _) |\n-                ItemImpl(_, _, _, ref generics, ..) => generics,\n-\n-                ItemTy(_, ref generics) |\n-                ItemEnum(_, ref generics) |\n-                ItemStruct(_, ref generics) |\n-                ItemExistential(hir::ExistTy { ref generics, .. }) |\n-                ItemUnion(_, ref generics) => {\n+                ItemKind::Fn(.., ref generics, _) |\n+                ItemKind::Impl(_, _, _, ref generics, ..) => generics,\n+\n+                ItemKind::Ty(_, ref generics) |\n+                ItemKind::Enum(_, ref generics) |\n+                ItemKind::Struct(_, ref generics) |\n+                ItemKind::Existential(hir::ExistTy { ref generics, .. }) |\n+                ItemKind::Union(_, ref generics) => {\n                     allow_defaults = true;\n                     generics\n                 }\n \n-                ItemTrait(_, _, ref generics, ..) | ItemTraitAlias(ref generics, ..) => {\n+                ItemKind::Trait(_, _, ref generics, ..) |\n+                ItemKind::TraitAlias(ref generics, ..) => {\n                     // Add in the self type parameter.\n                     //\n                     // Something of a hack: use the node id for the trait, also as\n@@ -869,9 +873,9 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeForeignItem(item) => {\n             match item.node {\n-                ForeignItemStatic(..) => &no_generics,\n-                ForeignItemFn(_, _, ref generics) => generics,\n-                ForeignItemType => &no_generics,\n+                ForeignItemKind::Static(..) => &no_generics,\n+                ForeignItemKind::Fn(_, _, ref generics) => generics,\n+                ForeignItemKind::Type => &no_generics,\n             }\n         }\n \n@@ -946,7 +950,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // provide junk type parameter defs - the only place that\n     // cares about anything but the length is instantiation,\n     // and we don't do that for closures.\n-    if let NodeExpr(&hir::Expr { node: hir::ExprClosure(.., gen), .. }) = node {\n+    if let NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(.., gen), .. }) = node {\n         let dummy_args = if gen.is_some() {\n             &[\"<yield_ty>\", \"<return_ty>\", \"<witness>\"][..]\n         } else {\n@@ -1043,33 +1047,33 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemStatic(ref t, ..) | ItemConst(ref t, _) |\n-                ItemTy(ref t, _) | ItemImpl(.., ref t, _) => {\n+                ItemKind::Static(ref t, ..) | ItemKind::Const(ref t, _) |\n+                ItemKind::Ty(ref t, _) | ItemKind::Impl(.., ref t, _) => {\n                     icx.to_ty(t)\n                 }\n-                ItemFn(..) => {\n+                ItemKind::Fn(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     tcx.mk_fn_def(def_id, substs)\n                 }\n-                ItemEnum(..) |\n-                ItemStruct(..) |\n-                ItemUnion(..) => {\n+                ItemKind::Enum(..) |\n+                ItemKind::Struct(..) |\n+                ItemKind::Union(..) => {\n                     let def = tcx.adt_def(def_id);\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     tcx.mk_adt(def, substs)\n                 }\n                 // this is only reachable once we have named existential types\n-                ItemExistential(hir::ExistTy { impl_trait_fn: None, .. }) => unimplemented!(),\n+                ItemKind::Existential(hir::ExistTy { impl_trait_fn: None, .. }) => unimplemented!(),\n                 // existential types desugared from impl Trait\n-                ItemExistential(hir::ExistTy { impl_trait_fn: Some(owner), .. }) => {\n+                ItemKind::Existential(hir::ExistTy { impl_trait_fn: Some(owner), .. }) => {\n                     tcx.typeck_tables_of(owner).concrete_existential_types[&def_id]\n                 },\n-                ItemTrait(..) | ItemTraitAlias(..) |\n-                ItemMod(..) |\n-                ItemForeignMod(..) |\n-                ItemGlobalAsm(..) |\n-                ItemExternCrate(..) |\n-                ItemUse(..) => {\n+                ItemKind::Trait(..) | ItemKind::TraitAlias(..) |\n+                ItemKind::Mod(..) |\n+                ItemKind::ForeignMod(..) |\n+                ItemKind::GlobalAsm(..) |\n+                ItemKind::ExternCrate(..) |\n+                ItemKind::Use(..) => {\n                     span_bug!(\n                         item.span,\n                         \"compute_type_of_item: unexpected item type: {:?}\",\n@@ -1080,17 +1084,17 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeForeignItem(foreign_item) => {\n             match foreign_item.node {\n-                ForeignItemFn(..) => {\n+                ForeignItemKind::Fn(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     tcx.mk_fn_def(def_id, substs)\n                 }\n-                ForeignItemStatic(ref t, _) => icx.to_ty(t),\n-                ForeignItemType => tcx.mk_foreign(def_id),\n+                ForeignItemKind::Static(ref t, _) => icx.to_ty(t),\n+                ForeignItemKind::Type => tcx.mk_foreign(def_id),\n             }\n         }\n \n         NodeStructCtor(&ref def) |\n-        NodeVariant(&Spanned { node: hir::Variant_ { data: ref def, .. }, .. }) => {\n+        NodeVariant(&Spanned { node: hir::VariantKind { data: ref def, .. }, .. }) => {\n             match *def {\n                 VariantData::Unit(..) | VariantData::Struct(..) => {\n                     tcx.type_of(tcx.hir.get_parent_did(node_id))\n@@ -1104,7 +1108,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeField(field) => icx.to_ty(&field.ty),\n \n-        NodeExpr(&hir::Expr { node: hir::ExprClosure(.., gen), .. }) => {\n+        NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(.., gen), .. }) => {\n             if gen.is_some() {\n                 let hir_id = tcx.hir.node_to_hir_id(node_id);\n                 return tcx.typeck_tables_of(def_id).node_id_to_type(hir_id);\n@@ -1118,12 +1122,12 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         NodeAnonConst(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n-            NodeTy(&hir::Ty { node: TyArray(_, ref constant), .. }) |\n-            NodeTy(&hir::Ty { node: TyTypeof(ref constant), .. }) |\n-            NodeExpr(&hir::Expr { node: ExprRepeat(_, ref constant), .. })\n+            NodeTy(&hir::Ty { node: hir::TyKind::Array(_, ref constant), .. }) |\n+            NodeTy(&hir::Ty { node: hir::TyKind::Typeof(ref constant), .. }) |\n+            NodeExpr(&hir::Expr { node: ExprKind::Repeat(_, ref constant), .. })\n                 if constant.id == node_id => tcx.types.usize,\n \n-            NodeVariant(&Spanned { node: Variant_ { disr_expr: Some(ref e), .. }, .. })\n+            NodeVariant(&Spanned { node: VariantKind { disr_expr: Some(ref e), .. }, .. })\n                 if e.id == node_id => {\n                     tcx.adt_def(tcx.hir.get_parent_did(node_id))\n                         .repr.discr_type().to_ty(tcx)\n@@ -1165,17 +1169,17 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             AstConv::ty_of_fn(&icx, sig.header.unsafety, sig.header.abi, &sig.decl)\n         }\n \n-        NodeItem(hir::Item { node: ItemFn(decl, header, _, _), .. }) => {\n+        NodeItem(hir::Item { node: ItemKind::Fn(decl, header, _, _), .. }) => {\n             AstConv::ty_of_fn(&icx, header.unsafety, header.abi, decl)\n         }\n \n-        NodeForeignItem(&hir::ForeignItem { node: ForeignItemFn(ref fn_decl, _, _), .. }) => {\n+        NodeForeignItem(&hir::ForeignItem { node: ForeignItemKind::Fn(ref fn_decl, _, _), .. }) => {\n             let abi = tcx.hir.get_foreign_abi(node_id);\n             compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n         NodeStructCtor(&VariantData::Tuple(ref fields, _)) |\n-        NodeVariant(&Spanned { node: hir::Variant_ {\n+        NodeVariant(&Spanned { node: hir::VariantKind {\n             data: VariantData::Tuple(ref fields, _), ..\n         }, .. }) => {\n             let ty = tcx.type_of(tcx.hir.get_parent_did(node_id));\n@@ -1191,7 +1195,7 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ))\n         }\n \n-        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+        NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(..), .. }) => {\n             // Closure signatures are not like other function\n             // signatures and cannot be accessed through `fn_sig`. For\n             // example, a closure signature excludes the `self`\n@@ -1223,7 +1227,7 @@ fn impl_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     match tcx.hir.expect_item(node_id).node {\n-        hir::ItemImpl(.., ref opt_trait_ref, _, _) => {\n+        hir::ItemKind::Impl(.., ref opt_trait_ref, _, _) => {\n             opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 let selfty = tcx.type_of(def_id);\n                 AstConv::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n@@ -1238,7 +1242,7 @@ fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            -> hir::ImplPolarity {\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     match tcx.hir.expect_item(node_id).node {\n-        hir::ItemImpl(_, polarity, ..) => polarity,\n+        hir::ItemKind::Impl(_, polarity, ..) => polarity,\n         ref item => bug!(\"impl_polarity: {:?} not an impl\", item)\n     }\n }\n@@ -1371,23 +1375,23 @@ fn explicit_predicates_of<'a, 'tcx>(\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemImpl(_, _, defaultness, ref generics, ..) => {\n+                ItemKind::Impl(_, _, defaultness, ref generics, ..) => {\n                     if defaultness.is_default() {\n                         is_default_impl_trait = tcx.impl_trait_ref(def_id);\n                     }\n                     generics\n                 }\n-                ItemFn(.., ref generics, _) |\n-                ItemTy(_, ref generics) |\n-                ItemEnum(_, ref generics) |\n-                ItemStruct(_, ref generics) |\n-                ItemUnion(_, ref generics) => generics,\n+                ItemKind::Fn(.., ref generics, _) |\n+                ItemKind::Ty(_, ref generics) |\n+                ItemKind::Enum(_, ref generics) |\n+                ItemKind::Struct(_, ref generics) |\n+                ItemKind::Union(_, ref generics) => generics,\n \n-                ItemTrait(_, _, ref generics, .., ref items) => {\n+                ItemKind::Trait(_, _, ref generics, .., ref items) => {\n                     is_trait = Some((ty::TraitRef::identity(tcx, def_id), items));\n                     generics\n                 }\n-                ItemExistential(ref exist_ty) => {\n+                ItemKind::Existential(ref exist_ty) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     let anon_ty = tcx.mk_anon(def_id, substs);\n \n@@ -1412,9 +1416,9 @@ fn explicit_predicates_of<'a, 'tcx>(\n \n         NodeForeignItem(item) => {\n             match item.node {\n-                ForeignItemStatic(..) => &no_generics,\n-                ForeignItemFn(_, _, ref generics) => generics,\n-                ForeignItemType => &no_generics,\n+                ForeignItemKind::Static(..) => &no_generics,\n+                ForeignItemKind::Fn(_, _, ref generics) => generics,\n+                ForeignItemKind::Type => &no_generics,\n             }\n         }\n \n@@ -1578,7 +1582,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n     // before uses of `U`.  This avoids false ambiguity errors\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n-    if let NodeItem(&Item { node: ItemImpl(..), .. }) = node {\n+    if let NodeItem(&Item { node: ItemKind::Impl(..), .. }) = node {\n         let self_ty = tcx.type_of(def_id);\n         let trait_ref = tcx.impl_trait_ref(def_id);\n         ctp::setup_constraining_predicates(tcx,"}, {"sha": "b7921301957ce294fbd1faeb51805c3877fd672e", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -72,7 +72,7 @@ struct ImplWfCheck<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            hir::ItemImpl(.., ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref impl_item_refs) => {\n                 let impl_def_id = self.tcx.hir.local_def_id(item.id);\n                 enforce_impl_params_are_constrained(self.tcx,\n                                                     impl_def_id,"}, {"sha": "e343fb1a57b1f294b0f3f512b4ccd41761ee8d4b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -189,7 +189,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             match tcx.hir.find(main_id) {\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {\n-                        hir::ItemFn(.., ref generics, _) => {\n+                        hir::ItemKind::Fn(.., ref generics, _) => {\n                             let mut error = false;\n                             if !generics.params.is_empty() {\n                                 let msg = format!(\"`main` function is not allowed to have generic \\\n@@ -261,7 +261,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             match tcx.hir.find(start_id) {\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {\n-                        hir::ItemFn(.., ref generics, _) => {\n+                        hir::ItemKind::Fn(.., ref generics, _) => {\n                             let mut error = false;\n                             if !generics.params.is_empty() {\n                                 struct_span_err!(tcx.sess, generics.span, E0132,"}, {"sha": "e378f1a2dce36e0a8b7dd12fc1273bdfe297f162", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -77,7 +77,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n \n         let mut item_required_predicates = RequiredPredicates::default();\n         match item.node {\n-            hir::ItemUnion(..) | hir::ItemEnum(..) | hir::ItemStruct(..) => {\n+            hir::ItemKind::Union(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Struct(..) => {\n                 let adt_def = self.tcx.adt_def(item_did);\n \n                 // Iterate over all fields in item_did"}, {"sha": "5801a6ada3f2f4e4c1f2d55bc150f06139812367", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -41,7 +41,7 @@ fn inferred_outlives_of<'a, 'tcx>(\n \n     match tcx.hir.get(id) {\n         hir_map::NodeItem(item) => match item.node {\n-            hir::ItemStruct(..) | hir::ItemEnum(..) | hir::ItemUnion(..) => {\n+            hir::ItemKind::Struct(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Union(..) => {\n                 let crate_map = tcx.inferred_outlives_crate(LOCAL_CRATE);\n \n                 let predicates = crate_map"}, {"sha": "9fecf5e73e761ac1cdffaa5ef31f3e757b79bcd0", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -80,16 +80,16 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         match item.node {\n-            hir::ItemStruct(ref struct_def, _) |\n-            hir::ItemUnion(ref struct_def, _) => {\n+            hir::ItemKind::Struct(ref struct_def, _) |\n+            hir::ItemKind::Union(ref struct_def, _) => {\n                 self.visit_node_helper(item.id);\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n                     self.visit_node_helper(struct_def.id());\n                 }\n             }\n \n-            hir::ItemEnum(ref enum_def, _) => {\n+            hir::ItemKind::Enum(ref enum_def, _) => {\n                 self.visit_node_helper(item.id);\n \n                 for variant in &enum_def.variants {\n@@ -99,13 +99,13 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            hir::ItemFn(..) => {\n+            hir::ItemKind::Fn(..) => {\n                 self.visit_node_helper(item.id);\n             }\n \n-            hir::ItemForeignMod(ref foreign_mod) => {\n+            hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    if let hir::ForeignItemFn(..) = foreign_item.node {\n+                    if let hir::ForeignItemKind::Fn(..) = foreign_item.node {\n                         self.visit_node_helper(foreign_item.id);\n                     }\n                 }"}, {"sha": "3d70550c1dfb20603f7aa3aaf5c14220c8549ab5", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -62,10 +62,10 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n     };\n     match tcx.hir.get(id) {\n         hir::map::NodeItem(item) => match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemUnion(..) |\n-            hir::ItemFn(..) => {}\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Fn(..) => {}\n \n             _ => unsupported()\n         },\n@@ -83,7 +83,7 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n         },\n \n         hir::map::NodeForeignItem(item) => match item.node {\n-            hir::ForeignItemFn(..) => {}\n+            hir::ForeignItemKind::Fn(..) => {}\n \n             _ => unsupported()\n         },"}, {"sha": "0aec31609b060dbd88d4d6de291c25853dbfbec6", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -142,16 +142,16 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n                self.tcx.hir.node_to_string(item.id));\n \n         match item.node {\n-            hir::ItemStruct(ref struct_def, _) |\n-            hir::ItemUnion(ref struct_def, _) => {\n+            hir::ItemKind::Struct(ref struct_def, _) |\n+            hir::ItemKind::Union(ref struct_def, _) => {\n                 self.add_inferreds_for_item(item.id);\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n                     self.add_inferreds_for_item(struct_def.id());\n                 }\n             }\n \n-            hir::ItemEnum(ref enum_def, _) => {\n+            hir::ItemKind::Enum(ref enum_def, _) => {\n                 self.add_inferreds_for_item(item.id);\n \n                 for variant in &enum_def.variants {\n@@ -161,13 +161,13 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n                 }\n             }\n \n-            hir::ItemFn(..) => {\n+            hir::ItemKind::Fn(..) => {\n                 self.add_inferreds_for_item(item.id);\n             }\n \n-            hir::ItemForeignMod(ref foreign_mod) => {\n+            hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    if let hir::ForeignItemFn(..) = foreign_item.node {\n+                    if let hir::ForeignItemKind::Fn(..) = foreign_item.node {\n                         self.add_inferreds_for_item(foreign_item.id);\n                     }\n                 }"}, {"sha": "0cdab1348159d9da919f5b7fb16912dc94ac8e88", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,6 +10,7 @@\n \n use rustc::traits::auto_trait as auto;\n use rustc::ty::TypeFoldable;\n+use rustc::hir;\n use std::fmt::Debug;\n \n use super::*;\n@@ -65,9 +66,9 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         let did = self.cx.tcx.hir.local_def_id(id);\n \n         let def_ctor = match *item {\n-            hir::ItemStruct(_, _) => Def::Struct,\n-            hir::ItemUnion(_, _) => Def::Union,\n-            hir::ItemEnum(_, _) => Def::Enum,\n+            hir::ItemKind::Struct(_, _) => Def::Struct,\n+            hir::ItemKind::Union(_, _) => Def::Union,\n+            hir::ItemKind::Enum(_, _) => Def::Enum,\n             _ => panic!(\"Unexpected type {:?} {:?}\", item, id),\n         };\n \n@@ -216,7 +217,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n \n             let ty = hir::Ty {\n                 id: ast::DUMMY_NODE_ID,\n-                node: hir::Ty_::TyPath(hir::QPath::Resolved(None, P(new_path))),\n+                node: hir::TyKind::Path(hir::QPath::Resolved(None, P(new_path))),\n                 span: DUMMY_SP,\n                 hir_id: hir::DUMMY_HIR_ID,\n             };\n@@ -279,7 +280,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         debug!(\"ty_param_to_ty({:?}) {:?}\", param, param.def_id);\n         hir::Ty {\n             id: ast::DUMMY_NODE_ID,\n-            node: hir::Ty_::TyPath(hir::QPath::Resolved(\n+            node: hir::TyKind::Path(hir::QPath::Resolved(\n                 None,\n                 P(hir::Path {\n                     span: DUMMY_SP,"}, {"sha": "2bf1f6e553f3ddab6acc186990d9a5cf18594a1a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -283,10 +283,10 @@ impl Clean<ExternalCrate> for CrateNum {\n             cx.tcx.hir.krate().module.item_ids.iter().filter_map(|&id| {\n                 let item = cx.tcx.hir.expect_item(id.id);\n                 match item.node {\n-                    hir::ItemMod(_) => {\n+                    hir::ItemKind::Mod(_) => {\n                         as_primitive(Def::Mod(cx.tcx.hir.local_def_id(id.id)))\n                     }\n-                    hir::ItemUse(ref path, hir::UseKind::Single)\n+                    hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n                         as_primitive(path.def).map(|(_, prim, attrs)| {\n                             // Pretend the primitive is local.\n@@ -325,10 +325,10 @@ impl Clean<ExternalCrate> for CrateNum {\n             cx.tcx.hir.krate().module.item_ids.iter().filter_map(|&id| {\n                 let item = cx.tcx.hir.expect_item(id.id);\n                 match item.node {\n-                    hir::ItemMod(_) => {\n+                    hir::ItemKind::Mod(_) => {\n                         as_keyword(Def::Mod(cx.tcx.hir.local_def_id(id.id)))\n                     }\n-                    hir::ItemUse(ref path, hir::UseKind::Single)\n+                    hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n                         as_keyword(path.def).map(|(_, prim, attrs)| {\n                             (cx.tcx.hir.local_def_id(id.id), prim, attrs)\n@@ -2586,7 +2586,7 @@ pub struct PolyTrait {\n /// it does not preserve mutability or boxes.\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum Type {\n-    /// structs/enums/traits (most that'd be an hir::TyPath)\n+    /// structs/enums/traits (most that'd be an hir::TyKind::Path)\n     ResolvedPath {\n         path: Path,\n         typarams: Option<Vec<GenericBound>>,\n@@ -2852,9 +2852,9 @@ impl Clean<Type> for hir::Ty {\n     fn clean(&self, cx: &DocContext) -> Type {\n         use rustc::hir::*;\n         match self.node {\n-            TyNever => Never,\n-            TyPtr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n-            TyRptr(ref l, ref m) => {\n+            TyKind::Never => Never,\n+            TyKind::Ptr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n+            TyKind::Rptr(ref l, ref m) => {\n                 let lifetime = if l.is_elided() {\n                     None\n                 } else {\n@@ -2863,8 +2863,8 @@ impl Clean<Type> for hir::Ty {\n                 BorrowedRef {lifetime: lifetime, mutability: m.mutbl.clean(cx),\n                              type_: box m.ty.clean(cx)}\n             }\n-            TySlice(ref ty) => Slice(box ty.clean(cx)),\n-            TyArray(ref ty, ref length) => {\n+            TyKind::Slice(ref ty) => Slice(box ty.clean(cx)),\n+            TyKind::Array(ref ty, ref length) => {\n                 let def_id = cx.tcx.hir.local_def_id(length.id);\n                 let param_env = cx.tcx.param_env(def_id);\n                 let substs = Substs::identity_for_item(cx.tcx, def_id);\n@@ -2878,8 +2878,8 @@ impl Clean<Type> for hir::Ty {\n                 let length = print_const(cx, length);\n                 Array(box ty.clean(cx), length)\n             },\n-            TyTup(ref tys) => Tuple(tys.clean(cx)),\n-            TyPath(hir::QPath::Resolved(None, ref path)) => {\n+            TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n+            TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                 if let Some(new_ty) = cx.ty_substs.borrow().get(&path.def).cloned() {\n                     return new_ty;\n                 }\n@@ -2900,7 +2900,7 @@ impl Clean<Type> for hir::Ty {\n                     }\n                 };\n \n-                if let Some(&hir::ItemTy(ref ty, ref generics)) = alias {\n+                if let Some(&hir::ItemKind::Ty(ref ty, ref generics)) = alias {\n                     let provided_params = &path.segments.last().unwrap();\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n@@ -2965,7 +2965,7 @@ impl Clean<Type> for hir::Ty {\n                 }\n                 resolve_type(cx, path.clean(cx), self.id)\n             }\n-            TyPath(hir::QPath::Resolved(Some(ref qself), ref p)) => {\n+            TyKind::Path(hir::QPath::Resolved(Some(ref qself), ref p)) => {\n                 let mut segments: Vec<_> = p.segments.clone().into();\n                 segments.pop();\n                 let trait_path = hir::Path {\n@@ -2979,7 +2979,7 @@ impl Clean<Type> for hir::Ty {\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n             }\n-            TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n+            TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 let mut def = Def::Err;\n                 let ty = hir_ty_to_ty(cx.tcx, self);\n                 if let ty::TyProjection(proj) = ty.sty {\n@@ -2996,7 +2996,7 @@ impl Clean<Type> for hir::Ty {\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n             }\n-            TyTraitObject(ref bounds, ref lifetime) => {\n+            TyKind::TraitObject(ref bounds, ref lifetime) => {\n                 match bounds[0].clean(cx).trait_ {\n                     ResolvedPath { path, typarams: None, did, is_generic } => {\n                         let mut bounds: Vec<self::GenericBound> = bounds[1..].iter().map(|bound| {\n@@ -3011,9 +3011,9 @@ impl Clean<Type> for hir::Ty {\n                     _ => Infer // shouldn't happen\n                 }\n             }\n-            TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n-            TyInfer | TyErr => Infer,\n-            TyTypeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n+            TyKind::BareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n+            TyKind::Infer | TyKind::Err => Infer,\n+            TyKind::Typeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n         }\n     }\n }\n@@ -4018,7 +4018,7 @@ impl Clean<Vec<Item>> for hir::ForeignMod {\n impl Clean<Item> for hir::ForeignItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n-            hir::ForeignItemFn(ref decl, ref names, ref generics) => {\n+            hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n                     (generics.clean(cx), (&**decl, &names[..]).clean(cx))\n                 });\n@@ -4033,14 +4033,14 @@ impl Clean<Item> for hir::ForeignItem {\n                     },\n                 })\n             }\n-            hir::ForeignItemStatic(ref ty, mutbl) => {\n+            hir::ForeignItemKind::Static(ref ty, mutbl) => {\n                 ForeignStaticItem(Static {\n                     type_: ty.clean(cx),\n                     mutability: if mutbl {Mutable} else {Immutable},\n                     expr: \"\".to_string(),\n                 })\n             }\n-            hir::ForeignItemType => {\n+            hir::ForeignItemKind::Type => {\n                 ForeignTypeItem\n             }\n         };\n@@ -4370,7 +4370,7 @@ pub fn path_to_def_local(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n                 }\n \n                 items = match &item.node {\n-                    &hir::ItemMod(ref m) => m.item_ids.clone(),\n+                    &hir::ItemKind::Mod(ref m) => m.item_ids.clone(),\n                     _ => panic!(\"Unexpected item {:?} in path {:?} path\")\n                 };\n                 break;"}, {"sha": "bd35cc0acda901de793133d5a7aa42bd95dbd792", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -706,7 +706,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n     }\n \n     fn visit_item(&mut self, item: &'hir hir::Item) {\n-        let name = if let hir::ItemImpl(.., ref ty, _) = item.node {\n+        let name = if let hir::ItemKind::Impl(.., ref ty, _) = item.node {\n             self.map.node_to_pretty_string(ty.id)\n         } else {\n             item.name.to_string()"}, {"sha": "875ba111ec002ebae6aaae2f7a33ffdbf537ee82", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -297,7 +297,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         if !self.view_item_stack.insert(def_node_id) { return false }\n \n         let ret = match tcx.hir.get(def_node_id) {\n-            hir_map::NodeItem(&hir::Item { node: hir::ItemMod(ref m), .. }) if glob => {\n+            hir_map::NodeItem(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n                     let i = self.cx.tcx.hir.expect_item(i.id);\n@@ -340,7 +340,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         }\n \n         match item.node {\n-            hir::ItemForeignMod(ref fm) => {\n+            hir::ItemKind::ForeignMod(ref fm) => {\n                 // If inlining we only want to include public functions.\n                 om.foreigns.push(if self.inlining {\n                     hir::ForeignMod {\n@@ -353,8 +353,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             }\n             // If we're inlining, skip private items.\n             _ if self.inlining && !item.vis.node.is_pub() => {}\n-            hir::ItemGlobalAsm(..) => {}\n-            hir::ItemExternCrate(orig_name) => {\n+            hir::ItemKind::GlobalAsm(..) => {}\n+            hir::ItemKind::ExternCrate(orig_name) => {\n                 let def_id = self.cx.tcx.hir.local_def_id(item.id);\n                 om.extern_crates.push(ExternCrate {\n                     cnum: self.cx.tcx.extern_mod_stmt_cnum(def_id)\n@@ -366,8 +366,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     whence: item.span,\n                 })\n             }\n-            hir::ItemUse(_, hir::UseKind::ListStem) => {}\n-            hir::ItemUse(ref path, kind) => {\n+            hir::ItemKind::Use(_, hir::UseKind::ListStem) => {}\n+            hir::ItemKind::Use(ref path, kind) => {\n                 let is_glob = kind == hir::UseKind::Glob;\n \n                 // struct and variant constructors always show up alongside their definitions, we've\n@@ -409,23 +409,23 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     whence: item.span,\n                 });\n             }\n-            hir::ItemMod(ref m) => {\n+            hir::ItemKind::Mod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(item.span,\n                                                      item.attrs.clone(),\n                                                      item.vis.clone(),\n                                                      item.id,\n                                                      m,\n                                                      Some(name)));\n             },\n-            hir::ItemEnum(ref ed, ref gen) =>\n+            hir::ItemKind::Enum(ref ed, ref gen) =>\n                 om.enums.push(self.visit_enum_def(item, name, ed, gen)),\n-            hir::ItemStruct(ref sd, ref gen) =>\n+            hir::ItemKind::Struct(ref sd, ref gen) =>\n                 om.structs.push(self.visit_variant_data(item, name, sd, gen)),\n-            hir::ItemUnion(ref sd, ref gen) =>\n+            hir::ItemKind::Union(ref sd, ref gen) =>\n                 om.unions.push(self.visit_union_data(item, name, sd, gen)),\n-            hir::ItemFn(ref fd, header, ref gen, body) =>\n+            hir::ItemKind::Fn(ref fd, header, ref gen, body) =>\n                 om.fns.push(self.visit_fn(item, name, &**fd, header, gen, body)),\n-            hir::ItemTy(ref ty, ref gen) => {\n+            hir::ItemKind::Ty(ref ty, ref gen) => {\n                 let t = Typedef {\n                     ty: ty.clone(),\n                     gen: gen.clone(),\n@@ -439,7 +439,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 };\n                 om.typedefs.push(t);\n             },\n-            hir::ItemStatic(ref ty, ref mut_, ref exp) => {\n+            hir::ItemKind::Static(ref ty, ref mut_, ref exp) => {\n                 let s = Static {\n                     type_: ty.clone(),\n                     mutability: mut_.clone(),\n@@ -454,7 +454,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 };\n                 om.statics.push(s);\n             },\n-            hir::ItemConst(ref ty, ref exp) => {\n+            hir::ItemKind::Const(ref ty, ref exp) => {\n                 let s = Constant {\n                     type_: ty.clone(),\n                     expr: exp.clone(),\n@@ -468,7 +468,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 };\n                 om.constants.push(s);\n             },\n-            hir::ItemTrait(is_auto, unsafety, ref gen, ref b, ref item_ids) => {\n+            hir::ItemKind::Trait(is_auto, unsafety, ref gen, ref b, ref item_ids) => {\n                 let items = item_ids.iter()\n                                     .map(|ti| self.cx.tcx.hir.trait_item(ti.id).clone())\n                                     .collect();\n@@ -488,11 +488,11 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 };\n                 om.traits.push(t);\n             },\n-            hir::ItemTraitAlias(..) => {\n+            hir::ItemKind::TraitAlias(..) => {\n                 unimplemented!(\"trait objects are not yet implemented\")\n             },\n \n-            hir::ItemImpl(unsafety,\n+            hir::ItemKind::Impl(unsafety,\n                           polarity,\n                           defaultness,\n                           ref gen,\n@@ -523,7 +523,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     om.impls.push(i);\n                 }\n             },\n-            hir::ItemExistential(_) => {\n+            hir::ItemKind::Existential(_) => {\n                 // FIXME(oli-obk): actually generate docs for real existential items\n             }\n         }"}, {"sha": "1241e230b26d60a5bc5d29f15c3f910d0e73541c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -1073,7 +1073,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 return attrs;\n             }\n \n-            if self.cx.ecfg.proc_macro_enabled() {\n+            if self.cx.ecfg.use_extern_macros_enabled() {\n                 attr = find_attr_invoc(&mut attrs);\n             }\n             traits = collect_derives(&mut self.cx, &mut attrs);\n@@ -1096,7 +1096,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 return attrs;\n             }\n \n-            if self.cx.ecfg.proc_macro_enabled() {\n+            if self.cx.ecfg.use_extern_macros_enabled() {\n                 attr = find_attr_invoc(&mut attrs);\n             }\n             attrs\n@@ -1406,7 +1406,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                          foreign_item: ast::ForeignItem) -> SmallVector<ast::ForeignItem> {\n         let (attr, traits, foreign_item) = self.classify_item(foreign_item);\n \n-        let explain = if self.cx.ecfg.proc_macro_enabled() {\n+        let explain = if self.cx.ecfg.use_extern_macros_enabled() {\n             feature_gate::EXPLAIN_PROC_MACROS_IN_EXTERN\n         } else {\n             feature_gate::EXPLAIN_MACROS_IN_EXTERN\n@@ -1592,7 +1592,7 @@ impl<'feat> ExpansionConfig<'feat> {\n         fn enable_trace_macros = trace_macros,\n         fn enable_allow_internal_unstable = allow_internal_unstable,\n         fn enable_custom_derive = custom_derive,\n-        fn proc_macro_enabled = proc_macro,\n+        fn use_extern_macros_enabled = use_extern_macros,\n         fn macros_in_extern_enabled = macros_in_extern,\n         fn proc_macro_mod = proc_macro_mod,\n         fn proc_macro_gen = proc_macro_gen,"}, {"sha": "1a73096505f453a7436c57919bb7c41ad5b3b8d1", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -39,13 +39,6 @@ use symbol::{keywords, Symbol};\n use std::{env, path};\n \n macro_rules! set {\n-    (proc_macro) => {{\n-        fn f(features: &mut Features, span: Span) {\n-            features.declared_lib_features.push((Symbol::intern(\"proc_macro\"), span));\n-            features.proc_macro = true;\n-        }\n-        f as fn(&mut Features, Span)\n-    }};\n     ($field: ident) => {{\n         fn f(features: &mut Features, _: Span) {\n             features.$field = true;\n@@ -303,9 +296,6 @@ declare_features! (\n     // rustc internal\n     (active, abi_unadjusted, \"1.16.0\", None, None),\n \n-    // Procedural macros 2.0.\n-    (active, proc_macro, \"1.16.0\", Some(38356), Some(Edition::Edition2018)),\n-\n     // Declarative macros 2.0 (`macro`).\n     (active, decl_macro, \"1.17.0\", Some(39412), None),\n \n@@ -626,6 +616,8 @@ declare_features! (\n     (accepted, global_allocator, \"1.28.0\", Some(27389), None),\n     // Allows `#[repr(transparent)]` attribute on newtype structs\n     (accepted, repr_transparent, \"1.28.0\", Some(43036), None),\n+    // Defining procedural macros in `proc-macro` crates\n+    (accepted, proc_macro, \"1.29.0\", Some(38356), None),\n );\n \n // If you change this, please modify src/doc/unstable-book as well. You must\n@@ -1033,15 +1025,8 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n \n     (\"windows_subsystem\", Whitelisted, Ungated),\n \n-    (\"proc_macro_attribute\", Normal, Gated(Stability::Unstable,\n-                                           \"proc_macro\",\n-                                           \"attribute proc macros are currently unstable\",\n-                                           cfg_fn!(proc_macro))),\n-\n-    (\"proc_macro\", Normal, Gated(Stability::Unstable,\n-                                 \"proc_macro\",\n-                                 \"function-like proc macros are currently unstable\",\n-                                 cfg_fn!(proc_macro))),\n+    (\"proc_macro_attribute\", Normal, Ungated),\n+    (\"proc_macro\", Normal, Ungated),\n \n     (\"rustc_derive_registrar\", Normal, Gated(Stability::Unstable,\n                                              \"rustc_derive_registrar\",\n@@ -1542,7 +1527,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n         }\n \n-        if self.context.features.proc_macro && attr::is_known(attr) {\n+        if self.context.features.use_extern_macros && attr::is_known(attr) {\n             return\n         }\n \n@@ -1990,7 +1975,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n /// A collector for mutually exclusive and interdependent features and their flag spans.\n #[derive(Default)]\n struct FeatureChecker {\n-    proc_macro: Option<Span>,\n+    use_extern_macros: Option<Span>,\n     custom_attribute: Option<Span>,\n }\n \n@@ -1999,9 +1984,9 @@ impl FeatureChecker {\n     // the branching can be eliminated by modifying `set!()` to set these spans\n     // only for the features that need to be checked for mutual exclusion.\n     fn collect(&mut self, features: &Features, span: Span) {\n-        if features.proc_macro {\n-            // If self.proc_macro is None, set to Some(span)\n-            self.proc_macro = self.proc_macro.or(Some(span));\n+        if features.use_extern_macros {\n+            // If self.use_extern_macros is None, set to Some(span)\n+            self.use_extern_macros = self.use_extern_macros.or(Some(span));\n         }\n \n         if features.custom_attribute {\n@@ -2010,8 +1995,8 @@ impl FeatureChecker {\n     }\n \n     fn check(self, handler: &Handler) {\n-        if let (Some(pm_span), Some(ca_span)) = (self.proc_macro, self.custom_attribute) {\n-            handler.struct_span_err(pm_span, \"Cannot use `#![feature(proc_macro)]` and \\\n+        if let (Some(pm_span), Some(ca_span)) = (self.use_extern_macros, self.custom_attribute) {\n+            handler.struct_span_err(pm_span, \"Cannot use `#![feature(use_extern_macros)]` and \\\n                                               `#![feature(custom_attribute)] at the same time\")\n                 .span_note(ca_span, \"`#![feature(custom_attribute)]` declared here\")\n                 .emit();"}, {"sha": "d56571ee1aca5039ed70f0ebcb992018db5da6a8", "filename": "src/test/compile-fail-fulldeps/issue-15778-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-15778-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-15778-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-15778-fail.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -12,7 +12,7 @@\n // ignore-stage1\n // compile-flags: -D crate-not-okay\n \n-#![feature(plugin, custom_attribute)] //~ ERROR crate is not marked with #![crate_okay]\n+#![feature(plugin)] //~ ERROR crate is not marked with #![crate_okay]\n #![plugin(lint_for_crate)]\n \n pub fn main() { }"}, {"sha": "64af21dbe10dcc8f286716578b9010022ad49b3b", "filename": "src/test/compile-fail-fulldeps/proc-macro/attr-invalid-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattr-invalid-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattr-invalid-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattr-invalid-exprs.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -13,7 +13,7 @@\n \n //! Attributes producing expressions in invalid locations\n \n-#![feature(proc_macro, stmt_expr_attributes, proc_macro_expr)]\n+#![feature(use_extern_macros, stmt_expr_attributes, proc_macro_expr)]\n \n extern crate attr_stmt_expr;\n use attr_stmt_expr::{duplicate, no_output};"}, {"sha": "05b5c918ef0156ae86195c3b1c9caabeeb312aa3", "filename": "src/test/compile-fail-fulldeps/proc-macro/attr-stmt-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattr-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattr-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattr-stmt-expr.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,7 @@\n // aux-build:attr-stmt-expr.rs\n // ignore-stage1\n \n-#![feature(proc_macro, proc_macro_expr)]\n+#![feature(use_extern_macros, proc_macro_expr)]\n \n extern crate attr_stmt_expr;\n use attr_stmt_expr::{expect_let, expect_print_stmt, expect_expr, expect_print_expr};"}, {"sha": "9e7bbb2b8f7ff119c244fd6ad17d5141faf10b81", "filename": "src/test/compile-fail-fulldeps/proc-macro/attribute-with-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,7 @@\n // aux-build:attribute-with-error.rs\n // ignore-stage1\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n \n extern crate attribute_with_error;\n "}, {"sha": "ea66d3c0ef6bbab22cbfb8d918e006bbaaadbe21", "filename": "src/test/compile-fail-fulldeps/proc-macro/attributes-included.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,23 +10,25 @@\n \n // aux-build:attributes-included.rs\n // ignore-stage1\n+// compile-pass\n \n-#![feature(proc_macro, rustc_attrs, proc_macro_path_invoc)]\n+#![feature(use_extern_macros)]\n #![warn(unused)]\n \n extern crate attributes_included;\n \n-#[attributes_included::bar]\n+use attributes_included::*;\n+\n+#[bar]\n #[inline]\n /// doc\n-#[attributes_included::foo]\n+#[foo]\n #[inline]\n /// doc\n fn foo() {\n     let a: i32 = \"foo\"; //~ WARN: unused variable\n }\n \n-#[rustc_error]\n-fn main() { //~ ERROR: compilation successful\n+fn main() {\n     foo()\n }"}, {"sha": "22ddc91399553158fe4f27636a79442f2b7d19f7", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/attr-stmt-expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,6 @@\n \n // no-prefer-dynamic\n \n-#![feature(proc_macro)]\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "679cb7728680ddbf26eefe2887c77cd9f7191a09", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/attr_proc_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr_proc_macro.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,7 @@\n \n // force-host\n // no-prefer-dynamic\n-#![feature(proc_macro)]\n+\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "142840926694416cf168585356242933777d2abb", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/attribute-with-error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattribute-with-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattribute-with-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattribute-with-error.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -12,7 +12,6 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n \n extern crate proc_macro;\n "}, {"sha": "a1f4209662d86b396528ec03de286323f26365e7", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/attributes-included.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,6 @@\n // force-host\n // no-prefer-dynamic\n \n-#![feature(proc_macro)]\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "6484725814a10b75581b8fa23a92e263dc695954", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/bang_proc_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang_proc_macro.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,7 @@\n \n // force-host\n // no-prefer-dynamic\n-#![feature(proc_macro)]\n+\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "3f0a45743671c3f25dce469868d4758c9cc12d4f", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/bang_proc_macro2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang_proc_macro2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang_proc_macro2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang_proc_macro2.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,7 @@\n \n // force-host\n // no-prefer-dynamic\n-#![feature(proc_macro)]\n+\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "5365e8238e99f5793a2ef58d13779b5909b2ffc6", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/issue-41211.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-41211.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-41211.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-41211.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -12,7 +12,6 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n \n extern crate proc_macro;\n use proc_macro::TokenStream;"}, {"sha": "e71b792a48a1434740c2164c4f7a977c501f7736", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/issue_50493.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue_50493.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue_50493.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue_50493.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,6 @@\n // force-host\n // no-prefer-dynamic\n \n-#![feature(proc_macro, proc_macro_lib)]\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "4d89384137b8006c5d38a9eb20b8c3fd80ed627f", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/more-gates.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fmore-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fmore-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fmore-gates.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,6 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n \n extern crate proc_macro;\n "}, {"sha": "0f8fd5b5709c7538ade2de3aa15e2146dc307bf9", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/proc-macro-gates.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fproc-macro-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fproc-macro-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fproc-macro-gates.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -12,7 +12,6 @@\n // force-host\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n \n extern crate proc_macro;\n "}, {"sha": "581c7cb15a59c666498c4dbbdc60ceb70e839ceb", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/test-macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,6 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n \n extern crate proc_macro;\n "}, {"sha": "eeede4b8aa13c9ed7826b35fe3ceb63f7ca46c27", "filename": "src/test/compile-fail-fulldeps/proc-macro/feature-gate-proc_macro.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6af3e2d707230cf4d0879dc81ceccc83e72fed25/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ffeature-gate-proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af3e2d707230cf4d0879dc81ceccc83e72fed25/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ffeature-gate-proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ffeature-gate-proc_macro.rs?ref=6af3e2d707230cf4d0879dc81ceccc83e72fed25", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// aux-build:attr_proc_macro.rs\n-#![feature(use_extern_macros)]\n-\n-extern crate attr_proc_macro;\n-use attr_proc_macro::attr_proc_macro;\n-\n-#[attr_proc_macro]\n-//~^ ERROR: attribute procedural macros are experimental\n-struct Foo;\n-\n-fn main() {\n-    let _ = Foo;\n-}"}, {"sha": "8fced7d8c70da134a6a9d9988ec86be2e83cc477", "filename": "src/test/compile-fail-fulldeps/proc-macro/issue-41211.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-41211.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-41211.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-41211.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -13,7 +13,7 @@\n // FIXME: https://github.com/rust-lang/rust/issues/41430\n // This is a temporary regression test for the ICE reported in #41211\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n #![emit_unchanged]\n //~^ ERROR: cannot find attribute macro `emit_unchanged` in this scope\n extern crate issue_41211;"}, {"sha": "bb7f341f9678632f2d2004e02d8f003c678b075c", "filename": "src/test/compile-fail-fulldeps/proc-macro/macro-use-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-attr.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // aux-build:attr_proc_macro.rs\n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n \n #[macro_use] extern crate attr_proc_macro;\n "}, {"sha": "9a35dc0edc4484b66d4bfb3550539b4476f0660c", "filename": "src/test/compile-fail-fulldeps/proc-macro/macros-in-extern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacros-in-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacros-in-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacros-in-extern.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -12,7 +12,7 @@\n // ignore-stage1\n // ignore-wasm32\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n \n extern crate test_macros;\n "}, {"sha": "ff9f1705c5b84765d5878fac54ef519ded8d7056", "filename": "src/test/compile-fail-fulldeps/proc-macro/more-gates.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmore-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmore-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmore-gates.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:more-gates.rs\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n \n extern crate more_gates as foo;\n "}, {"sha": "9ed665b6e68f69dcdffb3cc05931384ff5205bf8", "filename": "src/test/compile-fail-fulldeps/proc-macro/proc-macro-custom-attr-mutex.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-custom-attr-mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-custom-attr-mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-custom-attr-mutex.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -9,9 +9,10 @@\n // except according to those terms.\n \n // aux-build:attr_proc_macro.rs\n+// ignore-tidy-linelength\n \n-#![feature(proc_macro, custom_attribute)]\n-//~^ ERROR Cannot use `#![feature(proc_macro)]` and `#![feature(custom_attribute)] at the same time\n+#![feature(use_extern_macros, custom_attribute)]\n+//~^ ERROR Cannot use `#![feature(use_extern_macros)]` and `#![feature(custom_attribute)] at the same time\n \n extern crate attr_proc_macro;\n use attr_proc_macro::attr_proc_macro;"}, {"sha": "51b1bfca294e48c05678628c10354ea30e96335c", "filename": "src/test/compile-fail-fulldeps/proc-macro/proc-macro-gates.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-gates.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -16,7 +16,7 @@\n // gate-test-proc_macro_mod\n // gate-test-proc_macro_gen\n \n-#![feature(proc_macro, stmt_expr_attributes)]\n+#![feature(use_extern_macros, stmt_expr_attributes)]\n \n extern crate proc_macro_gates as foo;\n "}, {"sha": "30752e8ddb1086018331e639f246697998710027", "filename": "src/test/compile-fail/borrowck/two-phase-nonrecv-autoref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -52,7 +52,7 @@ fn deref_coercion(x: &mut u32) {\n // - [x] coerce_unsized e.g. `&[T; n]`, `&mut [T; n] -> &[T]`,\n //                      `&mut [T; n] -> &mut [T]`, `&Concrete -> &Trait`\n // - [x] Method Call Receivers (the case we want to support!)\n-// - [x] ExprIndex and ExprUnary Deref; only need to handle coerce_index_op\n+// - [x] ExprKind::Index and ExprKind::Unary Deref; only need to handle coerce_index_op\n // - [x] overloaded_binops\n \n fn overloaded_call_traits() {"}, {"sha": "fc4f3d1fb53de5a13c7cf49ac33b08385798eff9", "filename": "src/test/compile-fail/issue-26548.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: cycle detected when computing layout of\n-// note-pattern: ...which requires computing layout of\n-// note-pattern: ...which again requires computing layout of\n+//~^^^^^^^^^^ ERROR cycle detected when computing layout of\n+//~| NOTE ...which requires computing layout of\n+//~| NOTE ...which again requires computing layout of\n+//~| NOTE cycle used when compile_codegen_unit\n \n trait Mirror { type It: ?Sized; }\n impl<T: ?Sized> Mirror for T { type It = Self; }"}, {"sha": "7eafd834c49136eaefa9693b710579710638a2b4", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -35,7 +35,7 @@ use rustc_plugin::Registry;\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_syntax_extension(\n-        Symbol::intern(\"derive_TotalSum\"),\n+        Symbol::intern(\"rustc_derive_TotalSum\"),\n         MultiDecorator(box expand));\n }\n "}, {"sha": "545eabe00ff2e339945d9f46efaf01e093745b76", "filename": "src/test/run-pass-fulldeps/auxiliary/hello_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,7 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(use_extern_macros, proc_macro_non_items, proc_macro_quote)]\n \n extern crate proc_macro;\n "}, {"sha": "fa208e14b7d1c632afb41ef6b26eba6c7eba5de5", "filename": "src/test/run-pass-fulldeps/auxiliary/lint_for_crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_for_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_for_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_for_crate.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -57,19 +57,19 @@ declare_lint!(CRATE_NOT_GREEN, Warn, \"crate not marked with #![crate_green]\");\n fake_lint_pass! {\n     PassOkay,\n     lint_array!(CRATE_NOT_OKAY), // Single lint\n-    \"crate_okay\"\n+    \"rustc_crate_okay\"\n }\n \n fake_lint_pass! {\n     PassRedBlue,\n     lint_array!(CRATE_NOT_RED, CRATE_NOT_BLUE), // Multiple lints\n-    \"crate_red\", \"crate_blue\"\n+    \"rustc_crate_red\", \"rustc_crate_blue\"\n }\n \n fake_lint_pass! {\n     PassGreyGreen,\n     lint_array!(CRATE_NOT_GREY, CRATE_NOT_GREEN, ), // Trailing comma\n-    \"crate_grey\", \"crate_green\"\n+    \"rustc_crate_grey\", \"rustc_crate_green\"\n }\n \n #[plugin_registrar]"}, {"sha": "64fdd7f9a95a6c0895cf1ab4a4df1c7829d04f86", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -37,13 +37,13 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"make_a_1\", expand_make_a_1);\n     reg.register_macro(\"identity\", expand_identity);\n     reg.register_syntax_extension(\n-        Symbol::intern(\"into_multi_foo\"),\n+        Symbol::intern(\"rustc_into_multi_foo\"),\n         MultiModifier(Box::new(expand_into_foo_multi)));\n     reg.register_syntax_extension(\n-        Symbol::intern(\"duplicate\"),\n+        Symbol::intern(\"rustc_duplicate\"),\n         MultiDecorator(Box::new(expand_duplicate)));\n     reg.register_syntax_extension(\n-        Symbol::intern(\"caller\"),\n+        Symbol::intern(\"rustc_caller\"),\n         MultiDecorator(Box::new(expand_caller)));\n }\n "}, {"sha": "e088f5e4262631442e94f4422e91e15179c9ed2a", "filename": "src/test/run-pass-fulldeps/derive-totalsum-attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum-attr.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,7 @@\n // aux-build:custom_derive_plugin_attr.rs\n // ignore-stage1\n \n-#![feature(plugin, custom_derive, custom_attribute)]\n+#![feature(plugin, custom_derive, rustc_attrs)]\n #![plugin(custom_derive_plugin_attr)]\n \n trait TotalSum {\n@@ -32,7 +32,7 @@ impl TotalSum for Seven {\n     }\n }\n \n-#[derive(TotalSum)]\n+#[rustc_derive_TotalSum]\n struct Foo {\n     seven: Seven,\n     bar: Bar,\n@@ -41,7 +41,7 @@ struct Foo {\n     nan: NaN,\n }\n \n-#[derive(TotalSum)]\n+#[rustc_derive_TotalSum]\n struct Bar {\n     quux: isize,\n     bleh: isize,"}, {"sha": "6fcf0a0450c8488373d8c7749cfda5b4e72275ea", "filename": "src/test/run-pass-fulldeps/issue-15778-pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15778-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15778-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15778-pass.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -12,12 +12,12 @@\n // ignore-stage1\n // compile-flags: -D crate-not-okay\n \n-#![feature(plugin, custom_attribute)]\n+#![feature(plugin, rustc_attrs)]\n #![plugin(lint_for_crate)]\n-#![crate_okay]\n-#![crate_blue]\n-#![crate_red]\n-#![crate_grey]\n-#![crate_green]\n+#![rustc_crate_okay]\n+#![rustc_crate_blue]\n+#![rustc_crate_red]\n+#![rustc_crate_grey]\n+#![rustc_crate_green]\n \n pub fn main() { }"}, {"sha": "ce552d3ab7dd67ff8ff04d1cef1db678c121a57d", "filename": "src/test/run-pass-fulldeps/macro-crate-multi-decorator-literals.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator-literals.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,7 @@\n // aux-build:macro_crate_test.rs\n // ignore-stage1\n \n-#![feature(plugin, custom_attribute, attr_literals)]\n+#![feature(plugin, rustc_attrs, attr_literals)]\n #![plugin(macro_crate_test)]\n \n #[macro_use]\n@@ -30,16 +30,16 @@ extern crate macro_crate_test;\n // This results in a function named `simple` that calls `f(1, \"hello\", 3.14)`.\n // As a result, the expression `simple()` evaluates to `(1, \"helllo\", 3.14)`.\n \n-#[caller(simple, 1, \"hello\", 3.14)]\n-#[caller(simple1, 2, \"bye\", 6.28)]\n-#[caller(simple2, 3, \"hi\", 1.01)]\n+#[rustc_caller(simple, 1, \"hello\", 3.14)]\n+#[rustc_caller(simple1, 2, \"bye\", 6.28)]\n+#[rustc_caller(simple2, 3, \"hi\", 1.01)]\n fn f(num: isize, string: &'static str, float: f32) -> (isize, &'static str, f32) {\n     (num, string, float)\n }\n \n-#[caller(complex, true, 10)]\n-#[caller(complex1, false, 15)]\n-#[caller(complex2, true, 20)]\n+#[rustc_caller(complex, true, 10)]\n+#[rustc_caller(complex1, false, 15)]\n+#[rustc_caller(complex2, true, 20)]\n fn g(emit: bool, num: i32) -> Option<i32> {\n     match emit {\n         true => Some(num),"}, {"sha": "9245e85edd6ddf085351f180bea6765a2c0f4063", "filename": "src/test/run-pass-fulldeps/macro-crate-multi-decorator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,7 @@\n // aux-build:macro_crate_test.rs\n // ignore-stage1\n \n-#![feature(plugin, custom_attribute)]\n+#![feature(plugin, rustc_attrs)]\n #![plugin(macro_crate_test)]\n \n #[macro_use]\n@@ -20,27 +20,27 @@ extern crate macro_crate_test;\n \n // The duplicate macro will create a copy of the item with the given identifier.\n \n-#[duplicate(MyCopy)]\n+#[rustc_duplicate(MyCopy)]\n struct MyStruct {\n     number: i32\n }\n \n trait TestTrait {\n-    #[duplicate(TestType2)]\n+    #[rustc_duplicate(TestType2)]\n     type TestType;\n \n-    #[duplicate(required_fn2)]\n+    #[rustc_duplicate(required_fn2)]\n     fn required_fn(&self);\n \n-    #[duplicate(provided_fn2)]\n+    #[rustc_duplicate(provided_fn2)]\n     fn provided_fn(&self) { }\n }\n \n impl TestTrait for MyStruct {\n-    #[duplicate(TestType2)]\n+    #[rustc_duplicate(TestType2)]\n     type TestType = f64;\n \n-    #[duplicate(required_fn2)]\n+    #[rustc_duplicate(required_fn2)]\n     fn required_fn(&self) { }\n }\n "}, {"sha": "06f78b10e5e93071231b19f591f75f08a3bdd9dc", "filename": "src/test/run-pass-fulldeps/macro-crate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,26 +11,26 @@\n // aux-build:macro_crate_test.rs\n // ignore-stage1\n \n-#![feature(plugin, custom_attribute)]\n+#![feature(plugin, rustc_attrs)]\n #![plugin(macro_crate_test)]\n \n #[macro_use] #[no_link]\n extern crate macro_crate_test;\n \n #[derive(PartialEq, Clone, Debug)]\n-#[into_multi_foo]\n+#[rustc_into_multi_foo]\n fn foo() -> AnotherFakeTypeThatHadBetterGoAway {}\n \n // Check that the `#[into_multi_foo]`-generated `foo2` is configured away\n fn foo2() {}\n \n trait Qux {\n-    #[into_multi_foo]\n+    #[rustc_into_multi_foo]\n     fn bar();\n }\n \n impl Qux for i32 {\n-    #[into_multi_foo]\n+    #[rustc_into_multi_foo]\n     fn bar() {}\n }\n "}, {"sha": "26522396d6b331b7e72f123fc20545362e876d80", "filename": "src/test/run-pass-fulldeps/proc-macro/attr-args.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-args.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -12,14 +12,13 @@\n // ignore-stage1\n \n #![allow(warnings)]\n-#![feature(proc_macro, proc_macro_path_invoc)]\n+#![feature(use_extern_macros)]\n \n extern crate attr_args;\n-use attr_args::attr_with_args;\n+use attr_args::{attr_with_args, identity};\n \n #[attr_with_args(text = \"Hello, world!\")]\n fn foo() {}\n \n-#[::attr_args::identity(\n-  fn main() { assert_eq!(foo(), \"Hello, world!\"); })]\n+#[identity(fn main() { assert_eq!(foo(), \"Hello, world!\"); })]\n struct Dummy;"}, {"sha": "4ee30b8252baa12a283501f7561d8f6e136a10c7", "filename": "src/test/run-pass-fulldeps/proc-macro/attr-cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-cfg.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -12,7 +12,7 @@\n // ignore-stage1\n // revisions: foo bar\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n \n extern crate attr_cfg;\n use attr_cfg::attr_cfg;"}, {"sha": "256096f118aa40b5e6e5f32d2efc9c02cc8e2b5e", "filename": "src/test/run-pass-fulldeps/proc-macro/attr-on-trait.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-on-trait.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,12 +11,14 @@\n // aux-build:attr-on-trait.rs\n // ignore-stage1\n \n-#![feature(proc_macro, proc_macro_path_invoc)]\n+#![feature(use_extern_macros)]\n \n extern crate attr_on_trait;\n \n+use attr_on_trait::foo;\n+\n trait Foo {\n-    #[attr_on_trait::foo]\n+    #[foo]\n     fn foo() {}\n }\n "}, {"sha": "021b10e033fe9b374fc56171292cf0b83280ffb9", "filename": "src/test/run-pass-fulldeps/proc-macro/attr-stmt-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-stmt-expr.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,7 @@\n // aux-build:attr-stmt-expr.rs\n // ignore-stage1\n \n-#![feature(proc_macro, stmt_expr_attributes, proc_macro_stmt, proc_macro_expr)]\n+#![feature(use_extern_macros, stmt_expr_attributes, proc_macro_stmt, proc_macro_expr)]\n \n extern crate attr_stmt_expr;\n use attr_stmt_expr::{expect_let, expect_print_stmt, expect_expr, expect_print_expr,"}, {"sha": "655bfa3ff6312b421c245d27462f3022b43fedb8", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/attr-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-args.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // no-prefer-dynamic\n-#![feature(proc_macro)]\n+\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "f9037aa8bf94d5d4043682d6198f9dd7b289c65a", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/attr-cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-cfg.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // no-prefer-dynamic\n-#![feature(proc_macro)]\n+\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "5e5c775b1ffbdbad68dc478b7ddc1538943fc78e", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/attr-on-trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-on-trait.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,6 @@\n \n // no-prefer-dynamic\n \n-#![feature(proc_macro)]\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "4d5e22b4eb6c26a9d5914d9615552876d119b96f", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/attr-stmt-expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,6 @@\n \n // no-prefer-dynamic\n \n-#![feature(proc_macro)]\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "8b7c6cd10b8604337a745b830d0e61caf87debad", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/bang-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fbang-macro.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // no-prefer-dynamic\n-#![feature(proc_macro)]\n+\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "65eb8f4bec2d026d9159b1638f827df9643b25a0", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/call-site.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcall-site.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcall-site.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcall-site.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,6 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n \n extern crate proc_macro;\n use proc_macro::*;"}, {"sha": "c6bcc37ac4a5480a0a0bd003c33bf538cf191b79", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/count_compound_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcount_compound_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcount_compound_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcount_compound_ops.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,7 @@\n \n // no-prefer-dynamic\n \n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(proc_macro_non_items, proc_macro_quote, use_extern_macros)]\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "978de27b70aad52140e781908b1d6a264b25f98d", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/gen-lifetime-token.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fgen-lifetime-token.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fgen-lifetime-token.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fgen-lifetime-token.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,6 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n \n extern crate proc_macro;\n "}, {"sha": "8f95bdd9c3919e57da49dac4d37e218430357784", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/hygiene_example_codegen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fhygiene_example_codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fhygiene_example_codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fhygiene_example_codegen.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,7 @@\n \n // no-prefer-dynamic\n \n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(use_extern_macros, proc_macro_quote, proc_macro_non_items)]\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro as proc_macro_renamed; // This does not break `quote!`"}, {"sha": "56c163b8ce3d595cc473476fcca860c77d17ee54", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -7,6 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n #![feature(box_syntax, plugin, plugin_registrar, rustc_private)]\n #![feature(macro_vis_matcher)]\n #![feature(macro_at_most_once_rep)]"}, {"sha": "906caceb8696be4db89c3d0098671895a7e16271", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/issue-42708.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-42708.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-42708.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-42708.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,6 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n \n extern crate proc_macro;\n "}, {"sha": "6de17522fc9a748219c98d8ef4e066c77f28c682", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/issue-50061.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-50061.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-50061.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-50061.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,6 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n \n extern crate proc_macro;\n use proc_macro::TokenStream;"}, {"sha": "0ee26b6a1b9eeef7440d9aab3dcbfe95eab7bfe7", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/lifetimes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Flifetimes.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,6 @@\n \n // no-prefer-dynamic\n \n-#![feature(proc_macro)]\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "498c6811d9c20287ca8111f7199f52cf00b2b828", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/modify-ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fmodify-ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fmodify-ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fmodify-ast.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,6 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n \n extern crate proc_macro;\n "}, {"sha": "fd639696991f66f75abbaa192187b8ff1b06fe8e", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/negative-token.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fnegative-token.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fnegative-token.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fnegative-token.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,6 @@\n \n // no-prefer-dynamic\n \n-#![feature(proc_macro)]\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "e00a4d89e8d62ede5f7d4b097558e0b62bd63048", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/not-joint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fnot-joint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fnot-joint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fnot-joint.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,6 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n \n extern crate proc_macro;\n "}, {"sha": "8e2c5c0a088d29b1c09eebf3887a39c8670f13c3", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/span-api-tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fspan-api-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fspan-api-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fspan-api-tests.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -12,7 +12,7 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n+#![feature(proc_macro_span)]\n \n extern crate proc_macro;\n "}, {"sha": "581c7cb15a59c666498c4dbbdc60ceb70e839ceb", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/test-macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,6 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n \n extern crate proc_macro;\n "}, {"sha": "505994f66e7e553c339ccfc49e7a59b7b3064b01", "filename": "src/test/run-pass-fulldeps/proc-macro/call-site.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcall-site.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcall-site.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcall-site.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,7 @@\n // aux-build:call-site.rs\n // ignore-stage1\n \n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(proc_macro_non_items, use_extern_macros)]\n \n extern crate call_site;\n use call_site::*;"}, {"sha": "35d5084d9f650a3aa3a9bc8d09596be450f2a62d", "filename": "src/test/run-pass-fulldeps/proc-macro/derive-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,7 @@\n // aux-build:derive-b.rs\n // ignore-stage1\n \n-#![feature(proc_macro, proc_macro_path_invoc)]\n+#![feature(use_extern_macros, proc_macro_path_invoc)]\n \n extern crate derive_b;\n "}, {"sha": "c8a9bea3631cb582adc2c565e2a3cb0fa7cb951b", "filename": "src/test/run-pass-fulldeps/proc-macro/gen-lifetime-token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fgen-lifetime-token.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fgen-lifetime-token.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fgen-lifetime-token.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:gen-lifetime-token.rs\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n \n extern crate gen_lifetime_token as bar;\n "}, {"sha": "df4a1d8994b5481b7c219f726026d71b12992345", "filename": "src/test/run-pass-fulldeps/proc-macro/issue-42708.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-42708.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-42708.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-42708.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,7 @@\n // aux-build:issue-42708.rs\n // ignore-stage1\n \n-#![feature(decl_macro, proc_macro, proc_macro_path_invoc)]\n+#![feature(decl_macro, use_extern_macros, proc_macro_path_invoc)]\n #![allow(unused)]\n \n extern crate issue_42708;"}, {"sha": "15dff94c88c180b1e11e468ec3dada2c9c9aefff", "filename": "src/test/run-pass-fulldeps/proc-macro/issue-50061.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-50061.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-50061.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fissue-50061.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,7 @@\n // aux-build:issue-50061.rs\n // ignore-stage1\n \n-#![feature(proc_macro, proc_macro_path_invoc, decl_macro)]\n+#![feature(use_extern_macros, proc_macro_path_invoc, decl_macro)]\n \n extern crate issue_50061;\n "}, {"sha": "cfe0ce19a460627f04c34c747e5367d360311573", "filename": "src/test/run-pass-fulldeps/proc-macro/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Flifetimes.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,7 @@\n // aux-build:lifetimes.rs\n // ignore-stage1\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n \n extern crate lifetimes;\n use lifetimes::*;"}, {"sha": "e5f8c844b6b70cd4bac6b79b589cf1263533569d", "filename": "src/test/run-pass-fulldeps/proc-macro/macros-in-extern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fmacros-in-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fmacros-in-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fmacros-in-extern.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -12,7 +12,7 @@\n // ignore-stage1\n // ignore-wasm32\n \n-#![feature(proc_macro, macros_in_extern)]\n+#![feature(use_extern_macros, macros_in_extern)]\n \n extern crate test_macros;\n "}, {"sha": "0b584fdd44d478c8194d489a56e4f1b4f254bcf0", "filename": "src/test/run-pass-fulldeps/proc-macro/modify-ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fmodify-ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fmodify-ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fmodify-ast.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:modify-ast.rs\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n \n extern crate modify_ast;\n "}, {"sha": "8a59d57a938aaa8438bb77ece29155dc3f8aa173", "filename": "src/test/run-pass-fulldeps/proc-macro/not-joint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fnot-joint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fnot-joint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fnot-joint.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:not-joint.rs\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n \n extern crate not_joint as bar;\n use bar::{tokens, nothing};"}, {"sha": "46b62d7e34a5284e5b7b1914278ac1024914736c", "filename": "src/test/run-pass-fulldeps/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Frun-pass-fulldeps%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc_macro.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -12,7 +12,7 @@\n // ignore-stage1\n // ignore-cross-compile\n \n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(use_extern_macros, proc_macro_non_items)]\n \n extern crate proc_macro_def;\n "}, {"sha": "cc899fa610d13fa2afb6a5a19b014a2b81e4471c", "filename": "src/test/ui-fulldeps/auxiliary/invalid-punct-ident.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Finvalid-punct-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Finvalid-punct-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Finvalid-punct-ident.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,8 +11,8 @@\n // force-host\n // no-prefer-dynamic\n \n-#![feature(proc_macro)]\n #![crate_type = \"proc-macro\"]\n+#![feature(proc_macro_raw_ident)]\n \n extern crate proc_macro;\n use proc_macro::*;"}, {"sha": "3200e8fb2b1625b8245353317c09b29a877852e3", "filename": "src/test/ui-fulldeps/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flifetimes.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:lifetimes.rs\n \n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(use_extern_macros, proc_macro_non_items)]\n \n extern crate lifetimes;\n "}, {"sha": "be1777f3ebd05aa1ced6509e07eaf477390dd817", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/macro-brackets.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fmacro-brackets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fmacro-brackets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fmacro-brackets.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -11,7 +11,6 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n-#![feature(proc_macro)]\n \n extern crate proc_macro;\n use proc_macro::*;"}, {"sha": "f5590405e61e3a98539ebf88cf3ecb68e8428fd6", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/parent-source-spans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fparent-source-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fparent-source-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fparent-source-spans.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n // no-prefer-dynamic\n-#![feature(proc_macro)]\n+\n+#![feature(proc_macro_diagnostic, proc_macro_span)]\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "70151278947ddddf464fb87b6eb7b1ab8381d3b5", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/three-equals.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n \n // no-prefer-dynamic\n-#![feature(proc_macro)]\n+\n #![crate_type = \"proc-macro\"]\n+#![feature(proc_macro_diagnostic, proc_macro_span)]\n \n extern crate proc_macro;\n "}, {"sha": "168df906ad6982707fca4485c07070e544c1c6ea", "filename": "src/test/ui-fulldeps/proc-macro/generate-mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -12,7 +12,7 @@\n \n // aux-build:generate-mod.rs\n \n-#![feature(proc_macro, proc_macro_gen, proc_macro_path_invoc)]\n+#![feature(use_extern_macros, proc_macro_gen, proc_macro_path_invoc)]\n \n extern crate generate_mod;\n "}, {"sha": "1c16faa9986a5df926e5986057d5f439b36ee393", "filename": "src/test/ui-fulldeps/proc-macro/macro-brackets.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-brackets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-brackets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-brackets.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:macro-brackets.rs\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n \n extern crate macro_brackets as bar;\n use bar::doit;"}, {"sha": "9cfd486606abfaa766bcfb007be43d8c1a11d6ca", "filename": "src/test/ui-fulldeps/proc-macro/macro-namespace-reserved-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-namespace-reserved-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-namespace-reserved-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-namespace-reserved-2.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -10,7 +10,7 @@\n \n // no-prefer-dynamic\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;"}, {"sha": "df9b263534f605804276b984876b9bea5f0be208", "filename": "src/test/ui-fulldeps/resolve-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fresolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui-fulldeps%2Fresolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fresolve-error.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -13,7 +13,7 @@\n // aux-build:attr_proc_macro.rs\n // aux-build:bang_proc_macro.rs\n \n-#![feature(proc_macro)]\n+#![feature(use_extern_macros)]\n \n #[macro_use]\n extern crate derive_foo;"}, {"sha": "c968844ae21ac87c7c8d08ba8822c02ad5bd11ff", "filename": "src/test/ui/issue-10176.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10176.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10176.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10176.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-10176.rs"}, {"sha": "02e0b899b3f88122ae2be74ebc12a326e623611f", "filename": "src/test/ui/issue-10176.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10176.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10176.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10176.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-10176.rs:12:5\n+   |\n+LL | fn f() -> isize {\n+   |           ----- expected `isize` because of return type\n+LL |     (return 1, return 2)\n+   |     ^^^^^^^^^^^^^^^^^^^^ expected isize, found tuple\n+   |\n+   = note: expected type `isize`\n+              found type `(!, !)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "8c58ef6261e10485fa20e7265f475b7d72c4d1a0", "filename": "src/test/ui/issue-10200.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10200.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10200.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10200.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-10200.rs"}, {"sha": "4eb0782762857d15fdb5f6023cb18f0cd07467f7", "filename": "src/test/ui/issue-10200.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10200.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10200.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10200.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,9 @@\n+error[E0532]: expected tuple struct/variant, found function `foo`\n+  --> $DIR/issue-10200.rs:16:9\n+   |\n+LL |         foo(x) //~ ERROR expected tuple struct/variant, found function `foo`\n+   |         ^^^ did you mean `Foo`?\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0532`."}, {"sha": "1358fe010b443c5d8a607c5a908973e41adc9cc7", "filename": "src/test/ui/issue-10291.nll.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10291.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10291.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10291.nll.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,14 @@\n+warning: not reporting region error due to nll\n+  --> $DIR/issue-10291.rs:13:9\n+   |\n+LL |         x //~ ERROR E0312\n+   |         ^\n+\n+error: unsatisfied lifetime constraints\n+  --> $DIR/issue-10291.rs:12:5\n+   |\n+LL |     drop::<Box<for<'z> FnMut(&'z isize) -> &'z isize>>(Box::new(|z| {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ free region requires that `'x` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "d4e7dc7e9a35dfc705e0e5bdf36ee8159bcd12e4", "filename": "src/test/ui/issue-10291.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10291.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10291.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10291.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-10291.rs"}, {"sha": "af5929782f6278d9d60cfd9a42ad60b00bdc56be", "filename": "src/test/ui/issue-10291.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10291.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10291.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10291.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,23 @@\n+error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+  --> $DIR/issue-10291.rs:13:9\n+   |\n+LL |         x //~ ERROR E0312\n+   |         ^\n+   |\n+note: ...the reference is valid for the anonymous lifetime #2 defined on the body at 12:65...\n+  --> $DIR/issue-10291.rs:12:65\n+   |\n+LL |       drop::<Box<for<'z> FnMut(&'z isize) -> &'z isize>>(Box::new(|z| {\n+   |  _________________________________________________________________^\n+LL | |         x //~ ERROR E0312\n+LL | |     }));\n+   | |_____^\n+note: ...but the borrowed content is only valid for the lifetime 'x as defined on the function body at 11:9\n+  --> $DIR/issue-10291.rs:11:9\n+   |\n+LL | fn test<'x>(x: &'x isize) {\n+   |         ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0312`."}, {"sha": "d13e843b94b56334fcc3d37cb5c469158d081952", "filename": "src/test/ui/issue-10398.nll.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10398.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10398.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10398.nll.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,13 @@\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/issue-10398.rs:17:14\n+   |\n+LL |         let _a = x;\n+   |                  - value moved here\n+LL |         drop(x);\n+   |              ^ value used here after move\n+   |\n+   = note: move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "08e8effc626f5bd68b7e6bda91e97b9fb3fa3aa5", "filename": "src/test/ui/issue-10398.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10398.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10398.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10398.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-10398.rs"}, {"sha": "e3b816df3f4b666dd89a7dd852ca76d0a4286b15", "filename": "src/test/ui/issue-10398.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10398.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10398.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10398.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,13 @@\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/issue-10398.rs:17:14\n+   |\n+LL |         let _a = x;\n+   |             -- value moved here\n+LL |         drop(x);\n+   |              ^ value used here after move\n+   |\n+   = note: move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "e36193aee25c0471b3fbc98ad0d6ddf0002818ab", "filename": "src/test/ui/issue-10401.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10401.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-10401.rs"}, {"sha": "8c91c11a67c332125690ffaaa9cdd3e5e8b0df53", "filename": "src/test/ui/issue-10401.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10401.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,16 @@\n+error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n+  --> $DIR/issue-10401.rs:13:5\n+   |\n+LL |     a += { \"b\" };\n+   |     -^^^^^^^^^^^\n+   |     |\n+   |     cannot use `+=` on type `&str`\n+   |     `+` can't be used to concatenate two `&str` strings\n+help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n+   |\n+LL |     a.to_owned() += { \"b\" };\n+   |     ^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0368`."}, {"sha": "ee553730a35bc4ebca62138b8664b677394e1c36", "filename": "src/test/ui/issue-10412.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10412.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-10412.rs"}, {"sha": "7f2f2dbf5091a2ea1f2a0fc5f061cbed20bf023d", "filename": "src/test/ui/issue-10412.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10412.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10412.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10412.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,51 @@\n+error: lifetimes cannot use keyword names\n+  --> $DIR/issue-10412.rs:11:20\n+   |\n+LL | trait Serializable<'self, T> { //~ ERROR lifetimes cannot use keyword names\n+   |                    ^^^^^\n+\n+error: lifetimes cannot use keyword names\n+  --> $DIR/issue-10412.rs:12:25\n+   |\n+LL |     fn serialize(val : &'self T) -> Vec<u8>; //~ ERROR lifetimes cannot use keyword names\n+   |                         ^^^^^\n+\n+error: lifetimes cannot use keyword names\n+  --> $DIR/issue-10412.rs:13:38\n+   |\n+LL |     fn deserialize(repr : &[u8]) -> &'self T; //~ ERROR lifetimes cannot use keyword names\n+   |                                      ^^^^^\n+\n+error: lifetimes cannot use keyword names\n+  --> $DIR/issue-10412.rs:16:6\n+   |\n+LL | impl<'self> Serializable<str> for &'self str { //~ ERROR lifetimes cannot use keyword names\n+   |      ^^^^^\n+\n+error: lifetimes cannot use keyword names\n+  --> $DIR/issue-10412.rs:16:36\n+   |\n+LL | impl<'self> Serializable<str> for &'self str { //~ ERROR lifetimes cannot use keyword names\n+   |                                    ^^^^^\n+\n+error: lifetimes cannot use keyword names\n+  --> $DIR/issue-10412.rs:19:25\n+   |\n+LL |     fn serialize(val : &'self str) -> Vec<u8> { //~ ERROR lifetimes cannot use keyword names\n+   |                         ^^^^^\n+\n+error: lifetimes cannot use keyword names\n+  --> $DIR/issue-10412.rs:22:37\n+   |\n+LL |     fn deserialize(repr: &[u8]) -> &'self str { //~ ERROR lifetimes cannot use keyword names\n+   |                                     ^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/issue-10412.rs:16:13\n+   |\n+LL | impl<'self> Serializable<str> for &'self str { //~ ERROR lifetimes cannot use keyword names\n+   |             ^^^^^^^^^^^^^^^^^ expected lifetime parameter\n+\n+error: aborting due to 8 previous errors\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "ed91e935407b966a7200e92e8f773fbc47072d9e", "filename": "src/test/ui/issue-10465.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10465.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10465.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10465.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-10465.rs"}, {"sha": "add4b832e8322338a6135ef2193eba268c123ade", "filename": "src/test/ui/issue-10465.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10465.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10465.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10465.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,13 @@\n+error[E0599]: no method named `foo` found for type `&b::B` in the current scope\n+  --> $DIR/issue-10465.rs:27:15\n+   |\n+LL |             b.foo(); //~ ERROR: no method named `foo` found\n+   |               ^^^\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+   = note: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+           `use a::A;`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "2b71fb5c67f7a42a02ee9a59ac53bb93c6a892aa", "filename": "src/test/ui/issue-10536.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10536.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10536.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10536.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -24,8 +24,10 @@ pub fn main() {\n     foo!();\n \n     assert!({one! two()});\n+    //~^ ERROR macros that expand to items must either be surrounded with braces or followed by a\n \n     // regardless of whether nested macro_rules works, the following should at\n     // least throw a conventional error.\n     assert!({one! two});\n+    //~^ ERROR expected\n }", "previous_filename": "src/test/compile-fail/issue-10536.rs"}, {"sha": "ba404d0dd3f6353d791883b4d88b76ead9915742", "filename": "src/test/ui/issue-10536.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10536.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10536.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10536.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,14 @@\n+error: macros that expand to items must either be surrounded with braces or followed by a semicolon\n+  --> $DIR/issue-10536.rs:26:22\n+   |\n+LL |     assert!({one! two()});\n+   |                      ^^\n+\n+error: expected `(` or `{`, found `}`\n+  --> $DIR/issue-10536.rs:31:22\n+   |\n+LL |     assert!({one! two});\n+   |                      ^ expected `(` or `{`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "708eea39a9571b73dd58d24b5ebc4cd13cef3501", "filename": "src/test/ui/issue-10545.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10545.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10545.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10545.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-10545.rs"}, {"sha": "28f95dff3bc0ad7056c23fa9358be1bbed13f4fd", "filename": "src/test/ui/issue-10545.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10545.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10545.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10545.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,9 @@\n+error[E0603]: struct `S` is private\n+  --> $DIR/issue-10545.rs:17:11\n+   |\n+LL | fn foo(_: a::S) { //~ ERROR: struct `S` is private\n+   |           ^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0603`."}, {"sha": "7fd5a0d13485bec8ed786fc7a57070cb10c53099", "filename": "src/test/ui/issue-10656.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10656.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10656.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10656.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: missing documentation for crate\n-\n #![deny(missing_docs)]\n #![crate_type=\"lib\"]\n+//~^^ ERROR missing documentation for crate", "previous_filename": "src/test/compile-fail/issue-10656.rs"}, {"sha": "d67463f02636b1527f0e8fb8175b0d3473eabb39", "filename": "src/test/ui/issue-10656.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10656.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10656.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10656.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,15 @@\n+error: missing documentation for crate\n+  --> $DIR/issue-10656.rs:11:1\n+   |\n+LL | / #![deny(missing_docs)]\n+LL | | #![crate_type=\"lib\"]\n+   | |____________________^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-10656.rs:11:9\n+   |\n+LL | #![deny(missing_docs)]\n+   |         ^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "cd4ec495556c562303249997f20c36d31f7b3694", "filename": "src/test/ui/issue-10764.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10764.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10764.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10764.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-10764.rs"}, {"sha": "6aacbef089720f45fe05545e61bf694bfc91a258", "filename": "src/test/ui/issue-10764.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10764.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10764.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10764.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-10764.rs:14:15\n+   |\n+LL | fn main() { f(bar) }\n+   |               ^^^ expected \"Rust\" fn, found \"C\" fn\n+   |\n+   = note: expected type `fn()`\n+              found type `extern \"C\" fn() {bar}`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "39f25b837cd4976e6b0e439dffbbc4c7a67cb7e0", "filename": "src/test/ui/issue-10877.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10877.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-10877.rs"}, {"sha": "6db0bf6dc65fb3efcc7c858d1ef80f9b315e29e4", "filename": "src/test/ui/issue-10877.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10877.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10877.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10877.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,27 @@\n+error[E0130]: patterns aren't allowed in foreign function declarations\n+  --> $DIR/issue-10877.rs:13:12\n+   |\n+LL |     fn foo(1: ());\n+   |            ^ pattern not allowed in foreign function\n+\n+error[E0130]: patterns aren't allowed in foreign function declarations\n+  --> $DIR/issue-10877.rs:15:12\n+   |\n+LL |     fn bar((): isize);\n+   |            ^^ pattern not allowed in foreign function\n+\n+error[E0130]: patterns aren't allowed in foreign function declarations\n+  --> $DIR/issue-10877.rs:17:12\n+   |\n+LL |     fn baz(Foo { x }: isize);\n+   |            ^^^^^^^^^ pattern not allowed in foreign function\n+\n+error[E0130]: patterns aren't allowed in foreign function declarations\n+  --> $DIR/issue-10877.rs:19:12\n+   |\n+LL |     fn qux((x,y): ());\n+   |            ^^^^^ pattern not allowed in foreign function\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0130`."}, {"sha": "2d00f339f33a066607fbf6eee018501ce5557422", "filename": "src/test/ui/issue-10991.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10991.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-10991.rs"}, {"sha": "3ae3bbe06cbf79101d7f2dd2025a4c05a911ab88", "filename": "src/test/ui/issue-10991.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10991.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-10991.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-10991.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,11 @@\n+error[E0605]: non-primitive cast: `()` as `usize`\n+  --> $DIR/issue-10991.rs:13:14\n+   |\n+LL |     let _t = nil as usize; //~ ERROR: non-primitive cast: `()` as `usize`\n+   |              ^^^^^^^^^^^^\n+   |\n+   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0605`."}, {"sha": "1ff6812337406b9602ea71aa12b905d382b0f6f9", "filename": "src/test/ui/issue-11154.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11154.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11154.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11154.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-11154.rs"}, {"sha": "8eec8b37c85ec24320a5ccc68b260046e49cd6fd", "filename": "src/test/ui/issue-11154.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11154.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11154.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11154.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,6 @@\n+error: cannot prefer dynamic linking when performing LTO\n+\n+note: only 'staticlib', 'bin', and 'cdylib' outputs are supported with LTO\n+\n+error: aborting due to previous error\n+"}, {"sha": "d5a67083a23b81ce60526ae512b5414ce1d13c75", "filename": "src/test/ui/issue-11192.nll.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11192.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11192.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11192.nll.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,18 @@\n+error[E0502]: cannot borrow `*ptr` as immutable because it is also borrowed as mutable\n+  --> $DIR/issue-11192.rs:30:10\n+   |\n+LL |     let mut test = |foo: &Foo| {\n+   |                    ----------- mutable borrow occurs here\n+LL |         println!(\"access {}\", foo.x);\n+LL |         ptr = box Foo { x: ptr.x + 1 };\n+   |         --- previous borrow occurs due to use of `ptr` in closure\n+...\n+LL |     test(&*ptr);\n+   |     -----^^^^^-\n+   |     |    |\n+   |     |    immutable borrow occurs here\n+   |     borrow later used here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0502`."}, {"sha": "7d8a1528aba36973a5cc86d395b82a716d36772c", "filename": "src/test/ui/issue-11192.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11192.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11192.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11192.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-11192.rs"}, {"sha": "e9853ac0ca8277354b270745679468b6c5b51d5e", "filename": "src/test/ui/issue-11192.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11192.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11192.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11192.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,18 @@\n+error[E0502]: cannot borrow `*ptr` as immutable because `ptr` is also borrowed as mutable\n+  --> $DIR/issue-11192.rs:30:11\n+   |\n+LL |     let mut test = |foo: &Foo| {\n+   |                    ----------- mutable borrow occurs here\n+LL |         println!(\"access {}\", foo.x);\n+LL |         ptr = box Foo { x: ptr.x + 1 };\n+   |         --- previous borrow occurs due to use of `ptr` in closure\n+...\n+LL |     test(&*ptr);\n+   |           ^^^^ immutable borrow occurs here\n+LL |     //~^ ERROR: cannot borrow `*ptr` as immutable\n+LL | }\n+   | - mutable borrow ends here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0502`."}, {"sha": "1e444a6bebf9b23b573465a7090f60b174d52fa3", "filename": "src/test/ui/issue-11374.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11374.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-11374.rs"}, {"sha": "3465069129bf5659f899f35c58ff9afc62989da9", "filename": "src/test/ui/issue-11374.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11374.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11374.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11374.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,15 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-11374.rs:36:15\n+   |\n+LL |     c.read_to(v); //~ ERROR E0308\n+   |               ^\n+   |               |\n+   |               expected &mut [u8], found struct `std::vec::Vec`\n+   |               help: consider mutably borrowing here: `&mut v`\n+   |\n+   = note: expected type `&mut [u8]`\n+              found type `std::vec::Vec<_>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "99b996387e79be7ee2138715ae4d9c71c14b8314", "filename": "src/test/ui/issue-11493.ast.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11493.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11493.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11493.ast.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,16 @@\n+error[E0597]: borrowed value does not live long enough (Ast)\n+  --> $DIR/issue-11493.rs:20:35\n+   |\n+LL |     let y = x.as_ref().unwrap_or(&id(5));\n+   |                                   ^^^^^ - temporary value dropped here while still borrowed\n+   |                                   |\n+   |                                   temporary value does not live long enough\n+...\n+LL | }\n+   | - temporary value needs to live until here\n+   |\n+   = note: consider using a `let` binding to increase its lifetime\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "99b996387e79be7ee2138715ae4d9c71c14b8314", "filename": "src/test/ui/issue-11493.mir.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11493.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11493.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11493.mir.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,16 @@\n+error[E0597]: borrowed value does not live long enough (Ast)\n+  --> $DIR/issue-11493.rs:20:35\n+   |\n+LL |     let y = x.as_ref().unwrap_or(&id(5));\n+   |                                   ^^^^^ - temporary value dropped here while still borrowed\n+   |                                   |\n+   |                                   temporary value does not live long enough\n+...\n+LL | }\n+   | - temporary value needs to live until here\n+   |\n+   = note: consider using a `let` binding to increase its lifetime\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "80ecc24543e17d0c6f234ac10b58e017bef552ef", "filename": "src/test/ui/issue-11493.rs", "status": "renamed", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11493.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11493.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11493.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -9,10 +9,16 @@\n // except according to those terms.\n \n // This file must never have a trailing newline\n+//\n+// revisions: ast mir\n+// compile-flags: -Z borrowck=compare\n \n fn id<T>(x: T) -> T { x }\n \n fn main() {\n     let x = Some(3);\n-    let y = x.as_ref().unwrap_or(&id(5)); //~ ERROR: borrowed value does not live long enough\n+    let y = x.as_ref().unwrap_or(&id(5));\n+    //[ast]~^ ERROR borrowed value does not live long enough (Ast)\n+    //[mir]~^^ ERROR borrowed value does not live long enough (Ast)\n+    // This actually passes in mir\n }", "previous_filename": "src/test/compile-fail/issue-11493.rs"}, {"sha": "7afb8314ea689ffeba0615e449e18a503b16f2f1", "filename": "src/test/ui/issue-11515.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11515.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11515.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11515.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-11515.rs"}, {"sha": "25e2a45438e84b2c961497857be380ea054ba599", "filename": "src/test/ui/issue-11515.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11515.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11515.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11515.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-11515.rs:19:33\n+   |\n+LL |     let test = box Test { func: closure }; //~ ERROR mismatched types\n+   |                                 ^^^^^^^ expected trait `std::ops::FnMut`, found trait `std::ops::Fn`\n+   |\n+   = note: expected type `std::boxed::Box<(dyn std::ops::FnMut() + 'static)>`\n+              found type `std::boxed::Box<(dyn std::ops::Fn() + 'static)>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "71f1d5dcc9af4af1007fbf40ff0c8fdd57574a38", "filename": "src/test/ui/issue-11681.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11681.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11681.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11681.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-11681.rs"}, {"sha": "ef3d24c6657beff73dcd2556c0705d8f0f95c334", "filename": "src/test/ui/issue-11681.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11681.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11681.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11681.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,18 @@\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/issue-11681.rs:22:20\n+   |\n+LL |   let testValue = &Test; //~ ERROR borrowed value does not live long enough\n+   |                    ^^^^ temporary value does not live long enough\n+LL |   return testValue;\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 21:15...\n+  --> $DIR/issue-11681.rs:21:15\n+   |\n+LL | fn createTest<'a>() -> &'a Test {\n+   |               ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "f577aad04e620bf0c7e02bedb9ebdc60167a529c", "filename": "src/test/ui/issue-11692-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11692-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11692-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11692-1.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-11692-1.rs"}, {"sha": "daf53af3ace996a40b2aef793e181e344c6e7c43", "filename": "src/test/ui/issue-11692-1.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11692-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11692-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11692-1.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,8 @@\n+error: format argument must be a string literal.\n+  --> $DIR/issue-11692-1.rs:12:12\n+   |\n+LL |     print!(test!());\n+   |            ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "acac2d151fe9ad5ef8008d3caf10f1a5de111bf7", "filename": "src/test/ui/issue-11692-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11692-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11692-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11692-2.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-11692-2.rs"}, {"sha": "51d6041e92220e356b6f873a9ec54c9c8e5ca952", "filename": "src/test/ui/issue-11692-2.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11692-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11692-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11692-2.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,8 @@\n+error: cannot find macro `test!` in this scope\n+  --> $DIR/issue-11692-2.rs:12:13\n+   |\n+LL |     concat!(test!());\n+   |             ^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "0bda06be9e8ca964575185441d3beff9f5d526f2", "filename": "src/test/ui/issue-11740.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11740.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11740.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11740.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-11740.rs"}, {"sha": "a1913e0057ca77c0c8fe1b7b0701776595eab439", "filename": "src/test/ui/issue-11740.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11740.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11740.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11740.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,11 @@\n+error: compilation successful\n+  --> $DIR/issue-11740.rs:35:1\n+   |\n+LL | / fn main() { //~ ERROR compilation successful\n+LL | |     let element = Element { attrs: Vec::new() };\n+LL | |     let _ = unsafe { element.get_attr(\"foo\") };\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "69899105bc3178720a9c880b5f7efc61c1b0724f", "filename": "src/test/ui/issue-11771.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11771.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11771.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11771.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-11771.rs"}, {"sha": "a31c4fa008db14365ef4be97b56ef8596188c457", "filename": "src/test/ui/issue-11771.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11771.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11771.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11771.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: cannot add `()` to `{integer}`\n+  --> $DIR/issue-11771.rs:13:7\n+   |\n+LL |     1 +\n+   |       ^ no implementation for `{integer} + ()`\n+   |\n+   = help: the trait `std::ops::Add<()>` is not implemented for `{integer}`\n+\n+error[E0277]: cannot add `()` to `{integer}`\n+  --> $DIR/issue-11771.rs:18:7\n+   |\n+LL |     1 +\n+   |       ^ no implementation for `{integer} + ()`\n+   |\n+   = help: the trait `std::ops::Add<()>` is not implemented for `{integer}`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "a6dbe954ec0aca714e14c2c5b4891fe0d824ad70", "filename": "src/test/ui/issue-11844.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11844.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11844.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11844.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-11844.rs"}, {"sha": "d773e88d01cf2c129fbe7bf84c62b295354a4af2", "filename": "src/test/ui/issue-11844.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11844.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11844.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11844.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-11844.rs:16:9\n+   |\n+LL |         Ok(a) => //~ ERROR: mismatched types\n+   |         ^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n+   |\n+   = note: expected type `std::option::Option<std::boxed::Box<{integer}>>`\n+              found type `std::result::Result<_, _>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "c12cbbfdd53a16a4e0b3755ff9707f413d21ad3f", "filename": "src/test/ui/issue-11873.nll.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11873.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11873.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11873.nll.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,14 @@\n+error[E0505]: cannot move out of `v` because it is borrowed\n+  --> $DIR/issue-11873.rs:14:14\n+   |\n+LL |     let mut f = || v.push(2);\n+   |                 ------------ borrow of `v` occurs here\n+LL |     let _w = v; //~ ERROR: cannot move out of `v`\n+   |              ^ move out of `v` occurs here\n+LL | \n+LL |     f();\n+   |     - borrow later used here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0505`."}, {"sha": "4618851529a15b2aa8db1180e0ff783393bcc67e", "filename": "src/test/ui/issue-11873.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11873.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11873.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11873.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-11873.rs"}, {"sha": "f4da011f5729c38ed7f007866ada6ac6556ed1bc", "filename": "src/test/ui/issue-11873.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11873.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-11873.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11873.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,11 @@\n+error[E0505]: cannot move out of `v` because it is borrowed\n+  --> $DIR/issue-11873.rs:14:9\n+   |\n+LL |     let mut f = || v.push(2);\n+   |                 -- borrow of `v` occurs here\n+LL |     let _w = v; //~ ERROR: cannot move out of `v`\n+   |         ^^ move out of `v` occurs here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0505`."}, {"sha": "980385ce4cc6b360a65b7cd9876a356f385e0616", "filename": "src/test/ui/issue-12028.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12028.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12028.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12028.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-12028.rs"}, {"sha": "f756e0a29d17a978698459c46f0f11447fc501e2", "filename": "src/test/ui/issue-12028.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12028.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12028.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12028.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,9 @@\n+error[E0284]: type annotations required: cannot resolve `<_ as StreamHasher>::S == <H as StreamHasher>::S`\n+  --> $DIR/issue-12028.rs:39:14\n+   |\n+LL |         self.input_stream(&mut stream); //~ ERROR type annotations required\n+   |              ^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0284`."}, {"sha": "b880317a2a61298712dc0bc3cb2d2841374d9362", "filename": "src/test/ui/issue-12041.nll.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12041.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12041.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12041.nll.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,11 @@\n+error[E0382]: use of moved value: `tx`\n+  --> $DIR/issue-12041.rs:18:22\n+   |\n+LL |             let tx = tx;\n+   |                      ^^ value moved here in previous iteration of loop\n+   |\n+   = note: move occurs because `tx` has type `std::sync::mpsc::Sender<i32>`, which does not implement the `Copy` trait\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "f0f4bf5ca71bb611031a86f871bdf974ce923717", "filename": "src/test/ui/issue-12041.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12041.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12041.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12041.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-12041.rs"}, {"sha": "6172d78b51377b71031e8429ae383ca5cfd4db29", "filename": "src/test/ui/issue-12041.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12041.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12041.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12041.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,11 @@\n+error[E0382]: use of moved value: `tx`\n+  --> $DIR/issue-12041.rs:18:17\n+   |\n+LL |             let tx = tx;\n+   |                 ^^ value moved here in previous iteration of loop\n+   |\n+   = note: move occurs because `tx` has type `std::sync::mpsc::Sender<i32>`, which does not implement the `Copy` trait\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "a8d2c55255340ceca1c776cd07723836805d1080", "filename": "src/test/ui/issue-12116.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12116.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12116.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12116.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-12116.rs"}, {"sha": "3bf0984b25685acfa427b4bd25a01c7e6f4fe21d", "filename": "src/test/ui/issue-12116.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12116.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12116.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12116.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,14 @@\n+error: unreachable pattern\n+  --> $DIR/issue-12116.rs:25:9\n+   |\n+LL |         &IntList::Cons(val, box IntList::Nil)  => IntList::Cons(val, box IntList::Nil),\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-12116.rs:15:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "5565a9a5761166d0a52fb7649d241990b546c492", "filename": "src/test/ui/issue-12127.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12127.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12127.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12127.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-12127.rs"}, {"sha": "afd483823a63055777969309245a057f6ba2373b", "filename": "src/test/ui/issue-12127.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12127.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12127.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12127.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,13 @@\n+error[E0382]: use of moved value: `f`\n+  --> $DIR/issue-12127.rs:21:9\n+   |\n+LL |         f();\n+   |         - value moved here\n+LL |         f();\n+   |         ^ value used here after move\n+   |\n+   = note: move occurs because `f` has type `[closure@$DIR/issue-12127.rs:18:24: 18:41 x:std::boxed::Box<isize>]`, which does not implement the `Copy` trait\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "1b9af393ccce473bfce789a75af2b8c6058aa70c", "filename": "src/test/ui/issue-12369.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12369.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12369.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12369.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-12369.rs"}, {"sha": "2e8cd840fb7e8a5e033e19cf7ecc35fa0a8f5bb6", "filename": "src/test/ui/issue-12369.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12369.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12369.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12369.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,14 @@\n+error: unreachable pattern\n+  --> $DIR/issue-12369.rs:20:9\n+   |\n+LL |         &[10,a, ref rest..] => 10 //~ ERROR: unreachable pattern\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-12369.rs:12:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "09cbfe4f66daa3aaaae4d49fd735851fbd85a6ae", "filename": "src/test/ui/issue-12470.nll.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12470.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12470.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12470.nll.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,18 @@\n+error[E0597]: `*b` does not live long enough\n+  --> $DIR/issue-12470.rs:38:18\n+   |\n+LL |     let bb: &B = &*b;    //~ ERROR does not live long enough\n+   |                  ^^^ borrowed value does not live long enough\n+LL |     make_a(bb)\n+LL | }\n+   | - borrowed value only lives until here\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 36:16...\n+  --> $DIR/issue-12470.rs:36:16\n+   |\n+LL | fn make_make_a<'a>() -> A<'a> {\n+   |                ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "93785817e14f36107e704becf360d63f5538fa11", "filename": "src/test/ui/issue-12470.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12470.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12470.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12470.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-12470.rs"}, {"sha": "91788e96297892f6da13321acc6a0b758447095e", "filename": "src/test/ui/issue-12470.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12470.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12470.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12470.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,18 @@\n+error[E0597]: `*b` does not live long enough\n+  --> $DIR/issue-12470.rs:38:19\n+   |\n+LL |     let bb: &B = &*b;    //~ ERROR does not live long enough\n+   |                   ^^ borrowed value does not live long enough\n+LL |     make_a(bb)\n+LL | }\n+   | - borrowed value only lives until here\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 36:16...\n+  --> $DIR/issue-12470.rs:36:16\n+   |\n+LL | fn make_make_a<'a>() -> A<'a> {\n+   |                ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "e4788bac256e2424434039606391be6504f78724", "filename": "src/test/ui/issue-12552.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12552.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12552.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12552.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-12552.rs"}, {"sha": "9a3d5ef02c6277df069e010d30fcb7d86b4dee2b", "filename": "src/test/ui/issue-12552.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12552.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12552.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12552.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-12552.rs:16:5\n+   |\n+LL |     Some(k) => match k { //~ ERROR mismatched types\n+   |     ^^^^^^^ expected enum `std::result::Result`, found enum `std::option::Option`\n+   |\n+   = note: expected type `std::result::Result<_, {integer}>`\n+              found type `std::option::Option<_>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-12552.rs:19:5\n+   |\n+LL |     None => () //~ ERROR mismatched types\n+   |     ^^^^ expected enum `std::result::Result`, found enum `std::option::Option`\n+   |\n+   = note: expected type `std::result::Result<_, {integer}>`\n+              found type `std::option::Option<_>`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "a040f7c3c8d1b04d336189a5348c5e9334ec572b", "filename": "src/test/ui/issue-12567.nll.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12567.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12567.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12567.nll.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,31 @@\n+error[E0508]: cannot move out of type `[T]`, a non-copy slice\n+  --> $DIR/issue-12567.rs:14:11\n+   |\n+LL |     match (l1, l2) {\n+   |           ^^^^^^^^ cannot move out of here\n+help: to prevent move, use ref or ref mut\n+   |\n+LL |         (&[], &[ref hd, ..]) | (&[hd, ..], &[])\n+   |                 ^^^^^^\n+help: to prevent move, use ref or ref mut\n+   |\n+LL |         (&[hd1, ..], &[ref hd2, ..])\n+   |                        ^^^^^^^\n+\n+error[E0508]: cannot move out of type `[T]`, a non-copy slice\n+  --> $DIR/issue-12567.rs:14:11\n+   |\n+LL |     match (l1, l2) {\n+   |           ^^^^^^^^ cannot move out of here\n+help: to prevent move, use ref or ref mut\n+   |\n+LL |         (&[], &[ref hd, ..]) | (&[hd, ..], &[])\n+   |                 ^^^^^^\n+help: to prevent move, use ref or ref mut\n+   |\n+LL |         (&[ref hd1, ..], &[hd2, ..])\n+   |            ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0508`."}, {"sha": "30cdd07b399986de54b3e7137d31833ea310717d", "filename": "src/test/ui/issue-12567.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12567.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12567.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12567.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-12567.rs"}, {"sha": "60acffdcb06f8e410e38a6181ab13310d6346b1c", "filename": "src/test/ui/issue-12567.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12567.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12567.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12567.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,39 @@\n+error[E0508]: cannot move out of type `[T]`, a non-copy slice\n+  --> $DIR/issue-12567.rs:16:16\n+   |\n+LL |         (&[], &[hd, ..]) | (&[hd, ..], &[])\n+   |                ^--^^^^^\n+   |                ||\n+   |                |hint: to prevent move, use `ref hd` or `ref mut hd`\n+   |                cannot move out of here\n+\n+error[E0508]: cannot move out of type `[T]`, a non-copy slice\n+  --> $DIR/issue-12567.rs:16:30\n+   |\n+LL |         (&[], &[hd, ..]) | (&[hd, ..], &[])\n+   |                              ^--^^^^^\n+   |                              ||\n+   |                              |hint: to prevent move, use `ref hd` or `ref mut hd`\n+   |                              cannot move out of here\n+\n+error[E0508]: cannot move out of type `[T]`, a non-copy slice\n+  --> $DIR/issue-12567.rs:20:11\n+   |\n+LL |         (&[hd1, ..], &[hd2, ..])\n+   |           ^---^^^^^\n+   |           ||\n+   |           |hint: to prevent move, use `ref hd1` or `ref mut hd1`\n+   |           cannot move out of here\n+\n+error[E0508]: cannot move out of type `[T]`, a non-copy slice\n+  --> $DIR/issue-12567.rs:20:23\n+   |\n+LL |         (&[hd1, ..], &[hd2, ..])\n+   |                       ^---^^^^^\n+   |                       ||\n+   |                       |hint: to prevent move, use `ref hd2` or `ref mut hd2`\n+   |                       cannot move out of here\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0508`."}, {"sha": "0c3c82a99f28f4f38a6ba45caea71226fadad3de", "filename": "src/test/ui/issue-12796.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12796.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12796.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12796.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-12796.rs"}, {"sha": "c8bedd3853c68135e064e4ac5455813e9f7ae74c", "filename": "src/test/ui/issue-12796.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12796.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12796.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12796.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,11 @@\n+error[E0401]: can't use type parameters from outer function\n+  --> $DIR/issue-12796.rs:13:22\n+   |\n+LL |         fn inner(_: &Self) {\n+   |            -----     ^^^^ use of type variable from outer function\n+   |            |\n+   |            help: try using a local type parameter instead: `inner<Self>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0401`."}, {"sha": "d3432410c5427b6a99feea3bc952cbb347b23ec9", "filename": "src/test/ui/issue-12863.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12863.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12863.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12863.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-12863.rs"}, {"sha": "eb2957a8225937623fe0d18cd0bf7ff93b512fa4", "filename": "src/test/ui/issue-12863.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12863.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12863.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12863.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,9 @@\n+error[E0532]: expected unit struct/variant or constant, found function `foo::bar`\n+  --> $DIR/issue-12863.rs:15:9\n+   |\n+LL |         foo::bar => {} //~ ERROR expected unit struct/variant or constant, found function `foo::bar`\n+   |         ^^^^^^^^ not a unit struct/variant or constant\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0532`."}, {"sha": "2d8d7857c99fb9feb6a4007e8a831903331323aa", "filename": "src/test/ui/issue-12997-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12997-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12997-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12997-1.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-12997-1.rs"}, {"sha": "856538417d914e81770a7c96f5bc88bfb21bcd06", "filename": "src/test/ui/issue-12997-1.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12997-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12997-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12997-1.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,14 @@\n+error: functions used as benches must have signature `fn(&mut Bencher) -> impl Termination`\n+  --> $DIR/issue-12997-1.rs:16:1\n+   |\n+LL | fn foo() { } //~ ERROR functions used as benches\n+   | ^^^^^^^^^^^^\n+\n+error: functions used as benches must have signature `fn(&mut Bencher) -> impl Termination`\n+  --> $DIR/issue-12997-1.rs:19:1\n+   |\n+LL | fn bar(x: isize, y: isize) { } //~ ERROR functions used as benches\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "8d3df68577bab14f1d2518d02fd495acf220e63c", "filename": "src/test/ui/issue-12997-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12997-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12997-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12997-2.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-12997-2.rs"}, {"sha": "3030ee4779b4b71cc2fde28e532e526a5017b8b6", "filename": "src/test/ui/issue-12997-2.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12997-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-12997-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12997-2.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-12997-2.rs:16:1\n+   |\n+LL | fn bar(x: isize) { }\n+   | ^^^^^^^^^^^^^^^^^^^^ expected isize, found mutable reference\n+   |\n+   = note: expected type `isize`\n+              found type `&mut __test::test::Bencher`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "f1fd617717a5ee5af533bf7bf3b51c44259688d2", "filename": "src/test/ui/issue-13033.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13033.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13033.rs"}, {"sha": "2db3cb80a819e53fd4190eda2325d48e3fba04d5", "filename": "src/test/ui/issue-13033.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13033.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13033.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13033.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,15 @@\n+error[E0053]: method `bar` has an incompatible type for trait\n+  --> $DIR/issue-13033.rs:18:30\n+   |\n+LL |     fn bar(&mut self, other: &mut Foo);\n+   |                              -------- type in trait\n+...\n+LL |     fn bar(&mut self, other: &Foo) {}\n+   |                              ^^^^ types differ in mutability\n+   |\n+   = note: expected type `fn(&mut Baz, &mut dyn Foo)`\n+              found type `fn(&mut Baz, &dyn Foo)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0053`."}, {"sha": "e9d76c758cdb726f0cea282e12311bf211fe1071", "filename": "src/test/ui/issue-13352.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13352.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13352.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13352.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13352.rs"}, {"sha": "5324eb2118617d9503b7244f435f0d45d1f7c06e", "filename": "src/test/ui/issue-13352.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13352.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13352.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13352.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,11 @@\n+error[E0277]: cannot add `()` to `usize`\n+  --> $DIR/issue-13352.rs:19:13\n+   |\n+LL |     2_usize + (loop {});\n+   |             ^ no implementation for `usize + ()`\n+   |\n+   = help: the trait `std::ops::Add<()>` is not implemented for `usize`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "e33859e8c19a38479ee260f2579c00b8dd66068b", "filename": "src/test/ui/issue-13359.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13359.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13359.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13359.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13359.rs"}, {"sha": "77f10be982b0110921b877070e695b36a31b75ef", "filename": "src/test/ui/issue-13359.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13359.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13359.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13359.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,15 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-13359.rs:16:9\n+   |\n+LL |     foo(1*(1 as isize));\n+   |         ^^^^^^^^^^^^^^ expected i16, found isize\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-13359.rs:20:9\n+   |\n+LL |     bar(1*(1 as usize));\n+   |         ^^^^^^^^^^^^^^ expected u32, found usize\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "0059e92e07f07a8aa29ae13cfb8ff78e6395509e", "filename": "src/test/ui/issue-13404.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13404.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13404.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13404.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13404.rs"}, {"sha": "b71d3ceab5b3b9316da51f5de58f16a46629a32e", "filename": "src/test/ui/issue-13404.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13404.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13404.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13404.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,9 @@\n+error[E0432]: unresolved import `b::f`\n+  --> $DIR/issue-13404.rs:12:5\n+   |\n+LL | use b::f; //~ ERROR: unresolved import `b::f` [E0432]\n+   |     ^^^^ no `f` in `b`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "afb2e867f45c6057e60336534eefb316e4148cc7", "filename": "src/test/ui/issue-13407.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13407.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13407.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13407.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13407.rs"}, {"sha": "e5ef50e984a766ff337b7c86fc8505e9666fc96d", "filename": "src/test/ui/issue-13407.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13407.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13407.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13407.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,25 @@\n+error[E0603]: unit struct `C` is private\n+  --> $DIR/issue-13407.rs:16:5\n+   |\n+LL |     A::C = 1;\n+   |     ^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-13407.rs:16:12\n+   |\n+LL |     A::C = 1;\n+   |            ^ expected struct `A::C`, found integral variable\n+   |\n+   = note: expected type `A::C`\n+              found type `{integer}`\n+\n+error[E0070]: invalid left-hand side expression\n+  --> $DIR/issue-13407.rs:16:5\n+   |\n+LL |     A::C = 1;\n+   |     ^^^^^^^^ left-hand of expression not valid\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0070, E0308, E0603.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "6ad3ec67b29642bb251aef0cae43a3c216b2fe1f", "filename": "src/test/ui/issue-13446.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13446.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13446.rs"}, {"sha": "68fece30c81d1f5bb983369e8262dfa5e523bf8b", "filename": "src/test/ui/issue-13446.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13446.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13446.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13446.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,13 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-13446.rs:16:26\n+   |\n+LL | static VEC: [u32; 256] = vec![];\n+   |                          ^^^^^^ expected array of 256 elements, found struct `std::vec::Vec`\n+   |\n+   = note: expected type `[u32; 256]`\n+              found type `std::vec::Vec<_>`\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "abddf6ba7a38d4550392a514e56cc7d51e45820e", "filename": "src/test/ui/issue-13466.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13466.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13466.rs"}, {"sha": "be845fb8e22853849a872f524cbbee5ac0df3175", "filename": "src/test/ui/issue-13466.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13466.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13466.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13466.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-13466.rs:18:9\n+   |\n+LL |         Ok(u) => u,\n+   |         ^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n+   |\n+   = note: expected type `std::option::Option<{integer}>`\n+              found type `std::result::Result<_, _>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-13466.rs:24:9\n+   |\n+LL |         Err(e) => panic!(e)\n+   |         ^^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n+   |\n+   = note: expected type `std::option::Option<{integer}>`\n+              found type `std::result::Result<_, _>`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "fe7fbb176cc5e61adf95be6680d92539f3ccd8c4", "filename": "src/test/ui/issue-13482-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13482-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13482-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13482-2.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13482-2.rs"}, {"sha": "1ecae3b867a11df8671bfa7333b6aff40dc2aae9", "filename": "src/test/ui/issue-13482-2.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13482-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13482-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13482-2.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,9 @@\n+error[E0527]: pattern requires 0 elements but array has 2\n+  --> $DIR/issue-13482-2.rs:16:9\n+   |\n+LL |         [] => None, //~ ERROR pattern requires 0 elements but array has 2\n+   |         ^^ expected 2 elements\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0527`."}, {"sha": "32a63b79a32dd093cb845c688d72d8378cc7f7c2", "filename": "src/test/ui/issue-13482.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13482.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13482.rs"}, {"sha": "95273bb46bca3e0840772dfc9db7ccb8704c65e7", "filename": "src/test/ui/issue-13482.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13482.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13482.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13482.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,9 @@\n+error[E0527]: pattern requires 0 elements but array has 2\n+  --> $DIR/issue-13482.rs:14:5\n+   |\n+LL |     [] => None, //~ ERROR pattern requires 0 elements but array has 2\n+   |     ^^ expected 2 elements\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0527`."}, {"sha": "31716837493c7c0e71a9996b605ad6696eb2a2d9", "filename": "src/test/ui/issue-13497-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13497-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13497-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13497-2.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13497-2.rs"}, {"sha": "72770f8c84ce7df607fab5df04eac0f6f6b8cbb4", "filename": "src/test/ui/issue-13497-2.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13497-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13497-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13497-2.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,18 @@\n+error[E0597]: `rawLines` does not live long enough\n+  --> $DIR/issue-13497-2.rs:13:5\n+   |\n+LL |     rawLines //~ ERROR `rawLines` does not live long enough\n+   |     ^^^^^^^^ borrowed value does not live long enough\n+LL |         .iter().map(|l| l.trim()).collect()\n+LL | }\n+   | - borrowed value only lives until here\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 11:24...\n+  --> $DIR/issue-13497-2.rs:11:24\n+   |\n+LL | fn read_lines_borrowed<'a>() -> Vec<&'a str> {\n+   |                        ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "d544a92d9c3b594a842daae30c37efc166b1976a", "filename": "src/test/ui/issue-13497.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13497.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13497.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13497.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13497.rs"}, {"sha": "ab6d041bd48d731ac747a3019be44e452da776e6", "filename": "src/test/ui/issue-13497.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13497.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13497.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13497.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,12 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/issue-13497.rs:12:5\n+   |\n+LL |     &str //~ ERROR missing lifetime specifier\n+   |     ^ expected lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+   = help: consider giving it a 'static lifetime\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "d51db4795998b0fcd54ebb9235d4a92d9b9cac09", "filename": "src/test/ui/issue-1362.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-1362.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-1362.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-1362.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-1362.rs"}, {"sha": "c19e256eb92833e1f7822ac0824f77bd2ef9278e", "filename": "src/test/ui/issue-1362.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-1362.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-1362.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-1362.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-1362.rs:14:16\n+   |\n+LL |   let x: u32 = 20i32; //~ ERROR mismatched types\n+   |                ^^^^^ expected u32, found i32\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "3b690e08f6143042e6cc05cfeca424a036f4330c", "filename": "src/test/ui/issue-13641.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13641.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13641.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13641.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13641.rs"}, {"sha": "0f96b5f66b1b81a388d1fb31ab4cb962219efed8", "filename": "src/test/ui/issue-13641.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13641.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13641.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13641.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,15 @@\n+error[E0603]: struct `Foo` is private\n+  --> $DIR/issue-13641.rs:19:5\n+   |\n+LL |     a::Foo::new();\n+   |     ^^^^^^^^^^^\n+\n+error[E0603]: enum `Bar` is private\n+  --> $DIR/issue-13641.rs:21:5\n+   |\n+LL |     a::Bar::new();\n+   |     ^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0603`."}, {"sha": "2e815548e89134c7e95e16cc1fe318f0c0fc8df0", "filename": "src/test/ui/issue-13727.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13727.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13727.rs"}, {"sha": "47b9a0211a9670a479b91cd842bae687d96cfe97", "filename": "src/test/ui/issue-13727.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13727.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13727.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13727.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,14 @@\n+error: unreachable pattern\n+  --> $DIR/issue-13727.rs:17:5\n+   |\n+LL |     512 => print!(\"0b1111/n\"),\n+   |     ^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-13727.rs:12:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "0314f109a7c8129a7184b936f8900300ca03d86d", "filename": "src/test/ui/issue-13847.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13847.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13847.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13847.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13847.rs"}, {"sha": "fad3245034d06a35eb143d6b886049263754d35a", "filename": "src/test/ui/issue-13847.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13847.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13847.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13847.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,9 @@\n+error[E0609]: no field `is_failure` on type `!`\n+  --> $DIR/issue-13847.rs:12:12\n+   |\n+LL |     return.is_failure //~ ERROR no field `is_failure` on type `!`\n+   |            ^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0609`."}, {"sha": "1635a8f69a6cd2b481f91adf5c99402dfc6923d8", "filename": "src/test/ui/issue-13853-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13853-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13853-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13853-2.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13853-2.rs"}, {"sha": "c15290fb1d95791749f9b00f21ee8cf0cd66026e", "filename": "src/test/ui/issue-13853-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13853-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13853-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13853-2.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,11 @@\n+error[E0615]: attempted to take value of method `get` on type `std::boxed::Box<(dyn ResponseHook + 'static)>`\n+  --> $DIR/issue-13853-2.rs:15:39\n+   |\n+LL | fn foo(res : Box<ResponseHook>) { res.get } //~ ERROR attempted to take value of method\n+   |                                       ^^^\n+   |\n+   = help: maybe a `()` to call it is missing?\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0615`."}, {"sha": "78b079a7c44a4ac307edf34b8af0e906e5375bcb", "filename": "src/test/ui/issue-13853-5.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13853-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13853-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13853-5.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13853-5.rs"}, {"sha": "e93b03b43ee66d47fc9516cefa15cf59f66bbb4a", "filename": "src/test/ui/issue-13853-5.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13853-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13853-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13853-5.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,9 @@\n+error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predicates\n+  --> $DIR/issue-13853-5.rs:17:10\n+   |\n+LL | impl<'a, T: Deserializable> Deserializable for &'a str {\n+   |          ^ unconstrained type parameter\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0207`."}, {"sha": "86a6bdfd4dde4d5c1b1898a50272e22c43ed5a37", "filename": "src/test/ui/issue-13853.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13853.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "previous_filename": "src/test/compile-fail/issue-13853.rs"}, {"sha": "188bfd5930105777a9bf15848695388ca13101ec", "filename": "src/test/ui/issue-13853.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13853.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-13853.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13853.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,34 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-13853.rs:24:9\n+   |\n+LL |     fn nodes<'a, I: Iterator<Item=&'a N>>(&self) -> I\n+   |                                                     - expected `I` because of return type\n+...\n+LL |         self.iter() //~ ERROR mismatched types\n+   |         ^^^^^^^^^^^ expected type parameter, found struct `std::slice::Iter`\n+   |\n+   = note: expected type `I`\n+              found type `std::slice::Iter<'_, N>`\n+\n+error[E0599]: no method named `iter` found for type `&G` in the current scope\n+  --> $DIR/issue-13853.rs:37:23\n+   |\n+LL |     for node in graph.iter() { //~ ERROR no method named `iter` found\n+   |                       ^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-13853.rs:47:13\n+   |\n+LL |     iterate(graph); //~ ERROR mismatched types\n+   |             ^^^^^\n+   |             |\n+   |             expected reference, found struct `std::vec::Vec`\n+   |             help: consider borrowing here: `&graph`\n+   |\n+   = note: expected type `&_`\n+              found type `std::vec::Vec<Stuff>`\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0308, E0599.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "a4351733a876e1e419896791742d2a558c3c7112", "filename": "src/test/ui/issue-14091-2.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-14091-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-14091-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-14091-2.rs?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: cannot apply unary operator `!` to type `BytePos`\n+//\n \n // Very\n \n@@ -23,4 +23,5 @@ fn main() {\n     let x = BytePos(1);\n \n     assert!(x, x);\n+    //~^ ERROR cannot apply unary operator `!` to type `BytePos`\n }", "previous_filename": "src/test/compile-fail/issue-14091-2.rs"}, {"sha": "ccabd801c85da8c169476c07441629c997fc56c2", "filename": "src/test/ui/issue-14091-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-14091-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a07f213974cee627a621c82e303b00ddaa8359e5/src%2Ftest%2Fui%2Fissue-14091-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-14091-2.stderr?ref=a07f213974cee627a621c82e303b00ddaa8359e5", "patch": "@@ -0,0 +1,11 @@\n+error[E0600]: cannot apply unary operator `!` to type `BytePos`\n+  --> $DIR/issue-14091-2.rs:25:5\n+   |\n+LL |     assert!(x, x);\n+   |     ^^^^^^^^^^^^^^ cannot apply unary operator `!`\n+   |\n+   = note: an implementation of `std::ops::Not` might be missing for `BytePos`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0600`."}]}