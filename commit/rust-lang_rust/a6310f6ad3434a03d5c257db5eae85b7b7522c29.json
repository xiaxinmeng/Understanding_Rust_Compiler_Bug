{"sha": "a6310f6ad3434a03d5c257db5eae85b7b7522c29", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MzEwZjZhZDM0MzRhMDNkNWMyNTdkYjVlYWU4NWI3Yjc1MjJjMjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-08T19:51:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-08T19:51:22Z"}, "message": "auto merge of #10477 : ktt3ja/rust/dead-code, r=alexcrichton\n\nPR for issue #1749 mainly to get some feedback and suggestion. This adds a pass that warns if a function, struct, enum, or static item is never used. For the following code,\r\n\r\n```rust\r\npub static pub_static: int = 0;\r\nstatic priv_static: int = 0;\r\nstatic used_static: int = 0;\r\n\r\npub fn pub_fn() { used_fn(); }\r\nfn priv_fn() { let unused_struct = PrivStruct; }\r\nfn used_fn() {}\r\n\r\npub struct PubStruct();\r\nstruct PrivStruct();\r\nstruct UsedStruct1 { x: int }\r\nstruct UsedStruct2(int);\r\nstruct UsedStruct3();\r\n\r\npub enum pub_enum { foo1, bar1 }\r\nenum priv_enum { foo2, bar2 }\r\nenum used_enum { foo3, bar3 }\r\n\r\nfn foo() {\r\n\tbar();\r\n\tlet unused_enum = foo2;\r\n}\r\n\r\nfn bar() {\r\n\tfoo();\r\n}\r\n\r\nfn main() {\r\n\tlet used_struct1 = UsedStruct1 { x: 1 };\r\n\tlet used_struct2 = UsedStruct2(1);\r\n\tlet used_struct3 = UsedStruct3;\r\n\tlet t = used_static;\r\n\tlet e = foo3;\r\n}\r\n```\r\n\r\nit would add the following warnings:\r\n\r\n```rust\r\n/home/ktt3ja/test.rs:2:0: 2:28 warning: code is never used: `priv_static`, #[warn(dead_code)] on by default\r\n/home/ktt3ja/test.rs:2 static priv_static: int = 0;\r\n                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/home/ktt3ja/test.rs:6:0: 6:48 warning: code is never used: `priv_fn`, #[warn(dead_code)] on by default\r\n/home/ktt3ja/test.rs:6 fn priv_fn() { let unused_struct = PrivStruct; }\r\n                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/home/ktt3ja/test.rs:10:0: 10:20 warning: code is never used: `PrivStruct`, #[warn(dead_code)] on by default\r\n/home/ktt3ja/test.rs:10 struct PrivStruct();\r\n                        ^~~~~~~~~~~~~~~~~~~~\r\n/home/ktt3ja/test.rs:16:0: 16:29 warning: code is never used: `priv_enum`, #[warn(dead_code)] on by default\r\n/home/ktt3ja/test.rs:16 enum priv_enum { foo2, bar2 }\r\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/home/ktt3ja/test.rs:19:0: 22:1 warning: code is never used: `foo`, #[warn(dead_code)] on by default\r\n/home/ktt3ja/test.rs:19 fn foo() {\r\n/home/ktt3ja/test.rs:20 \tbar();\r\n/home/ktt3ja/test.rs:21 \tlet unused_enum = foo2;\r\n/home/ktt3ja/test.rs:22 }\r\n/home/ktt3ja/test.rs:24:0: 26:1 warning: code is never used: `bar`, #[warn(dead_code)] on by default\r\n/home/ktt3ja/test.rs:24 fn bar() {\r\n/home/ktt3ja/test.rs:25 \tfoo();\r\n/home/ktt3ja/test.rs:26 }\r\n```\r\n\r\nFurthermore, I would like to solicit some test cases since I haven't tested extensively and I'm still unclear about some of the things in here. For example, I'm not sure how reexports would affect this and just assumed that LiveContext (which is a copy of reachable::ReachableContext) does enough work to handle it. Also, the test case above doesn't include any impl or methods, etc.", "tree": {"sha": "cc9478fa0b97bafcbf6b7eab427ae0abca4ca87e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc9478fa0b97bafcbf6b7eab427ae0abca4ca87e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6310f6ad3434a03d5c257db5eae85b7b7522c29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6310f6ad3434a03d5c257db5eae85b7b7522c29", "html_url": "https://github.com/rust-lang/rust/commit/a6310f6ad3434a03d5c257db5eae85b7b7522c29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6310f6ad3434a03d5c257db5eae85b7b7522c29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af6010ca0bfc0abf3f9e184cc33b9821c8453916", "url": "https://api.github.com/repos/rust-lang/rust/commits/af6010ca0bfc0abf3f9e184cc33b9821c8453916", "html_url": "https://github.com/rust-lang/rust/commit/af6010ca0bfc0abf3f9e184cc33b9821c8453916"}, {"sha": "1755408d1a58684b6c9bce11aeceb18a1ec2d66e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1755408d1a58684b6c9bce11aeceb18a1ec2d66e", "html_url": "https://github.com/rust-lang/rust/commit/1755408d1a58684b6c9bce11aeceb18a1ec2d66e"}], "stats": {"total": 1905, "additions": 722, "deletions": 1183}, "files": [{"sha": "5e3c38d01eb8148ad25cc93816ed290d3a35fa6d", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -192,10 +192,6 @@ pub fn opt_str2(maybestr: Option<~str>) -> ~str {\n     match maybestr { None => ~\"(none)\", Some(s) => { s } }\n }\n \n-pub fn str_opt(maybestr: ~str) -> Option<~str> {\n-    if maybestr != ~\"(none)\" { Some(maybestr) } else { None }\n-}\n-\n pub fn str_mode(s: ~str) -> mode {\n     match s {\n       ~\"compile-fail\" => mode_compile_fail,"}, {"sha": "dae5a1d342b43e71144f0b38b80250a8026a3a28", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -18,6 +18,7 @@ use header::TestProps;\n use header::load_props;\n use procsrv;\n use util::logv;\n+#[cfg(target_os = \"win32\")]\n use util;\n \n use std::io::File;\n@@ -482,6 +483,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         format!(\"{}:{}:\", testfile.display(), ee.line)\n     }).collect::<~[~str]>();\n \n+    #[cfg(target_os = \"win32\")]\n     fn to_lower( s : &str ) -> ~str {\n         let i = s.chars();\n         let c : ~[char] = i.map( |c| {\n@@ -822,6 +824,7 @@ fn make_cmdline(libpath: &str, prog: &str, args: &[~str]) -> ~str {\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n+#[cfg(target_os = \"win32\")]\n fn lib_path_cmd_prefix(path: &str) -> ~str {\n     format!(\"{}=\\\"{}\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n }"}, {"sha": "52081648978bfcf16d11a2a20114fbd907daaf8e", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -10,6 +10,7 @@\n \n use common::config;\n \n+#[cfg(target_os = \"win32\")]\n use std::os::getenv;\n \n /// Conversion table from triple OS name to Rust SYSNAME\n@@ -31,6 +32,7 @@ pub fn get_os(triple: &str) -> &'static str {\n     fail!(\"Cannot determine OS from triple\");\n }\n \n+#[cfg(target_os = \"win32\")]\n pub fn make_new_path(path: &str) -> ~str {\n \n     // Windows just uses PATH as the library search path, so we have to\n@@ -43,21 +45,9 @@ pub fn make_new_path(path: &str) -> ~str {\n     }\n }\n \n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"freebsd\")]\n-pub fn lib_path_env_var() -> ~str { ~\"LD_LIBRARY_PATH\" }\n-\n-#[cfg(target_os = \"macos\")]\n-pub fn lib_path_env_var() -> ~str { ~\"DYLD_LIBRARY_PATH\" }\n-\n #[cfg(target_os = \"win32\")]\n pub fn lib_path_env_var() -> ~str { ~\"PATH\" }\n \n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-pub fn path_div() -> ~str { ~\":\" }\n-\n #[cfg(target_os = \"win32\")]\n pub fn path_div() -> ~str { ~\";\" }\n "}, {"sha": "ab2556f24c6d3d66e71dedfd320ae247d9be4c6a", "filename": "src/etc/extract-tests.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Fetc%2Fextract-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Fetc%2Fextract-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fextract-tests.py?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -64,6 +64,7 @@\n #[ allow(dead_assignment) ];\\n\n #[ allow(unused_mut) ];\\n\n #[ allow(attribute_usage) ];\\n\n+#[ allow(dead_code) ];\\n\n #[ feature(macro_rules, globs, struct_variant, managed_boxes) ];\\n\n \"\"\" + block\n             if xfail:"}, {"sha": "c6102079b20e06d45eb03721ae20351a62d3d5fb", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -382,11 +382,9 @@ impl Bitv {\n     #[inline]\n     pub fn negate(&mut self) {\n         match self.rep {\n-            Small(ref mut b) => b.negate(),\n-            Big(ref mut s) => {\n-                s.each_storage(|w| { *w = !*w; true });\n-            }\n-      }\n+            Small(ref mut s) => s.negate(),\n+            Big(ref mut b) => b.negate(),\n+        }\n     }\n \n     /**"}, {"sha": "5a4547ffeb24adf03ba2db19b63f960b0816bb7a", "filename": "src/libextra/btree.rs", "status": "modified", "additions": 84, "deletions": 81, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbtree.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -14,15 +14,14 @@\n //! Starting implementation of a btree for rust.\n //! Structure inspired by github user davidhalperin's gist.\n \n-\n+#[allow(dead_code)];\n use std::util::replace;\n \n-\n ///A B-tree contains a root node (which contains a vector of elements),\n ///a length (the height of the tree), and lower and upper bounds on the\n ///number of elements that a given node can contain.\n #[allow(missing_doc)]\n-pub struct BTree<K, V>{\n+pub struct BTree<K, V> {\n     root: Node<K, V>,\n     len: uint,\n     lower_bound: uint,\n@@ -34,11 +33,11 @@ pub struct BTree<K, V>{\n //especially during insertions and deletions.\n //Using the swap or replace methods is one option for replacing dependence on Clone, or\n //changing the way in which the BTree is stored could also potentially work.\n-impl<K: Clone + TotalOrd, V: Clone> BTree<K, V>{\n+impl<K: Clone + TotalOrd, V: Clone> BTree<K, V> {\n \n     ///Returns new BTree with root node (leaf) and user-supplied lower bound\n-    fn new(k: K, v: V, lb: uint) -> BTree<K, V>{\n-        BTree{\n+    pub fn new(k: K, v: V, lb: uint) -> BTree<K, V> {\n+        BTree {\n             root: Node::new_leaf(~[LeafElt::new(k, v)]),\n             len: 1,\n             lower_bound: lb,\n@@ -48,8 +47,10 @@ impl<K: Clone + TotalOrd, V: Clone> BTree<K, V>{\n \n     ///Helper function for clone: returns new BTree with supplied root node,\n     ///length, and lower bound.  For use when the length is known already.\n-    fn new_with_node_len(n: Node<K, V>, length: uint, lb: uint) -> BTree<K, V>{\n-        BTree{\n+    pub fn new_with_node_len(n: Node<K, V>,\n+                             length: uint,\n+                             lb: uint) -> BTree<K, V> {\n+        BTree {\n             root: n,\n             len: length,\n             lower_bound: lb,\n@@ -59,35 +60,31 @@ impl<K: Clone + TotalOrd, V: Clone> BTree<K, V>{\n \n     ///Implements the Clone trait for the BTree.\n     ///Uses a helper function/constructor to produce a new BTree.\n-    fn clone(&self) -> BTree<K, V>{\n+    pub fn clone(&self) -> BTree<K, V> {\n         return BTree::new_with_node_len(self.root.clone(), self.len, self.lower_bound);\n     }\n \n     ///Returns the value of a given key, which may not exist in the tree.\n     ///Calls the root node's get method.\n-    fn get(self, k: K) -> Option<V>{\n+    pub fn get(self, k: K) -> Option<V> {\n         return self.root.get(k);\n     }\n \n     ///Checks to see if the key already exists in the tree, and if it is not,\n     ///the key-value pair is added to the tree by calling add on the root node.\n-    fn add(self, k: K, v: V) -> bool{\n+    pub fn add(self, k: K, v: V) -> bool {\n         let is_get = &self.clone().get(k.clone());\n         if is_get.is_some(){ return false; }\n-        else{\n+        else {\n             replace(&mut self.root.clone(),self.root.add(k.clone(), v));\n             return true;\n         }\n-\n     }\n-\n-\n-\n }\n \n-impl<K: ToStr + TotalOrd, V: ToStr> ToStr for BTree<K, V>{\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for BTree<K, V> {\n     ///Returns a string representation of the BTree\n-    fn to_str(&self) -> ~str{\n+    fn to_str(&self) -> ~str {\n         let ret = self.root.to_str();\n         ret\n     }\n@@ -99,14 +96,14 @@ impl<K: ToStr + TotalOrd, V: ToStr> ToStr for BTree<K, V>{\n //Branches contain BranchElts, which contain a left child (another node) and a key-value\n //pair.  Branches also contain the rightmost child of the elements in the array.\n //Leaves contain LeafElts, which do not have children.\n-enum Node<K, V>{\n+enum Node<K, V> {\n     LeafNode(Leaf<K, V>),\n     BranchNode(Branch<K, V>)\n }\n \n \n //Node functions/methods\n-impl<K: Clone + TotalOrd, V: Clone> Node<K, V>{\n+impl<K: Clone + TotalOrd, V: Clone> Node<K, V> {\n \n     ///Differentiates between leaf and branch nodes.\n     fn is_leaf(&self) -> bool{\n@@ -117,52 +114,56 @@ impl<K: Clone + TotalOrd, V: Clone> Node<K, V>{\n     }\n \n     ///Creates a new leaf node given a vector of elements.\n-    fn new_leaf(vec: ~[LeafElt<K, V>]) -> Node<K,V>{\n+    fn new_leaf(vec: ~[LeafElt<K, V>]) -> Node<K,V> {\n         LeafNode(Leaf::new(vec))\n     }\n \n     ///Creates a new branch node given a vector of an elements and a pointer to a rightmost child.\n-    fn new_branch(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Node<K, V>{\n+    fn new_branch(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Node<K, V> {\n         BranchNode(Branch::new(vec, right))\n     }\n \n \n     ///Returns the corresponding value to the provided key.\n     ///get() is called in different ways on a branch or a leaf.\n-    fn get(&self, k: K) -> Option<V>{\n-        match *self{\n+    fn get(&self, k: K) -> Option<V> {\n+        match *self {\n             LeafNode(ref leaf) => return leaf.get(k),\n             BranchNode(ref branch) => return branch.get(k)\n         }\n     }\n \n     ///A placeholder for add\n     ///Currently returns a leaf node with a single value (the added one)\n-    fn add(self, k: K, v: V) -> Node<K, V>{\n+    fn add(self, k: K, v: V) -> Node<K, V> {\n         return Node::new_leaf(~[LeafElt::new(k, v)]);\n     }\n }\n \n //Again, this might not be necessary in the future.\n-impl<K: Clone + TotalOrd, V: Clone> Clone for Node<K, V>{\n+impl<K: Clone + TotalOrd, V: Clone> Clone for Node<K, V> {\n \n     ///Returns a new node based on whether or not it is a branch or a leaf.\n-    fn clone(&self) -> Node<K, V>{\n-        match *self{\n-            LeafNode(ref leaf) => return Node::new_leaf(leaf.elts.clone()),\n-            BranchNode(ref branch) => return Node::new_branch(branch.elts.clone(),\n-                                                              branch.rightmost_child.clone())\n+    fn clone(&self) -> Node<K, V> {\n+        match *self {\n+            LeafNode(ref leaf) => {\n+                return Node::new_leaf(leaf.elts.clone());\n+            }\n+            BranchNode(ref branch) => {\n+                return Node::new_branch(branch.elts.clone(),\n+                                        branch.rightmost_child.clone());\n+            }\n         }\n     }\n }\n \n //The following impl is unfinished.  Old iterations of code are left in for\n //future reference when implementing this trait (commented-out).\n-impl<K: Clone + TotalOrd, V: Clone> TotalOrd for Node<K, V>{\n+impl<K: Clone + TotalOrd, V: Clone> TotalOrd for Node<K, V> {\n \n     ///Placeholder for an implementation of TotalOrd for Nodes.\n     #[allow(unused_variable)]\n-    fn cmp(&self, other: &Node<K, V>) -> Ordering{\n+    fn cmp(&self, other: &Node<K, V>) -> Ordering {\n         //Requires a match statement--defer these procs to branch and leaf.\n         /* if self.elts[0].less_than(other.elts[0]) { return Less}\n         if self.elts[0].greater_than(other.elts[0]) {return Greater}\n@@ -174,11 +175,11 @@ impl<K: Clone + TotalOrd, V: Clone> TotalOrd for Node<K, V>{\n \n //The following impl is unfinished.  Old iterations of code are left in for\n //future reference when implementing this trait (commented-out).\n-impl<K: Clone + TotalOrd, V: Clone> TotalEq for Node<K, V>{\n+impl<K: Clone + TotalOrd, V: Clone> TotalEq for Node<K, V> {\n \n     ///Placeholder for an implementation of TotalEq for Nodes.\n     #[allow(unused_variable)]\n-    fn equals(&self, other: &Node<K, V>) -> bool{\n+    fn equals(&self, other: &Node<K, V>) -> bool {\n         /* put in a match and defer this stuff to branch and leaf\n \n         let mut shorter = 0;\n@@ -202,11 +203,11 @@ impl<K: Clone + TotalOrd, V: Clone> TotalEq for Node<K, V>{\n }\n \n \n-impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Node<K, V>{\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Node<K, V> {\n     ///Returns a string representation of a Node.\n     ///The Branch's to_str() is not implemented yet.\n-    fn to_str(&self) -> ~str{\n-        match *self{\n+    fn to_str(&self) -> ~str {\n+        match *self {\n             LeafNode(ref leaf) => leaf.to_str(),\n             BranchNode(..) => ~\"\"\n         }\n@@ -216,31 +217,31 @@ impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Node<K, V>{\n \n //A leaf is a vector with elements that contain no children.  A leaf also\n //does not contain a rightmost child.\n-struct Leaf<K, V>{\n+struct Leaf<K, V> {\n     elts: ~[LeafElt<K, V>]\n }\n \n //Vector of values with children, plus a rightmost child (greater than all)\n-struct Branch<K, V>{\n+struct Branch<K, V> {\n     elts: ~[BranchElt<K,V>],\n     rightmost_child: ~Node<K, V>\n }\n \n \n-impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V>{\n+impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V> {\n \n     ///Creates a new Leaf from a vector of LeafElts.\n-    fn new(vec: ~[LeafElt<K, V>]) -> Leaf<K, V>{\n-        Leaf{\n+    fn new(vec: ~[LeafElt<K, V>]) -> Leaf<K, V> {\n+        Leaf {\n             elts: vec\n         }\n     }\n \n     ///Returns the corresponding value to the supplied key.\n-    fn get(&self, k: K) -> Option<V>{\n-        for s in self.elts.iter(){\n+    fn get(&self, k: K) -> Option<V> {\n+        for s in self.elts.iter() {\n             let order = s.key.cmp(&k);\n-            match order{\n+            match order {\n                 Equal => return Some(s.value.clone()),\n                 _ => {}\n             }\n@@ -250,18 +251,18 @@ impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V>{\n \n     ///Placeholder for add method in progress.\n     ///Currently returns a new Leaf containing a single LeafElt.\n-    fn add(&self, k: K, v: V) -> Node<K, V>{\n+    fn add(&self, k: K, v: V) -> Node<K, V> {\n         return Node::new_leaf(~[LeafElt::new(k, v)]);\n     }\n \n }\n \n-impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Leaf<K, V>{\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Leaf<K, V> {\n \n     ///Returns a string representation of a Leaf.\n-    fn to_str(&self) -> ~str{\n+    fn to_str(&self) -> ~str {\n         let mut ret = ~\"\";\n-        for s in self.elts.iter(){\n+        for s in self.elts.iter() {\n             ret = ret + \" // \" + s.to_str();\n         }\n         ret\n@@ -270,22 +271,22 @@ impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Leaf<K, V>{\n }\n \n \n-impl<K: Clone + TotalOrd, V: Clone> Branch<K, V>{\n+impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n \n     ///Creates a new Branch from a vector of BranchElts and a rightmost child (a node).\n-    fn new(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Branch<K, V>{\n-        Branch{\n+    fn new(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Branch<K, V> {\n+        Branch {\n             elts: vec,\n             rightmost_child: right\n         }\n     }\n \n     ///Returns the corresponding value to the supplied key.\n     ///If the key is not there, find the child that might hold it.\n-    fn get(&self, k: K) -> Option<V>{\n-        for s in self.elts.iter(){\n+    fn get(&self, k: K) -> Option<V> {\n+        for s in self.elts.iter() {\n             let order = s.key.cmp(&k);\n-            match order{\n+            match order {\n                 Less => return s.left.get(k),\n                 Equal => return Some(s.value.clone()),\n                 _ => {}\n@@ -296,90 +297,90 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V>{\n \n \n     ///Placeholder for add method in progress\n-    fn add(&self, k: K, v: V) -> Node<K, V>{\n+    fn add(&self, k: K, v: V) -> Node<K, V> {\n         return Node::new_leaf(~[LeafElt::new(k, v)]);\n     }\n }\n \n //A LeafElt containts no left child, but a key-value pair.\n-struct LeafElt<K, V>{\n+struct LeafElt<K, V> {\n     key: K,\n     value: V\n }\n \n //A BranchElt has a left child in addition to a key-value pair.\n-struct BranchElt<K, V>{\n+struct BranchElt<K, V> {\n     left: Node<K, V>,\n     key: K,\n     value: V\n }\n \n-impl<K: Clone + TotalOrd, V> LeafElt<K, V>{\n+impl<K: Clone + TotalOrd, V> LeafElt<K, V> {\n \n     ///Creates a new LeafElt from a supplied key-value pair.\n-    fn new(k: K, v: V) -> LeafElt<K, V>{\n-        LeafElt{\n+    fn new(k: K, v: V) -> LeafElt<K, V> {\n+        LeafElt {\n             key: k,\n             value: v\n         }\n     }\n \n     ///Compares another LeafElt against itself and determines whether\n     ///the original LeafElt's key is less than the other one's key.\n-    fn less_than(&self, other: LeafElt<K, V>) -> bool{\n+    fn less_than(&self, other: LeafElt<K, V>) -> bool {\n         let order = self.key.cmp(&other.key);\n-        match order{\n+        match order {\n             Less => true,\n             _ => false\n         }\n     }\n \n     ///Compares another LeafElt against itself and determines whether\n     ///the original LeafElt's key is greater than the other one's key.\n-    fn greater_than(&self, other: LeafElt<K, V>) -> bool{\n+    fn greater_than(&self, other: LeafElt<K, V>) -> bool {\n         let order = self.key.cmp(&other.key);\n-        match order{\n+        match order {\n             Greater => true,\n             _ => false\n         }\n     }\n \n     ///Takes a key and determines whether its own key and the supplied key\n     ///are the same.\n-    fn has_key(&self, other: K) -> bool{\n+    fn has_key(&self, other: K) -> bool {\n         let order = self.key.cmp(&other);\n-        match order{\n+        match order {\n             Equal => true,\n             _ => false\n         }\n     }\n-\n }\n \n //This may be eliminated in the future to perserve efficiency by adjusting the way\n //the BTree as a whole is stored in memory.\n-impl<K: Clone + TotalOrd, V: Clone> Clone for LeafElt<K, V>{\n+impl<K: Clone + TotalOrd, V: Clone> Clone for LeafElt<K, V> {\n \n     ///Returns a new LeafElt by cloning the key and value.\n-    fn clone(&self) -> LeafElt<K, V>{\n+    fn clone(&self) -> LeafElt<K, V> {\n         return LeafElt::new(self.key.clone(), self.value.clone());\n     }\n }\n \n-impl<K: ToStr + TotalOrd, V: ToStr> ToStr for LeafElt<K, V>{\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for LeafElt<K, V> {\n \n     ///Returns a string representation of a LeafElt.\n-    fn to_str(&self) -> ~str{\n-        return \"Key: \" + self.key.to_str() + \", value: \"+ self.value.to_str() + \"; \";\n+    fn to_str(&self) -> ~str {\n+        return \"Key: \" + self.key.to_str() + \", value: \"\n+                       + self.value.to_str() + \"; \";\n     }\n \n }\n \n-impl<K: Clone + TotalOrd, V: Clone> BranchElt<K, V>{\n+impl<K: Clone + TotalOrd, V: Clone> BranchElt<K, V> {\n \n     ///Creates a new BranchElt from a supplied key, value, and left child.\n-    fn new(k: K, v: V, n: Node<K, V>) -> BranchElt<K, V>{\n-        BranchElt{\n+    fn new(k: K, v: V, n: Node<K, V>) -> BranchElt<K, V> {\n+        BranchElt {\n             left: n,\n             key: k,\n             value: v\n@@ -388,16 +389,18 @@ impl<K: Clone + TotalOrd, V: Clone> BranchElt<K, V>{\n \n     ///Placeholder for add method in progress.\n     ///Overall implementation will determine the actual return value of this method.\n-    fn add(&self, k: K, v: V) -> LeafElt<K, V>{\n+    fn add(&self, k: K, v: V) -> LeafElt<K, V> {\n         return LeafElt::new(k, v);\n     }\n }\n \n-impl<K: Clone + TotalOrd, V: Clone> Clone for BranchElt<K, V>{\n+impl<K: Clone + TotalOrd, V: Clone> Clone for BranchElt<K, V> {\n \n     ///Returns a new BranchElt by cloning the key, value, and left child.\n-    fn clone(&self) -> BranchElt<K, V>{\n-        return BranchElt::new(self.key.clone(), self.value.clone(), self.left.clone());\n+    fn clone(&self) -> BranchElt<K, V> {\n+        return BranchElt::new(self.key.clone(),\n+                              self.value.clone(),\n+                              self.left.clone());\n     }\n }\n "}, {"sha": "5014c42f8d8e0ede438be12d95a92d8f672ed391", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -17,17 +17,6 @@ use std::str;\n //     http://www.matroska.org/technical/specs/rfc/index.html\n \n // Common data structures\n-struct EbmlTag {\n-    id: uint,\n-    size: uint,\n-}\n-\n-struct EbmlState {\n-    ebml_tag: EbmlTag,\n-    tag_pos: uint,\n-    data_pos: uint,\n-}\n-\n #[deriving(Clone)]\n pub struct Doc {\n     data: @~[u8],"}, {"sha": "5227cb18e6ea2fd6673920bc571818c06c7a5d29", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -39,10 +39,7 @@ pub mod rustrt {\n     }\n }\n \n-static LZ_NONE : c_int = 0x0;   // Huffman-coding only.\n-static LZ_FAST : c_int = 0x1;   // LZ with only one probe\n static LZ_NORM : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n-static LZ_BEST : c_int = 0xfff; // LZ with 4095 probes, \"best\"\n static TINFL_FLAG_PARSE_ZLIB_HEADER : c_int = 0x1; // parse zlib header and adler32 checksum\n static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler32 checksum\n "}, {"sha": "a869c4939cf879205231315bf5d52d35d78d8df1", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -57,7 +57,6 @@ pub mod BigDigit {\n     pub static bits: uint = 32;\n \n     pub static base: uint = 1 << bits;\n-    static hi_mask: uint = (-1 as uint) << bits;\n     static lo_mask: uint = (-1 as uint) >> bits;\n \n     #[inline]"}, {"sha": "21f905e772e24b345dff22f14964f8ed14a1c0cb", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -100,7 +100,7 @@ impl<T: Clone + Integer + Ord>\n     }\n \n     /// Return a `reduce`d copy of self.\n-    fn reduced(&self) -> Ratio<T> {\n+    pub fn reduced(&self) -> Ratio<T> {\n         let mut ret = self.clone();\n         ret.reduce();\n         ret"}, {"sha": "a8b8c094135957401a35ec868b5f7bdde75c761b", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -179,7 +179,6 @@ impl<'self, T:Clone + Ord + Eq> Sort for &'self mut [T] {\n \n static MIN_MERGE: uint = 64;\n static MIN_GALLOP: uint = 7;\n-static INITIAL_TMP_STORAGE: uint = 128;\n \n #[allow(missing_doc)]\n pub fn tim_sort<T:Clone + Ord>(array: &mut [T]) {"}, {"sha": "13b87b9730923835e2767fbf56ee49468a9d38bb", "filename": "src/libextra/url.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -364,16 +364,6 @@ fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     }\n }\n \n-fn userinfo_from_str(uinfo: &str) -> UserInfo {\n-    let (user, p) = split_char_first(uinfo, ':');\n-    let pass = if p.is_empty() {\n-        None\n-    } else {\n-        Some(p)\n-    };\n-    return UserInfo::new(user, pass);\n-}\n-\n fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n     match userinfo.pass {\n         Some(ref pass) => format!(\"{}:{}@\", userinfo.user, *pass),"}, {"sha": "e08726ad8a61cdef406183b62391353d5b37d878", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -310,6 +310,10 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         time(time_passes, \"reachability checking\", (), |_|\n              reachable::find_reachable(ty_cx, method_map, &exported_items));\n \n+    time(time_passes, \"death checking\", (), |_|\n+         middle::dead::check_crate(ty_cx, method_map,\n+                                   &exported_items, reachable_map, crate));\n+\n     time(time_passes, \"lint checking\", (), |_|\n          lint::check_crate(ty_cx, &exported_items, crate));\n \n@@ -510,19 +514,6 @@ pub fn pretty_print_input(sess: Session,\n                           cfg: ast::CrateConfig,\n                           input: &input,\n                           ppm: PpMode) {\n-    fn ann_typed_post(tcx: ty::ctxt, node: pprust::ann_node) {\n-        match node {\n-          pprust::node_expr(s, expr) => {\n-            pp::space(s.s);\n-            pp::word(s.s, \"as\");\n-            pp::space(s.s);\n-            pp::word(s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n-            pprust::pclose(s);\n-          }\n-          _ => ()\n-        }\n-    }\n-\n     let crate = phase_1_parse_input(sess, cfg.clone(), input);\n \n     let (crate, is_expanded) = match ppm {"}, {"sha": "2185617c79f0d38d497b71a582afdda4964f8e82", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -77,6 +77,7 @@ pub mod middle {\n     pub mod reachable;\n     pub mod graph;\n     pub mod cfg;\n+    pub mod dead;\n }\n \n pub mod front {"}, {"sha": "c6a1da655aadec2428414558a15951108f36a1d7", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 272, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -30,7 +30,6 @@ use std::u64;\n use std::io;\n use std::io::extensions::u64_from_be_bytes;\n use std::option;\n-use std::str;\n use std::vec;\n use extra::ebml::reader;\n use extra::ebml;\n@@ -523,212 +522,6 @@ pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n     })\n }\n \n-struct EachItemContext<'self> {\n-    intr: @ident_interner,\n-    cdata: Cmd,\n-    get_crate_data: GetCrateDataCb<'self>,\n-    path_builder: &'self mut ~str,\n-    callback: 'self |&str, DefLike, ast::visibility| -> bool,\n-}\n-\n-impl<'self> EachItemContext<'self> {\n-    // Pushes the given name and returns the old length.\n-    fn push_name(&mut self, string: &str) -> uint {\n-        let path_len = self.path_builder.len();\n-        if path_len != 0 {\n-            self.path_builder.push_str(\"::\")\n-        }\n-        self.path_builder.push_str(string);\n-        path_len\n-    }\n-\n-    // Pops the given name.\n-    fn pop_name(&mut self, old_len: uint) {\n-        // XXX(pcwalton): There's no safe function to do this. :(\n-        unsafe {\n-            str::raw::set_len(self.path_builder, old_len)\n-        }\n-    }\n-\n-    fn process_item_and_pop_name(&mut self,\n-                                 doc: ebml::Doc,\n-                                 def_id: ast::DefId,\n-                                 old_len: uint,\n-                                 vis: ast::visibility)\n-                                 -> bool {\n-        let def_like = item_to_def_like(doc, def_id, self.cdata.cnum);\n-        match def_like {\n-            DlDef(def) => {\n-                debug!(\"(iterating over each item of a module) processing \\\n-                        `{}` (def {:?})\",\n-                       *self.path_builder,\n-                       def);\n-            }\n-            _ => {\n-                debug!(\"(iterating over each item of a module) processing \\\n-                        `{}` ({}:{})\",\n-                       *self.path_builder,\n-                       def_id.crate,\n-                       def_id.node);\n-            }\n-        }\n-\n-        let mut continue_ = (self.callback)(*self.path_builder, def_like, vis);\n-\n-        let family = item_family(doc);\n-        if family == ForeignMod {\n-            // These are unnamed; pop the name now.\n-            self.pop_name(old_len)\n-        }\n-\n-        if continue_ {\n-            // Recurse if necessary.\n-            match family {\n-                Mod | ForeignMod | Trait | Impl => {\n-                    continue_ = self.each_item_of_module(def_id);\n-                }\n-                ImmStatic | MutStatic | Struct | UnsafeFn | Fn | ForeignFn |\n-                UnsafeStaticMethod | StaticMethod | Type | ForeignType |\n-                TupleVariant | StructVariant | Enum | PublicField |\n-                PrivateField | InheritedField => {}\n-            }\n-        }\n-\n-        if family != ForeignMod {\n-            self.pop_name(old_len)\n-        }\n-\n-        continue_\n-    }\n-\n-    fn each_item_of_module(&mut self, def_id: ast::DefId) -> bool {\n-        // This item might not be in this crate. If it's not, look it up.\n-        let items = if def_id.crate == self.cdata.cnum {\n-            reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n-        } else {\n-            let crate_data = (self.get_crate_data)(def_id.crate);\n-            let root = reader::Doc(crate_data.data);\n-            reader::get_doc(root, tag_items)\n-        };\n-\n-        // Look up the item.\n-        let item_doc = match maybe_find_item(def_id.node, items) {\n-            None => return false,\n-            Some(item_doc) => item_doc,\n-        };\n-\n-        self.each_child_of_module_or_crate(item_doc)\n-    }\n-\n-    fn each_child_of_module_or_crate(&mut self, item_doc: ebml::Doc) -> bool {\n-        let mut continue_ = true;\n-\n-        // Iterate over all children.\n-        reader::tagged_docs(item_doc, tag_mod_child, |child_info_doc| {\n-            let child_def_id = reader::with_doc_data(child_info_doc,\n-                                                     parse_def_id);\n-            let child_def_id = translate_def_id(self.cdata, child_def_id);\n-\n-            // This item may be in yet another crate, if it was the child of\n-            // a reexport.\n-            let other_crates_items = if child_def_id.crate ==\n-                    self.cdata.cnum {\n-                reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n-            } else {\n-                let crate_data = (self.get_crate_data)(child_def_id.crate);\n-                let root = reader::Doc(crate_data.data);\n-                reader::get_doc(root, tag_items)\n-            };\n-\n-            debug!(\"(iterating over each item of a module) looking up item \\\n-                    {}:{} in `{}`, crate {}\",\n-                   child_def_id.crate,\n-                   child_def_id.node,\n-                   *self.path_builder,\n-                   self.cdata.cnum);\n-\n-            // Get the item.\n-            match maybe_find_item(child_def_id.node, other_crates_items) {\n-                None => {}\n-                Some(child_item_doc) => {\n-                    // Push the name.\n-                    let child_name = item_name(self.intr, child_item_doc);\n-                    debug!(\"(iterating over each item of a module) pushing \\\n-                            name `{}` onto `{}`\",\n-                           token::ident_to_str(&child_name),\n-                           *self.path_builder);\n-                    let old_len =\n-                        self.push_name(token::ident_to_str(&child_name));\n-\n-                    // Process this item.\n-\n-                    let vis = item_visibility(child_item_doc);\n-                    continue_ = self.process_item_and_pop_name(child_item_doc,\n-                                                              child_def_id,\n-                                                              old_len,\n-                                                              vis);\n-                }\n-            }\n-            continue_\n-        });\n-\n-        if !continue_ {\n-            return false\n-        }\n-\n-        // Iterate over reexports.\n-        each_reexport(item_doc, |reexport_doc| {\n-            let def_id_doc = reader::get_doc(\n-                reexport_doc,\n-                tag_items_data_item_reexport_def_id);\n-            let orig_def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n-\n-            // NB: was \"cdata\"\n-            let def_id = translate_def_id(self.cdata, orig_def_id);\n-\n-            let name_doc = reader::get_doc(reexport_doc,\n-                                           tag_items_data_item_reexport_name);\n-            let name = name_doc.as_str_slice();\n-\n-            // Push the name.\n-            debug!(\"(iterating over each item of a module) pushing \\\n-                    reexported name `{}` onto `{}` (crate {}, orig {}, \\\n-                    in crate {})\",\n-                   name,\n-                   *self.path_builder,\n-                   def_id.crate,\n-                   orig_def_id.crate,\n-                   self.cdata.cnum);\n-            let old_len = self.push_name(name);\n-\n-            // This reexport may be in yet another crate.\n-            let other_crates_items = if def_id.crate == self.cdata.cnum {\n-                reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n-            } else {\n-                let crate_data = (self.get_crate_data)(def_id.crate);\n-                let root = reader::Doc(crate_data.data);\n-                reader::get_doc(root, tag_items)\n-            };\n-\n-            // Get the item.\n-            match maybe_find_item(def_id.node, other_crates_items) {\n-                None => { self.pop_name(old_len); }\n-                Some(reexported_item_doc) => {\n-                    continue_ = self.process_item_and_pop_name(\n-                        reexported_item_doc,\n-                        def_id,\n-                        old_len,\n-                        ast::public);\n-                }\n-            }\n-\n-            continue_\n-        });\n-\n-        continue_\n-    }\n-}\n-\n fn each_child_of_item_or_crate(intr: @ident_interner,\n                                cdata: Cmd,\n                                item_doc: ebml::Doc,\n@@ -1259,62 +1052,6 @@ pub fn get_item_visibility(cdata: Cmd, id: ast::NodeId)\n     item_visibility(lookup_item(id, cdata.data))\n }\n \n-fn family_has_type_params(fam: Family) -> bool {\n-    match fam {\n-      ImmStatic | ForeignType | Mod | ForeignMod | PublicField | PrivateField\n-      | ForeignFn | MutStatic => false,\n-      _           => true\n-    }\n-}\n-\n-fn family_names_type(fam: Family) -> bool {\n-    match fam { Type | Mod | Trait => true, _ => false }\n-}\n-\n-fn read_path(d: ebml::Doc) -> (~str, uint) {\n-    reader::with_doc_data(d, |desc| {\n-        let pos = u64_from_be_bytes(desc, 0u, 4u) as uint;\n-        let pathbytes = desc.slice_from(4u).to_owned();\n-        let path = str::from_utf8_owned(pathbytes);\n-\n-        (path, pos)\n-    })\n-}\n-\n-fn describe_def(items: ebml::Doc, id: ast::DefId) -> ~str {\n-    if id.crate != ast::LOCAL_CRATE { return ~\"external\"; }\n-    let it = match maybe_find_item(id.node, items) {\n-        Some(it) => it,\n-        None => fail!(\"describe_def: item not found {:?}\", id)\n-    };\n-    return item_family_to_str(item_family(it));\n-}\n-\n-fn item_family_to_str(fam: Family) -> ~str {\n-    match fam {\n-      ImmStatic => ~\"static\",\n-      MutStatic => ~\"static mut\",\n-      Fn => ~\"fn\",\n-      UnsafeFn => ~\"unsafe fn\",\n-      StaticMethod => ~\"static method\",\n-      UnsafeStaticMethod => ~\"unsafe static method\",\n-      ForeignFn => ~\"foreign fn\",\n-      Type => ~\"type\",\n-      ForeignType => ~\"foreign type\",\n-      Mod => ~\"mod\",\n-      ForeignMod => ~\"foreign mod\",\n-      Enum => ~\"enum\",\n-      StructVariant => ~\"struct variant\",\n-      TupleVariant => ~\"tuple variant\",\n-      Impl => ~\"impl\",\n-      Trait => ~\"trait\",\n-      Struct => ~\"struct\",\n-      PublicField => ~\"public field\",\n-      PrivateField => ~\"private field\",\n-      InheritedField => ~\"inherited field\",\n-    }\n-}\n-\n fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n     let mut items: ~[@ast::MetaItem] = ~[];\n     reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n@@ -1370,15 +1107,6 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n     return attrs;\n }\n \n-fn list_meta_items(intr: @ident_interner,\n-                   meta_items: ebml::Doc,\n-                   out: @mut io::Writer) {\n-    let r = get_meta_items(meta_items);\n-    for mi in r.iter() {\n-        write!(out, \"{}\\n\", pprust::meta_item_to_str(*mi, intr));\n-    }\n-}\n-\n fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n                          out: @mut io::Writer) {\n     write!(out, \"=Crate Attributes ({})=\\n\", hash);"}, {"sha": "e7bef48e5ddcfb3a3a30aca5ac4a78f18dbe8a59", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -128,20 +128,6 @@ struct entry<T> {\n     pos: u64\n }\n \n-fn add_to_index(ebml_w: &mut writer::Encoder,\n-                path: &[Ident],\n-                index: &mut ~[entry<~str>],\n-                name: Ident) {\n-    let mut full_path = ~[];\n-    full_path.push_all(path);\n-    full_path.push(name);\n-    index.push(\n-        entry {\n-            val: ast_util::path_name_i(full_path),\n-            pos: ebml_w.writer.tell()\n-        });\n-}\n-\n fn encode_trait_ref(ebml_w: &mut writer::Encoder,\n                     ecx: &EncodeContext,\n                     trait_ref: &ty::TraitRef,\n@@ -1442,10 +1428,6 @@ fn encode_index<T:'static>(\n     ebml_w.end_tag();\n }\n \n-fn write_str(writer: @mut MemWriter, s: ~str) {\n-    writer.write(s.as_bytes());\n-}\n-\n fn write_i64(writer: @mut MemWriter, &n: &i64) {\n     let wr: &mut MemWriter = writer;\n     assert!(n < 0x7fff_ffff);"}, {"sha": "5f9be5f5c421eabc8c9d1509ff392195293165d9", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -23,7 +23,6 @@ use syntax::abi::AbiSet;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast::*;\n-use syntax::codemap::dummy_sp;\n use syntax::opt_vec;\n \n // Compact string representation for ty::t values. API ty_str &\n@@ -130,34 +129,6 @@ pub fn parse_trait_ref_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tc\n     parse_trait_ref(&mut st, conv)\n }\n \n-fn parse_path(st: &mut PState) -> @ast::Path {\n-    let mut idents: ~[ast::Ident] = ~[];\n-    fn is_last(c: char) -> bool { return c == '(' || c == ':'; }\n-    idents.push(parse_ident_(st, is_last));\n-    loop {\n-        match peek(st) {\n-          ':' => { next(st); next(st); }\n-          c => {\n-            if c == '(' {\n-                return @ast::Path {\n-                    span: dummy_sp(),\n-                    global: false,\n-                    segments: idents.move_iter().map(|identifier| {\n-                        ast::PathSegment {\n-                            identifier: identifier,\n-                            lifetimes: opt_vec::Empty,\n-                            types: opt_vec::Empty,\n-                        }\n-                    }).collect()\n-                };\n-            } else {\n-                idents.push(parse_ident_(st, is_last));\n-            }\n-          }\n-        }\n-    };\n-}\n-\n fn parse_sigil(st: &mut PState) -> ast::Sigil {\n     match next(st) {\n         '@' => ast::ManagedSigil,"}, {"sha": "7a00afbc65234b6e9f4e7b31fd92cb4bc13314b1", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -57,13 +57,6 @@ fn mywrite(w: @mut MemWriter, fmt: &fmt::Arguments) {\n     fmt::write(&mut *w as &mut io::Writer, fmt);\n }\n \n-fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n-    match cx.abbrevs {\n-      ac_no_abbrevs => return false,\n-      ac_use_abbrevs(_) => return true\n-    }\n-}\n-\n pub fn enc_ty(w: @mut MemWriter, cx: @ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {"}, {"sha": "227c7d72d6beeb6fc100273d6b1ab89a6a801e65", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -390,10 +390,6 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn encode_def(ebml_w: &mut writer::Encoder, def: ast::Def) {\n-    def.encode(ebml_w)\n-}\n-\n fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::Def {\n     let mut dsr = reader::Decoder(doc);\n     let def: ast::Def = Decodable::decode(&mut dsr);"}, {"sha": "77dde581c33b882046c3db938d968a6e8c224409", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -84,44 +84,6 @@ enum MoveError {\n }\n \n impl<'self> CheckLoanCtxt<'self> {\n-    fn check_by_move_capture(&self,\n-                             closure_id: ast::NodeId,\n-                             cap_var: &moves::CaptureVar,\n-                             move_path: @LoanPath) {\n-        let move_err = self.analyze_move_out_from(closure_id, move_path);\n-        match move_err {\n-            MoveOk => {}\n-            MoveWhileBorrowed(loan_path, loan_span) => {\n-                self.bccx.span_err(\n-                    cap_var.span,\n-                    format!(\"cannot move `{}` into closure \\\n-                          because it is borrowed\",\n-                         self.bccx.loan_path_to_str(move_path)));\n-                self.bccx.span_note(\n-                    loan_span,\n-                    format!(\"borrow of `{}` occurs here\",\n-                         self.bccx.loan_path_to_str(loan_path)));\n-            }\n-        }\n-    }\n-\n-    fn check_captured_variables(&self, closure_id: ast::NodeId, span: Span) {\n-        let cap_vars = self.bccx.capture_map.get(&closure_id);\n-        for cap_var in cap_vars.iter() {\n-            let var_id = ast_util::def_id_of_def(cap_var.def).node;\n-            let var_path = @LpVar(var_id);\n-            self.check_if_path_is_moved(closure_id, span,\n-                                        MovedInCapture, var_path);\n-            match cap_var.mode {\n-                moves::CapRef | moves::CapCopy => {}\n-                moves::CapMove => {\n-                    self.check_by_move_capture(closure_id, cap_var, var_path);\n-                }\n-            }\n-        }\n-        return;\n-    }\n-\n     pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n     pub fn each_issued_loan(&self, scope_id: ast::NodeId, op: |&Loan| -> bool)"}, {"sha": "440664b36d8633463230359ad5bb34c909fe86f4", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -818,10 +818,6 @@ impl<'self> GatherLoanCtxt<'self> {\n         }\n     }\n \n-    pub fn pat_is_variant_or_struct(&self, pat: @ast::Pat) -> bool {\n-        pat_util::pat_is_variant_or_struct(self.bccx.tcx.def_map, pat)\n-    }\n-\n     pub fn pat_is_binding(&self, pat: @ast::Pat) -> bool {\n         pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n     }"}, {"sha": "965139931a0ec20377d071290c37ce82dcaf4ca8", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -50,10 +50,6 @@ struct RestrictionsContext<'self> {\n }\n \n impl<'self> RestrictionsContext<'self> {\n-    fn tcx(&self) -> ty::ctxt {\n-        self.bccx.tcx\n-    }\n-\n     fn restrict(&self,\n                 cmt: mc::cmt,\n                 restrictions: RestrictionSet) -> RestrictionResult {\n@@ -251,14 +247,4 @@ impl<'self> RestrictionsContext<'self> {\n                 cause);\n         }\n     }\n-\n-    fn check_no_mutability_control(&self,\n-                                   cmt: mc::cmt,\n-                                   restrictions: RestrictionSet) {\n-        if restrictions.intersects(RESTR_MUTATE | RESTR_FREEZE | RESTR_CLAIM) {\n-            self.bccx.report(BckError {span: self.span,\n-                                       cmt: cmt,\n-                                       code: err_freeze_aliasable_const});\n-        }\n-    }\n }"}, {"sha": "2327425c2ade0bee27d6ee9dca865622e24cbb40", "filename": "src/librustc/middle/dead.rs", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -0,0 +1,352 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This implements the dead-code warning pass. It follows middle::reachable\n+// closely. The idea is that all reachable symbols are live, codes called\n+// from live codes are live, and everything else is dead.\n+\n+use middle::ty;\n+use middle::typeck;\n+use middle::privacy;\n+use middle::lint::dead_code;\n+\n+use std::hashmap::HashSet;\n+use syntax::ast;\n+use syntax::ast_map;\n+use syntax::ast_util::{local_def, def_id_of_def, is_local};\n+use syntax::codemap;\n+use syntax::parse::token;\n+use syntax::visit::Visitor;\n+use syntax::visit;\n+\n+// Any local node that may call something in its body block should be\n+// explored. For example, if it's a live node_item that is a\n+// function, then we should explore its block to check for codes that\n+// may need to be marked as live.\n+fn should_explore(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n+    if !is_local(def_id) {\n+        return false;\n+    }\n+    match tcx.items.find(&def_id.node) {\n+        Some(&ast_map::node_item(..))\n+        | Some(&ast_map::node_method(..))\n+        | Some(&ast_map::node_trait_method(..)) => true,\n+        _ => false\n+    }\n+}\n+\n+struct MarkSymbolVisitor {\n+    worklist: ~[ast::NodeId],\n+    method_map: typeck::method_map,\n+    tcx: ty::ctxt,\n+    live_symbols: ~HashSet<ast::NodeId>,\n+}\n+\n+impl MarkSymbolVisitor {\n+    fn new(tcx: ty::ctxt,\n+           method_map: typeck::method_map,\n+           worklist: ~[ast::NodeId]) -> MarkSymbolVisitor {\n+        MarkSymbolVisitor {\n+            worklist: worklist,\n+            method_map: method_map,\n+            tcx: tcx,\n+            live_symbols: ~HashSet::new(),\n+        }\n+    }\n+\n+    fn lookup_and_handle_definition(&mut self, id: &ast::NodeId,\n+                                    span: codemap::Span) {\n+        let def = match self.tcx.def_map.find(id) {\n+            Some(&def) => def,\n+            None => self.tcx.sess.span_bug(span, \"def ID not in def map?!\"),\n+        };\n+        let def_id = match def {\n+            ast::DefVariant(enum_id, _, _) => Some(enum_id),\n+            ast::DefPrimTy(_) => None,\n+            _ => Some(def_id_of_def(def)),\n+        };\n+        match def_id {\n+            Some(def_id) => {\n+                if should_explore(self.tcx, def_id) {\n+                    self.worklist.push(def_id.node);\n+                }\n+                self.live_symbols.insert(def_id.node);\n+            }\n+            None => (),\n+        }\n+    }\n+\n+    fn mark_live_symbols(&mut self) {\n+        let mut scanned = HashSet::new();\n+        while self.worklist.len() > 0 {\n+            let id = self.worklist.pop();\n+            if scanned.contains(&id) {\n+                continue\n+            }\n+            scanned.insert(id);\n+            match self.tcx.items.find(&id) {\n+                Some(node) => {\n+                    self.live_symbols.insert(id);\n+                    self.visit_node(node);\n+                }\n+                None => (),\n+            }\n+        }\n+    }\n+\n+    fn visit_node(&mut self, node: &ast_map::ast_node) {\n+        match *node {\n+            ast_map::node_item(item, _) => {\n+                match item.node {\n+                    ast::item_fn(..)\n+                    | ast::item_ty(..)\n+                    | ast::item_static(..)\n+                    | ast::item_foreign_mod(_) => {\n+                        visit::walk_item(self, item, ());\n+                    }\n+                    _ => ()\n+                }\n+            }\n+            ast_map::node_trait_method(trait_method, _, _) => {\n+                visit::walk_trait_method(self, trait_method, ());\n+            }\n+            ast_map::node_method(method, _, _) => {\n+                visit::walk_block(self, method.body, ());\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+impl Visitor<()> for MarkSymbolVisitor {\n+\n+    fn visit_expr(&mut self, expr: @ast::Expr, _: ()) {\n+        match expr.node {\n+            ast::ExprPath(_) | ast::ExprStruct(..) => {\n+                self.lookup_and_handle_definition(&expr.id, expr.span);\n+            }\n+            ast::ExprMethodCall(..) => {\n+                match self.method_map.find(&expr.id) {\n+                    Some(&typeck::method_map_entry {\n+                        origin: typeck::method_static(def_id),\n+                        ..\n+                    }) => {\n+                        if should_explore(self.tcx, def_id) {\n+                            self.worklist.push(def_id.node);\n+                        }\n+                        self.live_symbols.insert(def_id.node);\n+                    }\n+                    Some(_) => (),\n+                    None => {\n+                        self.tcx.sess.span_bug(expr.span,\n+                                               \"method call expression not \\\n+                                                in method map?!\")\n+                    }\n+                }\n+            }\n+            _ => ()\n+        }\n+\n+        visit::walk_expr(self, expr, ())\n+    }\n+\n+    fn visit_ty(&mut self, typ: &ast::Ty, _: ()) {\n+        match typ.node {\n+            ast::ty_path(_, _, ref id) => {\n+                self.lookup_and_handle_definition(id, typ.span);\n+            }\n+            _ => visit::walk_ty(self, typ, ()),\n+        }\n+    }\n+\n+    fn visit_item(&mut self, _item: @ast::item, _: ()) {\n+        // Do not recurse into items. These items will be added to the\n+        // worklist and recursed into manually if necessary.\n+    }\n+}\n+\n+// This visitor is used to mark the implemented methods of a trait. Since we\n+// can not be sure if such methods are live or dead, we simply mark them\n+// as live.\n+struct TraitMethodSeeder {\n+    worklist: ~[ast::NodeId],\n+}\n+\n+impl Visitor<()> for TraitMethodSeeder {\n+    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+        match item.node {\n+            ast::item_impl(_, Some(ref _trait_ref), _, ref methods) => {\n+                for method in methods.iter() {\n+                    self.worklist.push(method.id);\n+                }\n+            }\n+            ast::item_mod(..) | ast::item_fn(..) => {\n+                visit::walk_item(self, item, ());\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+fn create_and_seed_worklist(tcx: ty::ctxt,\n+                            exported_items: &privacy::ExportedItems,\n+                            reachable_symbols: &HashSet<ast::NodeId>,\n+                            crate: &ast::Crate) -> ~[ast::NodeId] {\n+    let mut worklist = ~[];\n+\n+    // Preferably, we would only need to seed the worklist with reachable\n+    // symbols. However, since the set of reachable symbols differs\n+    // depending on whether a crate is built as bin or lib, and we want\n+    // the warning to be consistent, we also seed the worklist with\n+    // exported symbols.\n+    for &id in exported_items.iter() {\n+        worklist.push(id);\n+    }\n+    for &id in reachable_symbols.iter() {\n+        worklist.push(id);\n+    }\n+\n+    // Seed entry point\n+    match *tcx.sess.entry_fn {\n+        Some((id, _)) => worklist.push(id),\n+        None => ()\n+    }\n+\n+    // Seed implemeneted trait methods\n+    let mut trait_method_seeder = TraitMethodSeeder {\n+        worklist: worklist\n+    };\n+    visit::walk_crate(&mut trait_method_seeder, crate, ());\n+\n+    return trait_method_seeder.worklist;\n+}\n+\n+fn find_live(tcx: ty::ctxt,\n+             method_map: typeck::method_map,\n+             exported_items: &privacy::ExportedItems,\n+             reachable_symbols: &HashSet<ast::NodeId>,\n+             crate: &ast::Crate)\n+             -> ~HashSet<ast::NodeId> {\n+    let worklist = create_and_seed_worklist(tcx, exported_items,\n+                                            reachable_symbols, crate);\n+    let mut symbol_visitor = MarkSymbolVisitor::new(tcx, method_map, worklist);\n+    symbol_visitor.mark_live_symbols();\n+    symbol_visitor.live_symbols\n+}\n+\n+fn should_warn(item: @ast::item) -> bool {\n+    match item.node {\n+        ast::item_static(..)\n+        | ast::item_fn(..)\n+        | ast::item_enum(..)\n+        | ast::item_struct(..) => true,\n+        _ => false\n+    }\n+}\n+\n+fn get_struct_ctor_id(item: &ast::item) -> Option<ast::NodeId> {\n+    match item.node {\n+        ast::item_struct(struct_def, _) => struct_def.ctor_id,\n+        _ => None\n+    }\n+}\n+\n+struct DeadVisitor {\n+    tcx: ty::ctxt,\n+    live_symbols: ~HashSet<ast::NodeId>,\n+}\n+\n+impl DeadVisitor {\n+    // id := node id of an item's definition.\n+    // ctor_id := `Some` if the item is a struct_ctor (tuple struct),\n+    //            `None` otherwise.\n+    // If the item is a struct_ctor, then either its `id` or\n+    // `ctor_id` (unwrapped) is in the live_symbols set. More specifically,\n+    // DefMap maps the ExprPath of a struct_ctor to the node referred by\n+    // `ctor_id`. On the other hand, in a statement like\n+    // `type <ident> <generics> = <ty>;` where <ty> refers to a struct_ctor,\n+    // DefMap maps <ty> to `id` instead.\n+    fn symbol_is_live(&mut self, id: ast::NodeId,\n+                      ctor_id: Option<ast::NodeId>) -> bool {\n+        if self.live_symbols.contains(&id)\n+           || ctor_id.map_default(false,\n+                                  |ctor| self.live_symbols.contains(&ctor)) {\n+            return true;\n+        }\n+        // If it's a type whose methods are live, then it's live, too.\n+        // This is done to handle the case where, for example, the static\n+        // method of a private type is used, but the type itself is never\n+        // called directly.\n+        let def_id = local_def(id);\n+        match self.tcx.inherent_impls.find(&def_id) {\n+            None => (),\n+            Some(ref impl_list) => {\n+                for impl_ in impl_list.iter() {\n+                    for method in impl_.methods.iter() {\n+                        if self.live_symbols.contains(&method.def_id.node) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        false\n+    }\n+}\n+\n+impl Visitor<()> for DeadVisitor {\n+    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+        let ctor_id = get_struct_ctor_id(item);\n+        if !self.symbol_is_live(item.id, ctor_id) && should_warn(item) {\n+            self.tcx.sess.add_lint(dead_code, item.id, item.span,\n+                                   format!(\"code is never used: `{}`\",\n+                                           token::ident_to_str(&item.ident)));\n+        }\n+        visit::walk_item(self, item, ());\n+    }\n+\n+    fn visit_fn(&mut self, fk: &visit::fn_kind,\n+                _: &ast::fn_decl, block: ast::P<ast::Block>,\n+                span: codemap::Span, id: ast::NodeId, _: ()) {\n+        // Have to warn method here because methods are not ast::item\n+        match *fk {\n+            visit::fk_method(..) => {\n+                let ident = visit::name_of_fn(fk);\n+                if !self.symbol_is_live(id, None) {\n+                    self.tcx.sess\n+                            .add_lint(dead_code, id, span,\n+                                      format!(\"code is never used: `{}`\",\n+                                              token::ident_to_str(&ident)));\n+                }\n+            }\n+            _ => ()\n+        }\n+        visit::walk_block(self, block, ());\n+    }\n+\n+    // Overwrite so that we don't warn the trait method itself.\n+    fn visit_trait_method(&mut self, trait_method :&ast::trait_method, _: ()) {\n+        match *trait_method {\n+            ast::provided(method) => visit::walk_block(self, method.body, ()),\n+            ast::required(_) => ()\n+        }\n+    }\n+}\n+\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: typeck::method_map,\n+                   exported_items: &privacy::ExportedItems,\n+                   reachable_symbols: &HashSet<ast::NodeId>,\n+                   crate: &ast::Crate) {\n+    let live_symbols = find_live(tcx, method_map, exported_items,\n+                                 reachable_symbols, crate);\n+    let mut visitor = DeadVisitor { tcx: tcx, live_symbols: live_symbols };\n+    visit::walk_crate(&mut visitor, crate, ());\n+}"}, {"sha": "195f7798eb0f5b5f7572c90235264c20680a85e1", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -411,20 +411,6 @@ pub fn check_trait_cast_bounds(cx: &Context, sp: Span, ty: ty::t,\n     });\n }\n \n-fn is_nullary_variant(cx: &Context, ex: @Expr) -> bool {\n-    match ex.node {\n-      ExprPath(_) => {\n-        match cx.tcx.def_map.get_copy(&ex.id) {\n-          DefVariant(edid, vdid, _) => {\n-              ty::enum_variant_with_id(cx.tcx, edid, vdid).args.is_empty()\n-          }\n-          _ => false\n-        }\n-      }\n-      _ => false\n-    }\n-}\n-\n fn check_imm_free_var(cx: &Context, def: Def, sp: Span) {\n     match def {\n         DefLocal(_, BindByValue(MutMutable)) => {\n@@ -585,8 +571,4 @@ pub fn check_cast_for_escaping_regions(\n             _ => false\n         }\n     }\n-\n-    fn is_subregion_of(cx: &Context, r_sub: ty::Region, r_sup: ty::Region) -> bool {\n-        cx.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n-    }\n }"}, {"sha": "3e6803feadbfd39de1e9cb28171651078727bd8f", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -88,6 +88,7 @@ pub enum lint {\n     dead_assignment,\n     unused_mut,\n     unnecessary_allocation,\n+    dead_code,\n \n     missing_doc,\n     unreachable_code,\n@@ -282,6 +283,13 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: warn\n     }),\n \n+    (\"dead_code\",\n+     LintSpec {\n+        lint: dead_code,\n+        desc: \"detect piece of code that will never be used\",\n+        default: warn\n+    }),\n+\n     (\"missing_doc\",\n      LintSpec {\n         lint: missing_doc,"}, {"sha": "55f054b0661fa1061eeca97696c561033a6945a5", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -578,7 +578,7 @@ static ACC_USE: uint = 4u;\n \n type LiveNodeMap = @mut HashMap<NodeId, LiveNode>;\n \n-struct Liveness {\n+pub struct Liveness {\n     tcx: ty::ctxt,\n     ir: @mut IrMaps,\n     s: Specials,\n@@ -625,37 +625,10 @@ impl Liveness {\n         }\n     }\n \n-    pub fn variable_from_path(&self, expr: &Expr) -> Option<Variable> {\n-        match expr.node {\n-          ExprPath(_) => {\n-            let def = self.tcx.def_map.get_copy(&expr.id);\n-            moves::moved_variable_node_id_from_def(def).map(|rdef| {\n-                self.variable(rdef, expr.span)\n-            })\n-          }\n-          _ => None\n-        }\n-    }\n-\n     pub fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n         self.ir.variable(node_id, span)\n     }\n \n-    pub fn variable_from_def_map(&self, node_id: NodeId, span: Span)\n-                                 -> Option<Variable> {\n-        match self.tcx.def_map.find(&node_id) {\n-          Some(&def) => {\n-            moves::moved_variable_node_id_from_def(def).map(|rdef| {\n-                self.variable(rdef, span)\n-            })\n-          }\n-          None => {\n-            self.tcx.sess.span_bug(\n-                span, \"Not present in def map\")\n-          }\n-        }\n-    }\n-\n     pub fn pat_bindings(&self,\n                         pat: @Pat,\n                         f: |LiveNode, Variable, Span, NodeId|) {\n@@ -730,13 +703,6 @@ impl Liveness {\n         self.assigned_on_entry(self.successors[*ln], var)\n     }\n \n-    pub fn indices(&self, ln: LiveNode, op: |uint|) {\n-        let node_base_idx = self.idx(ln, Variable(0));\n-        for var_idx in range(0u, self.ir.num_vars) {\n-            op(node_base_idx + var_idx)\n-        }\n-    }\n-\n     pub fn indices2(&self,\n                     ln: LiveNode,\n                     succ_ln: LiveNode,"}, {"sha": "d665d279a17596656f2d82eff13175dc286c5417", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -57,13 +57,6 @@ fn item_might_be_inlined(item: @ast::item) -> bool {\n     }\n }\n \n-// Returns true if the given type method must be inlined because it may be\n-// monomorphized or it was marked with `#[inline]`.\n-fn ty_method_might_be_inlined(ty_method: &ast::TypeMethod) -> bool {\n-    attributes_specify_inlining(ty_method.attrs) ||\n-        generics_require_inlining(&ty_method.generics)\n-}\n-\n fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::method,\n                            impl_src: ast::DefId) -> bool {\n     if attributes_specify_inlining(method.attrs) ||\n@@ -83,15 +76,6 @@ fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::method,\n     }\n }\n \n-// Returns true if the given trait method must be inlined because it may be\n-// monomorphized or it was marked with `#[inline]`.\n-fn trait_method_might_be_inlined(trait_method: &ast::trait_method) -> bool {\n-    match *trait_method {\n-        ast::required(ref ty_method) => ty_method_might_be_inlined(ty_method),\n-        ast::provided(_) => true\n-    }\n-}\n-\n // Information needed while computing reachability.\n struct ReachableContext {\n     // The type context."}, {"sha": "d2454be4fa06390a94f70ba61cb8b7e062bdbe04", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -52,12 +52,6 @@ type BindingMap = HashMap<Name,binding_info>;\n // Trait method resolution\n pub type TraitMap = HashMap<NodeId,@mut ~[DefId]>;\n \n-// A summary of the generics on a trait.\n-struct TraitGenerics {\n-    has_lifetime: bool,\n-    type_parameter_count: uint,\n-}\n-\n // This is the replacement export map. It maps a module to all of the exports\n // within.\n pub type ExportMap2 = @mut HashMap<NodeId, ~[Export2]>;\n@@ -141,12 +135,6 @@ enum NameDefinition {\n     ImportNameDefinition(Def, LastPrivate) //< The name identifies an import.\n }\n \n-#[deriving(Eq)]\n-enum Mutability {\n-    Mutable,\n-    Immutable\n-}\n-\n enum SelfBinding {\n     NoSelfBinding,\n     HasSelfBinding(NodeId, explicit_self)\n@@ -192,9 +180,6 @@ enum ResolveResult<T> {\n }\n \n impl<T> ResolveResult<T> {\n-    fn failed(&self) -> bool {\n-        match *self { Failed => true, _ => false }\n-    }\n     fn indeterminate(&self) -> bool {\n         match *self { Indeterminate => true, _ => false }\n     }\n@@ -5432,6 +5417,7 @@ impl Resolver {\n         return self.idents_to_str(idents.move_rev_iter().collect::<~[ast::Ident]>());\n     }\n \n+    #[allow(dead_code)]   // useful for debugging\n     fn dump_module(&mut self, module_: @mut Module) {\n         debug!(\"Dump of module `{}`:\", self.module_to_str(module_));\n "}, {"sha": "ac67045c241daf1bd62dc230e530aad1922288b6", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -49,8 +49,6 @@ use middle::trans::type_::Type;\n use syntax::ast;\n use syntax::abi::AbiSet;\n use syntax::ast_map;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n \n // Represents a (possibly monomorphized) top-level fn item or method\n // item.  Note that this is just the fn-ptr and is not a Rust closure\n@@ -569,27 +567,6 @@ pub fn trans_lang_call_with_type_params(bcx: @mut Block,\n         ArgVals(args), Some(dest), DontAutorefArg).bcx;\n }\n \n-\n-struct CalleeTranslationVisitor {\n-    flag: bool,\n-}\n-\n-impl Visitor<()> for CalleeTranslationVisitor {\n-\n-    fn visit_item(&mut self, _:@ast::item, _:()) { }\n-\n-    fn visit_expr(&mut self, e:@ast::Expr, _:()) {\n-\n-            if !self.flag {\n-                match e.node {\n-                  ast::ExprRet(_) => self.flag = true,\n-                  _ => visit::walk_expr(self, e, ()),\n-                }\n-            }\n-    }\n-\n-}\n-\n pub fn trans_call_inner(in_cx: @mut Block,\n                         call_info: Option<NodeInfo>,\n                         callee_ty: ty::t,"}, {"sha": "37346715d28483c2aa4036e353d4b2d02e8f9cc0", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -117,12 +117,12 @@ use syntax::parse::token::special_idents;\n static DW_LANG_RUST: c_uint = 0x9000;\n \n static DW_TAG_auto_variable: c_uint = 0x100;\n-static DW_TAG_arg_variable: c_uint = 0x101;\n+// static DW_TAG_arg_variable: c_uint = 0x101;\n \n static DW_ATE_boolean: c_uint = 0x02;\n static DW_ATE_float: c_uint = 0x04;\n static DW_ATE_signed: c_uint = 0x05;\n-static DW_ATE_signed_char: c_uint = 0x06;\n+// static DW_ATE_signed_char: c_uint = 0x06;\n static DW_ATE_unsigned: c_uint = 0x07;\n static DW_ATE_unsigned_char: c_uint = 0x08;\n \n@@ -1169,13 +1169,6 @@ enum RecursiveTypeDescription {\n \n impl RecursiveTypeDescription {\n \n-    fn metadata(&self) -> DICompositeType {\n-        match *self {\n-            UnfinishedMetadata { metadata_stub, .. } => metadata_stub,\n-            FinalMetadata(metadata) => metadata\n-        }\n-    }\n-\n     fn finalize(&self, cx: &mut CrateContext) -> DICompositeType {\n         match *self {\n             FinalMetadata(metadata) => metadata,\n@@ -1982,24 +1975,6 @@ fn trait_metadata(cx: &mut CrateContext,\n                                    definition_span);\n }\n \n-fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n-    debug!(\"unimplemented_type_metadata: {:?}\", ty::get(t));\n-\n-    let name = ppaux::ty_to_str(cx.tcx, t);\n-    let metadata = format!(\"NYI<{}>\", name).with_c_str(|name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateBasicType(\n-                DIB(cx),\n-                name,\n-                0_u64,\n-                8_u64,\n-                DW_ATE_unsigned as c_uint)\n-            }\n-        });\n-\n-    return metadata;\n-}\n-\n fn cache_id_for_type(t: ty::t) -> uint {\n     ty::type_id(t)\n }\n@@ -2179,11 +2154,6 @@ fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n //  Utility Functions\n //=-------------------------------------------------------------------------------------------------\n \n-#[inline]\n-fn roundup(x: uint, a: uint) -> uint {\n-    ((x + (a - 1)) / a) * a\n-}\n-\n /// Return codemap::Loc corresponding to the beginning of the span\n fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n     cx.sess.codemap.lookup_char_pos(span.lo)"}, {"sha": "a66e6f90ac763c69b1719ba5fe8a8117c35dff83", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -176,12 +176,6 @@ impl Dest {\n     }\n }\n \n-fn drop_and_cancel_clean(bcx: @mut Block, dat: Datum) -> @mut Block {\n-    let bcx = dat.drop_val(bcx);\n-    dat.cancel_clean(bcx);\n-    return bcx;\n-}\n-\n pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     debug!(\"trans_to_datum(expr={})\", bcx.expr_to_str(expr));\n \n@@ -1792,10 +1786,6 @@ fn trans_assign_op(bcx: @mut Block,\n     return result_datum.copy_to_datum(bcx, DROP_EXISTING, dst_datum);\n }\n \n-fn shorten(x: &str) -> @str {\n-    (if x.char_len() > 60 {x.slice_chars(0, 60)} else {x}).to_managed()\n-}\n-\n pub fn trans_log_level(bcx: @mut Block) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_log_level\");\n     let ccx = bcx.ccx();"}, {"sha": "c2003e0849f2f4937c64c38d449a365a488db787", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -1765,7 +1765,7 @@ def_type_content_sets!(\n \n         // Things that are interior to the value (first nibble):\n         InteriorUnsized                     = 0b0000__00000000__0001,\n-        InteriorAll                         = 0b0000__00000000__1111,\n+        // InteriorAll                         = 0b0000__00000000__1111,\n \n         // Things that are owned by the value (second and third nibbles):\n         OwnsOwned                           = 0b0000__00000001__0000,\n@@ -1777,7 +1777,7 @@ def_type_content_sets!(\n         // Things that are reachable by the value in any way (fourth nibble):\n         ReachesNonsendAnnot                 = 0b0001__00000000__0000,\n         ReachesBorrowed                     = 0b0010__00000000__0000,\n-        ReachesManaged /* see [1] below */  = 0b0100__00000000__0000,\n+        // ReachesManaged /* see [1] below */  = 0b0100__00000000__0000,\n         ReachesMutable                      = 0b1000__00000000__0000,\n         ReachesAll                          = 0b1111__00000000__0000,\n \n@@ -3631,30 +3631,6 @@ pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n     }\n }\n \n-/// Returns the def ID of the constructor for the given tuple-like struct, or\n-/// None if the struct is not tuple-like. Fails if the given def ID does not\n-/// refer to a struct at all.\n-fn struct_ctor_id(cx: ctxt, struct_did: ast::DefId) -> Option<ast::DefId> {\n-    if struct_did.crate != ast::LOCAL_CRATE {\n-        // XXX: Cross-crate functionality.\n-        cx.sess.unimpl(\"constructor ID of cross-crate tuple structs\");\n-    }\n-\n-    match cx.items.find(&struct_did.node) {\n-        Some(&ast_map::node_item(item, _)) => {\n-            match item.node {\n-                ast::item_struct(struct_def, _) => {\n-                    struct_def.ctor_id.map(|ctor_id| {\n-                        ast_util::local_def(ctor_id)\n-                    })\n-                }\n-                _ => cx.sess.bug(\"called struct_ctor_id on non-struct\")\n-            }\n-        }\n-        _ => cx.sess.bug(\"called struct_ctor_id on non-struct\")\n-    }\n-}\n-\n // Enum information\n #[deriving(Clone)]\n pub struct VariantInfo {"}, {"sha": "dbbdba520ab93a74d86a190f4092629ccc049658", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -692,13 +692,6 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn report_type_error(&mut self,\n-                         origin: SubregionOrigin,\n-                         terr: &ty::type_err) {\n-        let terr_str = ty::type_err_to_str(self.tcx, terr);\n-        self.tcx.sess.span_err(origin.span(), terr_str);\n-    }\n-\n     fn intersect_scopes(&self,\n                         region_a: ty::Region,\n                         region_b: ty::Region,"}, {"sha": "2b3db1e0a89aa222c525b61d63a14b9a25cf006e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -12,7 +12,7 @@\n use metadata::encoder;\n use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n-use middle::ty::{BrFresh, ctxt, field};\n+use middle::ty::{BrFresh, ctxt};\n use middle::ty::{mt, t, param_ty};\n use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region,\n                  ReEmpty};\n@@ -432,16 +432,6 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n             }\n         }\n     }\n-    fn method_to_str(cx: ctxt, m: ty::Method) -> ~str {\n-        bare_fn_to_str(cx,\n-                       m.fty.purity,\n-                       m.fty.abis,\n-                       Some(m.ident),\n-                       &m.fty.sig) + \";\"\n-    }\n-    fn field_to_str(cx: ctxt, f: field) -> ~str {\n-        return format!(\"{}: {}\", cx.sess.str_of(f.ident), mt_to_str(cx, &f.mt));\n-    }\n \n     // if there is an id, print that instead of the structural type:\n     /*for def_id in ty::type_def_id(typ).iter() {"}, {"sha": "ab9fabb08415a28d3d2a169ff137caa8570caf8b", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -305,15 +305,6 @@ pub struct Generics {\n     type_params: ~[TyParam]\n }\n \n-impl Generics {\n-    fn new() -> Generics {\n-        Generics {\n-            lifetimes: ~[],\n-            type_params: ~[]\n-        }\n-    }\n-}\n-\n impl Clean<Generics> for ast::Generics {\n     fn clean(&self) -> Generics {\n         Generics {"}, {"sha": "09b4ade381466833485576395df2c5127cebc798", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -122,10 +122,6 @@ pub fn render<T: fmt::Default, S: fmt::Default>(\n     );\n }\n \n-fn boolstr(b: bool) -> &'static str {\n-    if b { \"true\" } else { \"false\" }\n-}\n-\n fn nonestr<'a>(s: &'a str) -> &'a str {\n     if s == \"\" { \"none\" } else { s }\n }"}, {"sha": "e91be32227e074c8c09849c2a8a168b3f6c20c6c", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -38,9 +38,6 @@ static MKDEXT_TABLES: libc::c_uint = 1 << 1;\n static MKDEXT_FENCED_CODE: libc::c_uint = 1 << 2;\n static MKDEXT_AUTOLINK: libc::c_uint = 1 << 3;\n static MKDEXT_STRIKETHROUGH: libc::c_uint = 1 << 4;\n-static MKDEXT_SPACE_HEADERS: libc::c_uint = 1 << 6;\n-static MKDEXT_SUPERSCRIPT: libc::c_uint = 1 << 7;\n-static MKDEXT_LAX_SPACING: libc::c_uint = 1 << 8;\n \n type sd_markdown = libc::c_void;  // this is opaque to us\n "}, {"sha": "023bba15f97a192a5db4a175c866be9944171a1c", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -19,22 +19,10 @@ condition! {\n     pub bad_path: (Path, ~str) -> Path;\n }\n \n-condition! {\n-    pub bad_stat: (Path, ~str) -> FileStat;\n-}\n-\n-condition! {\n-    pub bad_kind: (~str) -> ();\n-}\n-\n condition! {\n     pub nonexistent_package: (PkgId, ~str) -> Path;\n }\n \n-condition! {\n-    pub copy_failed: (Path, Path) -> ();\n-}\n-\n condition! {\n     pub missing_pkg_files: (PkgId) -> ();\n }\n@@ -43,10 +31,6 @@ condition! {\n     pub bad_pkg_id: (Path, ~str) -> PkgId;\n }\n \n-condition! {\n-    pub no_rust_path: (~str) -> Path;\n-}\n-\n condition! {\n     pub failed_to_create_temp_dir: (~str) -> Path;\n }"}, {"sha": "345638386b2ad64885f0f5e5d00d6954fef32a7d", "filename": "src/librustpkg/crate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Fcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Fcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcrate.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(dead_code)];\n+\n use std::path::Path;\n use std::vec;\n "}, {"sha": "7801742bc910bb37423678b8df51316ba930ec73", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -63,10 +63,9 @@ mod crate;\n pub mod exit_codes;\n mod installed_packages;\n mod messages;\n-mod package_id;\n-mod package_source;\n+pub mod package_id;\n+pub mod package_source;\n mod path_util;\n-mod search;\n mod sha1;\n mod source_control;\n mod target;\n@@ -189,10 +188,6 @@ impl<'self> PkgScript<'self> {\n             (cfgs, output.status)\n         }\n     }\n-\n-    fn hash(&self) -> ~str {\n-        self.id.hash()\n-    }\n }\n \n pub trait CtxMethods {\n@@ -924,12 +919,3 @@ pub fn main_args(args: &[~str]) -> int {\n     if result.is_err() { return COPY_FAILED_CODE; }\n     return 0;\n }\n-\n-fn declare_package_script_dependency(prep: &mut workcache::Prep, pkg_src: &PkgSrc) {\n-    match pkg_src.package_script_option() {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        Some(ref p) => prep.declare_input(\"file\", p.as_str().unwrap(),\n-                                      workcache_support::digest_file_with_date(p)),\n-        None => ()\n-    }\n-}"}, {"sha": "4865003cb5e9f99a9210b5fdedede4498f2b49ef", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -321,11 +321,6 @@ impl PkgSrc {\n         }\n     }\n \n-    /// True if the given path's stem is self's pkg ID's stem\n-    fn stem_matches(&self, p: &Path) -> bool {\n-        p.filestem().map_default(false, |p| { p == self.id.short_name.as_bytes() })\n-    }\n-\n     pub fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n         let mut it = p.components().peekable();\n         if prefix > 0 {"}, {"sha": "4b5e1ce87277cdf6744945f06e113daee74951af", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -10,6 +10,8 @@\n \n // rustpkg utilities having to do with paths and directories\n \n+#[allow(dead_code)];\n+\n pub use package_id::PkgId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n pub use version::{Version, NoVersion, split_version_general, try_parsing_version};"}, {"sha": "aec4e95f8e21c5201a1f0d6d769d8386e3441a42", "filename": "src/librustpkg/search.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/af6010ca0bfc0abf3f9e184cc33b9821c8453916/src%2Flibrustpkg%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af6010ca0bfc0abf3f9e184cc33b9821c8453916/src%2Flibrustpkg%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsearch.rs?ref=af6010ca0bfc0abf3f9e184cc33b9821c8453916", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use path_util::{installed_library_in_workspace, rust_path};\n-use version::Version;\n-\n-/// If some workspace `p` in the RUST_PATH contains a package matching short_name,\n-/// return Some(p) (returns the first one of there are multiple matches.) Return\n-/// None if there's no such path.\n-/// FIXME #8711: This ignores the desired version.\n-pub fn find_installed_library_in_rust_path(pkg_path: &Path, _version: &Version) -> Option<Path> {\n-    let rp = rust_path();\n-    debug!(\"find_installed_library_in_rust_path: looking for path {}\",\n-            pkg_path.display());\n-    for p in rp.iter() {\n-        match installed_library_in_workspace(pkg_path, p) {\n-            Some(path) => return Some(path),\n-            None => ()\n-        }\n-    }\n-    None\n-}"}, {"sha": "73c305be798e259f89745df36372cd696fd3ad74", "filename": "src/librustpkg/target.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftarget.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -79,6 +79,7 @@ fn file_is(p: &Path, stem: &str) -> bool {\n     }\n }\n \n+#[allow(dead_code)]\n pub fn lib_name_of(p: &Path) -> Path {\n     p.join(\"lib.rs\")\n }"}, {"sha": "3f6d5b55066278098cf614df6798435d9056a75a", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(dead_code)];\n+\n use std::libc;\n use std::os;\n use std::io;"}, {"sha": "95fc667727240bbb0f0fc7279e8e9220299a7eb4", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -54,10 +54,6 @@ pub fn pkg_parent_workspaces(cx: &Context, pkgid: &PkgId) -> ~[Path] {\n     }\n }\n \n-pub fn is_workspace(p: &Path) -> bool {\n-    p.join(\"src\").is_dir()\n-}\n-\n /// Construct a workspace and package-ID name based on the current directory.\n /// This gets used when rustpkg gets invoked without a package-ID argument.\n pub fn cwd_to_workspace() -> Option<(Path, PkgId)> {"}, {"sha": "1e69f3e7050fa92301b239a03e73ccf0fad1079f", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -370,14 +370,6 @@ impl Drop for TcpListener {\n     }\n }\n \n-extern fn listener_close_cb(handle: *uvll::uv_handle_t) {\n-    let tcp: &mut TcpListener = unsafe { UvHandle::from_uv_handle(&handle) };\n-    unsafe { uvll::free_handle(handle) }\n-\n-    let sched: ~Scheduler = Local::take();\n-    sched.resume_blocked_task_immediately(tcp.closing_task.take_unwrap());\n-}\n-\n // TCP acceptors (bound servers)\n \n impl HomingIO for TcpAcceptor {"}, {"sha": "d6b78fa853c03945dca2560af8011a9565f9f7ea", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -141,10 +141,6 @@ impl Drop for PipeWatcher {\n     }\n }\n \n-extern fn pipe_close_cb(handle: *uvll::uv_handle_t) {\n-    unsafe { uvll::free_handle(handle) }\n-}\n-\n // PipeListener implementation and traits\n \n impl PipeListener {"}, {"sha": "fd439eb05e2d795b5aa336d415263fb71e926123", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -91,107 +91,6 @@ impl<A:IterBytes> Hash for A {\n     }\n }\n \n-fn hash_keyed_2<A: IterBytes,\n-                B: IterBytes>(a: &A, b: &B, k0: u64, k1: u64) -> u64 {\n-    let mut s = State::new(k0, k1);\n-    a.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    b.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    s.result_u64()\n-}\n-\n-fn hash_keyed_3<A: IterBytes,\n-                B: IterBytes,\n-                C: IterBytes>(a: &A, b: &B, c: &C, k0: u64, k1: u64) -> u64 {\n-    let mut s = State::new(k0, k1);\n-    a.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    b.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    c.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    s.result_u64()\n-}\n-\n-fn hash_keyed_4<A: IterBytes,\n-                B: IterBytes,\n-                C: IterBytes,\n-                D: IterBytes>(\n-                a: &A,\n-                b: &B,\n-                c: &C,\n-                d: &D,\n-                k0: u64,\n-                k1: u64)\n-                -> u64 {\n-    let mut s = State::new(k0, k1);\n-    a.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    b.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    c.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    d.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    s.result_u64()\n-}\n-\n-fn hash_keyed_5<A: IterBytes,\n-                B: IterBytes,\n-                C: IterBytes,\n-                D: IterBytes,\n-                E: IterBytes>(\n-                a: &A,\n-                b: &B,\n-                c: &C,\n-                d: &D,\n-                e: &E,\n-                k0: u64,\n-                k1: u64)\n-                -> u64 {\n-    let mut s = State::new(k0, k1);\n-    a.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    b.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    c.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    d.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    e.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    s.result_u64()\n-}\n-\n #[inline]\n pub fn default_state() -> State {\n     State::new(0, 0)"}, {"sha": "f9cf847621e1e7287571a5e94b1ac33cb9e51f23", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -12,7 +12,7 @@ use option::Option;\n use comm::{GenericPort, GenericChan};\n use super::{Reader, Writer};\n \n-struct PortReader<P>;\n+pub struct PortReader<P>;\n \n impl<P: GenericPort<~[u8]>> PortReader<P> {\n     pub fn new(_port: P) -> PortReader<P> { fail!() }\n@@ -24,7 +24,7 @@ impl<P: GenericPort<~[u8]>> Reader for PortReader<P> {\n     fn eof(&mut self) -> bool { fail!() }\n }\n \n-struct ChanWriter<C>;\n+pub struct ChanWriter<C>;\n \n impl<C: GenericChan<~[u8]>> ChanWriter<C> {\n     pub fn new(_chan: C) -> ChanWriter<C> { fail!() }\n@@ -34,7 +34,7 @@ impl<C: GenericChan<~[u8]>> Writer for ChanWriter<C> {\n     fn write(&mut self, _buf: &[u8]) { fail!() }\n }\n \n-struct ReaderPort<R>;\n+pub struct ReaderPort<R>;\n \n impl<R: Reader> ReaderPort<R> {\n     pub fn new(_reader: R) -> ReaderPort<R> { fail!() }\n@@ -46,7 +46,7 @@ impl<R: Reader> GenericPort<~[u8]> for ReaderPort<R> {\n     fn try_recv(&self) -> Option<~[u8]> { fail!() }\n }\n \n-struct WriterChan<W>;\n+pub struct WriterChan<W>;\n \n impl<W: Writer> WriterChan<W> {\n     pub fn new(_writer: W) -> WriterChan<W> { fail!() }"}, {"sha": "7b5104657d9dc8c5fc839f38f0bd2956b3db6264", "filename": "src/libstd/io/native/file.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Ffile.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -756,10 +756,6 @@ pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n #[cfg(windows)]\n fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n     let path = unsafe { CString::new(path.with_ref(|p| p), false) };\n-\n-    // FileStat times are in milliseconds\n-    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n-\n     let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n         libc::S_IFREG => io::TypeFile,\n         libc::S_IFDIR => io::TypeDirectory,"}, {"sha": "00b26116e678a3ad2c3ff56ec025165c38992294", "filename": "src/libstd/io/native/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fio%2Fnative%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fio%2Fnative%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Fmod.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -100,6 +100,7 @@ fn mkerr_libc(ret: libc::c_int) -> IoResult<()> {\n }\n \n // windows has zero values as errors\n+#[cfg(windows)]\n fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> {\n     if ret == 0 {\n         Err(last_error())"}, {"sha": "8cebc49be7c28be43cb573ac147a8fe3f0af2a11", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -1690,7 +1690,7 @@ impl<T> Fuse<T> {\n     /// Resets the fuse such that the next call to .next() or .next_back() will\n     /// call the underlying iterator again even if it prevously returned None.\n     #[inline]\n-    fn reset_fuse(&mut self) {\n+    pub fn reset_fuse(&mut self) {\n         self.done = false\n     }\n }"}, {"sha": "4eef3323403228d3d73c385a79533b9643faf83c", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -57,7 +57,7 @@ delegate!(\n     fn log2(n: f32) -> f32 = intrinsics::log2f32,\n     fn mul_add(a: f32, b: f32, c: f32) -> f32 = intrinsics::fmaf32,\n     fn pow(n: f32, e: f32) -> f32 = intrinsics::powf32,\n-    fn powi(n: f32, e: c_int) -> f32 = intrinsics::powif32,\n+    // fn powi(n: f32, e: c_int) -> f32 = intrinsics::powif32,\n     fn sin(n: f32) -> f32 = intrinsics::sinf32,\n     fn sqrt(n: f32) -> f32 = intrinsics::sqrtf32,\n \n@@ -79,25 +79,25 @@ delegate!(\n     fn cbrt(n: c_float) -> c_float = c_float_utils::cbrt,\n     fn copysign(x: c_float, y: c_float) -> c_float = c_float_utils::copysign,\n     fn cosh(n: c_float) -> c_float = c_float_utils::cosh,\n-    fn erf(n: c_float) -> c_float = c_float_utils::erf,\n-    fn erfc(n: c_float) -> c_float = c_float_utils::erfc,\n+    // fn erf(n: c_float) -> c_float = c_float_utils::erf,\n+    // fn erfc(n: c_float) -> c_float = c_float_utils::erfc,\n     fn exp_m1(n: c_float) -> c_float = c_float_utils::exp_m1,\n     fn abs_sub(a: c_float, b: c_float) -> c_float = c_float_utils::abs_sub,\n     fn next_after(x: c_float, y: c_float) -> c_float = c_float_utils::next_after,\n     fn frexp(n: c_float, value: &mut c_int) -> c_float = c_float_utils::frexp,\n     fn hypot(x: c_float, y: c_float) -> c_float = c_float_utils::hypot,\n     fn ldexp(x: c_float, n: c_int) -> c_float = c_float_utils::ldexp,\n-    fn lgamma(n: c_float, sign: &mut c_int) -> c_float = c_float_utils::lgamma,\n-    fn log_radix(n: c_float) -> c_float = c_float_utils::log_radix,\n+    // fn lgamma(n: c_float, sign: &mut c_int) -> c_float = c_float_utils::lgamma,\n+    // fn log_radix(n: c_float) -> c_float = c_float_utils::log_radix,\n     fn ln_1p(n: c_float) -> c_float = c_float_utils::ln_1p,\n-    fn ilog_radix(n: c_float) -> c_int = c_float_utils::ilog_radix,\n-    fn modf(n: c_float, iptr: &mut c_float) -> c_float = c_float_utils::modf,\n+    // fn ilog_radix(n: c_float) -> c_int = c_float_utils::ilog_radix,\n+    // fn modf(n: c_float, iptr: &mut c_float) -> c_float = c_float_utils::modf,\n     fn round(n: c_float) -> c_float = c_float_utils::round,\n-    fn ldexp_radix(n: c_float, i: c_int) -> c_float = c_float_utils::ldexp_radix,\n+    // fn ldexp_radix(n: c_float, i: c_int) -> c_float = c_float_utils::ldexp_radix,\n     fn sinh(n: c_float) -> c_float = c_float_utils::sinh,\n     fn tan(n: c_float) -> c_float = c_float_utils::tan,\n-    fn tanh(n: c_float) -> c_float = c_float_utils::tanh,\n-    fn tgamma(n: c_float) -> c_float = c_float_utils::tgamma\n+    fn tanh(n: c_float) -> c_float = c_float_utils::tanh\n+    // fn tgamma(n: c_float) -> c_float = c_float_utils::tgamma\n )\n \n // These are not defined inside consts:: for consistency with"}, {"sha": "1668019409e460c7a786b5c21808421f804ebc36", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -59,7 +59,7 @@ delegate!(\n     fn log2(n: f64) -> f64 = intrinsics::log2f64,\n     fn mul_add(a: f64, b: f64, c: f64) -> f64 = intrinsics::fmaf64,\n     fn pow(n: f64, e: f64) -> f64 = intrinsics::powf64,\n-    fn powi(n: f64, e: c_int) -> f64 = intrinsics::powif64,\n+    // fn powi(n: f64, e: c_int) -> f64 = intrinsics::powif64,\n     fn sin(n: f64) -> f64 = intrinsics::sinf64,\n     fn sqrt(n: f64) -> f64 = intrinsics::sqrtf64,\n \n@@ -81,21 +81,21 @@ delegate!(\n     fn cbrt(n: c_double) -> c_double = c_double_utils::cbrt,\n     fn copysign(x: c_double, y: c_double) -> c_double = c_double_utils::copysign,\n     fn cosh(n: c_double) -> c_double = c_double_utils::cosh,\n-    fn erf(n: c_double) -> c_double = c_double_utils::erf,\n-    fn erfc(n: c_double) -> c_double = c_double_utils::erfc,\n+    // fn erf(n: c_double) -> c_double = c_double_utils::erf,\n+    // fn erfc(n: c_double) -> c_double = c_double_utils::erfc,\n     fn exp_m1(n: c_double) -> c_double = c_double_utils::exp_m1,\n     fn abs_sub(a: c_double, b: c_double) -> c_double = c_double_utils::abs_sub,\n     fn next_after(x: c_double, y: c_double) -> c_double = c_double_utils::next_after,\n     fn frexp(n: c_double, value: &mut c_int) -> c_double = c_double_utils::frexp,\n     fn hypot(x: c_double, y: c_double) -> c_double = c_double_utils::hypot,\n     fn ldexp(x: c_double, n: c_int) -> c_double = c_double_utils::ldexp,\n     fn lgamma(n: c_double, sign: &mut c_int) -> c_double = c_double_utils::lgamma,\n-    fn log_radix(n: c_double) -> c_double = c_double_utils::log_radix,\n+    // fn log_radix(n: c_double) -> c_double = c_double_utils::log_radix,\n     fn ln_1p(n: c_double) -> c_double = c_double_utils::ln_1p,\n-    fn ilog_radix(n: c_double) -> c_int = c_double_utils::ilog_radix,\n-    fn modf(n: c_double, iptr: &mut c_double) -> c_double = c_double_utils::modf,\n+    // fn ilog_radix(n: c_double) -> c_int = c_double_utils::ilog_radix,\n+    // fn modf(n: c_double, iptr: &mut c_double) -> c_double = c_double_utils::modf,\n     fn round(n: c_double) -> c_double = c_double_utils::round,\n-    fn ldexp_radix(n: c_double, i: c_int) -> c_double = c_double_utils::ldexp_radix,\n+    // fn ldexp_radix(n: c_double, i: c_int) -> c_double = c_double_utils::ldexp_radix,\n     fn sinh(n: c_double) -> c_double = c_double_utils::sinh,\n     fn tan(n: c_double) -> c_double = c_double_utils::tan,\n     fn tanh(n: c_double) -> c_double = c_double_utils::tanh,"}, {"sha": "ff93931086598d4c83bfbd62138907a0c47e33bf", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -32,6 +32,7 @@\n use c_str::CString;\n use clone::Clone;\n use container::Container;\n+#[cfg(target_os = \"macos\")]\n use iter::range;\n use libc;\n use libc::{c_char, c_void, c_int, size_t};\n@@ -338,12 +339,6 @@ pub fn pipe() -> Pipe {\n     }\n }\n \n-fn dup2(src: c_int, dst: c_int) -> c_int {\n-    unsafe {\n-        libc::dup2(src, dst)\n-    }\n-}\n-\n /// Returns the proper dll filename for the given basename of a file.\n pub fn dll_filename(base: &str) -> ~str {\n     format!(\"{}{}{}\", DLL_PREFIX, base, DLL_SUFFIX)\n@@ -708,6 +703,7 @@ pub fn set_exit_status(code: int) {\n     rt::set_exit_status(code);\n }\n \n+#[cfg(target_os = \"macos\")]\n unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n     let mut args = ~[];\n     for i in range(0u, argc as uint) {\n@@ -787,10 +783,6 @@ extern \"system\" {\n     fn CommandLineToArgvW(lpCmdLine: LPCWSTR, pNumArgs: *mut c_int) -> **u16;\n }\n \n-struct OverriddenArgs {\n-    val: ~[~str]\n-}\n-\n /// Returns the arguments which this program was started with (normally passed\n /// via the command line).\n pub fn args() -> ~[~str] {"}, {"sha": "b7a0d685f124cc83c23982b85957564e68b9a459", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -1049,11 +1049,6 @@ fn prefix_len(p: Option<PathPrefix>) -> uint {\n     }\n }\n \n-fn prefix_is_sep(p: Option<PathPrefix>, c: u8) -> bool {\n-    c.is_ascii() && if !prefix_is_verbatim(p) { is_sep(c as char) }\n-                    else { is_sep_verbatim(c as char) }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "3a33fb182aa73ad0e612ceb96881afd85d3d22a5", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -886,6 +886,7 @@ mod test {\n     }\n }\n \n+#[cfg(test)]\n static RAND_BENCH_N: u64 = 100;\n \n #[cfg(test)]"}, {"sha": "311138d15a2b958a2212ce1dae55cf445c560991", "filename": "src/libstd/rt/basic.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Frt%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Frt%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbasic.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -37,17 +37,6 @@ struct BasicLoop {\n \n enum Message { RunRemote(uint), RemoveRemote(uint) }\n \n-struct Time {\n-    sec: u64,\n-    nsec: u64,\n-}\n-\n-impl Ord for Time {\n-    fn lt(&self, other: &Time) -> bool {\n-        self.sec < other.sec || self.nsec < other.nsec\n-    }\n-}\n-\n impl BasicLoop {\n     fn new() -> BasicLoop {\n         BasicLoop {\n@@ -238,14 +227,3 @@ impl Drop for BasicPausible {\n         }\n     }\n }\n-\n-fn time() -> Time {\n-    extern {\n-        fn rust_get_time(sec: &mut i64, nsec: &mut i32);\n-    }\n-    let mut sec = 0;\n-    let mut nsec = 0;\n-    unsafe { rust_get_time(&mut sec, &mut nsec) }\n-\n-    Time { sec: sec as u64, nsec: nsec as u64 }\n-}"}, {"sha": "2386a261bdf82132ece92997189facee4ec10d2e", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -25,7 +25,9 @@ use unstable::intrinsics::TyDesc;\n use unstable::raw;\n \n // This has no meaning with out rtdebug also turned on.\n+#[cfg(rtdebug)]\n static TRACK_ALLOCATIONS: int = 0;\n+#[cfg(rtdebug)]\n static MAGIC: u32 = 0xbadc0ffe;\n \n pub type Box = raw::Box<()>;"}, {"sha": "be3b5f951ebc454a7dfa13bcccde4946febf5ccd", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -15,6 +15,8 @@\n //! XXX: Add runtime checks for usage of inconsistent pointer types.\n //! and for overwriting an existing pointer.\n \n+#[allow(dead_code)];\n+\n use cast;\n use cell::Cell;\n use unstable::finally::Finally;"}, {"sha": "d5affdd51735cd5fe335bac0e53c686f8086ec9a", "filename": "src/libstd/rt/thread_local_storage.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(dead_code)];\n+\n use libc::c_void;\n #[cfg(unix)]\n use libc::c_int;"}, {"sha": "2447bba98d697d921316f52c95b87e46c723cb4d", "filename": "src/libstd/run.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -183,7 +183,10 @@ impl Process {\n         self.inner.io[0].take();\n     }\n \n-    fn close_outputs(&mut self) {\n+    /**\n+     * Closes the handle to stdout and stderr.\n+     */\n+    pub fn close_outputs(&mut self) {\n         self.inner.io[1].take();\n         self.inner.io[2].take();\n     }"}, {"sha": "144500fac5d962e941d3021c0e649de9b241c1f7", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -12,6 +12,7 @@\n \n #[allow(missing_doc)];\n #[allow(non_uppercase_statics)];\n+#[allow(dead_code)];\n \n pub mod general_category {\n "}, {"sha": "d8e437fda811802acbf2d253ccbc3937f384965f", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -35,6 +35,7 @@ pub enum UnsafeArcUnwrap<T> {\n     UnsafeArcT(T)\n }\n \n+#[cfg(test)]\n impl<T> UnsafeArcUnwrap<T> {\n     fn expect_t(self, msg: &'static str) -> T {\n         match self {"}, {"sha": "ac89689f00478abcc7a4e56a02997bc42ba9ac86", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -448,13 +448,6 @@ impl CodeMap {\n         };\n     }\n \n-    fn span_to_str_no_adj(&self, sp: Span) -> ~str {\n-        let lo = self.lookup_char_pos(sp.lo);\n-        let hi = self.lookup_char_pos(sp.hi);\n-        return format!(\"{}:{}:{}: {}:{}\", lo.file.name,\n-                    lo.line, lo.col.to_uint(), hi.line, hi.col.to_uint())\n-    }\n-\n     fn lookup_byte_offset(&self, bpos: BytePos)\n         -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);"}, {"sha": "af86091084a704ca2c984871b618c7e51abd3efe", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -201,15 +201,7 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n         } as @SyntaxExpanderTTTrait,\n         None))\n     }\n-    // utility function to simplify creating IdentTT syntax extensions\n-    // that ignore their contexts\n-    fn builtin_item_tt_no_ctxt(f: SyntaxExpanderTTItemFunNoCtxt) -> @Transformer {\n-        @SE(IdentTT(@SyntaxExpanderTTItem {\n-            expander: SyntaxExpanderTTItemExpanderWithoutContext(f),\n-            span: None,\n-        } as @SyntaxExpanderTTItemTrait,\n-        None))\n-    }\n+\n     let mut syntax_expanders = HashMap::new();\n     // NB identifier starts with space, and can't conflict with legal idents\n     syntax_expanders.insert(intern(&\" block\"),"}, {"sha": "a6e45c7e1bbb38d923a7b097dc8f55d217564ebe", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 39, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{P, Block, Crate, DeclLocal, Expr_, ExprMac, SyntaxContext};\n+use ast::{P, Block, Crate, DeclLocal, ExprMac, SyntaxContext};\n use ast::{Local, Ident, mac_invoc_tt};\n use ast::{item_mac, Mrk, Stmt, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n use ast::{token_tree};\n@@ -21,7 +21,6 @@ use codemap;\n use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use ext::base::*;\n use fold::*;\n-use opt_vec;\n use parse;\n use parse::{parse_item_from_source_str};\n use parse::token;\n@@ -140,29 +139,6 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n \n             let span = e.span;\n \n-            fn mk_expr(_: @ExtCtxt, span: Span, node: Expr_)\n-                           -> @ast::Expr {\n-                @ast::Expr {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: node,\n-                    span: span,\n-                }\n-            }\n-\n-            fn mk_simple_path(ident: ast::Ident, span: Span) -> ast::Path {\n-                ast::Path {\n-                    span: span,\n-                    global: false,\n-                    segments: ~[\n-                        ast::PathSegment {\n-                            identifier: ident,\n-                            lifetimes: opt_vec::Empty,\n-                            types: opt_vec::Empty,\n-                        }\n-                    ],\n-                }\n-            }\n-\n             // to:\n             //\n             // {\n@@ -714,14 +690,6 @@ pub fn renames_to_fold(renames: @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n     } as @ast_fold\n }\n \n-// perform a bunch of renames\n-fn apply_pending_renames(folder : @ast_fold, stmt : ast::Stmt) -> @ast::Stmt {\n-    folder.fold_stmt(&stmt)\n-            .expect_one(\"renaming of stmt did not produce one stmt\")\n-}\n-\n-\n-\n pub fn new_span(cx: @ExtCtxt, sp: Span) -> Span {\n     /* this discards information in the case of macro-defining macros */\n     Span {\n@@ -739,6 +707,7 @@ pub fn std_macros() -> @str {\n @r#\"mod __std_macros {\n     #[macro_escape];\n     #[doc(hidden)];\n+    #[allow(dead_code)];\n \n     macro_rules! ignore (($($x:tt)*) => (()))\n \n@@ -900,6 +869,7 @@ pub fn std_macros() -> @str {\n             mod $c {\n                 #[allow(unused_imports)];\n                 #[allow(non_uppercase_statics)];\n+                #[allow(dead_code)];\n \n                 use super::*;\n \n@@ -979,12 +949,6 @@ pub fn inject_std_macros(parse_sess: @mut parse::ParseSess,\n     injector.fold_crate(c)\n }\n \n-struct NoOpFolder {\n-    contents: (),\n-}\n-\n-impl ast_fold for NoOpFolder {}\n-\n pub struct MacroExpander {\n     extsbox: @mut SyntaxEnv,\n     cx: @ExtCtxt,"}, {"sha": "9193a9cee17d23009229b2b555a989974c0d4459", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -331,7 +331,12 @@ impl Context {\n         let unnamed = self.ecx.meta_word(self.fmtsp, @\"address_insignificant\");\n         let unnamed = self.ecx.attribute(self.fmtsp, unnamed);\n \n-        return ~[unnamed];\n+        // Do not warn format string as dead code\n+        let dead_code = self.ecx.meta_word(self.fmtsp, @\"dead_code\");\n+        let allow_dead_code = self.ecx.meta_list(self.fmtsp,\n+                                                 @\"allow\", ~[dead_code]);\n+        let allow_dead_code = self.ecx.attribute(self.fmtsp, allow_dead_code);\n+        return ~[unnamed, allow_dead_code];\n     }\n \n     /// Translate a `parse::Piece` to a static `rt::Piece`"}, {"sha": "0c6eb6a94a8be0ba27c11189a46586ff96a089bb", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use codemap::{BytePos, Pos, Span};\n+use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::base;\n use ext::build::AstBuilder;\n@@ -357,12 +357,6 @@ fn mk_ident(cx: @ExtCtxt, sp: Span, ident: ast::Ident) -> @ast::Expr {\n                         ~[e_str])\n }\n \n-fn mk_bytepos(cx: @ExtCtxt, sp: Span, bpos: BytePos) -> @ast::Expr {\n-    let path = id_ext(\"BytePos\");\n-    let arg = cx.expr_uint(sp, bpos.to_uint());\n-    cx.expr_call_ident(sp, path, ~[arg])\n-}\n-\n fn mk_binop(cx: @ExtCtxt, sp: Span, bop: token::binop) -> @ast::Expr {\n     let name = match bop {\n         PLUS => \"PLUS\","}, {"sha": "3547fa8251b030aaf010512485638b2abf5b0b0e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -541,20 +541,6 @@ fn fold_struct_def<T:ast_fold>(struct_def: @ast::struct_def, fld: &T)\n     }\n }\n \n-fn noop_fold_view_item(vi: &view_item_, fld: @ast_fold) -> view_item_ {\n-    match *vi {\n-        view_item_extern_mod(ident, name, ref meta_items, node_id) => {\n-            view_item_extern_mod(ident,\n-                                 name,\n-                                 fld.fold_meta_items(*meta_items),\n-                                 fld.new_id(node_id))\n-        }\n-        view_item_use(ref view_paths) => {\n-            view_item_use(fld.fold_view_paths(*view_paths))\n-        }\n-    }\n-}\n-\n fn fold_trait_ref<T:ast_fold>(p: &trait_ref, fld: &T) -> trait_ref {\n     ast::trait_ref {\n         path: fld.fold_path(&p.path),\n@@ -589,14 +575,6 @@ fn fold_mt<T:ast_fold>(mt: &mt, folder: &T) -> mt {\n     }\n }\n \n-fn fold_field<T:ast_fold>(f: TypeField, folder: &T) -> TypeField {\n-    ast::TypeField {\n-        ident: folder.fold_ident(f.ident),\n-        mt: fold_mt(&f.mt, folder),\n-        span: folder.new_span(f.span),\n-    }\n-}\n-\n fn fold_opt_bounds<T:ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &T)\n                                -> Option<OptVec<TyParamBound>> {\n     b.as_ref().map(|bounds| {"}, {"sha": "22a999ab744ed3740c48cfdad57fc65768fccbf1", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -273,22 +273,13 @@ pub fn nextch(rdr: @mut StringReader) -> char {\n     } else { return unsafe { transmute(-1u32) }; } // FIXME: #8971: unsound\n }\n \n-fn dec_digit_val(c: char) -> int { return (c as int) - ('0' as int); }\n-\n fn hex_digit_val(c: char) -> int {\n     if in_range(c, '0', '9') { return (c as int) - ('0' as int); }\n     if in_range(c, 'a', 'f') { return (c as int) - ('a' as int) + 10; }\n     if in_range(c, 'A', 'F') { return (c as int) - ('A' as int) + 10; }\n     fail!();\n }\n \n-fn oct_digit_val(c: char) -> int {\n-    if in_range(c, '0', '7') { return (c as int) - ('0' as int); }\n-    fail!();\n-}\n-\n-fn bin_digit_value(c: char) -> int { if c == '0' { return 0; } return 1; }\n-\n pub fn is_whitespace(c: char) -> bool {\n     return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n }\n@@ -304,10 +295,6 @@ fn is_hex_digit(c: char) -> bool {\n             in_range(c, 'A', 'F');\n }\n \n-fn is_oct_digit(c: char) -> bool { return in_range(c, '0', '7'); }\n-\n-fn is_bin_digit(c: char) -> bool { return c == '0' || c == '1'; }\n-\n // EFFECT: eats whitespace and comments.\n // returns a Some(sugared-doc-attr) if one exists, None otherwise.\n fn consume_whitespace_and_comments(rdr: @mut StringReader)"}, {"sha": "62bfd7c80f9fdfa35355c9e3a09a4f25c50e9149", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -135,13 +135,6 @@ pub enum item_or_view_item {\n     iovi_view_item(view_item)\n }\n \n-#[deriving(Eq)]\n-enum view_item_parse_mode {\n-    VIEW_ITEMS_AND_ITEMS_ALLOWED,\n-    FOREIGN_ITEMS_ALLOWED,\n-    IMPORTS_AND_ITEMS_ALLOWED\n-}\n-\n /* The expr situation is not as complex as I thought it would be.\n The important thing is to make sure that lookahead doesn't balk\n at INTERPOLATED tokens */\n@@ -3455,18 +3448,6 @@ impl Parser {\n         })\n     }\n \n-    fn parse_optional_purity(&self) -> ast::purity {\n-        if self.eat_keyword(keywords::Unsafe) {\n-            ast::unsafe_fn\n-        } else {\n-            ast::impure_fn\n-        }\n-    }\n-\n-    fn parse_optional_onceness(&self) -> ast::Onceness {\n-        if self.eat_keyword(keywords::Once) { ast::Once } else { ast::Many }\n-    }\n-\n     // matches optbounds = ( ( : ( boundseq )? )? )\n     // where   boundseq  = ( bound + boundseq ) | bound\n     // and     bound     = 'static | ty\n@@ -3531,15 +3512,6 @@ impl Parser {\n         }\n     }\n \n-    // parse a generic use site\n-    fn parse_generic_values(&self) -> (OptVec<ast::Lifetime>, ~[P<Ty>]) {\n-        if !self.eat(&token::LT) {\n-            (opt_vec::Empty, ~[])\n-        } else {\n-            self.parse_generic_values_after_lt()\n-        }\n-    }\n-\n     fn parse_generic_values_after_lt(&self) -> (OptVec<ast::Lifetime>, ~[P<Ty>]) {\n         let lifetimes = self.parse_lifetimes();\n         let result = self.parse_seq_to_gt(\n@@ -4080,13 +4052,6 @@ impl Parser {\n          None)\n     }\n \n-    fn token_is_pound_or_doc_comment(&self, tok: token::Token) -> bool {\n-        match tok {\n-            token::POUND | token::DOC_COMMENT(_) => true,\n-            _ => false\n-        }\n-    }\n-\n     // parse a structure field declaration\n     pub fn parse_single_struct_field(&self,\n                                      vis: visibility,\n@@ -4556,26 +4521,6 @@ impl Parser {\n         (id, item_enum(enum_definition, generics), None)\n     }\n \n-    fn parse_fn_ty_sigil(&self) -> Option<Sigil> {\n-        match *self.token {\n-            token::AT => {\n-                self.bump();\n-                Some(ManagedSigil)\n-            }\n-            token::TILDE => {\n-                self.bump();\n-                Some(OwnedSigil)\n-            }\n-            token::BINOP(token::AND) => {\n-                self.bump();\n-                Some(BorrowedSigil)\n-            }\n-            _ => {\n-                None\n-            }\n-        }\n-    }\n-\n     fn fn_expr_lookahead(&self, tok: &token::Token) -> bool {\n         match *tok {\n           token::LPAREN | token::AT | token::TILDE | token::BINOP(_) => true,\n@@ -4983,51 +4928,6 @@ impl Parser {\n         return vp;\n     }\n \n-    fn is_view_item(&self) -> bool {\n-        if !self.is_keyword(keywords::Pub) && !self.is_keyword(keywords::Priv) {\n-            token::is_keyword(keywords::Use, self.token)\n-                || (token::is_keyword(keywords::Extern, self.token) &&\n-                    self.look_ahead(1,\n-                                    |t| token::is_keyword(keywords::Mod, t)))\n-        } else {\n-            self.look_ahead(1, |t| token::is_keyword(keywords::Use, t))\n-                || (self.look_ahead(1,\n-                                    |t| token::is_keyword(keywords::Extern,\n-                                                          t)) &&\n-                    self.look_ahead(2,\n-                                    |t| token::is_keyword(keywords::Mod, t)))\n-        }\n-    }\n-\n-    // parse a view item.\n-    fn parse_view_item(\n-        &self,\n-        attrs: ~[Attribute],\n-        vis: visibility\n-    ) -> view_item {\n-        let lo = self.span.lo;\n-        let node = if self.eat_keyword(keywords::Use) {\n-            self.parse_use()\n-        } else if self.eat_keyword(keywords::Extern) {\n-            self.expect_keyword(keywords::Mod);\n-            let ident = self.parse_ident();\n-            let path = if *self.token == token::EQ {\n-                self.bump();\n-                Some(self.parse_str())\n-            }\n-            else { None };\n-            let metadata = self.parse_optional_meta();\n-            view_item_extern_mod(ident, path, metadata, ast::DUMMY_NODE_ID)\n-        } else {\n-            self.bug(\"expected view item\");\n-        };\n-        self.expect(&token::SEMI);\n-        ast::view_item { node: node,\n-                          attrs: attrs,\n-                          vis: vis,\n-                          span: mk_sp(lo, self.last_span.hi) }\n-    }\n-\n     // Parses a sequence of items. Stops when it finds program\n     // text that can't be parsed as an item\n     // - mod_items uses extern_mod_allowed = true"}, {"sha": "51656160d312e543a7f1de770e80a7d2ef6ada2f", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -64,7 +64,7 @@ impl<T> SmallVector<T> {\n         }\n     }\n \n-    fn get<'a>(&'a self, idx: uint) -> &'a T {\n+    pub fn get<'a>(&'a self, idx: uint) -> &'a T {\n         match *self {\n             One(ref v) if idx == 0 => v,\n             Many(ref vs) => &vs[idx],"}, {"sha": "2c54b622021153c44ebf5878a54a0d4655f0f44d", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -10,6 +10,7 @@\n \n #[deny(unreachable_code)];\n #[allow(unused_variable)];\n+#[allow(dead_code)];\n \n fn fail_len(v: ~[int]) -> uint {\n     let mut i = 3;"}, {"sha": "23d9f3199c1779eac9ffc22994c2957f23367355", "filename": "src/test/compile-fail/issue-6804.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -1,3 +1,5 @@\n+#[allow(dead_code)];\n+\n // Matching against NaN should result in a warning\n \n use std::f64::NAN;"}, {"sha": "ce31ac2e8fa0a3bc7305b5f4843816c91fccd7c4", "filename": "src/test/compile-fail/issue-7246.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Fissue-7246.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Fissue-7246.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7246.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n #[deny(unreachable_code)];\n+#[allow(dead_code)];\n+\n use std::ptr;\n pub unsafe fn g() {\n     return; "}, {"sha": "e9985430adfa5858e3b304657e81de86460c6df3", "filename": "src/test/compile-fail/lint-change-warnings.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-change-warnings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-change-warnings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-change-warnings.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #[deny(warnings)];\n+#[allow(dead_code)];\n \n fn main() {\n     while true {} //~ ERROR: infinite"}, {"sha": "2e47695f0fc0fa1a9ff1ed1e5cca73eaf0ccc655", "filename": "src/test/compile-fail/lint-ctypes-enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes-enum.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #[deny(ctypes)];\n+#[allow(dead_code)];\n \n enum Z { }\n enum U { A }"}, {"sha": "7d7cbce6e89ac717f41344c8fa8ce32feba02d2d", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(unused_variable)];\n+#[deny(dead_code)];\n+\n+#[crate_type=\"lib\"];\n+\n+pub use foo2::Bar2;\n+mod foo {\n+    pub struct Bar; //~ ERROR: code is never used\n+}\n+\n+mod foo2 {\n+    pub struct Bar2;\n+}\n+\n+pub static pub_static: int = 0;\n+static priv_static: int = 0; //~ ERROR: code is never used\n+static used_static: int = 0;\n+pub static used_static2: int = used_static;\n+\n+pub fn pub_fn() {\n+    used_fn();\n+    let used_struct1 = UsedStruct1 { x: 1 };\n+    let used_struct2 = UsedStruct2(1);\n+    let used_struct3 = UsedStruct3;\n+    let e = foo3;\n+    SemiUsedStruct::la_la_la();\n+\n+}\n+fn priv_fn() { //~ ERROR: code is never used\n+    let unused_struct = PrivStruct;\n+}\n+fn used_fn() {}\n+\n+pub type typ = ~UsedStruct4;\n+pub struct PubStruct();\n+struct PrivStruct; //~ ERROR: code is never used\n+struct UsedStruct1 { x: int }\n+struct UsedStruct2(int);\n+struct UsedStruct3;\n+struct UsedStruct4;\n+// this struct is never used directly, but its method is, so we don't want\n+// to warn it\n+struct SemiUsedStruct;\n+impl SemiUsedStruct {\n+    fn la_la_la() {}\n+}\n+\n+pub enum pub_enum { foo1, bar1 }\n+enum priv_enum { foo2, bar2 } //~ ERROR: code is never used\n+enum used_enum { foo3, bar3 }\n+\n+fn foo() { //~ ERROR: code is never used\n+    bar();\n+    let unused_enum = foo2;\n+}\n+\n+fn bar() { //~ ERROR: code is never used\n+    foo();\n+}"}, {"sha": "663e7890bbe09ad8e5e31e3f2b3cb80fb72fd4db", "filename": "src/test/compile-fail/lint-dead-code-2.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-dead-code-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-dead-code-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-2.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(unused_variable)];\n+#[deny(dead_code)];\n+\n+struct Foo;\n+\n+trait Bar {\n+    fn bar1(&self);\n+    fn bar2(&self) {\n+        self.bar1();\n+    }\n+}\n+\n+impl Bar for Foo {\n+    fn bar1(&self) {\n+        live_fn();\n+    }\n+}\n+\n+fn live_fn() {}\n+\n+fn dead_fn() {} //~ ERROR: code is never used\n+\n+#[main]\n+fn dead_fn2() {} //~ ERROR: code is never used\n+\n+fn used_fn() {}\n+\n+#[start]\n+fn start(_: int, _: **u8) -> int {\n+    used_fn();\n+    let foo = Foo;\n+    foo.bar2();\n+    0\n+}\n+\n+// this is not main\n+fn main() { //~ ERROR: code is never used\n+    dead_fn();\n+    dead_fn2();\n+}"}, {"sha": "8a5f239ed05c6ec7cc30944496a06125592cfe38", "filename": "src/test/compile-fail/lint-dead-code-3.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(unused_variable)];\n+#[deny(dead_code)];\n+\n+#[crate_type=\"lib\"];\n+\n+struct Foo; //~ ERROR: code is never used\n+impl Foo {\n+    fn foo(&self) { //~ ERROR: code is never used\n+        bar()\n+    }\n+}\n+\n+fn bar() { //~ ERROR: code is never used\n+    fn baz() {} //~ ERROR: code is never used\n+\n+    Foo.foo();\n+    baz();\n+}\n+\n+// no warning\n+struct Foo2;\n+impl Foo2 { fn foo2(&self) { bar2() } }\n+fn bar2() {\n+    fn baz2() {}\n+\n+    Foo2.foo2();\n+    baz2();\n+}\n+\n+pub fn pub_fn() {\n+    let foo2_struct = Foo2;\n+    foo2_struct.foo2();\n+}\n+\n+// not warned because it's used in the parameter of `free` below\n+enum c_void {}\n+\n+extern {\n+    fn free(p: *c_void);\n+}"}, {"sha": "b550c227898f29361c556c4b5509d61d0ae469e7", "filename": "src/test/compile-fail/lint-heap-memory.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -10,6 +10,7 @@\n \n #[feature(managed_boxes)];\n #[forbid(heap_memory)];\n+#[allow(dead_code)];\n \n struct Foo {\n     x: @int //~ ERROR type uses managed"}, {"sha": "ad35a22b4efa0e2b9407d67afcd886ddc7add2ac", "filename": "src/test/compile-fail/lint-impl-fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-impl-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-impl-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-impl-fn.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #[allow(while_true)];\n+#[allow(dead_code)];\n \n struct A(int);\n "}, {"sha": "a083948bf8406786fb4d80e93470d32c58ab82c2", "filename": "src/test/compile-fail/lint-missing-doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -13,6 +13,7 @@\n #[feature(struct_variant)];\n #[feature(globs)];\n #[deny(missing_doc)];\n+#[allow(dead_code)];\n \n //! Some garbage docs for the crate here\n #[doc=\"More garbage\"];"}, {"sha": "6d217656cd01039768f9e1ffd16f62795d60bc98", "filename": "src/test/compile-fail/lint-non-camel-case-types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-non-camel-case-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-non-camel-case-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-non-camel-case-types.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #[forbid(non_camel_case_types)];\n+#[allow(dead_code)];\n \n struct foo { //~ ERROR type `foo` should have a camel case identifier\n     bar: int,"}, {"sha": "d41a4ccda8d120aa4cb0c6cb7cdda51e44ed61a9", "filename": "src/test/compile-fail/lint-non-uppercase-statics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-non-uppercase-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-non-uppercase-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-non-uppercase-statics.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #[forbid(non_uppercase_statics)];\n+#[allow(dead_code)];\n \n static foo: int = 1; //~ ERROR static constant should have an uppercase identifier\n "}, {"sha": "442bcaa0923140bed7780a6e1a7e1b49aa6b5170", "filename": "src/test/compile-fail/lint-obsolete-attr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-obsolete-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-obsolete-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-obsolete-attr.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -12,6 +12,7 @@\n // injected intrinsics by the compiler.\n \n #[deny(attribute_usage)];\n+#[allow(dead_code)];\n \n #[abi=\"stdcall\"] extern {} //~ ERROR: obsolete attribute\n "}, {"sha": "9cc06cc5395bf1cec7ee44a7831f7a3de59a498c", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -15,6 +15,7 @@\n #[deny(unstable)];\n #[deny(deprecated)];\n #[deny(experimental)];\n+#[allow(dead_code)];\n \n mod cross_crate {\n     extern mod lint_stability;"}, {"sha": "f609debb5bd8fc881fd6ccfd50a69470ba58cf9b", "filename": "src/test/compile-fail/lint-type-limits.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(dead_code)];\n+\n // compile-flags: -D type-limits\n fn main() { }\n "}, {"sha": "529d3e921a069e23fc071ec993b2aa4aab9b6678", "filename": "src/test/compile-fail/lint-unsafe-block.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-unsafe-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-unsafe-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unsafe-block.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #[allow(unused_unsafe)];\n+#[allow(dead_code)];\n #[deny(unsafe_block)];\n #[feature(macro_rules)];\n "}, {"sha": "9d6140b8fd233cc20dccdc87ae823d63882b6aa9", "filename": "src/test/compile-fail/lint-unused-import-tricky-globs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-unused-import-tricky-globs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-unused-import-tricky-globs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-import-tricky-globs.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -10,6 +10,7 @@\n \n #[feature(globs)];\n #[deny(unused_imports)];\n+#[allow(dead_code)];\n \n mod A {\n     pub fn p() {}"}, {"sha": "24511296a0b12bb2b0395ec7afdbd249656ddcc4", "filename": "src/test/compile-fail/lint-unused-import-tricky-names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-unused-import-tricky-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-unused-import-tricky-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-import-tricky-names.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #[deny(unused_imports)];\n+#[allow(dead_code)];\n \n // Regression test for issue #6633\n mod issue6633 {"}, {"sha": "e248184d5e2004f0ada2a342c65e94160d0ca209", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -10,6 +10,7 @@\n \n #[feature(globs)];\n #[deny(unused_imports)];\n+#[allow(dead_code)];\n \n use cal = bar::c::cc;\n "}, {"sha": "271aedd3f6a6ba001814e618c278e2ffe5bb350d", "filename": "src/test/compile-fail/lint-unused-mut-variables.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -12,6 +12,7 @@\n \n #[allow(dead_assignment)];\n #[allow(unused_variable)];\n+#[allow(dead_code)];\n #[deny(unused_mut)];\n \n fn main() {"}, {"sha": "96a4c2adca32c93df98dbd3bce38d07664adaa61", "filename": "src/test/compile-fail/lint-unused-unsafe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -10,6 +10,7 @@\n \n // Exercise the unused_unsafe attribute in some positive and negative cases\n \n+#[allow(dead_code)];\n #[deny(unused_unsafe)];\n \n mod foo {"}, {"sha": "a3d388d7c341ba9350e486f845be4e5786c91cc2", "filename": "src/test/compile-fail/liveness-dead.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(dead_code)];\n #[deny(dead_assignment)];\n \n fn f1(x: &mut int) {"}, {"sha": "fd605b79dbecd48796f916f2c69b907aa5c0ebb9", "filename": "src/test/compile-fail/match-static-const-lc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Fmatch-static-const-lc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Fmatch-static-const-lc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-static-const-lc.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -10,6 +10,7 @@\n \n // Issue #7526: lowercase static constants in patterns look like bindings\n \n+#[allow(dead_code)];\n #[deny(non_uppercase_pattern_statics)];\n \n pub static a : int = 97;"}, {"sha": "4f7f7dd7408af1372bdafe2878d7868831fece2f", "filename": "src/test/compile-fail/static-assert.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Fstatic-assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Fstatic-assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-assert.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -1,3 +1,5 @@\n+#[allow(dead_code)];\n+\n #[static_assert]\n static A: bool = false; //~ ERROR static assertion failed\n "}, {"sha": "ceaa388917984a7117a0ed519baf2b14f6123327", "filename": "src/test/compile-fail/static-assert2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Fstatic-assert2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6310f6ad3434a03d5c257db5eae85b7b7522c29/src%2Ftest%2Fcompile-fail%2Fstatic-assert2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-assert2.rs?ref=a6310f6ad3434a03d5c257db5eae85b7b7522c29", "patch": "@@ -1,3 +1,5 @@\n+#[allow(dead_code)];\n+\n #[static_assert]\n static E: bool = 1 == 2; //~ ERROR static assertion failed\n "}]}