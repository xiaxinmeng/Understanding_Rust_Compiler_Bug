{"sha": "63b36ea7c211406a76c34cba5ac9b7218e003757", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzYjM2ZWE3YzIxMTQwNmE3NmMzNGNiYTVhYzliNzIxOGUwMDM3NTc=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-07T05:59:10Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-07T06:03:07Z"}, "message": "Work with assoc types in a super trait.\n\nAnd fix a bug with type param visibility though the Self rib.", "tree": {"sha": "605fb04f393746fc84f0257ff3fb16523397d002", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/605fb04f393746fc84f0257ff3fb16523397d002"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63b36ea7c211406a76c34cba5ac9b7218e003757", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63b36ea7c211406a76c34cba5ac9b7218e003757", "html_url": "https://github.com/rust-lang/rust/commit/63b36ea7c211406a76c34cba5ac9b7218e003757", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63b36ea7c211406a76c34cba5ac9b7218e003757/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc8a8e9beb1a8f5503c03db7a02957e5e4929141", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc8a8e9beb1a8f5503c03db7a02957e5e4929141", "html_url": "https://github.com/rust-lang/rust/commit/dc8a8e9beb1a8f5503c03db7a02957e5e4929141"}], "stats": {"total": 165, "additions": 102, "deletions": 63}, "files": [{"sha": "f90c7640f8ce70770ee64359177953bfcd04182c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=63b36ea7c211406a76c34cba5ac9b7218e003757", "patch": "@@ -1815,12 +1815,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ItemTrait(_, ref generics, ref bounds, ref trait_items) => {\n                 self.check_if_primitive_type_name(name, item.span);\n \n-                self.with_self_rib(DefSelfTy(Some(local_def(item.id)), None), |this| {\n-                    // Create a new rib for the trait-wide type parameters.\n-                    this.with_type_parameter_rib(HasTypeParameters(generics,\n-                                                                   TypeSpace,\n-                                                                   NormalRibKind),\n-                                                 |this| {\n+                // Create a new rib for the trait-wide type parameters.\n+                self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                               TypeSpace,\n+                                                               ItemRibKind),\n+                                             |this| {\n+                    this.with_self_rib(DefSelfTy(Some(local_def(item.id)), None), |this| {\n                         this.visit_generics(generics);\n                         visit::walk_ty_param_bounds_helper(this, bounds);\n "}, {"sha": "6617781ce2b0a0f4fb486499e2f1a58f28a615f3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 66, "deletions": 48, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=63b36ea7c211406a76c34cba5ac9b7218e003757", "patch": "@@ -871,24 +871,11 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n         }\n     }\n \n-    if candidates.len() > 1 {\n-        span_err!(tcx.sess, binding.span, E0217,\n-            \"ambiguous associated type: `{}` defined in multiple supertraits `{}`\",\n-                    token::get_name(binding.item_name),\n-                    candidates.user_string(tcx));\n-        return Err(ErrorReported);\n-    }\n-\n-    let candidate = match candidates.pop() {\n-        Some(c) => c,\n-        None => {\n-            span_err!(tcx.sess, binding.span, E0218,\n-                \"no associated type `{}` defined in `{}`\",\n-                        token::get_name(binding.item_name),\n-                        trait_ref.user_string(tcx));\n-            return Err(ErrorReported);\n-        }\n-    };\n+    let candidate = try!(one_bound_for_assoc_type(tcx,\n+                                                  candidates,\n+                                                  &trait_ref.user_string(tcx),\n+                                                  &token::get_name(binding.item_name),\n+                                                  binding.span));\n \n     Ok(ty::Binder(ty::ProjectionPredicate {             // <-------------------------+\n         projection_ty: ty::ProjectionTy {               //                           |\n@@ -1042,19 +1029,18 @@ fn report_ambiguous_associated_type(tcx: &ty::ctxt,\n }\n \n // Search for a bound on a type parameter which includes the associated item\n-// given by assoc_name. We assume that ty_path_def is the def for such a type\n-// parameter (which might be `Self`). This function will fail if there are no\n-// suitable bounds or there is any ambiguity.\n+// given by assoc_name. ty_param_node_id is the node id for the type parameter\n+// (which might be `Self`, but only if it is the `Self` of a trait, not an\n+// impl). This function will fail if there are no suitable bounds or there is\n+// any ambiguity.\n fn find_bound_for_assoc_item<'tcx>(this: &AstConv<'tcx>,\n-                                   ty_path_def: def::Def,\n+                                   ty_param_node_id: ast::NodeId,\n                                    assoc_name: ast::Name,\n                                    span: Span)\n                                    -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n {\n     let tcx = this.tcx();\n \n-    let ty_param_node_id = ty_path_def.local_node_id();\n-\n     let bounds = match this.get_type_parameter_bounds(span, ty_param_node_id) {\n         Ok(v) => v,\n         Err(ErrorReported) => {\n@@ -1069,35 +1055,52 @@ fn find_bound_for_assoc_item<'tcx>(this: &AstConv<'tcx>,\n \n     // Check that there is exactly one way to find an associated type with the\n     // correct name.\n-    let mut suitable_bounds: Vec<_> =\n+    let suitable_bounds: Vec<_> =\n         traits::transitive_bounds(tcx, &bounds)\n         .filter(|b| this.trait_defines_associated_type_named(b.def_id(), assoc_name))\n         .collect();\n \n-    let ty_param_name = tcx.ty_param_defs.borrow().get(&ty_param_node_id).unwrap().name;\n-    if suitable_bounds.len() == 0 {\n+    let ty_param_name = tcx.type_parameter_def(ty_param_node_id).name;\n+    one_bound_for_assoc_type(tcx,\n+                             suitable_bounds,\n+                             &token::get_name(ty_param_name),\n+                             &token::get_name(assoc_name),\n+                             span)\n+}\n+\n+\n+// Checks that bounds contains exactly one element and reports appropriate\n+// errors otherwise.\n+fn one_bound_for_assoc_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  bounds: Vec<ty::PolyTraitRef<'tcx>>,\n+                                  ty_param_name: &str,\n+                                  assoc_name: &str,\n+                                  span: Span)\n+    -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n+{\n+    if bounds.len() == 0 {\n         span_err!(tcx.sess, span, E0220,\n-                          \"associated type `{}` not found for type parameter `{}`\",\n-                                  token::get_name(assoc_name),\n-                                  token::get_name(ty_param_name));\n+                  \"associated type `{}` not found for `{}`\",\n+                  assoc_name,\n+                  ty_param_name);\n         return Err(ErrorReported);\n     }\n \n-    if suitable_bounds.len() > 1 {\n+    if bounds.len() > 1 {\n         span_err!(tcx.sess, span, E0221,\n-                          \"ambiguous associated type `{}` in bounds of `{}`\",\n-                                  token::get_name(assoc_name),\n-                                  token::get_name(ty_param_name));\n+                  \"ambiguous associated type `{}` in bounds of `{}`\",\n+                  assoc_name,\n+                  ty_param_name);\n \n-        for suitable_bound in &suitable_bounds {\n+        for bound in &bounds {\n             span_note!(tcx.sess, span,\n                        \"associated type `{}` could derive from `{}`\",\n-                       token::get_name(ty_param_name),\n-                       suitable_bound.user_string(tcx));\n+                       ty_param_name,\n+                       bound.user_string(tcx));\n         }\n     }\n \n-    Ok(suitable_bounds.pop().unwrap().clone())\n+    Ok(bounds[0].clone())\n }\n \n // Create a type from a a path to an associated type.\n@@ -1122,12 +1125,16 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     // Find the type of the associated item, and the trait where the associated\n     // item is declared.\n-    let (ty, trait_did) = match (&ty.sty, ty_path_def) {\n+    let bound = match (&ty.sty, ty_path_def) {\n         (_, def::DefSelfTy(Some(trait_did), Some((impl_id, _)))) => {\n             // `Self` in an impl of a trait - we have a concrete self type and a\n             // trait reference.\n             match tcx.map.expect_item(impl_id).node {\n                 ast::ItemImpl(_, _, _, Some(ref trait_ref), _, _) => {\n+                    if this.ensure_super_predicates(span, trait_did).is_err() {\n+                        return (tcx.types.err, ty_path_def);\n+                    }\n+\n                     let trait_segment = &trait_ref.path.segments.last().unwrap();\n                     let trait_ref = ast_path_to_mono_trait_ref(this,\n                                                                &ExplicitRscope,\n@@ -1137,8 +1144,20 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                                                Some(ty),\n                                                                trait_segment);\n \n-                    let ty = this.projected_ty(span, trait_ref, assoc_name);\n-                    (ty, trait_did)\n+                    let candidates: Vec<ty::PolyTraitRef> =\n+                        traits::supertraits(tcx, ty::Binder(trait_ref.clone()))\n+                        .filter(|r| this.trait_defines_associated_type_named(r.def_id(),\n+                                                                             assoc_name))\n+                        .collect();\n+\n+                    match one_bound_for_assoc_type(tcx,\n+                                                   candidates,\n+                                                   \"Self\",\n+                                                   &token::get_name(assoc_name),\n+                                                   span) {\n+                        Ok(bound) => bound,\n+                        Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n+                    }\n                 }\n                 _ => unreachable!()\n             }\n@@ -1147,17 +1166,13 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         (&ty::ty_param(_), def::DefSelfTy(Some(_), None)) => {\n             // A type parameter or Self, we need to find the associated item from\n             // a bound.\n-            let bound = match find_bound_for_assoc_item(this, ty_path_def, assoc_name, span) {\n+            let ty_param_node_id = ty_path_def.local_node_id();\n+            match find_bound_for_assoc_item(this, ty_param_node_id, assoc_name, span) {\n                 Ok(bound) => bound,\n                 Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n-            };\n-            let trait_did = bound.0.def_id;\n-            let ty = this.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n-\n-            (ty, trait_did)\n+            }\n         }\n         _ => {\n-            println!(\"{:?} {:?}\", ty.sty, ty_path_def);\n             report_ambiguous_associated_type(tcx,\n                                              span,\n                                              &ty.user_string(tcx),\n@@ -1167,6 +1182,9 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n     };\n \n+    let trait_did = bound.0.def_id;\n+    let ty = this.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n+\n     let item_did = if trait_did.krate == ast::LOCAL_CRATE {\n         // `ty::trait_items` used below requires information generated\n         // by type collection, which may be in progress at this point."}, {"sha": "95b943b254785ff0725dcc8801664ed19d06a703", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=63b36ea7c211406a76c34cba5ac9b7218e003757", "patch": "@@ -1815,7 +1815,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                     ty::ty_param(p) => if p.idx > cur_idx {\n                         span_err!(tcx.sess, path.span, E0128,\n                                   \"type parameters with a default cannot use \\\n-                                  forward declared identifiers\");\n+                                   forward declared identifiers\");\n                         },\n                         _ => {}\n                     }"}, {"sha": "d058c6a5a3b93fbb6c6bf3f6d232d8e9fdc0806f", "filename": "src/test/compile-fail/self-impl.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Ftest%2Fcompile-fail%2Fself-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Ftest%2Fcompile-fail%2Fself-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself-impl.rs?ref=63b36ea7c211406a76c34cba5ac9b7218e003757", "patch": "@@ -16,10 +16,18 @@ trait Foo {\n     type Baz;\n }\n \n+trait SuperFoo {\n+    type SuperBaz;\n+}\n+\n impl Foo for Bar {\n     type Baz = bool;\n }\n \n+impl SuperFoo for Bar {\n+    type SuperBaz = bool;\n+}\n+\n impl Bar {\n     fn f() {\n         let _: <Self>::Baz = true;"}, {"sha": "bb7e02d0d8b9bebf5abc9c9c26f9811b7f18cd21", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs?ref=63b36ea7c211406a76c34cba5ac9b7218e003757", "patch": "@@ -12,7 +12,7 @@\n \n trait One<A> { fn foo(&self) -> A; }\n \n-fn foo(_: &One()) //~ ERROR no associated type `Output` defined in `One<()>`\n+fn foo(_: &One()) //~ ERROR associated type `Output` not found for `One<()>`\n {}\n \n fn main() { }"}, {"sha": "20fdd52b82a3e257127e9d588a07a0767abfc51e", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs?ref=63b36ea7c211406a76c34cba5ac9b7218e003757", "patch": "@@ -14,7 +14,7 @@ trait Three<A,B,C> { fn dummy(&self) -> (A,B,C); }\n \n fn foo(_: &Three())\n //~^ ERROR wrong number of type arguments\n-//~| ERROR no associated type `Output`\n+//~| ERROR associated type `Output` not found\n {}\n \n fn main() { }"}, {"sha": "027fa6b0fe3b0866a70d208681c06dd8422ba1f5", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs?ref=63b36ea7c211406a76c34cba5ac9b7218e003757", "patch": "@@ -14,7 +14,7 @@ trait Zero { fn dummy(&self); }\n \n fn foo(_: Zero())\n     //~^ ERROR wrong number of type arguments\n-    //~| ERROR no associated type `Output` defined in `Zero`\n+    //~| ERROR associated type `Output` not found for `Zero`\n {}\n \n fn main() { }"}, {"sha": "04bbfc445edeaab920911845a249d8f4a30d7220", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs?ref=63b36ea7c211406a76c34cba5ac9b7218e003757", "patch": "@@ -14,6 +14,6 @@ trait Trait {}\n \n fn f<F:Trait(isize) -> isize>(x: F) {}\n //~^ ERROR wrong number of type arguments: expected 0, found 1\n-//~| ERROR no associated type `Output`\n+//~| ERROR associated type `Output` not found\n \n fn main() {}"}, {"sha": "688b66a0a87744553a75916813929b52775b879c", "filename": "src/test/run-pass/self-impl.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Ftest%2Frun-pass%2Fself-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b36ea7c211406a76c34cba5ac9b7218e003757/src%2Ftest%2Frun-pass%2Fself-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fself-impl.rs?ref=63b36ea7c211406a76c34cba5ac9b7218e003757", "patch": "@@ -40,19 +40,31 @@ pub struct Baz<X> {\n     pub f: X,\n }\n \n-trait Bar<X> {\n+trait SuperBar {\n+    type SuperQux;\n+}\n+\n+trait Bar<X>: SuperBar {\n     type Qux;\n \n-    fn bar(x: Self, y: &Self, z: Box<Self>) -> Self;\n+    fn bar(x: Self, y: &Self, z: Box<Self>, _: Self::SuperQux) -> Self;\n     fn dummy(&self, x: X) { }\n }\n \n+impl SuperBar for Box<Baz<isize>> {\n+    type SuperQux = bool;\n+}\n+\n impl Bar<isize> for Box<Baz<isize>> {\n     type Qux = i32;\n \n-    fn bar(_x: Self, _y: &Self, _z: Box<Self>) -> Self {\n+    fn bar(_x: Self, _y: &Self, _z: Box<Self>, _: Self::SuperQux) -> Self {\n         let _: Self::Qux = 42;\n         let _: <Self as Bar<isize>>::Qux = 42;\n+\n+        let _: Self::SuperQux = true;\n+        let _: <Self as SuperBar>::SuperQux = true;\n+\n         box Baz { f: 42 }\n     }\n }\n@@ -61,5 +73,6 @@ fn main() {\n     let _: Foo = Foo::foo(Foo, &Foo, box Foo);\n     let _: Box<Baz<isize>> = Bar::bar(box Baz { f: 42 },\n                                       &box Baz { f: 42 },\n-                                      box box Baz { f: 42 });\n+                                      box box Baz { f: 42 },\n+                                      true);\n }"}]}