{"sha": "f2810d5fa0fb5930a02e2bb4827b037292a83cea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyODEwZDVmYTBmYjU5MzBhMDJlMmJiNDgyN2IwMzcyOTJhODNjZWE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-05-27T01:02:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-27T01:02:03Z"}, "message": "Rollup merge of #84221 - ABouttefeux:generic-arg-elision, r=estebank\n\nE0599 suggestions and elision of generic argument if no canditate is found\n\nfixes #81576\nchanges: In error E0599 (method not found) generic argument are eluded if the method was not found anywhere. If the method was found in another inherent implementation suggest that it was found elsewhere.\n\nExample\n```rust\n\nstruct Wrapper<T>(T);\n\nstruct Wrapper2<T> {\n    x: T,\n}\n\nimpl Wrapper2<i8> {\n    fn method(&self) {}\n}\n\nfn main() {\n    let wrapper = Wrapper(i32);\n    wrapper.method();\n    let wrapper2 = Wrapper2{x: i32};\n    wrapper2.method();\n}\n```\n\n```\nError[E0599]: no method named `method` found for struct `Wrapper<_>` in the current scope\n....\nerror[E0599]: no method named `method` found for struct `Wrapper2<i32>` in the current scope\n...\n   = note: The method was found for Wrapper2<i8>.\n\n```\nI am not very happy with the ```no method named `test` found for struct `Vec<_, _>` in the current scope```. I think it might be better to show only one generic argument `Vec<_>` if there is a default one. But I haven't yet found a way to do that,", "tree": {"sha": "808ec000a1d4eee798f114b5401c8a3cd0eca5c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/808ec000a1d4eee798f114b5401c8a3cd0eca5c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2810d5fa0fb5930a02e2bb4827b037292a83cea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgru+NCRBK7hj4Ov3rIwAACC0IADhBqd8MqmoAGwIldJ0ToRrb\nkV/D6+c7Dgz3MGfgZxKgRALSbfxVblJRHOMycT0iKtaWN22ayPhrwrsvq32LZcna\ndhUDyjbXk7p6sBxet1OwkpGS+vOws8Ws6pnXhyWg75MCSO/9TwlrFnA9evKEHM/j\n4EASKxJ5i70/zoUwSvRbPr+3tOhm1jQVJcBppS2NA2x10JO3SBZTiDB5fviU58Se\nf7S7r6f/LEwAV5xE7lVquQRzE5H1oHFBZbP4a7rFNKzTydbLlxxxlDmv/8Cy4xir\nKCoII0BGI/DFWwTOya4mpNbEfJWFC3EuepYtXzsdRWMxPRxYyEA2bV5t8X2qUMU=\n=Vn2b\n-----END PGP SIGNATURE-----\n", "payload": "tree 808ec000a1d4eee798f114b5401c8a3cd0eca5c5\nparent 9111b8ae9793f18179a1336417618fc07a9cac85\nparent 5d8e6ea7b9e668578917940d2ab1ba1a51b291b5\nauthor Dylan DPC <dylan.dpc@gmail.com> 1622077323 +0200\ncommitter GitHub <noreply@github.com> 1622077323 +0200\n\nRollup merge of #84221 - ABouttefeux:generic-arg-elision, r=estebank\n\nE0599 suggestions and elision of generic argument if no canditate is found\n\nfixes #81576\nchanges: In error E0599 (method not found) generic argument are eluded if the method was not found anywhere. If the method was found in another inherent implementation suggest that it was found elsewhere.\n\nExample\n```rust\n\nstruct Wrapper<T>(T);\n\nstruct Wrapper2<T> {\n    x: T,\n}\n\nimpl Wrapper2<i8> {\n    fn method(&self) {}\n}\n\nfn main() {\n    let wrapper = Wrapper(i32);\n    wrapper.method();\n    let wrapper2 = Wrapper2{x: i32};\n    wrapper2.method();\n}\n```\n\n```\nError[E0599]: no method named `method` found for struct `Wrapper<_>` in the current scope\n....\nerror[E0599]: no method named `method` found for struct `Wrapper2<i32>` in the current scope\n...\n   = note: The method was found for Wrapper2<i8>.\n\n```\nI am not very happy with the ```no method named `test` found for struct `Vec<_, _>` in the current scope```. I think it might be better to show only one generic argument `Vec<_>` if there is a default one. But I haven't yet found a way to do that,\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2810d5fa0fb5930a02e2bb4827b037292a83cea", "html_url": "https://github.com/rust-lang/rust/commit/f2810d5fa0fb5930a02e2bb4827b037292a83cea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2810d5fa0fb5930a02e2bb4827b037292a83cea/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9111b8ae9793f18179a1336417618fc07a9cac85", "url": "https://api.github.com/repos/rust-lang/rust/commits/9111b8ae9793f18179a1336417618fc07a9cac85", "html_url": "https://github.com/rust-lang/rust/commit/9111b8ae9793f18179a1336417618fc07a9cac85"}, {"sha": "5d8e6ea7b9e668578917940d2ab1ba1a51b291b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d8e6ea7b9e668578917940d2ab1ba1a51b291b5", "html_url": "https://github.com/rust-lang/rust/commit/5d8e6ea7b9e668578917940d2ab1ba1a51b291b5"}], "stats": {"total": 317, "additions": 308, "deletions": 9}, "files": [{"sha": "16382c7e7a4bdce9ce540166f8416057facbc5ef", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 94, "deletions": 1, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/f2810d5fa0fb5930a02e2bb4827b037292a83cea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2810d5fa0fb5930a02e2bb4827b037292a83cea/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f2810d5fa0fb5930a02e2bb4827b037292a83cea", "patch": "@@ -383,6 +383,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         return None;\n                     } else {\n                         span = item_name.span;\n+\n+                        // Don't show generic arguments when the method can't be found in any implementation (#81576).\n+                        let mut ty_str_reported = ty_str.clone();\n+                        if let ty::Adt(_, ref generics) = actual.kind() {\n+                            if generics.len() > 0 {\n+                                let mut autoderef = self.autoderef(span, actual);\n+                                let candidate_found = autoderef.any(|(ty, _)| {\n+                                    if let ty::Adt(ref adt_deref, _) = ty.kind() {\n+                                        self.tcx\n+                                            .inherent_impls(adt_deref.did)\n+                                            .iter()\n+                                            .filter_map(|def_id| {\n+                                                self.associated_item(\n+                                                    *def_id,\n+                                                    item_name,\n+                                                    Namespace::ValueNS,\n+                                                )\n+                                            })\n+                                            .count()\n+                                            >= 1\n+                                    } else {\n+                                        false\n+                                    }\n+                                });\n+                                let has_deref = autoderef.step_count() > 0;\n+                                if !candidate_found\n+                                    && !has_deref\n+                                    && unsatisfied_predicates.is_empty()\n+                                {\n+                                    if let Some((path_string, _)) = ty_str.split_once('<') {\n+                                        ty_str_reported = path_string.to_string();\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n                         let mut err = struct_span_err!(\n                             tcx.sess,\n                             span,\n@@ -391,7 +427,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             item_kind,\n                             item_name,\n                             actual.prefix_string(self.tcx),\n-                            ty_str,\n+                            ty_str_reported,\n                         );\n                         if let Mode::MethodCall = mode {\n                             if let SelfSource::MethodCall(call) = source {\n@@ -449,6 +485,63 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut label_span_not_found = || {\n                     if unsatisfied_predicates.is_empty() {\n                         err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n+                        if let ty::Adt(ref adt, _) = rcvr_ty.kind() {\n+                            let mut inherent_impls_candidate = self\n+                                .tcx\n+                                .inherent_impls(adt.did)\n+                                .iter()\n+                                .copied()\n+                                .filter(|def_id| {\n+                                    if let Some(assoc) =\n+                                        self.associated_item(*def_id, item_name, Namespace::ValueNS)\n+                                    {\n+                                        // Check for both mode is the same so we avoid suggesting\n+                                        // incorrect associated item.\n+                                        match (mode, assoc.fn_has_self_parameter, source) {\n+                                            (Mode::MethodCall, true, SelfSource::MethodCall(_)) => {\n+                                                // We check that the suggest type is actually\n+                                                // different from the received one\n+                                                // So we avoid suggestion method with Box<Self>\n+                                                // for instance\n+                                                self.tcx.at(span).type_of(*def_id) != actual\n+                                                    && self.tcx.at(span).type_of(*def_id) != rcvr_ty\n+                                            }\n+                                            (Mode::Path, false, _) => true,\n+                                            _ => false,\n+                                        }\n+                                    } else {\n+                                        false\n+                                    }\n+                                })\n+                                .collect::<Vec<_>>();\n+                            if inherent_impls_candidate.len() > 0 {\n+                                inherent_impls_candidate.sort();\n+                                inherent_impls_candidate.dedup();\n+\n+                                // number of type to shows at most.\n+                                let limit = if inherent_impls_candidate.len() == 5 { 5 } else { 4 };\n+                                let type_candidates = inherent_impls_candidate\n+                                    .iter()\n+                                    .take(limit)\n+                                    .map(|impl_item| {\n+                                        format!(\"- `{}`\", self.tcx.at(span).type_of(*impl_item))\n+                                    })\n+                                    .collect::<Vec<_>>()\n+                                    .join(\"\\n\");\n+                                let additional_types = if inherent_impls_candidate.len() > limit {\n+                                    format!(\n+                                        \"\\nand {} more types\",\n+                                        inherent_impls_candidate.len() - limit\n+                                    )\n+                                } else {\n+                                    \"\".to_string()\n+                                };\n+                                err.note(&format!(\n+                                    \"the {item_kind} was found for\\n{}{}\",\n+                                    type_candidates, additional_types\n+                                ));\n+                            }\n+                        }\n                     } else {\n                         err.span_label(span, format!(\"{item_kind} cannot be called on `{ty_str}` due to unsatisfied trait bounds\"));\n                     }"}, {"sha": "fe6b12968c110a6d4f6c7bc0934ec0d7fffbb412", "filename": "src/test/ui/confuse-field-and-method/issue-18343.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2810d5fa0fb5930a02e2bb4827b037292a83cea/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-18343.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2810d5fa0fb5930a02e2bb4827b037292a83cea/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-18343.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-18343.stderr?ref=f2810d5fa0fb5930a02e2bb4827b037292a83cea", "patch": "@@ -1,4 +1,4 @@\n-error[E0599]: no method named `closure` found for struct `Obj<[closure@$DIR/issue-18343.rs:6:28: 6:33]>` in the current scope\n+error[E0599]: no method named `closure` found for struct `Obj` in the current scope\n   --> $DIR/issue-18343.rs:7:7\n    |\n LL | struct Obj<F> where F: FnMut() -> u32 {"}, {"sha": "0480958e99c0554ffe02ab7d26f1e9bea3d76594", "filename": "src/test/ui/confuse-field-and-method/issue-2392.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2810d5fa0fb5930a02e2bb4827b037292a83cea/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-2392.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2810d5fa0fb5930a02e2bb4827b037292a83cea/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-2392.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconfuse-field-and-method%2Fissue-2392.stderr?ref=f2810d5fa0fb5930a02e2bb4827b037292a83cea", "patch": "@@ -1,4 +1,4 @@\n-error[E0599]: no method named `closure` found for struct `Obj<[closure@$DIR/issue-2392.rs:35:36: 35:41]>` in the current scope\n+error[E0599]: no method named `closure` found for struct `Obj` in the current scope\n   --> $DIR/issue-2392.rs:36:15\n    |\n LL | struct Obj<F> where F: FnOnce() -> u32 {\n@@ -12,7 +12,7 @@ help: to call the function stored in `closure`, surround the field access with p\n LL |     (o_closure.closure)();\n    |     ^                 ^\n \n-error[E0599]: no method named `not_closure` found for struct `Obj<[closure@$DIR/issue-2392.rs:35:36: 35:41]>` in the current scope\n+error[E0599]: no method named `not_closure` found for struct `Obj` in the current scope\n   --> $DIR/issue-2392.rs:38:15\n    |\n LL | struct Obj<F> where F: FnOnce() -> u32 {\n@@ -23,7 +23,7 @@ LL |     o_closure.not_closure();\n    |               |\n    |               field, not a method\n \n-error[E0599]: no method named `closure` found for struct `Obj<fn() -> u32 {func}>` in the current scope\n+error[E0599]: no method named `closure` found for struct `Obj` in the current scope\n   --> $DIR/issue-2392.rs:42:12\n    |\n LL | struct Obj<F> where F: FnOnce() -> u32 {\n@@ -65,7 +65,7 @@ help: to call the function stored in `boxed_closure`, surround the field access\n LL |     (boxed_closure.boxed_closure)();\n    |     ^                           ^\n \n-error[E0599]: no method named `closure` found for struct `Obj<fn() -> u32 {func}>` in the current scope\n+error[E0599]: no method named `closure` found for struct `Obj` in the current scope\n   --> $DIR/issue-2392.rs:53:12\n    |\n LL | struct Obj<F> where F: FnOnce() -> u32 {\n@@ -79,7 +79,7 @@ help: to call the function stored in `closure`, surround the field access with p\n LL |     (w.wrap.closure)();\n    |     ^              ^\n \n-error[E0599]: no method named `not_closure` found for struct `Obj<fn() -> u32 {func}>` in the current scope\n+error[E0599]: no method named `not_closure` found for struct `Obj` in the current scope\n   --> $DIR/issue-2392.rs:55:12\n    |\n LL | struct Obj<F> where F: FnOnce() -> u32 {\n@@ -90,7 +90,7 @@ LL |     w.wrap.not_closure();\n    |            |\n    |            field, not a method\n \n-error[E0599]: no method named `closure` found for struct `Obj<Box<(dyn FnOnce() -> u32 + 'static)>>` in the current scope\n+error[E0599]: no method named `closure` found for struct `Obj` in the current scope\n   --> $DIR/issue-2392.rs:58:24\n    |\n LL | struct Obj<F> where F: FnOnce() -> u32 {"}, {"sha": "e9d934332f171f6402a5f296c5bc780903aef40a", "filename": "src/test/ui/issues/issue-30123.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2810d5fa0fb5930a02e2bb4827b037292a83cea/src%2Ftest%2Fui%2Fissues%2Fissue-30123.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2810d5fa0fb5930a02e2bb4827b037292a83cea/src%2Ftest%2Fui%2Fissues%2Fissue-30123.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30123.stderr?ref=f2810d5fa0fb5930a02e2bb4827b037292a83cea", "patch": "@@ -3,6 +3,9 @@ error[E0599]: no function or associated item named `new_undirected` found for st\n    |\n LL |     let ug = Graph::<i32, i32>::new_undirected();\n    |                                 ^^^^^^^^^^^^^^ function or associated item not found in `issue_30123_aux::Graph<i32, i32>`\n+   |\n+   = note: the function or associated item was found for\n+           - `issue_30123_aux::Graph<N, E, Undirected>`\n \n error: aborting due to previous error\n "}, {"sha": "017dd831f712a22a3ff23acc870d43c490e0c12f", "filename": "src/test/ui/issues/issue-41880.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2810d5fa0fb5930a02e2bb4827b037292a83cea/src%2Ftest%2Fui%2Fissues%2Fissue-41880.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2810d5fa0fb5930a02e2bb4827b037292a83cea/src%2Ftest%2Fui%2Fissues%2Fissue-41880.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41880.stderr?ref=f2810d5fa0fb5930a02e2bb4827b037292a83cea", "patch": "@@ -1,4 +1,4 @@\n-error[E0599]: no method named `iter` found for struct `Iterate<{integer}, [closure@$DIR/issue-41880.rs:26:24: 26:31]>` in the current scope\n+error[E0599]: no method named `iter` found for struct `Iterate` in the current scope\n   --> $DIR/issue-41880.rs:27:24\n    |\n LL | pub struct Iterate<T, F> {"}, {"sha": "3df928b5d804db01e868ea0f9277252d43d18d97", "filename": "src/test/ui/methods/method-not-found-generic-arg-elision.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f2810d5fa0fb5930a02e2bb4827b037292a83cea/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2810d5fa0fb5930a02e2bb4827b037292a83cea/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.rs?ref=f2810d5fa0fb5930a02e2bb4827b037292a83cea", "patch": "@@ -0,0 +1,106 @@\n+// Test for issue 81576\n+// Remove generic arguments if no method is found for all possible generic argument\n+\n+use std::marker::PhantomData;\n+\n+struct Wrapper2<'a, T, const C: usize> {\n+    x: &'a T,\n+}\n+\n+impl<'a, const C: usize> Wrapper2<'a, i8, C> {\n+    fn method(&self) {}\n+}\n+\n+impl<'a, const C: usize> Wrapper2<'a, i16, C> {\n+    fn method(&self) {}\n+}\n+\n+impl<'a, const C: usize> Wrapper2<'a, i32, C> {\n+    fn method(&self) {}\n+}\n+struct Wrapper<T>(T);\n+\n+impl Wrapper<i8> {\n+    fn method(&self) {}\n+}\n+\n+impl Wrapper<i16> {\n+    fn method(&self) {}\n+}\n+\n+impl Wrapper<i32> {\n+    fn method(&self) {}\n+}\n+\n+impl Wrapper<i64> {\n+    fn method(&self) {}\n+}\n+\n+impl Wrapper<u8> {\n+    fn method(&self) {}\n+}\n+\n+impl Wrapper<u16> {\n+    fn method(&self) {}\n+}\n+\n+struct Point<T> {\n+    x: T,\n+    y: T,\n+}\n+\n+impl Point<f64> {\n+    fn distance(&self) -> f64 {\n+        self.x.hypot(self.y)\n+    }\n+}\n+\n+struct Other;\n+\n+impl Other {\n+    fn other(&self) {}\n+}\n+\n+struct Struct<T>{\n+    _phatom: PhantomData<T>\n+}\n+\n+impl<T> Default for Struct<T> {\n+    fn default() -> Self {\n+        Self{ _phatom: PhantomData }\n+    }\n+}\n+\n+impl<T: Clone + Copy + PartialEq + Eq + PartialOrd + Ord> Struct<T> {\n+    fn method(&self) {}\n+}\n+\n+fn main() {\n+    let point_f64 = Point{ x: 1_f64, y: 1_f64};\n+    let d = point_f64.distance();\n+    let point_i32 = Point{ x: 1_i32, y: 1_i32};\n+    let d = point_i32.distance();\n+    //~^ ERROR no method named `distance` found for struct `Point<i32>\n+    let d = point_i32.other();\n+    //~^ ERROR no method named `other` found for struct `Point\n+    let v = vec![1_i32, 2, 3];\n+    v.iter().map(|x| x * x).extend(std::iter::once(100));\n+    //~^ ERROR no method named `extend` found for struct `Map\n+    let wrapper = Wrapper(true);\n+    wrapper.method();\n+    //~^ ERROR no method named `method` found for struct `Wrapper<bool>\n+    wrapper.other();\n+    //~^ ERROR no method named `other` found for struct `Wrapper\n+    let boolean = true;\n+    let wrapper = Wrapper2::<'_, _, 3> {x: &boolean};\n+    wrapper.method();\n+    //~^ ERROR no method named `method` found for struct `Wrapper2<'_, bool, 3_usize>\n+    wrapper.other();\n+    //~^ ERROR no method named `other` found for struct `Wrapper2\n+    let a = vec![1, 2, 3];\n+    a.not_found();\n+    //~^ ERROR no method named `not_found` found for struct `Vec\n+    let s = Struct::<f64>::default();\n+    s.method();\n+    //~^ ERROR the method `method` exists for struct `Struct<f64>`, but its trait bounds were not satisfied\n+}"}, {"sha": "1671e5e5e64c81d97a9802349d580053c765a01d", "filename": "src/test/ui/methods/method-not-found-generic-arg-elision.stderr", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f2810d5fa0fb5930a02e2bb4827b037292a83cea/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2810d5fa0fb5930a02e2bb4827b037292a83cea/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr?ref=f2810d5fa0fb5930a02e2bb4827b037292a83cea", "patch": "@@ -0,0 +1,97 @@\n+error[E0599]: no method named `distance` found for struct `Point<i32>` in the current scope\n+  --> $DIR/method-not-found-generic-arg-elision.rs:82:23\n+   |\n+LL | struct Point<T> {\n+   | --------------- method `distance` not found for this\n+...\n+LL |     let d = point_i32.distance();\n+   |                       ^^^^^^^^ method not found in `Point<i32>`\n+   |\n+   = note: the method was found for\n+           - `Point<f64>`\n+\n+error[E0599]: no method named `other` found for struct `Point` in the current scope\n+  --> $DIR/method-not-found-generic-arg-elision.rs:84:23\n+   |\n+LL | struct Point<T> {\n+   | --------------- method `other` not found for this\n+...\n+LL |     let d = point_i32.other();\n+   |                       ^^^^^ method not found in `Point<i32>`\n+\n+error[E0599]: no method named `extend` found for struct `Map` in the current scope\n+  --> $DIR/method-not-found-generic-arg-elision.rs:87:29\n+   |\n+LL |     v.iter().map(|x| x * x).extend(std::iter::once(100));\n+   |                             ^^^^^^ method not found in `Map<std::slice::Iter<'_, i32>, [closure@$DIR/method-not-found-generic-arg-elision.rs:87:18: 87:27]>`\n+\n+error[E0599]: no method named `method` found for struct `Wrapper<bool>` in the current scope\n+  --> $DIR/method-not-found-generic-arg-elision.rs:90:13\n+   |\n+LL | struct Wrapper<T>(T);\n+   | --------------------- method `method` not found for this\n+...\n+LL |     wrapper.method();\n+   |             ^^^^^^ method not found in `Wrapper<bool>`\n+   |\n+   = note: the method was found for\n+           - `Wrapper<i8>`\n+           - `Wrapper<i16>`\n+           - `Wrapper<i32>`\n+           - `Wrapper<i64>`\n+           and 2 more types\n+\n+error[E0599]: no method named `other` found for struct `Wrapper` in the current scope\n+  --> $DIR/method-not-found-generic-arg-elision.rs:92:13\n+   |\n+LL | struct Wrapper<T>(T);\n+   | --------------------- method `other` not found for this\n+...\n+LL |     wrapper.other();\n+   |             ^^^^^ method not found in `Wrapper<bool>`\n+\n+error[E0599]: no method named `method` found for struct `Wrapper2<'_, bool, 3_usize>` in the current scope\n+  --> $DIR/method-not-found-generic-arg-elision.rs:96:13\n+   |\n+LL | struct Wrapper2<'a, T, const C: usize> {\n+   | -------------------------------------- method `method` not found for this\n+...\n+LL |     wrapper.method();\n+   |             ^^^^^^ method not found in `Wrapper2<'_, bool, 3_usize>`\n+   |\n+   = note: the method was found for\n+           - `Wrapper2<'a, i8, C>`\n+           - `Wrapper2<'a, i16, C>`\n+           - `Wrapper2<'a, i32, C>`\n+\n+error[E0599]: no method named `other` found for struct `Wrapper2` in the current scope\n+  --> $DIR/method-not-found-generic-arg-elision.rs:98:13\n+   |\n+LL | struct Wrapper2<'a, T, const C: usize> {\n+   | -------------------------------------- method `other` not found for this\n+...\n+LL |     wrapper.other();\n+   |             ^^^^^ method not found in `Wrapper2<'_, bool, 3_usize>`\n+\n+error[E0599]: no method named `not_found` found for struct `Vec<{integer}>` in the current scope\n+  --> $DIR/method-not-found-generic-arg-elision.rs:101:7\n+   |\n+LL |     a.not_found();\n+   |       ^^^^^^^^^ method not found in `Vec<{integer}>`\n+\n+error[E0599]: the method `method` exists for struct `Struct<f64>`, but its trait bounds were not satisfied\n+  --> $DIR/method-not-found-generic-arg-elision.rs:104:7\n+   |\n+LL | struct Struct<T>{\n+   | ---------------- method `method` not found for this\n+...\n+LL |     s.method();\n+   |       ^^^^^^ method cannot be called on `Struct<f64>` due to unsatisfied trait bounds\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `f64: Eq`\n+           `f64: Ord`\n+\n+error: aborting due to 9 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}]}