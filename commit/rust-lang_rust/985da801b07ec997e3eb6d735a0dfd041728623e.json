{"sha": "985da801b07ec997e3eb6d735a0dfd041728623e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NWRhODAxYjA3ZWM5OTdlM2ViNmQ3MzVhMGRmZDA0MTcyODYyM2U=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-08-16T13:14:11Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-08-16T13:14:11Z"}, "message": "Generate blanket implementations for reexported items as well", "tree": {"sha": "473d38651d27ff22b5aad9217d02a896f15dceb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/473d38651d27ff22b5aad9217d02a896f15dceb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/985da801b07ec997e3eb6d735a0dfd041728623e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/985da801b07ec997e3eb6d735a0dfd041728623e", "html_url": "https://github.com/rust-lang/rust/commit/985da801b07ec997e3eb6d735a0dfd041728623e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/985da801b07ec997e3eb6d735a0dfd041728623e/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afd0a2f2499ff66e74236c5b06d3ab9ab87dd3d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/afd0a2f2499ff66e74236c5b06d3ab9ab87dd3d3", "html_url": "https://github.com/rust-lang/rust/commit/afd0a2f2499ff66e74236c5b06d3ab9ab87dd3d3"}], "stats": {"total": 196, "additions": 106, "deletions": 90}, "files": [{"sha": "b95b3ca8e113853d2e384c7d81b4fc67178258fb", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 88, "deletions": 90, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/985da801b07ec997e3eb6d735a0dfd041728623e/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985da801b07ec997e3eb6d735a0dfd041728623e/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=985da801b07ec997e3eb6d735a0dfd041728623e", "patch": "@@ -65,98 +65,96 @@ impl<'a, 'tcx, 'rcx, 'cstore> BlanketImplFinder <'a, 'tcx, 'rcx, 'cstore> {\n             return impls;\n         }\n         let ty = self.cx.tcx.type_of(def_id);\n-        if self.cx.access_levels.borrow().is_doc_reachable(def_id) || ty.is_primitive() {\n-            let generics = self.cx.tcx.generics_of(def_id);\n-            let real_name = name.clone().map(|name| Ident::from_str(&name));\n-            let param_env = self.cx.tcx.param_env(def_id);\n-            for &trait_def_id in self.cx.all_traits.iter() {\n-                if !self.cx.access_levels.borrow().is_doc_reachable(trait_def_id) ||\n-                   self.cx.generated_synthetics\n-                          .borrow_mut()\n-                          .get(&(def_id, trait_def_id))\n-                          .is_some() {\n-                    continue\n-                }\n-                self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n-                    self.cx.tcx.infer_ctxt().enter(|infcx| {\n-                        let t_generics = infcx.tcx.generics_of(impl_def_id);\n-                        let trait_ref = infcx.tcx.impl_trait_ref(impl_def_id)\n-                                                 .expect(\"Cannot get impl trait\");\n-\n-                        match trait_ref.self_ty().sty {\n-                            ty::TypeVariants::TyParam(_) => {},\n-                            _ => return,\n-                        }\n-\n-                        let substs = infcx.fresh_substs_for_item(DUMMY_SP, def_id);\n-                        let ty = ty.subst(infcx.tcx, substs);\n-                        let param_env = param_env.subst(infcx.tcx, substs);\n-\n-                        let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n-                        let trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n-\n-                        // Require the type the impl is implemented on to match\n-                        // our type, and ignore the impl if there was a mismatch.\n-                        let cause = traits::ObligationCause::dummy();\n-                        let eq_result = infcx.at(&cause, param_env)\n-                                             .eq(trait_ref.self_ty(), ty);\n-                        if let Ok(InferOk { value: (), obligations }) = eq_result {\n-                            // FIXME(eddyb) ignoring `obligations` might cause false positives.\n-                            drop(obligations);\n-\n-                            let may_apply = infcx.predicate_may_hold(&traits::Obligation::new(\n-                                cause.clone(),\n-                                param_env,\n-                                trait_ref.to_predicate(),\n-                            ));\n-                            if !may_apply {\n-                                return\n-                            }\n-                            self.cx.generated_synthetics.borrow_mut()\n-                                                        .insert((def_id, trait_def_id));\n-                            let trait_ = hir::TraitRef {\n-                                path: get_path_for_type(infcx.tcx,\n-                                                        trait_def_id,\n-                                                        hir::def::Def::Trait),\n-                                ref_id: ast::DUMMY_NODE_ID,\n-                                hir_ref_id: hir::DUMMY_HIR_ID,\n-                            };\n-                            let provided_trait_methods =\n-                                infcx.tcx.provided_trait_methods(trait_def_id)\n-                                         .into_iter()\n-                                         .map(|meth| meth.ident.to_string())\n-                                         .collect();\n-\n-                            let ty = self.cx.get_real_ty(def_id, def_ctor, &real_name, generics);\n-                            let predicates = infcx.tcx.predicates_of(impl_def_id);\n-\n-                            impls.push(Item {\n-                                source: infcx.tcx.def_span(impl_def_id).clean(self.cx),\n-                                name: None,\n-                                attrs: Default::default(),\n-                                visibility: None,\n-                                def_id: self.cx.next_def_id(impl_def_id.krate),\n-                                stability: None,\n-                                deprecation: None,\n-                                inner: ImplItem(Impl {\n-                                    unsafety: hir::Unsafety::Normal,\n-                                    generics: (t_generics, &predicates).clean(self.cx),\n-                                    provided_trait_methods,\n-                                    trait_: Some(trait_.clean(self.cx)),\n-                                    for_: ty.clean(self.cx),\n-                                    items: infcx.tcx.associated_items(impl_def_id)\n-                                                    .collect::<Vec<_>>()\n-                                                    .clean(self.cx),\n-                                    polarity: None,\n-                                    synthetic: false,\n-                                    blanket_impl: Some(infcx.tcx.type_of(impl_def_id)\n-                                                                .clean(self.cx)),\n-                                }),\n-                            });\n+        let generics = self.cx.tcx.generics_of(def_id);\n+        let real_name = name.clone().map(|name| Ident::from_str(&name));\n+        let param_env = self.cx.tcx.param_env(def_id);\n+        for &trait_def_id in self.cx.all_traits.iter() {\n+            if !self.cx.access_levels.borrow().is_doc_reachable(trait_def_id) ||\n+               self.cx.generated_synthetics\n+                      .borrow_mut()\n+                      .get(&(def_id, trait_def_id))\n+                      .is_some() {\n+                continue\n+            }\n+            self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n+                self.cx.tcx.infer_ctxt().enter(|infcx| {\n+                    let t_generics = infcx.tcx.generics_of(impl_def_id);\n+                    let trait_ref = infcx.tcx.impl_trait_ref(impl_def_id)\n+                                             .expect(\"Cannot get impl trait\");\n+\n+                    match trait_ref.self_ty().sty {\n+                        ty::TypeVariants::TyParam(_) => {},\n+                        _ => return,\n+                    }\n+\n+                    let substs = infcx.fresh_substs_for_item(DUMMY_SP, def_id);\n+                    let ty = ty.subst(infcx.tcx, substs);\n+                    let param_env = param_env.subst(infcx.tcx, substs);\n+\n+                    let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+                    let trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n+\n+                    // Require the type the impl is implemented on to match\n+                    // our type, and ignore the impl if there was a mismatch.\n+                    let cause = traits::ObligationCause::dummy();\n+                    let eq_result = infcx.at(&cause, param_env)\n+                                         .eq(trait_ref.self_ty(), ty);\n+                    if let Ok(InferOk { value: (), obligations }) = eq_result {\n+                        // FIXME(eddyb) ignoring `obligations` might cause false positives.\n+                        drop(obligations);\n+\n+                        let may_apply = infcx.predicate_may_hold(&traits::Obligation::new(\n+                            cause.clone(),\n+                            param_env,\n+                            trait_ref.to_predicate(),\n+                        ));\n+                        if !may_apply {\n+                            return\n                         }\n-                    });\n+                        self.cx.generated_synthetics.borrow_mut()\n+                                                    .insert((def_id, trait_def_id));\n+                        let trait_ = hir::TraitRef {\n+                            path: get_path_for_type(infcx.tcx,\n+                                                    trait_def_id,\n+                                                    hir::def::Def::Trait),\n+                            ref_id: ast::DUMMY_NODE_ID,\n+                            hir_ref_id: hir::DUMMY_HIR_ID,\n+                        };\n+                        let provided_trait_methods =\n+                            infcx.tcx.provided_trait_methods(trait_def_id)\n+                                     .into_iter()\n+                                     .map(|meth| meth.ident.to_string())\n+                                     .collect();\n+\n+                        let ty = self.cx.get_real_ty(def_id, def_ctor, &real_name, generics);\n+                        let predicates = infcx.tcx.predicates_of(impl_def_id);\n+\n+                        impls.push(Item {\n+                            source: infcx.tcx.def_span(impl_def_id).clean(self.cx),\n+                            name: None,\n+                            attrs: Default::default(),\n+                            visibility: None,\n+                            def_id: self.cx.next_def_id(impl_def_id.krate),\n+                            stability: None,\n+                            deprecation: None,\n+                            inner: ImplItem(Impl {\n+                                unsafety: hir::Unsafety::Normal,\n+                                generics: (t_generics, &predicates).clean(self.cx),\n+                                provided_trait_methods,\n+                                trait_: Some(trait_.clean(self.cx)),\n+                                for_: ty.clean(self.cx),\n+                                items: infcx.tcx.associated_items(impl_def_id)\n+                                                .collect::<Vec<_>>()\n+                                                .clean(self.cx),\n+                                polarity: None,\n+                                synthetic: false,\n+                                blanket_impl: Some(infcx.tcx.type_of(impl_def_id)\n+                                                            .clean(self.cx)),\n+                            }),\n+                        });\n+                    }\n                 });\n-            }\n+            });\n         }\n         impls\n     }"}, {"sha": "355bfa0f2f236b8f3dda969231daa22ac370025f", "filename": "src/test/rustdoc/blanket-reexport-item.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/985da801b07ec997e3eb6d735a0dfd041728623e/src%2Ftest%2Frustdoc%2Fblanket-reexport-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/985da801b07ec997e3eb6d735a0dfd041728623e/src%2Ftest%2Frustdoc%2Fblanket-reexport-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fblanket-reexport-item.rs?ref=985da801b07ec997e3eb6d735a0dfd041728623e", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has foo/struct.S.html '//h3[@id=\"impl-Into\"]//code' 'impl<T, U> Into for T'\n+pub struct S2 {}\n+mod m {\n+    pub struct S {}\n+}\n+pub use m::*;"}]}