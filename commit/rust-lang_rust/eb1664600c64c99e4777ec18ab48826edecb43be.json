{"sha": "eb1664600c64c99e4777ec18ab48826edecb43be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMTY2NDYwMGM2NGM5OWU0Nzc3ZWMxOGFiNDg4MjZlZGVjYjQzYmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-03T02:01:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-03T02:01:32Z"}, "message": "auto merge of #14605 : jakub-/rust/pattern-matching-refactor, r=pcwalton\n\nI've been working around these parts of code and it seems like it could use a bit of a refactor. This is the first step.", "tree": {"sha": "ef9de183fb7ca62452300efe7865d5d3352b771a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef9de183fb7ca62452300efe7865d5d3352b771a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb1664600c64c99e4777ec18ab48826edecb43be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb1664600c64c99e4777ec18ab48826edecb43be", "html_url": "https://github.com/rust-lang/rust/commit/eb1664600c64c99e4777ec18ab48826edecb43be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb1664600c64c99e4777ec18ab48826edecb43be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63e9b8f105ba0fe18e99cb280a23db82380960f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/63e9b8f105ba0fe18e99cb280a23db82380960f4", "html_url": "https://github.com/rust-lang/rust/commit/63e9b8f105ba0fe18e99cb280a23db82380960f4"}, {"sha": "774f36b5d80cdde405be27729b3700abbecf910b", "url": "https://api.github.com/repos/rust-lang/rust/commits/774f36b5d80cdde405be27729b3700abbecf910b", "html_url": "https://github.com/rust-lang/rust/commit/774f36b5d80cdde405be27729b3700abbecf910b"}], "stats": {"total": 366, "additions": 120, "deletions": 246}, "files": [{"sha": "26bc845a15aa97b9f5dcad1c5e94db64760b6362", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 120, "deletions": 246, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/eb1664600c64c99e4777ec18ab48826edecb43be/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1664600c64c99e4777ec18ab48826edecb43be/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=eb1664600c64c99e4777ec18ab48826edecb43be", "patch": "@@ -20,7 +20,7 @@ use util::ppaux::ty_to_str;\n use std::cmp;\n use std::iter;\n use syntax::ast::*;\n-use syntax::ast_util::{unguarded_pat, walk_pat};\n+use syntax::ast_util::{is_unguarded, walk_pat};\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token;\n use syntax::visit;\n@@ -79,26 +79,13 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n            // If the type *is* empty, it's vacuously exhaustive\n            return;\n        }\n-       match ty::get(pat_ty).sty {\n-          ty_enum(did, _) => {\n-              if (*enum_variants(cx.tcx, did)).is_empty() &&\n-                    (*arms).is_empty() {\n-\n-               return;\n-            }\n-          }\n-          _ => { /* We assume only enum types can be uninhabited */ }\n-       }\n-\n-       let pats: Vec<@Pat> = arms.iter()\n-                               .filter_map(unguarded_pat)\n-                               .flat_map(|pats| pats.move_iter())\n-                               .collect();\n-       if pats.is_empty() {\n-           cx.tcx.sess.span_err(ex.span, \"non-exhaustive patterns\");\n-       } else {\n-           check_exhaustive(cx, ex.span, pats);\n-       }\n+       let m: matrix = arms\n+          .iter()\n+          .filter(|&arm| is_unguarded(arm))\n+          .flat_map(|arm| arm.pats.iter())\n+          .map(|pat| vec!(pat.clone()))\n+          .collect();\n+       check_exhaustive(cx, ex.span, &m);\n      }\n      _ => ()\n     }\n@@ -152,9 +139,8 @@ fn raw_pat(p: @Pat) -> @Pat {\n     }\n }\n \n-fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: Vec<@Pat> ) {\n-    assert!((!pats.is_empty()));\n-    let ext = match is_useful(cx, &pats.iter().map(|p| vec!(*p)).collect(), [wild()]) {\n+fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &matrix) {\n+    let ext = match is_useful(cx, m, [wild()]) {\n         not_useful => {\n             // This is good, wildcard pattern isn't reachable\n             return;\n@@ -423,24 +409,12 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n           _ => check_matrix_for_wild(cx, m),\n       },\n       ty::ty_enum(eid, _) => {\n-        let mut found = Vec::new();\n-        for r in m.iter() {\n-            let r = pat_ctor_id(cx, *r.get(0));\n-            for id in r.move_iter() {\n-                if !found.contains(&id) {\n-                    found.push(id);\n-                }\n-            }\n-        }\n+        let pat_ctors: Vec<ctor> = m\n+          .iter()\n+          .filter_map(|r| pat_ctor_id(cx, *r.get(0)))\n+          .collect();\n         let variants = ty::enum_variants(cx.tcx, eid);\n-        if found.len() != (*variants).len() {\n-            for v in (*variants).iter() {\n-                if !found.iter().any(|x| x == &(variant(v.id))) {\n-                    return Some(variant(v.id));\n-                }\n-            }\n-            fail!();\n-        } else { None }\n+        variants.iter().map(|v| variant(v.id)).find(|c| !pat_ctors.contains(c))\n       }\n       ty::ty_nil => None,\n       ty::ty_bool => {\n@@ -581,267 +555,167 @@ fn wild_multi() -> @Pat {\n     @Pat {id: 0, node: PatWildMulti, span: DUMMY_SP}\n }\n \n+fn range_covered_by_constructor(ctor_id: &ctor, from: &const_val, to: &const_val) -> Option<bool> {\n+    let (c_from, c_to) = match *ctor_id {\n+        val(ref value)          => (value, value),\n+        range(ref from, ref to) => (from, to),\n+        single                  => return Some(true),\n+        _                       => unreachable!()\n+    };\n+    let cmp_from = compare_const_vals(c_from, from);\n+    let cmp_to = compare_const_vals(c_to, to);\n+    match (cmp_from, cmp_to) {\n+        (Some(val1), Some(val2)) => Some(val1 >= 0 && val2 <= 0),\n+        _ => None\n+    }\n+}\n+\n fn specialize(cx: &MatchCheckCtxt,\n                   r: &[@Pat],\n                   ctor_id: &ctor,\n                   arity: uint,\n                   left_ty: ty::t)\n                -> Option<Vec<@Pat> > {\n-    // Sad, but I can't get rid of this easily\n-    let r0 = (*raw_pat(r[0])).clone();\n-    match r0 {\n-        Pat{id: pat_id, node: n, span: pat_span} =>\n-            match n {\n-            PatWild => {\n-                Some(Vec::from_elem(arity, wild()).append(r.tail()))\n+    let &Pat{id: ref pat_id, node: ref n, span: ref pat_span} = &(*raw_pat(r[0]));\n+    let head: Option<Vec<@Pat>> = match n {\n+            &PatWild => {\n+                Some(Vec::from_elem(arity, wild()))\n             }\n-            PatWildMulti => {\n-                Some(Vec::from_elem(arity, wild_multi()).append(r.tail()))\n+            &PatWildMulti => {\n+                Some(Vec::from_elem(arity, wild_multi()))\n             }\n-            PatIdent(_, _, _) => {\n-                let opt_def = cx.tcx.def_map.borrow().find_copy(&pat_id);\n+            &PatIdent(_, _, _) => {\n+                let opt_def = cx.tcx.def_map.borrow().find_copy(pat_id);\n                 match opt_def {\n                     Some(DefVariant(_, id, _)) => {\n                         if variant(id) == *ctor_id {\n-                            Some(Vec::from_slice(r.tail()))\n+                            Some(vec!())\n                         } else {\n                             None\n                         }\n                     }\n                     Some(DefStatic(did, _)) => {\n-                        let const_expr =\n-                            lookup_const_by_id(cx.tcx, did).unwrap();\n+                        let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n-                        let match_ = match *ctor_id {\n-                            val(ref v) => {\n-                                match compare_const_vals(&e_v, v) {\n-                                    Some(val1) => (val1 == 0),\n-                                    None => {\n-                                        cx.tcx.sess.span_err(pat_span,\n-                                            \"mismatched types between arms\");\n-                                        false\n-                                    }\n-                                }\n-                            },\n-                            range(ref c_lo, ref c_hi) => {\n-                                let m1 = compare_const_vals(c_lo, &e_v);\n-                                let m2 = compare_const_vals(c_hi, &e_v);\n-                                match (m1, m2) {\n-                                    (Some(val1), Some(val2)) => {\n-                                        (val1 >= 0 && val2 <= 0)\n-                                    }\n-                                    _ => {\n-                                        cx.tcx.sess.span_err(pat_span,\n-                                            \"mismatched types between ranges\");\n-                                        false\n-                                    }\n-                                }\n-                            }\n-                            single => true,\n-                            _ => fail!(\"type error\")\n-                        };\n-                        if match_ {\n-                            Some(Vec::from_slice(r.tail()))\n-                        } else {\n-                            None\n+                        match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n+                           Some(true) => Some(vec!()),\n+                           Some(false) => None,\n+                           None => {\n+                              cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                              None\n+                           }\n                         }\n                     }\n                     _ => {\n-                        Some(Vec::from_elem(arity, wild()).append(r.tail()))\n+                        Some(Vec::from_elem(arity, wild()))\n                     }\n                 }\n             }\n-            PatEnum(_, args) => {\n-                let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n+            &PatEnum(_, ref args) => {\n+                let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n                 match def {\n                     DefStatic(did, _) => {\n-                        let const_expr =\n-                            lookup_const_by_id(cx.tcx, did).unwrap();\n+                        let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n-                        let match_ = match *ctor_id {\n-                            val(ref v) =>\n-                                match compare_const_vals(&e_v, v) {\n-                                    Some(val1) => (val1 == 0),\n-                                    None => {\n-                                        cx.tcx.sess.span_err(pat_span,\n-                                            \"mismatched types between arms\");\n-                                        false\n-                                    }\n-                                },\n-                            range(ref c_lo, ref c_hi) => {\n-                                let m1 = compare_const_vals(c_lo, &e_v);\n-                                let m2 = compare_const_vals(c_hi, &e_v);\n-                                match (m1, m2) {\n-                                    (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n-                                    _ => {\n-                                        cx.tcx.sess.span_err(pat_span,\n-                                            \"mismatched types between ranges\");\n-                                        false\n-                                    }\n-                                }\n-                            }\n-                            single => true,\n-                            _ => fail!(\"type error\")\n-                        };\n-                        if match_ {\n-                            Some(Vec::from_slice(r.tail()))\n-                        } else {\n-                            None\n+                        match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n+                           Some(true) => Some(vec!()),\n+                           Some(false) => None,\n+                           None => {\n+                              cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                              None\n+                           }\n                         }\n                     }\n-                    DefVariant(_, id, _) if variant(id) == *ctor_id => {\n-                        let args = match args {\n-                            Some(args) => args.iter().map(|x| *x).collect(),\n-                            None => Vec::from_elem(arity, wild())\n-                        };\n-                        Some(args.append(r.tail()))\n-                    }\n-                    DefVariant(_, _, _) => None,\n-\n-                    DefFn(..) |\n-                    DefStruct(..) => {\n-                        let new_args;\n-                        match args {\n-                            Some(args) => {\n-                                new_args = args.iter().map(|x| *x).collect()\n-                            }\n-                            None => new_args = Vec::from_elem(arity, wild())\n-                        }\n-                        Some(new_args.append(r.tail()))\n+                    DefVariant(_, id, _) if variant(id) != *ctor_id => None,\n+                    DefVariant(..) | DefFn(..) | DefStruct(..) => {\n+                        Some(match args {\n+                            &Some(ref args) => args.clone(),\n+                            &None => Vec::from_elem(arity, wild())\n+                        })\n                     }\n                     _ => None\n                 }\n             }\n-            PatStruct(_, ref pattern_fields, _) => {\n+            &PatStruct(_, ref pattern_fields, _) => {\n                 // Is this a struct or an enum variant?\n-                let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n-                match def {\n+                let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n+                let class_id = match def {\n                     DefVariant(_, variant_id, _) => {\n-                        if variant(variant_id) == *ctor_id {\n-                            let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n-                            let args = struct_fields.iter().map(|sf| {\n-                                match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n-                                    Some(f) => f.pat,\n-                                    _ => wild()\n-                                }\n-                            }).collect::<Vec<_>>();\n-                            Some(args.append(r.tail()))\n-                        } else {\n-                            None\n-                        }\n+                      if variant(variant_id) == *ctor_id {\n+                        Some(variant_id)\n+                      } else {\n+                        None\n+                      }\n                     }\n                     _ => {\n-                        // Grab the class data that we care about.\n-                        let class_fields;\n-                        let class_id;\n                         match ty::get(left_ty).sty {\n-                            ty::ty_struct(cid, _) => {\n-                                class_id = cid;\n-                                class_fields =\n-                                    ty::lookup_struct_fields(cx.tcx,\n-                                                             class_id);\n-                            }\n+                            ty::ty_struct(cid, _) => Some(cid),\n                             _ => {\n                                 cx.tcx.sess.span_bug(\n-                                    pat_span,\n+                                    *pat_span,\n                                     format!(\"struct pattern resolved to {}, \\\n                                           not a struct\",\n                                          ty_to_str(cx.tcx,\n                                                    left_ty)).as_slice());\n                             }\n                         }\n-                        let args = class_fields.iter().map(|class_field| {\n-                            match pattern_fields.iter().find(|f|\n-                                            f.ident.name == class_field.name) {\n-                                Some(f) => f.pat,\n-                                _ => wild()\n-                            }\n-                        }).collect::<Vec<_>>();\n-                        Some(args.append(r.tail()))\n                     }\n-                }\n+                };\n+                class_id.map(|variant_id| {\n+                  let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n+                  let args = struct_fields.iter().map(|sf| {\n+                      match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n+                          Some(f) => f.pat,\n+                          _ => wild()\n+                      }\n+                  }).collect();\n+                  args\n+                })\n+\n             }\n-            PatTup(args) => {\n-                Some(args.iter().map(|x| *x).collect::<Vec<_>>().append(r.tail()))\n+            &PatTup(ref args) => {\n+                Some(args.clone())\n             }\n-            PatBox(a) | PatRegion(a) => {\n-                Some((vec!(a)).append(r.tail()))\n+            &PatBox(ref inner) | &PatRegion(ref inner) => {\n+                Some(vec!(inner.clone()))\n             }\n-            PatLit(expr) => {\n-                let e_v = eval_const_expr(cx.tcx, expr);\n-                let match_ = match *ctor_id {\n-                    val(ref v) => {\n-                        match compare_const_vals(&e_v, v) {\n-                            Some(val1) => val1 == 0,\n-                            None => {\n-                                cx.tcx.sess.span_err(pat_span,\n-                                    \"mismatched types between arms\");\n-                                false\n-                            }\n-                        }\n-                    },\n-                    range(ref c_lo, ref c_hi) => {\n-                        let m1 = compare_const_vals(c_lo, &e_v);\n-                        let m2 = compare_const_vals(c_hi, &e_v);\n-                        match (m1, m2) {\n-                            (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n-                            _ => {\n-                                cx.tcx.sess.span_err(pat_span,\n-                                    \"mismatched types between ranges\");\n-                                false\n-                            }\n-                        }\n-                    }\n-                    single => true,\n-                    _ => fail!(\"type error\")\n-                };\n-                if match_ {\n-                    Some(Vec::from_slice(r.tail()))\n-                } else {\n+            &PatLit(ref expr) => {\n+              let expr_value = eval_const_expr(cx.tcx, *expr);\n+              match range_covered_by_constructor(ctor_id, &expr_value, &expr_value) {\n+                 Some(true) => Some(vec!()),\n+                 Some(false) => None,\n+                 None => {\n+                    cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n                     None\n-                }\n+                 }\n+              }\n             }\n-            PatRange(lo, hi) => {\n-                let (c_lo, c_hi) = match *ctor_id {\n-                    val(ref v) => ((*v).clone(), (*v).clone()),\n-                    range(ref lo, ref hi) => ((*lo).clone(), (*hi).clone()),\n-                    single => return Some(Vec::from_slice(r.tail())),\n-                    _ => fail!(\"type error\")\n-                };\n-                let v_lo = eval_const_expr(cx.tcx, lo);\n-                let v_hi = eval_const_expr(cx.tcx, hi);\n-\n-                let m1 = compare_const_vals(&c_lo, &v_lo);\n-                let m2 = compare_const_vals(&c_hi, &v_hi);\n-                match (m1, m2) {\n-                    (Some(val1), Some(val2)) if val1 >= 0 && val2 <= 0 => {\n-                        Some(Vec::from_slice(r.tail()))\n-                    },\n-                    (Some(_), Some(_)) => None,\n-                    _ => {\n-                        cx.tcx.sess.span_err(pat_span,\n-                            \"mismatched types between ranges\");\n-                        None\n-                    }\n-                }\n+            &PatRange(ref from, ref to) => {\n+              let from_value = eval_const_expr(cx.tcx, *from);\n+              let to_value = eval_const_expr(cx.tcx, *to);\n+              match range_covered_by_constructor(ctor_id, &from_value, &to_value) {\n+                 Some(true) => Some(vec!()),\n+                 Some(false) => None,\n+                 None => {\n+                    cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                    None\n+                 }\n+              }\n             }\n-            PatVec(before, slice, after) => {\n+            &PatVec(ref before, ref slice, ref after) => {\n                 match *ctor_id {\n                     vec(_) => {\n                         let num_elements = before.len() + after.len();\n                         if num_elements < arity && slice.is_some() {\n                             let mut result = Vec::new();\n-                            let wilds = Vec::from_elem(arity - num_elements, wild());\n-                            result.push_all_move(before);\n-                            result.push_all_move(wilds);\n-                            result.push_all_move(after);\n-                            result.push_all(r.tail());\n+                            result.push_all(before.as_slice());\n+                            result.grow_fn(arity - num_elements, |_| wild());\n+                            result.push_all(after.as_slice());\n                             Some(result)\n                         } else if num_elements == arity {\n                             let mut result = Vec::new();\n-                            result.push_all_move(before);\n-                            result.push_all_move(after);\n-                            result.push_all(r.tail());\n+                            result.push_all(before.as_slice());\n+                            result.push_all(after.as_slice());\n                             Some(result)\n                         } else {\n                             None\n@@ -850,12 +724,12 @@ fn specialize(cx: &MatchCheckCtxt,\n                     _ => None\n                 }\n             }\n-            PatMac(_) => {\n-                cx.tcx.sess.span_err(pat_span, \"unexpanded macro\");\n+            &PatMac(_) => {\n+                cx.tcx.sess.span_err(*pat_span, \"unexpanded macro\");\n                 None\n             }\n-        }\n-    }\n+    };\n+    head.map(|head| head.append(r.tail()))\n }\n \n fn default(cx: &MatchCheckCtxt, r: &[@Pat]) -> Option<Vec<@Pat> > {"}]}