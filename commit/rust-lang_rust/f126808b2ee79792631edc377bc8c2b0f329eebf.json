{"sha": "f126808b2ee79792631edc377bc8c2b0f329eebf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMjY4MDhiMmVlNzk3OTI2MzFlZGMzNzdiYzhjMmIwZjMyOWVlYmY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-02-21T20:46:21Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-02-22T10:09:21Z"}, "message": "Fix handling of binders in canonicalization\n\nI'm looking forward to getting rid of this in favor of Chalk's implementation.", "tree": {"sha": "687760c2eec85bdad42f6c6c56ab32b17a03aa37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/687760c2eec85bdad42f6c6c56ab32b17a03aa37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f126808b2ee79792631edc377bc8c2b0f329eebf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f126808b2ee79792631edc377bc8c2b0f329eebf", "html_url": "https://github.com/rust-lang/rust/commit/f126808b2ee79792631edc377bc8c2b0f329eebf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f126808b2ee79792631edc377bc8c2b0f329eebf/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dfbbaf03b03618dcb7ba203ddc453533bb8d1b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dfbbaf03b03618dcb7ba203ddc453533bb8d1b4", "html_url": "https://github.com/rust-lang/rust/commit/0dfbbaf03b03618dcb7ba203ddc453533bb8d1b4"}], "stats": {"total": 99, "additions": 35, "deletions": 64}, "files": [{"sha": "aed527fe591d3c43d11c1320ef5273349310a66b", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 35, "deletions": 64, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f126808b2ee79792631edc377bc8c2b0f329eebf/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f126808b2ee79792631edc377bc8c2b0f329eebf/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=f126808b2ee79792631edc377bc8c2b0f329eebf", "patch": "@@ -7,10 +7,7 @@ use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n use test_utils::tested_by;\n \n use super::{InferenceContext, Obligation};\n-use crate::{\n-    db::HirDatabase, utils::make_mut_slice, Canonical, InEnvironment, InferTy, ProjectionPredicate,\n-    ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n-};\n+use crate::{db::HirDatabase, Canonical, InEnvironment, InferTy, Substs, Ty, TypeCtor, TypeWalk};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     pub(super) fn canonicalizer<'b>(&'b mut self) -> Canonicalizer<'a, 'b, D>\n@@ -50,42 +47,38 @@ where\n         })\n     }\n \n-    fn do_canonicalize_ty(&mut self, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty {\n-            Ty::Infer(tv) => {\n-                let inner = tv.to_inner();\n-                if self.var_stack.contains(&inner) {\n-                    // recursive type\n-                    return tv.fallback_value();\n-                }\n-                if let Some(known_ty) =\n-                    self.ctx.table.var_unification_table.inlined_probe_value(inner).known()\n-                {\n-                    self.var_stack.push(inner);\n-                    let result = self.do_canonicalize_ty(known_ty.clone());\n-                    self.var_stack.pop();\n-                    result\n-                } else {\n-                    let root = self.ctx.table.var_unification_table.find(inner);\n-                    let free_var = match tv {\n-                        InferTy::TypeVar(_) => InferTy::TypeVar(root),\n-                        InferTy::IntVar(_) => InferTy::IntVar(root),\n-                        InferTy::FloatVar(_) => InferTy::FloatVar(root),\n-                        InferTy::MaybeNeverTypeVar(_) => InferTy::MaybeNeverTypeVar(root),\n-                    };\n-                    let position = self.add(free_var);\n-                    Ty::Bound(position as u32)\n+    fn do_canonicalize<T: TypeWalk>(&mut self, t: T, binders: usize) -> T {\n+        t.fold_binders(\n+            &mut |ty, binders| match ty {\n+                Ty::Infer(tv) => {\n+                    let inner = tv.to_inner();\n+                    if self.var_stack.contains(&inner) {\n+                        // recursive type\n+                        return tv.fallback_value();\n+                    }\n+                    if let Some(known_ty) =\n+                        self.ctx.table.var_unification_table.inlined_probe_value(inner).known()\n+                    {\n+                        self.var_stack.push(inner);\n+                        let result = self.do_canonicalize(known_ty.clone(), binders);\n+                        self.var_stack.pop();\n+                        result\n+                    } else {\n+                        let root = self.ctx.table.var_unification_table.find(inner);\n+                        let free_var = match tv {\n+                            InferTy::TypeVar(_) => InferTy::TypeVar(root),\n+                            InferTy::IntVar(_) => InferTy::IntVar(root),\n+                            InferTy::FloatVar(_) => InferTy::FloatVar(root),\n+                            InferTy::MaybeNeverTypeVar(_) => InferTy::MaybeNeverTypeVar(root),\n+                        };\n+                        let position = self.add(free_var);\n+                        Ty::Bound((position + binders) as u32)\n+                    }\n                 }\n-            }\n-            _ => ty,\n-        })\n-    }\n-\n-    fn do_canonicalize_trait_ref(&mut self, mut trait_ref: TraitRef) -> TraitRef {\n-        for ty in make_mut_slice(&mut trait_ref.substs.0) {\n-            *ty = self.do_canonicalize_ty(ty.clone());\n-        }\n-        trait_ref\n+                _ => ty,\n+            },\n+            binders,\n+        )\n     }\n \n     fn into_canonicalized<T>(self, result: T) -> Canonicalized<T> {\n@@ -95,28 +88,8 @@ where\n         }\n     }\n \n-    fn do_canonicalize_projection_ty(&mut self, mut projection_ty: ProjectionTy) -> ProjectionTy {\n-        for ty in make_mut_slice(&mut projection_ty.parameters.0) {\n-            *ty = self.do_canonicalize_ty(ty.clone());\n-        }\n-        projection_ty\n-    }\n-\n-    fn do_canonicalize_projection_predicate(\n-        &mut self,\n-        projection: ProjectionPredicate,\n-    ) -> ProjectionPredicate {\n-        let ty = self.do_canonicalize_ty(projection.ty);\n-        let projection_ty = self.do_canonicalize_projection_ty(projection.projection_ty);\n-\n-        ProjectionPredicate { ty, projection_ty }\n-    }\n-\n-    // FIXME: add some point, we need to introduce a `Fold` trait that abstracts\n-    // over all the things that can be canonicalized (like Chalk and rustc have)\n-\n     pub(crate) fn canonicalize_ty(mut self, ty: Ty) -> Canonicalized<Ty> {\n-        let result = self.do_canonicalize_ty(ty);\n+        let result = self.do_canonicalize(ty, 0);\n         self.into_canonicalized(result)\n     }\n \n@@ -125,10 +98,8 @@ where\n         obligation: InEnvironment<Obligation>,\n     ) -> Canonicalized<InEnvironment<Obligation>> {\n         let result = match obligation.value {\n-            Obligation::Trait(tr) => Obligation::Trait(self.do_canonicalize_trait_ref(tr)),\n-            Obligation::Projection(pr) => {\n-                Obligation::Projection(self.do_canonicalize_projection_predicate(pr))\n-            }\n+            Obligation::Trait(tr) => Obligation::Trait(self.do_canonicalize(tr, 0)),\n+            Obligation::Projection(pr) => Obligation::Projection(self.do_canonicalize(pr, 0)),\n         };\n         self.into_canonicalized(InEnvironment {\n             value: result,"}]}