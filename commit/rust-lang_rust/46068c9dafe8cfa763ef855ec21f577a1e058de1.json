{"sha": "46068c9dafe8cfa763ef855ec21f577a1e058de1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2MDY4YzlkYWZlOGNmYTc2M2VmODU1ZWMyMWY1NzdhMWUwNThkZTE=", "commit": {"author": {"name": "Stepan Koltsov", "email": "stepan.koltsov@gmail.com", "date": "2015-10-30T21:17:16Z"}, "committer": {"name": "Stepan Koltsov", "email": "stepan.koltsov@gmail.com", "date": "2015-10-30T21:17:16Z"}, "message": "Fix excessive memory allocation in RawVec::reserve\n\nBefore this patch `reserve` function allocated twice as requested\namount elements (not twice as capacity).  It leaded to unnecessary\nexcessive memory usage in scenarios like this:\n\n```\nlet mut v = Vec::new();\nv.push(17);\nv.extend(0..10);\nprintln!(\"{}\", v.capacity());\n```\n\n`Vec` allocated 22 elements, while it could allocate just 11.\n\n`reserve` function must have a property of keeping `push` operation\ncost (which calls `reserve`) `O(1)`. To achieve this `reserve` must\nexponentialy grow its capacity when it does reallocation.\n\nThere's better strategy to implement `reserve`:\n\n```\nlet new_capacity = max(current_capacity * 2, requested_capacity);\n```\n\nThis strategy still guarantees that capacity grows at `O(1)` with\n`reserve`, and fixes the issue with `extend`.\n\nPatch imlpements this strategy.", "tree": {"sha": "19f40fd28979ebc1dd77fde7599ab340ee1a8420", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19f40fd28979ebc1dd77fde7599ab340ee1a8420"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46068c9dafe8cfa763ef855ec21f577a1e058de1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46068c9dafe8cfa763ef855ec21f577a1e058de1", "html_url": "https://github.com/rust-lang/rust/commit/46068c9dafe8cfa763ef855ec21f577a1e058de1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46068c9dafe8cfa763ef855ec21f577a1e058de1/comments", "author": {"login": "stepancheg", "id": 28969, "node_id": "MDQ6VXNlcjI4OTY5", "avatar_url": "https://avatars.githubusercontent.com/u/28969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stepancheg", "html_url": "https://github.com/stepancheg", "followers_url": "https://api.github.com/users/stepancheg/followers", "following_url": "https://api.github.com/users/stepancheg/following{/other_user}", "gists_url": "https://api.github.com/users/stepancheg/gists{/gist_id}", "starred_url": "https://api.github.com/users/stepancheg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stepancheg/subscriptions", "organizations_url": "https://api.github.com/users/stepancheg/orgs", "repos_url": "https://api.github.com/users/stepancheg/repos", "events_url": "https://api.github.com/users/stepancheg/events{/privacy}", "received_events_url": "https://api.github.com/users/stepancheg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stepancheg", "id": 28969, "node_id": "MDQ6VXNlcjI4OTY5", "avatar_url": "https://avatars.githubusercontent.com/u/28969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stepancheg", "html_url": "https://github.com/stepancheg", "followers_url": "https://api.github.com/users/stepancheg/followers", "following_url": "https://api.github.com/users/stepancheg/following{/other_user}", "gists_url": "https://api.github.com/users/stepancheg/gists{/gist_id}", "starred_url": "https://api.github.com/users/stepancheg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stepancheg/subscriptions", "organizations_url": "https://api.github.com/users/stepancheg/orgs", "repos_url": "https://api.github.com/users/stepancheg/repos", "events_url": "https://api.github.com/users/stepancheg/events{/privacy}", "received_events_url": "https://api.github.com/users/stepancheg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "914c4dbc2a1037e63625b0bf846c6b550d0918c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/914c4dbc2a1037e63625b0bf846c6b550d0918c7", "html_url": "https://github.com/rust-lang/rust/commit/914c4dbc2a1037e63625b0bf846c6b550d0918c7"}], "stats": {"total": 52, "additions": 49, "deletions": 3}, "files": [{"sha": "78deed0c84f7f817da9fd2eb3ecf2294d05ecef0", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/46068c9dafe8cfa763ef855ec21f577a1e058de1/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46068c9dafe8cfa763ef855ec21f577a1e058de1/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=46068c9dafe8cfa763ef855ec21f577a1e058de1", "patch": "@@ -15,6 +15,7 @@ use heap;\n use super::oom;\n use super::boxed::Box;\n use core::ops::Drop;\n+use core::cmp;\n use core;\n \n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating a\n@@ -360,9 +361,15 @@ impl<T> RawVec<T> {\n             }\n \n             // Nothing we can really do about these checks :(\n-            let new_cap = used_cap.checked_add(needed_extra_cap)\n-                                  .and_then(|cap| cap.checked_mul(2))\n-                                  .expect(\"capacity overflow\");\n+            let required_cap = used_cap.checked_add(needed_extra_cap)\n+                                       .expect(\"capacity overflow\");\n+\n+            // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n+            let double_cap = self.cap * 2;\n+\n+            // `double_cap` guarantees exponential growth.\n+            let new_cap = cmp::max(double_cap, required_cap);\n+\n             let new_alloc_size = new_cap.checked_mul(elem_size).expect(\"capacity overflow\");\n             // FIXME: may crash and burn on over-reserve\n             alloc_guard(new_alloc_size);\n@@ -486,3 +493,42 @@ fn alloc_guard(alloc_size: usize) {\n                 \"capacity overflow\");\n     }\n }\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn reserve_does_not_overallocate() {\n+        {\n+            let mut v: RawVec<u32> = RawVec::new();\n+            // First `reserve` allocates like `reserve_exact`\n+            v.reserve(0, 9);\n+            assert_eq!(9, v.cap());\n+        }\n+\n+        {\n+            let mut v: RawVec<u32> = RawVec::new();\n+            v.reserve(0, 7);\n+            assert_eq!(7, v.cap());\n+            // 97 if more than double of 7, so `reserve` should work\n+            // like `reserve_exact`.\n+            v.reserve(7, 90);\n+            assert_eq!(97, v.cap());\n+        }\n+\n+        {\n+            let mut v: RawVec<u32> = RawVec::new();\n+            v.reserve(0, 12);\n+            assert_eq!(12, v.cap());\n+            v.reserve(12, 3);\n+            // 3 is less than half of 12, so `reserve` must grow\n+            // exponentially. At the time of writing this test grow\n+            // factor is 2, so new capacity is 24, however, grow factor\n+            // of 1.5 is OK too. Hence `>= 18` in assert.\n+            assert!(v.cap() >= 12 + 12 / 2);\n+        }\n+    }\n+\n+}"}]}