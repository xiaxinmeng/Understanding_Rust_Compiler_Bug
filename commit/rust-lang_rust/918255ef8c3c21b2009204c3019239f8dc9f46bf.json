{"sha": "918255ef8c3c21b2009204c3019239f8dc9f46bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxODI1NWVmOGMzYzIxYjIwMDkyMDRjMzAxOTIzOWY4ZGM5ZjQ2YmY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-31T07:20:40Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-06T21:24:19Z"}, "message": "Impls using the new scheme for slicing", "tree": {"sha": "30be294cdcbb3a6dd2e4280fd8409d8887ffefb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30be294cdcbb3a6dd2e4280fd8409d8887ffefb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/918255ef8c3c21b2009204c3019239f8dc9f46bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/918255ef8c3c21b2009204c3019239f8dc9f46bf", "html_url": "https://github.com/rust-lang/rust/commit/918255ef8c3c21b2009204c3019239f8dc9f46bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/918255ef8c3c21b2009204c3019239f8dc9f46bf/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6539cb417f4a7c2d9d1afce44c196578d2b67f38", "url": "https://api.github.com/repos/rust-lang/rust/commits/6539cb417f4a7c2d9d1afce44c196578d2b67f38", "html_url": "https://github.com/rust-lang/rust/commit/6539cb417f4a7c2d9d1afce44c196578d2b67f38"}], "stats": {"total": 406, "additions": 197, "deletions": 209}, "files": [{"sha": "b05b5e276e8670d70a679de802a8799e3c6642a6", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/918255ef8c3c21b2009204c3019239f8dc9f46bf/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918255ef8c3c21b2009204c3019239f8dc9f46bf/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=918255ef8c3c21b2009204c3019239f8dc9f46bf", "patch": "@@ -818,25 +818,31 @@ impl<'a> Add<&'a str> for String {\n     }\n }\n \n-impl ops::Slice<uint, str> for String {\n+impl<T> ops::Index<ops::Range<uint>, str> for String {\n     #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a str {\n-        unsafe { mem::transmute(self.vec.as_slice()) }\n+    fn index(&self, &index: &ops::Range<uint>) -> &str {\n+        self[][*index]\n     }\n+}\n \n+impl<T> ops::Index<ops::RangeTo<uint>, str> for String {\n     #[inline]\n-    fn slice_from_or_fail<'a>(&'a self, from: &uint) -> &'a str {\n-        self[][*from..]\n+    fn index(&self, &index: &ops::RangeTo<uint>) -> &str {\n+        self[][*index]\n     }\n+}\n \n+impl<T> ops::Index<ops::RangeFrom<uint>, str> for String {\n     #[inline]\n-    fn slice_to_or_fail<'a>(&'a self, to: &uint) -> &'a str {\n-        self[][..*to]\n+    fn index(&self, &index: &ops::RangeFrom<uint>) -> &str {\n+        self[][*index]\n     }\n+}\n \n+impl<T> ops::Index<ops::FullRange<uint>, str> for String {\n     #[inline]\n-    fn slice_or_fail<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n-        self[][*from..*to]\n+    fn index(&self, &index: &ops::FullRange<uint>) -> &str {\n+        unsafe { mem::transmute(self.vec.as_slice()) }\n     }\n }\n "}, {"sha": "c057939df2b421e9fb6a92dc0613cb56c5e6258f", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/918255ef8c3c21b2009204c3019239f8dc9f46bf/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918255ef8c3c21b2009204c3019239f8dc9f46bf/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=918255ef8c3c21b2009204c3019239f8dc9f46bf", "patch": "@@ -1211,43 +1211,64 @@ impl<T> IndexMut<uint> for Vec<T> {\n \n impl<T> ops::Slice<uint, [T]> for Vec<T> {\n     #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a [T] {\n-        self.as_slice()\n+    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n+        &mut self.as_mut_slice()[*index]\n     }\n+}\n \n+impl<T> ops::Index<ops::Range<uint>, [T]> for Vec<T> {\n     #[inline]\n-    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n-        self.as_slice().slice_from_or_fail(start)\n+    fn index(&self, &index: &ops::Range<uint>) -> &[T] {\n+        self.as_slice().index(index)\n     }\n+}\n \n+impl<T> ops::Index<ops::RangeTo<uint>, [T]> for Vec<T> {\n     #[inline]\n-    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n-        self.as_slice().slice_to_or_fail(end)\n+    fn index(&self, &index: &ops::RangeTo<uint>) -> &[T] {\n+        self.as_slice().index(index)\n     }\n+}\n+\n+impl<T> ops::Index<ops::RangeFrom<uint>, [T]> for Vec<T> {\n     #[inline]\n-    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        self.as_slice().slice_or_fail(start, end)\n+    fn index(&self, &index: &ops::RangeFrom<uint>) -> &[T] {\n+        self.as_slice().index(index)\n     }\n }\n \n-impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n+impl<T> ops::Index<ops::FullRange<uint>, [T]> for Vec<T> {\n     #[inline]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n-        self.as_mut_slice()\n+    fn index(&self, &index: &ops::FullRange<uint>) -> &[T] {\n+        self.as_slice()\n     }\n+}\n \n+impl<T> ops::IndexMut<ops::Range<uint>, [T]> for Vec<T> {\n     #[inline]\n-    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_from_or_fail_mut(start)\n+    fn index_mut(&mut self, &index: &ops::Range<uint>) -> &mut [T] {\n+        self.as_mut_slice().index_mut(index)\n     }\n+}\n \n+impl<T> ops::IndexMut<ops::RangeTo<uint>, [T]> for Vec<T> {\n     #[inline]\n-    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_to_or_fail_mut(end)\n+    fn index_mut(&mut self, &index: &ops::RangeTo<uint>) -> &mut [T] {\n+        self.as_mut_slice().index_mut(index)\n     }\n+}\n+\n+impl<T> ops::IndexMut<ops::RangeFrom<uint>, [T]> for Vec<T> {\n     #[inline]\n-    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_or_fail_mut(start, end)\n+    fn index_mut(&mut self, &index: &ops::RangeFrom<uint>) -> &mut [T] {\n+        self.as_mut_slice().index_mut(index)\n+    }\n+}\n+\n+impl<T> ops::IndexMut<ops::FullRange<uint>, [T]> for Vec<T> {\n+    #[inline]\n+    fn index_mut(&mut self, &index: &ops::FullRange<uint>) -> &mut [T] {\n+        self.as_mut_slice()\n     }\n }\n "}, {"sha": "2a7e6eb47955d2c642bbff73e181d2faac05ad8a", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/918255ef8c3c21b2009204c3019239f8dc9f46bf/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918255ef8c3c21b2009204c3019239f8dc9f46bf/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=918255ef8c3c21b2009204c3019239f8dc9f46bf", "patch": "@@ -846,105 +846,6 @@ pub trait IndexMut<Index: ?Sized> {\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Self::Output;\n }\n \n-/// The `Slice` trait is used to specify the functionality of slicing operations\n-/// like `arr[from..to]` when used in an immutable context.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Slice`. When `Foo[..Foo]` happens, it ends up\n-/// calling `slice_to`, and therefore, `main` prints `Slicing!`.\n-///\n-/// ```ignore\n-/// use std::ops::Slice;\n-///\n-/// #[derive(Copy)]\n-/// struct Foo;\n-///\n-/// impl Slice<Foo, Foo> for Foo {\n-///     fn as_slice_<'a>(&'a self) -> &'a Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-///     fn slice_from_or_fail<'a>(&'a self, _from: &Foo) -> &'a Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-///     fn slice_to_or_fail<'a>(&'a self, _to: &Foo) -> &'a Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-///     fn slice_or_fail<'a>(&'a self, _from: &Foo, _to: &Foo) -> &'a Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo[..Foo];\n-/// }\n-/// ```\n-#[lang=\"slice\"]\n-pub trait Slice<Idx: ?Sized, Result: ?Sized> {\n-    /// The method for the slicing operation foo[]\n-    fn as_slice_<'a>(&'a self) -> &'a Result;\n-    /// The method for the slicing operation foo[from..]\n-    fn slice_from_or_fail<'a>(&'a self, from: &Idx) -> &'a Result;\n-    /// The method for the slicing operation foo[..to]\n-    fn slice_to_or_fail<'a>(&'a self, to: &Idx) -> &'a Result;\n-    /// The method for the slicing operation foo[from..to]\n-    fn slice_or_fail<'a>(&'a self, from: &Idx, to: &Idx) -> &'a Result;\n-}\n-\n-/// The `SliceMut` trait is used to specify the functionality of slicing\n-/// operations like `arr[from..to]`, when used in a mutable context.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `SliceMut`. When `Foo[Foo..]` happens, it ends up\n-/// calling `slice_from_mut`, and therefore, `main` prints `Slicing!`.\n-///\n-/// ```ignore\n-/// use std::ops::SliceMut;\n-///\n-/// #[derive(Copy)]\n-/// struct Foo;\n-///\n-/// impl SliceMut<Foo, Foo> for Foo {\n-///     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-///     fn slice_from_or_fail_mut<'a>(&'a mut self, _from: &Foo) -> &'a mut Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-///     fn slice_to_or_fail_mut<'a>(&'a mut self, _to: &Foo) -> &'a mut Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-///     fn slice_or_fail_mut<'a>(&'a mut self, _from: &Foo, _to: &Foo) -> &'a mut Foo {\n-///         println!(\"Slicing!\");\n-///         self\n-///     }\n-/// }\n-///\n-/// pub fn main() {\n-///     Foo[mut Foo..];\n-/// }\n-/// ```\n-#[lang=\"slice_mut\"]\n-pub trait SliceMut<Idx: ?Sized, Result: ?Sized> {\n-    /// The method for the slicing operation foo[]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Result;\n-    /// The method for the slicing operation foo[from..]\n-    fn slice_from_or_fail_mut<'a>(&'a mut self, from: &Idx) -> &'a mut Result;\n-    /// The method for the slicing operation foo[..to]\n-    fn slice_to_or_fail_mut<'a>(&'a mut self, to: &Idx) -> &'a mut Result;\n-    /// The method for the slicing operation foo[from..to]\n-    fn slice_or_fail_mut<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n-}\n-\n-\n /// An unbounded range.\n #[derive(Copy)]\n #[lang=\"full_range\"]\n@@ -962,8 +863,6 @@ pub struct Range<Idx> {\n     pub end: Idx,\n }\n \n-// FIXME(#19391) needs a snapshot\n-//impl<Idx: Clone + Step<T=uint>> Iterator<Idx> for Range<Idx> {\n #[unstable = \"API still in development\"]\n impl<Idx: Clone + Step> Iterator for Range<Idx> {\n     type Item = Idx;"}, {"sha": "a560b68db01fa89cf50098f2f9e5f1d4e792ea16", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918255ef8c3c21b2009204c3019239f8dc9f46bf/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918255ef8c3c21b2009204c3019239f8dc9f46bf/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=918255ef8c3c21b2009204c3019239f8dc9f46bf", "patch": "@@ -30,7 +30,7 @@\n \n // Reexported core operators\n pub use kinds::{Copy, Send, Sized, Sync};\n-pub use ops::{Drop, Fn, FnMut, FnOnce};\n+pub use ops::{Drop, Fn, FnMut, FnOnce, FullRange};\n \n // Reexported functions\n pub use iter::range;"}, {"sha": "369652b215f24b7acc4ed6b79ed4b9a9a378d96c", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 128, "deletions": 72, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/918255ef8c3c21b2009204c3019239f8dc9f46bf/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918255ef8c3c21b2009204c3019239f8dc9f46bf/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=918255ef8c3c21b2009204c3019239f8dc9f46bf", "patch": "@@ -292,26 +292,26 @@ impl<T> SliceExt for [T] {\n     fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n     fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T] {\n-        ops::SliceMut::slice_or_fail_mut(self, &start, &end)\n+        ops::IndexMut::index_mut(self, &ops::Range { start: start, end: end } )\n     }\n \n     #[inline]\n     fn slice_from_mut(&mut self, start: uint) -> &mut [T] {\n-        ops::SliceMut::slice_from_or_fail_mut(self, &start)\n+        ops::IndexMut::index_mut(self, &ops::RangeFrom { start: start } )\n     }\n \n     #[inline]\n     fn slice_to_mut(&mut self, end: uint) -> &mut [T] {\n-        ops::SliceMut::slice_to_or_fail_mut(self, &end)\n+        ops::IndexMut::index_mut(self, &ops::RangeTo { end: end } )\n     }\n \n     #[inline]\n     fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]) {\n         unsafe {\n             let self2: &mut [T] = mem::transmute_copy(&self);\n \n-            (ops::SliceMut::slice_to_or_fail_mut(self, &mid),\n-             ops::SliceMut::slice_from_or_fail_mut(self2, &mid))\n+            (ops::IndexMut::index_mut(self, &ops::RangeTo { end: mid } ),\n+             ops::IndexMut::index_mut(self2, &ops::RangeFrom { start: mid } ))\n         }\n     }\n \n@@ -551,63 +551,78 @@ impl<T> ops::IndexMut<uint> for [T] {\n     }\n }\n \n-impl<T> ops::Slice<uint, [T]> for [T] {\n+impl<T> ops::Index<ops::Range<uint>, [T]> for [T] {\n     #[inline]\n-    fn as_slice_<'a>(&'a self) -> &'a [T] {\n-        self\n+    fn index(&self, &index: &ops::Range<uint>) -> &[T] {\n+        assert!(index.start <= index.end);\n+        assert!(index.end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(index.start as int),\n+                    len: index.end - index.start\n+                })\n+        }\n+    }\n+}\n+\n+impl<T> ops::Index<ops::RangeTo<uint>, [T]> for [T] {\n+    #[inline]\n+    fn index(&self, &index: &ops::RangeTo<uint>) -> &[T] {\n+        self.index(&ops::Range{ start: 0, end: index.end })\n     }\n+}\n \n+impl<T> ops::Index<ops::RangeFrom<uint>, [T]> for [T] {\n     #[inline]\n-    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {\n-        self.slice_or_fail(start, &self.len())\n+    fn index(&self, &index: &ops::RangeFrom<uint>) -> &[T] {\n+        self.index(&ops::Range{ start: index.start, end: self.len() })\n     }\n+}\n \n+impl<T> ops::Index<ops::FullRange, [T]> for [T] {\n     #[inline]\n-    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {\n-        self.slice_or_fail(&0, end)\n+    fn index(&self, &index: &ops::FullRange) -> &[T] {\n+        self\n     }\n+}\n+\n+impl<T> ops::IndexMut<ops::Range<uint>, [T]> for [T] {\n     #[inline]\n-    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n+    fn index_mut(&mut self, &index: &ops::Range<uint>) -> &mut [T] {\n+        assert!(index.start <= index.end);\n+        assert!(index.end <= self.len());\n         unsafe {\n             transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n+                    data: self.as_ptr().offset(index.start as int),\n+                    len: index.end - index.start\n                 })\n         }\n     }\n }\n \n-impl<T> ops::SliceMut<uint, [T]> for [T] {\n+impl<T> ops::IndexMut<ops::RangeTo<uint>, [T]> for [T] {\n     #[inline]\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n-        self\n+    fn index_mut(&mut self, &index: &ops::RangeTo<uint>) -> &mut [T] {\n+        self.index_mut(&ops::Range{ start: 0, end: index.end })\n     }\n+}\n \n+impl<T> ops::IndexMut<ops::RangeFrom<uint>, [T]> for [T] {\n     #[inline]\n-    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        let len = &self.len();\n-        self.slice_or_fail_mut(start, len)\n+    fn index_mut(&mut self, &index: &ops::RangeFrom<uint>) -> &mut [T] {\n+        let len = self.len();\n+        self.index_mut(&ops::Range{ start: index.start, end: len })\n     }\n+}\n \n+impl<T> ops::IndexMut<ops::FullRange, [T]> for [T] {\n     #[inline]\n-    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.slice_or_fail_mut(&0, end)\n-    }\n-    #[inline]\n-    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n-                })\n-        }\n+    fn index_mut(&mut self, &index: &ops::FullRange) -> &mut [T] {\n+        self\n     }\n }\n \n+\n ////////////////////////////////////////////////////////////////////////////////\n // Common traits\n ////////////////////////////////////////////////////////////////////////////////\n@@ -738,24 +753,38 @@ pub struct Iter<'a, T: 'a> {\n }\n \n #[experimental]\n-impl<'a, T> ops::Slice<uint, [T]> for Iter<'a, T> {\n-    fn as_slice_(&self) -> &[T] {\n-        self.as_slice()\n+impl<'a, T> ops::Index<ops::Range<uint>, [T]> for Iter<'a, T> {\n+    #[inline]\n+    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+        self.as_slice().index(index)\n     }\n-    fn slice_from_or_fail<'b>(&'b self, from: &uint) -> &'b [T] {\n-        use ops::Slice;\n-        self.as_slice().slice_from_or_fail(from)\n+}\n+\n+#[experimental]\n+impl<'a, T> ops::Index<ops::RangeTo<uint>, [T]> for Iter<'a, T> {\n+    #[inline]\n+    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n+        self.as_slice().index(index)\n     }\n-    fn slice_to_or_fail<'b>(&'b self, to: &uint) -> &'b [T] {\n-        use ops::Slice;\n-        self.as_slice().slice_to_or_fail(to)\n+}\n+\n+#[experimental]\n+impl<'a, T> ops::Index<ops::RangeFrom<uint>, [T]> for Iter<'a, T> {\n+    #[inline]\n+    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n+        self.as_slice().index(index)\n     }\n-    fn slice_or_fail<'b>(&'b self, from: &uint, to: &uint) -> &'b [T] {\n-        use ops::Slice;\n-        self.as_slice().slice_or_fail(from, to)\n+}\n+\n+#[experimental]\n+impl<'a, T> ops::Index<ops::FullRange, [T]> for Iter<'a, T> {\n+    #[inline]\n+    fn index(&self, index: &ops::FullRange) -> &[T] {\n+        self.as_slice()\n     }\n }\n \n+\n impl<'a, T> Iter<'a, T> {\n     /// View the underlying data as a subslice of the original data.\n     ///\n@@ -813,43 +842,70 @@ pub struct IterMut<'a, T: 'a> {\n }\n \n #[experimental]\n-impl<'a, T> ops::Slice<uint, [T]> for IterMut<'a, T> {\n-    fn as_slice_<'b>(&'b self) -> &'b [T] {\n-        make_slice!(T -> &'b [T]: self.ptr, self.end)\n+impl<'a, T> ops::Index<ops::Range<uint>, [T]> for IterMut<'a, T> {\n+    #[inline]\n+    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+        self.index(&ops::FullRange).index(index)\n     }\n-    fn slice_from_or_fail<'b>(&'b self, from: &uint) -> &'b [T] {\n-        use ops::Slice;\n-        self.as_slice_().slice_from_or_fail(from)\n+}\n+\n+#[experimental]\n+impl<'a, T> ops::Index<ops::RangeTo<uint>, [T]> for IterMut<'a, T> {\n+    #[inline]\n+    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n+        self.index(&ops::FullRange).index(index)\n     }\n-    fn slice_to_or_fail<'b>(&'b self, to: &uint) -> &'b [T] {\n-        use ops::Slice;\n-        self.as_slice_().slice_to_or_fail(to)\n+}\n+\n+#[experimental]\n+impl<'a, T> ops::Index<ops::RangeFrom<uint>, [T]> for IterMut<'a, T> {\n+    #[inline]\n+    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n+        self.index(&ops::FullRange).index(index)\n     }\n-    fn slice_or_fail<'b>(&'b self, from: &uint, to: &uint) -> &'b [T] {\n-        use ops::Slice;\n-        self.as_slice_().slice_or_fail(from, to)\n+}\n+\n+#[experimental]\n+impl<'a, T> ops::Index<ops::FullRange, [T]> for IterMut<'a, T> {\n+    #[inline]\n+    fn index(&self, index: &ops::FullRange) -> &[T] {\n+        make_slice!(T -> &[T]: self.ptr, self.end)\n     }\n }\n \n #[experimental]\n-impl<'a, T> ops::SliceMut<uint, [T]> for IterMut<'a, T> {\n-    fn as_mut_slice_<'b>(&'b mut self) -> &'b mut [T] {\n-        make_slice!(T -> &'b mut [T]: self.ptr, self.end)\n+impl<'a, T> ops::IndexMut<ops::Range<uint>, [T]> for IterMut<'a, T> {\n+    #[inline]\n+    fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n+        self.index_mut(&ops::FullRange).index_mut(index)\n     }\n-    fn slice_from_or_fail_mut<'b>(&'b mut self, from: &uint) -> &'b mut [T] {\n-        use ops::SliceMut;\n-        self.as_mut_slice_().slice_from_or_fail_mut(from)\n+}\n+\n+#[experimental]\n+impl<'a, T> ops::IndexMut<ops::RangeTo<uint>, [T]> for IterMut<'a, T> {\n+    #[inline]\n+    fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n+        self.index_mut(&ops::FullRange).index_mut(index)\n     }\n-    fn slice_to_or_fail_mut<'b>(&'b mut self, to: &uint) -> &'b mut [T] {\n-        use ops::SliceMut;\n-        self.as_mut_slice_().slice_to_or_fail_mut(to)\n+}\n+\n+#[experimental]\n+impl<'a, T> ops::IndexMut<ops::RangeFrom<uint>, [T]> for IterMut<'a, T> {\n+    #[inline]\n+    fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n+        self.index_mut(&ops::FullRange).index_mut(index)\n     }\n-    fn slice_or_fail_mut<'b>(&'b mut self, from: &uint, to: &uint) -> &'b mut [T] {\n-        use ops::SliceMut;\n-        self.as_mut_slice_().slice_or_fail_mut(from, to)\n+}\n+\n+#[experimental]\n+impl<'a, T> ops::IndexMut<ops::FullRange, [T]> for IterMut<'a, T> {\n+    #[inline]\n+    fn index_mut(&mut self, index: &ops::FullRange) -> &mut [T] {\n+        make_slice!(T -> &mut [T]: self.ptr, self.end)\n     }\n }\n \n+\n impl<'a, T> IterMut<'a, T> {\n     /// View the underlying data as a subslice of the original data.\n     ///"}, {"sha": "a28e56144177ed417fd3746e21a6f2a915587d46", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/918255ef8c3c21b2009204c3019239f8dc9f46bf/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918255ef8c3c21b2009204c3019239f8dc9f46bf/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=918255ef8c3c21b2009204c3019239f8dc9f46bf", "patch": "@@ -1119,25 +1119,31 @@ mod traits {\n         }\n     }\n \n-    impl ops::Slice<uint, str> for str {\n+    impl ops::Index<ops::Range<uint>, str> for str {\n         #[inline]\n-        fn as_slice_<'a>(&'a self) -> &'a str {\n-            self\n+        fn index(&self, &index: &ops::Range<uint>) -> &str {\n+            self.slice(index.start, index.end)\n         }\n+    }\n \n+    impl ops::Index<ops::RangeTo<uint>, str> for str {\n         #[inline]\n-        fn slice_from_or_fail<'a>(&'a self, from: &uint) -> &'a str {\n-            self.slice_from(*from)\n+        fn index(&self, &index: &ops::RangeTo<uint>) -> &str {\n+            self.slice_to(index.end)\n         }\n+    }\n \n+    impl ops::Index<ops::RangeFrom<uint>, str> for str {\n         #[inline]\n-        fn slice_to_or_fail<'a>(&'a self, to: &uint) -> &'a str {\n-            self.slice_to(*to)\n+        fn index(&self, &index: &ops::RangeFrom<uint>) -> &str {\n+            self.slice_from(index.start)\n         }\n+    }\n \n+    impl ops::Index<ops::FullRange, str> for str {\n         #[inline]\n-        fn slice_or_fail<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n-            self.slice(*from, *to)\n+        fn index(&self, &index: &ops::FullRange) -> &str {\n+            self\n         }\n     }\n }"}]}