{"sha": "d2ea3daad1372cffa5caf9f20fe36667e334662b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZWEzZGFhZDEzNzJjZmZhNWNhZjlmMjBmZTM2NjY3ZTMzNDY2MmI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-05T09:18:45Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:03Z"}, "message": "rustc_metadata: group the tags into root tags and item tags.", "tree": {"sha": "3a8e9077a1aa1dbe8deb319bb99926a1fe9f4eb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a8e9077a1aa1dbe8deb319bb99926a1fe9f4eb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2ea3daad1372cffa5caf9f20fe36667e334662b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ea3daad1372cffa5caf9f20fe36667e334662b", "html_url": "https://github.com/rust-lang/rust/commit/d2ea3daad1372cffa5caf9f20fe36667e334662b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2ea3daad1372cffa5caf9f20fe36667e334662b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89736e86716808801732323f3aa848b97fc2b5ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/89736e86716808801732323f3aa848b97fc2b5ba", "html_url": "https://github.com/rust-lang/rust/commit/89736e86716808801732323f3aa848b97fc2b5ba"}], "stats": {"total": 517, "additions": 205, "deletions": 312}, "files": [{"sha": "9d4ed84993f12a9324d0424f34c8c9f70aa1b1d9", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea3daad1372cffa5caf9f20fe36667e334662b/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea3daad1372cffa5caf9f20fe36667e334662b/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=d2ea3daad1372cffa5caf9f20fe36667e334662b", "patch": "@@ -33,7 +33,7 @@ use rustc_serialize::{Decodable, Encodable};\n // Top-level methods.\n \n pub fn encode_inlined_item(ecx: &mut EncodeContext, ii: InlinedItemRef) {\n-    ecx.tag(::common::tag_ast, |ecx| {\n+    ecx.tag(::common::item_tag::ast, |ecx| {\n         let mut visitor = IdRangeComputingVisitor::new();\n         match ii {\n             InlinedItemRef::Item(_, i) => visitor.visit_item(i),"}, {"sha": "04b9b7f7c67133d8fba7ed9a9f9fdca021be06c8", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 65, "deletions": 161, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea3daad1372cffa5caf9f20fe36667e334662b/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea3daad1372cffa5caf9f20fe36667e334662b/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=d2ea3daad1372cffa5caf9f20fe36667e334662b", "patch": "@@ -35,178 +35,82 @@ pub enum Family {\n     AssociatedConst,\n }\n \n-// GAP 0x00...0x19\n-\n-pub const tag_items: usize = 0x100; // top-level only\n-\n-pub const tag_paths_data_name: usize = 0x20;\n-\n-pub const tag_def_index: usize = 0x21;\n-\n-pub const tag_items_data: usize = 0x22;\n-\n-pub const tag_items_data_item: usize = 0x23;\n-\n-pub const tag_items_data_item_family: usize = 0x24;\n-\n-pub const tag_items_data_item_type: usize = 0x25;\n-\n-// GAP 0x26, 0x27\n-\n-pub const tag_items_data_parent_item: usize = 0x28;\n-\n-pub const tag_items_data_item_is_tuple_struct_ctor: usize = 0x29;\n-\n-pub const tag_items_closure_kind: usize = 0x2a;\n-pub const tag_items_closure_ty: usize = 0x2b;\n-pub const tag_def_key: usize = 0x2c;\n-\n-// GAP 0x2d 0x34\n-\n-pub const tag_index: usize = 0x110; // top-level only\n-pub const tag_xref_index: usize = 0x111; // top-level only\n-pub const tag_xref_data: usize = 0x112; // top-level only\n-pub const tag_attributes: usize = 0x101; // top-level only\n-\n-// The list of crates that this crate depends on\n-pub const tag_crate_deps: usize = 0x102; // top-level only\n-pub const tag_crate_hash: usize = 0x103; // top-level only\n-pub const tag_crate_crate_name: usize = 0x104; // top-level only\n-pub const tag_crate_disambiguator: usize = 0x113; // top-level only\n-\n-// GAP 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a\n-\n-pub const tag_item_trait_ref: usize = 0x3b;\n-\n-// discriminator value for variants\n-pub const tag_disr_val: usize = 0x3c;\n-\n-// GAP 0x3d, 0x3e, 0x3f, 0x40\n-\n-pub const tag_item_fields: usize = 0x41;\n-// GAP 0x42\n-pub const tag_item_variances: usize = 0x43;\n-// GAP 0x44\n-pub const tag_item_trait_method_explicit_self: usize = 0x45;\n-\n-// GAP 0x46, 0x47, 0x48\n-\n-// used to encode crate_ctxt side tables\n-pub const tag_ast: usize = 0x50;\n-\n-// GAP 0x51\n-\n-pub const tag_mir: usize = 0x52;\n-\n-// GAP 0x53...0x6a\n-\n-pub const tag_item_trait_item_has_body: usize = 0x70;\n-\n-pub const tag_crate_triple: usize = 0x105; // top-level only\n-\n-pub const tag_dylib_dependency_formats: usize = 0x106; // top-level only\n-\n-pub const tag_lang_items: usize = 0x107; // top-level only\n-\n-// GAP 0x73, 0x74, 0x75\n-\n-pub const tag_lang_items_missing: usize = 0x76; // top-level only\n-\n-// GAP 0x77\n-\n-pub const tag_items_data_item_visibility: usize = 0x78;\n-pub const tag_items_data_item_inherent_impls: usize = 0x79;\n-\n-// GAP 0x7a\n-\n-// GAP 0x7c\n-pub const tag_mod_children: usize = 0x7b;\n-\n-// GAP 0x108 // top-level only\n+// NB: increment this if you change the format of metadata such that\n+// rustc_version can't be found.\n+pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2];\n \n // GAP 0x7c\n-\n // GAP 0x108\n-pub const tag_impls: usize = 0x109; // top-level only\n-\n-// GAP 0x7d, 0x7e, 0x7f, 0x80, 0x81\n-\n-pub const tag_native_libraries: usize = 0x10a; // top-level only\n-\n-// GAP 0x82, 0x83, 0x84\n-\n-pub const tag_plugin_registrar_fn: usize = 0x10b; // top-level only\n-\n-pub const tag_method_argument_names: usize = 0x85;\n-\n-// GAP 0x86\n-\n-pub const tag_reachable_ids: usize = 0x10c; // top-level only\n-\n-// GAP 0x87\n-\n-pub const tag_items_data_item_stability: usize = 0x88;\n-\n-pub const tag_items_data_item_repr: usize = 0x89;\n-\n-// GAP 0x10d // top-level only\n-\n-// GAP 0x8a\n-\n-pub const tag_items_data_item_struct_ctor: usize = 0x8b;\n-pub const tag_attribute_is_sugared_doc: usize = 0x8c;\n-// GAP 0x8d\n-pub const tag_items_data_region: usize = 0x8e;\n-\n-pub const tag_item_generics: usize = 0x8f;\n-// GAP 0x90, 0x91, 0x92, 0x93, 0x94\n-\n-pub const tag_item_predicates: usize = 0x95;\n-// GAP 0x96, 0x97, 0x98, 0x99\n-\n-pub const tag_unsafety: usize = 0x9a;\n-\n-pub const tag_polarity: usize = 0x9d;\n-\n-pub const tag_macro_defs: usize = 0x10e; // top-level only\n-\n-// GAP 0x9e, 0x9f\n-\n-pub const tag_paren_sugar: usize = 0xa0;\n-\n-pub const tag_codemap: usize = 0xa1;\n-\n-// GAP 0xa2\n-\n-pub const tag_item_super_predicates: usize = 0xa3;\n-\n-pub const tag_defaulted_trait: usize = 0xa4;\n-\n-pub const tag_impl_coerce_unsized_kind: usize = 0xa5;\n-\n-pub const tag_items_data_item_constness: usize = 0xa6;\n-\n-pub const tag_items_data_item_deprecation: usize = 0xa7;\n-\n-pub const tag_items_data_item_defaultness: usize = 0xa8;\n-\n-pub const tag_items_data_parent_impl: usize = 0xa9;\n-\n-pub const tag_rustc_version: usize = 0x10f;\n pub fn rustc_version() -> String {\n     format!(\n         \"rustc {}\",\n         option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\")\n     )\n }\n \n-pub const tag_panic_strategy: usize = 0x114;\n-\n-pub const tag_macro_derive_registrar: usize = 0x115;\n+pub mod root_tag {\n+    pub const rustc_version: usize = 0x10f;\n+    pub const crate_deps: usize = 0x102;\n+    pub const crate_hash: usize = 0x103;\n+    pub const crate_crate_name: usize = 0x104;\n+    pub const crate_disambiguator: usize = 0x113;\n+    pub const items: usize = 0x100;\n+    pub const index: usize = 0x110;\n+    pub const xref_index: usize = 0x111;\n+    pub const xref_data: usize = 0x112;\n+    pub const crate_triple: usize = 0x105;\n+    pub const dylib_dependency_formats: usize = 0x106;\n+    pub const lang_items: usize = 0x107;\n+    pub const lang_items_missing: usize = 0x76;\n+    pub const impls: usize = 0x109;\n+    pub const native_libraries: usize = 0x10a;\n+    pub const plugin_registrar_fn: usize = 0x10b;\n+    pub const panic_strategy: usize = 0x114;\n+    pub const macro_derive_registrar: usize = 0x115;\n+    pub const reachable_ids: usize = 0x10c;\n+    pub const macro_defs: usize = 0x10e;\n+    pub const codemap: usize = 0xa1;\n+}\n \n-// NB: increment this if you change the format of metadata such that\n-// rustc_version can't be found.\n-pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2];\n+pub mod item_tag {\n+    pub const name: usize = 0x20;\n+    pub const def_index: usize = 0x21;\n+    pub const family: usize = 0x24;\n+    pub const ty: usize = 0x25;\n+    pub const parent_item: usize = 0x28;\n+    pub const is_tuple_struct_ctor: usize = 0x29;\n+    pub const closure_kind: usize = 0x2a;\n+    pub const closure_ty: usize = 0x2b;\n+    pub const def_key: usize = 0x2c;\n+    pub const attributes: usize = 0x101;\n+    pub const trait_ref: usize = 0x3b;\n+    pub const disr_val: usize = 0x3c;\n+    pub const fields: usize = 0x41;\n+    pub const variances: usize = 0x43;\n+    pub const trait_method_explicit_self: usize = 0x45;\n+    pub const ast: usize = 0x50;\n+    pub const mir: usize = 0x52;\n+    pub const trait_item_has_body: usize = 0x70;\n+    pub const visibility: usize = 0x78;\n+    pub const inherent_impls: usize = 0x79;\n+    pub const children: usize = 0x7b;\n+    pub const method_argument_names: usize = 0x85;\n+    pub const stability: usize = 0x88;\n+    pub const repr: usize = 0x89;\n+    pub const struct_ctor: usize = 0x8b;\n+    pub const generics: usize = 0x8f;\n+    pub const predicates: usize = 0x95;\n+    pub const unsafety: usize = 0x9a;\n+    pub const polarity: usize = 0x9d;\n+    pub const paren_sugar: usize = 0xa0;\n+    pub const super_predicates: usize = 0xa3;\n+    pub const defaulted_trait: usize = 0xa4;\n+    pub const impl_coerce_unsized_kind: usize = 0xa5;\n+    pub const constness: usize = 0xa6;\n+    pub const deprecation: usize = 0xa7;\n+    pub const defaultness: usize = 0xa8;\n+    pub const parent_impl: usize = 0xa9;\n+}\n \n /// The shorthand encoding of `Ty` uses `TypeVariants`' variant `usize`\n /// and is offset by this value so it never matches a real variant."}, {"sha": "662236be0f0d216a4324906e35404bba71886d89", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 71, "deletions": 80, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea3daad1372cffa5caf9f20fe36667e334662b/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea3daad1372cffa5caf9f20fe36667e334662b/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d2ea3daad1372cffa5caf9f20fe36667e334662b", "patch": "@@ -324,79 +324,79 @@ impl CrateMetadata {\n }\n \n pub fn load_index(data: &[u8]) -> index::Index {\n-    index::Index::from_rbml(rbml::Doc::new(data).get(tag_index))\n+    index::Index::from_rbml(rbml::Doc::new(data).get(root_tag::index))\n }\n \n pub fn crate_rustc_version(data: &[u8]) -> Option<String> {\n     let doc = rbml::Doc::new(data);\n-    reader::maybe_get_doc(doc, tag_rustc_version).map(|s| {\n+    reader::maybe_get_doc(doc, root_tag::rustc_version).map(|s| {\n         str::from_utf8(&s.data[s.start..s.end]).unwrap().to_string()\n     })\n }\n \n pub fn load_xrefs(data: &[u8]) -> index::DenseIndex {\n-    let index = rbml::Doc::new(data).get(tag_xref_index);\n+    let index = rbml::Doc::new(data).get(root_tag::xref_index);\n     index::DenseIndex::from_buf(index.data, index.start, index.end)\n }\n \n // Go through each item in the metadata and create a map from that\n // item's def-key to the item's DefIndex.\n pub fn load_key_map(data: &[u8]) -> FnvHashMap<DefKey, DefIndex> {\n-    rbml::Doc::new(data).get(tag_items).get(tag_items_data).children().map(|item_doc| {\n+    rbml::Doc::new(data).get(root_tag::items).children().map(|item_doc| {\n         // load def-key from item\n         let key = item_def_key(item_doc);\n \n         // load def-index from item\n-        (key, item_doc.get(tag_def_index).decoder().decode())\n+        (key, item_doc.get(item_tag::def_index).decoder().decode())\n     }).collect()\n }\n \n fn item_family(item: rbml::Doc) -> Family {\n-    item.get(tag_items_data_item_family).decoder().decode()\n+    item.get(item_tag::family).decoder().decode()\n }\n \n fn item_visibility(item: rbml::Doc) -> ty::Visibility {\n-    match reader::maybe_get_doc(item, tag_items_data_item_visibility) {\n+    match reader::maybe_get_doc(item, item_tag::visibility) {\n         None => ty::Visibility::Public,\n         Some(visibility_doc) => visibility_doc.decoder().decode()\n     }\n }\n \n fn item_defaultness(item: rbml::Doc) -> hir::Defaultness {\n-    match reader::maybe_get_doc(item, tag_items_data_item_defaultness) {\n+    match reader::maybe_get_doc(item, item_tag::defaultness) {\n         None => hir::Defaultness::Default, // should occur only for default impls on traits\n         Some(defaultness_doc) => defaultness_doc.decoder().decode()\n     }\n }\n \n fn item_parent_item(cdata: Cmd, d: rbml::Doc) -> Option<DefId> {\n-    reader::maybe_get_doc(d, tag_items_data_parent_item).map(|did| {\n+    reader::maybe_get_doc(d, item_tag::parent_item).map(|did| {\n         let mut dcx = did.decoder();\n         dcx.cdata = Some(cdata);\n         dcx.decode()\n     })\n }\n \n fn item_require_parent_item(cdata: Cmd, d: rbml::Doc) -> DefId {\n-    let mut dcx = d.get(tag_items_data_parent_item).decoder();\n+    let mut dcx = d.get(item_tag::parent_item).decoder();\n     dcx.cdata = Some(cdata);\n     dcx.decode()\n }\n \n fn item_def_id(d: rbml::Doc, cdata: Cmd) -> DefId {\n     DefId {\n         krate: cdata.cnum,\n-        index: d.get(tag_def_index).decoder().decode()\n+        index: d.get(item_tag::def_index).decoder().decode()\n     }\n }\n \n fn doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n-    maybe_doc_type(doc, tcx, cdata).expect(\"missing tag_items_data_item_type\")\n+    maybe_doc_type(doc, tcx, cdata).expect(\"missing item_tag::ty\")\n }\n \n fn maybe_doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n                             -> Option<Ty<'tcx>> {\n-    reader::maybe_get_doc(doc, tag_items_data_item_type).map(|tp| {\n+    reader::maybe_get_doc(doc, item_tag::ty).map(|tp| {\n         let mut dcx = tp.decoder();\n         dcx.tcx = Some(tcx);\n         dcx.cdata = Some(cdata);\n@@ -417,7 +417,7 @@ fn item_name(item: rbml::Doc) -> ast::Name {\n }\n \n fn maybe_item_name(item: rbml::Doc) -> Option<ast::Name> {\n-    reader::maybe_get_doc(item, tag_paths_data_name).map(|name| {\n+    reader::maybe_get_doc(item, item_tag::name).map(|name| {\n         name.decoder().decode()\n     })\n }\n@@ -459,9 +459,9 @@ pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n {\n     let item_doc = cdata.lookup_item(item_id);\n     let generics = doc_generics(item_doc, tcx, cdata);\n-    let unsafety = item_doc.get(tag_unsafety).decoder().decode();\n-    let paren_sugar = item_doc.get(tag_paren_sugar).decoder().decode();\n-    let trait_ref = doc_trait_ref(item_doc.get(tag_item_trait_ref), tcx, cdata);\n+    let unsafety = item_doc.get(item_tag::unsafety).decoder().decode();\n+    let paren_sugar = item_doc.get(item_tag::paren_sugar).decoder().decode();\n+    let trait_ref = doc_trait_ref(item_doc.get(item_tag::trait_ref), tcx, cdata);\n     let def_path = def_path(cdata, item_id).unwrap();\n \n     ty::TraitDef::new(unsafety, paren_sugar, generics, trait_ref,\n@@ -481,12 +481,12 @@ pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n         }\n     }\n     fn get_enum_variants<'tcx>(cdata: Cmd, doc: rbml::Doc) -> Vec<ty::VariantDefData<'tcx, 'tcx>> {\n-        let mut dcx = doc.get(tag_mod_children).decoder();\n+        let mut dcx = doc.get(item_tag::children).decoder();\n         dcx.cdata = Some(cdata);\n \n         dcx.seq().map(|did: DefId| {\n             let item = cdata.lookup_item(did.index);\n-            let disr = item.get(tag_disr_val).decoder().decode();\n+            let disr = item.get(item_tag::disr_val).decoder().decode();\n             ty::VariantDefData {\n                 did: did,\n                 name: item_name(item),\n@@ -497,7 +497,7 @@ pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n         }).collect()\n     }\n     fn get_variant_fields<'tcx>(cdata: Cmd, doc: rbml::Doc) -> Vec<ty::FieldDefData<'tcx, 'tcx>> {\n-        let mut dcx = doc.get(tag_item_fields).decoder();\n+        let mut dcx = doc.get(item_tag::fields).decoder();\n         dcx.cdata = Some(cdata);\n \n         dcx.seq().map(|did: DefId| {\n@@ -531,7 +531,7 @@ pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n         }\n         Struct(..) => {\n             // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n-            ctor_did = reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).map(|ctor_doc| {\n+            ctor_did = reader::maybe_get_doc(doc, item_tag::struct_ctor).map(|ctor_doc| {\n                 let mut dcx = ctor_doc.decoder();\n                 dcx.cdata = Some(cdata);\n                 dcx.decode()\n@@ -595,7 +595,7 @@ pub fn get_predicates<'a, 'tcx>(cdata: Cmd,\n                                 -> ty::GenericPredicates<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n-    doc_predicates(item_doc, tcx, cdata, tag_item_predicates)\n+    doc_predicates(item_doc, tcx, cdata, item_tag::predicates)\n }\n \n pub fn get_super_predicates<'a, 'tcx>(cdata: Cmd,\n@@ -604,7 +604,7 @@ pub fn get_super_predicates<'a, 'tcx>(cdata: Cmd,\n                                       -> ty::GenericPredicates<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n-    doc_predicates(item_doc, tcx, cdata, tag_item_super_predicates)\n+    doc_predicates(item_doc, tcx, cdata, item_tag::super_predicates)\n }\n \n pub fn get_generics<'a, 'tcx>(cdata: Cmd,\n@@ -625,14 +625,14 @@ pub fn get_type<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n pub fn get_stability(cdata: Cmd, id: DefIndex) -> Option<attr::Stability> {\n     let item = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item, tag_items_data_item_stability).map(|doc| {\n+    reader::maybe_get_doc(item, item_tag::stability).map(|doc| {\n         doc.decoder().decode()\n     })\n }\n \n pub fn get_deprecation(cdata: Cmd, id: DefIndex) -> Option<attr::Deprecation> {\n     let item = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item, tag_items_data_item_deprecation).map(|doc| {\n+    reader::maybe_get_doc(item, item_tag::deprecation).map(|doc| {\n         doc.decoder().decode()\n     })\n }\n@@ -643,7 +643,7 @@ pub fn get_visibility(cdata: Cmd, id: DefIndex) -> ty::Visibility {\n \n pub fn get_parent_impl(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n     let item = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item, tag_items_data_parent_impl).map(|doc| {\n+    reader::maybe_get_doc(item, item_tag::parent_impl).map(|doc| {\n         let mut dcx = doc.decoder();\n         dcx.cdata = Some(cdata);\n         dcx.decode()\n@@ -652,13 +652,13 @@ pub fn get_parent_impl(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n \n pub fn get_repr_attrs(cdata: Cmd, id: DefIndex) -> Vec<attr::ReprAttr> {\n     let item = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item, tag_items_data_item_repr).map_or(vec![], |doc| {\n+    reader::maybe_get_doc(item, item_tag::repr).map_or(vec![], |doc| {\n         doc.decoder().decode()\n     })\n }\n \n pub fn get_impl_polarity(cdata: Cmd, id: DefIndex) -> hir::ImplPolarity {\n-    cdata.lookup_item(id).get(tag_polarity).decoder().decode()\n+    cdata.lookup_item(id).get(item_tag::polarity).decoder().decode()\n }\n \n pub fn get_custom_coerce_unsized_kind(\n@@ -667,7 +667,7 @@ pub fn get_custom_coerce_unsized_kind(\n     -> Option<ty::adjustment::CustomCoerceUnsized>\n {\n     let item_doc = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item_doc, tag_impl_coerce_unsized_kind).map(|kind_doc| {\n+    reader::maybe_get_doc(item_doc, item_tag::impl_coerce_unsized_kind).map(|kind_doc| {\n         kind_doc.decoder().decode()\n     })\n }\n@@ -678,14 +678,14 @@ pub fn get_impl_trait<'a, 'tcx>(cdata: Cmd,\n                                 -> Option<ty::TraitRef<'tcx>>\n {\n     let item_doc = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n+    reader::maybe_get_doc(item_doc, item_tag::trait_ref).map(|tp| {\n         doc_trait_ref(tp, tcx, cdata)\n     })\n }\n \n /// Iterates over the language items in the given crate.\n pub fn get_lang_items(cdata: Cmd) -> Vec<(DefIndex, usize)> {\n-    rbml::Doc::new(cdata.data()).get(tag_lang_items).decoder().decode()\n+    rbml::Doc::new(cdata.data()).get(root_tag::lang_items).decoder().decode()\n }\n \n \n@@ -702,7 +702,7 @@ pub fn each_child_of_item<F, G>(cdata: Cmd, id: DefIndex,\n         Some(item_doc) => item_doc,\n     };\n \n-    let mut dcx = match reader::maybe_get_doc(item_doc, tag_mod_children) {\n+    let mut dcx = match reader::maybe_get_doc(item_doc, item_tag::children) {\n         Some(doc) => doc.decoder(),\n         None => return\n     };\n@@ -782,7 +782,7 @@ pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id:\n     };\n     let mut parent_def_path = def_path(cdata, id).unwrap();\n     parent_def_path.data.pop();\n-    if let Some(ast_doc) = reader::maybe_get_doc(item_doc, tag_ast as usize) {\n+    if let Some(ast_doc) = reader::maybe_get_doc(item_doc, item_tag::ast as usize) {\n         let ii = decode_inlined_item(cdata,\n                                      tcx,\n                                      parent_def_path,\n@@ -800,7 +800,7 @@ pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id:\n         let mut grandparent_def_path = parent_def_path;\n         grandparent_def_path.data.pop();\n         let parent_doc = cdata.lookup_item(parent_did.index);\n-        if let Some(ast_doc) = reader::maybe_get_doc(parent_doc, tag_ast as usize) {\n+        if let Some(ast_doc) = reader::maybe_get_doc(parent_doc, item_tag::ast as usize) {\n             let ii = decode_inlined_item(cdata,\n                                          tcx,\n                                          grandparent_def_path,\n@@ -817,7 +817,7 @@ pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id:\n \n pub fn is_item_mir_available<'tcx>(cdata: Cmd, id: DefIndex) -> bool {\n     if let Some(item_doc) = cdata.get_item(id) {\n-        return reader::maybe_get_doc(item_doc, tag_mir as usize).is_some();\n+        return reader::maybe_get_doc(item_doc, item_tag::mir as usize).is_some();\n     }\n \n     false\n@@ -829,7 +829,7 @@ pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n                                     -> Option<Mir<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n \n-    reader::maybe_get_doc(item_doc, tag_mir).map(|mir_doc| {\n+    reader::maybe_get_doc(item_doc, item_tag::mir).map(|mir_doc| {\n         let mut dcx = mir_doc.decoder();\n         dcx.tcx = Some(tcx);\n         dcx.cdata = Some(cdata);\n@@ -839,7 +839,7 @@ pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n \n fn get_explicit_self<'a, 'tcx>(cdata: Cmd, item: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                -> ty::ExplicitSelfCategory<'tcx> {\n-    let mut dcx = item.get(tag_item_trait_method_explicit_self).decoder();\n+    let mut dcx = item.get(item_tag::trait_method_explicit_self).decoder();\n     dcx.cdata = Some(cdata);\n     dcx.tcx = Some(tcx);\n \n@@ -881,12 +881,12 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n                 defaultness: defaultness,\n                 def_id: def_id,\n                 container: container,\n-                has_value: item_doc.get(tag_item_trait_item_has_body).decoder().decode(),\n+                has_value: item_doc.get(item_tag::trait_item_has_body).decoder().decode(),\n             }))\n         }\n         Family::Method => {\n             let generics = doc_generics(item_doc, tcx, cdata);\n-            let predicates = doc_predicates(item_doc, tcx, cdata, tag_item_predicates);\n+            let predicates = doc_predicates(item_doc, tcx, cdata, item_tag::predicates);\n             let ity = tcx.lookup_item_type(def_id).ty;\n             let fty = match ity.sty {\n                 ty::TyFnDef(.., fty) => fty,\n@@ -904,7 +904,7 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n                 explicit_self: explicit_self,\n                 vis: vis,\n                 defaultness: defaultness,\n-                has_body: item_doc.get(tag_item_trait_item_has_body).decoder().decode(),\n+                has_body: item_doc.get(item_tag::trait_item_has_body).decoder().decode(),\n                 def_id: def_id,\n                 container: container,\n             }))\n@@ -926,13 +926,13 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n \n pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> Vec<ty::Variance> {\n     let item_doc = cdata.lookup_item(id);\n-    item_doc.get(tag_item_variances).decoder().decode()\n+    item_doc.get(item_tag::variances).decoder().decode()\n }\n \n pub fn get_struct_ctor_def_id(cdata: Cmd, node_id: DefIndex) -> Option<DefId>\n {\n     let item = cdata.lookup_item(node_id);\n-    reader::maybe_get_doc(item, tag_items_data_item_struct_ctor).map(|ctor_doc| {\n+    reader::maybe_get_doc(item, item_tag::struct_ctor).map(|ctor_doc| {\n         let mut dcx = ctor_doc.decoder();\n         dcx.cdata = Some(cdata);\n         dcx.decode()\n@@ -946,7 +946,7 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n     -> Option<DefId>\n {\n     let item = cdata.lookup_item(node_id);\n-    reader::maybe_get_doc(item, tag_items_data_item_is_tuple_struct_ctor).and_then(|doc| {\n+    reader::maybe_get_doc(item, item_tag::is_tuple_struct_ctor).and_then(|doc| {\n         if doc.decoder().decode() {\n             Some(item_require_parent_item(cdata, item))\n         } else {\n@@ -968,7 +968,7 @@ pub fn get_item_attrs(cdata: Cmd,\n }\n \n pub fn get_struct_field_names(cdata: Cmd, id: DefIndex) -> Vec<ast::Name> {\n-    let mut dcx = cdata.lookup_item(id).get(tag_item_fields).decoder();\n+    let mut dcx = cdata.lookup_item(id).get(item_tag::fields).decoder();\n     dcx.cdata = Some(cdata);\n \n     dcx.seq().map(|did: DefId| {\n@@ -977,7 +977,7 @@ pub fn get_struct_field_names(cdata: Cmd, id: DefIndex) -> Vec<ast::Name> {\n }\n \n fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n-    reader::maybe_get_doc(md, tag_attributes).map_or(vec![], |attrs_doc| {\n+    reader::maybe_get_doc(md, item_tag::attributes).map_or(vec![], |attrs_doc| {\n         let mut attrs = attrs_doc.decoder().decode::<Vec<ast::Attribute>>();\n \n         // Need new unique IDs: old thread-local IDs won't map to new threads.\n@@ -998,7 +998,7 @@ pub struct CrateDep {\n }\n \n pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n-    let dcx = rbml::Doc::new(data).get(tag_crate_deps).decoder();\n+    let dcx = rbml::Doc::new(data).get(root_tag::crate_deps).decoder();\n \n     dcx.seq().enumerate().map(|(crate_num, (name, hash, explicitly_linked))| {\n         CrateDep {\n@@ -1021,29 +1021,29 @@ fn list_crate_deps(data: &[u8], out: &mut io::Write) -> io::Result<()> {\n \n pub fn maybe_get_crate_hash(data: &[u8]) -> Option<Svh> {\n     let cratedoc = rbml::Doc::new(data);\n-    reader::maybe_get_doc(cratedoc, tag_crate_hash).map(|doc| {\n+    reader::maybe_get_doc(cratedoc, root_tag::crate_hash).map(|doc| {\n         doc.decoder().decode()\n     })\n }\n \n pub fn get_crate_hash(data: &[u8]) -> Svh {\n-    rbml::Doc::new(data).get(tag_crate_hash).decoder().decode()\n+    rbml::Doc::new(data).get(root_tag::crate_hash).decoder().decode()\n }\n \n pub fn maybe_get_crate_name(data: &[u8]) -> Option<String> {\n     let cratedoc = rbml::Doc::new(data);\n-    reader::maybe_get_doc(cratedoc, tag_crate_crate_name).map(|doc| {\n+    reader::maybe_get_doc(cratedoc, root_tag::crate_crate_name).map(|doc| {\n         doc.decoder().decode()\n     })\n }\n \n pub fn get_crate_disambiguator(data: &[u8]) -> String {\n-    rbml::Doc::new(data).get(tag_crate_disambiguator).decoder().decode()\n+    rbml::Doc::new(data).get(root_tag::crate_disambiguator).decoder().decode()\n }\n \n pub fn get_crate_triple(data: &[u8]) -> Option<String> {\n     let cratedoc = rbml::Doc::new(data);\n-    let triple_doc = reader::maybe_get_doc(cratedoc, tag_crate_triple);\n+    let triple_doc = reader::maybe_get_doc(cratedoc, root_tag::crate_triple);\n     triple_doc.map(|s| s.decoder().decode())\n }\n \n@@ -1073,7 +1073,7 @@ pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n     where F: FnMut(DefId),\n {\n     let item_doc = cdata.lookup_item(id);\n-    let mut dcx = item_doc.get(tag_items_data_item_inherent_impls).decoder();\n+    let mut dcx = item_doc.get(item_tag::inherent_impls).decoder();\n     dcx.cdata = Some(cdata);\n \n     for impl_def_id in dcx.seq() {\n@@ -1095,7 +1095,7 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n     };\n \n     // FIXME(eddyb) Make this O(1) instead of O(n).\n-    for trait_doc in rbml::Doc::new(cdata.data()).get(tag_impls).children() {\n+    for trait_doc in rbml::Doc::new(cdata.data()).get(root_tag::impls).children() {\n         let mut dcx = trait_doc.decoder();\n         dcx.cdata = Some(cdata);\n \n@@ -1128,18 +1128,18 @@ pub fn get_trait_of_item(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n \n pub fn get_native_libraries(cdata: Cmd)\n                             -> Vec<(cstore::NativeLibraryKind, String)> {\n-    rbml::Doc::new(cdata.data()).get(tag_native_libraries).decoder().decode()\n+    rbml::Doc::new(cdata.data()).get(root_tag::native_libraries).decoder().decode()\n }\n \n pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<DefIndex> {\n-    reader::maybe_get_doc(rbml::Doc::new(data), tag_plugin_registrar_fn)\n+    reader::maybe_get_doc(rbml::Doc::new(data), root_tag::plugin_registrar_fn)\n         .map(|doc| doc.decoder().decode())\n }\n \n pub fn each_exported_macro<F>(data: &[u8], mut f: F) where\n     F: FnMut(ast::Name, Vec<ast::Attribute>, Span, String) -> bool,\n {\n-    let dcx = rbml::Doc::new(data).get(tag_macro_defs).decoder();\n+    let dcx = rbml::Doc::new(data).get(root_tag::macro_defs).decoder();\n     for (name, attrs, span, body) in dcx.seq() {\n         if !f(name, attrs, span, body) {\n             break;\n@@ -1148,14 +1148,14 @@ pub fn each_exported_macro<F>(data: &[u8], mut f: F) where\n }\n \n pub fn get_derive_registrar_fn(data: &[u8]) -> Option<DefIndex> {\n-    reader::maybe_get_doc(rbml::Doc::new(data), tag_macro_derive_registrar)\n+    reader::maybe_get_doc(rbml::Doc::new(data), root_tag::macro_derive_registrar)\n         .map(|doc| doc.decoder().decode())\n }\n \n pub fn get_dylib_dependency_formats(cdata: Cmd)\n     -> Vec<(CrateNum, LinkagePreference)>\n {\n-    let dcx = rbml::Doc::new(cdata.data()).get(tag_dylib_dependency_formats).decoder();\n+    let dcx = rbml::Doc::new(cdata.data()).get(root_tag::dylib_dependency_formats).decoder();\n \n     dcx.seq::<Option<_>>().enumerate().flat_map(|(i, link)| {\n         let cnum = CrateNum::new(i + 1);\n@@ -1164,19 +1164,19 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n }\n \n pub fn get_missing_lang_items(cdata: Cmd) -> Vec<lang_items::LangItem> {\n-    rbml::Doc::new(cdata.data()).get(tag_lang_items_missing).decoder().decode()\n+    rbml::Doc::new(cdata.data()).get(root_tag::lang_items_missing).decoder().decode()\n }\n \n pub fn get_method_arg_names(cdata: Cmd, id: DefIndex) -> Vec<String> {\n     let method_doc = cdata.lookup_item(id);\n-    match reader::maybe_get_doc(method_doc, tag_method_argument_names) {\n+    match reader::maybe_get_doc(method_doc, item_tag::method_argument_names) {\n         Some(args_doc) => args_doc.decoder().decode(),\n         None => vec![],\n     }\n }\n \n pub fn get_reachable_ids(cdata: Cmd) -> Vec<DefId> {\n-    let dcx = rbml::Doc::new(cdata.data()).get(tag_reachable_ids).decoder();\n+    let dcx = rbml::Doc::new(cdata.data()).get(root_tag::reachable_ids).decoder();\n \n     dcx.seq().map(|index| {\n         DefId {\n@@ -1187,7 +1187,7 @@ pub fn get_reachable_ids(cdata: Cmd) -> Vec<DefId> {\n }\n \n pub fn is_const_fn(cdata: Cmd, id: DefIndex) -> bool {\n-    match reader::maybe_get_doc(cdata.lookup_item(id), tag_items_data_item_constness) {\n+    match reader::maybe_get_doc(cdata.lookup_item(id), item_tag::constness) {\n         None => false,\n         Some(doc) => {\n             match doc.decoder().decode() {\n@@ -1235,7 +1235,7 @@ fn doc_generics<'a, 'tcx>(base_doc: rbml::Doc,\n                           cdata: Cmd)\n                           -> &'tcx ty::Generics<'tcx>\n {\n-    let mut dcx = base_doc.get(tag_item_generics).decoder();\n+    let mut dcx = base_doc.get(item_tag::generics).decoder();\n     dcx.tcx = Some(tcx);\n     dcx.cdata = Some(cdata);\n     tcx.alloc_generics(dcx.decode())\n@@ -1268,25 +1268,25 @@ fn doc_predicates<'a, 'tcx>(base_doc: rbml::Doc,\n }\n \n pub fn is_defaulted_trait(cdata: Cmd, trait_id: DefIndex) -> bool {\n-    cdata.lookup_item(trait_id).get(tag_defaulted_trait).decoder().decode()\n+    cdata.lookup_item(trait_id).get(item_tag::defaulted_trait).decoder().decode()\n }\n \n pub fn is_default_impl(cdata: Cmd, impl_id: DefIndex) -> bool {\n     item_family(cdata.lookup_item(impl_id)) == Family::DefaultImpl\n }\n \n pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<syntax_pos::FileMap> {\n-    rbml::Doc::new(metadata).get(tag_codemap).decoder().decode()\n+    rbml::Doc::new(metadata).get(root_tag::codemap).decoder().decode()\n }\n \n pub fn closure_kind(cdata: Cmd, closure_id: DefIndex) -> ty::ClosureKind {\n-    cdata.lookup_item(closure_id).get(tag_items_closure_kind).decoder().decode()\n+    cdata.lookup_item(closure_id).get(item_tag::closure_kind).decoder().decode()\n }\n \n pub fn closure_ty<'a, 'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                             -> ty::ClosureTy<'tcx> {\n     let closure_doc = cdata.lookup_item(closure_id);\n-    let closure_ty_doc = closure_doc.get(tag_items_closure_ty);\n+    let closure_ty_doc = closure_doc.get(item_tag::closure_ty);\n     let mut dcx = closure_ty_doc.decoder();\n     dcx.tcx = Some(tcx);\n     dcx.cdata = Some(cdata);\n@@ -1300,18 +1300,9 @@ pub fn def_key(cdata: Cmd, id: DefIndex) -> hir_map::DefKey {\n }\n \n fn item_def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n-    match reader::maybe_get_doc(item_doc, tag_def_key) {\n-        Some(def_key_doc) => {\n-            let simple_key = def_key_doc.decoder().decode();\n-            let name = maybe_item_name(item_doc).map(|name| name.as_str());\n-            def_key::recover_def_key(simple_key, name)\n-        }\n-        None => {\n-            bug!(\"failed to find block with tag {:?} for item with family {:?}\",\n-                   tag_def_key,\n-                   item_family(item_doc))\n-        }\n-    }\n+    let simple_key = item_doc.get(item_tag::def_key).decoder().decode();\n+    let name = maybe_item_name(item_doc).map(|name| name.as_str());\n+    def_key::recover_def_key(simple_key, name)\n }\n \n // Returns the path leading to the thing with this `id`. Note that\n@@ -1327,5 +1318,5 @@ pub fn def_path(cdata: Cmd, id: DefIndex) -> Option<hir_map::DefPath> {\n }\n \n pub fn get_panic_strategy(data: &[u8]) -> PanicStrategy {\n-    rbml::Doc::new(data).get(tag_panic_strategy).decoder().decode()\n+    rbml::Doc::new(data).get(root_tag::panic_strategy).decoder().decode()\n }"}, {"sha": "1e4c61e0b2e1098ae50d79a6ad253adb51e12db4", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 66, "deletions": 68, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea3daad1372cffa5caf9f20fe36667e334662b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea3daad1372cffa5caf9f20fe36667e334662b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d2ea3daad1372cffa5caf9f20fe36667e334662b", "patch": "@@ -169,21 +169,21 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n }\n \n fn encode_name(ecx: &mut EncodeContext, name: Name) {\n-    ecx.start_tag(tag_paths_data_name);\n+    ecx.start_tag(item_tag::name);\n     name.encode(ecx).unwrap();\n     ecx.end_tag();\n }\n \n fn encode_def_id(ecx: &mut EncodeContext, def_id: DefId) {\n     assert!(def_id.is_local());\n-    ecx.start_tag(tag_def_index);\n+    ecx.start_tag(item_tag::def_index);\n     def_id.index.encode(ecx).unwrap();\n     ecx.end_tag();\n }\n \n fn encode_def_key(ecx: &mut EncodeContext, key: DefKey) {\n     let simple_key = def_key::simplify_def_key(key);\n-    ecx.start_tag(tag_def_key);\n+    ecx.start_tag(item_tag::def_key);\n     simple_key.encode(ecx);\n     ecx.end_tag();\n }\n@@ -206,14 +206,14 @@ fn encode_trait_ref<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>,\n \n // Item info table encoding\n fn encode_family(ecx: &mut EncodeContext, f: Family) {\n-    ecx.start_tag(tag_items_data_item_family);\n+    ecx.start_tag(item_tag::family);\n     f.encode(ecx).unwrap();\n     ecx.end_tag();\n }\n \n fn encode_item_variances(ecx: &mut EncodeContext, id: NodeId) {\n     let v = ecx.tcx.item_variances(ecx.tcx.map.local_def_id(id));\n-    ecx.start_tag(tag_item_variances);\n+    ecx.start_tag(item_tag::variances);\n     v.encode(ecx);\n     ecx.end_tag();\n }\n@@ -233,27 +233,27 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_type(&mut self, typ: Ty<'tcx>) {\n-        self.start_tag(tag_items_data_item_type);\n+        self.start_tag(item_tag::ty);\n         typ.encode(self).unwrap();\n         self.end_tag();\n     }\n \n     fn encode_disr_val(&mut self,\n                        disr_val: ty::Disr) {\n-        self.start_tag(tag_disr_val);\n+        self.start_tag(item_tag::disr_val);\n         disr_val.to_u64_unchecked().encode(self).unwrap();\n         self.end_tag();\n     }\n \n     fn encode_parent_item(&mut self, id: DefId) {\n-        self.start_tag(tag_items_data_parent_item);\n+        self.start_tag(item_tag::parent_item);\n         id.encode(self).unwrap();\n         self.end_tag();\n     }\n \n     fn encode_variant_fields(&mut self,\n                              variant: ty::VariantDef) {\n-        self.start_tag(tag_item_fields);\n+        self.start_tag(item_tag::fields);\n         self.seq(&variant.fields, |_, f| f.did);\n         self.end_tag();\n     }\n@@ -321,7 +321,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n         // Encode info about all the module children.\n-        self.start_tag(tag_mod_children);\n+        self.start_tag(item_tag::children);\n         self.seq(&md.item_ids, |_, item_id| {\n             tcx.map.local_def_id(item_id.id)\n         });\n@@ -358,7 +358,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         } else {\n             ty::Visibility::PrivateExternal\n         };\n-        self.start_tag(tag_items_data_item_visibility);\n+        self.start_tag(item_tag::visibility);\n         vis.encode(self).unwrap();\n         self.end_tag();\n     }\n@@ -381,13 +381,13 @@ impl HasVisibility for ty::Visibility {\n }\n \n fn encode_constness(ecx: &mut EncodeContext, constness: hir::Constness) {\n-    ecx.start_tag(tag_items_data_item_constness);\n+    ecx.start_tag(item_tag::constness);\n     constness.encode(ecx).unwrap();\n     ecx.end_tag();\n }\n \n fn encode_defaultness(ecx: &mut EncodeContext, defaultness: hir::Defaultness) {\n-    ecx.start_tag(tag_items_data_item_defaultness);\n+    ecx.start_tag(item_tag::defaultness);\n     defaultness.encode(ecx).unwrap();\n     ecx.end_tag();\n }\n@@ -463,7 +463,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // definition, but without this there is no way for them\n         // to tell that they actually have a ctor rather than a\n         // normal function\n-        self.start_tag(tag_items_data_item_is_tuple_struct_ctor);\n+        self.start_tag(item_tag::is_tuple_struct_ctor);\n         true.encode(self).unwrap();\n         self.end_tag();\n     }\n@@ -472,10 +472,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                        generics: &ty::Generics<'tcx>,\n                        predicates: &ty::GenericPredicates<'tcx>)\n     {\n-        self.start_tag(tag_item_generics);\n+        self.start_tag(item_tag::generics);\n         generics.encode(self).unwrap();\n         self.end_tag();\n-        self.encode_predicates(predicates, tag_item_predicates);\n+        self.encode_predicates(predicates, item_tag::predicates);\n     }\n \n     fn encode_predicates(&mut self,\n@@ -495,7 +495,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.encode_generics(&method_ty.generics, &method_ty.predicates);\n         self.encode_visibility(method_ty.vis);\n \n-        self.start_tag(tag_item_trait_method_explicit_self);\n+        self.start_tag(item_tag::trait_method_explicit_self);\n         method_ty.explicit_self.encode(self).unwrap();\n         self.end_tag();\n \n@@ -541,7 +541,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         encode_attributes(self, &trait_item.attrs);\n         match trait_item.node {\n             hir::ConstTraitItem(_, ref default) => {\n-                self.start_tag(tag_item_trait_item_has_body);\n+                self.start_tag(item_tag::trait_item_has_body);\n                 default.is_some().encode(self).unwrap();\n                 self.end_tag();\n \n@@ -550,7 +550,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 self.encode_mir(item_def_id);\n             }\n             hir::MethodTraitItem(ref sig, ref body) => {\n-                self.start_tag(tag_item_trait_item_has_body);\n+                self.start_tag(item_tag::trait_item_has_body);\n                 body.is_some().encode(self).unwrap();\n                 self.end_tag();\n \n@@ -600,7 +600,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         self.encode_parent_item(tcx.map.local_def_id(parent_id));\n \n-        self.start_tag(tag_item_trait_item_has_body);\n+        self.start_tag(item_tag::trait_item_has_body);\n         true.encode(self).unwrap();\n         self.end_tag();\n \n@@ -632,7 +632,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.encode_method_ty_fields(m);\n         self.encode_parent_item(tcx.map.local_def_id(parent_id));\n \n-        self.start_tag(tag_item_trait_item_has_body);\n+        self.start_tag(item_tag::trait_item_has_body);\n         true.encode(self).unwrap();\n         self.end_tag();\n \n@@ -697,7 +697,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_method_argument_names(&mut self,\n                                     decl: &hir::FnDecl) {\n-        self.start_tag(tag_method_argument_names);\n+        self.start_tag(item_tag::method_argument_names);\n \n         self.seq(&decl.inputs, |_, arg| {\n             if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n@@ -717,14 +717,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             repr_attrs.extend(attr::find_repr_attrs(self.tcx.sess.diagnostic(),\n                                                     attr));\n         }\n-        self.start_tag(tag_items_data_item_repr);\n+        self.start_tag(item_tag::repr);\n         repr_attrs.encode(self);\n         self.end_tag();\n     }\n \n     fn encode_mir(&mut self, def_id: DefId) {\n         if let Some(mir) = self.mir_map.map.get(&def_id) {\n-            self.start_tag(tag_mir as usize);\n+            self.start_tag(item_tag::mir as usize);\n             mir.encode(self);\n             self.end_tag();\n         }\n@@ -734,7 +734,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n // Encodes the inherent implementations of a structure, enumeration, or trait.\n fn encode_inherent_implementations(ecx: &mut EncodeContext,\n                                    def_id: DefId) {\n-    ecx.start_tag(tag_items_data_item_inherent_impls);\n+    ecx.start_tag(item_tag::inherent_impls);\n     match ecx.tcx.inherent_impls.borrow().get(&def_id) {\n         None => <[DefId]>::encode(&[], ecx).unwrap(),\n         Some(implementations) => implementations.encode(ecx).unwrap()\n@@ -744,15 +744,15 @@ fn encode_inherent_implementations(ecx: &mut EncodeContext,\n \n fn encode_stability(ecx: &mut EncodeContext, stab_opt: Option<&attr::Stability>) {\n     stab_opt.map(|stab| {\n-        ecx.start_tag(tag_items_data_item_stability);\n+        ecx.start_tag(item_tag::stability);\n         stab.encode(ecx).unwrap();\n         ecx.end_tag();\n     });\n }\n \n fn encode_deprecation(ecx: &mut EncodeContext, depr_opt: Option<attr::Deprecation>) {\n     depr_opt.map(|depr| {\n-        ecx.start_tag(tag_items_data_item_deprecation);\n+        ecx.start_tag(item_tag::deprecation);\n         depr.encode(ecx).unwrap();\n         ecx.end_tag();\n     });\n@@ -772,7 +772,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let mut sorted_xrefs: Vec<_> = xrefs.into_iter().collect();\n         sorted_xrefs.sort_by_key(|&(_, id)| id);\n \n-        self.start_tag(tag_xref_data);\n+        self.start_tag(root_tag::xref_data);\n         for (xref, id) in sorted_xrefs.into_iter() {\n             xref_positions[id as usize] = self.mark_stable_position() as u32;\n             match xref {\n@@ -782,7 +782,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.mark_stable_position();\n         self.end_tag();\n \n-        self.start_tag(tag_xref_index);\n+        self.start_tag(root_tag::xref_index);\n         index::write_dense_index(xref_positions, &mut self.opaque.cursor);\n         self.end_tag();\n     }\n@@ -857,7 +857,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 encode_name(self, item.name);\n \n                 // Encode all the items in self module.\n-                self.start_tag(tag_mod_children);\n+                self.start_tag(item_tag::children);\n                 self.seq(&fm.items, |_, foreign_item| {\n                     tcx.map.local_def_id(foreign_item.id)\n                 });\n@@ -886,7 +886,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 encode_attributes(self, &item.attrs);\n                 self.encode_repr_attrs(&item.attrs);\n \n-                self.start_tag(tag_mod_children);\n+                self.start_tag(item_tag::children);\n                 self.seq(&enum_definition.variants, |_, v| {\n                     tcx.map.local_def_id(v.node.data.id())\n                 });\n@@ -928,7 +928,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 if !struct_def.is_struct() {\n                     let ctor_did = tcx.map.local_def_id(struct_def.id());\n-                    self.start_tag(tag_items_data_item_struct_ctor);\n+                    self.start_tag(item_tag::struct_ctor);\n                     ctor_did.encode(self).unwrap();\n                     self.end_tag();\n                 }\n@@ -966,7 +966,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 encode_name(self, item.name);\n \n                 let trait_ref = tcx.impl_trait_ref(tcx.map.local_def_id(item.id)).unwrap();\n-                encode_trait_ref(self, trait_ref, tag_item_trait_ref);\n+                encode_trait_ref(self, trait_ref, item_tag::trait_ref);\n             }\n             hir::ItemImpl(_, polarity, ..) => {\n                 encode_def_id_and_key(self, def_id);\n@@ -975,7 +975,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 encode_name(self, item.name);\n                 encode_attributes(self, &item.attrs);\n \n-                self.start_tag(tag_polarity);\n+                self.start_tag(item_tag::polarity);\n                 polarity.encode(self).unwrap();\n                 self.end_tag();\n \n@@ -985,21 +985,21 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                        .get(&tcx.map.local_def_id(item.id))\n                 {\n                     Some(&kind) => {\n-                        self.start_tag(tag_impl_coerce_unsized_kind);\n+                        self.start_tag(item_tag::impl_coerce_unsized_kind);\n                         kind.encode(self);\n                         self.end_tag();\n                     }\n                     None => {}\n                 }\n \n-                self.start_tag(tag_mod_children);\n+                self.start_tag(item_tag::children);\n                 tcx.impl_or_trait_items(def_id).encode(self).unwrap();\n                 <[def::Export]>::encode(&[], self).unwrap();\n                 self.end_tag();\n \n                 let did = tcx.map.local_def_id(item.id);\n                 if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n-                    encode_trait_ref(self, trait_ref, tag_item_trait_ref);\n+                    encode_trait_ref(self, trait_ref, item_tag::trait_ref);\n \n                     let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n                     let parent = trait_def.ancestors(did)\n@@ -1011,7 +1011,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                                               _ => None,\n                                           });\n                     parent.map(|parent| {\n-                        self.start_tag(tag_items_data_parent_impl);\n+                        self.start_tag(item_tag::parent_impl);\n                         parent.encode(self).unwrap();\n                         self.end_tag();\n                     });\n@@ -1026,29 +1026,29 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let trait_def = tcx.lookup_trait_def(def_id);\n                 let trait_predicates = tcx.lookup_predicates(def_id);\n \n-                self.start_tag(tag_unsafety);\n+                self.start_tag(item_tag::unsafety);\n                 trait_def.unsafety.encode(self).unwrap();\n                 self.end_tag();\n \n-                self.start_tag(tag_paren_sugar);\n+                self.start_tag(item_tag::paren_sugar);\n                 trait_def.paren_sugar.encode(self).unwrap();\n                 self.end_tag();\n \n-                self.start_tag(tag_defaulted_trait);\n+                self.start_tag(item_tag::defaulted_trait);\n                 tcx.trait_has_default_impl(def_id).encode(self).unwrap();\n                 self.end_tag();\n \n                 self.encode_generics(&trait_def.generics, &trait_predicates);\n                 self.encode_predicates(&tcx.lookup_super_predicates(def_id),\n-                                       tag_item_super_predicates);\n-                encode_trait_ref(self, trait_def.trait_ref, tag_item_trait_ref);\n+                                       item_tag::super_predicates);\n+                encode_trait_ref(self, trait_def.trait_ref, item_tag::trait_ref);\n                 encode_name(self, item.name);\n                 encode_attributes(self, &item.attrs);\n                 self.encode_visibility(vis);\n                 encode_stability(self, stab);\n                 encode_deprecation(self, depr);\n \n-                self.start_tag(tag_mod_children);\n+                self.start_tag(item_tag::children);\n                 tcx.impl_or_trait_items(def_id).encode(self).unwrap();\n                 <[def::Export]>::encode(&[], self).unwrap();\n                 self.end_tag();\n@@ -1276,11 +1276,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         encode_def_id_and_key(self, def_id);\n         encode_name(self, syntax::parse::token::intern(\"<closure>\"));\n \n-        self.start_tag(tag_items_closure_ty);\n+        self.start_tag(item_tag::closure_ty);\n         tcx.tables.borrow().closure_tys[&def_id].encode(self).unwrap();\n         self.end_tag();\n \n-        self.start_tag(tag_items_closure_kind);\n+        self.start_tag(item_tag::closure_kind);\n         tcx.closure_kind(def_id).encode(self).unwrap();\n         self.end_tag();\n \n@@ -1292,7 +1292,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n fn encode_info_for_items(ecx: &mut EncodeContext) -> IndexData {\n     let krate = ecx.tcx.map.krate();\n \n-    ecx.start_tag(tag_items_data);\n+    ecx.start_tag(root_tag::items);\n \n     let items = {\n         let mut index = IndexBuilder::new(ecx);\n@@ -1315,13 +1315,13 @@ fn encode_info_for_items(ecx: &mut EncodeContext) -> IndexData {\n }\n \n fn encode_item_index(ecx: &mut EncodeContext, index: IndexData) {\n-    ecx.start_tag(tag_index);\n+    ecx.start_tag(root_tag::index);\n     index.write_index(&mut ecx.opaque.cursor);\n     ecx.end_tag();\n }\n \n fn encode_attributes(ecx: &mut EncodeContext, attrs: &[ast::Attribute]) {\n-    ecx.start_tag(tag_attributes);\n+    ecx.start_tag(item_tag::attributes);\n     attrs.encode(ecx).unwrap();\n     ecx.end_tag();\n }\n@@ -1352,7 +1352,7 @@ fn encode_crate_deps(ecx: &mut EncodeContext, cstore: &cstore::CStore) {\n     // the assumption that they are numbered 1 to n.\n     // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n-    ecx.start_tag(tag_crate_deps);\n+    ecx.start_tag(root_tag::crate_deps);\n     ecx.seq(&get_ordered_deps(cstore), |_, &(_, ref dep)| {\n         (dep.name(), decoder::get_crate_hash(dep.data()),\n          dep.explicitly_linked.get())\n@@ -1376,11 +1376,11 @@ fn encode_lang_items(ecx: &mut EncodeContext) {\n     let count = lang_items().count();\n     let mut lang_items = lang_items();\n \n-    ecx.start_tag(tag_lang_items);\n+    ecx.start_tag(root_tag::lang_items);\n     ecx.seq(0..count, |_, _| lang_items.next().unwrap());\n     ecx.end_tag();\n \n-    ecx.start_tag(tag_lang_items_missing);\n+    ecx.start_tag(root_tag::lang_items_missing);\n     tcx.lang_items.missing.encode(ecx).unwrap();\n     ecx.end_tag();\n }\n@@ -1401,7 +1401,7 @@ fn encode_native_libraries(ecx: &mut EncodeContext) {\n     let count = libs().count();\n     let mut libs = libs();\n \n-    ecx.start_tag(tag_native_libraries);\n+    ecx.start_tag(root_tag::native_libraries);\n     ecx.seq(0..count, |_, _| libs.next().unwrap());\n     ecx.end_tag();\n }\n@@ -1410,7 +1410,7 @@ fn encode_plugin_registrar_fn(ecx: &mut EncodeContext) {\n     match ecx.tcx.sess.plugin_registrar_fn.get() {\n         Some(id) => {\n             let def_id = ecx.tcx.map.local_def_id(id);\n-            ecx.start_tag(tag_plugin_registrar_fn);\n+            ecx.start_tag(root_tag::plugin_registrar_fn);\n             def_id.index.encode(ecx).unwrap();\n             ecx.end_tag();\n         }\n@@ -1434,15 +1434,15 @@ fn encode_codemap(ecx: &mut EncodeContext) {\n     let count = filemaps().count();\n     let mut filemaps = filemaps();\n \n-    ecx.start_tag(tag_codemap);\n+    ecx.start_tag(root_tag::codemap);\n     ecx.seq(0..count, |_, _| filemaps.next().unwrap());\n     ecx.end_tag();\n }\n \n /// Serialize the text of the exported macros\n fn encode_macro_defs(ecx: &mut EncodeContext) {\n     let tcx = ecx.tcx;\n-    ecx.start_tag(tag_macro_defs);\n+    ecx.start_tag(root_tag::macro_defs);\n     ecx.seq(&tcx.map.krate().exported_macros, |_, def| {\n         let body = ::syntax::print::pprust::tts_to_string(&def.body);\n         (def.name, &def.attrs, def.span, body)\n@@ -1453,7 +1453,7 @@ fn encode_macro_defs(ecx: &mut EncodeContext) {\n         let id = ecx.tcx.sess.derive_registrar_fn.get().unwrap();\n         let did = ecx.tcx.map.local_def_id(id);\n \n-        ecx.start_tag(tag_macro_derive_registrar);\n+        ecx.start_tag(root_tag::macro_derive_registrar);\n         did.index.encode(ecx).unwrap();\n         ecx.end_tag();\n     }\n@@ -1485,7 +1485,7 @@ fn encode_impls(ecx: &mut EncodeContext) {\n     };\n     ecx.tcx.map.krate().visit_all_items(&mut visitor);\n \n-    ecx.start_tag(tag_impls);\n+    ecx.start_tag(root_tag::impls);\n     for (trait_def_id, trait_impls) in visitor.impls {\n         // FIXME(eddyb) Avoid wrapping the entries in docs.\n         ecx.start_tag(0);\n@@ -1503,7 +1503,7 @@ fn encode_impls(ecx: &mut EncodeContext) {\n // symbol associated with them (they weren't translated) or if they're an FFI\n // definition (as that's not defined in this crate).\n fn encode_reachable(ecx: &mut EncodeContext) {\n-    ecx.start_tag(tag_reachable_ids);\n+    ecx.start_tag(root_tag::reachable_ids);\n \n     let reachable = ecx.reachable;\n     ecx.seq(reachable, |ecx, &id| ecx.tcx.map.local_def_id(id).index);\n@@ -1512,7 +1512,7 @@ fn encode_reachable(ecx: &mut EncodeContext) {\n }\n \n fn encode_dylib_dependency_formats(ecx: &mut EncodeContext) {\n-    ecx.start_tag(tag_dylib_dependency_formats);\n+    ecx.start_tag(root_tag::dylib_dependency_formats);\n     match ecx.tcx.sess.dependency_formats.borrow().get(&config::CrateTypeDylib) {\n         Some(arr) => {\n             ecx.seq(arr, |_, slot| {\n@@ -1596,30 +1596,30 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn encode_metadata_inner(ecx: &mut EncodeContext) {\n-    ecx.wr_tagged_str(tag_rustc_version, &rustc_version());\n+    ecx.wr_tagged_str(root_tag::rustc_version, &rustc_version());\n \n     let tcx = ecx.tcx;\n     let link_meta = ecx.link_meta;\n \n-    ecx.start_tag(tag_crate_crate_name);\n+    ecx.start_tag(root_tag::crate_crate_name);\n     link_meta.crate_name.encode(ecx).unwrap();\n     ecx.end_tag();\n \n-    ecx.start_tag(tag_crate_triple);\n+    ecx.start_tag(root_tag::crate_triple);\n     tcx.sess.opts.target_triple.encode(ecx).unwrap();\n     ecx.end_tag();\n \n-    ecx.start_tag(tag_crate_hash);\n+    ecx.start_tag(root_tag::crate_hash);\n     link_meta.crate_hash.encode(ecx).unwrap();\n     ecx.end_tag();\n \n-    ecx.start_tag(tag_crate_disambiguator);\n+    ecx.start_tag(root_tag::crate_disambiguator);\n     tcx.sess.local_crate_disambiguator().encode(ecx).unwrap();\n     ecx.end_tag();\n \n     encode_dylib_dependency_formats(ecx);\n \n-    ecx.start_tag(tag_panic_strategy);\n+    ecx.start_tag(root_tag::panic_strategy);\n     ecx.tcx.sess.opts.cg.panic.encode(ecx);\n     ecx.end_tag();\n \n@@ -1663,11 +1663,9 @@ fn encode_metadata_inner(ecx: &mut EncodeContext) {\n     let reachable_bytes = ecx.position() - i;\n \n     // Encode and index the items.\n-    ecx.start_tag(tag_items);\n     i = ecx.position();\n     let items = encode_info_for_items(ecx);\n     let item_bytes = ecx.position() - i;\n-    ecx.end_tag();\n \n     i = ecx.position();\n     encode_item_index(ecx, items);"}, {"sha": "372577e21f1165069a5274fe078aae4a02e6726b", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2ea3daad1372cffa5caf9f20fe36667e334662b/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ea3daad1372cffa5caf9f20fe36667e334662b/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=d2ea3daad1372cffa5caf9f20fe36667e334662b", "patch": "@@ -55,7 +55,6 @@\n //! give a callback fn, rather than taking a closure: it allows us to\n //! easily control precisely what data is given to that fn.\n \n-use common::tag_items_data_item;\n use encoder::EncodeContext;\n use index::IndexData;\n use rustc::dep_graph::DepNode;\n@@ -120,7 +119,8 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         let position = self.ecx.mark_stable_position();\n         self.items.record(id, position);\n         let _task = self.tcx.dep_graph.in_task(DepNode::MetaData(id));\n-        self.ecx.start_tag(tag_items_data_item).unwrap();\n+        // FIXME(eddyb) Avoid wrapping the entries in docs.\n+        self.ecx.start_tag(0).unwrap();\n         data.read(self.tcx);\n         op(&mut self.ecx, data);\n         self.ecx.end_tag().unwrap();"}]}