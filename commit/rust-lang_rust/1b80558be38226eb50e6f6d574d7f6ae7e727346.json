{"sha": "1b80558be38226eb50e6f6d574d7f6ae7e727346", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiODA1NThiZTM4MjI2ZWI1MGU2ZjZkNTc0ZDdmNmFlN2U3MjczNDY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-28T05:38:08Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-01T06:21:19Z"}, "message": "rustc: Remove usage of fmt!", "tree": {"sha": "9c1c77e0911b1c8f0f0d9aad19b94c9e5c608201", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c1c77e0911b1c8f0f0d9aad19b94c9e5c608201"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b80558be38226eb50e6f6d574d7f6ae7e727346", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b80558be38226eb50e6f6d574d7f6ae7e727346", "html_url": "https://github.com/rust-lang/rust/commit/1b80558be38226eb50e6f6d574d7f6ae7e727346", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b80558be38226eb50e6f6d574d7f6ae7e727346/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af3b132285bc9314d545cae2e4eaef079a26252a", "url": "https://api.github.com/repos/rust-lang/rust/commits/af3b132285bc9314d545cae2e4eaef079a26252a", "html_url": "https://github.com/rust-lang/rust/commit/af3b132285bc9314d545cae2e4eaef079a26252a"}], "stats": {"total": 3482, "additions": 1743, "deletions": 1739}, "files": [{"sha": "8be8a433ef8335ca1563abca8708ee725426648e", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -131,13 +131,13 @@ pub mod jit {\n             for cratepath in r.iter() {\n                 let path = cratepath.to_str();\n \n-                debug!(\"linking: %s\", path);\n+                debug2!(\"linking: {}\", path);\n \n                 do path.with_c_str |buf_t| {\n                     if !llvm::LLVMRustLoadCrate(manager, buf_t) {\n                         llvm_err(sess, ~\"Could not link\");\n                     }\n-                    debug!(\"linked: %s\", path);\n+                    debug2!(\"linked: {}\", path);\n                 }\n             }\n \n@@ -303,7 +303,7 @@ pub mod write {\n             for pass in sess.opts.custom_passes.iter() {\n                 do pass.with_c_str |s| {\n                     if !llvm::LLVMRustAddPass(mpm, s) {\n-                        sess.warn(fmt!(\"Unknown pass %s, ignoring\", *pass));\n+                        sess.warn(format!(\"Unknown pass {}, ignoring\", *pass));\n                     }\n                 }\n             }\n@@ -381,9 +381,9 @@ pub mod write {\n         let prog = run::process_output(cc_prog, cc_args);\n \n         if prog.status != 0 {\n-            sess.err(fmt!(\"building with `%s` failed with code %d\",\n+            sess.err(format!(\"building with `{}` failed with code {}\",\n                         cc_prog, prog.status));\n-            sess.note(fmt!(\"%s arguments: %s\",\n+            sess.note(format!(\"{} arguments: {}\",\n                         cc_prog, cc_args.connect(\" \")));\n             sess.note(str::from_utf8(prog.error + prog.output));\n             sess.abort_if_errors();\n@@ -554,7 +554,7 @@ pub fn build_link_meta(sess: Session,\n                               dep_hashes: ~[@str],\n                               pkg_id: Option<@str>) -> @str {\n         fn len_and_str(s: &str) -> ~str {\n-            fmt!(\"%u_%s\", s.len(), s)\n+            format!(\"{}_{}\", s.len(), s)\n         }\n \n         fn len_and_str_lit(l: ast::lit) -> ~str {\n@@ -599,7 +599,7 @@ pub fn build_link_meta(sess: Session,\n \n     fn warn_missing(sess: Session, name: &str, default: &str) {\n         if !*sess.building_library { return; }\n-        sess.warn(fmt!(\"missing crate link meta `%s`, using `%s` as default\",\n+        sess.warn(format!(\"missing crate link meta `{}`, using `{}` as default\",\n                        name, default));\n     }\n \n@@ -612,7 +612,7 @@ pub fn build_link_meta(sess: Session,\n                 // filestem that returned an @str\n                 let name = session::expect(sess,\n                                            output.filestem(),\n-                                           || fmt!(\"output file name `%s` doesn't\\\n+                                           || format!(\"output file name `{}` doesn't\\\n                                                     appear to have a stem\",\n                                                    output.to_str())).to_managed();\n                 if name.is_empty() {\n@@ -762,7 +762,7 @@ pub fn mangle(sess: Session, ss: path,\n \n     let push = |s: &str| {\n         let sani = sanitize(s);\n-        n.push_str(fmt!(\"%u%s\", sani.len(), sani));\n+        n.push_str(format!(\"{}{}\", sani.len(), sani));\n     };\n \n     // First, connect each component with <len, name> pairs.\n@@ -874,7 +874,7 @@ pub fn output_dll_filename(os: session::Os, lm: LinkMeta) -> ~str {\n         session::OsAndroid => (android::DLL_PREFIX, android::DLL_SUFFIX),\n         session::OsFreebsd => (freebsd::DLL_PREFIX, freebsd::DLL_SUFFIX),\n     };\n-    fmt!(\"%s%s-%s-%s%s\", dll_prefix, lm.name, lm.extras_hash, lm.vers, dll_suffix)\n+    format!(\"{}{}-{}-{}{}\", dll_prefix, lm.name, lm.extras_hash, lm.vers, dll_suffix)\n }\n \n pub fn get_cc_prog(sess: Session) -> ~str {\n@@ -890,7 +890,7 @@ pub fn get_cc_prog(sess: Session) -> ~str {\n             session::OsAndroid =>\n                 match &sess.opts.android_cross_path {\n                     &Some(ref path) => {\n-                        fmt!(\"%s/bin/arm-linux-androideabi-gcc\", *path)\n+                        format!(\"{}/bin/arm-linux-androideabi-gcc\", *path)\n                     }\n                     &None => {\n                         sess.fatal(\"need Android NDK path for linking \\\n@@ -915,29 +915,29 @@ pub fn link_binary(sess: Session,\n \n     let output = if *sess.building_library {\n         let long_libname = output_dll_filename(sess.targ_cfg.os, lm);\n-        debug!(\"link_meta.name:  %s\", lm.name);\n-        debug!(\"long_libname: %s\", long_libname);\n-        debug!(\"out_filename: %s\", out_filename.to_str());\n-        debug!(\"dirname(out_filename): %s\", out_filename.dir_path().to_str());\n+        debug2!(\"link_meta.name:  {}\", lm.name);\n+        debug2!(\"long_libname: {}\", long_libname);\n+        debug2!(\"out_filename: {}\", out_filename.to_str());\n+        debug2!(\"dirname(out_filename): {}\", out_filename.dir_path().to_str());\n \n         out_filename.dir_path().push(long_libname)\n     } else {\n         out_filename.clone()\n     };\n \n-    debug!(\"output: %s\", output.to_str());\n+    debug2!(\"output: {}\", output.to_str());\n     let cc_args = link_args(sess, obj_filename, out_filename, lm);\n-    debug!(\"%s link args: %s\", cc_prog, cc_args.connect(\" \"));\n+    debug2!(\"{} link args: {}\", cc_prog, cc_args.connect(\" \"));\n     if (sess.opts.debugging_opts & session::print_link_args) != 0 {\n-        io::println(fmt!(\"%s link args: %s\", cc_prog, cc_args.connect(\" \")));\n+        io::println(format!(\"{} link args: {}\", cc_prog, cc_args.connect(\" \")));\n     }\n \n     // We run 'cc' here\n     let prog = run::process_output(cc_prog, cc_args);\n     if 0 != prog.status {\n-        sess.err(fmt!(\"linking with `%s` failed with code %d\",\n+        sess.err(format!(\"linking with `{}` failed with code {}\",\n                       cc_prog, prog.status));\n-        sess.note(fmt!(\"%s arguments: %s\",\n+        sess.note(format!(\"{} arguments: {}\",\n                        cc_prog, cc_args.connect(\" \")));\n         sess.note(str::from_utf8(prog.error + prog.output));\n         sess.abort_if_errors();\n@@ -951,7 +951,7 @@ pub fn link_binary(sess: Session,\n     // Remove the temporary object file if we aren't saving temps\n     if !sess.opts.save_temps {\n         if ! os::remove_file(obj_filename) {\n-            sess.warn(fmt!(\"failed to delete object file `%s`\",\n+            sess.warn(format!(\"failed to delete object file `{}`\",\n                            obj_filename.to_str()));\n         }\n     }"}, {"sha": "60289e0ebe5a190d649a17ecd908996a14db4e22", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -29,7 +29,7 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path)\n         return ~[];\n     }\n \n-    debug!(\"preparing the RPATH!\");\n+    debug2!(\"preparing the RPATH!\");\n \n     let sysroot = sess.filesearch.sysroot();\n     let output = out_filename;\n@@ -49,21 +49,21 @@ fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n }\n \n pub fn rpaths_to_flags(rpaths: &[Path]) -> ~[~str] {\n-    rpaths.iter().map(|rpath| fmt!(\"-Wl,-rpath,%s\",rpath.to_str())).collect()\n+    rpaths.iter().map(|rpath| format!(\"-Wl,-rpath,{}\",rpath.to_str())).collect()\n }\n \n fn get_rpaths(os: session::Os,\n               sysroot: &Path,\n               output: &Path,\n               libs: &[Path],\n               target_triple: &str) -> ~[Path] {\n-    debug!(\"sysroot: %s\", sysroot.to_str());\n-    debug!(\"output: %s\", output.to_str());\n-    debug!(\"libs:\");\n+    debug2!(\"sysroot: {}\", sysroot.to_str());\n+    debug2!(\"output: {}\", output.to_str());\n+    debug2!(\"libs:\");\n     for libpath in libs.iter() {\n-        debug!(\"    %s\", libpath.to_str());\n+        debug2!(\"    {}\", libpath.to_str());\n     }\n-    debug!(\"target_triple: %s\", target_triple);\n+    debug2!(\"target_triple: {}\", target_triple);\n \n     // Use relative paths to the libraries. Binaries can be moved\n     // as long as they maintain the relative relationship to the\n@@ -78,9 +78,9 @@ fn get_rpaths(os: session::Os,\n     let fallback_rpaths = ~[get_install_prefix_rpath(target_triple)];\n \n     fn log_rpaths(desc: &str, rpaths: &[Path]) {\n-        debug!(\"%s rpaths:\", desc);\n+        debug2!(\"{} rpaths:\", desc);\n         for rpath in rpaths.iter() {\n-            debug!(\"    %s\", rpath.to_str());\n+            debug2!(\"    {}\", rpath.to_str());\n         }\n     }\n \n@@ -172,7 +172,7 @@ mod test {\n         let res = get_install_prefix_rpath(\"triple\");\n         let d = Path(env!(\"CFG_PREFIX\"))\n             .push_rel(&Path(\"lib/rustc/triple/lib\"));\n-        debug!(\"test_prefix_path: %s vs. %s\",\n+        debug2!(\"test_prefix_path: {} vs. {}\",\n                res.to_str(),\n                d.to_str());\n         assert!(res.to_str().ends_with(d.to_str()));\n@@ -233,7 +233,7 @@ mod test {\n     #[test]\n     fn test_get_absolute_rpath() {\n         let res = get_absolute_rpath(&Path(\"lib/libstd.so\"));\n-        debug!(\"test_get_absolute_rpath: %s vs. %s\",\n+        debug2!(\"test_get_absolute_rpath: {} vs. {}\",\n                res.to_str(),\n                os::make_absolute(&Path(\"lib\")).to_str());\n "}, {"sha": "76f48577fe672641eff18e9db06953e9bbe6cab1", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -386,33 +386,33 @@ pub fn phase_6_link_output(sess: Session,\n \n pub fn stop_after_phase_3(sess: Session) -> bool {\n    if sess.opts.no_trans {\n-        debug!(\"invoked with --no-trans, returning early from compile_input\");\n+        debug2!(\"invoked with --no-trans, returning early from compile_input\");\n         return true;\n     }\n     return false;\n }\n \n pub fn stop_after_phase_1(sess: Session) -> bool {\n     if sess.opts.parse_only {\n-        debug!(\"invoked with --parse-only, returning early from compile_input\");\n+        debug2!(\"invoked with --parse-only, returning early from compile_input\");\n         return true;\n     }\n     return false;\n }\n \n pub fn stop_after_phase_5(sess: Session) -> bool {\n     if sess.opts.output_type != link::output_type_exe {\n-        debug!(\"not building executable, returning early from compile_input\");\n+        debug2!(\"not building executable, returning early from compile_input\");\n         return true;\n     }\n \n     if sess.opts.is_static && *sess.building_library {\n-        debug!(\"building static library, returning early from compile_input\");\n+        debug2!(\"building static library, returning early from compile_input\");\n         return true;\n     }\n \n     if sess.opts.jit {\n-        debug!(\"running JIT, returning early from compile_input\");\n+        debug2!(\"running JIT, returning early from compile_input\");\n         return true;\n     }\n     return false;\n@@ -670,7 +670,7 @@ pub fn build_session_options(binary: @str,\n             let lint_name = lint_name.replace(\"-\", \"_\");\n             match lint_dict.find_equiv(&lint_name) {\n               None => {\n-                early_error(demitter, fmt!(\"unknown %s flag: %s\",\n+                early_error(demitter, format!(\"unknown {} flag: {}\",\n                                            level_name, lint_name));\n               }\n               Some(lint) => {\n@@ -690,7 +690,7 @@ pub fn build_session_options(binary: @str,\n             if name == debug_flag { this_bit = bit; break; }\n         }\n         if this_bit == 0u {\n-            early_error(demitter, fmt!(\"unknown debug flag: %s\", *debug_flag))\n+            early_error(demitter, format!(\"unknown debug flag: {}\", *debug_flag))\n         }\n         debugging_opts |= this_bit;\n     }\n@@ -1033,7 +1033,7 @@ pub fn build_output_filenames(input: &input,\n \n pub fn early_error(emitter: @diagnostic::Emitter, msg: ~str) -> ! {\n     emitter.emit(None, msg, diagnostic::fatal);\n-    fail!();\n+    fail2!();\n }\n \n pub fn list_metadata(sess: Session, path: &Path, out: @io::Writer) {\n@@ -1058,7 +1058,7 @@ mod test {\n         let matches =\n             &match getopts([~\"--test\"], optgroups()) {\n               Ok(m) => m,\n-              Err(f) => fail!(\"test_switch_implies_cfg_test: %s\", f.to_err_msg())\n+              Err(f) => fail2!(\"test_switch_implies_cfg_test: {}\", f.to_err_msg())\n             };\n         let sessopts = build_session_options(\n             @\"rustc\",\n@@ -1079,7 +1079,8 @@ mod test {\n             &match getopts([~\"--test\", ~\"--cfg=test\"], optgroups()) {\n               Ok(m) => m,\n               Err(f) => {\n-                fail!(\"test_switch_implies_cfg_test_unless_cfg_test: %s\", f.to_err_msg());\n+                fail2!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\",\n+                       f.to_err_msg());\n               }\n             };\n         let sessopts = build_session_options("}, {"sha": "5998f590a334f6e42fab94f83d65a0fc691ab65f", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -296,7 +296,7 @@ impl Session_ {\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp, fmt!(\"Impossible case reached: %s\", msg));\n+        self.span_bug(sp, format!(\"Impossible case reached: {}\", msg));\n     }\n     pub fn verbose(&self) -> bool { self.debugging_opt(verbose) }\n     pub fn time_passes(&self) -> bool { self.debugging_opt(time_passes) }"}, {"sha": "e4904863a94bc195a66b4d28e5e84e9abeeb1663", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -78,7 +78,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n \n     fn fold_item(&self, i: @ast::item) -> Option<@ast::item> {\n         self.cx.path.push(i.ident);\n-        debug!(\"current path: %s\",\n+        debug2!(\"current path: {}\",\n                ast_util::path_name_i(self.cx.path.clone()));\n \n         if is_test_fn(self.cx, i) || is_bench_fn(i) {\n@@ -91,7 +91,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n                                      tests\");\n                 }\n                 _ => {\n-                    debug!(\"this is a test function\");\n+                    debug2!(\"this is a test function\");\n                     let test = Test {\n                         span: i.span,\n                         path: self.cx.path.clone(),\n@@ -100,7 +100,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n                         should_fail: should_fail(i)\n                     };\n                     self.cx.testfns.push(test);\n-                    // debug!(\"have %u test/bench functions\",\n+                    // debug2!(\"have {} test/bench functions\",\n                     //        cx.testfns.len());\n                 }\n             }\n@@ -327,7 +327,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n         span: dummy_sp(),\n      };\n \n-    debug!(\"Synthetic test module:\\n%s\\n\",\n+    debug2!(\"Synthetic test module:\\n{}\\n\",\n            pprust::item_to_str(@item.clone(), cx.sess.intr()));\n \n     return @item;\n@@ -381,7 +381,7 @@ fn is_extra(crate: &ast::Crate) -> bool {\n }\n \n fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n-    debug!(\"building test vector from %u tests\", cx.testfns.len());\n+    debug2!(\"building test vector from {} tests\", cx.testfns.len());\n     let mut descs = ~[];\n     for test in cx.testfns.iter() {\n         descs.push(mk_test_desc_and_fn_rec(cx, test));\n@@ -404,7 +404,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n     let span = test.span;\n     let path = test.path.clone();\n \n-    debug!(\"encoding %s\", ast_util::path_name_i(path));\n+    debug2!(\"encoding {}\", ast_util::path_name_i(path));\n \n     let name_lit: ast::lit =\n         nospan(ast::lit_str(ast_util::path_name_i(path).to_managed()));"}, {"sha": "0ef98d96568a38438873c0ca70207a29451b5b57", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -2270,33 +2270,33 @@ impl TypeNames {\n                 Metadata => ~\"Metadata\",\n                 X86_MMX => ~\"X86_MMAX\",\n                 Integer => {\n-                    fmt!(\"i%d\", llvm::LLVMGetIntTypeWidth(ty.to_ref()) as int)\n+                    format!(\"i{}\", llvm::LLVMGetIntTypeWidth(ty.to_ref()) as int)\n                 }\n                 Function => {\n                     let out_ty = ty.return_type();\n                     let args = ty.func_params();\n                     let args =\n                         args.map(|&ty| self.type_to_str_depth(ty, depth-1)).connect(\", \");\n                     let out_ty = self.type_to_str_depth(out_ty, depth-1);\n-                    fmt!(\"fn(%s) -> %s\", args, out_ty)\n+                    format!(\"fn({}) -> {}\", args, out_ty)\n                 }\n                 Struct => {\n                     let tys = ty.field_types();\n                     let tys = tys.map(|&ty| self.type_to_str_depth(ty, depth-1)).connect(\", \");\n-                    fmt!(\"{%s}\", tys)\n+                    format!(\"\\\\{{}\\\\}\", tys)\n                 }\n                 Array => {\n                     let el_ty = ty.element_type();\n                     let el_ty = self.type_to_str_depth(el_ty, depth-1);\n                     let len = ty.array_length();\n-                    fmt!(\"[%s x %u]\", el_ty, len)\n+                    format!(\"[{} x {}]\", el_ty, len)\n                 }\n                 Pointer => {\n                     let el_ty = ty.element_type();\n                     let el_ty = self.type_to_str_depth(el_ty, depth-1);\n-                    fmt!(\"*%s\", el_ty)\n+                    format!(\"*{}\", el_ty)\n                 }\n-                _ => fail!(\"Unknown Type Kind (%u)\", kind as uint)\n+                _ => fail2!(\"Unknown Type Kind ({})\", kind as uint)\n             }\n         }\n     }\n@@ -2307,7 +2307,7 @@ impl TypeNames {\n \n     pub fn types_to_str(&self, tys: &[Type]) -> ~str {\n         let strs = tys.map(|t| self.type_to_str(*t));\n-        fmt!(\"[%s]\", strs.connect(\",\"))\n+        format!(\"[{}]\", strs.connect(\",\"))\n     }\n \n     pub fn val_to_str(&self, val: ValueRef) -> ~str {"}, {"sha": "c41e1d78f6486b3a22dc79fb92ba2e9e5c9faaf8", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -74,11 +74,11 @@ struct cache_entry {\n }\n \n fn dump_crates(crate_cache: &[cache_entry]) {\n-    debug!(\"resolved crates:\");\n+    debug2!(\"resolved crates:\");\n     for entry in crate_cache.iter() {\n-        debug!(\"cnum: %?\", entry.cnum);\n-        debug!(\"span: %?\", entry.span);\n-        debug!(\"hash: %?\", entry.hash);\n+        debug2!(\"cnum: {:?}\", entry.cnum);\n+        debug2!(\"span: {:?}\", entry.span);\n+        debug2!(\"hash: {:?}\", entry.hash);\n     }\n }\n \n@@ -97,7 +97,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n \n         if matches.len() != 1u {\n             diag.handler().warn(\n-                fmt!(\"using multiple versions of crate `%s`\", name));\n+                format!(\"using multiple versions of crate `{}`\", name));\n             for match_ in matches.iter() {\n                 diag.span_note(match_.span, \"used here\");\n                 let attrs = ~[\n@@ -154,7 +154,7 @@ fn visit_view_item(e: @mut Env, i: &ast::view_item) {\n                   }\n             }\n           };\n-          debug!(\"resolving extern mod stmt. ident: %?, meta: %?\",\n+          debug2!(\"resolving extern mod stmt. ident: {:?}, meta: {:?}\",\n                  ident, meta_items);\n           let cnum = resolve_crate(e,\n                                    ident,\n@@ -317,7 +317,7 @@ fn resolve_crate(e: @mut Env,\n \n // Go through the crate metadata and load any crates that it references\n fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n-    debug!(\"resolving deps of external crate\");\n+    debug2!(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n     let mut cnum_map = HashMap::new();\n@@ -326,18 +326,18 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n         let extrn_cnum = dep.cnum;\n         let cname_str = token::ident_to_str(&dep.name);\n         let cmetas = metas_with(dep.vers, @\"vers\", ~[]);\n-        debug!(\"resolving dep crate %s ver: %s hash: %s\",\n+        debug2!(\"resolving dep crate {} ver: {} hash: {}\",\n                cname_str, dep.vers, dep.hash);\n         match existing_match(e,\n                              metas_with_ident(cname_str, cmetas.clone()),\n                              dep.hash) {\n           Some(local_cnum) => {\n-            debug!(\"already have it\");\n+            debug2!(\"already have it\");\n             // We've already seen this crate\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n           None => {\n-            debug!(\"need to load it\");\n+            debug2!(\"need to load it\");\n             // This is a new one so we've got to load it\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span."}, {"sha": "6def597b89fb3bc2bff41043a566b2e36f50454c", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -210,17 +210,17 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n     let all_items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n-    debug!(\"Looking up %?\", class_id);\n+    debug2!(\"Looking up {:?}\", class_id);\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),\n-                           || fmt!(\"get_field_type: class ID %? not found\",\n+                           || format!(\"get_field_type: class ID {:?} not found\",\n                                    class_id) );\n-    debug!(\"looking up %? : %?\", def, class_doc);\n+    debug2!(\"looking up {:?} : {:?}\", def, class_doc);\n     let the_field = expect(tcx.diag,\n         decoder::maybe_find_item(def.node, class_doc),\n-        || fmt!(\"get_field_type: in class %?, field ID %? not found\",\n+        || format!(\"get_field_type: in class {:?}, field ID {:?} not found\",\n                  class_id, def) );\n-    debug!(\"got field data %?\", the_field);\n+    debug2!(\"got field data {:?}\", the_field);\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     ty::ty_param_bounds_and_ty {\n         generics: ty::Generics {type_param_defs: @~[],"}, {"sha": "03af7c98b877490dde7bb13a7f96dccec530d8a8", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -152,7 +152,7 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         let vers = decoder::get_crate_vers(cdata.data);\n-        debug!(\"Add hash[%s]: %s %s\", cdata.name, vers, hash);\n+        debug2!(\"Add hash[{}]: {} {}\", cdata.name, vers, hash);\n         result.push(crate_hash {\n             name: cdata.name,\n             vers: vers,\n@@ -164,9 +164,9 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n         (a.name, a.vers, a.hash) <= (b.name, b.vers, b.hash)\n     };\n \n-    debug!(\"sorted:\");\n+    debug2!(\"sorted:\");\n     for x in sorted.iter() {\n-        debug!(\"  hash[%s]: %s\", x.name, x.hash);\n+        debug2!(\"  hash[{}]: {}\", x.name, x.hash);\n     }\n \n     sorted.map(|ch| ch.hash)"}, {"sha": "5c6a7c4f3b7c752f94d3f0524e373e3d46412059", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -89,7 +89,7 @@ pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n \n fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n     match maybe_find_item(item_id, items) {\n-       None => fail!(\"lookup_item: id not found: %d\", item_id),\n+       None => fail2!(\"lookup_item: id not found: {}\", item_id),\n        Some(d) => d\n     }\n }\n@@ -148,7 +148,7 @@ fn item_family(item: ebml::Doc) -> Family {\n       'g' => PublicField,\n       'j' => PrivateField,\n       'N' => InheritedField,\n-       c => fail!(\"unexpected family char: %c\", c)\n+       c => fail2!(\"unexpected family char: {}\", c)\n     }\n }\n \n@@ -160,7 +160,7 @@ fn item_visibility(item: ebml::Doc) -> ast::visibility {\n                 'y' => ast::public,\n                 'n' => ast::private,\n                 'i' => ast::inherited,\n-                _ => fail!(\"unknown visibility character\")\n+                _ => fail2!(\"unknown visibility character\")\n             }\n         }\n     }\n@@ -494,8 +494,8 @@ pub enum DefLike {\n pub fn def_like_to_def(def_like: DefLike) -> ast::Def {\n     match def_like {\n         DlDef(def) => return def,\n-        DlImpl(*) => fail!(\"found impl in def_like_to_def\"),\n-        DlField => fail!(\"found field in def_like_to_def\")\n+        DlImpl(*) => fail2!(\"found impl in def_like_to_def\"),\n+        DlField => fail2!(\"found field in def_like_to_def\")\n     }\n }\n \n@@ -550,14 +550,14 @@ impl<'self> EachItemContext<'self> {\n         let def_like = item_to_def_like(doc, def_id, self.cdata.cnum);\n         match def_like {\n             DlDef(def) => {\n-                debug!(\"(iterating over each item of a module) processing \\\n-                        `%s` (def %?)\",\n+                debug2!(\"(iterating over each item of a module) processing \\\n+                        `{}` (def {:?})\",\n                        *self.path_builder,\n                        def);\n             }\n             _ => {\n-                debug!(\"(iterating over each item of a module) processing \\\n-                        `%s` (%d:%d)\",\n+                debug2!(\"(iterating over each item of a module) processing \\\n+                        `{}` ({}:{})\",\n                        *self.path_builder,\n                        def_id.crate,\n                        def_id.node);\n@@ -631,8 +631,8 @@ impl<'self> EachItemContext<'self> {\n                 reader::get_doc(root, tag_items)\n             };\n \n-            debug!(\"(iterating over each item of a module) looking up item \\\n-                    %d:%d in `%s`, crate %d\",\n+            debug2!(\"(iterating over each item of a module) looking up item \\\n+                    {}:{} in `{}`, crate {}\",\n                    child_def_id.crate,\n                    child_def_id.node,\n                    *self.path_builder,\n@@ -644,8 +644,8 @@ impl<'self> EachItemContext<'self> {\n                 Some(child_item_doc) => {\n                     // Push the name.\n                     let child_name = item_name(self.intr, child_item_doc);\n-                    debug!(\"(iterating over each item of a module) pushing \\\n-                            name `%s` onto `%s`\",\n+                    debug2!(\"(iterating over each item of a module) pushing \\\n+                            name `{}` onto `{}`\",\n                            token::ident_to_str(&child_name),\n                            *self.path_builder);\n                     let old_len =\n@@ -682,9 +682,9 @@ impl<'self> EachItemContext<'self> {\n             let name = name_doc.as_str_slice();\n \n             // Push the name.\n-            debug!(\"(iterating over each item of a module) pushing \\\n-                    reexported name `%s` onto `%s` (crate %d, orig %d, \\\n-                    in crate %d)\",\n+            debug2!(\"(iterating over each item of a module) pushing \\\n+                    reexported name `{}` onto `{}` (crate {}, orig {}, \\\n+                    in crate {})\",\n                    name,\n                    *self.path_builder,\n                    def_id.crate,\n@@ -899,7 +899,7 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt,\n                           id: ast::NodeId,\n                           decode_inlined_item: decode_inlined_item)\n                        -> csearch::found_ast {\n-    debug!(\"Looking up item: %d\", id);\n+    debug2!(\"Looking up item: {}\", id);\n     let item_doc = lookup_item(id, cdata.data);\n     let path = {\n         let item_path = item_path(item_doc);\n@@ -964,7 +964,7 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n         match ch as char {\n             'i' => ast::MutImmutable,\n             'm' => ast::MutMutable,\n-            _ => fail!(\"unknown mutability character: `%c`\", ch as char),\n+            _ => fail2!(\"unknown mutability character: `{}`\", ch as char),\n         }\n     }\n \n@@ -982,7 +982,7 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n             return ast::sty_region(None, get_mutability(string[1]));\n         }\n         _ => {\n-            fail!(\"unknown self type code: `%c`\", explicit_self_kind as char);\n+            fail2!(\"unknown self type code: `{}`\", explicit_self_kind as char);\n         }\n     }\n }\n@@ -1163,7 +1163,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n                 match item_family(impl_method_doc) {\n                     StaticMethod => purity = ast::impure_fn,\n                     UnsafeStaticMethod => purity = ast::unsafe_fn,\n-                    _ => fail!()\n+                    _ => fail2!()\n                 }\n \n                 static_impl_methods.push(StaticMethodInfo {\n@@ -1199,7 +1199,7 @@ fn struct_field_family_to_visibility(family: Family) -> ast::visibility {\n       PublicField => ast::public,\n       PrivateField => ast::private,\n       InheritedField => ast::inherited,\n-      _ => fail!()\n+      _ => fail2!()\n     }\n }\n \n@@ -1265,7 +1265,7 @@ fn describe_def(items: ebml::Doc, id: ast::DefId) -> ~str {\n     if id.crate != ast::LOCAL_CRATE { return ~\"external\"; }\n     let it = match maybe_find_item(id.node, items) {\n         Some(it) => it,\n-        None => fail!(\"describe_def: item not found %?\", id)\n+        None => fail2!(\"describe_def: item not found {:?}\", id)\n     };\n     return item_family_to_str(item_family(it));\n }\n@@ -1355,17 +1355,17 @@ fn list_meta_items(intr: @ident_interner,\n                    out: @io::Writer) {\n     let r = get_meta_items(meta_items);\n     for mi in r.iter() {\n-        out.write_str(fmt!(\"%s\\n\", pprust::meta_item_to_str(*mi, intr)));\n+        out.write_str(format!(\"{}\\n\", pprust::meta_item_to_str(*mi, intr)));\n     }\n }\n \n fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n                          out: @io::Writer) {\n-    out.write_str(fmt!(\"=Crate Attributes (%s)=\\n\", hash));\n+    out.write_str(format!(\"=Crate Attributes ({})=\\n\", hash));\n \n     let r = get_attributes(md);\n     for attr in r.iter() {\n-        out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(attr, intr)));\n+        out.write_str(format!(\"{}\\n\", pprust::attribute_to_str(attr, intr)));\n     }\n \n     out.write_str(\"\\n\\n\");\n@@ -1409,7 +1409,7 @@ fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n     let r = get_crate_deps(data);\n     for dep in r.iter() {\n         out.write_str(\n-            fmt!(\"%d %s-%s-%s\\n\",\n+            format!(\"{} {}-{}-{}\\n\",\n                  dep.cnum, token::ident_to_str(&dep.name), dep.hash, dep.vers));\n     }\n \n@@ -1452,7 +1452,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n \n     match cdata.cnum_map.find(&did.crate) {\n       option::Some(&n) => ast::DefId { crate: n, node: did.node },\n-      option::None => fail!(\"didn't find a crate in the cnum_map\")\n+      option::None => fail2!(\"didn't find a crate in the cnum_map\")\n     }\n }\n "}, {"sha": "ff59376aa37f2622f9f4e9108978e2606a6617ab", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -185,7 +185,7 @@ fn encode_family(ebml_w: &mut writer::Encoder, c: char) {\n }\n \n pub fn def_to_str(did: DefId) -> ~str {\n-    fmt!(\"%d:%d\", did.crate, did.node)\n+    format!(\"{}:{}\", did.crate, did.node)\n }\n \n fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n@@ -284,12 +284,12 @@ fn encode_symbol(ecx: &EncodeContext,\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.find(&id) {\n         Some(x) => {\n-            debug!(\"encode_symbol(id=%?, str=%s)\", id, *x);\n+            debug2!(\"encode_symbol(id={:?}, str={})\", id, *x);\n             ebml_w.writer.write(x.as_bytes());\n         }\n         None => {\n             ecx.diag.handler().bug(\n-                fmt!(\"encode_symbol: id not found %d\", id));\n+                format!(\"encode_symbol: id not found {}\", id));\n         }\n     }\n     ebml_w.end_tag();\n@@ -339,7 +339,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             path: &[ast_map::path_elt],\n                             index: @mut ~[entry<i64>],\n                             generics: &ast::Generics) {\n-    debug!(\"encode_enum_variant_info(id=%?)\", id);\n+    debug2!(\"encode_enum_variant_info(id={:?})\", id);\n \n     let mut disr_val = 0;\n     let mut i = 0;\n@@ -425,14 +425,14 @@ fn encode_reexported_static_method(ecx: &EncodeContext,\n                                    exp: &middle::resolve::Export2,\n                                    method_def_id: DefId,\n                                    method_ident: Ident) {\n-    debug!(\"(encode reexported static method) %s::%s\",\n+    debug2!(\"(encode reexported static method) {}::{}\",\n             exp.name, ecx.tcx.sess.str_of(method_ident));\n     ebml_w.start_tag(tag_items_data_item_reexport);\n     ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n     ebml_w.wr_str(def_to_str(method_def_id));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_items_data_item_reexport_name);\n-    ebml_w.wr_str(fmt!(\"%s::%s\", exp.name, ecx.tcx.sess.str_of(method_ident)));\n+    ebml_w.wr_str(format!(\"{}::{}\", exp.name, ecx.tcx.sess.str_of(method_ident)));\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n@@ -498,14 +498,14 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n             if mod_path != *path || exp.name != original_name {\n                 if !encode_reexported_static_base_methods(ecx, ebml_w, exp) {\n                     if encode_reexported_static_trait_methods(ecx, ebml_w, exp) {\n-                        debug!(fmt!(\"(encode reexported static methods) %s \\\n-                                    [trait]\",\n-                                    original_name));\n+                        debug2!(\"(encode reexported static methods) {} \\\n+                                 [trait]\",\n+                                original_name);\n                     }\n                 }\n                 else {\n-                    debug!(fmt!(\"(encode reexported static methods) %s [base]\",\n-                                original_name));\n+                    debug2!(\"(encode reexported static methods) {} [base]\",\n+                            original_name);\n                 }\n             }\n         }\n@@ -552,13 +552,13 @@ fn encode_reexports(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     id: NodeId,\n                     path: &[ast_map::path_elt]) {\n-    debug!(\"(encoding info for module) encoding reexports for %d\", id);\n+    debug2!(\"(encoding info for module) encoding reexports for {}\", id);\n     match ecx.reexports2.find(&id) {\n         Some(ref exports) => {\n-            debug!(\"(encoding info for module) found reexports for %d\", id);\n+            debug2!(\"(encoding info for module) found reexports for {}\", id);\n             for exp in exports.iter() {\n-                debug!(\"(encoding info for module) reexport '%s' (%d/%d) for \\\n-                        %d\",\n+                debug2!(\"(encoding info for module) reexport '{}' ({}/{}) for \\\n+                        {}\",\n                        exp.name,\n                        exp.def_id.crate,\n                        exp.def_id.node,\n@@ -575,7 +575,7 @@ fn encode_reexports(ecx: &EncodeContext,\n             }\n         }\n         None => {\n-            debug!(\"(encoding info for module) found no reexports for %d\",\n+            debug2!(\"(encoding info for module) found no reexports for {}\",\n                    id);\n         }\n     }\n@@ -592,7 +592,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n     encode_name(ecx, ebml_w, name);\n-    debug!(\"(encoding info for module) encoding info for module ID %d\", id);\n+    debug2!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n     // Encode info about all the module children.\n     for item in md.items.iter() {\n@@ -610,8 +610,8 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         match item.node {\n             item_impl(*) => {\n                 let (ident, did) = (item.ident, item.id);\n-                debug!(\"(encoding info for module) ... encoding impl %s \\\n-                        (%?/%?)\",\n+                debug2!(\"(encoding info for module) ... encoding impl {} \\\n+                        ({:?}/{:?})\",\n                         ecx.tcx.sess.str_of(ident),\n                         did,\n                         ast_map::node_id_to_str(ecx.tcx.items, did, token::get_ident_interner()));\n@@ -628,7 +628,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n \n     // Encode the reexports of this module, if this module is public.\n     if vis == public {\n-        debug!(\"(encoding info for module) encoding reexports for %d\", id);\n+        debug2!(\"(encoding info for module) encoding reexports for {}\", id);\n         encode_reexports(ecx, ebml_w, id, path);\n     }\n \n@@ -730,7 +730,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n         global_index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n-        debug!(\"encode_info_for_struct: doing %s %d\",\n+        debug2!(\"encode_info_for_struct: doing {} {}\",\n                tcx.sess.str_of(nm), id);\n         encode_struct_field_family(ebml_w, vis);\n         encode_name(ecx, ebml_w, nm);\n@@ -794,7 +794,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                           parent_id: NodeId,\n                           ast_method_opt: Option<@method>) {\n \n-    debug!(\"encode_info_for_method: %? %s\", m.def_id,\n+    debug2!(\"encode_info_for_method: {:?} {}\", m.def_id,\n            ecx.tcx.sess.str_of(m.ident));\n     ebml_w.start_tag(tag_items_data_item);\n \n@@ -834,7 +834,7 @@ fn purity_static_method_family(p: purity) -> char {\n     match p {\n       unsafe_fn => 'U',\n       impure_fn => 'F',\n-      _ => fail!(\"extern fn can't be static\")\n+      _ => fail2!(\"extern fn can't be static\")\n     }\n }\n \n@@ -893,7 +893,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     }\n     let add_to_index: &fn() = || add_to_index_(item, ebml_w, index);\n \n-    debug!(\"encoding info for item at %s\",\n+    debug2!(\"encoding info for item at {}\",\n            ecx.tcx.sess.codemap.span_to_str(item.span));\n \n     let def_id = local_def(item.id);\n@@ -1220,7 +1220,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode inherent implementations for this trait.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n       }\n-      item_mac(*) => fail!(\"item macros unimplemented\")\n+      item_mac(*) => fail2!(\"item macros unimplemented\")\n     }\n }\n \n@@ -1279,15 +1279,15 @@ fn my_visit_item(i:@item, items: ast_map::map, ebml_w:&writer::Encoder,\n             };\n             encode_info_for_item(ecx, &mut ebml_w, i, index, *pt, vis);\n         }\n-        _ => fail!(\"bad item\")\n+        _ => fail2!(\"bad item\")\n     }\n }\n \n fn my_visit_foreign_item(ni:@foreign_item, items: ast_map::map, ebml_w:&writer::Encoder,\n                          ecx_ptr:*int, index: @mut ~[entry<i64>]) {\n     match items.get_copy(&ni.id) {\n         ast_map::node_foreign_item(_, abi, _, pt) => {\n-            debug!(\"writing foreign item %s::%s\",\n+            debug2!(\"writing foreign item {}::{}\",\n                    ast_map::path_to_str(\n                        *pt,\n                        token::get_ident_interner()),\n@@ -1304,7 +1304,7 @@ fn my_visit_foreign_item(ni:@foreign_item, items: ast_map::map, ebml_w:&writer::\n                                          abi);\n         }\n         // case for separate item and foreign-item tables\n-        _ => fail!(\"bad foreign item\")\n+        _ => fail2!(\"bad foreign item\")\n     }\n }\n "}, {"sha": "6761445b74e2212c2c26a993dfe283d1e6cb8a5c", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -53,7 +53,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n             let mut visited_dirs = HashSet::new();\n             let mut found = false;\n \n-            debug!(\"filesearch: searching additional lib search paths [%?]\",\n+            debug2!(\"filesearch: searching additional lib search paths [{:?}]\",\n                    self.addl_lib_search_paths.len());\n             for path in self.addl_lib_search_paths.iter() {\n                 match f(path) {\n@@ -63,7 +63,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n                 visited_dirs.insert(path.to_str());\n             }\n \n-            debug!(\"filesearch: searching target lib path\");\n+            debug2!(\"filesearch: searching target lib path\");\n             let tlib_path = make_target_lib_path(self.sysroot,\n                                         self.target_triple);\n             if !visited_dirs.contains(&tlib_path.to_str()) {\n@@ -78,7 +78,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n                 let rustpath = rust_path();\n                 for path in rustpath.iter() {\n                     let tlib_path = make_rustpkg_target_lib_path(path, self.target_triple);\n-                    debug!(\"is %s in visited_dirs? %?\", tlib_path.to_str(),\n+                    debug2!(\"is {} in visited_dirs? {:?}\", tlib_path.to_str(),\n                             visited_dirs.contains(&tlib_path.to_str()));\n \n                     if !visited_dirs.contains(&tlib_path.to_str()) {\n@@ -104,7 +104,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n     }\n \n     let sysroot = get_sysroot(maybe_sysroot);\n-    debug!(\"using sysroot = %s\", sysroot.to_str());\n+    debug2!(\"using sysroot = {}\", sysroot.to_str());\n     @FileSearchImpl {\n         sysroot: sysroot,\n         addl_lib_search_paths: addl_lib_search_paths,\n@@ -114,19 +114,19 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n \n pub fn search(filesearch: @FileSearch, pick: pick) {\n     do filesearch.for_each_lib_search_path() |lib_search_path| {\n-        debug!(\"searching %s\", lib_search_path.to_str());\n+        debug2!(\"searching {}\", lib_search_path.to_str());\n         let r = os::list_dir_path(lib_search_path);\n         let mut rslt = FileDoesntMatch;\n         for path in r.iter() {\n-            debug!(\"testing %s\", path.to_str());\n+            debug2!(\"testing {}\", path.to_str());\n             let maybe_picked = pick(path);\n             match maybe_picked {\n                 FileMatches => {\n-                    debug!(\"picked %s\", path.to_str());\n+                    debug2!(\"picked {}\", path.to_str());\n                     rslt = FileMatches;\n                 }\n                 FileDoesntMatch => {\n-                    debug!(\"rejected %s\", path.to_str());\n+                    debug2!(\"rejected {}\", path.to_str());\n                 }\n             }\n         }\n@@ -153,7 +153,7 @@ fn make_rustpkg_target_lib_path(dir: &Path,\n pub fn get_or_default_sysroot() -> Path {\n     match os::self_exe_path() {\n       option::Some(ref p) => (*p).pop(),\n-      option::None => fail!(\"can't determine value for sysroot\")\n+      option::None => fail2!(\"can't determine value for sysroot\")\n     }\n }\n "}, {"sha": "4d69a2ffce85d88ad91d028c7269a21afb56e7b5", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -59,7 +59,7 @@ pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n       Some(t) => t,\n       None => {\n         cx.diag.span_fatal(cx.span,\n-                           fmt!(\"can't find crate for `%s`\",\n+                           format!(\"can't find crate for `{}`\",\n                                 cx.ident));\n       }\n     }\n@@ -90,28 +90,28 @@ fn find_library_crate_aux(\n ) -> Option<(~str, @~[u8])> {\n     let crate_name = crate_name_from_metas(cx.metas);\n     // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n-    let prefix = fmt!(\"%s%s-\", prefix, crate_name);\n+    let prefix = format!(\"{}{}-\", prefix, crate_name);\n     let mut matches = ~[];\n     filesearch::search(filesearch, |path| -> FileMatch {\n       let path_str = path.filename();\n       match path_str {\n           None => FileDoesntMatch,\n           Some(path_str) =>\n               if path_str.starts_with(prefix) && path_str.ends_with(suffix) {\n-                  debug!(\"%s is a candidate\", path.to_str());\n+                  debug2!(\"{} is a candidate\", path.to_str());\n                   match get_metadata_section(cx.os, path) {\n                       Some(cvec) =>\n                           if !crate_matches(cvec, cx.metas, cx.hash) {\n-                              debug!(\"skipping %s, metadata doesn't match\",\n+                              debug2!(\"skipping {}, metadata doesn't match\",\n                                   path.to_str());\n                               FileDoesntMatch\n                           } else {\n-                              debug!(\"found %s with matching metadata\", path.to_str());\n+                              debug2!(\"found {} with matching metadata\", path.to_str());\n                               matches.push((path.to_str(), cvec));\n                               FileMatches\n                           },\n                       _ => {\n-                          debug!(\"could not load metadata for %s\", path.to_str());\n+                          debug2!(\"could not load metadata for {}\", path.to_str());\n                           FileDoesntMatch\n                       }\n                   }\n@@ -127,12 +127,12 @@ fn find_library_crate_aux(\n         1 => Some(matches[0]),\n         _ => {\n             cx.diag.span_err(\n-                    cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n+                    cx.span, format!(\"multiple matching crates for `{}`\", crate_name));\n                 cx.diag.handler().note(\"candidates:\");\n                 for pair in matches.iter() {\n                     let ident = pair.first();\n                     let data = pair.second();\n-                    cx.diag.handler().note(fmt!(\"path: %s\", ident));\n+                    cx.diag.handler().note(format!(\"path: {}\", ident));\n                     let attrs = decoder::get_crate_attributes(data);\n                     note_linkage_attrs(cx.intr, cx.diag, attrs);\n                 }\n@@ -149,7 +149,7 @@ pub fn crate_name_from_metas(metas: &[@ast::MetaItem]) -> @str {\n             _ => {}\n         }\n     }\n-    fail!(\"expected to find the crate name\")\n+    fail2!(\"expected to find the crate name\")\n }\n \n pub fn package_id_from_metas(metas: &[@ast::MetaItem]) -> Option<@str> {\n@@ -167,7 +167,7 @@ pub fn note_linkage_attrs(intr: @ident_interner,\n                           attrs: ~[ast::Attribute]) {\n     let r = attr::find_linkage_metas(attrs);\n     for mi in r.iter() {\n-        diag.handler().note(fmt!(\"meta: %s\", pprust::meta_item_to_str(*mi,intr)));\n+        diag.handler().note(format!(\"meta: {}\", pprust::meta_item_to_str(*mi,intr)));\n     }\n }\n \n@@ -188,7 +188,7 @@ pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n \n // extern_metas: metas we read from the crate\n // local_metas: metas we're looking for\n-    debug!(\"matching %u metadata requirements against %u items\",\n+    debug2!(\"matching {} metadata requirements against {} items\",\n            local_metas.len(), extern_metas.len());\n \n     do local_metas.iter().all |needed| {\n@@ -211,14 +211,14 @@ fn get_metadata_section(os: Os,\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let name_buf = llvm::LLVMGetSectionName(si.llsi);\n             let name = str::raw::from_c_str(name_buf);\n-            debug!(\"get_metadata_section: name %s\", name);\n+            debug2!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(os) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n                 let mut found = None;\n                 let cvbuf: *u8 = cast::transmute(cbuf);\n                 let vlen = encoder::metadata_encoding_version.len();\n-                debug!(\"checking %u bytes of metadata-version stamp\",\n+                debug2!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);\n                 let minsz = num::min(vlen, csz);\n                 let mut version_ok = false;\n@@ -229,7 +229,7 @@ fn get_metadata_section(os: Os,\n                 if !version_ok { return None; }\n \n                 let cvbuf1 = ptr::offset(cvbuf, vlen as int);\n-                debug!(\"inflating %u bytes of compressed metadata\",\n+                debug2!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n                 do vec::raw::buf_as_slice(cvbuf1, csz-vlen) |bytes| {\n                     let inflated = flate::inflate_bytes(bytes);\n@@ -273,7 +273,7 @@ pub fn list_file_metadata(intr: @ident_interner,\n     match get_metadata_section(os, path) {\n       option::Some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n       option::None => {\n-        out.write_str(fmt!(\"could not find metadata in %s.\\n\", path.to_str()))\n+        out.write_str(format!(\"could not find metadata in {}.\\n\", path.to_str()))\n       }\n     }\n }"}, {"sha": "b44051ef56058424ef31d9faaa9eb437ff93cce9", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -80,10 +80,10 @@ fn scan<R>(st: &mut PState, is_last: &fn(char) -> bool,\n            op: &fn(&[u8]) -> R) -> R\n {\n     let start_pos = st.pos;\n-    debug!(\"scan: '%c' (start)\", st.data[st.pos] as char);\n+    debug2!(\"scan: '{}' (start)\", st.data[st.pos] as char);\n     while !is_last(st.data[st.pos] as char) {\n         st.pos += 1;\n-        debug!(\"scan: '%c'\", st.data[st.pos] as char);\n+        debug2!(\"scan: '{}'\", st.data[st.pos] as char);\n     }\n     let end_pos = st.pos;\n     st.pos += 1;\n@@ -161,7 +161,7 @@ fn parse_sigil(st: &mut PState) -> ast::Sigil {\n         '@' => ast::ManagedSigil,\n         '~' => ast::OwnedSigil,\n         '&' => ast::BorrowedSigil,\n-        c => st.tcx.sess.bug(fmt!(\"parse_sigil(): bad input '%c'\", c))\n+        c => st.tcx.sess.bug(format!(\"parse_sigil(): bad input '{}'\", c))\n     }\n }\n \n@@ -179,7 +179,7 @@ fn parse_vstore(st: &mut PState) -> ty::vstore {\n       '~' => ty::vstore_uniq,\n       '@' => ty::vstore_box,\n       '&' => ty::vstore_slice(parse_region(st)),\n-      c => st.tcx.sess.bug(fmt!(\"parse_vstore(): bad input '%c'\", c))\n+      c => st.tcx.sess.bug(format!(\"parse_vstore(): bad input '{}'\", c))\n     }\n }\n \n@@ -188,7 +188,7 @@ fn parse_trait_store(st: &mut PState) -> ty::TraitStore {\n         '~' => ty::UniqTraitStore,\n         '@' => ty::BoxTraitStore,\n         '&' => ty::RegionTraitStore(parse_region(st)),\n-        c => st.tcx.sess.bug(fmt!(\"parse_trait_store(): bad input '%c'\", c))\n+        c => st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\", c))\n     }\n }\n \n@@ -221,7 +221,7 @@ fn parse_region_substs(st: &mut PState) -> ty::RegionSubsts {\n             assert_eq!(next(st), '.');\n             ty::NonerasedRegions(regions)\n         }\n-        _ => fail!(\"parse_bound_region: bad input\")\n+        _ => fail2!(\"parse_bound_region: bad input\")\n     }\n }\n \n@@ -239,7 +239,7 @@ fn parse_bound_region(st: &mut PState) -> ty::bound_region {\n         assert_eq!(next(st), '|');\n         ty::br_cap_avoid(id, @parse_bound_region(st))\n       },\n-      _ => fail!(\"parse_bound_region: bad input\")\n+      _ => fail2!(\"parse_bound_region: bad input\")\n     }\n }\n \n@@ -268,15 +268,15 @@ fn parse_region(st: &mut PState) -> ty::Region {\n       'e' => {\n         ty::re_static\n       }\n-      _ => fail!(\"parse_region: bad input\")\n+      _ => fail2!(\"parse_region: bad input\")\n     }\n }\n \n fn parse_opt<T>(st: &mut PState, f: &fn(&mut PState) -> T) -> Option<T> {\n     match next(st) {\n       'n' => None,\n       's' => Some(f(st)),\n-      _ => fail!(\"parse_opt: bad input\")\n+      _ => fail2!(\"parse_opt: bad input\")\n     }\n }\n \n@@ -317,7 +317,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n           'D' => return ty::mk_mach_int(ast::ty_i64),\n           'f' => return ty::mk_mach_float(ast::ty_f32),\n           'F' => return ty::mk_mach_float(ast::ty_f64),\n-          _ => fail!(\"parse_ty: bad numeric type\")\n+          _ => fail2!(\"parse_ty: bad numeric type\")\n         }\n       }\n       'c' => return ty::mk_char(),\n@@ -340,7 +340,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       }\n       'p' => {\n         let did = parse_def(st, TypeParameter, conv);\n-        debug!(\"parsed ty_param: did=%?\", did);\n+        debug2!(\"parsed ty_param: did={:?}\", did);\n         return ty::mk_param(st.tcx, parse_uint(st), did);\n       }\n       's' => {\n@@ -417,7 +417,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n           assert_eq!(next(st), ']');\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n-      c => { error!(\"unexpected char in type string: %c\", c); fail!();}\n+      c => { error2!(\"unexpected char in type string: {}\", c); fail2!();}\n     }\n }\n \n@@ -467,7 +467,7 @@ fn parse_purity(c: char) -> purity {\n       'u' => unsafe_fn,\n       'i' => impure_fn,\n       'c' => extern_fn,\n-      _ => fail!(\"parse_purity: bad purity %c\", c)\n+      _ => fail2!(\"parse_purity: bad purity {}\", c)\n     }\n }\n \n@@ -488,7 +488,7 @@ fn parse_onceness(c: char) -> ast::Onceness {\n     match c {\n         'o' => ast::Once,\n         'm' => ast::Many,\n-        _ => fail!(\"parse_onceness: bad onceness\")\n+        _ => fail2!(\"parse_onceness: bad onceness\")\n     }\n }\n \n@@ -539,21 +539,21 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let len = buf.len();\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n     if colon_idx == len {\n-        error!(\"didn't find ':' when parsing def id\");\n-        fail!();\n+        error2!(\"didn't find ':' when parsing def id\");\n+        fail2!();\n     }\n \n     let crate_part = buf.slice(0u, colon_idx);\n     let def_part = buf.slice(colon_idx + 1u, len);\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as int,\n-       None => fail!(\"internal error: parse_def_id: crate number expected, but found %?\",\n+       None => fail2!(\"internal error: parse_def_id: crate number expected, but found {:?}\",\n                      crate_part)\n     };\n     let def_num = match uint::parse_bytes(def_part, 10u) {\n        Some(dn) => dn as int,\n-       None => fail!(\"internal error: parse_def_id: id expected, but found %?\",\n+       None => fail2!(\"internal error: parse_def_id: id expected, but found {:?}\",\n                      def_part)\n     };\n     ast::DefId { crate: crate_num, node: def_num }\n@@ -599,7 +599,7 @@ fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n                 return param_bounds;\n             }\n             _ => {\n-                fail!(\"parse_bounds: bad bounds\")\n+                fail2!(\"parse_bounds: bad bounds\")\n             }\n         }\n     }"}, {"sha": "09c776a9fab5d8a12a31b200f58a2904e020f4ea", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -86,7 +86,7 @@ pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n           let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n           if abbrev_len < len {\n               // I.e. it's actually an abbreviation.\n-              let s = fmt!(\"#%x:%x#\", pos, len).to_managed();\n+              let s = format!(\"\\\\#{:x}:{:x}\\\\#\", pos, len).to_managed();\n               let a = ty_abbrev { pos: pos, len: len, s: s };\n               abbrevs.insert(t, a);\n           }\n@@ -336,18 +336,18 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: &ty::sty) {\n       }\n       ty::ty_opaque_box => w.write_char('B'),\n       ty::ty_struct(def, ref substs) => {\n-          debug!(\"~~~~ %s\", \"a[\");\n+          debug2!(\"~~~~ {}\", \"a[\");\n           w.write_str(&\"a[\");\n           let s = (cx.ds)(def);\n-          debug!(\"~~~~ %s\", s);\n+          debug2!(\"~~~~ {}\", s);\n           w.write_str(s);\n-          debug!(\"~~~~ %s\", \"|\");\n+          debug2!(\"~~~~ {}\", \"|\");\n           w.write_char('|');\n           enc_substs(w, cx, substs);\n-          debug!(\"~~~~ %s\", \"]\");\n+          debug2!(\"~~~~ {}\", \"]\");\n           w.write_char(']');\n       }\n-      ty::ty_err => fail!(\"Shouldn't encode error type\")\n+      ty::ty_err => fail2!(\"Shouldn't encode error type\")\n     }\n }\n "}, {"sha": "902f90eb7cd5c8dd8aea899d501d3e3d85078e81", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -84,7 +84,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            path: &[ast_map::path_elt],\n                            ii: ast::inlined_item,\n                            maps: Maps) {\n-    debug!(\"> Encoding inlined item: %s::%s (%u)\",\n+    debug2!(\"> Encoding inlined item: {}::{} ({})\",\n            ast_map::path_to_str(path, token::get_ident_interner()),\n            ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n@@ -97,7 +97,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     encode_side_tables_for_ii(ecx, maps, ebml_w, &ii);\n     ebml_w.end_tag();\n \n-    debug!(\"< Encoded inlined fn: %s::%s (%u)\",\n+    debug2!(\"< Encoded inlined fn: {}::{} ({})\",\n            ast_map::path_to_str(path, token::get_ident_interner()),\n            ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n@@ -117,7 +117,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n     match par_doc.opt_child(c::tag_ast) {\n       None => None,\n       Some(ast_doc) => {\n-        debug!(\"> Decoding inlined fn: %s::?\",\n+        debug2!(\"> Decoding inlined fn: {}::?\",\n                ast_map::path_to_str(path, token::get_ident_interner()));\n         let mut ast_dsr = reader::Decoder(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr);\n@@ -129,8 +129,8 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n         };\n         let raw_ii = decode_ast(ast_doc);\n         let ii = renumber_ast(xcx, raw_ii);\n-        debug!(\"Fn named: %s\", tcx.sess.str_of(ii.ident()));\n-        debug!(\"< Decoded inlined fn: %s::%s\",\n+        debug2!(\"Fn named: {}\", tcx.sess.str_of(ii.ident()));\n+        debug2!(\"< Decoded inlined fn: {}::{}\",\n                ast_map::path_to_str(path, token::get_ident_interner()),\n                tcx.sess.str_of(ii.ident()));\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n@@ -140,7 +140,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n         decode_side_tables(xcx, ast_doc);\n         match ii {\n           ast::ii_item(i) => {\n-            debug!(\">>> DECODED ITEM >>>\\n%s\\n<<< DECODED ITEM <<<\",\n+            debug2!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n                    syntax::print::pprust::item_to_str(i, tcx.sess.intr()));\n           }\n           _ => { }\n@@ -305,7 +305,7 @@ impl fold::ast_fold for NestedItemsDropper {\n                     node: ast::DeclItem(_),\n                     span: _\n                 }, _) => None,\n-                ast::StmtMac(*) => fail!(\"unexpanded macro in astencode\")\n+                ast::StmtMac(*) => fail2!(\"unexpanded macro in astencode\")\n             }\n         }.collect();\n         let blk_sans_items = ast::Block {\n@@ -741,7 +741,7 @@ impl vtable_decoder_helpers for reader::Decoder {\n                     )\n                   }\n                   // hard to avoid - user input\n-                  _ => fail!(\"bad enum variant\")\n+                  _ => fail2!(\"bad enum variant\")\n                 }\n             }\n         }\n@@ -896,7 +896,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                              id: ast::NodeId) {\n     let tcx = ecx.tcx;\n \n-    debug!(\"Encoding side tables for id %d\", id);\n+    debug2!(\"Encoding side tables for id {}\", id);\n \n     {\n         let r = tcx.def_map.find(&id);\n@@ -1091,7 +1091,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                 xcx.dcx.tcx,\n                 |s, a| this.convert_def_id(xcx, s, a));\n \n-            debug!(\"read_ty(%s) = %s\",\n+            debug2!(\"read_ty({}) = {}\",\n                    type_string(doc),\n                    ty_to_str(xcx.dcx.tcx, ty));\n \n@@ -1176,7 +1176,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n             NominalType | TypeWithId => xcx.tr_def_id(did),\n             TypeParameter => xcx.tr_intern_def_id(did)\n         };\n-        debug!(\"convert_def_id(source=%?, did=%?)=%?\", source, did, r);\n+        debug2!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);\n         return r;\n     }\n }\n@@ -1189,14 +1189,14 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n         let id0 = entry_doc.get(c::tag_table_id as uint).as_int();\n         let id = xcx.tr_id(id0);\n \n-        debug!(\">> Side table document with tag 0x%x \\\n-                found for id %d (orig %d)\",\n+        debug2!(\">> Side table document with tag 0x{:x} \\\n+                found for id {} (orig {})\",\n                tag, id, id0);\n \n         match c::astencode_tag::from_uint(tag) {\n             None => {\n                 xcx.dcx.tcx.sess.bug(\n-                    fmt!(\"unknown tag found in side tables: %x\", tag));\n+                    format!(\"unknown tag found in side tables: {:x}\", tag));\n             }\n             Some(value) => {\n                 let val_doc = entry_doc.get(c::tag_table_val as uint);\n@@ -1210,7 +1210,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     }\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(xcx);\n-                        debug!(\"inserting ty for node %?: %s\",\n+                        debug2!(\"inserting ty for node {:?}: {}\",\n                                id, ty_to_str(dcx.tcx, ty));\n                         dcx.tcx.node_types.insert(id as uint, ty);\n                     }\n@@ -1257,13 +1257,13 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     }\n                     _ => {\n                         xcx.dcx.tcx.sess.bug(\n-                            fmt!(\"unknown tag found in side tables: %x\", tag));\n+                            format!(\"unknown tag found in side tables: {:x}\", tag));\n                     }\n                 }\n             }\n         }\n \n-        debug!(\">< Side table doc loaded\");\n+        debug2!(\">< Side table doc loaded\");\n         true\n     };\n }\n@@ -1381,6 +1381,6 @@ fn test_simplification() {\n                      == pprust::item_to_str(item_exp,\n                                             token::get_ident_interner()));\n       }\n-      _ => fail!()\n+      _ => fail2!()\n     }\n }"}, {"sha": "5334bf7cc1de4cc0e59d640c07f75a957daaa752", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -65,7 +65,7 @@ pub fn check_loans(bccx: &BorrowckCtxt,\n                    move_data: move_data::FlowedMoveData,\n                    all_loans: &[Loan],\n                    body: &ast::Block) {\n-    debug!(\"check_loans(body id=%?)\", body.id);\n+    debug2!(\"check_loans(body id={:?})\", body.id);\n \n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,\n@@ -94,12 +94,12 @@ impl<'self> CheckLoanCtxt<'self> {\n             MoveWhileBorrowed(loan_path, loan_span) => {\n                 self.bccx.span_err(\n                     cap_var.span,\n-                    fmt!(\"cannot move `%s` into closure \\\n+                    format!(\"cannot move `{}` into closure \\\n                           because it is borrowed\",\n                          self.bccx.loan_path_to_str(move_path)));\n                 self.bccx.span_note(\n                     loan_span,\n-                    fmt!(\"borrow of `%s` occurs here\",\n+                    format!(\"borrow of `{}` occurs here\",\n                          self.bccx.loan_path_to_str(loan_path)));\n             }\n         }\n@@ -197,10 +197,10 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! issued when we enter `scope_id` (for example, we do not\n         //! permit two `&mut` borrows of the same variable).\n \n-        debug!(\"check_for_conflicting_loans(scope_id=%?)\", scope_id);\n+        debug2!(\"check_for_conflicting_loans(scope_id={:?})\", scope_id);\n \n         let new_loan_indices = self.loans_generated_by(scope_id);\n-        debug!(\"new_loan_indices = %?\", new_loan_indices);\n+        debug2!(\"new_loan_indices = {:?}\", new_loan_indices);\n \n         do self.each_issued_loan(scope_id) |issued_loan| {\n             for &new_loan_index in new_loan_indices.iter() {\n@@ -225,7 +225,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! Checks whether `old_loan` and `new_loan` can safely be issued\n         //! simultaneously.\n \n-        debug!(\"report_error_if_loans_conflict(old_loan=%s, new_loan=%s)\",\n+        debug2!(\"report_error_if_loans_conflict(old_loan={}, new_loan={})\",\n                old_loan.repr(self.tcx()),\n                new_loan.repr(self.tcx()));\n \n@@ -249,8 +249,8 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! Checks whether the restrictions introduced by `loan1` would\n         //! prohibit `loan2`. Returns false if an error is reported.\n \n-        debug!(\"report_error_if_loan_conflicts_with_restriction(\\\n-                loan1=%s, loan2=%s)\",\n+        debug2!(\"report_error_if_loan_conflicts_with_restriction(\\\n+                loan1={}, loan2={})\",\n                loan1.repr(self.tcx()),\n                loan2.repr(self.tcx()));\n \n@@ -260,7 +260,7 @@ impl<'self> CheckLoanCtxt<'self> {\n             ImmutableMutability => RESTR_ALIAS | RESTR_FREEZE,\n             ConstMutability     => RESTR_ALIAS,\n         };\n-        debug!(\"illegal_if=%?\", illegal_if);\n+        debug2!(\"illegal_if={:?}\", illegal_if);\n \n         for restr in loan1.restrictions.iter() {\n             if !restr.set.intersects(illegal_if) { loop; }\n@@ -270,27 +270,27 @@ impl<'self> CheckLoanCtxt<'self> {\n                 (MutableMutability, MutableMutability) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        fmt!(\"cannot borrow `%s` as mutable \\\n+                        format!(\"cannot borrow `{}` as mutable \\\n                               more than once at a time\",\n                              self.bccx.loan_path_to_str(new_loan.loan_path)));\n                     self.bccx.span_note(\n                         old_loan.span,\n-                        fmt!(\"second borrow of `%s` as mutable occurs here\",\n+                        format!(\"second borrow of `{}` as mutable occurs here\",\n                              self.bccx.loan_path_to_str(new_loan.loan_path)));\n                     return false;\n                 }\n \n                 _ => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        fmt!(\"cannot borrow `%s` as %s because \\\n-                              it is also borrowed as %s\",\n+                        format!(\"cannot borrow `{}` as {} because \\\n+                              it is also borrowed as {}\",\n                              self.bccx.loan_path_to_str(new_loan.loan_path),\n                              self.bccx.mut_to_str(new_loan.mutbl),\n                              self.bccx.mut_to_str(old_loan.mutbl)));\n                     self.bccx.span_note(\n                         old_loan.span,\n-                        fmt!(\"second borrow of `%s` occurs here\",\n+                        format!(\"second borrow of `{}` occurs here\",\n                              self.bccx.loan_path_to_str(new_loan.loan_path)));\n                     return false;\n                 }\n@@ -317,7 +317,7 @@ impl<'self> CheckLoanCtxt<'self> {\n          * is using a moved/uninitialized value\n          */\n \n-        debug!(\"check_if_path_is_moved(id=%?, use_kind=%?, lp=%s)\",\n+        debug2!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={})\",\n                id, use_kind, lp.repr(self.bccx.tcx));\n         do self.move_data.each_move_of(id, lp) |move, moved_lp| {\n             self.bccx.report_use_of_moved_value(\n@@ -338,7 +338,7 @@ impl<'self> CheckLoanCtxt<'self> {\n             Some(&adj) => self.bccx.cat_expr_autoderefd(expr, adj)\n         };\n \n-        debug!(\"check_assignment(cmt=%s)\", cmt.repr(self.tcx()));\n+        debug2!(\"check_assignment(cmt={})\", cmt.repr(self.tcx()));\n \n         // Mutable values can be assigned, as long as they obey loans\n         // and aliasing restrictions:\n@@ -372,7 +372,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         // Otherwise, just a plain error.\n         self.bccx.span_err(\n             expr.span,\n-            fmt!(\"cannot assign to %s %s\",\n+            format!(\"cannot assign to {} {}\",\n                  cmt.mutbl.to_user_str(),\n                  self.bccx.cmt_to_str(cmt)));\n         return;\n@@ -387,7 +387,7 @@ impl<'self> CheckLoanCtxt<'self> {\n \n             let mut cmt = cmt;\n             loop {\n-                debug!(\"mark_writes_through_upvars_as_used_mut(cmt=%s)\",\n+                debug2!(\"mark_writes_through_upvars_as_used_mut(cmt={})\",\n                        cmt.repr(this.tcx()));\n                 match cmt.cat {\n                     mc::cat_local(id) |\n@@ -435,7 +435,7 @@ impl<'self> CheckLoanCtxt<'self> {\n             //! Safety checks related to writes to aliasable, mutable locations\n \n             let guarantor = cmt.guarantor();\n-            debug!(\"check_for_aliasable_mutable_writes(cmt=%s, guarantor=%s)\",\n+            debug2!(\"check_for_aliasable_mutable_writes(cmt={}, guarantor={})\",\n                    cmt.repr(this.tcx()), guarantor.repr(this.tcx()));\n             match guarantor.cat {\n                 mc::cat_deref(b, _, mc::region_ptr(MutMutable, _)) => {\n@@ -451,7 +451,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                         id: guarantor.id,\n                         derefs: deref_count\n                     };\n-                    debug!(\"Inserting write guard at %?\", key);\n+                    debug2!(\"Inserting write guard at {:?}\", key);\n                     this.bccx.write_guard_map.insert(key);\n                 }\n \n@@ -646,11 +646,11 @@ impl<'self> CheckLoanCtxt<'self> {\n                                    loan: &Loan) {\n         self.bccx.span_err(\n             expr.span,\n-            fmt!(\"cannot assign to `%s` because it is borrowed\",\n+            format!(\"cannot assign to `{}` because it is borrowed\",\n                  self.bccx.loan_path_to_str(loan_path)));\n         self.bccx.span_note(\n             loan.span,\n-            fmt!(\"borrow of `%s` occurs here\",\n+            format!(\"borrow of `{}` occurs here\",\n                  self.bccx.loan_path_to_str(loan_path)));\n     }\n \n@@ -674,12 +674,12 @@ impl<'self> CheckLoanCtxt<'self> {\n                 MoveWhileBorrowed(loan_path, loan_span) => {\n                     self.bccx.span_err(\n                         span,\n-                        fmt!(\"cannot move out of `%s` \\\n+                        format!(\"cannot move out of `{}` \\\n                               because it is borrowed\",\n                              self.bccx.loan_path_to_str(move_path)));\n                     self.bccx.span_note(\n                         loan_span,\n-                        fmt!(\"borrow of `%s` occurs here\",\n+                        format!(\"borrow of `{}` occurs here\",\n                              self.bccx.loan_path_to_str(loan_path)));\n                 }\n             }\n@@ -690,7 +690,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     pub fn analyze_move_out_from(&self,\n                                  expr_id: ast::NodeId,\n                                  move_path: @LoanPath) -> MoveError {\n-        debug!(\"analyze_move_out_from(expr_id=%?, move_path=%s)\",\n+        debug2!(\"analyze_move_out_from(expr_id={:?}, move_path={})\",\n                expr_id, move_path.repr(self.tcx()));\n \n         // FIXME(#4384) inadequare if/when we permit `move a.b`\n@@ -772,12 +772,12 @@ fn check_loans_in_fn<'a>(this: &mut CheckLoanCtxt<'a>,\n                 MoveWhileBorrowed(loan_path, loan_span) => {\n                     this.bccx.span_err(\n                         cap_var.span,\n-                        fmt!(\"cannot move `%s` into closure \\\n+                        format!(\"cannot move `{}` into closure \\\n                               because it is borrowed\",\n                              this.bccx.loan_path_to_str(move_path)));\n                     this.bccx.span_note(\n                         loan_span,\n-                        fmt!(\"borrow of `%s` occurs here\",\n+                        format!(\"borrow of `{}` occurs here\",\n                              this.bccx.loan_path_to_str(loan_path)));\n                 }\n             }\n@@ -794,7 +794,7 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n                            expr: @ast::Expr) {\n     visit::walk_expr(this, expr, ());\n \n-    debug!(\"check_loans_in_expr(expr=%s)\",\n+    debug2!(\"check_loans_in_expr(expr={})\",\n            expr.repr(this.tcx()));\n \n     this.check_for_conflicting_loans(expr.id);\n@@ -805,7 +805,7 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n       ast::ExprPath(*) => {\n           if !this.move_data.is_assignee(expr.id) {\n               let cmt = this.bccx.cat_expr_unadjusted(expr);\n-              debug!(\"path cmt=%s\", cmt.repr(this.tcx()));\n+              debug2!(\"path cmt={}\", cmt.repr(this.tcx()));\n               let r = opt_loan_path(cmt);\n               for &lp in r.iter() {\n                   this.check_if_path_is_moved(expr.id, expr.span, MovedInUse, lp);"}, {"sha": "a6db028a4919ba0a504d16e3533eef7aa0441792", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -105,7 +105,7 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n         mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n             bccx.span_err(\n                 cmt0.span,\n-                fmt!(\"cannot move out of %s\",\n+                format!(\"cannot move out of {}\",\n                      bccx.cmt_to_str(cmt)));\n             false\n         }\n@@ -120,7 +120,7 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n             };\n             bccx.span_err(\n                 cmt0.span,\n-                fmt!(\"cannot move out of %s%s\", bccx.cmt_to_str(cmt), once_hint));\n+                format!(\"cannot move out of {}{}\", bccx.cmt_to_str(cmt), once_hint));\n             false\n         }\n \n@@ -158,7 +158,7 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n                     if ty::has_dtor(bccx.tcx, did) {\n                         bccx.span_err(\n                             cmt0.span,\n-                            fmt!(\"cannot move out of type `%s`, \\\n+                            format!(\"cannot move out of type `{}`, \\\n                                   which defines the `Drop` trait\",\n                                  b.ty.user_string(bccx.tcx)));\n                         false"}, {"sha": "485004a642cfbcce25a8911ecfd476e50d06f6e6", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -27,7 +27,7 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n                           cmt: mc::cmt,\n                           loan_region: ty::Region,\n                           loan_mutbl: LoanMutability) {\n-    debug!(\"guarantee_lifetime(cmt=%s, loan_region=%s)\",\n+    debug2!(\"guarantee_lifetime(cmt={}, loan_region={})\",\n            cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n                                          item_scope_id: item_scope_id,\n@@ -101,7 +101,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                     // L-Deref-Managed-Mut-Compiler-Root\n                     self.check_root(cmt, base, derefs, ptr_mutbl, discr_scope);\n                 } else {\n-                    debug!(\"omitting root, base=%s, base_scope=%?\",\n+                    debug2!(\"omitting root, base={}, base_scope={:?}\",\n                            base.repr(self.tcx()), base_scope);\n                 }\n             }\n@@ -189,8 +189,8 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                   derefs: uint,\n                   ptr_mutbl: ast::Mutability,\n                   discr_scope: Option<ast::NodeId>) {\n-        debug!(\"check_root(cmt_deref=%s, cmt_base=%s, derefs=%?, ptr_mutbl=%?, \\\n-                discr_scope=%?)\",\n+        debug2!(\"check_root(cmt_deref={}, cmt_base={}, derefs={:?}, ptr_mutbl={:?}, \\\n+                discr_scope={:?})\",\n                cmt_deref.repr(self.tcx()),\n                cmt_base.repr(self.tcx()),\n                derefs,\n@@ -213,7 +213,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                 // the check above should fail for anything is not re_scope\n                 self.bccx.tcx.sess.span_bug(\n                     cmt_base.span,\n-                    fmt!(\"Cannot issue root for scope region: %?\",\n+                    format!(\"Cannot issue root for scope region: {:?}\",\n                          self.loan_region));\n             }\n         };\n@@ -247,16 +247,16 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n         // FIXME(#3511) grow to the nearest cleanup scope---this can\n         // cause observable errors if freezing!\n         if !self.bccx.tcx.region_maps.is_cleanup_scope(root_scope) {\n-            debug!(\"%? is not a cleanup scope, adjusting\", root_scope);\n+            debug2!(\"{:?} is not a cleanup scope, adjusting\", root_scope);\n \n             let cleanup_scope =\n                 self.bccx.tcx.region_maps.cleanup_scope(root_scope);\n \n             if opt_dyna.is_some() {\n                 self.tcx().sess.span_warn(\n                     self.span,\n-                    fmt!(\"Dynamic freeze scope artifically extended \\\n-                          (see Issue #6248)\"));\n+                    format!(\"Dynamic freeze scope artifically extended \\\n+                          (see Issue \\\\#6248)\"));\n                 note_and_explain_region(\n                     self.bccx.tcx,\n                     \"managed value only needs to be frozen for \",\n@@ -277,7 +277,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n         let root_info = RootInfo {scope: root_scope, freeze: opt_dyna};\n         self.bccx.root_map.insert(rm_key, root_info);\n \n-        debug!(\"root_key: %? root_info: %?\", rm_key, root_info);\n+        debug2!(\"root_key: {:?} root_info: {:?}\", rm_key, root_info);\n     }\n \n     fn check_scope(&self, max_scope: ty::Region) {\n@@ -310,7 +310,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n             r @ mc::cat_discr(*) => {\n                 self.tcx().sess.span_bug(\n                     cmt.span,\n-                    fmt!(\"illegal guarantor category: %?\", r));\n+                    format!(\"illegal guarantor category: {:?}\", r));\n             }\n         }\n     }"}, {"sha": "b3980c2e045b93de80165c693921b761ea1cf797", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -136,7 +136,7 @@ fn gather_loans_in_fn(this: &mut GatherLoanCtxt,\n                       id: ast::NodeId) {\n     match fk {\n         &visit::fk_item_fn(*) | &visit::fk_method(*) => {\n-            fail!(\"cannot occur, due to visit_item override\");\n+            fail2!(\"cannot occur, due to visit_item override\");\n         }\n \n         // Visit closures as part of the containing item.\n@@ -196,7 +196,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n     let bccx = this.bccx;\n     let tcx = bccx.tcx;\n \n-    debug!(\"gather_loans_in_expr(expr=%?/%s)\",\n+    debug2!(\"gather_loans_in_expr(expr={:?}/{})\",\n            ex.id, pprust::expr_to_str(ex, tcx.sess.intr()));\n \n     this.id_range.add(ex.id);\n@@ -330,20 +330,20 @@ impl<'self> GatherLoanCtxt<'self> {\n     pub fn guarantee_adjustments(&mut self,\n                                  expr: @ast::Expr,\n                                  adjustment: &ty::AutoAdjustment) {\n-        debug!(\"guarantee_adjustments(expr=%s, adjustment=%?)\",\n+        debug2!(\"guarantee_adjustments(expr={}, adjustment={:?})\",\n                expr.repr(self.tcx()), adjustment);\n         let _i = indenter();\n \n         match *adjustment {\n             ty::AutoAddEnv(*) => {\n-                debug!(\"autoaddenv -- no autoref\");\n+                debug2!(\"autoaddenv -- no autoref\");\n                 return;\n             }\n \n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n                     autoref: None, _ }) => {\n-                debug!(\"no autoref\");\n+                debug2!(\"no autoref\");\n                 return;\n             }\n \n@@ -355,7 +355,7 @@ impl<'self> GatherLoanCtxt<'self> {\n                     tcx: self.tcx(),\n                     method_map: self.bccx.method_map};\n                 let cmt = mcx.cat_expr_autoderefd(expr, autoderefs);\n-                debug!(\"after autoderef, cmt=%s\", cmt.repr(self.tcx()));\n+                debug2!(\"after autoderef, cmt={}\", cmt.repr(self.tcx()));\n \n                 match *autoref {\n                     ty::AutoPtr(r, m) => {\n@@ -412,8 +412,8 @@ impl<'self> GatherLoanCtxt<'self> {\n                            cmt: mc::cmt,\n                            req_mutbl: LoanMutability,\n                            loan_region: ty::Region) {\n-        debug!(\"guarantee_valid(borrow_id=%?, cmt=%s, \\\n-                req_mutbl=%?, loan_region=%?)\",\n+        debug2!(\"guarantee_valid(borrow_id={:?}, cmt={}, \\\n+                req_mutbl={:?}, loan_region={:?})\",\n                borrow_id,\n                cmt.repr(self.tcx()),\n                req_mutbl,\n@@ -470,16 +470,16 @@ impl<'self> GatherLoanCtxt<'self> {\n                     ty::re_infer(*) => {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n-                            fmt!(\"Invalid borrow lifetime: %?\", loan_region));\n+                            format!(\"Invalid borrow lifetime: {:?}\", loan_region));\n                     }\n                 };\n-                debug!(\"loan_scope = %?\", loan_scope);\n+                debug2!(\"loan_scope = {:?}\", loan_scope);\n \n                 let gen_scope = self.compute_gen_scope(borrow_id, loan_scope);\n-                debug!(\"gen_scope = %?\", gen_scope);\n+                debug2!(\"gen_scope = {:?}\", gen_scope);\n \n                 let kill_scope = self.compute_kill_scope(loan_scope, loan_path);\n-                debug!(\"kill_scope = %?\", kill_scope);\n+                debug2!(\"kill_scope = {:?}\", kill_scope);\n \n                 if req_mutbl == MutableMutability {\n                     self.mark_loan_path_as_mutated(loan_path);\n@@ -499,7 +499,7 @@ impl<'self> GatherLoanCtxt<'self> {\n             }\n         };\n \n-        debug!(\"guarantee_valid(borrow_id=%?), loan=%s\",\n+        debug2!(\"guarantee_valid(borrow_id={:?}), loan={}\",\n                borrow_id, loan.repr(self.tcx()));\n \n         // let loan_path = loan.loan_path;\n@@ -785,7 +785,7 @@ impl<'self> GatherLoanCtxt<'self> {\n             _ => {\n                 self.tcx().sess.span_bug(\n                     pat.span,\n-                    fmt!(\"Type of slice pattern is not a slice\"));\n+                    format!(\"Type of slice pattern is not a slice\"));\n             }\n         }\n     }"}, {"sha": "f2bfc6fb4ec2e4ba8828420834774177af348a43", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -117,7 +117,7 @@ pub fn check_crate(\n     fn make_stat(bccx: &mut BorrowckCtxt, stat: uint) -> ~str {\n         let stat_f = stat as float;\n         let total = bccx.stats.guaranteed_paths as float;\n-        fmt!(\"%u (%.0f%%)\", stat  , stat_f * 100f / total)\n+        format!(\"{} ({:.0f}%)\", stat  , stat_f * 100f / total)\n     }\n }\n \n@@ -135,7 +135,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n \n         &visit::fk_item_fn(*) |\n         &visit::fk_method(*) => {\n-            debug!(\"borrowck_fn(id=%?)\", id);\n+            debug2!(\"borrowck_fn(id={:?})\", id);\n \n             // Check the body of fn items.\n             let (id_range, all_loans, move_data) =\n@@ -561,15 +561,15 @@ impl BorrowckCtxt {\n             move_data::Declared => {\n                 self.tcx.sess.span_err(\n                     use_span,\n-                    fmt!(\"%s of possibly uninitialized value: `%s`\",\n+                    format!(\"{} of possibly uninitialized value: `{}`\",\n                          verb,\n                          self.loan_path_to_str(lp)));\n             }\n             _ => {\n                 let partially = if lp == moved_lp {\"\"} else {\"partially \"};\n                 self.tcx.sess.span_err(\n                     use_span,\n-                    fmt!(\"%s of %smoved value: `%s`\",\n+                    format!(\"{} of {}moved value: `{}`\",\n                          verb,\n                          partially,\n                          self.loan_path_to_str(lp)));\n@@ -585,7 +585,7 @@ impl BorrowckCtxt {\n                         \"moved by default (use `copy` to override)\");\n                 self.tcx.sess.span_note(\n                     expr.span,\n-                    fmt!(\"`%s` moved here because it has type `%s`, which is %s\",\n+                    format!(\"`{}` moved here because it has type `{}`, which is {}\",\n                          self.loan_path_to_str(moved_lp),\n                          expr_ty.user_string(self.tcx), suggestion));\n             }\n@@ -594,7 +594,7 @@ impl BorrowckCtxt {\n                 let pat_ty = ty::node_id_to_type(self.tcx, pat.id);\n                 self.tcx.sess.span_note(\n                     pat.span,\n-                    fmt!(\"`%s` moved here because it has type `%s`, \\\n+                    format!(\"`{}` moved here because it has type `{}`, \\\n                           which is moved by default (use `ref` to override)\",\n                          self.loan_path_to_str(moved_lp),\n                          pat_ty.user_string(self.tcx)));\n@@ -607,8 +607,8 @@ impl BorrowckCtxt {\n                          capture that instead to override)\");\n                 self.tcx.sess.span_note(\n                     expr.span,\n-                    fmt!(\"`%s` moved into closure environment here because it \\\n-                          has type `%s`, which is %s\",\n+                    format!(\"`{}` moved into closure environment here because it \\\n+                          has type `{}`, which is {}\",\n                          self.loan_path_to_str(moved_lp),\n                          expr_ty.user_string(self.tcx), suggestion));\n             }\n@@ -634,11 +634,11 @@ impl BorrowckCtxt {\n                                                 &move_data::Assignment) {\n         self.tcx.sess.span_err(\n             span,\n-            fmt!(\"re-assignment of immutable variable `%s`\",\n+            format!(\"re-assignment of immutable variable `{}`\",\n                  self.loan_path_to_str(lp)));\n         self.tcx.sess.span_note(\n             assign.span,\n-            fmt!(\"prior assignment occurs here\"));\n+            format!(\"prior assignment occurs here\"));\n     }\n \n     pub fn span_err(&self, s: Span, m: &str) {\n@@ -652,23 +652,23 @@ impl BorrowckCtxt {\n     pub fn bckerr_to_str(&self, err: BckError) -> ~str {\n         match err.code {\n             err_mutbl(lk) => {\n-                fmt!(\"cannot borrow %s %s as %s\",\n+                format!(\"cannot borrow {} {} as {}\",\n                      err.cmt.mutbl.to_user_str(),\n                      self.cmt_to_str(err.cmt),\n                      self.mut_to_str(lk))\n             }\n             err_out_of_root_scope(*) => {\n-                fmt!(\"cannot root managed value long enough\")\n+                format!(\"cannot root managed value long enough\")\n             }\n             err_out_of_scope(*) => {\n-                fmt!(\"borrowed value does not live long enough\")\n+                format!(\"borrowed value does not live long enough\")\n             }\n             err_freeze_aliasable_const => {\n                 // Means that the user borrowed a ~T or enum value\n                 // residing in &const or @const pointer.  Terrible\n                 // error message, but then &const and @const are\n                 // supposed to be going away.\n-                fmt!(\"unsafe borrow of aliasable, const value\")\n+                format!(\"unsafe borrow of aliasable, const value\")\n             }\n         }\n     }\n@@ -686,27 +686,27 @@ impl BorrowckCtxt {\n             mc::AliasableOther => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    fmt!(\"%s in an aliasable location\", prefix));\n+                    format!(\"{} in an aliasable location\", prefix));\n             }\n             mc::AliasableManaged(ast::MutMutable) => {\n                 // FIXME(#6269) reborrow @mut to &mut\n                 self.tcx.sess.span_err(\n                     span,\n-                    fmt!(\"%s in a `@mut` pointer; \\\n+                    format!(\"{} in a `@mut` pointer; \\\n                           try borrowing as `&mut` first\", prefix));\n             }\n             mc::AliasableManaged(m) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    fmt!(\"%s in a `@%s` pointer; \\\n+                    format!(\"{} in a `@{}` pointer; \\\n                           try an `@mut` instead\",\n                          prefix,\n                          self.mut_to_keyword(m)));\n             }\n             mc::AliasableBorrowed(m) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    fmt!(\"%s in a `&%s` pointer; \\\n+                    format!(\"{} in a `&{}` pointer; \\\n                           try an `&mut` instead\",\n                          prefix,\n                          self.mut_to_keyword(m)));\n@@ -774,7 +774,7 @@ impl BorrowckCtxt {\n                     }\n                     r => {\n                         self.tcx.sess.bug(\n-                            fmt!(\"Loan path LpVar(%?) maps to %?, not local\",\n+                            format!(\"Loan path LpVar({:?}) maps to {:?}, not local\",\n                                  id, r));\n                     }\n                 }\n@@ -849,7 +849,7 @@ impl DataFlowOperator for LoanDataFlowOperator {\n \n impl Repr for Loan {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n-        fmt!(\"Loan_%?(%s, %?, %?-%?, %s)\",\n+        format!(\"Loan_{:?}({}, {:?}, {:?}-{:?}, {})\",\n              self.index,\n              self.loan_path.repr(tcx),\n              self.mutbl,\n@@ -861,7 +861,7 @@ impl Repr for Loan {\n \n impl Repr for Restriction {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n-        fmt!(\"Restriction(%s, %x)\",\n+        format!(\"Restriction({}, {:x})\",\n              self.loan_path.repr(tcx),\n              self.set.bits as uint)\n     }\n@@ -871,15 +871,15 @@ impl Repr for LoanPath {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match self {\n             &LpVar(id) => {\n-                fmt!(\"$(%?)\", id)\n+                format!(\"$({:?})\", id)\n             }\n \n             &LpExtend(lp, _, LpDeref(_)) => {\n-                fmt!(\"%s.*\", lp.repr(tcx))\n+                format!(\"{}.*\", lp.repr(tcx))\n             }\n \n             &LpExtend(lp, _, LpInterior(ref interior)) => {\n-                fmt!(\"%s.%s\", lp.repr(tcx), interior.repr(tcx))\n+                format!(\"{}.{}\", lp.repr(tcx), interior.repr(tcx))\n             }\n         }\n     }"}, {"sha": "239254e82dd5232b6ccba407aa2ff4bc77761b6e", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -244,7 +244,7 @@ impl MoveData {\n             }\n         };\n \n-        debug!(\"move_path(lp=%s, index=%?)\",\n+        debug2!(\"move_path(lp={}, index={:?})\",\n                lp.repr(tcx),\n                index);\n \n@@ -304,7 +304,7 @@ impl MoveData {\n          * location `id` with kind `kind`.\n          */\n \n-        debug!(\"add_move(lp=%s, id=%?, kind=%?)\",\n+        debug2!(\"add_move(lp={}, id={:?}, kind={:?})\",\n                lp.repr(tcx),\n                id,\n                kind);\n@@ -334,7 +334,7 @@ impl MoveData {\n          * location `id` with the given `span`.\n          */\n \n-        debug!(\"add_assignment(lp=%s, assign_id=%?, assignee_id=%?\",\n+        debug2!(\"add_assignment(lp={}, assign_id={:?}, assignee_id={:?}\",\n                lp.repr(tcx), assign_id, assignee_id);\n \n         let path_index = self.move_path(tcx, lp);\n@@ -348,12 +348,12 @@ impl MoveData {\n         };\n \n         if self.is_var_path(path_index) {\n-            debug!(\"add_assignment[var](lp=%s, assignment=%u, path_index=%?)\",\n+            debug2!(\"add_assignment[var](lp={}, assignment={}, path_index={:?})\",\n                    lp.repr(tcx), self.var_assignments.len(), path_index);\n \n             self.var_assignments.push(assignment);\n         } else {\n-            debug!(\"add_assignment[path](lp=%s, path_index=%?)\",\n+            debug2!(\"add_assignment[path](lp={}, path_index={:?})\",\n                    lp.repr(tcx), path_index);\n \n             self.path_assignments.push(assignment);"}, {"sha": "9e92bd3829c5da59568b98c853f437fc97aed1da", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -239,7 +239,7 @@ impl CFGBuilder {\n                 expr_exit\n             }\n \n-            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n \n             ast::ExprLoop(ref body, _) => {\n                 //\n@@ -504,13 +504,13 @@ impl CFGBuilder {\n                         }\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            fmt!(\"No loop scope for id %?\", loop_id));\n+                            format!(\"No loop scope for id {:?}\", loop_id));\n                     }\n \n                     r => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            fmt!(\"Bad entry `%?` in def_map for label\", r));\n+                            format!(\"Bad entry `{:?}` in def_map for label\", r));\n                     }\n                 }\n             }"}, {"sha": "30cf827cb72cfc9551c6994f659c583666c342f2", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -153,7 +153,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n               Some(&DefStruct(_)) => { }\n \n               Some(&def) => {\n-                debug!(\"(checking const) found bad def: %?\", def);\n+                debug2!(\"(checking const) found bad def: {:?}\", def);\n                 sess.span_err(\n                     e.span,\n                     \"paths in constants may only refer to \\\n@@ -266,7 +266,7 @@ impl Visitor<()> for CheckItemRecursionVisitor {\n                         ast_map::node_item(it, _) => {\n                             self.visit_item(it, ());\n                         }\n-                        _ => fail!(\"const not bound to an item\")\n+                        _ => fail2!(\"const not bound to an item\")\n                     },\n                 _ => ()\n             },"}, {"sha": "8befb42f300e2898d9c9251329416812a1c52f2c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -86,8 +86,8 @@ pub fn check_expr(v: &mut CheckMatchVisitor,\n        if (*arms).is_empty() {\n            if !type_is_empty(cx.tcx, pat_ty) {\n                // We know the type is inhabited, so this must be wrong\n-               cx.tcx.sess.span_err(ex.span, fmt!(\"non-exhaustive patterns: \\\n-                            type %s is non-empty\",\n+               cx.tcx.sess.span_err(ex.span, format!(\"non-exhaustive patterns: \\\n+                            type {} is non-empty\",\n                             ty_to_str(cx.tcx, pat_ty)));\n            }\n            // If the type *is* empty, it's vacuously exhaustive\n@@ -180,20 +180,20 @@ pub fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n                 ty::ty_enum(id, _) => {\n                     let vid = match *ctor {\n                         variant(id) => id,\n-                        _ => fail!(\"check_exhaustive: non-variant ctor\"),\n+                        _ => fail2!(\"check_exhaustive: non-variant ctor\"),\n                     };\n                     let variants = ty::enum_variants(cx.tcx, id);\n \n                     match variants.iter().find(|v| v.id == vid) {\n                         Some(v) => Some(cx.tcx.sess.str_of(v.name)),\n                         None => {\n-                            fail!(\"check_exhaustive: bad variant in ctor\")\n+                            fail2!(\"check_exhaustive: bad variant in ctor\")\n                         }\n                     }\n                 }\n                 ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n                     match *ctor {\n-                        vec(n) => Some(fmt!(\"vectors of length %u\", n).to_managed()),\n+                        vec(n) => Some(format!(\"vectors of length {}\", n).to_managed()),\n                         _ => None\n                     }\n                 }\n@@ -202,7 +202,7 @@ pub fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n         }\n     };\n     let msg = ~\"non-exhaustive patterns\" + match ext {\n-        Some(ref s) => fmt!(\": %s not covered\",  *s),\n+        Some(ref s) => format!(\": {} not covered\",  *s),\n         None => ~\"\"\n     };\n     cx.tcx.sess.span_err(sp, msg);\n@@ -408,7 +408,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n                     return Some(variant(v.id));\n                 }\n             }\n-            fail!();\n+            fail2!();\n         } else { None }\n       }\n       ty::ty_nil => None,\n@@ -420,7 +420,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n               None => (),\n               Some(val(const_bool(true))) => true_found = true,\n               Some(val(const_bool(false))) => false_found = true,\n-              _ => fail!(\"impossible case\")\n+              _ => fail2!(\"impossible case\")\n             }\n         }\n         if true_found && false_found { None }\n@@ -510,10 +510,10 @@ pub fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n       ty::ty_enum(eid, _) => {\n           let id = match *ctor { variant(id) => id,\n-          _ => fail!(\"impossible case\") };\n+          _ => fail2!(\"impossible case\") };\n         match ty::enum_variants(cx.tcx, eid).iter().find(|v| v.id == id ) {\n             Some(v) => v.args.len(),\n-            None => fail!(\"impossible case\")\n+            None => fail2!(\"impossible case\")\n         }\n       }\n       ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n@@ -584,7 +584,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                                 }\n                             }\n                             single => true,\n-                            _ => fail!(\"type error\")\n+                            _ => fail2!(\"type error\")\n                         };\n                         if match_ {\n                             Some(r.tail().to_owned())\n@@ -631,7 +631,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                                 }\n                             }\n                             single => true,\n-                            _ => fail!(\"type error\")\n+                            _ => fail2!(\"type error\")\n                         };\n                         if match_ {\n                             Some(r.tail().to_owned())\n@@ -693,7 +693,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                             _ => {\n                                 cx.tcx.sess.span_bug(\n                                     pat_span,\n-                                    fmt!(\"struct pattern resolved to %s, \\\n+                                    format!(\"struct pattern resolved to {}, \\\n                                           not a struct\",\n                                          ty_to_str(cx.tcx, left_ty)));\n                             }\n@@ -739,7 +739,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                         }\n                     }\n                     single => true,\n-                    _ => fail!(\"type error\")\n+                    _ => fail2!(\"type error\")\n                 };\n                 if match_ { Some(r.tail().to_owned()) } else { None }\n             }\n@@ -748,7 +748,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                     val(ref v) => (*v, *v),\n                     range(ref lo, ref hi) => (*lo, *hi),\n                     single => return Some(r.tail().to_owned()),\n-                    _ => fail!(\"type error\")\n+                    _ => fail2!(\"type error\")\n                 };\n                 let v_lo = eval_const_expr(cx.tcx, lo);\n                 let v_hi = eval_const_expr(cx.tcx, hi);\n@@ -929,8 +929,8 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     _ => {\n                         cx.tcx.sess.span_bug(\n                             p.span,\n-                            fmt!(\"Binding pattern %d is \\\n-                                  not an identifier: %?\",\n+                            format!(\"Binding pattern {} is \\\n+                                  not an identifier: {:?}\",\n                                  p.id, p.node));\n                     }\n                 }"}, {"sha": "b9355d326637726985783cb2b6955a48cc62e4fb", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -103,20 +103,20 @@ impl<O:DataFlowOperator> pprust::pp_ann for DataFlowContext<O> {\n \n             let gens = self.gens.slice(start, end);\n             let gens_str = if gens.iter().any(|&u| u != 0) {\n-                fmt!(\" gen: %s\", bits_to_str(gens))\n+                format!(\" gen: {}\", bits_to_str(gens))\n             } else {\n                 ~\"\"\n             };\n \n             let kills = self.kills.slice(start, end);\n             let kills_str = if kills.iter().any(|&u| u != 0) {\n-                fmt!(\" kill: %s\", bits_to_str(kills))\n+                format!(\" kill: {}\", bits_to_str(kills))\n             } else {\n                 ~\"\"\n             };\n \n-            let comment_str = fmt!(\"id %d: %s%s%s\",\n-                                   id, entry_str, gens_str, kills_str);\n+            let comment_str = format!(\"id {}: {}{}{}\",\n+                                      id, entry_str, gens_str, kills_str);\n             pprust::synth_comment(ps, comment_str);\n             pp::space(ps.s);\n         }\n@@ -131,7 +131,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                bits_per_id: uint) -> DataFlowContext<O> {\n         let words_per_id = (bits_per_id + uint::bits - 1) / uint::bits;\n \n-        debug!(\"DataFlowContext::new(id_range=%?, bits_per_id=%?, words_per_id=%?)\",\n+        debug2!(\"DataFlowContext::new(id_range={:?}, bits_per_id={:?}, words_per_id={:?})\",\n                id_range, bits_per_id, words_per_id);\n \n         let gens = ~[];\n@@ -154,7 +154,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     pub fn add_gen(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` generates `bit`\n \n-        debug!(\"add_gen(id=%?, bit=%?)\", id, bit);\n+        debug2!(\"add_gen(id={:?}, bit={:?})\", id, bit);\n         let (start, end) = self.compute_id_range(id);\n         {\n             let gens = self.gens.mut_slice(start, end);\n@@ -165,7 +165,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` kills `bit`\n \n-        debug!(\"add_kill(id=%?, bit=%?)\", id, bit);\n+        debug2!(\"add_kill(id={:?}, bit={:?})\", id, bit);\n         let (start, end) = self.compute_id_range(id);\n         {\n             let kills = self.kills.mut_slice(start, end);\n@@ -176,25 +176,25 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     fn apply_gen_kill(&mut self, id: ast::NodeId, bits: &mut [uint]) {\n         //! Applies the gen and kill sets for `id` to `bits`\n \n-        debug!(\"apply_gen_kill(id=%?, bits=%s) [before]\",\n+        debug2!(\"apply_gen_kill(id={:?}, bits={}) [before]\",\n                id, mut_bits_to_str(bits));\n         let (start, end) = self.compute_id_range(id);\n         let gens = self.gens.slice(start, end);\n         bitwise(bits, gens, |a, b| a | b);\n         let kills = self.kills.slice(start, end);\n         bitwise(bits, kills, |a, b| a & !b);\n \n-        debug!(\"apply_gen_kill(id=%?, bits=%s) [after]\",\n+        debug2!(\"apply_gen_kill(id={:?}, bits={}) [after]\",\n                id, mut_bits_to_str(bits));\n     }\n \n     fn apply_kill(&mut self, id: ast::NodeId, bits: &mut [uint]) {\n-        debug!(\"apply_kill(id=%?, bits=%s) [before]\",\n+        debug2!(\"apply_kill(id={:?}, bits={}) [before]\",\n                id, mut_bits_to_str(bits));\n         let (start, end) = self.compute_id_range(id);\n         let kills = self.kills.slice(start, end);\n         bitwise(bits, kills, |a, b| a & !b);\n-        debug!(\"apply_kill(id=%?, bits=%s) [after]\",\n+        debug2!(\"apply_kill(id={:?}, bits={}) [after]\",\n                id, mut_bits_to_str(bits));\n     }\n \n@@ -242,7 +242,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         }\n         let (start, end) = self.compute_id_range_frozen(id);\n         let on_entry = self.on_entry.slice(start, end);\n-        debug!(\"each_bit_on_entry_frozen(id=%?, on_entry=%s)\",\n+        debug2!(\"each_bit_on_entry_frozen(id={:?}, on_entry={})\",\n                id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f)\n     }\n@@ -255,7 +255,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n \n         let (start, end) = self.compute_id_range(id);\n         let on_entry = self.on_entry.slice(start, end);\n-        debug!(\"each_bit_on_entry(id=%?, on_entry=%s)\",\n+        debug2!(\"each_bit_on_entry(id={:?}, on_entry={})\",\n                id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f)\n     }\n@@ -267,7 +267,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n \n         let (start, end) = self.compute_id_range(id);\n         let gens = self.gens.slice(start, end);\n-        debug!(\"each_gen_bit(id=%?, gens=%s)\",\n+        debug2!(\"each_gen_bit(id={:?}, gens={})\",\n                id, bits_to_str(gens));\n         self.each_bit(gens, f)\n     }\n@@ -281,7 +281,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         }\n         let (start, end) = self.compute_id_range_frozen(id);\n         let gens = self.gens.slice(start, end);\n-        debug!(\"each_gen_bit(id=%?, gens=%s)\",\n+        debug2!(\"each_gen_bit(id={:?}, gens={})\",\n                id, bits_to_str(gens));\n         self.each_bit(gens, f)\n     }\n@@ -346,8 +346,8 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n             }\n         }\n \n-        debug!(\"Dataflow result:\");\n-        debug!(\"%s\", {\n+        debug2!(\"Dataflow result:\");\n+        debug2!(\"{}\", {\n             let this = @(*self).clone();\n             this.pretty_print_to(io::stderr(), blk);\n             \"\"\n@@ -374,7 +374,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                   blk: &ast::Block,\n                   in_out: &mut [uint],\n                   loop_scopes: &mut ~[LoopScope]) {\n-        debug!(\"DataFlowContext::walk_block(blk.id=%?, in_out=%s)\",\n+        debug2!(\"DataFlowContext::walk_block(blk.id={:?}, in_out={})\",\n                blk.id, bits_to_str(reslice(in_out)));\n \n         self.merge_with_entry_set(blk.id, in_out);\n@@ -425,7 +425,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                  expr: &ast::Expr,\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n-        debug!(\"DataFlowContext::walk_expr(expr=%s, in_out=%s)\",\n+        debug2!(\"DataFlowContext::walk_expr(expr={}, in_out={})\",\n                expr.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n \n         self.merge_with_entry_set(expr.id, in_out);\n@@ -569,7 +569,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 copy_bits(new_loop_scope.break_bits, in_out);\n             }\n \n-            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n \n             ast::ExprLoop(ref blk, _) => {\n                 //\n@@ -756,7 +756,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         let tcx = self.tcx();\n         let region_maps = tcx.region_maps;\n \n-        debug!(\"pop_scopes(from_expr=%s, to_scope=%?, in_out=%s)\",\n+        debug2!(\"pop_scopes(from_expr={}, to_scope={:?}, in_out={})\",\n                from_expr.repr(tcx), to_scope.loop_id,\n                bits_to_str(reslice(in_out)));\n \n@@ -769,7 +769,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 None => {\n                     tcx.sess.span_bug(\n                         from_expr.span,\n-                        fmt!(\"pop_scopes(from_expr=%s, to_scope=%?) \\\n+                        format!(\"pop_scopes(from_expr={}, to_scope={:?}) \\\n                               to_scope does not enclose from_expr\",\n                              from_expr.repr(tcx), to_scope.loop_id));\n                 }\n@@ -784,7 +784,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         self.pop_scopes(from_expr, to_scope, in_out);\n         self.dfcx.apply_kill(from_expr.id, in_out);\n         join_bits(&self.dfcx.oper, reslice(in_out), to_scope.break_bits);\n-        debug!(\"break_from_to(from_expr=%s, to_scope=%?) final break_bits=%s\",\n+        debug2!(\"break_from_to(from_expr={}, to_scope={:?}) final break_bits={}\",\n                from_expr.repr(self.tcx()),\n                to_scope.loop_id,\n                bits_to_str(reslice(in_out)));\n@@ -833,11 +833,11 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 pat: @ast::Pat,\n                 in_out: &mut [uint],\n                 _loop_scopes: &mut ~[LoopScope]) {\n-        debug!(\"DataFlowContext::walk_pat(pat=%s, in_out=%s)\",\n+        debug2!(\"DataFlowContext::walk_pat(pat={}, in_out={})\",\n                pat.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n \n         do ast_util::walk_pat(pat) |p| {\n-            debug!(\"  p.id=%? in_out=%s\", p.id, bits_to_str(reslice(in_out)));\n+            debug2!(\"  p.id={:?} in_out={}\", p.id, bits_to_str(reslice(in_out)));\n             self.merge_with_entry_set(p.id, in_out);\n             self.dfcx.apply_gen_kill(p.id, in_out);\n             true\n@@ -882,15 +882,15 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                             None => {\n                                 self.tcx().sess.span_bug(\n                                     expr.span,\n-                                    fmt!(\"No loop scope for id %?\", loop_id));\n+                                    format!(\"No loop scope for id {:?}\", loop_id));\n                             }\n                         }\n                     }\n \n                     r => {\n                         self.tcx().sess.span_bug(\n                             expr.span,\n-                            fmt!(\"Bad entry `%?` in def_map for label\", r));\n+                            format!(\"Bad entry `{:?}` in def_map for label\", r));\n                     }\n                 }\n             }\n@@ -909,15 +909,15 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn add_to_entry_set(&mut self, id: ast::NodeId, pred_bits: &[uint]) {\n-        debug!(\"add_to_entry_set(id=%?, pred_bits=%s)\",\n+        debug2!(\"add_to_entry_set(id={:?}, pred_bits={})\",\n                id, bits_to_str(pred_bits));\n         let (start, end) = self.dfcx.compute_id_range(id);\n         let changed = { // FIXME(#5074) awkward construction\n             let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n             join_bits(&self.dfcx.oper, pred_bits, on_entry)\n         };\n         if changed {\n-            debug!(\"changed entry set for %? to %s\",\n+            debug2!(\"changed entry set for {:?} to {}\",\n                    id, bits_to_str(self.dfcx.on_entry.slice(start, end)));\n             self.changed = true;\n         }\n@@ -926,7 +926,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     fn merge_with_entry_set(&mut self,\n                             id: ast::NodeId,\n                             pred_bits: &mut [uint]) {\n-        debug!(\"merge_with_entry_set(id=%?, pred_bits=%s)\",\n+        debug2!(\"merge_with_entry_set(id={:?}, pred_bits={})\",\n                id, mut_bits_to_str(pred_bits));\n         let (start, end) = self.dfcx.compute_id_range(id);\n         let changed = { // FIXME(#5074) awkward construction\n@@ -936,7 +936,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             changed\n         };\n         if changed {\n-            debug!(\"changed entry set for %? to %s\",\n+            debug2!(\"changed entry set for {:?} to {}\",\n                    id, bits_to_str(self.dfcx.on_entry.slice(start, end)));\n             self.changed = true;\n         }\n@@ -957,7 +957,7 @@ fn bits_to_str(words: &[uint]) -> ~str {\n         let mut v = word;\n         for _ in range(0u, uint::bytes) {\n             result.push_char(sep);\n-            result.push_str(fmt!(\"%02x\", v & 0xFF));\n+            result.push_str(format!(\"{:02x}\", v & 0xFF));\n             v >>= 8;\n             sep = '-';\n         }\n@@ -992,12 +992,12 @@ fn bitwise(out_vec: &mut [uint],\n }\n \n fn set_bit(words: &mut [uint], bit: uint) -> bool {\n-    debug!(\"set_bit: words=%s bit=%s\",\n+    debug2!(\"set_bit: words={} bit={}\",\n            mut_bits_to_str(words), bit_str(bit));\n     let word = bit / uint::bits;\n     let bit_in_word = bit % uint::bits;\n     let bit_mask = 1 << bit_in_word;\n-    debug!(\"word=%u bit_in_word=%u bit_mask=%u\", word, bit_in_word, word);\n+    debug2!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, word);\n     let oldv = words[word];\n     let newv = oldv | bit_mask;\n     words[word] = newv;\n@@ -1007,7 +1007,7 @@ fn set_bit(words: &mut [uint], bit: uint) -> bool {\n fn bit_str(bit: uint) -> ~str {\n     let byte = bit >> 8;\n     let lobits = 1 << (bit & 0xFF);\n-    fmt!(\"[%u:%u-%02x]\", bit, byte, lobits)\n+    format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n }\n \n fn reslice<'a>(v: &'a mut [uint]) -> &'a [uint] {"}, {"sha": "6d479ca220a06e8b1c4762391127b092029de6ae", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -58,12 +58,12 @@ impl EffectCheckVisitor {\n             SafeContext => {\n                 // Report an error.\n                 self.tcx.sess.span_err(span,\n-                                  fmt!(\"%s requires unsafe function or block\",\n+                                  format!(\"{} requires unsafe function or block\",\n                                        description))\n             }\n             UnsafeBlock(block_id) => {\n                 // OK, but record this.\n-                debug!(\"effect: recording unsafe block as used: %?\", block_id);\n+                debug2!(\"effect: recording unsafe block as used: {:?}\", block_id);\n                 let _ = self.tcx.used_unsafe.insert(block_id);\n             }\n             UnsafeFn => {}\n@@ -119,7 +119,7 @@ impl Visitor<()> for EffectCheckVisitor {\n             match expr.node {\n                 ExprMethodCall(callee_id, _, _, _, _, _) => {\n                     let base_type = ty::node_id_to_type(self.tcx, callee_id);\n-                    debug!(\"effect: method call case, base type is %s\",\n+                    debug2!(\"effect: method call case, base type is {}\",\n                            ppaux::ty_to_str(self.tcx, base_type));\n                     if type_is_unsafe_function(base_type) {\n                         self.require_unsafe(expr.span,\n@@ -128,15 +128,15 @@ impl Visitor<()> for EffectCheckVisitor {\n                 }\n                 ExprCall(base, _, _) => {\n                     let base_type = ty::node_id_to_type(self.tcx, base.id);\n-                    debug!(\"effect: call case, base type is %s\",\n+                    debug2!(\"effect: call case, base type is {}\",\n                            ppaux::ty_to_str(self.tcx, base_type));\n                     if type_is_unsafe_function(base_type) {\n                         self.require_unsafe(expr.span, \"call to unsafe function\")\n                     }\n                 }\n                 ExprUnary(_, UnDeref, base) => {\n                     let base_type = ty::node_id_to_type(self.tcx, base.id);\n-                    debug!(\"effect: unary case, base type is %s\",\n+                    debug2!(\"effect: unary case, base type is {}\",\n                            ppaux::ty_to_str(self.tcx, base_type));\n                     match ty::get(base_type).sty {\n                         ty_ptr(_) => {"}, {"sha": "383c37952d7a7984252a6f8fd3347d44ee7abfa5", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -53,7 +53,7 @@ impl Visitor<int> for CollectFreevarsVisitor {\n               ast::ExprPath(*) | ast::ExprSelf => {\n                   let mut i = 0;\n                   match self.def_map.find(&expr.id) {\n-                    None => fail!(\"path not found\"),\n+                    None => fail2!(\"path not found\"),\n                     Some(&df) => {\n                       let mut def = df;\n                       while i < depth {\n@@ -137,7 +137,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: &ast::Crate) ->\n \n pub fn get_freevars(tcx: ty::ctxt, fid: ast::NodeId) -> freevar_info {\n     match tcx.freevars.find(&fid) {\n-      None => fail!(\"get_freevars: %d has no freevars\", fid),\n+      None => fail2!(\"get_freevars: {} has no freevars\", fid),\n       Some(&d) => return d\n     }\n }"}, {"sha": "98912b57572a61abf68f8be73bd909a7b498b1d3", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -343,7 +343,7 @@ mod test {\n         do graph.each_incoming_edge(start_index) |edge_index, edge| {\n             assert_eq!(graph.edge_data(edge_index), &edge.data);\n             assert!(counter < expected_incoming.len());\n-            debug!(\"counter=%? expected=%? edge_index=%? edge=%?\",\n+            debug2!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                    counter, expected_incoming[counter], edge_index, edge);\n             match expected_incoming[counter] {\n                 (ref e, ref n) => {\n@@ -361,7 +361,7 @@ mod test {\n         do graph.each_outgoing_edge(start_index) |edge_index, edge| {\n             assert_eq!(graph.edge_data(edge_index), &edge.data);\n             assert!(counter < expected_outgoing.len());\n-            debug!(\"counter=%? expected=%? edge_index=%? edge=%?\",\n+            debug2!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                    counter, expected_outgoing[counter], edge_index, edge);\n             match expected_outgoing[counter] {\n                 (ref e, ref n) => {"}, {"sha": "b20cb8ed809b95de49c56a6cf29c88b0b9823aab", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -124,13 +124,13 @@ fn check_impl_of_trait(cx: &mut Context, it: @item, trait_ref: &trait_ref, self_\n \n     // If this trait has builtin-kind supertraits, meet them.\n     let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n-    debug!(\"checking impl with self type %?\", ty::get(self_ty).sty);\n+    debug2!(\"checking impl with self type {:?}\", ty::get(self_ty).sty);\n     do check_builtin_bounds(cx, self_ty, trait_def.bounds) |missing| {\n         cx.tcx.sess.span_err(self_type.span,\n-            fmt!(\"the type `%s', which does not fulfill `%s`, cannot implement this \\\n+            format!(\"the type `{}', which does not fulfill `{}`, cannot implement this \\\n                   trait\", ty_to_str(cx.tcx, self_ty), missing.user_string(cx.tcx)));\n         cx.tcx.sess.span_note(self_type.span,\n-            fmt!(\"types implementing this trait must fulfill `%s`\",\n+            format!(\"types implementing this trait must fulfill `{}`\",\n                  trait_def.bounds.user_string(cx.tcx)));\n     }\n \n@@ -238,7 +238,7 @@ fn with_appropriate_checker(cx: &Context, id: NodeId,\n         }\n         ref s => {\n             cx.tcx.sess.bug(\n-                fmt!(\"expect fn type in kind checker, not %?\", s));\n+                format!(\"expect fn type in kind checker, not {:?}\", s));\n         }\n     }\n }\n@@ -265,7 +265,7 @@ fn check_fn(\n }\n \n pub fn check_expr(cx: &mut Context, e: @Expr) {\n-    debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n+    debug2!(\"kind::check_expr({})\", expr_to_str(e, cx.tcx.sess.intr()));\n \n     // Handle any kind bounds on type parameters\n     let type_parameter_id = match e.get_callee_id() {\n@@ -292,9 +292,9 @@ pub fn check_expr(cx: &mut Context, e: @Expr) {\n             };\n             if ts.len() != type_param_defs.len() {\n                 // Fail earlier to make debugging easier\n-                fail!(\"internal error: in kind::check_expr, length \\\n+                fail2!(\"internal error: in kind::check_expr, length \\\n                       mismatch between actual and declared bounds: actual = \\\n-                      %s, declared = %s\",\n+                      {}, declared = {}\",\n                       ts.repr(cx.tcx),\n                       type_param_defs.repr(cx.tcx));\n             }\n@@ -375,8 +375,8 @@ pub fn check_typaram_bounds(cx: &Context,\n     do check_builtin_bounds(cx, ty, type_param_def.bounds.builtin_bounds) |missing| {\n         cx.tcx.sess.span_err(\n             sp,\n-            fmt!(\"instantiating a type parameter with an incompatible type \\\n-                  `%s`, which does not fulfill `%s`\",\n+            format!(\"instantiating a type parameter with an incompatible type \\\n+                  `{}`, which does not fulfill `{}`\",\n                  ty_to_str(cx.tcx, ty),\n                  missing.user_string(cx.tcx)));\n     }\n@@ -390,17 +390,17 @@ pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n         // Emit a less mysterious error message in this case.\n         match referenced_ty {\n             Some(rty) => cx.tcx.sess.span_err(sp,\n-                fmt!(\"cannot implicitly borrow variable of type `%s` in a bounded \\\n-                      stack closure (implicit reference does not fulfill `%s`)\",\n+                format!(\"cannot implicitly borrow variable of type `{}` in a bounded \\\n+                      stack closure (implicit reference does not fulfill `{}`)\",\n                      ty_to_str(cx.tcx, rty), missing.user_string(cx.tcx))),\n             None => cx.tcx.sess.span_err(sp,\n-                fmt!(\"cannot capture variable of type `%s`, which does \\\n-                      not fulfill `%s`, in a bounded closure\",\n+                format!(\"cannot capture variable of type `{}`, which does \\\n+                      not fulfill `{}`, in a bounded closure\",\n                      ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx))),\n         }\n         cx.tcx.sess.span_note(\n             sp,\n-            fmt!(\"this closure's environment must satisfy `%s`\",\n+            format!(\"this closure's environment must satisfy `{}`\",\n                  bounds.user_string(cx.tcx)));\n     }\n }\n@@ -409,8 +409,8 @@ pub fn check_trait_cast_bounds(cx: &Context, sp: Span, ty: ty::t,\n                                bounds: ty::BuiltinBounds) {\n     do check_builtin_bounds(cx, ty, bounds) |missing| {\n         cx.tcx.sess.span_err(sp,\n-            fmt!(\"cannot pack type `%s`, which does not fulfill \\\n-                  `%s`, as a trait bounded by %s\",\n+            format!(\"cannot pack type `{}`, which does not fulfill \\\n+                  `{}`, as a trait bounded by {}\",\n                  ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx),\n                  bounds.user_string(cx.tcx)));\n     }\n@@ -445,27 +445,27 @@ fn check_imm_free_var(cx: &Context, def: Def, sp: Span) {\n         _ => {\n             cx.tcx.sess.span_bug(\n                 sp,\n-                fmt!(\"unknown def for free variable: %?\", def));\n+                format!(\"unknown def for free variable: {:?}\", def));\n         }\n     }\n }\n \n fn check_copy(cx: &Context, ty: ty::t, sp: Span, reason: &str) {\n-    debug!(\"type_contents(%s)=%s\",\n+    debug2!(\"type_contents({})={}\",\n            ty_to_str(cx.tcx, ty),\n            ty::type_contents(cx.tcx, ty).to_str());\n     if ty::type_moves_by_default(cx.tcx, ty) {\n         cx.tcx.sess.span_err(\n-            sp, fmt!(\"copying a value of non-copyable type `%s`\",\n+            sp, format!(\"copying a value of non-copyable type `{}`\",\n                      ty_to_str(cx.tcx, ty)));\n-        cx.tcx.sess.span_note(sp, fmt!(\"%s\", reason));\n+        cx.tcx.sess.span_note(sp, format!(\"{}\", reason));\n     }\n }\n \n pub fn check_send(cx: &Context, ty: ty::t, sp: Span) -> bool {\n     if !ty::type_is_sendable(cx.tcx, ty) {\n         cx.tcx.sess.span_err(\n-            sp, fmt!(\"value has non-sendable type `%s`\",\n+            sp, format!(\"value has non-sendable type `{}`\",\n                      ty_to_str(cx.tcx, ty)));\n         false\n     } else {\n@@ -565,8 +565,8 @@ pub fn check_cast_for_escaping_regions(\n             // if !target_regions.iter().any(|t_r| is_subregion_of(cx, *t_r, r)) {\n             //     cx.tcx.sess.span_err(\n             //         source.span,\n-            //         fmt!(\"source contains borrowed pointer with lifetime \\\n-            //               not found in the target type `%s`\",\n+            //         format!(\"source contains borrowed pointer with lifetime \\\n+            //               not found in the target type `{}`\",\n             //              ty_to_str(cx.tcx, target_ty)));\n             //     note_and_explain_region(\n             //         cx.tcx, \"source data is only valid for \", r, \"\");"}, {"sha": "f154255e7b6f21bf8712ef5335442ba7bc7da487", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -154,7 +154,7 @@ impl LanguageItems {\n     pub fn require(&self, it: LangItem) -> Result<DefId, ~str> {\n         match self.items[it as uint] {\n             Some(id) => Ok(id),\n-            None => Err(fmt!(\"requires `%s` lang_item\",\n+            None => Err(format!(\"requires `{}` lang_item\",\n                              LanguageItems::item_name(it as uint)))\n         }\n     }\n@@ -398,7 +398,7 @@ impl<'self> LanguageItemCollector<'self> {\n         // Check for duplicates.\n         match self.items.items[item_index] {\n             Some(original_def_id) if original_def_id != item_def_id => {\n-                self.session.err(fmt!(\"duplicate entry for `%s`\",\n+                self.session.err(format!(\"duplicate entry for `{}`\",\n                                       LanguageItems::item_name(item_index)));\n             }\n             Some(_) | None => {"}, {"sha": "591ca2ada5a12c65d56f40beb218413a8fbb424d", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -430,7 +430,7 @@ impl Context {\n                 return *k;\n             }\n         }\n-        fail!(\"unregistered lint %?\", lint);\n+        fail2!(\"unregistered lint {:?}\", lint);\n     }\n \n     fn span_lint(&self, lint: lint, span: Span, msg: &str) {\n@@ -444,9 +444,9 @@ impl Context {\n         let mut note = None;\n         let msg = match src {\n             Default | CommandLine => {\n-                fmt!(\"%s [-%c %s%s]\", msg, match level {\n+                format!(\"{} [-{} {}{}]\", msg, match level {\n                         warn => 'W', deny => 'D', forbid => 'F',\n-                        allow => fail!()\n+                        allow => fail2!()\n                     }, self.lint_to_str(lint).replace(\"_\", \"-\"),\n                     if src == Default { \" (default)\" } else { \"\" })\n             },\n@@ -458,7 +458,7 @@ impl Context {\n         match level {\n             warn =>          { self.tcx.sess.span_warn(span, msg); }\n             deny | forbid => { self.tcx.sess.span_err(span, msg);  }\n-            allow => fail!(),\n+            allow => fail2!(),\n         }\n \n         for &span in note.iter() {\n@@ -483,15 +483,15 @@ impl Context {\n                     self.span_lint(\n                         unrecognized_lint,\n                         meta.span,\n-                        fmt!(\"unknown `%s` attribute: `%s`\",\n+                        format!(\"unknown `{}` attribute: `{}`\",\n                         level_to_str(level), lintname));\n                 }\n                 Some(lint) => {\n                     let lint = lint.lint;\n                     let now = self.get_level(lint);\n                     if now == forbid && level != forbid {\n                         self.tcx.sess.span_err(meta.span,\n-                        fmt!(\"%s(%s) overruled by outer forbid(%s)\",\n+                        format!(\"{}({}) overruled by outer forbid({})\",\n                         level_to_str(level),\n                         lintname, lintname));\n                     } else if now != level {\n@@ -757,7 +757,7 @@ impl TypeLimitsLintVisitor {\n             ast::BiGt => v >= min,\n             ast::BiGe => v > min,\n             ast::BiEq | ast::BiNe => v >= min && v <= max,\n-            _ => fail!()\n+            _ => fail2!()\n         }\n     }\n \n@@ -821,7 +821,7 @@ impl TypeLimitsLintVisitor {\n                         ast::lit_int_unsuffixed(v) => v,\n                         _ => return true\n                     },\n-                    _ => fail!()\n+                    _ => fail2!()\n                 };\n                 self.is_valid(norm_binop, lit_val, min, max)\n             }\n@@ -834,7 +834,7 @@ impl TypeLimitsLintVisitor {\n                         ast::lit_int_unsuffixed(v) => v as u64,\n                         _ => return true\n                     },\n-                    _ => fail!()\n+                    _ => fail2!()\n                 };\n                 self.is_valid(norm_binop, lit_val, min, max)\n             }\n@@ -1071,7 +1071,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n         if !is_camel_case(cx.tcx, ident) {\n             cx.span_lint(\n                 non_camel_case_types, span,\n-                fmt!(\"%s `%s` should have a camel case identifier\",\n+                format!(\"{} `{}` should have a camel case identifier\",\n                     sort, cx.tcx.sess.str_of(ident)));\n         }\n     }\n@@ -1437,7 +1437,7 @@ impl StabilityLintVisitor {\n                         None => return\n                     }\n                 }\n-                _ => cx.tcx.sess.bug(fmt!(\"handle_def: %? not found\", id))\n+                _ => cx.tcx.sess.bug(format!(\"handle_def: {:?} not found\", id))\n             }\n         } else {\n             // cross-crate\n@@ -1466,9 +1466,9 @@ impl StabilityLintVisitor {\n \n         let msg = match stability {\n             Some(attr::Stability { text: Some(ref s), _ }) => {\n-                fmt!(\"use of %s item: %s\", label, *s)\n+                format!(\"use of {} item: {}\", label, *s)\n             }\n-            _ => fmt!(\"use of %s item\", label)\n+            _ => format!(\"use of {} item\", label)\n         };\n \n         cx.span_lint(lint, sp, msg);\n@@ -1613,8 +1613,8 @@ pub fn check_crate(tcx: ty::ctxt, crate: &ast::Crate) {\n         for t in v.iter() {\n             match *t {\n                 (lint, span, ref msg) =>\n-                    tcx.sess.span_bug(span, fmt!(\"unprocessed lint %? at %s: \\\n-                                                  %s\",\n+                    tcx.sess.span_bug(span, format!(\"unprocessed lint {:?} at {}: \\\n+                                                  {}\",\n                                                  lint,\n                                                  ast_map::node_id_to_str(\n                                                  tcx.items,"}, {"sha": "e9119e75287a3d96994a5672e60f2435114ea960", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -144,9 +144,9 @@ enum LiveNodeKind {\n fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n     let cm = cx.sess.codemap;\n     match lnk {\n-        FreeVarNode(s) => fmt!(\"Free var node [%s]\", cm.span_to_str(s)),\n-        ExprNode(s)    => fmt!(\"Expr node [%s]\", cm.span_to_str(s)),\n-        VarDefNode(s)  => fmt!(\"Var def node [%s]\", cm.span_to_str(s)),\n+        FreeVarNode(s) => format!(\"Free var node [{}]\", cm.span_to_str(s)),\n+        ExprNode(s)    => format!(\"Expr node [{}]\", cm.span_to_str(s)),\n+        VarDefNode(s)  => format!(\"Var def node [{}]\", cm.span_to_str(s)),\n         ExitNode       => ~\"Exit node\"\n     }\n }\n@@ -176,11 +176,11 @@ pub fn check_crate(tcx: ty::ctxt,\n }\n \n impl to_str::ToStr for LiveNode {\n-    fn to_str(&self) -> ~str { fmt!(\"ln(%u)\", **self) }\n+    fn to_str(&self) -> ~str { format!(\"ln({})\", **self) }\n }\n \n impl to_str::ToStr for Variable {\n-    fn to_str(&self) -> ~str { fmt!(\"v(%u)\", **self) }\n+    fn to_str(&self) -> ~str { format!(\"v({})\", **self) }\n }\n \n // ______________________________________________________________________\n@@ -276,7 +276,7 @@ impl IrMaps {\n         self.lnks.push(lnk);\n         self.num_live_nodes += 1;\n \n-        debug!(\"%s is of kind %s\", ln.to_str(),\n+        debug2!(\"{} is of kind {}\", ln.to_str(),\n                live_node_kind_to_str(lnk, self.tcx));\n \n         ln\n@@ -288,7 +288,7 @@ impl IrMaps {\n         let ln = self.add_live_node(lnk);\n         self.live_node_map.insert(node_id, ln);\n \n-        debug!(\"%s is node %d\", ln.to_str(), node_id);\n+        debug2!(\"{} is node {}\", ln.to_str(), node_id);\n     }\n \n     pub fn add_variable(&mut self, vk: VarKind) -> Variable {\n@@ -303,7 +303,7 @@ impl IrMaps {\n             ImplicitRet => {}\n         }\n \n-        debug!(\"%s is %?\", v.to_str(), vk);\n+        debug2!(\"{} is {:?}\", v.to_str(), vk);\n \n         v\n     }\n@@ -313,7 +313,7 @@ impl IrMaps {\n           Some(&var) => var,\n           None => {\n             self.tcx.sess.span_bug(\n-                span, fmt!(\"No variable registered for id %d\", node_id));\n+                span, format!(\"No variable registered for id {}\", node_id));\n           }\n         }\n     }\n@@ -367,7 +367,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n             sp: Span,\n             id: NodeId,\n             this: @mut IrMaps) {\n-    debug!(\"visit_fn: id=%d\", id);\n+    debug2!(\"visit_fn: id={}\", id);\n     let _i = ::util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n@@ -376,13 +376,13 @@ fn visit_fn(v: &mut LivenessVisitor,\n                               this.capture_map);\n \n     unsafe {\n-        debug!(\"creating fn_maps: %x\", transmute(&*fn_maps));\n+        debug2!(\"creating fn_maps: {}\", transmute::<&IrMaps, *IrMaps>(fn_maps));\n     }\n \n     for arg in decl.inputs.iter() {\n         do pat_util::pat_bindings(this.tcx.def_map, arg.pat)\n                 |_bm, arg_id, _x, path| {\n-            debug!(\"adding argument %d\", arg_id);\n+            debug2!(\"adding argument {}\", arg_id);\n             let ident = ast_util::path_to_ident(path);\n             fn_maps.add_variable(Arg(arg_id, ident));\n         }\n@@ -429,7 +429,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.pat) |_bm, p_id, sp, path| {\n-        debug!(\"adding local variable %d\", p_id);\n+        debug2!(\"adding local variable {}\", p_id);\n         let name = ast_util::path_to_ident(path);\n         this.add_live_node_for_node(p_id, VarDefNode(sp));\n         let kind = match local.init {\n@@ -450,7 +450,7 @@ fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n     for pat in arm.pats.iter() {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n-            debug!(\"adding local variable %d from match with bm %?\",\n+            debug2!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = ast_util::path_to_ident(path);\n             this.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -470,7 +470,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: @Expr, this: @mut IrMaps) {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) | ExprSelf => {\n         let def = this.tcx.def_map.get_copy(&expr.id);\n-        debug!(\"expr %d: path that leads to %?\", expr.id, def);\n+        debug2!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if moves::moved_variable_node_id_from_def(def).is_some() {\n             this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n@@ -515,7 +515,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: @Expr, this: @mut IrMaps) {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(v, expr, this);\n       }\n-      ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+      ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n       ExprBinary(_, op, _, _) if ast_util::lazy_binop(op) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(v, expr, this);\n@@ -609,7 +609,7 @@ impl Liveness {\n             // code have to agree about which AST nodes are worth\n             // creating liveness nodes for.\n             self.tcx.sess.span_bug(\n-                span, fmt!(\"No live node registered for node %d\",\n+                span, format!(\"No live node registered for node {}\",\n                            node_id));\n           }\n         }\n@@ -788,7 +788,7 @@ impl Liveness {\n             wr.write_str(\"[ln(\");\n             wr.write_uint(*ln);\n             wr.write_str(\") of kind \");\n-            wr.write_str(fmt!(\"%?\", self.ir.lnks[*ln]));\n+            wr.write_str(format!(\"{:?}\", self.ir.lnks[*ln]));\n             wr.write_str(\" reads\");\n             self.write_vars(wr, ln, |idx| self.users[idx].reader );\n             wr.write_str(\"  writes\");\n@@ -819,7 +819,7 @@ impl Liveness {\n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n             self.users[idx] = self.users[succ_idx]\n         });\n-        debug!(\"init_from_succ(ln=%s, succ=%s)\",\n+        debug2!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n     }\n \n@@ -843,7 +843,7 @@ impl Liveness {\n             }\n         }\n \n-        debug!(\"merge_from_succ(ln=%s, succ=%s, first_merge=%b, changed=%b)\",\n+        debug2!(\"merge_from_succ(ln={}, succ={}, first_merge={}, changed={})\",\n                ln.to_str(), self.ln_str(succ_ln), first_merge, changed);\n         return changed;\n \n@@ -866,7 +866,7 @@ impl Liveness {\n         self.users[idx].reader = invalid_node();\n         self.users[idx].writer = invalid_node();\n \n-        debug!(\"%s defines %s (idx=%u): %s\", writer.to_str(), var.to_str(),\n+        debug2!(\"{} defines {} (idx={}): {}\", writer.to_str(), var.to_str(),\n                idx, self.ln_str(writer));\n     }\n \n@@ -891,7 +891,7 @@ impl Liveness {\n             user.used = true;\n         }\n \n-        debug!(\"%s accesses[%x] %s: %s\",\n+        debug2!(\"{} accesses[{:x}] {}: {}\",\n                ln.to_str(), acc, var.to_str(), self.ln_str(ln));\n     }\n \n@@ -902,18 +902,18 @@ impl Liveness {\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n \n-        debug!(\"compute: using id for block, %s\", block_to_str(body,\n+        debug2!(\"compute: using id for block, {}\", block_to_str(body,\n                       self.tcx.sess.intr()));\n \n         let entry_ln: LiveNode =\n             self.with_loop_nodes(body.id, self.s.exit_ln, self.s.exit_ln,\n               || { self.propagate_through_fn_block(decl, body) });\n \n-        // hack to skip the loop unless debug! is enabled:\n-        debug!(\"^^ liveness computation results for body %d (entry=%s)\",\n+        // hack to skip the loop unless debug2! is enabled:\n+        debug2!(\"^^ liveness computation results for body {} (entry={})\",\n                {\n                    for ln_idx in range(0u, self.ir.num_live_nodes) {\n-                       debug!(\"%s\", self.ln_str(LiveNode(ln_idx)));\n+                       debug2!(\"{}\", self.ln_str(LiveNode(ln_idx)));\n                    }\n                    body.id\n                },\n@@ -1007,7 +1007,7 @@ impl Liveness {\n \n     pub fn propagate_through_expr(&self, expr: @Expr, succ: LiveNode)\n                                   -> LiveNode {\n-        debug!(\"propagate_through_expr: %s\",\n+        debug2!(\"propagate_through_expr: {}\",\n              expr_to_str(expr, self.tcx.sess.intr()));\n \n         match expr.node {\n@@ -1022,7 +1022,7 @@ impl Liveness {\n           }\n \n           ExprFnBlock(_, ref blk) => {\n-              debug!(\"%s is an expr_fn_block\",\n+              debug2!(\"{} is an expr_fn_block\",\n                    expr_to_str(expr, self.tcx.sess.intr()));\n \n               /*\n@@ -1070,7 +1070,7 @@ impl Liveness {\n             self.propagate_through_loop(expr, Some(cond), blk, succ)\n           }\n \n-          ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+          ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n@@ -1379,7 +1379,7 @@ impl Liveness {\n             self.merge_from_succ(ln, succ, first_merge);\n             first_merge = false;\n         }\n-        debug!(\"propagate_through_loop: using id for loop body %d %s\",\n+        debug2!(\"propagate_through_loop: using id for loop body {} {}\",\n                expr.id, block_to_str(body, self.tcx.sess.intr()));\n \n         let cond_ln = self.propagate_through_opt_expr(cond, ln);\n@@ -1407,7 +1407,7 @@ impl Liveness {\n                               cont_ln: LiveNode,\n                               f: &fn() -> R)\n                               -> R {\n-      debug!(\"with_loop_nodes: %d %u\", loop_node_id, *break_ln);\n+      debug2!(\"with_loop_nodes: {} {}\", loop_node_id, *break_ln);\n         self.loop_scope.push(loop_node_id);\n         self.break_ln.insert(loop_node_id, break_ln);\n         self.cont_ln.insert(loop_node_id, cont_ln);\n@@ -1430,7 +1430,7 @@ fn check_local(this: &mut Liveness, local: @Local) {\n         // No initializer: the variable might be unused; if not, it\n         // should not be live at this point.\n \n-        debug!(\"check_local() with no initializer\");\n+        debug2!(\"check_local() with no initializer\");\n         do this.pat_bindings(local.pat) |ln, var, sp, id| {\n             if !this.warn_about_unused(sp, id, ln, var) {\n                 match this.live_on_exit(ln, var) {\n@@ -1501,7 +1501,7 @@ fn check_expr(this: &mut Liveness, expr: @Expr) {\n       ExprParen(*) | ExprFnBlock(*) | ExprPath(*) | ExprSelf(*) => {\n         visit::walk_expr(this, expr, ());\n       }\n-      ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\")\n+      ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\")\n     }\n }\n \n@@ -1596,17 +1596,17 @@ impl Liveness {\n           FreeVarNode(span) => {\n             self.tcx.sess.span_err(\n                 span,\n-                fmt!(\"capture of %s: `%s`\", msg, name));\n+                format!(\"capture of {}: `{}`\", msg, name));\n           }\n           ExprNode(span) => {\n             self.tcx.sess.span_err(\n                 span,\n-                fmt!(\"use of %s: `%s`\", msg, name));\n+                format!(\"use of {}: `{}`\", msg, name));\n           }\n           ExitNode | VarDefNode(_) => {\n             self.tcx.sess.span_bug(\n                 chk_span,\n-                fmt!(\"illegal reader: %?\", lnk));\n+                format!(\"illegal reader: {:?}\", lnk));\n           }\n         }\n     }\n@@ -1655,11 +1655,11 @@ impl Liveness {\n \n                 if is_assigned {\n                     self.tcx.sess.add_lint(unused_variable, id, sp,\n-                        fmt!(\"variable `%s` is assigned to, \\\n+                        format!(\"variable `{}` is assigned to, \\\n                                   but never used\", *name));\n                 } else {\n                     self.tcx.sess.add_lint(unused_variable, id, sp,\n-                        fmt!(\"unused variable: `%s`\", *name));\n+                        format!(\"unused variable: `{}`\", *name));\n                 }\n             }\n             true\n@@ -1677,7 +1677,7 @@ impl Liveness {\n             let r = self.should_warn(var);\n             for name in r.iter() {\n                 self.tcx.sess.add_lint(dead_assignment, id, sp,\n-                    fmt!(\"value assigned to `%s` is never read\", *name));\n+                    format!(\"value assigned to `{}` is never read\", *name));\n             }\n         }\n     }"}, {"sha": "19be4d041edfd308e31ab7ea33247c1c5fd69311", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -214,7 +214,7 @@ pub fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n       Some(k) => k,\n       None => {\n         tcx.sess.bug(\n-            fmt!(\"deref_cat() invoked on non-derefable type %s\",\n+            format!(\"deref_cat() invoked on non-derefable type {}\",\n                  ty_to_str(tcx, t)));\n       }\n     }\n@@ -288,7 +288,7 @@ pub struct mem_categorization_ctxt {\n \n impl ToStr for MutabilityCategory {\n     fn to_str(&self) -> ~str {\n-        fmt!(\"%?\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n@@ -383,7 +383,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn cat_expr_unadjusted(&self, expr: @ast::Expr) -> cmt {\n-        debug!(\"cat_expr: id=%d expr=%s\",\n+        debug2!(\"cat_expr: id={} expr={}\",\n                expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()));\n \n         let expr_ty = self.expr_ty(expr);\n@@ -436,7 +436,7 @@ impl mem_categorization_ctxt {\n             return self.cat_rvalue_node(expr, expr_ty);\n           }\n \n-          ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\")\n+          ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\")\n         }\n     }\n \n@@ -544,7 +544,7 @@ impl mem_categorization_ctxt {\n                   _ => {\n                       self.tcx.sess.span_bug(\n                           span,\n-                          fmt!(\"Upvar of non-closure %? - %s\",\n+                          format!(\"Upvar of non-closure {:?} - {}\",\n                                fn_node_id, ty.repr(self.tcx)));\n                   }\n               }\n@@ -651,7 +651,7 @@ impl mem_categorization_ctxt {\n             None => {\n                 self.tcx.sess.span_bug(\n                     node.span(),\n-                    fmt!(\"Explicit deref of non-derefable type: %s\",\n+                    format!(\"Explicit deref of non-derefable type: {}\",\n                          ty_to_str(self.tcx, base_cmt.ty)));\n             }\n         };\n@@ -741,7 +741,7 @@ impl mem_categorization_ctxt {\n           None => {\n             self.tcx.sess.span_bug(\n                 elt.span(),\n-                fmt!(\"Explicit index of non-index type `%s`\",\n+                format!(\"Explicit index of non-index type `{}`\",\n                      ty_to_str(self.tcx, base_cmt.ty)));\n           }\n         };\n@@ -872,7 +872,7 @@ impl mem_categorization_ctxt {\n         // get the type of the *subpattern* and use that.\n \n         let tcx = self.tcx;\n-        debug!(\"cat_pattern: id=%d pat=%s cmt=%s\",\n+        debug2!(\"cat_pattern: id={} pat={} cmt={}\",\n                pat.id, pprust::pat_to_str(pat, tcx.sess.intr()),\n                cmt.repr(tcx));\n         let _i = indenter();\n@@ -1020,7 +1020,7 @@ impl mem_categorization_ctxt {\n               ~\"argument\"\n           }\n           cat_deref(_, _, pk) => {\n-              fmt!(\"dereference of %s pointer\", ptr_sigil(pk))\n+              format!(\"dereference of {} pointer\", ptr_sigil(pk))\n           }\n           cat_interior(_, InteriorField(NamedField(_))) => {\n               ~\"field\"\n@@ -1177,7 +1177,7 @@ impl cmt_ {\n \n impl Repr for cmt_ {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n-        fmt!(\"{%s id:%d m:%? ty:%s}\",\n+        format!(\"\\\\{{} id:{} m:{:?} ty:{}\\\\}\",\n              self.cat.repr(tcx),\n              self.id,\n              self.mutbl,\n@@ -1194,19 +1194,19 @@ impl Repr for categorization {\n             cat_local(*) |\n             cat_self(*) |\n             cat_arg(*) => {\n-                fmt!(\"%?\", *self)\n+                format!(\"{:?}\", *self)\n             }\n             cat_deref(cmt, derefs, ptr) => {\n-                fmt!(\"%s->(%s, %u)\", cmt.cat.repr(tcx),\n+                format!(\"{}->({}, {})\", cmt.cat.repr(tcx),\n                      ptr_sigil(ptr), derefs)\n             }\n             cat_interior(cmt, interior) => {\n-                fmt!(\"%s.%s\",\n+                format!(\"{}.{}\",\n                      cmt.cat.repr(tcx),\n                      interior.repr(tcx))\n             }\n             cat_downcast(cmt) => {\n-                fmt!(\"%s->(enum)\", cmt.cat.repr(tcx))\n+                format!(\"{}->(enum)\", cmt.cat.repr(tcx))\n             }\n             cat_stack_upvar(cmt) |\n             cat_discr(cmt, _) => {\n@@ -1229,7 +1229,7 @@ impl Repr for InteriorKind {\n     fn repr(&self, _tcx: ty::ctxt) -> ~str {\n         match *self {\n             InteriorField(NamedField(fld)) => token::interner_get(fld).to_owned(),\n-            InteriorField(PositionalField(i)) => fmt!(\"#%?\", i),\n+            InteriorField(PositionalField(i)) => format!(\"\\\\#{:?}\", i),\n             InteriorElement(_) => ~\"[]\",\n         }\n     }"}, {"sha": "71d0621fc16aefdd8e40390bc5682d2f30833efb", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -275,7 +275,7 @@ impl VisitContext {\n          * meaning either copied or moved depending on its type.\n          */\n \n-        debug!(\"consume_expr(expr=%s)\",\n+        debug2!(\"consume_expr(expr={})\",\n                expr.repr(self.tcx));\n \n         let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n@@ -293,7 +293,7 @@ impl VisitContext {\n          * meaning either copied or moved depending on its type.\n          */\n \n-        debug!(\"consume_block(blk.id=%?)\", blk.id);\n+        debug2!(\"consume_block(blk.id={:?})\", blk.id);\n \n         for stmt in blk.stmts.iter() {\n             self.visit_stmt(*stmt, ());\n@@ -312,7 +312,7 @@ impl VisitContext {\n          * in turn trigger calls to the subcomponents of `expr`.\n          */\n \n-        debug!(\"use_expr(expr=%s, mode=%?)\",\n+        debug2!(\"use_expr(expr={}, mode={:?})\",\n                expr.repr(self.tcx),\n                expr_mode);\n \n@@ -326,7 +326,7 @@ impl VisitContext {\n             _ => expr_mode\n         };\n \n-        debug!(\"comp_mode = %?\", comp_mode);\n+        debug2!(\"comp_mode = {:?}\", comp_mode);\n \n         match expr.node {\n             ExprPath(*) | ExprSelf => {\n@@ -375,7 +375,7 @@ impl VisitContext {\n                     ty::ty_bare_fn(*) => Read,\n                     ref x =>\n                         self.tcx.sess.span_bug(callee.span,\n-                            fmt!(\"non-function type in moves for expr_call: %?\", x)),\n+                            format!(\"non-function type in moves for expr_call: {:?}\", x)),\n                 };\n                 // Note we're not using consume_expr, which uses type_moves_by_default\n                 // to determine the mode, for this. The reason is that while stack\n@@ -411,7 +411,7 @@ impl VisitContext {\n                         ref r => {\n                            self.tcx.sess.span_bug(\n                                 with_expr.span,\n-                                fmt!(\"bad base expr type in record: %?\", r))\n+                                format!(\"bad base expr type in record: {:?}\", r))\n                         }\n                     };\n \n@@ -435,7 +435,7 @@ impl VisitContext {\n                     if consume_with {\n                         if has_dtor(self.tcx, with_ty) {\n                             self.tcx.sess.span_err(with_expr.span,\n-                                                   fmt!(\"cannot move out of type `%s`, \\\n+                                                   format!(\"cannot move out of type `{}`, \\\n                                                          which defines the `Drop` trait\",\n                                                         with_ty.user_string(self.tcx)));\n                         }\n@@ -500,7 +500,7 @@ impl VisitContext {\n                 self.consume_block(blk);\n             }\n \n-            ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n \n             ExprUnary(_, _, lhs) => {\n                 if !self.use_overloaded_operator(expr, lhs, [])\n@@ -620,15 +620,15 @@ impl VisitContext {\n                 BindByRef(_) => false,\n                 BindInfer => {\n                     let pat_ty = ty::node_id_to_type(self.tcx, id);\n-                    debug!(\"pattern %? %s type is %s\",\n+                    debug2!(\"pattern {:?} {} type is {}\",\n                            id,\n                            ast_util::path_to_ident(path).repr(self.tcx),\n                            pat_ty.repr(self.tcx));\n                     ty::type_moves_by_default(self.tcx, pat_ty)\n                 }\n             };\n \n-            debug!(\"pattern binding %?: bm=%?, binding_moves=%b\",\n+            debug2!(\"pattern binding {:?}: bm={:?}, binding_moves={}\",\n                    id, bm, binding_moves);\n \n             if binding_moves {\n@@ -678,7 +678,7 @@ impl VisitContext {\n     }\n \n     pub fn compute_captures(&mut self, fn_expr_id: NodeId) -> @[CaptureVar] {\n-        debug!(\"compute_capture_vars(fn_expr_id=%?)\", fn_expr_id);\n+        debug2!(\"compute_capture_vars(fn_expr_id={:?})\", fn_expr_id);\n         let _indenter = indenter();\n \n         let fn_ty = ty::node_id_to_type(self.tcx, fn_expr_id);\n@@ -696,7 +696,7 @@ impl VisitContext {\n                 let fvar = &freevars[i];\n                 let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n                 let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n-                debug!(\"fvar_def_id=%? fvar_ty=%s\",\n+                debug2!(\"fvar_def_id={:?} fvar_ty={}\",\n                        fvar_def_id, ppaux::ty_to_str(self.tcx, fvar_ty));\n                 let mode = if ty::type_moves_by_default(self.tcx, fvar_ty) {\n                     CapMove"}, {"sha": "8b2e581836bd817171cf947e35c3755d3dffea13", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -111,8 +111,8 @@ impl PrivacyVisitor {\n             // WRONG\n             Public\n         };\n-        debug!(\"parental_privacy = %?\", parental_privacy);\n-        debug!(\"vis = %?, priv = %?\",\n+        debug2!(\"parental_privacy = {:?}\", parental_privacy);\n+        debug2!(\"vis = {:?}, priv = {:?}\",\n                variant_info.vis,\n                visibility_to_privacy(variant_info.vis))\n         // inherited => privacy of the enum item\n@@ -175,7 +175,7 @@ impl PrivacyVisitor {\n             }\n             Some(_) => {\n                 self.tcx.sess.span_bug(span,\n-                                  fmt!(\"method_is_private: method was a %s?!\",\n+                                  format!(\"method_is_private: method was a {}?!\",\n                                        ast_map::node_id_to_str(\n                                             self.tcx.items,\n                                             method_id,\n@@ -205,8 +205,8 @@ impl PrivacyVisitor {\n                 Some(&node_trait_method(_, trait_did, _)) => f(trait_did.node),\n                 Some(_) => {\n                     self.tcx.sess.span_bug(span,\n-                                      fmt!(\"local_item_is_private: item was \\\n-                                            a %s?!\",\n+                                      format!(\"local_item_is_private: item was \\\n+                                            a {}?!\",\n                                            ast_map::node_id_to_str(\n                                                 self.tcx.items,\n                                                 item_id,\n@@ -227,7 +227,7 @@ impl PrivacyVisitor {\n         for field in fields.iter() {\n             if field.name != ident.name { loop; }\n             if field.vis == private {\n-                self.tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n+                self.tcx.sess.span_err(span, format!(\"field `{}` is private\",\n                                              token::ident_to_str(&ident)));\n             }\n             break;\n@@ -248,26 +248,26 @@ impl PrivacyVisitor {\n                     (container_id.crate != LOCAL_CRATE ||\n                      !self.privileged_items.iter().any(|x| x == &(container_id.node))) {\n                 self.tcx.sess.span_err(span,\n-                                  fmt!(\"method `%s` is private\",\n+                                  format!(\"method `{}` is private\",\n                                        token::ident_to_str(name)));\n             }\n         } else {\n             let visibility =\n                 csearch::get_item_visibility(self.tcx.sess.cstore, method_id);\n             if visibility != public {\n                 self.tcx.sess.span_err(span,\n-                                  fmt!(\"method `%s` is private\",\n+                                  format!(\"method `{}` is private\",\n                                        token::ident_to_str(name)));\n             }\n         }\n     }\n \n     // Checks that a private path is in scope.\n     fn check_path(&mut self, span: Span, def: Def, path: &Path) {\n-        debug!(\"checking path\");\n+        debug2!(\"checking path\");\n         match def {\n             DefStaticMethod(method_id, _, _) => {\n-                debug!(\"found static method def, checking it\");\n+                debug2!(\"found static method def, checking it\");\n                 self.check_method_common(span,\n                                          method_id,\n                                          &path.segments.last().identifier)\n@@ -277,7 +277,7 @@ impl PrivacyVisitor {\n                     if self.local_item_is_private(span, def_id.node) &&\n                             !self.privileged_items.iter().any(|x| x == &def_id.node) {\n                         self.tcx.sess.span_err(span,\n-                                          fmt!(\"function `%s` is private\",\n+                                          format!(\"function `{}` is private\",\n                                                token::ident_to_str(\n                                                 &path.segments\n                                                      .last()\n@@ -286,7 +286,7 @@ impl PrivacyVisitor {\n                 //} else if csearch::get_item_visibility(self.tcx.sess.cstore,\n                 //                                       def_id) != public {\n                 //    self.tcx.sess.span_err(span,\n-                //                      fmt!(\"function `%s` is private\",\n+                //                      format!(\"function `{}` is private\",\n                 //                           token::ident_to_str(\n                 //                                &path.segments\n                 //                                     .last()\n@@ -333,7 +333,7 @@ impl PrivacyVisitor {\n                                              !self.privileged_items.iter()\n                                              .any(|x| x == &(trait_id.node)) => {\n                                             self.tcx.sess.span_err(span,\n-                                                              fmt!(\"method `%s` is private\",\n+                                                              format!(\"method `{}` is private\",\n                                                                    token::ident_to_str(&method\n                                                                                         .ident)));\n                                         }\n@@ -476,7 +476,7 @@ impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n                         ty_struct(id, _)\n                         if id.crate != LOCAL_CRATE || !self.privileged_items.iter()\n                                 .any(|x| x == &(id.node)) => {\n-                            debug!(\"(privacy checking) checking field access\");\n+                            debug2!(\"(privacy checking) checking field access\");\n                             self.check_field(expr.span, id, ident);\n                         }\n                         _ => {}\n@@ -497,7 +497,7 @@ impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n                                                        method map\");\n                                 }\n                                 Some(ref entry) => {\n-                                    debug!(\"(privacy checking) checking \\\n+                                    debug2!(\"(privacy checking) checking \\\n                                             impl method\");\n                                     self.check_method(expr.span, &entry.origin, ident);\n                                 }\n@@ -515,7 +515,7 @@ impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n                             if id.crate != LOCAL_CRATE ||\n                                     !self.privileged_items.iter().any(|x| x == &(id.node)) {\n                                 for field in (*fields).iter() {\n-                                        debug!(\"(privacy checking) checking \\\n+                                        debug2!(\"(privacy checking) checking \\\n                                                 field in struct literal\");\n                                     self.check_field(expr.span, id, field.ident);\n                                 }\n@@ -527,7 +527,7 @@ impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n                                 match self.tcx.def_map.get_copy(&expr.id) {\n                                     DefVariant(_, variant_id, _) => {\n                                         for field in (*fields).iter() {\n-                                                debug!(\"(privacy checking) \\\n+                                                debug2!(\"(privacy checking) \\\n                                                         checking field in \\\n                                                         struct variant \\\n                                                         literal\");\n@@ -582,7 +582,7 @@ impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n                             if id.crate != LOCAL_CRATE ||\n                                     !self.privileged_items.iter().any(|x| x == &(id.node)) {\n                                 for field in fields.iter() {\n-                                        debug!(\"(privacy checking) checking \\\n+                                        debug2!(\"(privacy checking) checking \\\n                                                 struct pattern\");\n                                     self.check_field(pattern.span, id, field.ident);\n                                 }\n@@ -594,7 +594,7 @@ impl<'self> Visitor<Context<'self>> for PrivacyVisitor {\n                                 match self.tcx.def_map.find(&pattern.id) {\n                                     Some(&DefVariant(_, variant_id, _)) => {\n                                         for field in fields.iter() {\n-                                            debug!(\"(privacy checking) \\\n+                                            debug2!(\"(privacy checking) \\\n                                                     checking field in \\\n                                                     struct variant pattern\");\n                                             self.check_field(pattern.span, variant_id, field.ident);"}, {"sha": "6973b46c92c47c58d79e4d5898520392efe0c406", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -400,14 +400,14 @@ impl ReachableContext {\n                     let desc = ast_map::node_id_to_str(self.tcx.items,\n                                                        search_item,\n                                                        ident_interner);\n-                    self.tcx.sess.bug(fmt!(\"found unexpected thingy in \\\n-                                            worklist: %s\",\n-                                            desc))\n+                    self.tcx.sess.bug(format!(\"found unexpected thingy in \\\n+                                               worklist: {}\",\n+                                               desc))\n                 }\n                 None => {\n-                    self.tcx.sess.bug(fmt!(\"found unmapped ID in worklist: \\\n-                                            %d\",\n-                                           search_item))\n+                    self.tcx.sess.bug(format!(\"found unmapped ID in worklist: \\\n+                                               {}\",\n+                                              search_item))\n                 }\n             }\n         }"}, {"sha": "0afcf87817ab53d0988050d2983102305c3a7bba", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -93,13 +93,13 @@ impl RegionMaps {\n             None => {}\n         }\n \n-        debug!(\"relate_free_regions(sub=%?, sup=%?)\", sub, sup);\n+        debug2!(\"relate_free_regions(sub={:?}, sup={:?})\", sub, sup);\n \n         self.free_region_map.insert(sub, ~[sup]);\n     }\n \n     pub fn record_parent(&mut self, sub: ast::NodeId, sup: ast::NodeId) {\n-        debug!(\"record_parent(sub=%?, sup=%?)\", sub, sup);\n+        debug2!(\"record_parent(sub={:?}, sup={:?})\", sub, sup);\n         assert!(sub != sup);\n \n         self.scope_map.insert(sub, sup);\n@@ -125,7 +125,7 @@ impl RegionMaps {\n \n         match self.scope_map.find(&id) {\n             Some(&r) => r,\n-            None => { fail!(\"No enclosing scope for id %?\", id); }\n+            None => { fail2!(\"No enclosing scope for id {:?}\", id); }\n         }\n     }\n \n@@ -168,7 +168,7 @@ impl RegionMaps {\n         while superscope != s {\n             match self.scope_map.find(&s) {\n                 None => {\n-                    debug!(\"is_subscope_of(%?, %?, s=%?)=false\",\n+                    debug2!(\"is_subscope_of({:?}, {:?}, s={:?})=false\",\n                            subscope, superscope, s);\n \n                     return false;\n@@ -177,7 +177,7 @@ impl RegionMaps {\n             }\n         }\n \n-        debug!(\"is_subscope_of(%?, %?)=true\",\n+        debug2!(\"is_subscope_of({:?}, {:?})=true\",\n                subscope, superscope);\n \n         return true;\n@@ -231,7 +231,7 @@ impl RegionMaps {\n          * duplicated with the code in infer.rs.\n          */\n \n-        debug!(\"is_subregion_of(sub_region=%?, super_region=%?)\",\n+        debug2!(\"is_subregion_of(sub_region={:?}, super_region={:?})\",\n                sub_region, super_region);\n \n         sub_region == super_region || {\n@@ -303,7 +303,7 @@ impl RegionMaps {\n         fn ancestors_of(this: &RegionMaps, scope: ast::NodeId)\n             -> ~[ast::NodeId]\n         {\n-            // debug!(\"ancestors_of(scope=%d)\", scope);\n+            // debug2!(\"ancestors_of(scope={})\", scope);\n             let mut result = ~[scope];\n             let mut scope = scope;\n             loop {\n@@ -314,7 +314,7 @@ impl RegionMaps {\n                         scope = superscope;\n                     }\n                 }\n-                // debug!(\"ancestors_of_loop(scope=%d)\", scope);\n+                // debug2!(\"ancestors_of_loop(scope={})\", scope);\n             }\n         }\n     }\n@@ -323,7 +323,7 @@ impl RegionMaps {\n /// Records the current parent (if any) as the parent of `child_id`.\n fn parent_to_expr(visitor: &mut RegionResolutionVisitor,\n                   cx: Context, child_id: ast::NodeId, sp: Span) {\n-    debug!(\"region::parent_to_expr(span=%?)\",\n+    debug2!(\"region::parent_to_expr(span={:?})\",\n            visitor.sess.codemap.span_to_str(sp));\n     for parent_id in cx.parent.iter() {\n         visitor.region_maps.record_parent(child_id, *parent_id);\n@@ -437,10 +437,10 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               sp: Span,\n               id: ast::NodeId,\n               cx: Context) {\n-    debug!(\"region::resolve_fn(id=%?, \\\n-                               span=%?, \\\n-                               body.id=%?, \\\n-                               cx.parent=%?)\",\n+    debug2!(\"region::resolve_fn(id={:?}, \\\n+                               span={:?}, \\\n+                               body.id={:?}, \\\n+                               cx.parent={:?})\",\n            id,\n            visitor.sess.codemap.span_to_str(sp),\n            body.id,\n@@ -619,7 +619,7 @@ impl DetermineRpCtxt {\n           Some(v) => join_variance(v, variance)\n         };\n \n-        debug!(\"add_rp() variance for %s: %? == %? ^ %?\",\n+        debug2!(\"add_rp() variance for {}: {:?} == {:?} ^ {:?}\",\n                ast_map::node_id_to_str(self.ast_map, id,\n                                        token::get_ident_interner()),\n                joined_variance, old_variance, variance);\n@@ -637,7 +637,7 @@ impl DetermineRpCtxt {\n     /// contains a value of type `from`, so if `from` is\n     /// region-parameterized, so is the current item.\n     pub fn add_dep(&mut self, from: ast::NodeId) {\n-        debug!(\"add dependency from %d -> %d (%s -> %s) with variance %?\",\n+        debug2!(\"add dependency from {} -> {} ({} -> {}) with variance {:?}\",\n                from, self.item_id,\n                ast_map::node_id_to_str(self.ast_map, from,\n                                        token::get_ident_interner()),\n@@ -715,7 +715,7 @@ impl DetermineRpCtxt {\n         let old_anon_implies_rp = self.anon_implies_rp;\n         self.item_id = item_id;\n         self.anon_implies_rp = anon_implies_rp;\n-        debug!(\"with_item_id(%d, %b)\",\n+        debug2!(\"with_item_id({}, {})\",\n                item_id,\n                anon_implies_rp);\n         let _i = ::util::common::indenter();\n@@ -787,7 +787,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n     let sess = cx.sess;\n     match ty.node {\n         ast::ty_rptr(ref r, _) => {\n-            debug!(\"referenced rptr type %s\",\n+            debug2!(\"referenced rptr type {}\",\n                    pprust::ty_to_str(ty, sess.intr()));\n \n             if cx.region_is_relevant(r) {\n@@ -797,7 +797,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n         }\n \n         ast::ty_closure(ref f) => {\n-            debug!(\"referenced fn type: %s\",\n+            debug2!(\"referenced fn type: {}\",\n                    pprust::ty_to_str(ty, sess.intr()));\n             match f.region {\n                 Some(_) => {\n@@ -837,7 +837,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n                 match csearch::get_region_param(cstore, did) {\n                   None => {}\n                   Some(variance) => {\n-                    debug!(\"reference to external, rp'd type %s\",\n+                    debug2!(\"reference to external, rp'd type {}\",\n                            pprust::ty_to_str(ty, sess.intr()));\n                     if cx.region_is_relevant(&path.segments.last().lifetime) {\n                         let rv = cx.add_variance(variance);\n@@ -967,7 +967,7 @@ pub fn determine_rp_in_crate(sess: Session,\n         while cx.worklist.len() != 0 {\n             let c_id = cx.worklist.pop();\n             let c_variance = cx.region_paramd_items.get_copy(&c_id);\n-            debug!(\"popped %d from worklist\", c_id);\n+            debug2!(\"popped {} from worklist\", c_id);\n             match cx.dep_map.find(&c_id) {\n               None => {}\n               Some(deps) => {\n@@ -980,11 +980,11 @@ pub fn determine_rp_in_crate(sess: Session,\n         }\n     }\n \n-    debug!(\"%s\", {\n-        debug!(\"Region variance results:\");\n+    debug2!(\"{}\", {\n+        debug2!(\"Region variance results:\");\n         let region_paramd_items = cx.region_paramd_items;\n         for (&key, &value) in region_paramd_items.iter() {\n-            debug!(\"item %? (%s) is parameterized with variance %?\",\n+            debug2!(\"item {:?} ({}) is parameterized with variance {:?}\",\n                    key,\n                    ast_map::node_id_to_str(ast_map, key,\n                                            token::get_ident_interner()),"}, {"sha": "4b5141f1630e0f7f440ad60984c942c3711d29a5", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 210, "deletions": 206, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -646,7 +646,7 @@ impl NameBindings {\n     pub fn get_module(&mut self) -> @mut Module {\n         match self.get_module_if_available() {\n             None => {\n-                fail!(\"get_module called on a node with no module \\\n+                fail2!(\"get_module called on a node with no module \\\n                        definition!\")\n             }\n             Some(module_def) => module_def\n@@ -1096,14 +1096,14 @@ impl Resolver {\n                     // had the duplicate.\n                     let ns = ns.unwrap();\n                     self.resolve_error(sp,\n-                        fmt!(\"duplicate definition of %s `%s`\",\n+                        format!(\"duplicate definition of {} `{}`\",\n                              namespace_error_to_str(duplicate_type),\n                              self.session.str_of(name)));\n                     {\n                         let r = child.span_for_namespace(ns);\n                         for sp in r.iter() {\n                             self.session.span_note(*sp,\n-                                 fmt!(\"first definition of %s `%s` here\",\n+                                 format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_str(duplicate_type),\n                                       self.session.str_of(name)));\n                         }\n@@ -1427,7 +1427,7 @@ impl Resolver {\n                     }\n                     match self.method_map.find_mut(name) {\n                         Some(s) => { s.insert(def_id); },\n-                        _ => fail!(\"Can't happen\"),\n+                        _ => fail2!(\"Can't happen\"),\n                     }\n                 }\n \n@@ -1436,7 +1436,7 @@ impl Resolver {\n             }\n \n             item_mac(*) => {\n-                fail!(\"item macros unimplemented\")\n+                fail2!(\"item macros unimplemented\")\n             }\n         }\n     }\n@@ -1620,8 +1620,8 @@ impl Resolver {\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.id;\n \n-            debug!(\"(building reduced graph for block) creating a new \\\n-                    anonymous module for block %d\",\n+            debug2!(\"(building reduced graph for block) creating a new \\\n+                    anonymous module for block {}\",\n                    block_id);\n \n             let parent_module = self.get_module_from_parent(parent);\n@@ -1645,22 +1645,22 @@ impl Resolver {\n                            ident: Ident,\n                            new_parent: ReducedGraphParent) {\n         let privacy = visibility_to_privacy(visibility);\n-        debug!(\"(building reduced graph for \\\n-                external crate) building external def, priv %?\",\n+        debug2!(\"(building reduced graph for \\\n+                external crate) building external def, priv {:?}\",\n                privacy);\n         match def {\n           DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n           DefTy(def_id) => {\n             match child_name_bindings.type_def {\n               Some(TypeNsDef { module_def: Some(module_def), _ }) => {\n-                debug!(\"(building reduced graph for external crate) \\\n+                debug2!(\"(building reduced graph for external crate) \\\n                         already created module\");\n                 module_def.def_id = Some(def_id);\n               }\n               Some(_) | None => {\n-                debug!(\"(building reduced graph for \\\n+                debug2!(\"(building reduced graph for \\\n                         external crate) building module \\\n-                        %s\", final_ident);\n+                        {}\", final_ident);\n                 let parent_link = self.get_parent_link(new_parent, ident);\n \n                 child_name_bindings.define_module(privacy,\n@@ -1678,8 +1678,8 @@ impl Resolver {\n         match def {\n           DefMod(_) | DefForeignMod(_) => {}\n           DefVariant(_, variant_id, is_struct) => {\n-            debug!(\"(building reduced graph for external crate) building \\\n-                    variant %s\",\n+            debug2!(\"(building reduced graph for external crate) building \\\n+                    variant {}\",\n                    final_ident);\n             // We assume the parent is visible, or else we wouldn't have seen\n             // it.\n@@ -1693,13 +1693,13 @@ impl Resolver {\n             }\n           }\n           DefFn(*) | DefStaticMethod(*) | DefStatic(*) => {\n-            debug!(\"(building reduced graph for external \\\n-                    crate) building value (fn/static) %s\", final_ident);\n+            debug2!(\"(building reduced graph for external \\\n+                    crate) building value (fn/static) {}\", final_ident);\n             child_name_bindings.define_value(privacy, def, dummy_sp());\n           }\n           DefTrait(def_id) => {\n-              debug!(\"(building reduced graph for external \\\n-                      crate) building type %s\", final_ident);\n+              debug2!(\"(building reduced graph for external \\\n+                      crate) building type {}\", final_ident);\n \n               // If this is a trait, add all the method names\n               // to the trait info.\n@@ -1712,9 +1712,9 @@ impl Resolver {\n                       get_method_name_and_explicit_self(self.session.cstore,\n                                                         method_def_id);\n \n-                  debug!(\"(building reduced graph for \\\n+                  debug2!(\"(building reduced graph for \\\n                           external crate) ... adding \\\n-                          trait method '%s'\",\n+                          trait method '{}'\",\n                          self.session.str_of(method_name));\n \n                   // Add it to the trait info if not static.\n@@ -1728,7 +1728,7 @@ impl Resolver {\n                   }\n                   match self.method_map.find_mut(name) {\n                       Some(s) => { s.insert(def_id); },\n-                      _ => fail!(\"Can't happen\"),\n+                      _ => fail2!(\"Can't happen\"),\n                   }\n               }\n \n@@ -1744,14 +1744,14 @@ impl Resolver {\n                                                   dummy_sp())\n           }\n           DefTy(_) => {\n-              debug!(\"(building reduced graph for external \\\n-                      crate) building type %s\", final_ident);\n+              debug2!(\"(building reduced graph for external \\\n+                      crate) building type {}\", final_ident);\n \n               child_name_bindings.define_type(privacy, def, dummy_sp());\n           }\n           DefStruct(def_id) => {\n-            debug!(\"(building reduced graph for external \\\n-                    crate) building type and value for %s\",\n+            debug2!(\"(building reduced graph for external \\\n+                    crate) building type and value for {}\",\n                    final_ident);\n             child_name_bindings.define_type(privacy, def, dummy_sp());\n             if get_struct_fields(self.session.cstore, def_id).len() == 0 {\n@@ -1766,7 +1766,7 @@ impl Resolver {\n           DefPrimTy(*) | DefTyParam(*) | DefBinding(*) |\n           DefUse(*) | DefUpvar(*) | DefRegion(*) |\n           DefTyParamBinder(*) | DefLabel(*) | DefSelfTy(*) => {\n-            fail!(\"didn't expect `%?`\", def);\n+            fail2!(\"didn't expect `{:?}`\", def);\n           }\n         }\n     }\n@@ -1821,9 +1821,9 @@ impl Resolver {\n                         match static_methods_opt {\n                             Some(ref static_methods) if\n                                 static_methods.len() >= 1 => {\n-                                debug!(\"(building reduced graph for \\\n+                                debug2!(\"(building reduced graph for \\\n                                         external crate) processing \\\n-                                        static methods for type name %s\",\n+                                        static methods for type name {}\",\n                                         self.session.str_of(\n                                             final_ident));\n \n@@ -1873,9 +1873,9 @@ impl Resolver {\n                                 for static_method_info in\n                                         static_methods.iter() {\n                                     let ident = static_method_info.ident;\n-                                    debug!(\"(building reduced graph for \\\n+                                    debug2!(\"(building reduced graph for \\\n                                              external crate) creating \\\n-                                             static method '%s'\",\n+                                             static method '{}'\",\n                                            self.session.str_of(ident));\n \n                                     let (method_name_bindings, _) =\n@@ -1901,28 +1901,28 @@ impl Resolver {\n                 }\n             }\n             DlField => {\n-                debug!(\"(building reduced graph for external crate) \\\n+                debug2!(\"(building reduced graph for external crate) \\\n                         ignoring field\");\n             }\n         }\n     }\n \n     /// Builds the reduced graph rooted at the given external module.\n     fn populate_external_module(&mut self, module: @mut Module) {\n-        debug!(\"(populating external module) attempting to populate %s\",\n+        debug2!(\"(populating external module) attempting to populate {}\",\n                self.module_to_str(module));\n \n         let def_id = match module.def_id {\n             None => {\n-                debug!(\"(populating external module) ... no def ID!\");\n+                debug2!(\"(populating external module) ... no def ID!\");\n                 return\n             }\n             Some(def_id) => def_id,\n         };\n \n         do csearch::each_child_of_item(self.session.cstore, def_id)\n                 |def_like, child_ident, visibility| {\n-            debug!(\"(populating external module) ... found ident: %s\",\n+            debug2!(\"(populating external module) ... found ident: {}\",\n                    token::ident_to_str(&child_ident));\n             self.build_reduced_graph_for_external_crate_def(module,\n                                                             def_like,\n@@ -1972,15 +1972,15 @@ impl Resolver {\n \n         match *subclass {\n             SingleImport(target, _) => {\n-                debug!(\"(building import directive) building import \\\n-                        directive: privacy %? %s::%s\",\n+                debug2!(\"(building import directive) building import \\\n+                        directive: privacy {:?} {}::{}\",\n                        privacy,\n                        self.idents_to_str(directive.module_path),\n                        self.session.str_of(target));\n \n                 match module_.import_resolutions.find(&target.name) {\n                     Some(&resolution) => {\n-                        debug!(\"(building import directive) bumping \\\n+                        debug2!(\"(building import directive) bumping \\\n                                 reference\");\n                         resolution.outstanding_references += 1;\n \n@@ -1990,7 +1990,7 @@ impl Resolver {\n                         resolution.value_id = id;\n                     }\n                     None => {\n-                        debug!(\"(building import directive) creating new\");\n+                        debug2!(\"(building import directive) creating new\");\n                         let resolution = @mut ImportResolution::new(privacy, id);\n                         resolution.outstanding_references = 1;\n                         module_.import_resolutions.insert(target.name, resolution);\n@@ -2022,14 +2022,14 @@ impl Resolver {\n         let mut i = 0;\n         let mut prev_unresolved_imports = 0;\n         loop {\n-            debug!(\"(resolving imports) iteration %u, %u imports left\",\n+            debug2!(\"(resolving imports) iteration {}, {} imports left\",\n                    i, self.unresolved_imports);\n \n             let module_root = self.graph_root.get_module();\n             self.resolve_imports_for_module_subtree(module_root);\n \n             if self.unresolved_imports == 0 {\n-                debug!(\"(resolving imports) success\");\n+                debug2!(\"(resolving imports) success\");\n                 break;\n             }\n \n@@ -2047,7 +2047,7 @@ impl Resolver {\n     /// submodules.\n     pub fn resolve_imports_for_module_subtree(&mut self,\n                                               module_: @mut Module) {\n-        debug!(\"(resolving imports for module subtree) resolving %s\",\n+        debug2!(\"(resolving imports for module subtree) resolving {}\",\n                self.module_to_str(module_));\n         self.resolve_imports_for_module(module_);\n \n@@ -2071,8 +2071,8 @@ impl Resolver {\n     /// Attempts to resolve imports for the given module only.\n     pub fn resolve_imports_for_module(&mut self, module: @mut Module) {\n         if module.all_imports_resolved() {\n-            debug!(\"(resolving imports for module) all imports resolved for \\\n-                   %s\",\n+            debug2!(\"(resolving imports for module) all imports resolved for \\\n+                   {}\",\n                    self.module_to_str(module));\n             return;\n         }\n@@ -2085,7 +2085,7 @@ impl Resolver {\n             match self.resolve_import_for_module(module, import_directive) {\n                 Failed => {\n                     // We presumably emitted an error. Continue.\n-                    let msg = fmt!(\"failed to resolve import `%s`\",\n+                    let msg = format!(\"failed to resolve import `{}`\",\n                                    self.import_path_to_str(\n                                        import_directive.module_path,\n                                        *import_directive.subclass));\n@@ -2142,7 +2142,7 @@ impl Resolver {\n         if idents.is_empty() {\n             self.import_directive_subclass_to_str(subclass)\n         } else {\n-            (fmt!(\"%s::%s\",\n+            (format!(\"{}::{}\",\n                   self.idents_to_str(idents),\n                   self.import_directive_subclass_to_str(subclass))).to_managed()\n         }\n@@ -2160,8 +2160,8 @@ impl Resolver {\n         let mut resolution_result = Failed;\n         let module_path = &import_directive.module_path;\n \n-        debug!(\"(resolving import for module) resolving import `%s::...` in \\\n-                `%s`\",\n+        debug2!(\"(resolving import for module) resolving import `{}::...` in \\\n+                `{}`\",\n                self.idents_to_str(*module_path),\n                self.module_to_str(module_));\n \n@@ -2263,8 +2263,8 @@ impl Resolver {\n                                  source: Ident,\n                                  directive: &ImportDirective)\n                                  -> ResolveResult<()> {\n-        debug!(\"(resolving single import) resolving `%s` = `%s::%s` from \\\n-                `%s`\",\n+        debug2!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n+                `{}`\",\n                self.session.str_of(target),\n                self.module_to_str(containing_module),\n                self.session.str_of(source),\n@@ -2304,7 +2304,7 @@ impl Resolver {\n                 // able to resolve this import.\n \n                 if containing_module.glob_count > 0 {\n-                    debug!(\"(resolving single import) unresolved glob; \\\n+                    debug2!(\"(resolving single import) unresolved glob; \\\n                             bailing out\");\n                     return Indeterminate;\n                 }\n@@ -2369,7 +2369,7 @@ impl Resolver {\n                     }\n                     Some(_) => {\n                         // The import is unresolved. Bail out.\n-                        debug!(\"(resolving single import) unresolved import; \\\n+                        debug2!(\"(resolving single import) unresolved import; \\\n                                 bailing out\");\n                         return Indeterminate;\n                     }\n@@ -2402,27 +2402,27 @@ impl Resolver {\n \n         match value_result {\n             BoundResult(target_module, name_bindings) => {\n-                debug!(\"(resolving single import) found value target\");\n+                debug2!(\"(resolving single import) found value target\");\n                 import_resolution.value_target =\n                     Some(Target::new(target_module, name_bindings));\n                 import_resolution.value_id = directive.id;\n             }\n             UnboundResult => { /* Continue. */ }\n             UnknownResult => {\n-                fail!(\"value result should be known at this point\");\n+                fail2!(\"value result should be known at this point\");\n             }\n         }\n         match type_result {\n             BoundResult(target_module, name_bindings) => {\n-                debug!(\"(resolving single import) found type target: %?\",\n+                debug2!(\"(resolving single import) found type target: {:?}\",\n                         name_bindings.type_def.unwrap().type_def);\n                 import_resolution.type_target =\n                     Some(Target::new(target_module, name_bindings));\n                 import_resolution.type_id = directive.id;\n             }\n             UnboundResult => { /* Continue. */ }\n             UnknownResult => {\n-                fail!(\"type result should be known at this point\");\n+                fail2!(\"type result should be known at this point\");\n             }\n         }\n \n@@ -2469,15 +2469,15 @@ impl Resolver {\n \n         let span = directive.span;\n         if resolve_fail {\n-            let msg = fmt!(\"unresolved import: there is no `%s` in `%s`\",\n-                           self.session.str_of(source),\n-                           self.module_to_str(containing_module));\n+            let msg = format!(\"unresolved import: there is no `{}` in `{}`\",\n+                              self.session.str_of(source),\n+                              self.module_to_str(containing_module));\n             self.resolve_error(span, msg);\n             return Failed;\n         } else if priv_fail {\n-            let msg = fmt!(\"unresolved import: found `%s` in `%s` but it is \\\n-                           private\", self.session.str_of(source),\n-                           self.module_to_str(containing_module));\n+            let msg = format!(\"unresolved import: found `{}` in `{}` but it is \\\n+                              private\", self.session.str_of(source),\n+                              self.module_to_str(containing_module));\n             self.resolve_error(span, msg);\n             return Failed;\n         }\n@@ -2505,7 +2505,7 @@ impl Resolver {\n             None => {}\n         }\n \n-        debug!(\"(resolving single import) successfully resolved import\");\n+        debug2!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n     }\n \n@@ -2521,12 +2521,12 @@ impl Resolver {\n         // This function works in a highly imperative manner; it eagerly adds\n         // everything it can to the list of import resolutions of the module\n         // node.\n-        debug!(\"(resolving glob import) resolving %? glob import\", privacy);\n+        debug2!(\"(resolving glob import) resolving {:?} glob import\", privacy);\n \n         // We must bail out if the node has unresolved imports of any kind\n         // (including globs).\n         if !(*containing_module).all_imports_resolved() {\n-            debug!(\"(resolving glob import) target module has unresolved \\\n+            debug2!(\"(resolving glob import) target module has unresolved \\\n                     imports; bailing out\");\n             return Indeterminate;\n         }\n@@ -2536,8 +2536,8 @@ impl Resolver {\n         // Add all resolved imports from the containing module.\n         for (ident, target_import_resolution) in containing_module.import_resolutions.iter() {\n \n-            debug!(\"(resolving glob import) writing module resolution \\\n-                    %? into `%s`\",\n+            debug2!(\"(resolving glob import) writing module resolution \\\n+                    {:?} into `{}`\",\n                    target_import_resolution.type_target.is_none(),\n                    self.module_to_str(module_));\n \n@@ -2597,22 +2597,22 @@ impl Resolver {\n                 }\n             }\n \n-            debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n-                    to `%s`, privacy=%?\",\n+            debug2!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n+                    to `{}`, privacy={:?}\",\n                    interner_get(name),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_),\n                    dest_import_resolution.privacy);\n \n             // Merge the child item into the import resolution.\n             if name_bindings.defined_in_public_namespace(ValueNS) {\n-                debug!(\"(resolving glob import) ... for value target\");\n+                debug2!(\"(resolving glob import) ... for value target\");\n                 dest_import_resolution.value_target =\n                     Some(Target::new(containing_module, name_bindings));\n                 dest_import_resolution.value_id = id;\n             }\n             if name_bindings.defined_in_public_namespace(TypeNS) {\n-                debug!(\"(resolving glob import) ... for type target\");\n+                debug2!(\"(resolving glob import) ... for type target\");\n                 dest_import_resolution.type_target =\n                     Some(Target::new(containing_module, name_bindings));\n                 dest_import_resolution.type_id = id;\n@@ -2640,7 +2640,7 @@ impl Resolver {\n             None => {}\n         }\n \n-        debug!(\"(resolving glob import) successfully resolved import\");\n+        debug2!(\"(resolving glob import) successfully resolved import\");\n         return Success(());\n     }\n \n@@ -2675,19 +2675,19 @@ impl Resolver {\n                             expn_info: span.expn_info,\n                         };\n                         self.resolve_error(span,\n-                                              fmt!(\"unresolved import. maybe \\\n+                                              format!(\"unresolved import. maybe \\\n                                                     a missing `extern mod \\\n-                                                    %s`?\",\n+                                                    {}`?\",\n                                                     segment_name));\n                         return Failed;\n                     }\n-                    self.resolve_error(span, fmt!(\"unresolved import: could not find `%s` in \\\n-                                                     `%s`.\", segment_name, module_name));\n+                    self.resolve_error(span, format!(\"unresolved import: could not find `{}` in \\\n+                                                     `{}`.\", segment_name, module_name));\n                     return Failed;\n                 }\n                 Indeterminate => {\n-                    debug!(\"(resolving module path for import) module \\\n-                            resolution is indeterminate: %s\",\n+                    debug2!(\"(resolving module path for import) module \\\n+                            resolution is indeterminate: {}\",\n                             self.session.str_of(name));\n                     return Indeterminate;\n                 }\n@@ -2700,8 +2700,8 @@ impl Resolver {\n                                 None => {\n                                     // Not a module.\n                                     self.resolve_error(span,\n-                                                          fmt!(\"not a \\\n-                                                                module `%s`\",\n+                                                          format!(\"not a \\\n+                                                                module `{}`\",\n                                                                self.session.\n                                                                    str_of(\n                                                                     name)));\n@@ -2729,7 +2729,7 @@ impl Resolver {\n                         None => {\n                             // There are no type bindings at all.\n                             self.resolve_error(span,\n-                                                  fmt!(\"not a module `%s`\",\n+                                                  format!(\"not a module `{}`\",\n                                                        self.session.str_of(\n                                                             name)));\n                             return Failed;\n@@ -2764,8 +2764,8 @@ impl Resolver {\n         let module_path_len = module_path.len();\n         assert!(module_path_len > 0);\n \n-        debug!(\"(resolving module path for import) processing `%s` rooted at \\\n-               `%s`\",\n+        debug2!(\"(resolving module path for import) processing `{}` rooted at \\\n+               `{}`\",\n                self.idents_to_str(module_path),\n                self.module_to_str(module_));\n \n@@ -2780,8 +2780,8 @@ impl Resolver {\n                 let mpath = self.idents_to_str(module_path);\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n-                        self.resolve_error(span, fmt!(\"unresolved import: could not find `%s` \\\n-                                                         in `%s`\",\n+                        self.resolve_error(span, format!(\"unresolved import: could not find `{}` \\\n+                                                         in `{}`\",\n                                                          // idx +- 1 to account for the colons\n                                                          // on either side\n                                                          mpath.slice_from(idx + 1),\n@@ -2792,7 +2792,7 @@ impl Resolver {\n                 return Failed;\n             }\n             Indeterminate => {\n-                debug!(\"(resolving module path for import) indeterminate; \\\n+                debug2!(\"(resolving module path for import) indeterminate; \\\n                         bailing\");\n                 return Indeterminate;\n             }\n@@ -2820,7 +2820,7 @@ impl Resolver {\n                                 return Failed;\n                             }\n                             Indeterminate => {\n-                                debug!(\"(resolving module path for import) \\\n+                                debug2!(\"(resolving module path for import) \\\n                                         indeterminate; bailing\");\n                                 return Indeterminate;\n                             }\n@@ -2854,8 +2854,8 @@ impl Resolver {\n                                          search_through_modules:\n                                          SearchThroughModulesFlag)\n                                          -> ResolveResult<Target> {\n-        debug!(\"(resolving item in lexical scope) resolving `%s` in \\\n-                namespace %? in `%s`\",\n+        debug2!(\"(resolving item in lexical scope) resolving `{}` in \\\n+                namespace {:?} in `{}`\",\n                self.session.str_of(name),\n                namespace,\n                self.module_to_str(module_));\n@@ -2883,12 +2883,12 @@ impl Resolver {\n                 match (*import_resolution).target_for_namespace(namespace) {\n                     None => {\n                         // Not found; continue.\n-                        debug!(\"(resolving item in lexical scope) found \\\n-                                import resolution, but not in namespace %?\",\n+                        debug2!(\"(resolving item in lexical scope) found \\\n+                                import resolution, but not in namespace {:?}\",\n                                namespace);\n                     }\n                     Some(target) => {\n-                        debug!(\"(resolving item in lexical scope) using \\\n+                        debug2!(\"(resolving item in lexical scope) using \\\n                                 import resolution\");\n                         self.used_imports.insert(import_resolution.id(namespace));\n                         return Success(target);\n@@ -2917,7 +2917,7 @@ impl Resolver {\n             match search_module.parent_link {\n                 NoParentLink => {\n                     // No more parents. This module was unresolved.\n-                    debug!(\"(resolving item in lexical scope) unresolved \\\n+                    debug2!(\"(resolving item in lexical scope) unresolved \\\n                             module\");\n                     return Failed;\n                 }\n@@ -2927,7 +2927,7 @@ impl Resolver {\n                             match search_module.kind {\n                                 NormalModuleKind => {\n                                     // We stop the search here.\n-                                    debug!(\"(resolving item in lexical \\\n+                                    debug2!(\"(resolving item in lexical \\\n                                             scope) unresolved module: not \\\n                                             searching through module \\\n                                             parents\");\n@@ -2963,7 +2963,7 @@ impl Resolver {\n                     // We couldn't see through the higher scope because of an\n                     // unresolved import higher up. Bail.\n \n-                    debug!(\"(resolving item in lexical scope) indeterminate \\\n+                    debug2!(\"(resolving item in lexical scope) indeterminate \\\n                             higher scope; bailing\");\n                     return Indeterminate;\n                 }\n@@ -2991,7 +2991,7 @@ impl Resolver {\n                     Some(ref type_def) => {\n                         match (*type_def).module_def {\n                             None => {\n-                                error!(\"!!! (resolving module in lexical \\\n+                                error2!(\"!!! (resolving module in lexical \\\n                                         scope) module wasn't actually a \\\n                                         module!\");\n                                 return Failed;\n@@ -3002,19 +3002,19 @@ impl Resolver {\n                         }\n                     }\n                     None => {\n-                        error!(\"!!! (resolving module in lexical scope) module\n+                        error2!(\"!!! (resolving module in lexical scope) module\n                                 wasn't actually a module!\");\n                         return Failed;\n                     }\n                 }\n             }\n             Indeterminate => {\n-                debug!(\"(resolving module in lexical scope) indeterminate; \\\n+                debug2!(\"(resolving module in lexical scope) indeterminate; \\\n                         bailing\");\n                 return Indeterminate;\n             }\n             Failed => {\n-                debug!(\"(resolving module in lexical scope) failed to \\\n+                debug2!(\"(resolving module in lexical scope) failed to \\\n                         resolve\");\n                 return Failed;\n             }\n@@ -3087,7 +3087,7 @@ impl Resolver {\n         // Now loop through all the `super`s we find.\n         while i < module_path.len() &&\n                 \"super\" == token::ident_to_str(&module_path[i]) {\n-            debug!(\"(resolving module prefix) resolving `super` at %s\",\n+            debug2!(\"(resolving module prefix) resolving `super` at {}\",\n                    self.module_to_str(containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n                 None => return Failed,\n@@ -3098,7 +3098,7 @@ impl Resolver {\n             }\n         }\n \n-        debug!(\"(resolving module prefix) finished resolving prefix at %s\",\n+        debug2!(\"(resolving module prefix) finished resolving prefix at {}\",\n                self.module_to_str(containing_module));\n \n         return Success(PrefixFound(containing_module, i));\n@@ -3113,7 +3113,7 @@ impl Resolver {\n                                   namespace: Namespace,\n                                   name_search_type: NameSearchType)\n                                   -> ResolveResult<Target> {\n-        debug!(\"(resolving name in module) resolving `%s` in `%s`\",\n+        debug2!(\"(resolving name in module) resolving `{}` in `{}`\",\n                self.session.str_of(name),\n                self.module_to_str(module_));\n \n@@ -3122,7 +3122,7 @@ impl Resolver {\n         match module_.children.find(&name.name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n-                debug!(\"(resolving name in module) found node as child\");\n+                debug2!(\"(resolving name in module) found node as child\");\n                 return Success(Target::new(module_, *name_bindings));\n             }\n             Some(_) | None => {\n@@ -3144,28 +3144,28 @@ impl Resolver {\n             Some(import_resolution) => {\n                 if import_resolution.privacy == Public &&\n                         import_resolution.outstanding_references != 0 {\n-                    debug!(\"(resolving name in module) import \\\n+                    debug2!(\"(resolving name in module) import \\\n                             unresolved; bailing out\");\n                     return Indeterminate;\n                 }\n \n                 match import_resolution.target_for_namespace(namespace) {\n                     None => {\n-                        debug!(\"(resolving name in module) name found, \\\n-                                but not in namespace %?\",\n+                        debug2!(\"(resolving name in module) name found, \\\n+                                but not in namespace {:?}\",\n                                namespace);\n                     }\n                     Some(target)\n                             if name_search_type ==\n                                 PathPublicOrPrivateSearch ||\n                             import_resolution.privacy == Public => {\n-                        debug!(\"(resolving name in module) resolved to \\\n+                        debug2!(\"(resolving name in module) resolved to \\\n                                 import\");\n                         self.used_imports.insert(import_resolution.id(namespace));\n                         return Success(target);\n                     }\n                     Some(_) => {\n-                        debug!(\"(resolving name in module) name found, \\\n+                        debug2!(\"(resolving name in module) name found, \\\n                                 but not public\");\n                     }\n                 }\n@@ -3187,7 +3187,7 @@ impl Resolver {\n         }\n \n         // We're out of luck.\n-        debug!(\"(resolving name in module) failed to resolve `%s`\",\n+        debug2!(\"(resolving name in module) failed to resolve `{}`\",\n                self.session.str_of(name));\n         return Failed;\n     }\n@@ -3201,7 +3201,7 @@ impl Resolver {\n             if sn.contains(\"::\") {\n                 self.resolve_error(imports[index].span, \"unresolved import\");\n             } else {\n-                let err = fmt!(\"unresolved import (maybe you meant `%s::*`?)\",\n+                let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                sn.slice(0, sn.len()));\n                 self.resolve_error(imports[index].span, err);\n             }\n@@ -3247,20 +3247,20 @@ impl Resolver {\n         match module_.def_id {\n             Some(def_id) if def_id.crate == LOCAL_CRATE => {\n                 // OK. Continue.\n-                debug!(\"(recording exports for module subtree) recording \\\n-                        exports for local module `%s`\",\n+                debug2!(\"(recording exports for module subtree) recording \\\n+                        exports for local module `{}`\",\n                        self.module_to_str(module_));\n             }\n             None => {\n                 // Record exports for the root module.\n-                debug!(\"(recording exports for module subtree) recording \\\n-                        exports for root module `%s`\",\n+                debug2!(\"(recording exports for module subtree) recording \\\n+                        exports for root module `{}`\",\n                        self.module_to_str(module_));\n             }\n             Some(_) => {\n                 // Bail out.\n-                debug!(\"(recording exports for module subtree) not recording \\\n-                        exports for `%s`\",\n+                debug2!(\"(recording exports for module subtree) not recording \\\n+                        exports for `{}`\",\n                        self.module_to_str(module_));\n                 return;\n             }\n@@ -3292,7 +3292,7 @@ impl Resolver {\n         match module_.def_id {\n             Some(def_id) => {\n                 self.export_map2.insert(def_id.node, exports2);\n-                debug!(\"(computing exports) writing exports for %d (some)\",\n+                debug2!(\"(computing exports) writing exports for {} (some)\",\n                        def_id.node);\n             }\n             None => {}\n@@ -3308,7 +3308,7 @@ impl Resolver {\n         match (namebindings.def_for_namespace(ns),\n                namebindings.privacy_for_namespace(ns)) {\n             (Some(d), Some(Public)) => {\n-                debug!(\"(computing exports) YES: %s '%s' => %?\",\n+                debug2!(\"(computing exports) YES: {} '{}' => {:?}\",\n                        if reexport { ~\"reexport\" } else { ~\"export\"},\n                        interner_get(name),\n                        def_id_of_def(d));\n@@ -3319,10 +3319,10 @@ impl Resolver {\n                 });\n             }\n             (Some(_), Some(privacy)) => {\n-                debug!(\"(computing reexports) NO: privacy %?\", privacy);\n+                debug2!(\"(computing reexports) NO: privacy {:?}\", privacy);\n             }\n             (d_opt, p_opt) => {\n-                debug!(\"(computing reexports) NO: %?, %?\", d_opt, p_opt);\n+                debug2!(\"(computing reexports) NO: {:?}, {:?}\", d_opt, p_opt);\n             }\n         }\n     }\n@@ -3332,15 +3332,15 @@ impl Resolver {\n                                   module_: @mut Module) {\n         for (name, importresolution) in module_.import_resolutions.iter() {\n             if importresolution.privacy != Public {\n-                debug!(\"(computing exports) not reexporting private `%s`\",\n+                debug2!(\"(computing exports) not reexporting private `{}`\",\n                        interner_get(*name));\n                 loop;\n             }\n             let xs = [TypeNS, ValueNS];\n             for ns in xs.iter() {\n                 match importresolution.target_for_namespace(*ns) {\n                     Some(target) => {\n-                        debug!(\"(computing exports) maybe reexport '%s'\",\n+                        debug2!(\"(computing exports) maybe reexport '{}'\",\n                                interner_get(*name));\n                         self.add_exports_of_namebindings(&mut *exports2,\n                                                          *name,\n@@ -3384,15 +3384,15 @@ impl Resolver {\n                 self.populate_module_if_necessary(orig_module);\n                 match orig_module.children.find(&name.name) {\n                     None => {\n-                        debug!(\"!!! (with scope) didn't find `%s` in `%s`\",\n+                        debug2!(\"!!! (with scope) didn't find `{}` in `{}`\",\n                                self.session.str_of(name),\n                                self.module_to_str(orig_module));\n                     }\n                     Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             None => {\n-                                debug!(\"!!! (with scope) didn't find module \\\n-                                        for `%s` in `%s`\",\n+                                debug2!(\"!!! (with scope) didn't find module \\\n+                                        for `{}` in `{}`\",\n                                        self.session.str_of(name),\n                                        self.module_to_str(orig_module));\n                             }\n@@ -3551,13 +3551,13 @@ impl Resolver {\n     }\n \n     pub fn resolve_crate(&mut self, crate: &ast::Crate) {\n-        debug!(\"(resolving crate) starting\");\n+        debug2!(\"(resolving crate) starting\");\n \n         visit::walk_crate(self, crate, ());\n     }\n \n     pub fn resolve_item(&mut self, item: @item) {\n-        debug!(\"(resolving item) resolving %s\",\n+        debug2!(\"(resolving item) resolving {}\",\n                self.session.str_of(item.ident));\n \n         // Items with the !resolve_unexported attribute are X-ray contexts.\n@@ -3727,7 +3727,7 @@ impl Resolver {\n             }\n \n           item_mac(*) => {\n-            fail!(\"item macros unimplemented\")\n+            fail2!(\"item macros unimplemented\")\n           }\n         }\n \n@@ -3746,7 +3746,7 @@ impl Resolver {\n \n                 for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n                     let ident = type_parameter.ident;\n-                    debug!(\"with_type_parameter_rib: %d %d\", node_id,\n+                    debug2!(\"with_type_parameter_rib: {} {}\", node_id,\n                            type_parameter.id);\n                     let def_like = DlDef(DefTyParam\n                         (local_def(type_parameter.id),\n@@ -3844,7 +3844,7 @@ impl Resolver {\n \n                         this.resolve_type(&argument.ty);\n \n-                        debug!(\"(resolving function) recorded argument\");\n+                        debug2!(\"(resolving function) recorded argument\");\n                     }\n \n                     this.resolve_type(&declaration.output);\n@@ -3854,7 +3854,7 @@ impl Resolver {\n             // Resolve the function body.\n             this.resolve_block(block);\n \n-            debug!(\"(resolving function) leaving function\");\n+            debug2!(\"(resolving function) leaving function\");\n         }\n \n         self.label_ribs.pop();\n@@ -3894,11 +3894,11 @@ impl Resolver {\n                     TraitDerivation            => \"derive\"\n                 };\n \n-                let msg = fmt!(\"attempt to %s a nonexistent trait `%s`\", usage_str, path_str);\n+                let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n                 self.resolve_error(trait_reference.path.span, msg);\n             }\n             Some(def) => {\n-                debug!(\"(resolving trait) found trait def: %?\", def);\n+                debug2!(\"(resolving trait) found trait def: {:?}\", def);\n                 self.record_def(trait_reference.ref_id, def);\n             }\n         }\n@@ -3916,7 +3916,7 @@ impl Resolver {\n                         Some(&prev_field) => {\n                             let ident_str = self.session.str_of(ident);\n                             self.resolve_error(field.span,\n-                                fmt!(\"field `%s` is already declared\", ident_str));\n+                                format!(\"field `{}` is already declared\", ident_str));\n                             self.session.span_note(prev_field.span,\n                                 \"Previously declared here\");\n                         },\n@@ -4049,7 +4049,7 @@ impl Resolver {\n                           _name: Ident,\n                           id: NodeId) {\n         // Write the implementations in scope into the module metadata.\n-        debug!(\"(resolving module) resolving module ID %d\", id);\n+        debug2!(\"(resolving module) resolving module ID {}\", id);\n         visit::walk_mod(self, module_, ());\n     }\n \n@@ -4101,16 +4101,16 @@ impl Resolver {\n                   None => {\n                     self.resolve_error(\n                         p.span,\n-                        fmt!(\"variable `%s` from pattern #1 is \\\n-                                  not bound in pattern #%u\",\n+                        format!(\"variable `{}` from pattern \\\\#1 is \\\n+                                  not bound in pattern \\\\#{}\",\n                              interner_get(key), i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n                         self.resolve_error(\n                             binding_i.span,\n-                            fmt!(\"variable `%s` is bound with different \\\n-                                      mode in pattern #%u than in pattern #1\",\n+                            format!(\"variable `{}` is bound with different \\\n+                                      mode in pattern \\\\#{} than in pattern \\\\#1\",\n                                  interner_get(key), i + 1));\n                     }\n                   }\n@@ -4121,8 +4121,8 @@ impl Resolver {\n                 if !map_0.contains_key(&key) {\n                     self.resolve_error(\n                         binding.span,\n-                        fmt!(\"variable `%s` from pattern #%u is \\\n-                                  not bound in pattern #1\",\n+                        format!(\"variable `{}` from pattern \\\\#{} is \\\n+                                  not bound in pattern \\\\#1\",\n                              interner_get(key), i + 1));\n                 }\n             }\n@@ -4149,15 +4149,15 @@ impl Resolver {\n     }\n \n     pub fn resolve_block(&mut self, block: &Block) {\n-        debug!(\"(resolving block) entering block\");\n+        debug2!(\"(resolving block) entering block\");\n         self.value_ribs.push(@Rib::new(NormalRibKind));\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n         match self.current_module.anonymous_children.find(&block.id) {\n             None => { /* Nothing to do. */ }\n             Some(&anonymous_module) => {\n-                debug!(\"(resolving block) found anonymous module, moving \\\n+                debug2!(\"(resolving block) found anonymous module, moving \\\n                         down\");\n                 self.current_module = anonymous_module;\n             }\n@@ -4170,7 +4170,7 @@ impl Resolver {\n         self.current_module = orig_module;\n \n         self.value_ribs.pop();\n-        debug!(\"(resolving block) leaving block\");\n+        debug2!(\"(resolving block) leaving block\");\n     }\n \n     pub fn resolve_type(&mut self, ty: &Ty) {\n@@ -4224,8 +4224,8 @@ impl Resolver {\n                                                 TypeNS,\n                                                 true) {\n                             Some(def) => {\n-                                debug!(\"(resolving type) resolved `%s` to \\\n-                                        type %?\",\n+                                debug2!(\"(resolving type) resolved `{}` to \\\n+                                        type {:?}\",\n                                        self.session.str_of(path.segments\n                                                                .last()\n                                                                .identifier),\n@@ -4243,15 +4243,15 @@ impl Resolver {\n                 match result_def {\n                     Some(def) => {\n                         // Write the result into the def map.\n-                        debug!(\"(resolving type) writing resolution for `%s` \\\n-                                (id %d)\",\n+                        debug2!(\"(resolving type) writing resolution for `{}` \\\n+                                (id {})\",\n                                self.path_idents_to_str(path),\n                                path_id);\n                         self.record_def(path_id, def);\n                     }\n                     None => {\n-                        let msg = fmt!(\"use of undeclared type name `%s`\",\n-                                       self.path_idents_to_str(path));\n+                        let msg = format!(\"use of undeclared type name `{}`\",\n+                                          self.path_idents_to_str(path));\n                         self.resolve_error(ty.span, msg);\n                     }\n                 }\n@@ -4307,7 +4307,7 @@ impl Resolver {\n                     match self.resolve_bare_identifier_pattern(ident) {\n                         FoundStructOrEnumVariant(def)\n                                 if mode == RefutableMode => {\n-                            debug!(\"(resolving pattern) resolving `%s` to \\\n+                            debug2!(\"(resolving pattern) resolving `{}` to \\\n                                     struct or enum variant\",\n                                    interner_get(renamed));\n \n@@ -4319,14 +4319,14 @@ impl Resolver {\n                         }\n                         FoundStructOrEnumVariant(_) => {\n                             self.resolve_error(pattern.span,\n-                                                  fmt!(\"declaration of `%s` \\\n+                                                  format!(\"declaration of `{}` \\\n                                                         shadows an enum \\\n                                                         variant or unit-like \\\n                                                         struct in scope\",\n                                                        interner_get(renamed)));\n                         }\n                         FoundConst(def) if mode == RefutableMode => {\n-                            debug!(\"(resolving pattern) resolving `%s` to \\\n+                            debug2!(\"(resolving pattern) resolving `{}` to \\\n                                     constant\",\n                                    interner_get(renamed));\n \n@@ -4342,7 +4342,7 @@ impl Resolver {\n                                                    allowed here\");\n                         }\n                         BareIdentifierPatternUnresolved => {\n-                            debug!(\"(resolving pattern) binding `%s`\",\n+                            debug2!(\"(resolving pattern) binding `{}`\",\n                                    interner_get(renamed));\n \n                             let is_mutable = mutability == Mutable;\n@@ -4392,7 +4392,7 @@ impl Resolver {\n                                       // in the same disjunct, which is an\n                                       // error\n                                      self.resolve_error(pattern.span,\n-                                       fmt!(\"Identifier `%s` is bound more \\\n+                                       format!(\"Identifier `{}` is bound more \\\n                                              than once in the same pattern\",\n                                             path_to_str(path, self.session\n                                                         .intr())));\n@@ -4435,7 +4435,7 @@ impl Resolver {\n                         Some(_) => {\n                             self.resolve_error(\n                                 path.span,\n-                                fmt!(\"`%s` is not an enum variant or constant\",\n+                                format!(\"`{}` is not an enum variant or constant\",\n                                      self.session.str_of(\n                                          path.segments.last().identifier)))\n                         }\n@@ -4465,16 +4465,16 @@ impl Resolver {\n                         Some(_) => {\n                             self.resolve_error(\n                                 path.span,\n-                                fmt!(\"`%s` is not an enum variant, struct or const\",\n+                                format!(\"`{}` is not an enum variant, struct or const\",\n                                      self.session\n                                          .str_of(path.segments\n                                                      .last()\n                                                      .identifier)));\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n-                                               fmt!(\"unresolved enum variant, \\\n-                                                    struct or const `%s`\",\n+                                               format!(\"unresolved enum variant, \\\n+                                                    struct or const `{}`\",\n                                                     self.session\n                                                         .str_of(path.segments\n                                                                     .last()\n@@ -4515,10 +4515,10 @@ impl Resolver {\n                             self.record_def(pattern.id, definition);\n                         }\n                         result => {\n-                            debug!(\"(resolving pattern) didn't find struct \\\n-                                    def: %?\", result);\n-                            let msg = fmt!(\"`%s` does not name a structure\",\n-                                           self.path_idents_to_str(path));\n+                            debug2!(\"(resolving pattern) didn't find struct \\\n+                                    def: {:?}\", result);\n+                            let msg = format!(\"`{}` does not name a structure\",\n+                                              self.path_idents_to_str(path));\n                             self.resolve_error(path.span, msg);\n                         }\n                     }\n@@ -4542,7 +4542,7 @@ impl Resolver {\n             Success(target) => {\n                 match target.bindings.value_def {\n                     None => {\n-                        fail!(\"resolved name in the value namespace to a \\\n+                        fail2!(\"resolved name in the value namespace to a \\\n                               set of name bindings with no def?!\");\n                     }\n                     Some(def) => {\n@@ -4562,7 +4562,7 @@ impl Resolver {\n             }\n \n             Indeterminate => {\n-                fail!(\"unexpected indeterminate result\");\n+                fail2!(\"unexpected indeterminate result\");\n             }\n \n             Failed => {\n@@ -4732,14 +4732,14 @@ impl Resolver {\n                                        path.span,\n                                        PathPublicOnlySearch) {\n             Failed => {\n-                let msg = fmt!(\"use of undeclared module `%s`\",\n-                               self.idents_to_str(module_path_idents));\n+                let msg = format!(\"use of undeclared module `{}`\",\n+                                  self.idents_to_str(module_path_idents));\n                 self.resolve_error(path.span, msg);\n                 return None;\n             }\n \n             Indeterminate => {\n-                fail!(\"indeterminate unexpected\");\n+                fail2!(\"indeterminate unexpected\");\n             }\n \n             Success(resulting_module) => {\n@@ -4766,7 +4766,7 @@ impl Resolver {\n                     Some(s) => {\n                         match containing_module.def_id {\n                             Some(def_id) if s.contains(&def_id) => {\n-                                debug!(\"containing module was a trait or impl \\\n+                                debug2!(\"containing module was a trait or impl \\\n                                         and name was a method -> not resolved\");\n                                 return None;\n                             },\n@@ -4799,14 +4799,14 @@ impl Resolver {\n                                                  path.span,\n                                                  PathPublicOrPrivateSearch) {\n             Failed => {\n-                let msg = fmt!(\"use of undeclared module `::%s`\",\n-                               self.idents_to_str(module_path_idents));\n+                let msg = format!(\"use of undeclared module `::{}`\",\n+                                  self.idents_to_str(module_path_idents));\n                 self.resolve_error(path.span, msg);\n                 return None;\n             }\n \n             Indeterminate => {\n-                fail!(\"indeterminate unexpected\");\n+                fail2!(\"indeterminate unexpected\");\n             }\n \n             Success(resulting_module) => {\n@@ -4852,8 +4852,8 @@ impl Resolver {\n \n         match search_result {\n             Some(DlDef(def)) => {\n-                debug!(\"(resolving path in local ribs) resolved `%s` to \\\n-                        local: %?\",\n+                debug2!(\"(resolving path in local ribs) resolved `{}` to \\\n+                        local: {:?}\",\n                        self.session.str_of(ident),\n                        def);\n                 return Some(def);\n@@ -4913,15 +4913,15 @@ impl Resolver {\n                         return None;\n                     }\n                     Some(def) => {\n-                        debug!(\"(resolving item path in lexical scope) \\\n-                                resolved `%s` to item\",\n+                        debug2!(\"(resolving item path in lexical scope) \\\n+                                resolved `{}` to item\",\n                                self.session.str_of(ident));\n                         return Some(def);\n                     }\n                 }\n             }\n             Indeterminate => {\n-                fail!(\"unexpected indeterminate result\");\n+                fail2!(\"unexpected indeterminate result\");\n             }\n             Failed => {\n                 return None;\n@@ -5000,7 +5000,7 @@ impl Resolver {\n                 match self.resolve_path(expr.id, path, ValueNS, true) {\n                     Some(def) => {\n                         // Write the result into the def map.\n-                        debug!(\"(resolving expr) resolved `%s`\",\n+                        debug2!(\"(resolving expr) resolved `{}`\",\n                                self.path_idents_to_str(path));\n \n                         // First-class methods are not supported yet; error\n@@ -5031,11 +5031,15 @@ impl Resolver {\n                             Some(DefTy(struct_id))\n                               if self.structs.contains(&struct_id) => {\n                                 self.resolve_error(expr.span,\n-                                        fmt!(\"`%s` is a structure name, but this expression \\\n-                                            uses it like a function name\", wrong_name));\n+                                        format!(\"`{}` is a structure name, but \\\n+                                                 this expression \\\n+                                                 uses it like a function name\",\n+                                                wrong_name));\n \n-                                self.session.span_note(expr.span, fmt!(\"Did you mean to write: \\\n-                                            `%s { /* fields */ }`?\", wrong_name));\n+                                self.session.span_note(expr.span,\n+                                    format!(\"Did you mean to write: \\\n+                                            `{} \\\\{ /* fields */ \\\\}`?\",\n+                                            wrong_name));\n \n                             }\n                             _ =>\n@@ -5044,14 +5048,14 @@ impl Resolver {\n                                match self.find_best_match_for_name(wrong_name, 5) {\n                                    Some(m) => {\n                                        self.resolve_error(expr.span,\n-                                           fmt!(\"unresolved name `%s`. \\\n-                                               Did you mean `%s`?\",\n-                                               wrong_name, m));\n+                                           format!(\"unresolved name `{}`. \\\n+                                                    Did you mean `{}`?\",\n+                                                    wrong_name, m));\n                                    }\n                                    None => {\n                                        self.resolve_error(expr.span,\n-                                            fmt!(\"unresolved name `%s`.\",\n-                                                wrong_name));\n+                                            format!(\"unresolved name `{}`.\",\n+                                                    wrong_name));\n                                    }\n                                }\n                         }\n@@ -5082,10 +5086,10 @@ impl Resolver {\n                         self.record_def(expr.id, definition);\n                     }\n                     result => {\n-                        debug!(\"(resolving expression) didn't find struct \\\n-                                def: %?\", result);\n-                        let msg = fmt!(\"`%s` does not name a structure\",\n-                                       self.path_idents_to_str(path));\n+                        debug2!(\"(resolving expression) didn't find struct \\\n+                                def: {:?}\", result);\n+                        let msg = format!(\"`{}` does not name a structure\",\n+                                          self.path_idents_to_str(path));\n                         self.resolve_error(path.span, msg);\n                     }\n                 }\n@@ -5104,15 +5108,15 @@ impl Resolver {\n                 }\n             }\n \n-            ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 match self.search_ribs(self.label_ribs, label, expr.span,\n                                        DontAllowCapturingSelf) {\n                     None =>\n                         self.resolve_error(expr.span,\n-                                              fmt!(\"use of undeclared label \\\n-                                                   `%s`\",\n+                                              format!(\"use of undeclared label \\\n+                                                   `{}`\",\n                                                    interner_get(label))),\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         self.record_def(expr.id, def)\n@@ -5154,8 +5158,8 @@ impl Resolver {\n                 self.trait_map.insert(expr.id, @mut traits);\n             }\n             ExprMethodCall(_, _, ident, _, _, _) => {\n-                debug!(\"(recording candidate traits for expr) recording \\\n-                        traits for %d\",\n+                debug2!(\"(recording candidate traits for expr) recording \\\n+                        traits for {}\",\n                        expr.id);\n                 let traits = self.search_for_traits_containing_method(ident);\n                 self.trait_map.insert(expr.id, @mut traits);\n@@ -5229,7 +5233,7 @@ impl Resolver {\n \n     pub fn search_for_traits_containing_method(&mut self, name: Ident)\n                                                -> ~[DefId] {\n-        debug!(\"(searching for traits containing method) looking for '%s'\",\n+        debug2!(\"(searching for traits containing method) looking for '{}'\",\n                self.session.str_of(name));\n \n         let mut found_traits = ~[];\n@@ -5331,7 +5335,7 @@ impl Resolver {\n                           found_traits: &mut ~[DefId],\n                           trait_def_id: DefId,\n                           name: Ident) {\n-        debug!(\"(adding trait info) found trait %d:%d for method '%s'\",\n+        debug2!(\"(adding trait info) found trait {}:{} for method '{}'\",\n                trait_def_id.crate,\n                trait_def_id.node,\n                self.session.str_of(name));\n@@ -5350,14 +5354,14 @@ impl Resolver {\n     }\n \n     pub fn record_def(&mut self, node_id: NodeId, def: Def) {\n-        debug!(\"(recording def) recording %? for %?\", def, node_id);\n+        debug2!(\"(recording def) recording {:?} for {:?}\", def, node_id);\n         do self.def_map.insert_or_update_with(node_id, def) |_, old_value| {\n             // Resolve appears to \"resolve\" the same ID multiple\n             // times, so here is a sanity check it at least comes to\n             // the same conclusion! - nmatsakis\n             if def != *old_value {\n-                self.session.bug(fmt!(\"node_id %? resolved first to %? \\\n-                                      and then %?\", node_id, *old_value, def));\n+                self.session.bug(format!(\"node_id {:?} resolved first to {:?} \\\n+                                      and then {:?}\", node_id, *old_value, def));\n             }\n         };\n     }\n@@ -5371,7 +5375,7 @@ impl Resolver {\n             BindByRef(*) => {\n                 self.resolve_error(\n                     pat.span,\n-                    fmt!(\"cannot use `ref` binding mode with %s\",\n+                    format!(\"cannot use `ref` binding mode with {}\",\n                          descr));\n             }\n         }\n@@ -5459,15 +5463,15 @@ impl Resolver {\n     }\n \n     pub fn dump_module(&mut self, module_: @mut Module) {\n-        debug!(\"Dump of module `%s`:\", self.module_to_str(module_));\n+        debug2!(\"Dump of module `{}`:\", self.module_to_str(module_));\n \n-        debug!(\"Children:\");\n+        debug2!(\"Children:\");\n         self.populate_module_if_necessary(module_);\n         for (&name, _) in module_.children.iter() {\n-            debug!(\"* %s\", interner_get(name));\n+            debug2!(\"* {}\", interner_get(name));\n         }\n \n-        debug!(\"Import resolutions:\");\n+        debug2!(\"Import resolutions:\");\n         for (name, import_resolution) in module_.import_resolutions.iter() {\n             let value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n@@ -5487,7 +5491,7 @@ impl Resolver {\n                 }\n             }\n \n-            debug!(\"* %s:%s%s\", interner_get(*name),\n+            debug2!(\"* {}:{}{}\", interner_get(*name),\n                    value_repr, type_repr);\n         }\n     }"}, {"sha": "1c572b2cbadbfaa1be234e1f9b490ab377cb8bb5", "filename": "src/librustc/middle/stack_check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstack_check.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -123,20 +123,20 @@ fn stack_check_fn<'a>(v: &mut StackCheckVisitor,\n         }\n     };\n     let new_cx = Context {safe_stack: safe_stack};\n-    debug!(\"stack_check_fn(safe_stack=%b, id=%?)\", safe_stack, id);\n+    debug2!(\"stack_check_fn(safe_stack={}, id={:?})\", safe_stack, id);\n     visit::walk_fn(v, fk, decl, body, sp, id, new_cx);\n }\n \n fn stack_check_expr<'a>(v: &mut StackCheckVisitor,\n                         expr: @ast::Expr,\n                         cx: Context) {\n-    debug!(\"stack_check_expr(safe_stack=%b, expr=%s)\",\n+    debug2!(\"stack_check_expr(safe_stack={}, expr={})\",\n            cx.safe_stack, expr.repr(v.tcx));\n     if !cx.safe_stack {\n         match expr.node {\n             ast::ExprCall(callee, _, _) => {\n                 let callee_ty = ty::expr_ty(v.tcx, callee);\n-                debug!(\"callee_ty=%s\", callee_ty.repr(v.tcx));\n+                debug2!(\"callee_ty={}\", callee_ty.repr(v.tcx));\n                 match ty::get(callee_ty).sty {\n                     ty::ty_bare_fn(ref fty) => {\n                         if !fty.abis.is_rust() && !fty.abis.is_intrinsic() {\n@@ -177,6 +177,6 @@ fn call_to_extern_fn(v: &mut StackCheckVisitor, callee: @ast::Expr) {\n     v.tcx.sess.add_lint(lint::cstack,\n                          callee.id,\n                          callee.span,\n-                         fmt!(\"invoking non-Rust fn in fn without \\\n-                              #[fixed_stack_segment]\"));\n+                         format!(\"invoking non-Rust fn in fn without \\\n+                              \\\\#[fixed_stack_segment]\"));\n }"}, {"sha": "40cd693b5c109394590d79974a16ca8357a77b8a", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -183,9 +183,9 @@ impl Subst for ty::Region {\n                     ty::NonerasedRegions(ref regions) => {\n                         if regions.len() != 1 {\n                             tcx.sess.bug(\n-                                fmt!(\"ty::Region#subst(): \\\n+                                format!(\"ty::Region\\\\#subst(): \\\n                                       Reference to self region when \\\n-                                      given substs with no self region: %s\",\n+                                      given substs with no self region: {}\",\n                                      substs.repr(tcx)));\n                         }\n                         *regions.get(0)"}, {"sha": "a159512aee5b94156f70a05c65ac8a2368c3eca8", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -264,7 +264,7 @@ fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n                                 a_expr = e.unwrap();\n                             }\n                         UnitLikeStructLit(_) => {\n-                            fail!(\"UnitLikeStructLit should have been handled \\\n+                            fail2!(\"UnitLikeStructLit should have been handled \\\n                                     above\")\n                         }\n                     }\n@@ -277,14 +277,14 @@ fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n                                 b_expr = e.unwrap();\n                             }\n                         UnitLikeStructLit(_) => {\n-                            fail!(\"UnitLikeStructLit should have been handled \\\n+                            fail2!(\"UnitLikeStructLit should have been handled \\\n                                     above\")\n                         }\n                     }\n \n                     match const_eval::compare_lit_exprs(tcx, a_expr, b_expr) {\n                         Some(val1) => val1 == 0,\n-                        None => fail!(\"compare_list_exprs: type mismatch\"),\n+                        None => fail2!(\"compare_list_exprs: type mismatch\"),\n                     }\n                 }\n             }\n@@ -294,7 +294,7 @@ fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n             let m2 = const_eval::compare_lit_exprs(tcx, a2, b2);\n             match (m1, m2) {\n                 (Some(val1), Some(val2)) => (val1 == 0 && val2 == 0),\n-                _ => fail!(\"compare_list_exprs: type mismatch\"),\n+                _ => fail2!(\"compare_list_exprs: type mismatch\"),\n             }\n         }\n         (&var(a, _), &var(b, _)) => a == b,\n@@ -419,7 +419,7 @@ impl<'self> Repr for Match<'self> {\n             // for many programs, this just take too long to serialize\n             self.pats.repr(tcx)\n         } else {\n-            fmt!(\"%u pats\", self.pats.len())\n+            format!(\"{} pats\", self.pats.len())\n         }\n     }\n }\n@@ -439,7 +439,7 @@ fn expand_nested_bindings<'r>(bcx: @mut Block,\n                                   col: uint,\n                                   val: ValueRef)\n                               -> ~[Match<'r>] {\n-    debug!(\"expand_nested_bindings(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -472,7 +472,7 @@ fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::Pat) {\n     if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n         bcx.sess().span_bug(\n             p.span,\n-            fmt!(\"Expected an identifier pattern but found p: %s\",\n+            format!(\"Expected an identifier pattern but found p: {}\",\n                  p.repr(bcx.tcx())));\n     }\n }\n@@ -486,7 +486,7 @@ fn enter_match<'r>(bcx: @mut Block,\n                        val: ValueRef,\n                        e: enter_pat)\n                     -> ~[Match<'r>] {\n-    debug!(\"enter_match(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -523,7 +523,7 @@ fn enter_match<'r>(bcx: @mut Block,\n         }\n     }\n \n-    debug!(\"result=%s\", result.repr(bcx.tcx()));\n+    debug2!(\"result={}\", result.repr(bcx.tcx()));\n \n     return result;\n }\n@@ -535,7 +535,7 @@ fn enter_default<'r>(bcx: @mut Block,\n                      val: ValueRef,\n                      chk: FailureHandler)\n                       -> ~[Match<'r>] {\n-    debug!(\"enter_default(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -605,7 +605,7 @@ fn enter_opt<'r>(bcx: @mut Block,\n                      variant_size: uint,\n                      val: ValueRef)\n                   -> ~[Match<'r>] {\n-    debug!(\"enter_opt(bcx=%s, m=%s, opt=%?, col=%u, val=%s)\",\n+    debug2!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            *opt,\n@@ -741,7 +741,7 @@ fn enter_rec_or_struct<'r>(bcx: @mut Block,\n                                fields: &[ast::Ident],\n                                val: ValueRef)\n                             -> ~[Match<'r>] {\n-    debug!(\"enter_rec_or_struct(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_rec_or_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -776,7 +776,7 @@ fn enter_tup<'r>(bcx: @mut Block,\n                      val: ValueRef,\n                      n_elts: uint)\n                   -> ~[Match<'r>] {\n-    debug!(\"enter_tup(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_tup(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -802,7 +802,7 @@ fn enter_tuple_struct<'r>(bcx: @mut Block,\n                               val: ValueRef,\n                               n_elts: uint)\n                           -> ~[Match<'r>] {\n-    debug!(\"enter_tuple_struct(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_tuple_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -827,7 +827,7 @@ fn enter_box<'r>(bcx: @mut Block,\n                      col: uint,\n                      val: ValueRef)\n                  -> ~[Match<'r>] {\n-    debug!(\"enter_box(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_box(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -854,7 +854,7 @@ fn enter_uniq<'r>(bcx: @mut Block,\n                       col: uint,\n                       val: ValueRef)\n                   -> ~[Match<'r>] {\n-    debug!(\"enter_uniq(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_uniq(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -881,7 +881,7 @@ fn enter_region<'r>(bcx: @mut Block,\n                         col: uint,\n                         val: ValueRef)\n                     -> ~[Match<'r>] {\n-    debug!(\"enter_region(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug2!(\"enter_region(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -1232,7 +1232,7 @@ impl FailureHandler {\n     fn handle_fail(&self) -> BasicBlockRef {\n         match *self {\n             Infallible => {\n-                fail!(\"attempted to fail in infallible failure handler!\")\n+                fail2!(\"attempted to fail in infallible failure handler!\")\n             }\n             JumpToBasicBlock(basic_block) => basic_block,\n             CustomFailureHandlerClass(custom_failure_handler) => {\n@@ -1295,7 +1295,7 @@ fn compare_values(cx: @mut Block,\n             let scratch_rhs = alloca(cx, val_ty(rhs), \"__rhs\");\n             Store(cx, rhs, scratch_rhs);\n             let did = langcall(cx, None,\n-                               fmt!(\"comparison of `%s`\", cx.ty_to_str(rhs_t)),\n+                               format!(\"comparison of `{}`\", cx.ty_to_str(rhs_t)),\n                                UniqStrEqFnLangItem);\n             let result = callee::trans_lang_call(cx, did, [scratch_lhs, scratch_rhs], None);\n             Result {\n@@ -1305,7 +1305,7 @@ fn compare_values(cx: @mut Block,\n         }\n         ty::ty_estr(_) => {\n             let did = langcall(cx, None,\n-                               fmt!(\"comparison of `%s`\", cx.ty_to_str(rhs_t)),\n+                               format!(\"comparison of `{}`\", cx.ty_to_str(rhs_t)),\n                                StrEqFnLangItem);\n             let result = callee::trans_lang_call(cx, did, [lhs, rhs], None);\n             Result {\n@@ -1383,7 +1383,7 @@ fn insert_lllocals(bcx: @mut Block,\n             }\n         };\n \n-        debug!(\"binding %? to %s\", binding_info.id, bcx.val_to_str(llval));\n+        debug2!(\"binding {:?} to {}\", binding_info.id, bcx.val_to_str(llval));\n         llmap.insert(binding_info.id, llval);\n \n         if bcx.sess().opts.extra_debuginfo {\n@@ -1404,7 +1404,7 @@ fn compile_guard(bcx: @mut Block,\n                      vals: &[ValueRef],\n                      chk: FailureHandler)\n                   -> @mut Block {\n-    debug!(\"compile_guard(bcx=%s, guard_expr=%s, m=%s, vals=%s)\",\n+    debug2!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n            bcx.to_str(),\n            bcx.expr_to_str(guard_expr),\n            m.repr(bcx.tcx()),\n@@ -1458,7 +1458,7 @@ fn compile_submatch(bcx: @mut Block,\n                     m: &[Match],\n                     vals: &[ValueRef],\n                     chk: FailureHandler) {\n-    debug!(\"compile_submatch(bcx=%s, m=%s, vals=%s)\",\n+    debug2!(\"compile_submatch(bcx={}, m={}, vals={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            vec_map_to_str(vals, |v| bcx.val_to_str(*v)));\n@@ -1624,7 +1624,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n \n     // Decide what kind of branch we need\n     let opts = get_options(bcx, m, col);\n-    debug!(\"options=%?\", opts);\n+    debug2!(\"options={:?}\", opts);\n     let mut kind = no_branch;\n     let mut test_val = val;\n     if opts.len() > 0u {\n@@ -2113,13 +2113,13 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n      * - binding_mode: is this for an argument or a local variable?\n      */\n \n-    debug!(\"bind_irrefutable_pat(bcx=%s, pat=%s, binding_mode=%?)\",\n+    debug2!(\"bind_irrefutable_pat(bcx={}, pat={}, binding_mode={:?})\",\n            bcx.to_str(),\n            pat.repr(bcx.tcx()),\n            binding_mode);\n \n     if bcx.sess().asm_comments() {\n-        add_comment(bcx, fmt!(\"bind_irrefutable_pat(pat=%s)\",\n+        add_comment(bcx, format!(\"bind_irrefutable_pat(pat={})\",\n                               pat.repr(bcx.tcx())));\n     }\n \n@@ -2241,7 +2241,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n         ast::PatVec(*) => {\n             bcx.tcx().sess.span_bug(\n                 pat.span,\n-                fmt!(\"vector patterns are never irrefutable!\"));\n+                format!(\"vector patterns are never irrefutable!\"));\n         }\n         ast::PatWild | ast::PatLit(_) | ast::PatRange(_, _) => ()\n     }"}, {"sha": "0fdbc04a6c1e058b72732e16eebf4291cec12671", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -113,13 +113,13 @@ pub fn represent_node(bcx: @mut Block, node: ast::NodeId) -> @Repr {\n \n /// Decides how to represent a given type.\n pub fn represent_type(cx: &mut CrateContext, t: ty::t) -> @Repr {\n-    debug!(\"Representing: %s\", ty_to_str(cx.tcx, t));\n+    debug2!(\"Representing: {}\", ty_to_str(cx.tcx, t));\n     match cx.adt_reprs.find(&t) {\n         Some(repr) => return *repr,\n         None => { }\n     }\n     let repr = @represent_type_uncached(cx, t);\n-    debug!(\"Represented as: %?\", repr)\n+    debug2!(\"Represented as: {:?}\", repr)\n     cx.adt_reprs.insert(t, repr);\n     return repr;\n }\n@@ -179,7 +179,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n             if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n-                cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n+                cx.sess.bug(format!(\"non-C-like enum {} with specified \\\n                                   discriminants\",\n                                  ty::item_path_str(cx.tcx, def_id)))\n             }"}, {"sha": "4a960b1721d2d5d49412416fd424f528c45a3c1b", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -47,7 +47,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n \n         let e = match out.node {\n             ast::ExprAddrOf(_, e) => e,\n-            _ => fail!(\"Expression must be addr of\")\n+            _ => fail2!(\"Expression must be addr of\")\n         };\n \n         unpack_result!(bcx, {\n@@ -89,7 +89,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n \n     let mut clobbers = getClobbers();\n     if !ia.clobbers.is_empty() && !clobbers.is_empty() {\n-        clobbers = fmt!(\"%s,%s\", ia.clobbers, clobbers);\n+        clobbers = format!(\"{},{}\", ia.clobbers, clobbers);\n     } else {\n         clobbers.push_str(ia.clobbers);\n     };\n@@ -102,7 +102,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n         constraints.push_str(clobbers);\n     }\n \n-    debug!(\"Asm Constraints: %?\", constraints);\n+    debug2!(\"Asm Constraints: {:?}\", constraints);\n \n     let numOutputs = outputs.len();\n "}, {"sha": "3a35f144ab50423062e5511f6766b1e4731f5dfc", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -351,7 +351,7 @@ pub fn malloc_raw_dyn(bcx: @mut Block,\n         match li.require(it) {\n             Ok(id) => id,\n             Err(s) => {\n-                bcx.tcx().sess.fatal(fmt!(\"allocation of `%s` %s\",\n+                bcx.tcx().sess.fatal(format!(\"allocation of `{}` {}\",\n                                           bcx.ty_to_str(t), s));\n             }\n         }\n@@ -379,7 +379,7 @@ pub fn malloc_raw_dyn(bcx: @mut Block,\n                 (ty::mk_imm_box,\n                  require_alloc_fn(bcx, t, ClosureExchangeMallocFnLangItem))\n             }\n-            _ => fail!(\"heap_exchange already handled\")\n+            _ => fail2!(\"heap_exchange already handled\")\n         };\n \n         // Grab the TypeRef type of box_ptr_ty.\n@@ -911,20 +911,18 @@ pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef],\n     }\n \n     match bcx.node_info {\n-        None => debug!(\"invoke at ???\"),\n+        None => debug2!(\"invoke at ???\"),\n         Some(node_info) => {\n-            debug!(\"invoke at %s\",\n+            debug2!(\"invoke at {}\",\n                    bcx.sess().codemap.span_to_str(node_info.span));\n         }\n     }\n \n     if need_invoke(bcx) {\n         unsafe {\n-            debug!(\"invoking %x at %x\",\n-                   ::std::cast::transmute(llfn),\n-                   ::std::cast::transmute(bcx.llbb));\n+            debug2!(\"invoking {} at {}\", llfn, bcx.llbb);\n             for &llarg in llargs.iter() {\n-                debug!(\"arg: %x\", ::std::cast::transmute(llarg));\n+                debug2!(\"arg: {}\", llarg);\n             }\n         }\n         let normal_bcx = sub_block(bcx, \"normal return\");\n@@ -937,11 +935,9 @@ pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef],\n         return (llresult, normal_bcx);\n     } else {\n         unsafe {\n-            debug!(\"calling %x at %x\",\n-                   ::std::cast::transmute(llfn),\n-                   ::std::cast::transmute(bcx.llbb));\n+            debug2!(\"calling {} at {}\", llfn, bcx.llbb);\n             for &llarg in llargs.iter() {\n-                debug!(\"arg: %x\", ::std::cast::transmute(llarg));\n+                debug2!(\"arg: {}\", llarg);\n             }\n         }\n         let llresult = Call(bcx, llfn, llargs, attributes);\n@@ -1092,7 +1088,7 @@ pub fn find_bcx_for_scope(bcx: @mut Block, scope_id: ast::NodeId) -> @mut Block\n             }\n             None => {\n                 bcx_sid = match bcx_sid.parent {\n-                    None => bcx.tcx().sess.bug(fmt!(\"no enclosing scope with id %d\", scope_id)),\n+                    None => bcx.tcx().sess.bug(format!(\"no enclosing scope with id {}\", scope_id)),\n                     Some(bcx_par) => bcx_par\n                 };\n                 bcx_sid.scope\n@@ -1161,7 +1157,7 @@ pub fn ignore_lhs(_bcx: @mut Block, local: &ast::Local) -> bool {\n \n pub fn init_local(bcx: @mut Block, local: &ast::Local) -> @mut Block {\n \n-    debug!(\"init_local(bcx=%s, local.id=%?)\",\n+    debug2!(\"init_local(bcx={}, local.id={:?})\",\n            bcx.to_str(), local.id);\n     let _indenter = indenter();\n \n@@ -1182,7 +1178,7 @@ pub fn init_local(bcx: @mut Block, local: &ast::Local) -> @mut Block {\n \n pub fn trans_stmt(cx: @mut Block, s: &ast::Stmt) -> @mut Block {\n     let _icx = push_ctxt(\"trans_stmt\");\n-    debug!(\"trans_stmt(%s)\", stmt_to_str(s, cx.tcx().sess.intr()));\n+    debug2!(\"trans_stmt({})\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n     if cx.sess().asm_comments() {\n         add_span_comment(cx, s.span, stmt_to_str(s, cx.ccx().sess.intr()));\n@@ -1345,12 +1341,12 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n     let mut bcx = bcx;\n     let is_lpad = leave == None;\n     loop {\n-        debug!(\"cleanup_and_leave: leaving %s\", cur.to_str());\n+        debug2!(\"cleanup_and_leave: leaving {}\", cur.to_str());\n \n         if bcx.sess().trace() {\n             trans_trace(\n                 bcx, None,\n-                (fmt!(\"cleanup_and_leave(%s)\", cur.to_str())).to_managed());\n+                (format!(\"cleanup_and_leave({})\", cur.to_str())).to_managed());\n         }\n \n         let mut cur_scope = cur.scope;\n@@ -1419,12 +1415,12 @@ pub fn cleanup_block(bcx: @mut Block, upto: Option<BasicBlockRef>) -> @mut Block\n     let mut cur = bcx;\n     let mut bcx = bcx;\n     loop {\n-        debug!(\"cleanup_block: %s\", cur.to_str());\n+        debug2!(\"cleanup_block: {}\", cur.to_str());\n \n         if bcx.sess().trace() {\n             trans_trace(\n                 bcx, None,\n-                (fmt!(\"cleanup_block(%s)\", cur.to_str())).to_managed());\n+                (format!(\"cleanup_block({})\", cur.to_str())).to_managed());\n         }\n \n         let mut cur_scope = cur.scope;\n@@ -1469,7 +1465,7 @@ pub fn with_scope(bcx: @mut Block,\n                   f: &fn(@mut Block) -> @mut Block) -> @mut Block {\n     let _icx = push_ctxt(\"with_scope\");\n \n-    debug!(\"with_scope(bcx=%s, opt_node_info=%?, name=%s)\",\n+    debug2!(\"with_scope(bcx={}, opt_node_info={:?}, name={})\",\n            bcx.to_str(), opt_node_info, name);\n     let _indenter = indenter();\n \n@@ -1599,7 +1595,7 @@ pub fn alloc_ty(bcx: @mut Block, t: ty::t, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n-    assert!(!ty::type_has_params(t), \"Type has params: %s\", ty_to_str(ccx.tcx, t));\n+    assert!(!ty::type_has_params(t));\n     let val = alloca(bcx, ty, name);\n     return val;\n }\n@@ -1688,8 +1684,8 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                      -> @mut FunctionContext {\n     for p in param_substs.iter() { p.validate(); }\n \n-    debug!(\"new_fn_ctxt_w_id(path=%s, id=%?, \\\n-            param_substs=%s)\",\n+    debug2!(\"new_fn_ctxt_w_id(path={}, id={:?}, \\\n+            param_substs={})\",\n            path_str(ccx.sess, path),\n            id,\n            param_substs.repr(ccx.tcx));\n@@ -1802,7 +1798,7 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n                             args: &[ast::arg],\n                             raw_llargs: &[ValueRef],\n                             arg_tys: &[ty::t]) -> @mut Block {\n-    debug!(\"copy_args_to_allocas: raw_llargs=%s arg_tys=%s\",\n+    debug2!(\"copy_args_to_allocas: raw_llargs={} arg_tys={}\",\n            raw_llargs.llrepr(fcx.ccx),\n            arg_tys.repr(fcx.ccx.tcx));\n \n@@ -1926,7 +1922,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     let _icx = push_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n \n-    debug!(\"trans_closure(..., param_substs=%s)\",\n+    debug2!(\"trans_closure(..., param_substs={})\",\n            param_substs.repr(ccx.tcx));\n \n     let fcx = new_fn_ctxt_w_id(ccx,\n@@ -2006,7 +2002,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n \n     let the_path_str = path_str(ccx.sess, path);\n     let _s = StatRecorder::new(ccx, the_path_str);\n-    debug!(\"trans_fn(self_arg=%?, param_substs=%s)\",\n+    debug2!(\"trans_fn(self_arg={:?}, param_substs={})\",\n            self_arg,\n            param_substs.repr(ccx.tcx));\n     let _icx = push_ctxt(\"trans_fn\");\n@@ -2042,7 +2038,7 @@ fn insert_synthetic_type_entries(bcx: @mut Block,\n \n     let tcx = bcx.tcx();\n     for i in range(0u, fn_args.len()) {\n-        debug!(\"setting type of argument %u (pat node %d) to %s\",\n+        debug2!(\"setting type of argument {} (pat node {}) to {}\",\n                i, fn_args[i].pat.id, bcx.ty_to_str(arg_tys[i]));\n \n         let pat_id = fn_args[i].pat.id;\n@@ -2141,8 +2137,8 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     let result_ty = match ty::get(ctor_ty).sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output,\n         _ => ccx.sess.bug(\n-            fmt!(\"trans_enum_variant_or_tuple_like_struct: \\\n-                  unexpected ctor return type %s\",\n+            format!(\"trans_enum_variant_or_tuple_like_struct: \\\n+                  unexpected ctor return type {}\",\n                  ty_to_str(ccx.tcx, ctor_ty)))\n     };\n \n@@ -2218,7 +2214,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n     let path = match ccx.tcx.items.get_copy(&item.id) {\n         ast_map::node_item(_, p) => p,\n         // tjc: ?\n-        _ => fail!(\"trans_item\"),\n+        _ => fail2!(\"trans_item\"),\n     };\n     match item.node {\n       ast::item_fn(ref decl, purity, _abis, ref generics, ref body) => {\n@@ -2360,7 +2356,7 @@ pub fn register_fn(ccx: @mut CrateContext,\n             assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n             f\n         }\n-        _ => fail!(\"expected bare rust fn or an intrinsic\")\n+        _ => fail2!(\"expected bare rust fn or an intrinsic\")\n     };\n \n     let llfn = decl_rust_fn(ccx, f.sig.inputs, f.sig.output, sym);\n@@ -2376,7 +2372,7 @@ pub fn register_fn_llvmty(ccx: @mut CrateContext,\n                           cc: lib::llvm::CallConv,\n                           fn_ty: Type)\n                           -> ValueRef {\n-    debug!(\"register_fn_fuller creating fn for item %d with path %s\",\n+    debug2!(\"register_fn_fuller creating fn for item {} with path {}\",\n            node_id,\n            ast_map::path_to_str(item_path(ccx, &node_id), token::get_ident_interner()));\n \n@@ -2455,7 +2451,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 };\n                 (start_fn, args)\n             } else {\n-                debug!(\"using user-defined start fn\");\n+                debug2!(\"using user-defined start fn\");\n                 let args = ~[\n                     C_null(Type::opaque_box(ccx).ptr_to()),\n                     llvm::LLVMGetParam(llfn, 0 as c_uint),\n@@ -2503,7 +2499,7 @@ fn exported_name(ccx: &mut CrateContext, path: path, ty: ty::t, attrs: &[ast::At\n }\n \n pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n-    debug!(\"get_item_val(id=`%?`)\", id);\n+    debug2!(\"get_item_val(id=`{:?}`)\", id);\n \n     let val = ccx.item_vals.find_copy(&id);\n     match val {\n@@ -2525,10 +2521,10 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             // we need to get the symbol from csearch instead of\n                             // using the current crate's name/version\n                             // information in the hash of the symbol\n-                            debug!(\"making %s\", sym);\n+                            debug2!(\"making {}\", sym);\n                             let sym = match ccx.external_srcs.find(&i.id) {\n                                 Some(&did) => {\n-                                    debug!(\"but found in other crate...\");\n+                                    debug2!(\"but found in other crate...\");\n                                     csearch::get_symbol(ccx.sess.cstore, did)\n                                 }\n                                 None => sym\n@@ -2579,7 +2575,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                                 }\n \n                                 if !inlineable {\n-                                    debug!(\"%s not inlined\", sym);\n+                                    debug2!(\"{} not inlined\", sym);\n                                     ccx.non_inlineable_statics.insert(id);\n                                 }\n                                 ccx.item_symbols.insert(i.id, sym);\n@@ -2600,7 +2596,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             llfn\n                         }\n \n-                        _ => fail!(\"get_item_val: weird result in table\")\n+                        _ => fail2!(\"get_item_val: weird result in table\")\n                     };\n \n                     match (attr::first_attr_value_str_by_name(i.attrs, \"link_section\")) {\n@@ -2616,7 +2612,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n \n                 ast_map::node_trait_method(trait_method, _, pth) => {\n-                    debug!(\"get_item_val(): processing a node_trait_method\");\n+                    debug2!(\"get_item_val(): processing a node_trait_method\");\n                     match *trait_method {\n                         ast::required(_) => {\n                             ccx.sess.bug(\"unexpected variant: required trait method in \\\n@@ -2673,11 +2669,11 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                                 ast::item_enum(_, _) => {\n                                     register_fn(ccx, (*v).span, sym, id, ty)\n                                 }\n-                                _ => fail!(\"node_variant, shouldn't happen\")\n+                                _ => fail2!(\"node_variant, shouldn't happen\")\n                             };\n                         }\n                         ast::struct_variant_kind(_) => {\n-                            fail!(\"struct variant kind unexpected in get_item_val\")\n+                            fail2!(\"struct variant kind unexpected in get_item_val\")\n                         }\n                     }\n                     set_inline_hint(llfn);\n@@ -2704,7 +2700,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n \n                 ref variant => {\n-                    ccx.sess.bug(fmt!(\"get_item_val(): unexpected variant: %?\",\n+                    ccx.sess.bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n                                  variant))\n                 }\n             };\n@@ -2959,7 +2955,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     let cstore = sess.cstore;\n     while cstore::have_crate_data(cstore, n_subcrates) { n_subcrates += 1; }\n     let mapname = if *sess.building_library {\n-        fmt!(\"%s_%s_%s\", mapmeta.name, mapmeta.vers, mapmeta.extras_hash)\n+        format!(\"{}_{}_{}\", mapmeta.name, mapmeta.vers, mapmeta.extras_hash)\n     } else {\n         ~\"toplevel\"\n     };\n@@ -2988,7 +2984,7 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n     let cstore = ccx.sess.cstore;\n     while cstore::have_crate_data(cstore, i) {\n         let cdata = cstore::get_crate_data(cstore, i);\n-        let nm = fmt!(\"_rust_crate_map_%s_%s_%s\",\n+        let nm = format!(\"_rust_crate_map_{}_{}_{}\",\n                       cdata.name,\n                       cstore::get_crate_vers(cstore, i),\n                       cstore::get_crate_hash(cstore, i));"}, {"sha": "1754741a1f4fe86a0f4238c075a7e86a96455c79", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -29,7 +29,7 @@ pub fn terminate(cx: &mut Block, _: &str) {\n \n pub fn check_not_terminated(cx: &Block) {\n     if cx.terminated {\n-        fail!(\"already terminated!\");\n+        fail2!(\"already terminated!\");\n     }\n }\n \n@@ -117,7 +117,7 @@ pub fn Invoke(cx: @mut Block,\n     }\n     check_not_terminated(cx);\n     terminate(cx, \"Invoke\");\n-    debug!(\"Invoke(%s with arguments (%s))\",\n+    debug2!(\"Invoke({} with arguments ({}))\",\n            cx.val_to_str(Fn),\n            Args.map(|a| cx.val_to_str(*a)).connect(\", \"));\n     B(cx).invoke(Fn, Args, Then, Catch, attributes)"}, {"sha": "febe4de730da7188617e8b7d1a7445279c036966", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -476,7 +476,7 @@ impl Builder {\n     }\n \n     pub fn store(&self, val: ValueRef, ptr: ValueRef) {\n-        debug!(\"Store %s -> %s\",\n+        debug2!(\"Store {} -> {}\",\n                self.ccx.tn.val_to_str(val),\n                self.ccx.tn.val_to_str(ptr));\n         assert!(is_not_null(self.llbuilder));\n@@ -487,7 +487,7 @@ impl Builder {\n     }\n \n     pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n-        debug!(\"Store %s -> %s\",\n+        debug2!(\"Store {} -> {}\",\n                self.ccx.tn.val_to_str(val),\n                self.ccx.tn.val_to_str(ptr));\n         self.count_insn(\"store.atomic\");\n@@ -725,16 +725,16 @@ impl Builder {\n \n     pub fn add_span_comment(&self, sp: Span, text: &str) {\n         if self.ccx.sess.asm_comments() {\n-            let s = fmt!(\"%s (%s)\", text, self.ccx.sess.codemap.span_to_str(sp));\n-            debug!(\"%s\", s);\n+            let s = format!(\"{} ({})\", text, self.ccx.sess.codemap.span_to_str(sp));\n+            debug2!(\"{}\", s);\n             self.add_comment(s);\n         }\n     }\n \n     pub fn add_comment(&self, text: &str) {\n         if self.ccx.sess.asm_comments() {\n             let sanitized = text.replace(\"$\", \"\");\n-            let comment_text = fmt!(\"# %s\", sanitized.replace(\"\\n\", \"\\n\\t# \"));\n+            let comment_text = format!(\"\\\\# {}\", sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n             let asm = do comment_text.with_c_str |c| {\n                 unsafe {\n@@ -758,11 +758,11 @@ impl Builder {\n                          else          { lib::llvm::False };\n \n         let argtys = do inputs.map |v| {\n-            debug!(\"Asm Input Type: %?\", self.ccx.tn.val_to_str(*v));\n+            debug2!(\"Asm Input Type: {:?}\", self.ccx.tn.val_to_str(*v));\n             val_ty(*v)\n         };\n \n-        debug!(\"Asm Output Type: %?\", self.ccx.tn.type_to_str(output));\n+        debug2!(\"Asm Output Type: {:?}\", self.ccx.tn.type_to_str(output));\n         let fty = Type::func(argtys, &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm("}, {"sha": "2cba0615310f71c8e3a1f9a6dd5ebed6b8adfe04", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -49,7 +49,7 @@ fn ty_align(ty: Type) -> uint {\n             let elt = ty.element_type();\n             ty_align(elt)\n         }\n-        _ => fail!(\"ty_align: unhandled type\")\n+        _ => fail2!(\"ty_align: unhandled type\")\n     }\n }\n \n@@ -79,7 +79,7 @@ fn ty_size(ty: Type) -> uint {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => fail!(\"ty_size: unhandled type\")\n+        _ => fail2!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "3d11c3dafb2e9ca8e30a3b803a4af4b936313a8b", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -51,7 +51,7 @@ fn ty_align(ty: Type) -> uint {\n             let elt = ty.element_type();\n             ty_align(elt)\n         }\n-        _ => fail!(\"ty_size: unhandled type\")\n+        _ => fail2!(\"ty_size: unhandled type\")\n     }\n }\n \n@@ -81,7 +81,7 @@ fn ty_size(ty: Type) -> uint {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => fail!(\"ty_size: unhandled type\")\n+        _ => fail2!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "9f098fe3cc116ffab71e886cb3d2e41738588106", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -112,7 +112,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                 let elt = ty.element_type();\n                 ty_align(elt)\n             }\n-            _ => fail!(\"ty_size: unhandled type\")\n+            _ => fail2!(\"ty_size: unhandled type\")\n         }\n     }\n \n@@ -141,7 +141,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                 let eltsz = ty_size(elt);\n                 len * eltsz\n             }\n-            _ => fail!(\"ty_size: unhandled type\")\n+            _ => fail2!(\"ty_size: unhandled type\")\n         }\n     }\n \n@@ -232,7 +232,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                     i += 1u;\n                 }\n             }\n-            _ => fail!(\"classify: unhandled type\")\n+            _ => fail2!(\"classify: unhandled type\")\n         }\n     }\n \n@@ -325,7 +325,7 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n             SSEDs => {\n                 tys.push(Type::f64());\n             }\n-            _ => fail!(\"llregtype: unhandled class\")\n+            _ => fail2!(\"llregtype: unhandled class\")\n         }\n         i += 1u;\n     }"}, {"sha": "c1a9f7649626ad077cc182d46131b15489059389", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -79,7 +79,7 @@ pub struct Callee {\n \n pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n     let _icx = push_ctxt(\"trans_callee\");\n-    debug!(\"callee::trans(expr=%s)\", expr.repr(bcx.tcx()));\n+    debug2!(\"callee::trans(expr={})\", expr.repr(bcx.tcx()));\n \n     // pick out special kinds of expressions that can be called:\n     match expr.node {\n@@ -105,7 +105,7 @@ pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n             _ => {\n                 bcx.tcx().sess.span_bug(\n                     expr.span,\n-                    fmt!(\"Type of callee is neither bare-fn nor closure: %s\",\n+                    format!(\"Type of callee is neither bare-fn nor closure: {}\",\n                          bcx.ty_to_str(datum.ty)));\n             }\n         }\n@@ -153,7 +153,7 @@ pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n             ast::DefSelfTy(*) | ast::DefMethod(*) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n-                    fmt!(\"Cannot translate def %? \\\n+                    format!(\"Cannot translate def {:?} \\\n                           to a callable thing!\", def));\n             }\n         }\n@@ -180,7 +180,7 @@ pub fn trans_fn_ref(bcx: @mut Block,\n \n     let type_params = node_id_type_params(bcx, ref_id);\n     let vtables = node_vtables(bcx, ref_id);\n-    debug!(\"trans_fn_ref(def_id=%s, ref_id=%?, type_params=%s, vtables=%s)\",\n+    debug2!(\"trans_fn_ref(def_id={}, ref_id={:?}, type_params={}, vtables={})\",\n            def_id.repr(bcx.tcx()), ref_id, type_params.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));\n     trans_fn_ref_with_vtables(bcx, def_id, ref_id, type_params, vtables)\n@@ -266,8 +266,8 @@ pub fn trans_fn_ref_with_vtables(\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n-    debug!(\"trans_fn_ref_with_vtables(bcx=%s, def_id=%s, ref_id=%?, \\\n-            type_params=%s, vtables=%s)\",\n+    debug2!(\"trans_fn_ref_with_vtables(bcx={}, def_id={}, ref_id={:?}, \\\n+            type_params={}, vtables={})\",\n            bcx.to_str(),\n            def_id.repr(bcx.tcx()),\n            ref_id,\n@@ -329,11 +329,11 @@ pub fn trans_fn_ref_with_vtables(\n                 resolve_default_method_vtables(bcx, impl_id,\n                                                method, &substs, vtables);\n \n-            debug!(\"trans_fn_with_vtables - default method: \\\n-                    substs = %s, trait_subst = %s, \\\n-                    first_subst = %s, new_subst = %s, \\\n-                    vtables = %s, \\\n-                    self_vtable = %s, param_vtables = %s\",\n+            debug2!(\"trans_fn_with_vtables - default method: \\\n+                    substs = {}, trait_subst = {}, \\\n+                    first_subst = {}, new_subst = {}, \\\n+                    vtables = {}, \\\n+                    self_vtable = {}, param_vtables = {}\",\n                    substs.repr(tcx), trait_ref.substs.repr(tcx),\n                    first_subst.repr(tcx), new_substs.repr(tcx),\n                    vtables.repr(tcx),\n@@ -365,7 +365,7 @@ pub fn trans_fn_ref_with_vtables(\n         let map_node = session::expect(\n             ccx.sess,\n             ccx.tcx.items.find(&def_id.node),\n-            || fmt!(\"local item should be in ast map\"));\n+            || format!(\"local item should be in ast map\"));\n \n         match *map_node {\n             ast_map::node_foreign_item(_, abis, _, _) => {\n@@ -472,7 +472,7 @@ pub fn trans_method_call(in_cx: @mut Block,\n                          dest: expr::Dest)\n                          -> @mut Block {\n     let _icx = push_ctxt(\"trans_method_call\");\n-    debug!(\"trans_method_call(call_ex=%s, rcvr=%s)\",\n+    debug2!(\"trans_method_call(call_ex={}, rcvr={})\",\n            call_ex.repr(in_cx.tcx()),\n            rcvr.repr(in_cx.tcx()));\n     trans_call_inner(\n@@ -483,7 +483,7 @@ pub fn trans_method_call(in_cx: @mut Block,\n         |cx| {\n             match cx.ccx().maps.method_map.find_copy(&call_ex.id) {\n                 Some(origin) => {\n-                    debug!(\"origin for %s: %s\",\n+                    debug2!(\"origin for {}: {}\",\n                            call_ex.repr(in_cx.tcx()),\n                            origin.repr(in_cx.tcx()));\n \n@@ -562,7 +562,7 @@ pub fn trans_lang_call_with_type_params(bcx: @mut Block,\n                                                       substituted);\n                     new_llval = PointerCast(callee.bcx, fn_data.llfn, llfnty);\n                 }\n-                _ => fail!()\n+                _ => fail2!()\n             }\n             Callee { bcx: callee.bcx, data: Fn(FnData { llfn: new_llval }) }\n         },\n@@ -840,7 +840,7 @@ pub fn trans_arg_expr(bcx: @mut Block,\n     let _icx = push_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_expr(formal_arg_ty=(%s), self_mode=%?, arg_expr=%s)\",\n+    debug2!(\"trans_arg_expr(formal_arg_ty=({}), self_mode={:?}, arg_expr={})\",\n            formal_arg_ty.repr(bcx.tcx()),\n            self_mode,\n            arg_expr.repr(bcx.tcx()));\n@@ -850,7 +850,7 @@ pub fn trans_arg_expr(bcx: @mut Block,\n     let arg_datum = arg_datumblock.datum;\n     let bcx = arg_datumblock.bcx;\n \n-    debug!(\"   arg datum: %s\", arg_datum.to_str(bcx.ccx()));\n+    debug2!(\"   arg datum: {}\", arg_datum.to_str(bcx.ccx()));\n \n     let mut val;\n     if ty::type_is_bot(arg_datum.ty) {\n@@ -890,11 +890,11 @@ pub fn trans_arg_expr(bcx: @mut Block,\n \n                 val = match self_mode {\n                     ty::ByRef => {\n-                        debug!(\"by ref arg with type %s\", bcx.ty_to_str(arg_datum.ty));\n+                        debug2!(\"by ref arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n                         arg_datum.to_ref_llval(bcx)\n                     }\n                     ty::ByCopy => {\n-                        debug!(\"by copy arg with type %s\", bcx.ty_to_str(arg_datum.ty));\n+                        debug2!(\"by copy arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n                         arg_datum.to_appropriate_llval(bcx)\n                     }\n                 }\n@@ -904,12 +904,12 @@ pub fn trans_arg_expr(bcx: @mut Block,\n         if formal_arg_ty != arg_datum.ty {\n             // this could happen due to e.g. subtyping\n             let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n-            debug!(\"casting actual type (%s) to match formal (%s)\",\n+            debug2!(\"casting actual type ({}) to match formal ({})\",\n                    bcx.val_to_str(val), bcx.llty_str(llformal_arg_ty));\n             val = PointerCast(bcx, val, llformal_arg_ty);\n         }\n     }\n \n-    debug!(\"--- trans_arg_expr passing %s\", bcx.val_to_str(val));\n+    debug2!(\"--- trans_arg_expr passing {}\", bcx.val_to_str(val));\n     return rslt(bcx, val);\n }"}, {"sha": "875be5d3af54a69091370e4a5e5cb41625c43863", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -127,7 +127,7 @@ impl EnvAction {\n \n impl EnvValue {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        fmt!(\"%s(%s)\", self.action.to_str(), self.datum.to_str(ccx))\n+        format!(\"{}({})\", self.action.to_str(), self.datum.to_str(ccx))\n     }\n }\n \n@@ -151,7 +151,7 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n         }\n     });\n     let cdata_ty = ty::mk_tup(tcx, bound_tys);\n-    debug!(\"cdata_ty=%s\", ty_to_str(tcx, cdata_ty));\n+    debug2!(\"cdata_ty={}\", ty_to_str(tcx, cdata_ty));\n     return cdata_ty;\n }\n \n@@ -224,15 +224,15 @@ pub fn store_environment(bcx: @mut Block,\n     let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, sigil, cdata_ty);\n \n     let llbox = PointerCast(bcx, llbox, llboxptr_ty);\n-    debug!(\"tuplify_box_ty = %s\", ty_to_str(tcx, cbox_ty));\n+    debug2!(\"tuplify_box_ty = {}\", ty_to_str(tcx, cbox_ty));\n \n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n     for (i, bv) in bound_values.iter().enumerate() {\n-        debug!(\"Copy %s into closure\", bv.to_str(ccx));\n+        debug2!(\"Copy {} into closure\", bv.to_str(ccx));\n \n         if ccx.sess.asm_comments() {\n-            add_comment(bcx, fmt!(\"Copy %s into closure\",\n+            add_comment(bcx, format!(\"Copy {} into closure\",\n                                   bv.to_str(ccx)));\n         }\n \n@@ -268,7 +268,7 @@ pub fn build_closure(bcx0: @mut Block,\n     // Package up the captured upvars\n     let mut env_vals = ~[];\n     for cap_var in cap_vars.iter() {\n-        debug!(\"Building closure: captured variable %?\", *cap_var);\n+        debug2!(\"Building closure: captured variable {:?}\", *cap_var);\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n             moves::CapRef => {\n@@ -384,7 +384,7 @@ pub fn trans_expr_fn(bcx: @mut Block,\n     let fty = node_id_type(bcx, outer_id);\n     let f = match ty::get(fty).sty {\n         ty::ty_closure(ref f) => f,\n-        _ => fail!(\"expected closure\")\n+        _ => fail2!(\"expected closure\")\n     };\n \n     let sub_path = vec::append_one(bcx.fcx.path.clone(),"}, {"sha": "4d46ae385eb2fec791d1aa117b8b6f4c30684db1", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -169,7 +169,7 @@ impl param_substs {\n }\n \n fn param_substs_to_str(this: &param_substs, tcx: ty::ctxt) -> ~str {\n-    fmt!(\"param_substs {tys:%s, vtables:%s}\",\n+    format!(\"param_substs \\\\{tys:{}, vtables:{}\\\\}\",\n          this.tys.repr(tcx),\n          this.vtables.repr(tcx))\n }\n@@ -436,7 +436,7 @@ pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n         return\n     }\n \n-    debug!(\"add_clean(%s, %s, %s)\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n+    debug2!(\"add_clean({}, {}, {})\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n \n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx, None) |scope_info| {\n@@ -451,7 +451,7 @@ pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n \n pub fn add_clean_temp_immediate(cx: @mut Block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n-    debug!(\"add_clean_temp_immediate(%s, %s, %s)\",\n+    debug2!(\"add_clean_temp_immediate({}, {}, {})\",\n            cx.to_str(), cx.val_to_str(val),\n            ty.repr(cx.tcx()));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n@@ -480,7 +480,7 @@ pub fn add_clean_temp_mem_in_scope(bcx: @mut Block,\n pub fn add_clean_temp_mem_in_scope_(bcx: @mut Block, scope_id: Option<ast::NodeId>,\n                                     val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n-    debug!(\"add_clean_temp_mem(%s, %s, %s)\",\n+    debug2!(\"add_clean_temp_mem({}, {}, {})\",\n            bcx.to_str(), bcx.val_to_str(val),\n            t.repr(bcx.tcx()));\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n@@ -509,7 +509,7 @@ pub fn add_clean_return_to_mut(bcx: @mut Block,\n     //! box was frozen initially. Here, both `frozen_val_ref` and\n     //! `bits_val_ref` are in fact pointers to stack slots.\n \n-    debug!(\"add_clean_return_to_mut(%s, %s, %s)\",\n+    debug2!(\"add_clean_return_to_mut({}, {}, {})\",\n            bcx.to_str(),\n            bcx.val_to_str(frozen_val_ref),\n            bcx.val_to_str(bits_val_ref));\n@@ -705,8 +705,8 @@ impl Block {\n         match self.tcx().def_map.find(&nid) {\n             Some(&v) => v,\n             None => {\n-                self.tcx().sess.bug(fmt!(\n-                    \"No def associated with node id %?\", nid));\n+                self.tcx().sess.bug(format!(\n+                    \"No def associated with node id {:?}\", nid));\n             }\n         }\n     }\n@@ -726,8 +726,8 @@ impl Block {\n     pub fn to_str(&self) -> ~str {\n         unsafe {\n             match self.node_info {\n-                Some(node_info) => fmt!(\"[block %d]\", node_info.id),\n-                None => fmt!(\"[block %x]\", transmute(&*self)),\n+                Some(node_info) => format!(\"[block {}]\", node_info.id),\n+                None => format!(\"[block {}]\", transmute::<&Block, *Block>(self)),\n             }\n         }\n     }\n@@ -763,15 +763,15 @@ pub fn in_scope_cx(cx: @mut Block, scope_id: Option<ast::NodeId>, f: &fn(si: &mu\n             Some(inf) => match scope_id {\n                 Some(wanted) => match inf.node_info {\n                     Some(NodeInfo { id: actual, _ }) if wanted == actual => {\n-                        debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n+                        debug2!(\"in_scope_cx: selected cur={} (cx={})\",\n                                cur.to_str(), cx.to_str());\n                         f(inf);\n                         return;\n                     },\n                     _ => inf.parent,\n                 },\n                 None => {\n-                    debug!(\"in_scope_cx: selected cur=%s (cx=%s)\",\n+                    debug2!(\"in_scope_cx: selected cur={} (cx={})\",\n                            cur.to_str(), cx.to_str());\n                     f(inf);\n                     return;\n@@ -788,7 +788,7 @@ pub fn in_scope_cx(cx: @mut Block, scope_id: Option<ast::NodeId>, f: &fn(si: &mu\n pub fn block_parent(cx: @mut Block) -> @mut Block {\n     match cx.parent {\n       Some(b) => b,\n-      None    => cx.sess().bug(fmt!(\"block_parent called on root block %?\",\n+      None    => cx.sess().bug(format!(\"block_parent called on root block {:?}\",\n                                    cx))\n     }\n }\n@@ -881,7 +881,7 @@ pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n         };\n \n         let gsym = token::gensym(\"str\");\n-        let g = do fmt!(\"str%u\", gsym).with_c_str |buf| {\n+        let g = do format!(\"str{}\", gsym).with_c_str |buf| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(sc).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(g, sc);\n@@ -964,7 +964,7 @@ pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n             llvm::LLVMConstExtractValue(v, p, len as c_uint)\n         };\n \n-        debug!(\"const_get_elt(v=%s, us=%?, r=%s)\",\n+        debug2!(\"const_get_elt(v={}, us={:?}, r={})\",\n                cx.tn.val_to_str(v), us, cx.tn.val_to_str(r));\n \n         return r;\n@@ -1115,7 +1115,7 @@ pub fn node_id_type_params(bcx: &mut Block, id: ast::NodeId) -> ~[ty::t] {\n \n     if !params.iter().all(|t| !ty::type_needs_infer(*t)) {\n         bcx.sess().bug(\n-            fmt!(\"Type parameters for node %d include inference types: %s\",\n+            format!(\"Type parameters for node {} include inference types: {}\",\n                  id, params.map(|t| bcx.ty_to_str(*t)).connect(\",\")));\n     }\n \n@@ -1193,7 +1193,7 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n                     find_vtable(tcx, substs, n_param, n_bound)\n                 }\n                 _ => {\n-                    tcx.sess.bug(fmt!(\n+                    tcx.sess.bug(format!(\n                         \"resolve_vtable_under_param_substs: asked to lookup \\\n                          but no vtables in the fn_ctxt!\"))\n                 }\n@@ -1207,7 +1207,7 @@ pub fn find_vtable(tcx: ty::ctxt,\n                    n_param: typeck::param_index,\n                    n_bound: uint)\n                    -> typeck::vtable_origin {\n-    debug!(\"find_vtable(n_param=%?, n_bound=%u, ps=%s)\",\n+    debug2!(\"find_vtable(n_param={:?}, n_bound={}, ps={})\",\n            n_param, n_bound, ps.repr(tcx));\n \n     let param_bounds = match n_param {\n@@ -1248,7 +1248,7 @@ pub fn langcall(bcx: @mut Block, span: Option<Span>, msg: &str,\n     match bcx.tcx().lang_items.require(li) {\n         Ok(id) => id,\n         Err(s) => {\n-            let msg = fmt!(\"%s %s\", msg, s);\n+            let msg = format!(\"{} {}\", msg, s);\n             match span {\n                 Some(span) => { bcx.tcx().sess.span_fatal(span, msg); }\n                 None => { bcx.tcx().sess.fatal(msg); }"}, {"sha": "aa56631438638d7b31f5a859edb95736bf133c97", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -52,7 +52,7 @@ pub fn const_lit(cx: &mut CrateContext, e: &ast::Expr, lit: ast::lit)\n             C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n           }\n           _ => cx.sess.span_bug(lit.span,\n-                   fmt!(\"integer literal has type %s (expected int or uint)\",\n+                   format!(\"integer literal has type {} (expected int or uint)\",\n                         ty_to_str(cx.tcx, lit_int_ty)))\n         }\n       }\n@@ -144,14 +144,14 @@ fn const_deref(cx: &mut CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n                     const_deref_newtype(cx, v, t)\n                 }\n                 _ => {\n-                    cx.sess.bug(fmt!(\"Unexpected dereferenceable type %s\",\n+                    cx.sess.bug(format!(\"Unexpected dereferenceable type {}\",\n                                      ty_to_str(cx.tcx, t)))\n                 }\n             };\n             (dv, mt.ty)\n         }\n         None => {\n-            cx.sess.bug(fmt!(\"Can't dereference const of type %s\",\n+            cx.sess.bug(format!(\"Can't dereference const of type {}\",\n                              ty_to_str(cx.tcx, t)))\n         }\n     }\n@@ -189,8 +189,8 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n             llconst = C_struct([llconst, C_null(Type::opaque_box(cx).ptr_to())])\n         }\n         Some(@ty::AutoAddEnv(ref r, ref s)) => {\n-            cx.sess.span_bug(e.span, fmt!(\"unexpected static function: \\\n-                                           region %? sigil %?\", *r, *s))\n+            cx.sess.span_bug(e.span, format!(\"unexpected static function: \\\n+                                           region {:?} sigil {:?}\", *r, *s))\n         }\n         Some(@ty::AutoDerefRef(ref adj)) => {\n             let mut ty = ety;\n@@ -234,8 +234,8 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n                         }\n                         _ => {\n                             cx.sess.span_bug(e.span,\n-                                             fmt!(\"unimplemented const \\\n-                                                   autoref %?\", autoref))\n+                                             format!(\"unimplemented const \\\n+                                                   autoref {:?}\", autoref))\n                         }\n                     }\n                 }\n@@ -253,7 +253,7 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n             llvm::LLVMDumpValue(llconst);\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n-        cx.sess.bug(fmt!(\"const %s of type %s has size %u instead of %u\",\n+        cx.sess.bug(format!(\"const {} of type {} has size {} instead of {}\",\n                          e.repr(cx.tcx), ty_to_str(cx.tcx, ety),\n                          csize, tsize));\n     }"}, {"sha": "d2a3557d85b9eabf7fdc03be67cda3008c8b4df2", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -252,7 +252,7 @@ impl CrateContext {\n     pub fn const_inbounds_gepi(&self,\n                                pointer: ValueRef,\n                                indices: &[uint]) -> ValueRef {\n-        debug!(\"const_inbounds_gepi: pointer=%s indices=%?\",\n+        debug2!(\"const_inbounds_gepi: pointer={} indices={:?}\",\n                self.tn.val_to_str(pointer), indices);\n         let v: ~[ValueRef] =\n             indices.iter().map(|i| C_i32(*i as i32)).collect();"}, {"sha": "105cb6e5606db60772d51a4fc2880f8b9dc8a853", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -50,7 +50,7 @@ pub fn trans_if(bcx: @mut Block,\n             els: Option<@ast::Expr>,\n             dest: expr::Dest)\n          -> @mut Block {\n-    debug!(\"trans_if(bcx=%s, cond=%s, thn=%?, dest=%s)\",\n+    debug2!(\"trans_if(bcx={}, cond={}, thn={:?}, dest={})\",\n            bcx.to_str(), bcx.expr_to_str(cond), thn.id,\n            dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n@@ -119,7 +119,7 @@ pub fn trans_if(bcx: @mut Block,\n       }\n     };\n \n-    debug!(\"then_bcx_in=%s, else_bcx_in=%s\",\n+    debug2!(\"then_bcx_in={}, else_bcx_in={}\",\n            then_bcx_in.to_str(), else_bcx_in.to_str());\n \n     CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);"}, {"sha": "7842215912640c61c34839daa16630a308fe4d7a", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -242,7 +242,7 @@ impl Datum {\n                           action: CopyAction,\n                           datum: Datum)\n                           -> @mut Block {\n-        debug!(\"store_to_datum(self=%s, action=%?, datum=%s)\",\n+        debug2!(\"store_to_datum(self={}, action={:?}, datum={})\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n         assert!(datum.mode.is_by_ref());\n         self.store_to(bcx, action, datum.val)\n@@ -275,7 +275,7 @@ impl Datum {\n             return bcx;\n         }\n \n-        debug!(\"copy_to(self=%s, action=%?, dst=%s)\",\n+        debug2!(\"copy_to(self={}, action={:?}, dst={})\",\n                self.to_str(bcx.ccx()), action, bcx.val_to_str(dst));\n \n         // Watch out for the case where we are writing the copying the\n@@ -340,7 +340,7 @@ impl Datum {\n         let _icx = push_ctxt(\"move_to\");\n         let mut bcx = bcx;\n \n-        debug!(\"move_to(self=%s, action=%?, dst=%s)\",\n+        debug2!(\"move_to(self={}, action={:?}, dst={})\",\n                self.to_str(bcx.ccx()), action, bcx.val_to_str(dst));\n \n         if ty::type_is_voidish(self.ty) {\n@@ -380,7 +380,7 @@ impl Datum {\n             }\n             ByRef(ZeroMem) => {\n                 bcx.tcx().sess.bug(\n-                    fmt!(\"Cannot add clean to a 'zero-mem' datum\"));\n+                    format!(\"Cannot add clean to a 'zero-mem' datum\"));\n             }\n         }\n     }\n@@ -404,7 +404,7 @@ impl Datum {\n     }\n \n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        fmt!(\"Datum { val=%s, ty=%s, mode=%? }\",\n+        format!(\"Datum \\\\{ val={}, ty={}, mode={:?} \\\\}\",\n              ccx.tn.val_to_str(self.val),\n              ty_to_str(ccx.tcx, self.ty),\n              self.mode)\n@@ -573,8 +573,8 @@ impl Datum {\n                 (unboxed_vec_ty, true)\n             }\n             _ => {\n-                bcx.tcx().sess.bug(fmt!(\n-                    \"box_body() invoked on non-box type %s\",\n+                bcx.tcx().sess.bug(format!(\n+                    \"box_body() invoked on non-box type {}\",\n                     ty_to_str(bcx.tcx(), self.ty)));\n             }\n         };\n@@ -620,7 +620,7 @@ impl Datum {\n                      -> (Option<Datum>, @mut Block) {\n         let ccx = bcx.ccx();\n \n-        debug!(\"try_deref(expr_id=%?, derefs=%?, is_auto=%b, self=%?)\",\n+        debug2!(\"try_deref(expr_id={:?}, derefs={:?}, is_auto={}, self={:?})\",\n                expr_id, derefs, is_auto, self.to_str(bcx.ccx()));\n \n         let bcx =\n@@ -745,7 +745,7 @@ impl Datum {\n                      -> DatumBlock {\n         let _icx = push_ctxt(\"autoderef\");\n \n-        debug!(\"autoderef(expr_id=%d, max=%?, self=%?)\",\n+        debug2!(\"autoderef(expr_id={}, max={:?}, self={:?})\",\n                expr_id, max, self.to_str(bcx.ccx()));\n         let _indenter = indenter();\n "}, {"sha": "3f4c2e8abc586bedfb0e8c9997941df0c48e6935", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -142,7 +142,7 @@ pub struct CrateDebugContext {\n \n impl CrateDebugContext {\n     pub fn new(llmod: ModuleRef, crate: ~str) -> CrateDebugContext {\n-        debug!(\"CrateDebugContext::new\");\n+        debug2!(\"CrateDebugContext::new\");\n         let builder = unsafe { llvm::LLVMDIBuilderCreate(llmod) };\n         // DIBuilder inherits context from the module, so we'd better use the same one\n         let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n@@ -240,7 +240,7 @@ pub fn finalize(cx: @mut CrateContext) {\n         return;\n     }\n \n-    debug!(\"finalize\");\n+    debug2!(\"finalize\");\n     compile_unit_metadata(cx);\n     unsafe {\n         llvm::LLVMDIBuilderFinalize(DIB(cx));\n@@ -268,7 +268,8 @@ pub fn create_local_var_metadata(bcx: @mut Block,\n         let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n             Some(v) => v,\n             None => {\n-                bcx.tcx().sess.span_bug(span, fmt!(\"No entry in lllocals table for %?\", node_id));\n+                bcx.tcx().sess.span_bug(span,\n+                    format!(\"No entry in lllocals table for {:?}\", node_id));\n             }\n         };\n \n@@ -310,8 +311,8 @@ pub fn create_captured_var_metadata(bcx: @mut Block,\n             ast_util::path_to_ident(path)\n         }\n         _ => {\n-            cx.sess.span_bug(span, fmt!(\"debuginfo::create_captured_var_metadata() - \\\n-                Captured var-id refers to unexpected ast_map variant: %?\", ast_item));\n+            cx.sess.span_bug(span, format!(\"debuginfo::create_captured_var_metadata() - \\\n+                Captured var-id refers to unexpected ast_map variant: {:?}\", ast_item));\n         }\n     };\n \n@@ -366,7 +367,7 @@ pub fn create_match_binding_metadata(bcx: @mut Block,\n     let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n         Some(v) => v,\n         None => {\n-            bcx.tcx().sess.span_bug(span, fmt!(\"No entry in lllocals table for %?\", node_id));\n+            bcx.tcx().sess.span_bug(span, format!(\"No entry in lllocals table for {:?}\", node_id));\n         }\n     };\n \n@@ -408,7 +409,7 @@ pub fn create_self_argument_metadata(bcx: @mut Block,\n             explicit_self.span\n         }\n         _ => bcx.ccx().sess.bug(\n-                fmt!(\"create_self_argument_metadata: unexpected sort of node: %?\", fnitem))\n+                format!(\"create_self_argument_metadata: unexpected sort of node: {:?}\", fnitem))\n     };\n \n     let scope_metadata = bcx.fcx.debug_context.get_ref(bcx.ccx(), span).fn_metadata;\n@@ -459,7 +460,8 @@ pub fn create_argument_metadata(bcx: @mut Block,\n         let llptr = match bcx.fcx.llargs.find_copy(&node_id) {\n             Some(v) => v,\n             None => {\n-                bcx.tcx().sess.span_bug(span, fmt!(\"No entry in llargs table for %?\", node_id));\n+                bcx.tcx().sess.span_bug(span,\n+                    format!(\"No entry in llargs table for {:?}\", node_id));\n             }\n         };\n \n@@ -501,7 +503,7 @@ pub fn set_source_location(fcx: &FunctionContext,\n \n     let cx = fcx.ccx;\n \n-    debug!(\"set_source_location: %s\", cx.sess.codemap.span_to_str(span));\n+    debug2!(\"set_source_location: {}\", cx.sess.codemap.span_to_str(span));\n \n     if fcx.debug_context.get_ref(cx, span).source_locations_enabled {\n         let loc = span_start(cx, span);\n@@ -574,7 +576,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n                 ast::ExprFnBlock(ref fn_decl, ref top_level_block) => {\n-                    let name = fmt!(\"fn%u\", token::gensym(\"fn\"));\n+                    let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(name);\n                     (name, fn_decl,\n                         // This is not quite right. It should actually inherit the generics of the\n@@ -606,7 +608,8 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         ast_map::node_struct_ctor(*) => {\n             return FunctionWithoutDebugInfo;\n         }\n-        _ => cx.sess.bug(fmt!(\"create_function_debug_context: unexpected sort of node: %?\", fnitem))\n+        _ => cx.sess.bug(format!(\"create_function_debug_context: \\\n+                                  unexpected sort of node: {:?}\", fnitem))\n     };\n \n     // This can be the case for functions inlined from another crate\n@@ -637,8 +640,8 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         }\n         None => {\n             // This branch is only hit when there is a bug in the NamespaceVisitor.\n-            cx.sess.span_warn(span, fmt!(\"debuginfo: Could not find namespace node for function\n-                                          with name %s. This is a bug! Please report this to\n+            cx.sess.span_warn(span, format!(\"debuginfo: Could not find namespace node for function\n+                                          with name {}. This is a bug! Please report this to\n                                           github.com/mozilla/rust/issues\", function_name));\n             (function_name.clone(), file_metadata)\n         }\n@@ -870,10 +873,10 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n     let dcx = debug_context(cx);\n     let crate_name: &str = dcx.crate_file;\n \n-    debug!(\"compile_unit_metadata: %?\", crate_name);\n+    debug2!(\"compile_unit_metadata: {:?}\", crate_name);\n \n     let work_dir = cx.sess.working_dir.to_str();\n-    let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n+    let producer = format!(\"rustc version {}\", env!(\"CFG_VERSION\"));\n \n     do crate_name.with_c_str |crate_name| {\n     do work_dir.with_c_str |work_dir| {\n@@ -980,7 +983,7 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n         None => ()\n     }\n \n-    debug!(\"file_metadata: %s\", full_path);\n+    debug2!(\"file_metadata: {}\", full_path);\n \n     let work_dir = cx.sess.working_dir.to_str();\n     let file_name =\n@@ -1015,14 +1018,14 @@ fn scope_metadata(fcx: &FunctionContext,\n             let node = fcx.ccx.tcx.items.get_copy(&node_id);\n \n             fcx.ccx.sess.span_bug(span,\n-                fmt!(\"debuginfo: Could not find scope info for node %?\", node));\n+                format!(\"debuginfo: Could not find scope info for node {:?}\", node));\n         }\n     }\n }\n \n fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n \n-    debug!(\"basic_type_metadata: %?\", ty::get(t));\n+    debug2!(\"basic_type_metadata: {:?}\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bot => (~\"uint\", DW_ATE_unsigned),\n@@ -1340,8 +1343,8 @@ fn describe_variant(cx: &mut CrateContext,\n             Some(&ast_map::node_variant(ref variant, _, _)) => variant.span,\n             ref node => {\n                 cx.sess.span_warn(span,\n-                    fmt!(\"debuginfo::enum_metadata()::adt_struct_metadata() - Unexpected node \\\n-                          type: %?. This is a bug.\", node));\n+                    format!(\"debuginfo::enum_metadata()::adt_struct_metadata() - Unexpected node \\\n+                          type: {:?}. This is a bug.\", node));\n                 codemap::dummy_sp()\n             }\n         }\n@@ -1659,7 +1662,7 @@ fn boxed_type_metadata(cx: &mut CrateContext,\n                        span: Span)\n                     -> DICompositeType {\n     let box_type_name = match content_type_name {\n-        Some(content_type_name) => fmt!(\"Boxed<%s>\", content_type_name),\n+        Some(content_type_name) => format!(\"Boxed<{}>\", content_type_name),\n         None                    => ~\"BoxedType\"\n     };\n \n@@ -1768,7 +1771,7 @@ fn vec_metadata(cx: &mut CrateContext,\n     let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n \n     let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n-    let vec_type_name: &str = fmt!(\"[%s]\", ppaux::ty_to_str(cx.tcx, element_type));\n+    let vec_type_name: &str = format!(\"[{}]\", ppaux::ty_to_str(cx.tcx, element_type));\n \n     let member_llvm_types = vec_llvm_type.field_types();\n \n@@ -1824,7 +1827,7 @@ fn boxed_vec_metadata(cx: &mut CrateContext,\n                    -> DICompositeType {\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n-    let vec_type_name: &str = fmt!(\"[%s]\", ppaux::ty_to_str(cx.tcx, element_type));\n+    let vec_type_name: &str = format!(\"[{}]\", ppaux::ty_to_str(cx.tcx, element_type));\n     let vec_metadata = vec_metadata(cx, element_type, span);\n \n     return boxed_type_metadata(\n@@ -1841,7 +1844,7 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n                       span: Span)\n                    -> DICompositeType {\n \n-    debug!(\"vec_slice_metadata: %?\", ty::get(vec_type));\n+    debug2!(\"vec_slice_metadata: {:?}\", ty::get(vec_type));\n \n     let slice_llvm_type = type_of::type_of(cx, vec_type);\n     let slice_type_name = ppaux::ty_to_str(cx.tcx, vec_type);\n@@ -1956,10 +1959,10 @@ fn trait_metadata(cx: &mut CrateContext,\n }\n \n fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n-    debug!(\"unimplemented_type_metadata: %?\", ty::get(t));\n+    debug2!(\"unimplemented_type_metadata: {:?}\", ty::get(t));\n \n     let name = ppaux::ty_to_str(cx.tcx, t);\n-    let metadata = do fmt!(\"NYI<%s>\", name).with_c_str |name| {\n+    let metadata = do format!(\"NYI<{}>\", name).with_c_str |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),\n@@ -2008,7 +2011,7 @@ fn type_metadata(cx: &mut CrateContext,\n         pointer_type_metadata(cx, pointer_type, box_metadata)\n     }\n \n-    debug!(\"type_metadata: %?\", ty::get(t));\n+    debug2!(\"type_metadata: {:?}\", ty::get(t));\n \n     let sty = &ty::get(t).sty;\n     let type_metadata = match *sty {\n@@ -2095,7 +2098,7 @@ fn type_metadata(cx: &mut CrateContext,\n         ty::ty_opaque_box => {\n             create_pointer_to_box_metadata(cx, t, ty::mk_nil())\n         }\n-        _ => cx.sess.bug(fmt!(\"debuginfo: unexpected type in type_metadata: %?\", sty))\n+        _ => cx.sess.bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty))\n     };\n \n     debug_context(cx).created_types.insert(cache_id, type_metadata);\n@@ -2127,7 +2130,7 @@ fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n \n     match debug_location {\n         KnownLocation { scope, line, col } => {\n-            debug!(\"setting debug location to %u %u\", line, col);\n+            debug2!(\"setting debug location to {} {}\", line, col);\n             let elements = [C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n             unsafe {\n                 metadata_node = llvm::LLVMMDNodeInContext(debug_context(cx).llcontext,\n@@ -2136,7 +2139,7 @@ fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n             }\n         }\n         UnknownLocation => {\n-            debug!(\"clearing debug location \");\n+            debug2!(\"clearing debug location \");\n             metadata_node = ptr::null();\n         }\n     };\n@@ -2202,8 +2205,9 @@ fn get_namespace_and_span_for_item(cx: &mut CrateContext,\n         let definition_span = match cx.tcx.items.find(&def_id.node) {\n             Some(&ast_map::node_item(@ast::item { span, _ }, _)) => span,\n             ref node => {\n-                cx.sess.span_warn(warning_span, fmt!(\"debuginfo::get_namespace_and_span_for_item() \\\n-                                                      - Unexpected node type: %?\", *node));\n+                cx.sess.span_warn(warning_span,\n+                    format!(\"debuginfo::get_namespace_and_span_for_item() \\\n+                             - Unexpected node type: {:?}\", *node));\n                 codemap::dummy_sp()\n             }\n         };\n@@ -2682,7 +2686,7 @@ impl NamespaceTreeNode {\n         let mut name = ~\"_ZN\";\n         fill_nested(self, &mut name);\n \n-        name.push_str(fmt!(\"%u%s\", item_name.len(), item_name));\n+        name.push_str(format!(\"{}{}\", item_name.len(), item_name));\n         name.push_char('E');\n \n         return name;\n@@ -2695,7 +2699,7 @@ impl NamespaceTreeNode {\n                 None => {}\n             }\n             let name = token::ident_to_str(&node.ident);\n-            output.push_str(fmt!(\"%u%s\", name.len(), name));\n+            output.push_str(format!(\"{}{}\", name.len(), name));\n         }\n     }\n }\n@@ -2704,7 +2708,7 @@ fn namespace_for_external_item(cx: &mut CrateContext,\n                                item_path: &ast_map::path)\n                             -> @NamespaceTreeNode {\n     if item_path.len() < 2 {\n-        cx.sess.bug(fmt!(\"debuginfo::namespace_for_external_item() - Invalid item_path: %s\",\n+        cx.sess.bug(format!(\"debuginfo::namespace_for_external_item() - Invalid item_path: {}\",\n             ast_map::path_to_str(*item_path, token::get_ident_interner())));\n     }\n "}, {"sha": "995b246788854b7cc972d9da04a067f8d327af52", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -169,7 +169,7 @@ pub enum Dest {\n impl Dest {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n         match *self {\n-            SaveIn(v) => fmt!(\"SaveIn(%s)\", ccx.tn.val_to_str(v)),\n+            SaveIn(v) => format!(\"SaveIn({})\", ccx.tn.val_to_str(v)),\n             Ignore => ~\"Ignore\"\n         }\n     }\n@@ -182,15 +182,15 @@ fn drop_and_cancel_clean(bcx: @mut Block, dat: Datum) -> @mut Block {\n }\n \n pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n-    debug!(\"trans_to_datum(expr=%s)\", bcx.expr_to_str(expr));\n+    debug2!(\"trans_to_datum(expr={})\", bcx.expr_to_str(expr));\n \n     let mut bcx = bcx;\n     let mut datum = unpack_datum!(bcx, trans_to_datum_unadjusted(bcx, expr));\n     let adjustment = match bcx.tcx().adjustments.find_copy(&expr.id) {\n         None => { return DatumBlock {bcx: bcx, datum: datum}; }\n         Some(adj) => { adj }\n     };\n-    debug!(\"unadjusted datum: %s\", datum.to_str(bcx.ccx()));\n+    debug2!(\"unadjusted datum: {}\", datum.to_str(bcx.ccx()));\n     match *adjustment {\n         AutoAddEnv(*) => {\n             datum = unpack_datum!(bcx, add_env(bcx, expr, datum));\n@@ -232,7 +232,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n             };\n         }\n     }\n-    debug!(\"after adjustments, datum=%s\", datum.to_str(bcx.ccx()));\n+    debug2!(\"after adjustments, datum={}\", datum.to_str(bcx.ccx()));\n     return DatumBlock {bcx: bcx, datum: datum};\n \n     fn auto_ref(bcx: @mut Block, datum: Datum) -> DatumBlock {\n@@ -287,7 +287,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n \n         let tcx = bcx.tcx();\n         let closure_ty = expr_ty_adjusted(bcx, expr);\n-        debug!(\"add_env(closure_ty=%s)\", closure_ty.repr(tcx));\n+        debug2!(\"add_env(closure_ty={})\", closure_ty.repr(tcx));\n         let scratch = scratch_datum(bcx, closure_ty, \"__adjust\", false);\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n         assert_eq!(datum.appropriate_mode(tcx), ByValue);\n@@ -311,7 +311,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                        source_datum: Datum) -> DatumBlock {\n         let tcx = bcx.tcx();\n         let target_obj_ty = expr_ty_adjusted(bcx, expr);\n-        debug!(\"auto_borrow_obj(target=%s)\",\n+        debug2!(\"auto_borrow_obj(target={})\",\n                target_obj_ty.repr(tcx));\n \n         // Extract source store information\n@@ -320,7 +320,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n             _ => {\n                 bcx.sess().span_bug(\n                     expr.span,\n-                    fmt!(\"auto_borrow_trait_obj expected a trait, found %s\",\n+                    format!(\"auto_borrow_trait_obj expected a trait, found {}\",\n                          source_datum.ty.repr(bcx.tcx())));\n             }\n         };\n@@ -432,7 +432,7 @@ pub fn trans_into(bcx: @mut Block, expr: &ast::Expr, dest: Dest) -> @mut Block {\n \n     let ty = expr_ty(bcx, expr);\n \n-    debug!(\"trans_into_unadjusted(expr=%s, dest=%s)\",\n+    debug2!(\"trans_into_unadjusted(expr={}, dest={})\",\n            bcx.expr_to_str(expr),\n            dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n@@ -448,7 +448,7 @@ pub fn trans_into(bcx: @mut Block, expr: &ast::Expr, dest: Dest) -> @mut Block {\n     };\n \n     let kind = bcx.expr_kind(expr);\n-    debug!(\"expr kind = %?\", kind);\n+    debug2!(\"expr kind = {:?}\", kind);\n     return match kind {\n         ty::LvalueExpr => {\n             let datumblock = trans_lvalue_unadjusted(bcx, expr);\n@@ -490,7 +490,7 @@ fn trans_lvalue(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         Some(_) => {\n             bcx.sess().span_bug(\n                 expr.span,\n-                fmt!(\"trans_lvalue() called on an expression \\\n+                format!(\"trans_lvalue() called on an expression \\\n                       with adjustments\"));\n         }\n     };\n@@ -506,7 +506,7 @@ fn trans_to_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n \n     let mut bcx = bcx;\n \n-    debug!(\"trans_to_datum_unadjusted(expr=%s)\", bcx.expr_to_str(expr));\n+    debug2!(\"trans_to_datum_unadjusted(expr={})\", bcx.expr_to_str(expr));\n     let _indenter = indenter();\n \n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n@@ -608,8 +608,8 @@ fn trans_rvalue_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBloc\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                fmt!(\"trans_rvalue_datum_unadjusted reached \\\n-                      fall-through case: %?\",\n+                format!(\"trans_rvalue_datum_unadjusted reached \\\n+                      fall-through case: {:?}\",\n                      expr.node));\n         }\n     }\n@@ -662,8 +662,8 @@ fn trans_rvalue_stmt_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> @mut Block\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                fmt!(\"trans_rvalue_stmt_unadjusted reached \\\n-                      fall-through case: %?\",\n+                format!(\"trans_rvalue_stmt_unadjusted reached \\\n+                      fall-through case: {:?}\",\n                      expr.node));\n         }\n     };\n@@ -718,7 +718,7 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n         ast::ExprFnBlock(ref decl, ref body) => {\n             let expr_ty = expr_ty(bcx, expr);\n             let sigil = ty::ty_closure_sigil(expr_ty);\n-            debug!(\"translating fn_block %s with type %s\",\n+            debug2!(\"translating fn_block {} with type {}\",\n                    expr_to_str(expr, tcx.sess.intr()),\n                    expr_ty.repr(tcx));\n             return closure::trans_expr_fn(bcx, sigil, decl, body,\n@@ -787,7 +787,7 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                fmt!(\"trans_rvalue_dps_unadjusted reached fall-through case: %?\",\n+                format!(\"trans_rvalue_dps_unadjusted reached fall-through case: {:?}\",\n                      expr.node));\n         }\n     }\n@@ -836,8 +836,8 @@ fn trans_def_dps_unadjusted(bcx: @mut Block, ref_expr: &ast::Expr,\n             return bcx;\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(ref_expr.span, fmt!(\n-                \"Non-DPS def %? referened by %s\",\n+            bcx.tcx().sess.span_bug(ref_expr.span, format!(\n+                \"Non-DPS def {:?} referened by {}\",\n                 def, bcx.node_id_to_str(ref_expr.id)));\n         }\n     }\n@@ -861,8 +861,8 @@ fn trans_def_datum_unadjusted(bcx: @mut Block,\n                                              ref_expr.id)\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(ref_expr.span, fmt!(\n-                \"Non-DPS def %? referened by %s\",\n+            bcx.tcx().sess.span_bug(ref_expr.span, format!(\n+                \"Non-DPS def {:?} referened by {}\",\n                 def, bcx.node_id_to_str(ref_expr.id)));\n         }\n     };\n@@ -887,7 +887,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_lval\");\n     let mut bcx = bcx;\n \n-    debug!(\"trans_lvalue(expr=%s)\", bcx.expr_to_str(expr));\n+    debug2!(\"trans_lvalue(expr={})\", bcx.expr_to_str(expr));\n     let _indenter = indenter();\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n@@ -912,7 +912,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                fmt!(\"trans_lvalue reached fall-through case: %?\",\n+                format!(\"trans_lvalue reached fall-through case: {:?}\",\n                      expr.node));\n         }\n     };\n@@ -978,8 +978,8 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n             base_datum.get_vec_base_and_len(bcx, index_expr.span,\n                                             index_expr.id, 0);\n \n-        debug!(\"trans_index: base %s\", bcx.val_to_str(base));\n-        debug!(\"trans_index: len %s\", bcx.val_to_str(len));\n+        debug2!(\"trans_index: base {}\", bcx.val_to_str(base));\n+        debug2!(\"trans_index: len {}\", bcx.val_to_str(len));\n \n         let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, len);\n         let bcx = do with_cond(bcx, bounds_check) |bcx| {\n@@ -1091,8 +1091,8 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n                     }\n                 }\n                 None => {\n-                    bcx.sess().bug(fmt!(\n-                        \"trans_local_var: no llval for upvar %? found\", nid));\n+                    bcx.sess().bug(format!(\n+                        \"trans_local_var: no llval for upvar {:?} found\", nid));\n                 }\n             }\n         }\n@@ -1106,13 +1106,13 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n             let self_info: ValSelfData = match bcx.fcx.llself {\n                 Some(ref self_info) => *self_info,\n                 None => {\n-                    bcx.sess().bug(fmt!(\n+                    bcx.sess().bug(format!(\n                         \"trans_local_var: reference to self \\\n-                         out of context with id %?\", nid));\n+                         out of context with id {:?}\", nid));\n                 }\n             };\n \n-            debug!(\"def_self() reference, self_info.t=%s\",\n+            debug2!(\"def_self() reference, self_info.t={}\",\n                    self_info.t.repr(bcx.tcx()));\n \n             Datum {\n@@ -1122,8 +1122,8 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n             }\n         }\n         _ => {\n-            bcx.sess().unimpl(fmt!(\n-                \"unsupported def type in trans_local_var: %?\", def));\n+            bcx.sess().unimpl(format!(\n+                \"unsupported def type in trans_local_var: {:?}\", def));\n         }\n     };\n \n@@ -1133,12 +1133,12 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n         let v = match table.find(&nid) {\n             Some(&v) => v,\n             None => {\n-                bcx.sess().bug(fmt!(\n-                    \"trans_local_var: no llval for local/arg %? found\", nid));\n+                bcx.sess().bug(format!(\n+                    \"trans_local_var: no llval for local/arg {:?} found\", nid));\n             }\n         };\n         let ty = node_id_type(bcx, nid);\n-        debug!(\"take_local(nid=%?, v=%s, ty=%s)\",\n+        debug2!(\"take_local(nid={:?}, v={}, ty={})\",\n                nid, bcx.val_to_str(v), bcx.ty_to_str(ty));\n         Datum {\n             val: v,\n@@ -1164,8 +1164,8 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n             // We want the *variant* ID here, not the enum ID.\n             match node_id_opt {\n                 None => {\n-                    tcx.sess.bug(fmt!(\n-                        \"cannot get field types from the enum type %s \\\n+                    tcx.sess.bug(format!(\n+                        \"cannot get field types from the enum type {} \\\n                          without a node ID\",\n                         ty.repr(tcx)));\n                 }\n@@ -1187,8 +1187,8 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n         }\n \n         _ => {\n-            tcx.sess.bug(fmt!(\n-                \"cannot get field types from the type %s\",\n+            tcx.sess.bug(format!(\n+                \"cannot get field types from the type {}\",\n                 ty.repr(tcx)));\n         }\n     }\n@@ -1733,14 +1733,14 @@ fn trans_imm_cast(bcx: @mut Block, expr: &ast::Expr,\n                                               val_ty(lldiscrim_a),\n                                               lldiscrim_a, true),\n                     cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n-                    _ => ccx.sess.bug(fmt!(\"translating unsupported cast: \\\n-                                           %s (%?) -> %s (%?)\",\n+                    _ => ccx.sess.bug(format!(\"translating unsupported cast: \\\n+                                           {} ({:?}) -> {} ({:?})\",\n                                            t_in.repr(ccx.tcx), k_in,\n                                            t_out.repr(ccx.tcx), k_out))\n                 }\n             }\n-            _ => ccx.sess.bug(fmt!(\"translating unsupported cast: \\\n-                                   %s (%?) -> %s (%?)\",\n+            _ => ccx.sess.bug(format!(\"translating unsupported cast: \\\n+                                   {} ({:?}) -> {} ({:?})\",\n                                    t_in.repr(ccx.tcx), k_in,\n                                    t_out.repr(ccx.tcx), k_out))\n         };\n@@ -1757,7 +1757,7 @@ fn trans_assign_op(bcx: @mut Block,\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n \n-    debug!(\"trans_assign_op(expr=%s)\", bcx.expr_to_str(expr));\n+    debug2!(\"trans_assign_op(expr={})\", bcx.expr_to_str(expr));\n \n     // Evaluate LHS (destination), which should be an lvalue\n     let dst_datum = unpack_datum!(bcx, trans_lvalue_unadjusted(bcx, dst));"}, {"sha": "6ca0967f8eea827dda8bc1c24544c165ec6f4dfe", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -80,13 +80,13 @@ pub fn llvm_calling_convention(ccx: &mut CrateContext,\n         match *abi {\n             RustIntrinsic => {\n                 // Intrinsics are emitted by monomorphic fn\n-                ccx.sess.bug(fmt!(\"Asked to register intrinsic fn\"));\n+                ccx.sess.bug(format!(\"Asked to register intrinsic fn\"));\n             }\n \n             Rust => {\n                 // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n                 ccx.sess.unimpl(\n-                    fmt!(\"Foreign functions with Rust ABI\"));\n+                    format!(\"Foreign functions with Rust ABI\"));\n             }\n \n             Stdcall => lib::llvm::X86StdcallCallConv,\n@@ -110,9 +110,9 @@ pub fn register_foreign_item_fn(ccx: @mut CrateContext,\n      * Just adds a LLVM global.\n      */\n \n-    debug!(\"register_foreign_item_fn(abis=%s, \\\n-            path=%s, \\\n-            foreign_item.id=%?)\",\n+    debug2!(\"register_foreign_item_fn(abis={}, \\\n+            path={}, \\\n+            foreign_item.id={:?})\",\n            abis.repr(ccx.tcx),\n            path.repr(ccx.tcx),\n            foreign_item.id);\n@@ -122,9 +122,9 @@ pub fn register_foreign_item_fn(ccx: @mut CrateContext,\n         None => {\n             // FIXME(#8357) We really ought to report a span here\n             ccx.sess.fatal(\n-                fmt!(\"ABI `%s` has no suitable ABI \\\n+                format!(\"ABI `{}` has no suitable ABI \\\n                       for target architecture \\\n-                      in module %s\",\n+                      in module {}\",\n                      abis.user_string(ccx.tcx),\n                      ast_map::path_to_str(*path,\n                                           ccx.sess.intr())));\n@@ -165,9 +165,9 @@ pub fn trans_native_call(bcx: @mut Block,\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n \n-    debug!(\"trans_native_call(callee_ty=%s, \\\n-            llfn=%s, \\\n-            llretptr=%s)\",\n+    debug2!(\"trans_native_call(callee_ty={}, \\\n+            llfn={}, \\\n+            llretptr={})\",\n            callee_ty.repr(tcx),\n            ccx.tn.val_to_str(llfn),\n            ccx.tn.val_to_str(llretptr));\n@@ -213,7 +213,7 @@ pub fn trans_native_call(bcx: @mut Block,\n         // Does Rust pass this argument by pointer?\n         let rust_indirect = type_of::arg_is_indirect(ccx, fn_sig.inputs[i]);\n \n-        debug!(\"argument %u, llarg_rust=%s, rust_indirect=%b, arg_ty=%s\",\n+        debug2!(\"argument {}, llarg_rust={}, rust_indirect={}, arg_ty={}\",\n                i,\n                ccx.tn.val_to_str(llarg_rust),\n                rust_indirect,\n@@ -227,7 +227,7 @@ pub fn trans_native_call(bcx: @mut Block,\n             llarg_rust = scratch;\n         }\n \n-        debug!(\"llarg_rust=%s (after indirection)\",\n+        debug2!(\"llarg_rust={} (after indirection)\",\n                ccx.tn.val_to_str(llarg_rust));\n \n         // Check whether we need to do any casting\n@@ -236,7 +236,7 @@ pub fn trans_native_call(bcx: @mut Block,\n             llarg_rust = BitCast(bcx, llarg_rust, foreignarg_ty.ptr_to());\n         }\n \n-        debug!(\"llarg_rust=%s (after casting)\",\n+        debug2!(\"llarg_rust={} (after casting)\",\n                ccx.tn.val_to_str(llarg_rust));\n \n         // Finally, load the value if needed for the foreign ABI\n@@ -247,7 +247,7 @@ pub fn trans_native_call(bcx: @mut Block,\n             Load(bcx, llarg_rust)\n         };\n \n-        debug!(\"argument %u, llarg_foreign=%s\",\n+        debug2!(\"argument {}, llarg_foreign={}\",\n                i, ccx.tn.val_to_str(llarg_foreign));\n \n         llargs_foreign.push(llarg_foreign);\n@@ -258,7 +258,7 @@ pub fn trans_native_call(bcx: @mut Block,\n         None => {\n             // FIXME(#8357) We really ought to report a span here\n             ccx.sess.fatal(\n-                fmt!(\"ABI string `%s` has no suitable ABI \\\n+                format!(\"ABI string `{}` has no suitable ABI \\\n                       for target architecture\",\n                      fn_abis.user_string(ccx.tcx)));\n         }\n@@ -284,10 +284,10 @@ pub fn trans_native_call(bcx: @mut Block,\n         let llrust_ret_ty = llsig.llret_ty;\n         let llforeign_ret_ty = fn_type.ret_ty.ty;\n \n-        debug!(\"llretptr=%s\", ccx.tn.val_to_str(llretptr));\n-        debug!(\"llforeign_retval=%s\", ccx.tn.val_to_str(llforeign_retval));\n-        debug!(\"llrust_ret_ty=%s\", ccx.tn.type_to_str(llrust_ret_ty));\n-        debug!(\"llforeign_ret_ty=%s\", ccx.tn.type_to_str(llforeign_ret_ty));\n+        debug2!(\"llretptr={}\", ccx.tn.val_to_str(llretptr));\n+        debug2!(\"llforeign_retval={}\", ccx.tn.val_to_str(llforeign_retval));\n+        debug2!(\"llrust_ret_ty={}\", ccx.tn.type_to_str(llrust_ret_ty));\n+        debug2!(\"llforeign_ret_ty={}\", ccx.tn.type_to_str(llforeign_ret_ty));\n \n         if llrust_ret_ty == llforeign_ret_ty {\n             Store(bcx, llforeign_retval, llretptr);\n@@ -313,7 +313,7 @@ pub fn trans_native_call(bcx: @mut Block,\n             let llforeign_align = machine::llalign_of_min(ccx, llforeign_ret_ty);\n             let llrust_align = machine::llalign_of_min(ccx, llrust_ret_ty);\n             let llalign = uint::min(llforeign_align, llrust_align);\n-            debug!(\"llrust_size=%?\", llrust_size);\n+            debug2!(\"llrust_size={:?}\", llrust_size);\n             base::call_memcpy(bcx, llretptr_i8, llscratch_i8,\n                               C_uint(ccx, llrust_size), llalign as u32);\n         }\n@@ -372,7 +372,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                                         lib::llvm::CCallConv,\n                                         llfn_ty);\n     add_argument_attributes(&tys, llfn);\n-    debug!(\"register_rust_fn_with_foreign_abi(node_id=%?, llfn_ty=%s, llfn=%s)\",\n+    debug2!(\"register_rust_fn_with_foreign_abi(node_id={:?}, llfn_ty={}, llfn={})\",\n            node_id, ccx.tn.type_to_str(llfn_ty), ccx.tn.val_to_str(llfn));\n     llfn\n }\n@@ -416,14 +416,14 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                 f\n             }\n             _ => {\n-                ccx.sess.bug(fmt!(\"build_rust_fn: extern fn %s has ty %s, \\\n+                ccx.sess.bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n                                   expected a bare fn ty\",\n                                   path.repr(tcx),\n                                   t.repr(tcx)));\n             }\n         };\n \n-        debug!(\"build_rust_fn: path=%s id=%? t=%s\",\n+        debug2!(\"build_rust_fn: path={} id={:?} t={}\",\n                path.repr(tcx),\n                id,\n                t.repr(tcx));\n@@ -449,7 +449,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n             \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n         let tcx = ccx.tcx;\n \n-        debug!(\"build_wrap_fn(llrustfn=%s, llwrapfn=%s)\",\n+        debug2!(\"build_wrap_fn(llrustfn={}, llwrapfn={})\",\n                ccx.tn.val_to_str(llrustfn),\n                ccx.tn.val_to_str(llwrapfn));\n \n@@ -504,14 +504,14 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n             // alloca some scratch space on the stack.\n             match foreign_outptr {\n                 Some(llforeign_outptr) => {\n-                    debug!(\"out pointer, foreign=%s\",\n+                    debug2!(\"out pointer, foreign={}\",\n                            ccx.tn.val_to_str(llforeign_outptr));\n                     let llrust_retptr =\n                         llvm::LLVMBuildBitCast(builder,\n                                                llforeign_outptr,\n                                                llrust_ret_ty.ptr_to().to_ref(),\n                                                noname());\n-                    debug!(\"out pointer, foreign=%s (casted)\",\n+                    debug2!(\"out pointer, foreign={} (casted)\",\n                            ccx.tn.val_to_str(llrust_retptr));\n                     llrust_args.push(llrust_retptr);\n                     return_alloca = None;\n@@ -524,10 +524,10 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                                                       llrust_ret_ty.to_ref(),\n                                                       s))\n                     };\n-                    debug!(\"out pointer, \\\n-                            allocad=%s, \\\n-                            llrust_ret_ty=%s, \\\n-                            return_ty=%s\",\n+                    debug2!(\"out pointer, \\\n+                            allocad={}, \\\n+                            llrust_ret_ty={}, \\\n+                            return_ty={}\",\n                            ccx.tn.val_to_str(slot),\n                            ccx.tn.type_to_str(llrust_ret_ty),\n                            tys.fn_sig.output.repr(tcx));\n@@ -544,7 +544,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n \n         // Push an (null) env pointer\n         let env_pointer = base::null_env_ptr(ccx);\n-        debug!(\"env pointer=%s\", ccx.tn.val_to_str(env_pointer));\n+        debug2!(\"env pointer={}\", ccx.tn.val_to_str(env_pointer));\n         llrust_args.push(env_pointer);\n \n         // Build up the arguments to the call to the rust function.\n@@ -558,9 +558,9 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n             let foreign_indirect = tys.fn_ty.attrs[foreign_index].is_some();\n             let mut llforeign_arg = llvm::LLVMGetParam(llwrapfn, foreign_index);\n \n-            debug!(\"llforeign_arg #%u: %s\",\n+            debug2!(\"llforeign_arg \\\\#{}: {}\",\n                    i, ccx.tn.val_to_str(llforeign_arg));\n-            debug!(\"rust_indirect = %b, foreign_indirect = %b\",\n+            debug2!(\"rust_indirect = {}, foreign_indirect = {}\",\n                    rust_indirect, foreign_indirect);\n \n             // Ensure that the foreign argument is indirect (by\n@@ -591,14 +591,14 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                 llvm::LLVMBuildLoad(builder, llforeign_arg, noname())\n             };\n \n-            debug!(\"llrust_arg #%u: %s\",\n+            debug2!(\"llrust_arg \\\\#{}: {}\",\n                    i, ccx.tn.val_to_str(llrust_arg));\n             llrust_args.push(llrust_arg);\n         }\n \n         // Perform the call itself\n         let llrust_ret_val = do llrust_args.as_imm_buf |ptr, len| {\n-            debug!(\"calling llrustfn = %s\", ccx.tn.val_to_str(llrustfn));\n+            debug2!(\"calling llrustfn = {}\", ccx.tn.val_to_str(llrustfn));\n             llvm::LLVMBuildCall(builder, llrustfn, ptr,\n                                 len as c_uint, noname())\n         };\n@@ -723,11 +723,11 @@ fn foreign_types_for_fn_ty(ccx: &mut CrateContext,\n                                        llsig.llarg_tys,\n                                        llsig.llret_ty,\n                                        ret_def);\n-    debug!(\"foreign_types_for_fn_ty(\\\n-           ty=%s, \\\n-           llsig=%s -> %s, \\\n-           fn_ty=%s -> %s, \\\n-           ret_def=%b\",\n+    debug2!(\"foreign_types_for_fn_ty(\\\n+           ty={}, \\\n+           llsig={} -> {}, \\\n+           fn_ty={} -> {}, \\\n+           ret_def={}\",\n            ty.repr(ccx.tcx),\n            ccx.tn.types_to_str(llsig.llarg_tys),\n            ccx.tn.type_to_str(llsig.llret_ty),"}, {"sha": "d420514e84f7f7bcc3da989561593fb1b23d37cf", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -213,51 +213,51 @@ pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n         match ti.take_glue {\n           Some(_) => (),\n           None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n+            debug2!(\"+++ lazily_emit_tydesc_glue TAKE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"take\");\n             ti.take_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_take_glue, \"take\");\n-            debug!(\"--- lazily_emit_tydesc_glue TAKE %s\",\n+            debug2!(\"--- lazily_emit_tydesc_glue TAKE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_drop_glue {\n         match ti.drop_glue {\n           Some(_) => (),\n           None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue DROP %s\",\n+            debug2!(\"+++ lazily_emit_tydesc_glue DROP {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"drop\");\n             ti.drop_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_drop_glue, \"drop\");\n-            debug!(\"--- lazily_emit_tydesc_glue DROP %s\",\n+            debug2!(\"--- lazily_emit_tydesc_glue DROP {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_free_glue {\n         match ti.free_glue {\n           Some(_) => (),\n           None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue FREE %s\",\n+            debug2!(\"+++ lazily_emit_tydesc_glue FREE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"free\");\n             ti.free_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_free_glue, \"free\");\n-            debug!(\"--- lazily_emit_tydesc_glue FREE %s\",\n+            debug2!(\"--- lazily_emit_tydesc_glue FREE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_visit_glue {\n         match ti.visit_glue {\n           Some(_) => (),\n           None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue VISIT %s\",\n+            debug2!(\"+++ lazily_emit_tydesc_glue VISIT {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"visit\");\n             ti.visit_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n-            debug!(\"--- lazily_emit_tydesc_glue VISIT %s\",\n+            debug2!(\"--- lazily_emit_tydesc_glue VISIT {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n@@ -658,7 +658,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     let llalign = llalign_of(ccx, llty);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\").to_managed();\n     note_unique_llvm_symbol(ccx, name);\n-    debug!(\"+++ declare_tydesc %s %s\", ppaux::ty_to_str(ccx.tcx, t), name);\n+    debug2!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_str(ccx.tcx, t), name);\n     let gvar = do name.with_c_str |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type.to_ref(), buf)\n@@ -679,7 +679,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n         free_glue: None,\n         visit_glue: None\n     };\n-    debug!(\"--- declare_tydesc %s\", ppaux::ty_to_str(ccx.tcx, t));\n+    debug2!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx, t));\n     return inf;\n }\n \n@@ -689,7 +689,7 @@ pub fn declare_generic_glue(ccx: &mut CrateContext, t: ty::t, llfnty: Type,\n                             name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, (~\"glue_\" + name)).to_managed();\n-    debug!(\"%s is for type %s\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n+    debug2!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n     note_unique_llvm_symbol(ccx, fn_nm);\n     let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty);\n     set_glue_inlining(llfn, t);\n@@ -730,7 +730,7 @@ pub fn make_generic_glue(ccx: @mut CrateContext,\n                          name: &str)\n                       -> ValueRef {\n     let _icx = push_ctxt(\"make_generic_glue\");\n-    let glue_name = fmt!(\"glue %s %s\", name, ty_to_short_str(ccx.tcx, t));\n+    let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx, t));\n     let _s = StatRecorder::new(ccx, glue_name);\n     make_generic_glue_inner(ccx, t, llfn, helper)\n }\n@@ -789,8 +789,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n               }\n             };\n \n-        debug!(\"ti.borrow_offset: %s\",\n-               ccx.tn.val_to_str(ti.borrow_offset));\n+        debug2!(\"ti.borrow_offset: {}\", ccx.tn.val_to_str(ti.borrow_offset));\n \n         let tydesc = C_named_struct(ccx.tydesc_type,\n                                     [ti.size, // size"}, {"sha": "de117a7c037e9cc6c8d4e33a96b47aa603456bf3", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -29,7 +29,7 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n     match ccx.external.find(&fn_id) {\n         Some(&Some(node_id)) => {\n             // Already inline\n-            debug!(\"maybe_instantiate_inline(%s): already inline as node id %d\",\n+            debug2!(\"maybe_instantiate_inline({}): already inline as node id {}\",\n                    ty::item_path_str(ccx.tcx, fn_id), node_id);\n             return local_def(node_id);\n         }\n@@ -132,7 +132,7 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n                   _ => {\n                       let self_ty = ty::node_id_to_type(ccx.tcx,\n                                                         mth.self_id);\n-                      debug!(\"calling inline trans_fn with self_ty %s\",\n+                      debug2!(\"calling inline trans_fn with self_ty {}\",\n                              ty_to_str(ccx.tcx, self_ty));\n                       match mth.explicit_self.node {\n                           ast::sty_value => impl_self(self_ty, ty::ByRef),"}, {"sha": "da71e99badba3a765ac6f9362dd7f57e5271eaff", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -39,7 +39,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                        substs: @param_substs,\n                        attributes: &[ast::Attribute],\n                        ref_id: Option<ast::NodeId>) {\n-    debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n+    debug2!(\"trans_intrinsic(item.ident={})\", ccx.sess.str_of(item.ident));\n \n     fn simple_llvm_intrinsic(bcx: @mut Block, name: &'static str, num_args: uint) {\n         assert!(num_args <= 4);\n@@ -299,13 +299,13 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             if in_type_size != out_type_size {\n                 let sp = match ccx.tcx.items.get_copy(&ref_id.unwrap()) {\n                     ast_map::node_expr(e) => e.span,\n-                    _ => fail!(\"transmute has non-expr arg\"),\n+                    _ => fail2!(\"transmute has non-expr arg\"),\n                 };\n                 let pluralize = |n| if 1u == n { \"\" } else { \"s\" };\n                 ccx.sess.span_fatal(sp,\n-                                    fmt!(\"transmute called on types with \\\n-                                          different sizes: %s (%u bit%s) to \\\n-                                          %s (%u bit%s)\",\n+                                    format!(\"transmute called on types with \\\n+                                          different sizes: {} ({} bit{}) to \\\n+                                          {} ({} bit{})\",\n                                          ty_to_str(ccx.tcx, in_type),\n                                          in_type_size,\n                                          pluralize(in_type_size),"}, {"sha": "ffb70abcec5fca810a163018c6e77ec539250374", "filename": "src/librustc/middle/trans/llrepr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -19,7 +19,7 @@ pub trait LlvmRepr {\n impl<'self, T:LlvmRepr> LlvmRepr for &'self [T] {\n     fn llrepr(&self, ccx: &CrateContext) -> ~str {\n         let reprs = self.map(|t| t.llrepr(ccx));\n-        fmt!(\"[%s]\", reprs.connect(\",\"))\n+        format!(\"[{}]\", reprs.connect(\",\"))\n     }\n }\n "}, {"sha": "03eb4f18784d5160cb1b2b2c3f2fe4284f4045d6", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -55,7 +55,7 @@ pub fn trans_impl(ccx: @mut CrateContext,\n     let _icx = push_ctxt(\"impl::trans_impl\");\n     let tcx = ccx.tcx;\n \n-    debug!(\"trans_impl(path=%s, name=%s, id=%?)\",\n+    debug2!(\"trans_impl(path={}, name={}, id={:?})\",\n            path.repr(tcx), name.repr(tcx), id);\n \n     // Both here and below with generic methods, be sure to recurse and look for\n@@ -117,7 +117,7 @@ pub fn trans_method(ccx: @mut CrateContext,\n                 ty::subst_tps(ccx.tcx, *tys, *self_sub, self_ty)\n             }\n         };\n-        debug!(\"calling trans_fn with self_ty %s\",\n+        debug2!(\"calling trans_fn with self_ty {}\",\n                self_ty.repr(ccx.tcx));\n         match method.explicit_self.node {\n           ast::sty_value => impl_self(self_ty, ty::ByRef),\n@@ -161,7 +161,7 @@ pub fn trans_method_callee(bcx: @mut Block,\n                            -> Callee {\n     let _icx = push_ctxt(\"impl::trans_method_callee\");\n \n-    debug!(\"trans_method_callee(callee_id=%?, this=%s, mentry=%s)\",\n+    debug2!(\"trans_method_callee(callee_id={:?}, this={}, mentry={})\",\n            callee_id,\n            bcx.expr_to_str(this),\n            mentry.repr(bcx.tcx()));\n@@ -199,7 +199,7 @@ pub fn trans_method_callee(bcx: @mut Block,\n                                                trait_id, off, vtbl)\n                 }\n                 // how to get rid of this?\n-                None => fail!(\"trans_method_callee: missing param_substs\")\n+                None => fail2!(\"trans_method_callee: missing param_substs\")\n             }\n         }\n \n@@ -220,8 +220,8 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n     let _icx = push_ctxt(\"impl::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_static_method_callee(method_id=%?, trait_id=%s, \\\n-            callee_id=%?)\",\n+    debug2!(\"trans_static_method_callee(method_id={:?}, trait_id={}, \\\n+            callee_id={:?})\",\n            method_id,\n            ty::item_path_str(bcx.tcx(), trait_id),\n            callee_id);\n@@ -250,17 +250,17 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n             ast_map::node_trait_method(trait_method, _, _) => {\n                 ast_util::trait_method_to_ty_method(trait_method).ident\n             }\n-            _ => fail!(\"callee is not a trait method\")\n+            _ => fail2!(\"callee is not a trait method\")\n         }\n     } else {\n         let path = csearch::get_item_path(bcx.tcx(), method_id);\n         match path[path.len()-1] {\n             path_pretty_name(s, _) | path_name(s) => { s }\n-            path_mod(_) => { fail!(\"path doesn't have a name?\") }\n+            path_mod(_) => { fail2!(\"path doesn't have a name?\") }\n         }\n     };\n-    debug!(\"trans_static_method_callee: method_id=%?, callee_id=%?, \\\n-            name=%s\", method_id, callee_id, ccx.sess.str_of(mname));\n+    debug2!(\"trans_static_method_callee: method_id={:?}, callee_id={:?}, \\\n+            name={}\", method_id, callee_id, ccx.sess.str_of(mname));\n \n     let vtbls = resolve_vtables_in_fn_ctxt(\n         bcx.fcx, ccx.maps.vtable_map.get_copy(&callee_id));\n@@ -287,7 +287,7 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n             FnData {llfn: PointerCast(bcx, lval, llty)}\n         }\n         _ => {\n-            fail!(\"vtable_param left in monomorphized \\\n+            fail2!(\"vtable_param left in monomorphized \\\n                    function's vtable substs\");\n         }\n     }\n@@ -362,7 +362,7 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n           }\n       }\n       typeck::vtable_param(*) => {\n-          fail!(\"vtable_param left in monomorphized function's vtable substs\");\n+          fail2!(\"vtable_param left in monomorphized function's vtable substs\");\n       }\n     };\n \n@@ -395,13 +395,13 @@ pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n     let method = ty::method(ccx.tcx, mth_did);\n     let n_m_tps = method.generics.type_param_defs.len();\n     let node_substs = node_id_type_params(bcx, callee_id);\n-    debug!(\"rcvr_substs=%?\", rcvr_substs.repr(ccx.tcx));\n+    debug2!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx));\n     let ty_substs\n         = vec::append(rcvr_substs.to_owned(),\n                       node_substs.tailn(node_substs.len() - n_m_tps));\n-    debug!(\"n_m_tps=%?\", n_m_tps);\n-    debug!(\"node_substs=%?\", node_substs.repr(ccx.tcx));\n-    debug!(\"ty_substs=%?\", ty_substs.repr(ccx.tcx));\n+    debug2!(\"n_m_tps={:?}\", n_m_tps);\n+    debug2!(\"node_substs={:?}\", node_substs.repr(ccx.tcx));\n+    debug2!(\"ty_substs={:?}\", ty_substs.repr(ccx.tcx));\n \n \n     // Now, do the same work for the vtables.  The vtables might not\n@@ -474,13 +474,13 @@ pub fn trans_trait_callee_from_llval(bcx: @mut Block,\n     let ccx = bcx.ccx();\n \n     // Load the data pointer from the object.\n-    debug!(\"(translating trait callee) loading second index from pair\");\n+    debug2!(\"(translating trait callee) loading second index from pair\");\n     let llboxptr = GEPi(bcx, llpair, [0u, abi::trt_field_box]);\n     let llbox = Load(bcx, llboxptr);\n     let llself = PointerCast(bcx, llbox, Type::opaque_box(ccx).ptr_to());\n \n     // Load the function from the vtable and cast it to the expected type.\n-    debug!(\"(translating trait callee) loading method\");\n+    debug2!(\"(translating trait callee) loading method\");\n     let llcallee_ty = type_of_fn_from_ty(ccx, callee_ty);\n     let llvtable = Load(bcx,\n                         PointerCast(bcx,\n@@ -524,7 +524,7 @@ pub fn vtable_id(ccx: @mut CrateContext,\n         }\n \n         // can't this be checked at the callee?\n-        _ => fail!(\"vtable_id\")\n+        _ => fail2!(\"vtable_id\")\n     }\n }\n \n@@ -578,7 +578,7 @@ pub fn make_vtable(ccx: &mut CrateContext,\n \n         let tbl = C_struct(components);\n         let sym = token::gensym(\"vtable\");\n-        let vt_gvar = do fmt!(\"vtable%u\", sym).with_c_str |buf| {\n+        let vt_gvar = do format!(\"vtable{}\", sym).with_c_str |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n         };\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n@@ -611,15 +611,15 @@ fn emit_vtable_methods(bcx: @mut Block,\n         // the method type from the impl to substitute into.\n         let m_id = method_with_name(ccx, impl_id, ident.name);\n         let m = ty::method(tcx, m_id);\n-        debug!(\"(making impl vtable) emitting method %s at subst %s\",\n+        debug2!(\"(making impl vtable) emitting method {} at subst {}\",\n                m.repr(tcx),\n                substs.repr(tcx));\n         let fty = ty::subst_tps(tcx,\n                                 substs,\n                                 None,\n                                 ty::mk_bare_fn(tcx, m.fty.clone()));\n         if m.generics.has_type_params() || ty::type_has_self(fty) {\n-            debug!(\"(making impl vtable) method has self or type params: %s\",\n+            debug2!(\"(making impl vtable) method has self or type params: {}\",\n                    tcx.sess.str_of(ident));\n             C_null(Type::nil().ptr_to())\n         } else {"}, {"sha": "79b3453037d103b8a0f392708a62ef44669cff1b", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -36,12 +36,12 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                       ref_id: Option<ast::NodeId>)\n     -> (ValueRef, bool)\n {\n-    debug!(\"monomorphic_fn(\\\n-            fn_id=%s, \\\n-            real_substs=%s, \\\n-            vtables=%s, \\\n-            self_vtable=%s, \\\n-            ref_id=%?)\",\n+    debug2!(\"monomorphic_fn(\\\n+            fn_id={}, \\\n+            real_substs={}, \\\n+            vtables={}, \\\n+            self_vtable={}, \\\n+            ref_id={:?})\",\n            fn_id.repr(ccx.tcx),\n            real_substs.repr(ccx.tcx),\n            vtables.repr(ccx.tcx),\n@@ -68,17 +68,17 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n         must_cast = true;\n     }\n \n-    debug!(\"monomorphic_fn(\\\n-            fn_id=%s, \\\n-            psubsts=%s, \\\n-            hash_id=%?)\",\n+    debug2!(\"monomorphic_fn(\\\n+            fn_id={}, \\\n+            psubsts={}, \\\n+            hash_id={:?})\",\n            fn_id.repr(ccx.tcx),\n            psubsts.repr(ccx.tcx),\n            hash_id);\n \n     match ccx.monomorphized.find(&hash_id) {\n       Some(&val) => {\n-        debug!(\"leaving monomorphic fn %s\",\n+        debug2!(\"leaving monomorphic fn {}\",\n                ty::item_path_str(ccx.tcx, fn_id));\n         return (val, must_cast);\n       }\n@@ -95,7 +95,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     let map_node = session::expect(\n         ccx.sess,\n         ccx.tcx.items.find_copy(&fn_id.node),\n-        || fmt!(\"While monomorphizing %?, couldn't find it in the item map \\\n+        || format!(\"While monomorphizing {:?}, couldn't find it in the item map \\\n                  (may have attempted to monomorphize an item \\\n                  defined in a different crate?)\", fn_id));\n     // Get the path so that we can create a symbol\n@@ -140,7 +140,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       ast_map::node_struct_ctor(_, i, pt) => (pt, i.ident, i.span)\n     };\n \n-    debug!(\"monomorphic_fn about to subst into %s\", llitem_ty.repr(ccx.tcx));\n+    debug2!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx));\n     let mono_ty = match is_static_provided {\n         None => ty::subst_tps(ccx.tcx, psubsts.tys,\n                               psubsts.self_ty, llitem_ty),\n@@ -164,7 +164,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                 (psubsts.tys.slice(0, idx) +\n                  &[psubsts.self_ty.unwrap()] +\n                  psubsts.tys.tailn(idx));\n-            debug!(\"static default: changed substitution to %s\",\n+            debug2!(\"static default: changed substitution to {}\",\n                    substs.repr(ccx.tcx));\n \n             ty::subst_tps(ccx.tcx, substs, None, llitem_ty)\n@@ -176,7 +176,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n             assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n             f\n         }\n-        _ => fail!(\"expected bare rust fn or an intrinsic\")\n+        _ => fail2!(\"expected bare rust fn or an intrinsic\")\n     };\n \n     ccx.stats.n_monos += 1;\n@@ -197,7 +197,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     let mut pt = (*pt).clone();\n     pt.push(elt);\n     let s = mangle_exported_name(ccx, pt.clone(), mono_ty);\n-    debug!(\"monomorphize_fn mangled to %s\", s);\n+    debug2!(\"monomorphize_fn mangled to {}\", s);\n \n     let mk_lldecl = || {\n         let lldecl = decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, s);\n@@ -285,12 +285,12 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       ast_map::node_block(*) |\n       ast_map::node_callee_scope(*) |\n       ast_map::node_local(*) => {\n-        ccx.tcx.sess.bug(fmt!(\"Can't monomorphize a %?\", map_node))\n+        ccx.tcx.sess.bug(format!(\"Can't monomorphize a {:?}\", map_node))\n       }\n     };\n     ccx.monomorphizing.insert(fn_id, depth);\n \n-    debug!(\"leaving monomorphic fn %s\", ty::item_path_str(ccx.tcx, fn_id));\n+    debug2!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx, fn_id));\n     (lldecl, must_cast)\n }\n \n@@ -302,7 +302,7 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n     let substs_iter = substs.self_ty.iter().chain(substs.tys.iter());\n     let precise_param_ids: ~[(ty::t, Option<@~[mono_id]>)] = match substs.vtables {\n       Some(vts) => {\n-        debug!(\"make_mono_id vtables=%s substs=%s\",\n+        debug2!(\"make_mono_id vtables={} substs={}\",\n                vts.repr(ccx.tcx), substs.tys.repr(ccx.tcx));\n         let vts_iter = substs.self_vtables.iter().chain(vts.iter());\n         vts_iter.zip(substs_iter).map(|(vtable, subst)| {"}, {"sha": "b63533b1559d3017fc33b5ac7414fea1b625e84b", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -93,15 +93,15 @@ impl Reflector {\n         let tcx = self.bcx.tcx();\n         let mth_idx = ty::method_idx(\n             tcx.sess.ident_of(~\"visit_\" + ty_name),\n-            *self.visitor_methods).expect(fmt!(\"Couldn't find visit method \\\n-                                                for %s\", ty_name));\n+            *self.visitor_methods).expect(format!(\"Couldn't find visit method \\\n+                                                for {}\", ty_name));\n         let mth_ty =\n             ty::mk_bare_fn(tcx, self.visitor_methods[mth_idx].fty.clone());\n         let v = self.visitor_val;\n-        debug!(\"passing %u args:\", args.len());\n+        debug2!(\"passing {} args:\", args.len());\n         let mut bcx = self.bcx;\n         for (i, a) in args.iter().enumerate() {\n-            debug!(\"arg %u: %s\", i, bcx.val_to_str(*a));\n+            debug2!(\"arg {}: {}\", i, bcx.val_to_str(*a));\n         }\n         let bool_ty = ty::mk_bool();\n         let result = unpack_result!(bcx, callee::trans_call_inner(\n@@ -151,7 +151,7 @@ impl Reflector {\n     pub fn visit_ty(&mut self, t: ty::t) {\n         let bcx = self.bcx;\n         let tcx = bcx.ccx().tcx;\n-        debug!(\"reflect::visit_ty %s\", ty_to_str(bcx.ccx().tcx, t));\n+        debug2!(\"reflect::visit_ty {}\", ty_to_str(bcx.ccx().tcx, t));\n \n         match ty::get(t).sty {\n           ty::ty_bot => self.leaf(\"bot\"),"}, {"sha": "896ce4be33726bc77e59ea9d9ccfe58a6fd3f4f7", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -149,7 +149,7 @@ pub struct VecTypes {\n \n impl VecTypes {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        fmt!(\"VecTypes {vec_ty=%s, unit_ty=%s, llunit_ty=%s, llunit_size=%s}\",\n+        format!(\"VecTypes \\\\{vec_ty={}, unit_ty={}, llunit_ty={}, llunit_size={}\\\\}\",\n              ty_to_str(ccx.tcx, self.vec_ty),\n              ty_to_str(ccx.tcx, self.unit_ty),\n              ccx.tn.type_to_str(self.llunit_ty),\n@@ -169,7 +169,7 @@ pub fn trans_fixed_vstore(bcx: @mut Block,\n     // to store the array of the suitable size, so all we have to do is\n     // generate the content.\n \n-    debug!(\"trans_fixed_vstore(vstore_expr=%s, dest=%?)\",\n+    debug2!(\"trans_fixed_vstore(vstore_expr={}, dest={:?})\",\n            bcx.expr_to_str(vstore_expr), dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n \n@@ -199,7 +199,7 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n \n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_slice_vstore(vstore_expr=%s, dest=%s)\",\n+    debug2!(\"trans_slice_vstore(vstore_expr={}, dest={})\",\n            bcx.expr_to_str(vstore_expr), dest.to_str(ccx));\n     let _indenter = indenter();\n \n@@ -214,7 +214,7 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n     // Handle the &[...] case:\n     let vt = vec_types_from_expr(bcx, vstore_expr);\n     let count = elements_required(bcx, content_expr);\n-    debug!(\"vt=%s, count=%?\", vt.to_str(ccx), count);\n+    debug2!(\"vt={}, count={:?}\", vt.to_str(ccx), count);\n \n     // Make a fixed-length backing array and allocate it on the stack.\n     let llcount = C_uint(ccx, count);\n@@ -256,7 +256,7 @@ pub fn trans_lit_str(bcx: @mut Block,\n     // different from trans_slice_vstore() above because it does need to copy\n     // the content anywhere.\n \n-    debug!(\"trans_lit_str(lit_expr=%s, dest=%s)\",\n+    debug2!(\"trans_lit_str(lit_expr={}, dest={})\",\n            bcx.expr_to_str(lit_expr),\n            dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n@@ -287,7 +287,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: &a\n     // @[...] or ~[...] (also @\"...\" or ~\"...\") allocate boxes in the\n     // appropriate heap and write the array elements into them.\n \n-    debug!(\"trans_uniq_or_managed_vstore(vstore_expr=%s, heap=%?)\",\n+    debug2!(\"trans_uniq_or_managed_vstore(vstore_expr={}, heap={:?})\",\n            bcx.expr_to_str(vstore_expr), heap);\n     let _indenter = indenter();\n \n@@ -318,7 +318,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: &a\n                 _ => {}\n             }\n         }\n-        heap_exchange_closure => fail!(\"vectors use exchange_alloc\"),\n+        heap_exchange_closure => fail2!(\"vectors use exchange_alloc\"),\n         heap_managed | heap_managed_unique => {}\n     }\n \n@@ -330,7 +330,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: &a\n     add_clean_free(bcx, val, heap);\n     let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val, vt.vec_ty));\n \n-    debug!(\"alloc_vec() returned val=%s, dataptr=%s\",\n+    debug2!(\"alloc_vec() returned val={}, dataptr={}\",\n            bcx.val_to_str(val), bcx.val_to_str(dataptr));\n \n     let bcx = write_content(bcx, &vt, vstore_expr,\n@@ -350,7 +350,7 @@ pub fn write_content(bcx: @mut Block,\n     let _icx = push_ctxt(\"tvec::write_content\");\n     let mut bcx = bcx;\n \n-    debug!(\"write_content(vt=%s, dest=%s, vstore_expr=%?)\",\n+    debug2!(\"write_content(vt={}, dest={}, vstore_expr={:?})\",\n            vt.to_str(bcx.ccx()),\n            dest.to_str(bcx.ccx()),\n            bcx.expr_to_str(vstore_expr));\n@@ -383,7 +383,7 @@ pub fn write_content(bcx: @mut Block,\n                     let mut temp_cleanups = ~[];\n                     for (i, element) in elements.iter().enumerate() {\n                         let lleltptr = GEPi(bcx, lldest, [i]);\n-                        debug!(\"writing index %? with lleltptr=%?\",\n+                        debug2!(\"writing index {:?} with lleltptr={:?}\",\n                                i, bcx.val_to_str(lleltptr));\n                         bcx = expr::trans_into(bcx, *element,\n                                                SaveIn(lleltptr));"}, {"sha": "4a7351c207dc6a247d2be0c32fa8309d6d8de7a7", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -364,7 +364,7 @@ impl Type {\n             Double => 64,\n             X86_FP80 => 80,\n             FP128 | PPC_FP128 => 128,\n-            _ => fail!(\"llvm_float_width called on a non-float type\")\n+            _ => fail2!(\"llvm_float_width called on a non-float type\")\n         }\n     }\n }"}, {"sha": "72b7281148c3d3e1b3ee02253838d0cc97c814b7", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -162,7 +162,7 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n         }\n \n         ty::ty_self(_) | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n-            cx.tcx.sess.bug(fmt!(\"fictitious type %? in sizing_type_of()\", ty::get(t).sty))\n+            cx.tcx.sess.bug(format!(\"fictitious type {:?} in sizing_type_of()\", ty::get(t).sty))\n         }\n     };\n \n@@ -172,7 +172,7 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n-    debug!(\"type_of %?: %?\", t, ty::get(t));\n+    debug2!(\"type_of {:?}: {:?}\", t, ty::get(t));\n \n     // Check the cache.\n     match cx.lltypes.find(&t) {\n@@ -335,9 +335,9 @@ pub fn llvm_type_name(cx: &CrateContext,\n     let tstr = ppaux::parameterized(cx.tcx, ty::item_path_str(cx.tcx, did),\n                                     &ty::NonerasedRegions(opt_vec::Empty), tps);\n     if did.crate == 0 {\n-        fmt!(\"%s.%s\", name, tstr)\n+        format!(\"{}.{}\", name, tstr)\n     } else {\n-        fmt!(\"%s.%s[#%d]\", name, tstr, did.crate)\n+        format!(\"{}.{}[\\\\#{}]\", name, tstr, did.crate)\n     }\n }\n "}, {"sha": "f6c1741a9bd6e2993395f5228d0c720b6f9e5886", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -39,7 +39,7 @@ pub fn root_and_write_guard(datum: &Datum,\n                             expr_id: ast::NodeId,\n                             derefs: uint) -> @mut Block {\n     let key = root_map_key { id: expr_id, derefs: derefs };\n-    debug!(\"write_guard::root_and_write_guard(key=%?)\", key);\n+    debug2!(\"write_guard::root_and_write_guard(key={:?})\", key);\n \n     // root the autoderef'd value, if necessary:\n     //\n@@ -66,7 +66,7 @@ pub fn return_to_mut(mut bcx: @mut Block,\n                      bits_val_ref: ValueRef,\n                      filename_val: ValueRef,\n                      line_val: ValueRef) -> @mut Block {\n-    debug!(\"write_guard::return_to_mut(root_key=%?, %s, %s, %s)\",\n+    debug2!(\"write_guard::return_to_mut(root_key={:?}, {}, {}, {})\",\n            root_key,\n            bcx.to_str(),\n            bcx.val_to_str(frozen_val_ref),\n@@ -111,13 +111,13 @@ fn root(datum: &Datum,\n     //! case, we will call this function, which will stash a copy\n     //! away until we exit the scope `scope_id`.\n \n-    debug!(\"write_guard::root(root_key=%?, root_info=%?, datum=%?)\",\n+    debug2!(\"write_guard::root(root_key={:?}, root_info={:?}, datum={:?})\",\n            root_key, root_info, datum.to_str(bcx.ccx()));\n \n     if bcx.sess().trace() {\n         trans_trace(\n             bcx, None,\n-            (fmt!(\"preserving until end of scope %d\",\n+            (format!(\"preserving until end of scope {}\",\n                   root_info.scope)).to_managed());\n     }\n \n@@ -184,7 +184,7 @@ fn root(datum: &Datum,\n fn perform_write_guard(datum: &Datum,\n                        bcx: @mut Block,\n                        span: Span) -> @mut Block {\n-    debug!(\"perform_write_guard\");\n+    debug2!(\"perform_write_guard\");\n \n     let llval = datum.to_value_llval(bcx);\n     let (filename, line) = filename_and_line_num_from_span(bcx, span);"}, {"sha": "ef6809c15c8955ed79e6cf35f46073e4e9acc826", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -794,31 +794,31 @@ impl Vid for TyVid {\n }\n \n impl ToStr for TyVid {\n-    fn to_str(&self) -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n+    fn to_str(&self) -> ~str { format!(\"<V{}>\", self.to_uint()) }\n }\n \n impl Vid for IntVid {\n     fn to_uint(&self) -> uint { **self }\n }\n \n impl ToStr for IntVid {\n-    fn to_str(&self) -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n+    fn to_str(&self) -> ~str { format!(\"<VI{}>\", self.to_uint()) }\n }\n \n impl Vid for FloatVid {\n     fn to_uint(&self) -> uint { **self }\n }\n \n impl ToStr for FloatVid {\n-    fn to_str(&self) -> ~str { fmt!(\"<VF%u>\", self.to_uint()) }\n+    fn to_str(&self) -> ~str { format!(\"<VF{}>\", self.to_uint()) }\n }\n \n impl Vid for RegionVid {\n     fn to_uint(&self) -> uint { self.id }\n }\n \n impl ToStr for RegionVid {\n-    fn to_str(&self) -> ~str { fmt!(\"%?\", self.id) }\n+    fn to_str(&self) -> ~str { format!(\"{:?}\", self.id) }\n }\n \n impl ToStr for FnSig {\n@@ -1515,7 +1515,7 @@ pub fn fold_regions(\n     fldr: &fn(r: Region, in_fn: bool) -> Region) -> t {\n     fn do_fold(cx: ctxt, ty: t, in_fn: bool,\n                fldr: &fn(Region, bool) -> Region) -> t {\n-        debug!(\"do_fold(ty=%s, in_fn=%b)\", ty_to_str(cx, ty), in_fn);\n+        debug2!(\"do_fold(ty={}, in_fn={})\", ty_to_str(cx, ty), in_fn);\n         if !type_has_regions(ty) { return ty; }\n         fold_regions_and_ty(\n             cx, ty,\n@@ -1656,7 +1656,7 @@ pub fn simd_type(cx: ctxt, ty: t) -> t {\n             let fields = lookup_struct_fields(cx, did);\n             lookup_field_type(cx, did, fields[0].id, substs)\n         }\n-        _ => fail!(\"simd_type called on invalid type\")\n+        _ => fail2!(\"simd_type called on invalid type\")\n     }\n }\n \n@@ -1666,14 +1666,14 @@ pub fn simd_size(cx: ctxt, ty: t) -> uint {\n             let fields = lookup_struct_fields(cx, did);\n             fields.len()\n         }\n-        _ => fail!(\"simd_size called on invalid type\")\n+        _ => fail2!(\"simd_size called on invalid type\")\n     }\n }\n \n pub fn get_element_type(ty: t, i: uint) -> t {\n     match get(ty).sty {\n       ty_tup(ref ts) => return ts[i],\n-      _ => fail!(\"get_element_type called on invalid type\")\n+      _ => fail2!(\"get_element_type called on invalid type\")\n     }\n }\n \n@@ -1950,7 +1950,7 @@ impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n \n impl ToStr for TypeContents {\n     fn to_str(&self) -> ~str {\n-        fmt!(\"TypeContents(%s)\", self.bits.to_str_radix(2))\n+        format!(\"TypeContents({})\", self.bits.to_str_radix(2))\n     }\n }\n \n@@ -2324,7 +2324,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n \n         let mut tc = TC_ALL;\n         do each_inherited_builtin_bound(cx, bounds, traits) |bound| {\n-            debug!(\"tc = %s, bound = %?\", tc.to_str(), bound);\n+            debug2!(\"tc = {}, bound = {:?}\", tc.to_str(), bound);\n             tc = tc - match bound {\n                 BoundStatic => TypeContents::nonstatic(cx),\n                 BoundSend => TypeContents::nonsendable(cx),\n@@ -2334,7 +2334,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             };\n         }\n \n-        debug!(\"result = %s\", tc.to_str());\n+        debug2!(\"result = {}\", tc.to_str());\n         return tc;\n \n         // Iterates over all builtin bounds on the type parameter def, including\n@@ -2364,7 +2364,7 @@ pub fn type_moves_by_default(cx: ctxt, ty: t) -> bool {\n pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n     fn type_requires(cx: ctxt, seen: &mut ~[DefId],\n                      r_ty: t, ty: t) -> bool {\n-        debug!(\"type_requires(%s, %s)?\",\n+        debug2!(\"type_requires({}, {})?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n                ::util::ppaux::ty_to_str(cx, ty));\n \n@@ -2373,7 +2373,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 subtypes_require(cx, seen, r_ty, ty)\n         };\n \n-        debug!(\"type_requires(%s, %s)? %b\",\n+        debug2!(\"type_requires({}, {})? {}\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n                ::util::ppaux::ty_to_str(cx, ty),\n                r);\n@@ -2382,7 +2382,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n \n     fn subtypes_require(cx: ctxt, seen: &mut ~[DefId],\n                         r_ty: t, ty: t) -> bool {\n-        debug!(\"subtypes_require(%s, %s)?\",\n+        debug2!(\"subtypes_require({}, {})?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n                ::util::ppaux::ty_to_str(cx, ty));\n \n@@ -2456,7 +2456,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             }\n         };\n \n-        debug!(\"subtypes_require(%s, %s)? %b\",\n+        debug2!(\"subtypes_require({}, {})? {}\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n                ::util::ppaux::ty_to_str(cx, ty),\n                r);\n@@ -2473,7 +2473,7 @@ pub fn type_structurally_contains(cx: ctxt,\n                                   test: &fn(x: &sty) -> bool)\n                                -> bool {\n     let sty = &get(ty).sty;\n-    debug!(\"type_structurally_contains: %s\",\n+    debug2!(\"type_structurally_contains: {}\",\n            ::util::ppaux::ty_to_str(cx, ty));\n     if test(sty) { return true; }\n     match *sty {\n@@ -2786,18 +2786,18 @@ pub fn node_id_to_trait_ref(cx: ctxt, id: ast::NodeId) -> @ty::TraitRef {\n     match cx.trait_refs.find(&id) {\n        Some(&t) => t,\n        None => cx.sess.bug(\n-           fmt!(\"node_id_to_trait_ref: no trait ref for node `%s`\",\n+           format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n                 ast_map::node_id_to_str(cx.items, id,\n                                         token::get_ident_interner())))\n     }\n }\n \n pub fn node_id_to_type(cx: ctxt, id: ast::NodeId) -> t {\n-    //printfln!(\"%?/%?\", id, cx.node_types.len());\n+    //printfln!(\"{:?}/{:?}\", id, cx.node_types.len());\n     match cx.node_types.find(&(id as uint)) {\n        Some(&t) => t,\n        None => cx.sess.bug(\n-           fmt!(\"node_id_to_type: no type for node `%s`\",\n+           format!(\"node_id_to_type: no type for node `{}`\",\n                 ast_map::node_id_to_str(cx.items, id,\n                                         token::get_ident_interner())))\n     }\n@@ -2820,7 +2820,7 @@ pub fn ty_fn_sig(fty: t) -> FnSig {\n         ty_bare_fn(ref f) => f.sig.clone(),\n         ty_closure(ref f) => f.sig.clone(),\n         ref s => {\n-            fail!(\"ty_fn_sig() called on non-fn type: %?\", s)\n+            fail2!(\"ty_fn_sig() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -2831,7 +2831,7 @@ pub fn ty_fn_args(fty: t) -> ~[t] {\n         ty_bare_fn(ref f) => f.sig.inputs.clone(),\n         ty_closure(ref f) => f.sig.inputs.clone(),\n         ref s => {\n-            fail!(\"ty_fn_args() called on non-fn type: %?\", s)\n+            fail2!(\"ty_fn_args() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -2840,7 +2840,7 @@ pub fn ty_closure_sigil(fty: t) -> Sigil {\n     match get(fty).sty {\n         ty_closure(ref f) => f.sigil,\n         ref s => {\n-            fail!(\"ty_closure_sigil() called on non-closure type: %?\", s)\n+            fail2!(\"ty_closure_sigil() called on non-closure type: {:?}\", s)\n         }\n     }\n }\n@@ -2850,7 +2850,7 @@ pub fn ty_fn_purity(fty: t) -> ast::purity {\n         ty_bare_fn(ref f) => f.purity,\n         ty_closure(ref f) => f.purity,\n         ref s => {\n-            fail!(\"ty_fn_purity() called on non-fn type: %?\", s)\n+            fail2!(\"ty_fn_purity() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -2860,7 +2860,7 @@ pub fn ty_fn_ret(fty: t) -> t {\n         ty_bare_fn(ref f) => f.sig.output,\n         ty_closure(ref f) => f.sig.output,\n         ref s => {\n-            fail!(\"ty_fn_ret() called on non-fn type: %?\", s)\n+            fail2!(\"ty_fn_ret() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -2877,7 +2877,7 @@ pub fn ty_vstore(ty: t) -> vstore {\n     match get(ty).sty {\n         ty_evec(_, vstore) => vstore,\n         ty_estr(vstore) => vstore,\n-        ref s => fail!(\"ty_vstore() called on invalid sty: %?\", s)\n+        ref s => fail2!(\"ty_vstore() called on invalid sty: {:?}\", s)\n     }\n }\n \n@@ -2891,7 +2891,7 @@ pub fn ty_region(tcx: ctxt,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n-                fmt!(\"ty_region() invoked on in appropriate ty: %?\", s));\n+                format!(\"ty_region() invoked on in appropriate ty: {:?}\", s));\n         }\n     }\n }\n@@ -2902,7 +2902,7 @@ pub fn replace_fn_sig(cx: ctxt, fsty: &sty, new_sig: FnSig) -> t {\n         ty_closure(ref f) => mk_closure(cx, ClosureTy {sig: new_sig, ..*f}),\n         ref s => {\n             cx.sess.bug(\n-                fmt!(\"ty_fn_sig() called on non-fn type: %?\", s));\n+                format!(\"ty_fn_sig() called on non-fn type: {:?}\", s));\n         }\n     }\n }\n@@ -2921,8 +2921,8 @@ pub fn replace_closure_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n             })\n         }\n         _ => {\n-            tcx.sess.bug(fmt!(\n-                \"replace_fn_ret() invoked with non-fn-type: %s\",\n+            tcx.sess.bug(format!(\n+                \"replace_fn_ret() invoked with non-fn-type: {}\",\n                 ty_to_str(tcx, fn_type)));\n         }\n     }\n@@ -3003,7 +3003,7 @@ pub fn adjust_ty(cx: ctxt,\n                 }\n                 ref b => {\n                     cx.sess.bug(\n-                        fmt!(\"add_env adjustment on non-bare-fn: %?\", b));\n+                        format!(\"add_env adjustment on non-bare-fn: {:?}\", b));\n                 }\n             }\n         }\n@@ -3018,7 +3018,7 @@ pub fn adjust_ty(cx: ctxt,\n                         None => {\n                             cx.sess.span_bug(\n                                 span,\n-                                fmt!(\"The %uth autoderef failed: %s\",\n+                                format!(\"The {}th autoderef failed: {}\",\n                                      i, ty_to_str(cx,\n                                                   adjusted_ty)));\n                         }\n@@ -3075,7 +3075,7 @@ pub fn adjust_ty(cx: ctxt,\n             ref s => {\n                 cx.sess.span_bug(\n                     span,\n-                    fmt!(\"borrow-vec associated with bad sty: %?\",\n+                    format!(\"borrow-vec associated with bad sty: {:?}\",\n                          s));\n             }\n         }\n@@ -3094,7 +3094,7 @@ pub fn adjust_ty(cx: ctxt,\n             ref s => {\n                 cx.sess.span_bug(\n                     span,\n-                    fmt!(\"borrow-fn associated with bad sty: %?\",\n+                    format!(\"borrow-fn associated with bad sty: {:?}\",\n                          s));\n             }\n         }\n@@ -3110,7 +3110,7 @@ pub fn adjust_ty(cx: ctxt,\n             ref s => {\n                 cx.sess.span_bug(\n                     span,\n-                    fmt!(\"borrow-trait-obj associated with bad sty: %?\",\n+                    format!(\"borrow-trait-obj associated with bad sty: {:?}\",\n                          s));\n             }\n         }\n@@ -3185,8 +3185,8 @@ pub fn resolve_expr(tcx: ctxt, expr: &ast::Expr) -> ast::Def {\n     match tcx.def_map.find(&expr.id) {\n         Some(&def) => def,\n         None => {\n-            tcx.sess.span_bug(expr.span, fmt!(\n-                \"No def-map entry for expr %?\", expr.id));\n+            tcx.sess.span_bug(expr.span, format!(\n+                \"No def-map entry for expr {:?}\", expr.id));\n         }\n     }\n }\n@@ -3244,8 +3244,8 @@ pub fn expr_kind(tcx: ctxt,\n                 ast::DefSelf(*) => LvalueExpr,\n \n                 def => {\n-                    tcx.sess.span_bug(expr.span, fmt!(\n-                        \"Uncategorized def for expr %?: %?\",\n+                    tcx.sess.span_bug(expr.span, format!(\n+                        \"Uncategorized def for expr {:?}: {:?}\",\n                         expr.id, def));\n                 }\n             }\n@@ -3311,7 +3311,7 @@ pub fn expr_kind(tcx: ctxt,\n             RvalueStmtExpr\n         }\n \n-        ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+        ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n \n         ast::ExprLogLevel |\n         ast::ExprLit(_) | // Note: lit_str is carved out above\n@@ -3339,7 +3339,7 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n       ast::StmtDecl(_, id) | StmtExpr(_, id) | StmtSemi(_, id) => {\n         return id;\n       }\n-      ast::StmtMac(*) => fail!(\"unexpanded macro in trans\")\n+      ast::StmtMac(*) => fail2!(\"unexpanded macro in trans\")\n     }\n }\n \n@@ -3353,8 +3353,8 @@ pub fn field_idx_strict(tcx: ty::ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n     for f in fields.iter() { if f.ident.name == name { return i; } i += 1u; }\n-    tcx.sess.bug(fmt!(\n-        \"No field named `%s` found in the list of fields `%?`\",\n+    tcx.sess.bug(format!(\n+        \"No field named `{}` found in the list of fields `{:?}`\",\n         token::interner_get(name),\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n@@ -3418,7 +3418,7 @@ pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n         ::util::ppaux::ty_to_str(cx, t)\n       }\n \n-      ty_enum(id, _) => fmt!(\"enum %s\", item_path_str(cx, id)),\n+      ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n       ty_box(_) => ~\"@-ptr\",\n       ty_uniq(_) => ~\"~-ptr\",\n       ty_evec(_, _) => ~\"vector\",\n@@ -3427,8 +3427,8 @@ pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_rptr(_, _) => ~\"&-ptr\",\n       ty_bare_fn(_) => ~\"extern fn\",\n       ty_closure(_) => ~\"fn\",\n-      ty_trait(id, _, _, _, _) => fmt!(\"trait %s\", item_path_str(cx, id)),\n-      ty_struct(id, _) => fmt!(\"struct %s\", item_path_str(cx, id)),\n+      ty_trait(id, _, _, _, _) => format!(\"trait {}\", item_path_str(cx, id)),\n+      ty_struct(id, _) => format!(\"struct {}\", item_path_str(cx, id)),\n       ty_tup(_) => ~\"tuple\",\n       ty_infer(TyVar(_)) => ~\"inferred type\",\n       ty_infer(IntVar(_)) => ~\"integral variable\",\n@@ -3461,19 +3461,19 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n     match *err {\n         terr_mismatch => ~\"types differ\",\n         terr_purity_mismatch(values) => {\n-            fmt!(\"expected %s fn but found %s fn\",\n+            format!(\"expected {} fn but found {} fn\",\n                  values.expected.to_str(), values.found.to_str())\n         }\n         terr_abi_mismatch(values) => {\n-            fmt!(\"expected %s fn but found %s fn\",\n+            format!(\"expected {} fn but found {} fn\",\n                  values.expected.to_str(), values.found.to_str())\n         }\n         terr_onceness_mismatch(values) => {\n-            fmt!(\"expected %s fn but found %s fn\",\n+            format!(\"expected {} fn but found {} fn\",\n                  values.expected.to_str(), values.found.to_str())\n         }\n         terr_sigil_mismatch(values) => {\n-            fmt!(\"expected %s closure, found %s closure\",\n+            format!(\"expected {} closure, found {} closure\",\n                  values.expected.to_str(),\n                  values.found.to_str())\n         }\n@@ -3483,97 +3483,97 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n         terr_ptr_mutability => ~\"pointers differ in mutability\",\n         terr_ref_mutability => ~\"references differ in mutability\",\n         terr_ty_param_size(values) => {\n-            fmt!(\"expected a type with %u type params \\\n-                  but found one with %u type params\",\n+            format!(\"expected a type with {} type params \\\n+                  but found one with {} type params\",\n                  values.expected, values.found)\n         }\n         terr_tuple_size(values) => {\n-            fmt!(\"expected a tuple with %u elements \\\n-                  but found one with %u elements\",\n+            format!(\"expected a tuple with {} elements \\\n+                  but found one with {} elements\",\n                  values.expected, values.found)\n         }\n         terr_record_size(values) => {\n-            fmt!(\"expected a record with %u fields \\\n-                  but found one with %u fields\",\n+            format!(\"expected a record with {} fields \\\n+                  but found one with {} fields\",\n                  values.expected, values.found)\n         }\n         terr_record_mutability => {\n             ~\"record elements differ in mutability\"\n         }\n         terr_record_fields(values) => {\n-            fmt!(\"expected a record with field `%s` but found one with field \\\n-                  `%s`\",\n+            format!(\"expected a record with field `{}` but found one with field \\\n+                  `{}`\",\n                  cx.sess.str_of(values.expected),\n                  cx.sess.str_of(values.found))\n         }\n         terr_arg_count => ~\"incorrect number of function parameters\",\n         terr_regions_does_not_outlive(*) => {\n-            fmt!(\"lifetime mismatch\")\n+            format!(\"lifetime mismatch\")\n         }\n         terr_regions_not_same(*) => {\n-            fmt!(\"lifetimes are not the same\")\n+            format!(\"lifetimes are not the same\")\n         }\n         terr_regions_no_overlap(*) => {\n-            fmt!(\"lifetimes do not intersect\")\n+            format!(\"lifetimes do not intersect\")\n         }\n         terr_regions_insufficiently_polymorphic(br, _) => {\n-            fmt!(\"expected bound lifetime parameter %s, \\\n+            format!(\"expected bound lifetime parameter {}, \\\n                   but found concrete lifetime\",\n                  bound_region_ptr_to_str(cx, br))\n         }\n         terr_regions_overly_polymorphic(br, _) => {\n-            fmt!(\"expected concrete lifetime, \\\n-                  but found bound lifetime parameter %s\",\n+            format!(\"expected concrete lifetime, \\\n+                  but found bound lifetime parameter {}\",\n                  bound_region_ptr_to_str(cx, br))\n         }\n         terr_vstores_differ(k, ref values) => {\n-            fmt!(\"%s storage differs: expected %s but found %s\",\n+            format!(\"{} storage differs: expected {} but found {}\",\n                  terr_vstore_kind_to_str(k),\n                  vstore_to_str(cx, (*values).expected),\n                  vstore_to_str(cx, (*values).found))\n         }\n         terr_trait_stores_differ(_, ref values) => {\n-            fmt!(\"trait storage differs: expected %s but found %s\",\n+            format!(\"trait storage differs: expected {} but found {}\",\n                  trait_store_to_str(cx, (*values).expected),\n                  trait_store_to_str(cx, (*values).found))\n         }\n         terr_in_field(err, fname) => {\n-            fmt!(\"in field `%s`, %s\", cx.sess.str_of(fname),\n+            format!(\"in field `{}`, {}\", cx.sess.str_of(fname),\n                  type_err_to_str(cx, err))\n         }\n         terr_sorts(values) => {\n-            fmt!(\"expected %s but found %s\",\n+            format!(\"expected {} but found {}\",\n                  ty_sort_str(cx, values.expected),\n                  ty_sort_str(cx, values.found))\n         }\n         terr_traits(values) => {\n-            fmt!(\"expected trait %s but found trait %s\",\n+            format!(\"expected trait {} but found trait {}\",\n                  item_path_str(cx, values.expected),\n                  item_path_str(cx, values.found))\n         }\n         terr_builtin_bounds(values) => {\n             if values.expected.is_empty() {\n-                fmt!(\"expected no bounds but found `%s`\",\n+                format!(\"expected no bounds but found `{}`\",\n                      values.found.user_string(cx))\n             } else if values.found.is_empty() {\n-                fmt!(\"expected bounds `%s` but found no bounds\",\n+                format!(\"expected bounds `{}` but found no bounds\",\n                      values.expected.user_string(cx))\n             } else {\n-                fmt!(\"expected bounds `%s` but found bounds `%s`\",\n+                format!(\"expected bounds `{}` but found bounds `{}`\",\n                      values.expected.user_string(cx),\n                      values.found.user_string(cx))\n             }\n         }\n         terr_integer_as_char => {\n-            fmt!(\"expected an integral type but found char\")\n+            format!(\"expected an integral type but found char\")\n         }\n         terr_int_mismatch(ref values) => {\n-            fmt!(\"expected %s but found %s\",\n+            format!(\"expected {} but found {}\",\n                  values.expected.to_str(),\n                  values.found.to_str())\n         }\n         terr_float_mismatch(ref values) => {\n-            fmt!(\"expected %s but found %s\",\n+            format!(\"expected {} but found {}\",\n                  values.expected.to_str(),\n                  values.found.to_str())\n         }\n@@ -3633,7 +3633,7 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n                 match ast_util::split_trait_methods(*ms) {\n                    (_, p) => p.map(|m| method(cx, ast_util::local_def(m.id)))\n                 },\n-            _ => cx.sess.bug(fmt!(\"provided_trait_methods: %? is not a trait\",\n+            _ => cx.sess.bug(format!(\"provided_trait_methods: {:?} is not a trait\",\n                                   id))\n         }\n     } else {\n@@ -3690,7 +3690,7 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     }\n \n     if def_id.crate == ast::LOCAL_CRATE {\n-        fail!(\"No def'n found for %? in tcx.%s\", def_id, descr);\n+        fail2!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n     }\n     let v = load_external();\n     map.insert(def_id, v.clone());\n@@ -3733,7 +3733,7 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n         None => {}\n     }\n     let ret = if id.crate == ast::LOCAL_CRATE {\n-        debug!(\"(impl_trait_ref) searching for trait impl %?\", id);\n+        debug2!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n         match cx.items.find(&id.node) {\n             Some(&ast_map::node_item(@ast::item {\n                                      node: ast::item_impl(_, ref opt_trait, _, _),\n@@ -3979,7 +3979,7 @@ pub fn item_path(cx: ctxt, id: ast::DefId) -> ast_map::path {\n           }\n \n           ref node => {\n-            cx.sess.bug(fmt!(\"cannot find item_path for node %?\", node));\n+            cx.sess.bug(format!(\"cannot find item_path for node {:?}\", node));\n           }\n         }\n     }\n@@ -4031,7 +4031,7 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n                             cx.sess.span_err(e.span, \"expected signed integer constant\");\n                         }\n                         Err(ref err) => {\n-                            cx.sess.span_err(e.span, fmt!(\"expected constant: %s\", (*err)));\n+                            cx.sess.span_err(e.span, format!(\"expected constant: {}\", (*err)));\n                         }\n                     },\n                     None => {}\n@@ -4111,7 +4111,7 @@ pub fn has_attr(tcx: ctxt, did: DefId, attr: &str) -> bool {\n                     attrs: ref attrs,\n                     _\n                 }, _)) => attr::contains_name(*attrs, attr),\n-            _ => tcx.sess.bug(fmt!(\"has_attr: %? is not an item\",\n+            _ => tcx.sess.bug(format!(\"has_attr: {:?} is not an item\",\n                                    did))\n         }\n     } else {\n@@ -4182,7 +4182,7 @@ pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> ~[field_ty] {\n        }\n        _ => {\n            cx.sess.bug(\n-               fmt!(\"struct ID not bound to an item: %s\",\n+               format!(\"struct ID not bound to an item: {}\",\n                     ast_map::node_id_to_str(cx.items, did.node,\n                                             token::get_ident_interner())));\n        }\n@@ -4486,7 +4486,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n \n         // Add the given trait ty to the hash map\n         while i < trait_refs.len() {\n-            debug!(\"each_bound_trait_and_supertraits(i=%?, trait_ref=%s)\",\n+            debug2!(\"each_bound_trait_and_supertraits(i={:?}, trait_ref={})\",\n                    i, trait_refs[i].repr(tcx));\n \n             if !f(trait_refs[i]) {\n@@ -4496,7 +4496,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n             // Add supertraits to supertrait_set\n             let supertrait_refs = trait_ref_supertraits(tcx, trait_refs[i]);\n             for &supertrait_ref in supertrait_refs.iter() {\n-                debug!(\"each_bound_trait_and_supertraits(supertrait_ref=%s)\",\n+                debug2!(\"each_bound_trait_and_supertraits(supertrait_ref={})\",\n                        supertrait_ref.repr(tcx));\n \n                 let d_id = supertrait_ref.def_id;"}, {"sha": "91bb4df301707c5764b5b70c51f8c5f677b3b3a7", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -92,12 +92,12 @@ pub fn get_region_reporting_err(\n         result::Err(ref e) => {\n             let descr = match a_r {\n                 &None => ~\"anonymous lifetime\",\n-                &Some(ref a) => fmt!(\"lifetime %s\",\n+                &Some(ref a) => format!(\"lifetime {}\",\n                                 lifetime_to_str(a, tcx.sess.intr()))\n             };\n             tcx.sess.span_err(\n                 span,\n-                fmt!(\"Illegal %s: %s\",\n+                format!(\"Illegal {}: {}\",\n                      descr, e.msg));\n             e.replacement\n         }\n@@ -157,7 +157,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope + Clone + 'static>(\n         (&None, &Some(_)) => {\n             tcx.sess.span_err(\n                 path.span,\n-                fmt!(\"no region bound is allowed on `%s`, \\\n+                format!(\"no region bound is allowed on `{}`, \\\n                       which is not declared as containing region pointers\",\n                      ty::item_path_str(tcx, def_id)));\n             opt_vec::Empty\n@@ -182,7 +182,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     if decl_generics.type_param_defs.len() != supplied_type_parameter_count {\n         this.tcx().sess.span_fatal(\n             path.span,\n-            fmt!(\"wrong number of type arguments: expected %u but found %u\",\n+            format!(\"wrong number of type arguments: expected {} but found {}\",\n                  decl_generics.type_param_defs.len(),\n                  supplied_type_parameter_count));\n     }\n@@ -428,7 +428,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n       ast::ty_path(ref path, ref bounds, id) => {\n         let a_def = match tcx.def_map.find(&id) {\n           None => tcx.sess.span_fatal(\n-              ast_ty.span, fmt!(\"unbound path %s\",\n+              ast_ty.span, format!(\"unbound path {}\",\n                                 path_to_str(path, tcx.sess.intr()))),\n           Some(&d) => d\n         };\n@@ -446,8 +446,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n               let path_str = path_to_str(path, tcx.sess.intr());\n               tcx.sess.span_err(\n                   ast_ty.span,\n-                  fmt!(\"reference to trait `%s` where a type is expected; \\\n-                        try `@%s`, `~%s`, or `&%s`\",\n+                  format!(\"reference to trait `{}` where a type is expected; \\\n+                        try `@{}`, `~{}`, or `&{}`\",\n                        path_str, path_str, path_str, path_str));\n               ty::mk_err()\n           }\n@@ -498,7 +498,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n           }\n           _ => {\n             tcx.sess.span_fatal(ast_ty.span,\n-                                fmt!(\"found value name used as a type: %?\", a_def));\n+                                format!(\"found value name used as a type: {:?}\", a_def));\n           }\n         }\n       }\n@@ -521,8 +521,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n           Err(ref r) => {\n             tcx.sess.span_fatal(\n                 ast_ty.span,\n-                fmt!(\"expected constant expr for vector length: %s\",\n-                     *r));\n+                format!(\"expected constant expr for vector length: {}\", *r));\n           }\n         }\n       }\n@@ -583,7 +582,7 @@ pub fn bound_lifetimes<AC:AstConv>(\n         if special_idents.iter().any(|&i| i == ast_lifetime.ident) {\n             this.tcx().sess.span_err(\n                 ast_lifetime.span,\n-                fmt!(\"illegal lifetime parameter name: `%s`\",\n+                format!(\"illegal lifetime parameter name: `{}`\",\n                      lifetime_to_str(ast_lifetime, this.tcx().sess.intr())));\n         } else {\n             bound_lifetime_names.push(ast_lifetime.ident);\n@@ -637,7 +636,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     opt_self_info: Option<&SelfInfo>,\n     decl: &ast::fn_decl) -> (Option<Option<ty::t>>, ty::BareFnTy)\n {\n-    debug!(\"ty_of_bare_fn\");\n+    debug2!(\"ty_of_bare_fn\");\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n@@ -718,7 +717,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     // names or they are provided, but not both.\n     assert!(lifetimes.is_empty() || expected_sig.is_none());\n \n-    debug!(\"ty_of_fn_decl\");\n+    debug2!(\"ty_of_fn_decl\");\n     let _i = indenter();\n \n     // resolve the function bound region in the original region\n@@ -807,7 +806,7 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n                         }\n                         tcx.sess.span_fatal(\n                             b.path.span,\n-                            fmt!(\"only the builtin traits can be used \\\n+                            format!(\"only the builtin traits can be used \\\n                                   as closure or object bounds\"));\n                     }\n                     ast::RegionTyParamBound => {"}, {"sha": "f022f2b3c4bce1c429fb30079450a16dc00948eb", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -166,7 +166,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::Pat, path: &ast::Path,\n                     fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                        |expected, actual| {\n                                                        expected.map_move_default(~\"\", |e| {\n-                        fmt!(\"mismatched types: expected `%s` but found %s\",\n+                        format!(\"mismatched types: expected `{}` but found {}\",\n                              e, actual)})},\n                              Some(expected), ~\"a structure pattern\",\n                              None);\n@@ -215,7 +215,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::Pat, path: &ast::Path,\n             fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                |expected, actual| {\n                                                expected.map_move_default(~\"\", |e| {\n-                    fmt!(\"mismatched types: expected `%s` but found %s\",\n+                    format!(\"mismatched types: expected `{}` but found {}\",\n                          e, actual)})},\n                     Some(expected), ~\"an enum or structure pattern\",\n                     None);\n@@ -241,7 +241,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::Pat, path: &ast::Path,\n     if arg_len > 0 {\n         // N-ary variant.\n         if arg_len != subpats_len {\n-            let s = fmt!(\"this pattern has %u field%s, but the corresponding %s has %u field%s\",\n+            let s = format!(\"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n                          subpats_len,\n                          if subpats_len == 1u { ~\"\" } else { ~\"s\" },\n                          kind_name,\n@@ -260,7 +260,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::Pat, path: &ast::Path,\n         }\n     } else if subpats_len > 0 {\n         tcx.sess.span_err(pat.span,\n-                          fmt!(\"this pattern has %u field%s, but the corresponding %s has no \\\n+                          format!(\"this pattern has {} field{}, but the corresponding {} has no \\\n                                 fields\",\n                                subpats_len,\n                                if subpats_len == 1u { \"\" } else { \"s\" },\n@@ -319,7 +319,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                 // up its type won't fail\n                 check_pat(pcx, field.pat, ty::mk_err());\n                 tcx.sess.span_err(span,\n-                    fmt!(\"struct `%s` does not have a field named `%s`\",\n+                    format!(\"struct `{}` does not have a field named `{}`\",\n                          name,\n                          tcx.sess.str_of(field.ident)));\n             }\n@@ -333,7 +333,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                 loop;\n             }\n             tcx.sess.span_err(span,\n-                              fmt!(\"pattern does not mention field `%s`\",\n+                              format!(\"pattern does not mention field `{}`\",\n                                    token::interner_get(field.name)));\n         }\n     }\n@@ -358,7 +358,7 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: Span,\n         Some(&ast::DefStruct(*)) | Some(&ast::DefVariant(*)) => {\n             let name = pprust::path_to_str(path, tcx.sess.intr());\n             tcx.sess.span_err(span,\n-                              fmt!(\"mismatched types: expected `%s` but found `%s`\",\n+                              format!(\"mismatched types: expected `{}` but found `{}`\",\n                                    fcx.infcx().ty_to_str(expected),\n                                    name));\n         }\n@@ -396,8 +396,8 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n         Some(&ast::DefStruct(*)) | Some(&ast::DefVariant(*)) => {\n             let name = pprust::path_to_str(path, tcx.sess.intr());\n             tcx.sess.span_err(span,\n-                              fmt!(\"mismatched types: expected `%s` but \\\n-                                    found `%s`\",\n+                              format!(\"mismatched types: expected `{}` but \\\n+                                    found `{}`\",\n                                    fcx.infcx().ty_to_str(expected),\n                                    name));\n         }\n@@ -428,8 +428,8 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n             fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(begin));\n         let e_ty =\n             fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(end));\n-        debug!(\"pat_range beginning type: %?\", b_ty);\n-        debug!(\"pat_range ending type: %?\", e_ty);\n+        debug2!(\"pat_range beginning type: {:?}\", b_ty);\n+        debug2!(\"pat_range ending type: {:?}\", e_ty);\n         if !require_same_types(\n             tcx, Some(fcx.infcx()), false, pat.span, b_ty, e_ty,\n             || ~\"mismatched types in range\")\n@@ -488,7 +488,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n         }\n         fcx.write_ty(pat.id, typ);\n \n-        debug!(\"(checking match) writing type for pat id %d\", pat.id);\n+        debug2!(\"(checking match) writing type for pat id {}\", pat.id);\n \n         match sub {\n           Some(p) => check_pat(pcx, p, expected),\n@@ -520,7 +520,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n                fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                                 |expected, actual| {\n                             expected.map_move_default(~\"\", |e| {\n-                                    fmt!(\"mismatched types: expected `%s` but found %s\",\n+                                    format!(\"mismatched types: expected `{}` but found {}\",\n                                          e, actual)})},\n                                          Some(expected), ~\"a structure pattern\",\n                                          None);\n@@ -567,7 +567,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n                 // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n                 fcx.infcx().type_error_message_str_with_expected(pat.span, |expected, actual| {\n                 expected.map_move_default(~\"\", |e| {\n-                    fmt!(\"mismatched types: expected `%s` but found %s\",\n+                    format!(\"mismatched types: expected `{}` but found {}\",\n                                      e, actual)})}, Some(expected), ~\"tuple\", Some(&type_error));\n                 fcx.write_error(pat.id);\n             }\n@@ -617,7 +617,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n                   pat.span,\n                   |expected, actual| {\n                       expected.map_move_default(~\"\", |e| {\n-                          fmt!(\"mismatched types: expected `%s` but found %s\",\n+                          format!(\"mismatched types: expected `{}` but found {}\",\n                                e, actual)})},\n                   Some(expected),\n                   ~\"a vector pattern\",\n@@ -676,10 +676,10 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n                 span,\n                 |expected, actual| {\n                     expected.map_move_default(~\"\", |e| {\n-                        fmt!(\"mismatched types: expected `%s` but found %s\",\n+                        format!(\"mismatched types: expected `{}` but found {}\",\n                              e, actual)})},\n                 Some(expected),\n-                fmt!(\"%s pattern\", match pointer_kind {\n+                format!(\"{} pattern\", match pointer_kind {\n                     Managed => \"an @-box\",\n                     Send => \"a ~-box\",\n                     Borrowed => \"an &-pointer\""}, {"sha": "a4538c961fd6d1e611b4358b5bc3edf85071bf61", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -151,18 +151,18 @@ pub fn lookup(\n     };\n \n     let self_ty = structurally_resolved_type(fcx, self_expr.span, self_ty);\n-    debug!(\"method lookup(self_ty=%s, expr=%s, self_expr=%s)\",\n+    debug2!(\"method lookup(self_ty={}, expr={}, self_expr={})\",\n            self_ty.repr(fcx.tcx()), expr.repr(fcx.tcx()),\n            self_expr.repr(fcx.tcx()));\n \n-    debug!(\"searching inherent candidates\");\n+    debug2!(\"searching inherent candidates\");\n     lcx.push_inherent_candidates(self_ty);\n     let mme = lcx.search(self_ty);\n     if mme.is_some() {\n         return mme;\n     }\n \n-    debug!(\"searching extension candidates\");\n+    debug2!(\"searching extension candidates\");\n     lcx.reset_candidates();\n     lcx.push_bound_candidates(self_ty);\n     lcx.push_extension_candidates();\n@@ -215,7 +215,7 @@ impl<'self> LookupContext<'self> {\n         let mut self_ty = self_ty;\n         let mut autoderefs = 0;\n         loop {\n-            debug!(\"loop: self_ty=%s autoderefs=%u\",\n+            debug2!(\"loop: self_ty={} autoderefs={}\",\n                    self.ty_to_str(self_ty), autoderefs);\n \n             match self.deref_args {\n@@ -397,7 +397,7 @@ impl<'self> LookupContext<'self> {\n     fn push_inherent_candidates_from_object(&self,\n                                             did: DefId,\n                                             substs: &ty::substs) {\n-        debug!(\"push_inherent_candidates_from_object(did=%s, substs=%s)\",\n+        debug2!(\"push_inherent_candidates_from_object(did={}, substs={})\",\n                self.did_to_str(did),\n                substs_to_str(self.tcx(), substs));\n         let _indenter = indenter();\n@@ -446,7 +446,7 @@ impl<'self> LookupContext<'self> {\n     fn push_inherent_candidates_from_param(&self,\n                                            rcvr_ty: ty::t,\n                                            param_ty: param_ty) {\n-        debug!(\"push_inherent_candidates_from_param(param_ty=%?)\",\n+        debug2!(\"push_inherent_candidates_from_param(param_ty={:?})\",\n                param_ty);\n         let _indenter = indenter();\n \n@@ -456,7 +456,7 @@ impl<'self> LookupContext<'self> {\n             None => {\n                 tcx.sess.span_bug(\n                     self.expr.span,\n-                    fmt!(\"No param def for %?\", param_ty));\n+                    format!(\"No param def for {:?}\", param_ty));\n             }\n         };\n \n@@ -523,11 +523,11 @@ impl<'self> LookupContext<'self> {\n                     let cand = mk_cand(bound_trait_ref, method,\n                                        pos, this_bound_idx);\n \n-                    debug!(\"pushing inherent candidate for param: %?\", cand);\n+                    debug2!(\"pushing inherent candidate for param: {:?}\", cand);\n                     self.inherent_candidates.push(cand);\n                 }\n                 None => {\n-                    debug!(\"trait doesn't contain method: %?\",\n+                    debug2!(\"trait doesn't contain method: {:?}\",\n                     bound_trait_ref.def_id);\n                     // check next trait or bound\n                 }\n@@ -557,7 +557,7 @@ impl<'self> LookupContext<'self> {\n         if !self.impl_dups.insert(impl_info.did) {\n             return; // already visited\n         }\n-        debug!(\"push_candidates_from_impl: %s %s %s\",\n+        debug2!(\"push_candidates_from_impl: {} {} {}\",\n                token::interner_get(self.m_name),\n                impl_info.ident.repr(self.tcx()),\n                impl_info.methods.map(|m| m.ident).repr(self.tcx()));\n@@ -603,8 +603,8 @@ impl<'self> LookupContext<'self> {\n         match self.search_for_method(self_ty) {\n             None => None,\n             Some(mme) => {\n-                debug!(\"(searching for autoderef'd method) writing \\\n-                       adjustment (%u) to %d\",\n+                debug2!(\"(searching for autoderef'd method) writing \\\n+                       adjustment ({}) to {}\",\n                        autoderefs,\n                        self.self_expr.id);\n                 self.fcx.write_adjustment(self.self_expr.id, @autoadjust);\n@@ -795,7 +795,7 @@ impl<'self> LookupContext<'self> {\n \n             ty_opaque_closure_ptr(_) | ty_unboxed_vec(_) |\n             ty_opaque_box | ty_type | ty_infer(TyVar(_)) => {\n-                self.bug(fmt!(\"Unexpected type: %s\",\n+                self.bug(format!(\"Unexpected type: {}\",\n                               self.ty_to_str(self_ty)));\n             }\n         }\n@@ -832,22 +832,22 @@ impl<'self> LookupContext<'self> {\n \n     fn search_for_method(&self, rcvr_ty: ty::t)\n                              -> Option<method_map_entry> {\n-        debug!(\"search_for_method(rcvr_ty=%s)\", self.ty_to_str(rcvr_ty));\n+        debug2!(\"search_for_method(rcvr_ty={})\", self.ty_to_str(rcvr_ty));\n         let _indenter = indenter();\n \n         // I am not sure that inherent methods should have higher\n         // priority, but it is necessary ATM to handle some of the\n         // existing code.\n \n-        debug!(\"searching inherent candidates\");\n+        debug2!(\"searching inherent candidates\");\n         match self.consider_candidates(rcvr_ty, self.inherent_candidates) {\n             None => {}\n             Some(mme) => {\n                 return Some(mme);\n             }\n         }\n \n-        debug!(\"searching extension candidates\");\n+        debug2!(\"searching extension candidates\");\n         match self.consider_candidates(rcvr_ty, self.extension_candidates) {\n             None => {\n                 return None;\n@@ -896,7 +896,7 @@ impl<'self> LookupContext<'self> {\n             let mut j = i + 1;\n             while j < candidates.len() {\n                 let candidate_b = &candidates[j];\n-                debug!(\"attempting to merge %? and %?\",\n+                debug2!(\"attempting to merge {:?} and {:?}\",\n                        candidate_a, candidate_b);\n                 let candidates_same = match (&candidate_a.origin,\n                                              &candidate_b.origin) {\n@@ -936,7 +936,7 @@ impl<'self> LookupContext<'self> {\n         let tcx = self.tcx();\n         let fty = ty::mk_bare_fn(tcx, candidate.method_ty.fty.clone());\n \n-        debug!(\"confirm_candidate(expr=%s, candidate=%s, fty=%s)\",\n+        debug2!(\"confirm_candidate(expr={}, candidate={}, fty={})\",\n                self.expr.repr(tcx),\n                self.cand_to_str(candidate),\n                self.ty_to_str(fty));\n@@ -992,11 +992,11 @@ impl<'self> LookupContext<'self> {\n         };\n \n         // Compute the method type with type parameters substituted\n-        debug!(\"fty=%s all_substs=%s\",\n+        debug2!(\"fty={} all_substs={}\",\n                self.ty_to_str(fty),\n                ty::substs_to_str(tcx, &all_substs));\n         let fty = ty::subst(tcx, &all_substs, fty);\n-        debug!(\"after subst, fty=%s\", self.ty_to_str(fty));\n+        debug2!(\"after subst, fty={}\", self.ty_to_str(fty));\n \n         // Replace any bound regions that appear in the function\n         // signature with region variables\n@@ -1005,7 +1005,7 @@ impl<'self> LookupContext<'self> {\n             ref s => {\n                 tcx.sess.span_bug(\n                     self.expr.span,\n-                    fmt!(\"Invoking method with non-bare-fn ty: %?\", s));\n+                    format!(\"Invoking method with non-bare-fn ty: {:?}\", s));\n             }\n         };\n         let (_, opt_transformed_self_ty, fn_sig) =\n@@ -1019,7 +1019,7 @@ impl<'self> LookupContext<'self> {\n             purity: bare_fn_ty.purity,\n             abis: bare_fn_ty.abis.clone(),\n         });\n-        debug!(\"after replacing bound regions, fty=%s\", self.ty_to_str(fty));\n+        debug2!(\"after replacing bound regions, fty={}\", self.ty_to_str(fty));\n \n         let self_mode = get_mode_from_explicit_self(candidate.method_ty.explicit_self);\n \n@@ -1032,7 +1032,7 @@ impl<'self> LookupContext<'self> {\n                                 rcvr_ty, transformed_self_ty) {\n             result::Ok(_) => (),\n             result::Err(_) => {\n-                self.bug(fmt!(\"%s was a subtype of %s but now is not?\",\n+                self.bug(format!(\"{} was a subtype of {} but now is not?\",\n                               self.ty_to_str(rcvr_ty),\n                               self.ty_to_str(transformed_self_ty)));\n             }\n@@ -1106,7 +1106,7 @@ impl<'self> LookupContext<'self> {\n                     }\n                     _ => {\n                         self.bug(\n-                            fmt!(\"'impossible' transformed_self_ty: %s\",\n+                            format!(\"'impossible' transformed_self_ty: {}\",\n                                  transformed_self_ty.repr(self.tcx())));\n                     }\n                 }\n@@ -1189,12 +1189,12 @@ impl<'self> LookupContext<'self> {\n     // `rcvr_ty` is the type of the expression. It may be a subtype of a\n     // candidate method's `self_ty`.\n     fn is_relevant(&self, rcvr_ty: ty::t, candidate: &Candidate) -> bool {\n-        debug!(\"is_relevant(rcvr_ty=%s, candidate=%s)\",\n+        debug2!(\"is_relevant(rcvr_ty={}, candidate={})\",\n                self.ty_to_str(rcvr_ty), self.cand_to_str(candidate));\n \n         return match candidate.method_ty.explicit_self {\n             sty_static => {\n-                debug!(\"(is relevant?) explicit self is static\");\n+                debug2!(\"(is relevant?) explicit self is static\");\n                 false\n             }\n \n@@ -1203,7 +1203,7 @@ impl<'self> LookupContext<'self> {\n             }\n \n             sty_region(_, m) => {\n-                debug!(\"(is relevant?) explicit self is a region\");\n+                debug2!(\"(is relevant?) explicit self is a region\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n@@ -1220,7 +1220,7 @@ impl<'self> LookupContext<'self> {\n             }\n \n             sty_box(m) => {\n-                debug!(\"(is relevant?) explicit self is a box\");\n+                debug2!(\"(is relevant?) explicit self is a box\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_box(mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n@@ -1237,7 +1237,7 @@ impl<'self> LookupContext<'self> {\n             }\n \n             sty_uniq => {\n-                debug!(\"(is relevant?) explicit self is a unique pointer\");\n+                debug2!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(mt) => {\n                         rcvr_matches_ty(self.fcx, mt.ty, candidate)\n@@ -1303,31 +1303,31 @@ impl<'self> LookupContext<'self> {\n         let span = if did.crate == ast::LOCAL_CRATE {\n             match self.tcx().items.find(&did.node) {\n               Some(&ast_map::node_method(m, _, _)) => m.span,\n-              _ => fail!(\"report_static_candidate: bad item %?\", did)\n+              _ => fail2!(\"report_static_candidate: bad item {:?}\", did)\n             }\n         } else {\n             self.expr.span\n         };\n         self.tcx().sess.span_note(\n             span,\n-            fmt!(\"candidate #%u is `%s`\",\n+            format!(\"candidate \\\\#{} is `{}`\",\n                  (idx+1u),\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n     fn report_param_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n-            fmt!(\"candidate #%u derives from the bound `%s`\",\n+            format!(\"candidate \\\\#{} derives from the bound `{}`\",\n                  (idx+1u),\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n     fn report_trait_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n-            fmt!(\"candidate #%u derives from the type of the receiver, \\\n-                  which is the trait `%s`\",\n+            format!(\"candidate \\\\#{} derives from the type of the receiver, \\\n+                  which is the trait `{}`\",\n                  (idx+1u),\n                  ty::item_path_str(self.tcx(), did)));\n     }\n@@ -1345,7 +1345,7 @@ impl<'self> LookupContext<'self> {\n     }\n \n     fn cand_to_str(&self, cand: &Candidate) -> ~str {\n-        fmt!(\"Candidate(rcvr_ty=%s, rcvr_substs=%s, origin=%?)\",\n+        format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, origin={:?})\",\n              cand.rcvr_match_condition.repr(self.tcx()),\n              ty::substs_to_str(self.tcx(), &cand.rcvr_substs),\n              cand.origin)\n@@ -1371,10 +1371,10 @@ impl Repr for RcvrMatchCondition {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n             RcvrMatchesIfObject(d) => {\n-                fmt!(\"RcvrMatchesIfObject(%s)\", d.repr(tcx))\n+                format!(\"RcvrMatchesIfObject({})\", d.repr(tcx))\n             }\n             RcvrMatchesIfSubtype(t) => {\n-                fmt!(\"RcvrMatchesIfSubtype(%s)\", t.repr(tcx))\n+                format!(\"RcvrMatchesIfSubtype({})\", t.repr(tcx))\n             }\n         }\n     }"}, {"sha": "54de7fc1bab9996628bfa7743aab94bf9d80026c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 87, "deletions": 88, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -110,7 +110,6 @@ use util::ppaux::{bound_region_ptr_to_str};\n use util::ppaux;\n \n \n-use std::cast::transmute;\n use std::hashmap::HashMap;\n use std::result;\n use std::util::replace;\n@@ -363,7 +362,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n               _ => Some(self.fcx.to_ty(&local.ty))\n             };\n             self.assign(local.id, o_ty);\n-            debug!(\"Local variable %s is assigned type %s\",\n+            debug2!(\"Local variable {} is assigned type {}\",\n                    self.fcx.pat_to_str(local.pat),\n                    self.fcx.infcx().ty_to_str(\n                        self.fcx.inh.locals.get_copy(&local.id)));\n@@ -376,7 +375,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n               ast::PatIdent(_, ref path, _)\n                   if pat_util::pat_is_binding(self.fcx.ccx.tcx.def_map, p) => {\n                 self.assign(p.id, None);\n-                debug!(\"Pattern binding %s is assigned to %s\",\n+                debug2!(\"Pattern binding {} is assigned to {}\",\n                        self.tcx.sess.str_of(path.segments[0].identifier),\n                        self.fcx.infcx().ty_to_str(\n                            self.fcx.inh.locals.get_copy(&p.id)));\n@@ -451,7 +450,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n     let arg_tys = fn_sig.inputs.map(|a| *a);\n     let ret_ty = fn_sig.output;\n \n-    debug!(\"check_fn(arg_tys=%?, ret_ty=%?, opt_self_ty=%?)\",\n+    debug2!(\"check_fn(arg_tys={:?}, ret_ty={:?}, opt_self_ty={:?})\",\n            arg_tys.map(|&a| ppaux::ty_to_str(tcx, a)),\n            ppaux::ty_to_str(tcx, ret_ty),\n            opt_self_info.map(|si| ppaux::ty_to_str(tcx, si.self_ty)));\n@@ -511,7 +510,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         // Add the self parameter\n         for self_info in opt_self_info.iter() {\n             visit.assign(self_info.self_id, Some(self_info.self_ty));\n-            debug!(\"self is assigned to %s\",\n+            debug2!(\"self is assigned to {}\",\n                    fcx.infcx().ty_to_str(\n                        fcx.inh.locals.get_copy(&self_info.self_id)));\n         }\n@@ -565,7 +564,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n         let orig_sp = field_names.find(&id).map_move(|x| *x);\n         match orig_sp {\n             Some(orig_sp) => {\n-                tcx.sess.span_err(sp, fmt!(\"Duplicate field name %s in record type declaration\",\n+                tcx.sess.span_err(sp, format!(\"Duplicate field name {} in record type declaration\",\n                                            tcx.sess.str_of(id)));\n                 tcx.sess.span_note(orig_sp, \"First declaration of this field occurred here\");\n                 break;\n@@ -589,7 +588,7 @@ pub fn check_struct(ccx: @mut CrateCtxt, id: ast::NodeId, span: Span) {\n }\n \n pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n-    debug!(\"check_item(it.id=%d, it.ident=%s)\",\n+    debug2!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n     let _indenter = indenter();\n@@ -607,7 +606,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       }\n       ast::item_impl(_, _, _, ref ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n-        debug!(\"item_impl %s with id %d rp %?\",\n+        debug2!(\"item_impl {} with id {} rp {:?}\",\n                ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         for m in ms.iter() {\n             check_method(ccx, *m);\n@@ -645,7 +644,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n                 if tpt.generics.has_type_params() {\n                     ccx.tcx.sess.span_err(\n                         item.span,\n-                        fmt!(\"foreign items may not have type parameters\"));\n+                        format!(\"foreign items may not have type parameters\"));\n                 }\n             }\n         }\n@@ -691,7 +690,7 @@ impl FnCtxt {\n                 } else {\n                     result::Err(RegionError {\n                         msg: {\n-                            fmt!(\"named region `%s` not in scope here\",\n+                            format!(\"named region `{}` not in scope here\",\n                                  bound_region_ptr_to_str(self.tcx(), br))\n                         },\n                         replacement: {\n@@ -722,7 +721,7 @@ impl RegionScope for FnCtxt {\n impl FnCtxt {\n     pub fn tag(&self) -> ~str {\n         unsafe {\n-            fmt!(\"%x\", transmute(self))\n+            format!(\"{}\", self as *FnCtxt)\n         }\n     }\n \n@@ -732,7 +731,7 @@ impl FnCtxt {\n             None => {\n                 self.tcx().sess.span_bug(\n                     span,\n-                    fmt!(\"No type for local variable %?\", nid));\n+                    format!(\"No type for local variable {:?}\", nid));\n             }\n         }\n     }\n@@ -743,14 +742,14 @@ impl FnCtxt {\n \n     #[inline]\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: ty::t) {\n-        debug!(\"write_ty(%d, %s) in fcx %s\",\n+        debug2!(\"write_ty({}, {}) in fcx {}\",\n                node_id, ppaux::ty_to_str(self.tcx(), ty), self.tag());\n         self.inh.node_types.insert(node_id, ty);\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::substs) {\n         if !ty::substs_is_noop(&substs) {\n-            debug!(\"write_substs(%d, %s) in fcx %s\",\n+            debug2!(\"write_substs({}, {}) in fcx {}\",\n                    node_id,\n                    ty::substs_to_str(self.tcx(), &substs),\n                    self.tag());\n@@ -782,7 +781,7 @@ impl FnCtxt {\n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n                             adj: @ty::AutoAdjustment) {\n-        debug!(\"write_adjustment(node_id=%?, adj=%?)\", node_id, adj);\n+        debug2!(\"write_adjustment(node_id={:?}, adj={:?})\", node_id, adj);\n         self.inh.adjustments.insert(node_id, adj);\n     }\n \n@@ -808,7 +807,7 @@ impl FnCtxt {\n         match self.inh.node_types.find(&ex.id) {\n             Some(&t) => t,\n             None => {\n-                self.tcx().sess.bug(fmt!(\"no type for expr in fcx %s\",\n+                self.tcx().sess.bug(format!(\"no type for expr in fcx {}\",\n                                          self.tag()));\n             }\n         }\n@@ -819,7 +818,7 @@ impl FnCtxt {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(\n-                    fmt!(\"no type for node %d: %s in fcx %s\",\n+                    format!(\"no type for node {}: {} in fcx {}\",\n                          id, ast_map::node_id_to_str(\n                              self.tcx().items, id,\n                              token::get_ident_interner()),\n@@ -833,7 +832,7 @@ impl FnCtxt {\n             Some(ts) => (*ts).clone(),\n             None => {\n                 self.tcx().sess.bug(\n-                    fmt!(\"no type substs for node %d: %s in fcx %s\",\n+                    format!(\"no type substs for node {}: {} in fcx {}\",\n                          id, ast_map::node_id_to_str(\n                              self.tcx().items, id,\n                              token::get_ident_interner()),\n@@ -1212,7 +1211,7 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n                     function_context.tcx()\n                                     .sess\n                                     .span_err(path.span,\n-                                              fmt!(\"this %s has a lifetime \\\n+                                              format!(\"this {} has a lifetime \\\n                                                     parameter but no \\\n                                                     lifetime was specified\",\n                                                    name))\n@@ -1221,7 +1220,7 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n                     function_context.tcx()\n                                     .sess\n                                     .span_err(path.span,\n-                                              fmt!(\"this %s has no lifetime \\\n+                                              format!(\"this {} has no lifetime \\\n                                                     parameter but a lifetime \\\n                                                     was specified\",\n                                                    name))\n@@ -1249,10 +1248,10 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n                 function_context.tcx()\n                                 .sess\n                                 .span_err(path.span,\n-                                          fmt!(\"the %s referenced by this \\\n-                                                path has %u type \\\n-                                                parameter%s, but %u type \\\n-                                                parameter%s were supplied\",\n+                                          format!(\"the {} referenced by this \\\n+                                                path has {} type \\\n+                                                parameter{}, but {} type \\\n+                                                parameter{} were supplied\",\n                                                name,\n                                                trait_type_parameter_count,\n                                                trait_count_suffix,\n@@ -1283,7 +1282,7 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n                 function_context.tcx()\n                                 .sess\n                                 .span_note(typ.span,\n-                                           fmt!(\"this is a %?\", def));\n+                                           format!(\"this is a {:?}\", def));\n             }\n         }\n     }\n@@ -1303,7 +1302,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                expr: @ast::Expr,\n                                expected: Option<ty::t>,\n                                unifier: &fn()) {\n-    debug!(\">> typechecking\");\n+    debug2!(\">> typechecking\");\n \n     fn check_method_argument_types(\n         fcx: @mut FnCtxt,\n@@ -1329,7 +1328,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 _ => {\n                     fcx.tcx().sess.span_bug(\n                         sp,\n-                        fmt!(\"Method without bare fn type\"));\n+                        format!(\"Method without bare fn type\"));\n                 }\n             }\n         }\n@@ -1366,8 +1365,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 ast::ForSugar => \" (including the closure passed by \\\n                                   the `for` keyword)\"\n             };\n-            let msg = fmt!(\"this function takes %u parameter%s but \\\n-                            %u parameter%s supplied%s\",\n+            let msg = format!(\"this function takes {} parameter{} but \\\n+                            {} parameter{} supplied{}\",\n                            expected_arg_count,\n                            if expected_arg_count == 1 {\"\"}\n                            else {\"s\"},\n@@ -1381,7 +1380,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             vec::from_elem(supplied_arg_count, ty::mk_err())\n         };\n \n-        debug!(\"check_argument_types: formal_tys=%?\",\n+        debug2!(\"check_argument_types: formal_tys={:?}\",\n                formal_tys.map(|t| fcx.infcx().ty_to_str(*t)));\n \n         // Check the arguments.\n@@ -1393,7 +1392,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let xs = [false, true];\n         for check_blocks in xs.iter() {\n             let check_blocks = *check_blocks;\n-            debug!(\"check_blocks=%b\", check_blocks);\n+            debug2!(\"check_blocks={}\", check_blocks);\n \n             // More awful hacks: before we check the blocks, try to do\n             // an \"opportunistic\" vtable resolution of any trait\n@@ -1410,7 +1409,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 };\n \n                 if is_block == check_blocks {\n-                    debug!(\"checking the argument\");\n+                    debug2!(\"checking the argument\");\n                     let mut formal_ty = formal_tys[i];\n \n                     match deref_args {\n@@ -1459,8 +1458,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 match ty::get(output).sty {\n                     ty::ty_bool => {}\n                     _ => fcx.type_error_message(call_expr.span, |actual| {\n-                            fmt!(\"expected `for` closure to return `bool`, \\\n-                                  but found `%s`\", actual) },\n+                            format!(\"expected `for` closure to return `bool`, \\\n+                                  but found `{}`\", actual) },\n                             output, None)\n                 }\n                 ty::mk_nil()\n@@ -1508,8 +1507,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => sig,\n             _ => {\n                 fcx.type_error_message(call_expr.span, |actual| {\n-                    fmt!(\"expected function but \\\n-                          found `%s`\", actual) }, fn_ty, None);\n+                    format!(\"expected function but \\\n+                          found `{}`\", actual) }, fn_ty, None);\n                 &error_fn_sig\n             }\n         };\n@@ -1564,12 +1563,12 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 method_map.insert(expr.id, (*entry));\n             }\n             None => {\n-                debug!(\"(checking method call) failing expr is %d\", expr.id);\n+                debug2!(\"(checking method call) failing expr is {}\", expr.id);\n \n                 fcx.type_error_message(expr.span,\n                   |actual| {\n-                      fmt!(\"type `%s` does not implement any method in scope \\\n-                            named `%s`\",\n+                      format!(\"type `{}` does not implement any method in scope \\\n+                            named `{}`\",\n                            actual,\n                            fcx.ccx.tcx.sess.str_of(method_name))\n                   },\n@@ -1721,8 +1720,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_error(expr.id);\n             fcx.write_error(rhs.id);\n             fcx.type_error_message(expr.span, |actual| {\n-                fmt!(\"binary operation %s cannot be applied \\\n-                      to type `%s`\",\n+                format!(\"binary operation {} cannot be applied \\\n+                      to type `{}`\",\n                      ast_util::binop_to_str(op), actual)},\n                                    lhs_t, None)\n \n@@ -1742,8 +1741,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         } else {\n             fcx.type_error_message(expr.span,\n                                    |actual| {\n-                                        fmt!(\"binary operation %s cannot be \\\n-                                              applied to type `%s`\",\n+                                        format!(\"binary operation {} cannot be \\\n+                                              applied to type `{}`\",\n                                              ast_util::binop_to_str(op),\n                                              actual)\n                                    },\n@@ -1771,8 +1770,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             Some(ref name) => {\n                 let if_op_unbound = || {\n                     fcx.type_error_message(ex.span, |actual| {\n-                        fmt!(\"binary operation %s cannot be applied \\\n-                              to type `%s`\",\n+                        format!(\"binary operation {} cannot be applied \\\n+                              to type `{}`\",\n                              ast_util::binop_to_str(op), actual)},\n                             lhs_resolved_t, None)\n                 };\n@@ -1815,7 +1814,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             DoDerefArgs, DontAutoderefReceiver,\n             || {\n                 fcx.type_error_message(ex.span, |actual| {\n-                    fmt!(\"cannot apply unary operator `%s` to type `%s`\",\n+                    format!(\"cannot apply unary operator `{}` to type `{}`\",\n                          op_str, actual)\n                 }, rhs_t, None);\n             }, expected_t)\n@@ -1918,7 +1917,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             ty::mk_closure(tcx, fn_ty_copy)\n         };\n \n-        debug!(\"check_expr_fn_with_unifier fty=%s\",\n+        debug2!(\"check_expr_fn_with_unifier fty={}\",\n                fcx.infcx().ty_to_str(fty));\n \n         fcx.write_ty(expr.id, fty);\n@@ -1952,7 +1951,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n                 // (1) verify that the class id actually has a field called\n                 // field\n-                debug!(\"class named %s\", ppaux::ty_to_str(tcx, base_t));\n+                debug2!(\"class named {}\", ppaux::ty_to_str(tcx, base_t));\n                 let cls_items = ty::lookup_struct_fields(tcx, base_id);\n                 match lookup_field_ty(tcx, base_id, cls_items,\n                                       field, &(*substs)) {\n@@ -1983,7 +1982,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 fcx.type_error_message(\n                     expr.span,\n                     |actual| {\n-                        fmt!(\"attempted to take value of method `%s` on type `%s` \\\n+                        format!(\"attempted to take value of method `{}` on type `{}` \\\n                               (try writing an anonymous function)\",\n                              token::interner_get(field), actual)\n                     },\n@@ -1994,7 +1993,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 fcx.type_error_message(\n                     expr.span,\n                     |actual| {\n-                        fmt!(\"attempted access of field `%s` on type `%s`, \\\n+                        format!(\"attempted access of field `{}` on type `{}`, \\\n                               but no field with that name was found\",\n                              token::interner_get(field), actual)\n                     },\n@@ -2032,14 +2031,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 None => {\n                     tcx.sess.span_err(\n                         field.span,\n-                        fmt!(\"structure has no field named `%s`\",\n+                        format!(\"structure has no field named `{}`\",\n                              tcx.sess.str_of(field.ident)));\n                     error_happened = true;\n                 }\n                 Some((_, true)) => {\n                     tcx.sess.span_err(\n                         field.span,\n-                        fmt!(\"field `%s` specified more than once\",\n+                        format!(\"field `{}` specified more than once\",\n                              tcx.sess.str_of(field.ident)));\n                     error_happened = true;\n                 }\n@@ -2079,7 +2078,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 }\n \n                 tcx.sess.span_err(span,\n-                                  fmt!(\"missing field%s: %s\",\n+                                  format!(\"missing field{}: {}\",\n                                        if missing_fields.len() == 1 {\n                                            \"\"\n                                        } else {\n@@ -2419,7 +2418,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                 _ => {\n                                     fcx.type_error_message(expr.span,\n                                         |actual| {\n-                                            fmt!(\"type %s cannot be dereferenced\", actual)\n+                                            format!(\"type {} cannot be dereferenced\", actual)\n                                     }, oprnd_t, None);\n                                 }\n                             }\n@@ -2567,7 +2566,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n       }\n       ast::ExprForLoop(*) =>\n-          fail!(\"non-desugared expr_for_loop\"),\n+          fail2!(\"non-desugared expr_for_loop\"),\n       ast::ExprLoop(ref body, _) => {\n         check_block_no_value(fcx, (body));\n         if !may_break(tcx, expr.id, body) {\n@@ -2593,8 +2592,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             _ => match expected {\n                 Some(expected_t) => {\n                     fcx.type_error_message(expr.span, |actual| {\n-                        fmt!(\"last argument in `do` call \\\n-                              has non-closure type: %s\",\n+                        format!(\"last argument in `do` call \\\n+                              has non-closure type: {}\",\n                              actual)\n                     }, expected_t, None);\n                     let err_ty = ty::mk_err();\n@@ -2615,7 +2614,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n           }\n           // argh\n-          _ => fail!(\"expected fn ty\")\n+          _ => fail2!(\"expected fn ty\")\n         }\n         fcx.write_ty(expr.id, fcx.node_ty(b.id));\n       }\n@@ -2659,8 +2658,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n \n-        debug!(\"t_1=%s\", fcx.infcx().ty_to_str(t_1));\n-        debug!(\"t_e=%s\", fcx.infcx().ty_to_str(t_e));\n+        debug2!(\"t_1={}\", fcx.infcx().ty_to_str(t_1));\n+        debug2!(\"t_e={}\", fcx.infcx().ty_to_str(t_e));\n \n         if ty::type_is_error(t_e) {\n             fcx.write_error(id);\n@@ -2676,12 +2675,12 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 _ => {\n                     if ty::type_is_nil(t_e) {\n                         fcx.type_error_message(expr.span, |actual| {\n-                            fmt!(\"cast from nil: `%s` as `%s`\", actual,\n+                            format!(\"cast from nil: `{}` as `{}`\", actual,\n                                  fcx.infcx().ty_to_str(t_1))\n                         }, t_e, None);\n                     } else if ty::type_is_nil(t_1) {\n                         fcx.type_error_message(expr.span, |actual| {\n-                            fmt!(\"cast to nil: `%s` as `%s`\", actual,\n+                            format!(\"cast to nil: `{}` as `{}`\", actual,\n                                  fcx.infcx().ty_to_str(t_1))\n                         }, t_e, None);\n                     }\n@@ -2698,7 +2697,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     } else if t_1_is_char {\n                         if ty::get(te).sty != ty::ty_uint(ast::ty_u8) {\n                             fcx.type_error_message(expr.span, |actual| {\n-                                fmt!(\"only `u8` can be cast as `char`, not `%s`\", actual)\n+                                format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n                             }, t_e, None);\n                         }\n                     } else if ty::get(t1).sty == ty::ty_bool {\n@@ -2752,7 +2751,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         record the issue number in this comment.\n                         */\n                         fcx.type_error_message(expr.span, |actual| {\n-                            fmt!(\"non-scalar cast: `%s` as `%s`\", actual,\n+                            format!(\"non-scalar cast: `{}` as `{}`\", actual,\n                                  fcx.infcx().ty_to_str(t_1))\n                         }, t_e, None);\n                     }\n@@ -2864,8 +2863,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                       let error_message = || {\n                         fcx.type_error_message(expr.span,\n                                                |actual| {\n-                                                fmt!(\"cannot index a value \\\n-                                                      of type `%s`\",\n+                                                format!(\"cannot index a value \\\n+                                                      of type `{}`\",\n                                                      actual)\n                                                },\n                                                base_t,\n@@ -2889,9 +2888,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n        }\n     }\n \n-    debug!(\"type of expr(%d) %s is...\", expr.id,\n+    debug2!(\"type of expr({}) {} is...\", expr.id,\n            syntax::print::pprust::expr_to_str(expr, tcx.sess.intr()));\n-    debug!(\"... %s, expected is %s\",\n+    debug2!(\"... {}, expected is {}\",\n            ppaux::ty_to_str(tcx, fcx.expr_ty(expr)),\n            match expected {\n                Some(t) => ppaux::ty_to_str(tcx, t),\n@@ -2904,7 +2903,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n pub fn require_integral(fcx: @mut FnCtxt, sp: Span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.type_error_message(sp, |actual| {\n-            fmt!(\"mismatched types: expected integral type but found `%s`\",\n+            format!(\"mismatched types: expected integral type but found `{}`\",\n                  actual)\n         }, t, None);\n     }\n@@ -3110,9 +3109,9 @@ pub fn check_instantiable(tcx: ty::ctxt,\n                           item_id: ast::NodeId) {\n     let item_ty = ty::node_id_to_type(tcx, item_id);\n     if !ty::is_instantiable(tcx, item_ty) {\n-        tcx.sess.span_err(sp, fmt!(\"this type cannot be instantiated \\\n+        tcx.sess.span_err(sp, format!(\"this type cannot be instantiated \\\n                   without an instance of itself; \\\n-                  consider using `Option<%s>`\",\n+                  consider using `Option<{}>`\",\n                                    ppaux::ty_to_str(tcx, item_ty)));\n     }\n }\n@@ -3171,7 +3170,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n \n             match v.node.disr_expr {\n                 Some(e) => {\n-                    debug!(\"disr expr, checking %s\", pprust::expr_to_str(e, ccx.tcx.sess.intr()));\n+                    debug2!(\"disr expr, checking {}\", pprust::expr_to_str(e, ccx.tcx.sess.intr()));\n \n                     let fcx = blank_fn_ctxt(ccx, rty, e.id);\n                     let declty = ty::mk_int_var(ccx.tcx, fcx.infcx().next_int_var_id());\n@@ -3187,7 +3186,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                             ccx.tcx.sess.span_err(e.span, \"expected signed integer constant\");\n                         }\n                         Err(ref err) => {\n-                            ccx.tcx.sess.span_err(e.span, fmt!(\"expected constant: %s\", (*err)));\n+                            ccx.tcx.sess.span_err(e.span, format!(\"expected constant: {}\", (*err)));\n                         }\n                     }\n                 },\n@@ -3301,15 +3300,15 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n                         def: ast::Def,\n                         span: Span,\n                         node_id: ast::NodeId) {\n-    debug!(\">>> instantiate_path\");\n+    debug2!(\">>> instantiate_path\");\n \n     let ty_param_count = tpt.generics.type_param_defs.len();\n     let mut ty_substs_len = 0;\n     for segment in pth.segments.iter() {\n         ty_substs_len += segment.types.len()\n     }\n \n-    debug!(\"tpt=%s ty_param_count=%? ty_substs_len=%?\",\n+    debug2!(\"tpt={} ty_param_count={:?} ty_substs_len={:?}\",\n            tpt.repr(fcx.tcx()),\n            ty_param_count,\n            ty_substs_len);\n@@ -3364,13 +3363,13 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n     } else if ty_substs_len > user_type_parameter_count {\n         fcx.ccx.tcx.sess.span_err\n             (span,\n-             fmt!(\"too many type parameters provided: expected %u, found %u\",\n+             format!(\"too many type parameters provided: expected {}, found {}\",\n                   user_type_parameter_count, ty_substs_len));\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else if ty_substs_len < user_type_parameter_count {\n         fcx.ccx.tcx.sess.span_err\n             (span,\n-             fmt!(\"not enough type parameters provided: expected %u, found %u\",\n+             format!(\"not enough type parameters provided: expected {}, found {}\",\n                   user_type_parameter_count, ty_substs_len));\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else {\n@@ -3408,7 +3407,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n     };\n     fcx.write_ty_substs(node_id, tpt.ty, substs);\n \n-    debug!(\"<<<\");\n+    debug2!(\"<<<\");\n }\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n@@ -3504,7 +3503,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n                              span: Span,\n                              tps: &OptVec<ast::TyParam>,\n                              ty: ty::t) {\n-    debug!(\"check_bounds_are_used(n_tps=%u, ty=%s)\",\n+    debug2!(\"check_bounds_are_used(n_tps={}, ty={})\",\n            tps.len(), ppaux::ty_to_str(ccx.tcx, ty));\n \n     // make a vector of booleans initially false, set to true when used\n@@ -3517,7 +3516,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n         |t| {\n             match ty::get(t).sty {\n               ty::ty_param(param_ty {idx, _}) => {\n-                  debug!(\"Found use of ty param #%u\", idx);\n+                  debug2!(\"Found use of ty param \\\\#{}\", idx);\n                   tps_used[idx] = true;\n               }\n               _ => ()\n@@ -3528,7 +3527,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n     for (i, b) in tps_used.iter().enumerate() {\n         if !*b {\n             ccx.tcx.sess.span_err(\n-                span, fmt!(\"type parameter `%s` is unused\",\n+                span, format!(\"type parameter `{}` is unused\",\n                            ccx.tcx.sess.str_of(tps.get(i).ident)));\n         }\n     }\n@@ -3577,7 +3576,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             }\n             op => {\n                 tcx.sess.span_err(it.span,\n-                                  fmt!(\"unrecognized atomic operation function: `%s`\",\n+                                  format!(\"unrecognized atomic operation function: `{}`\",\n                                        op));\n                 return;\n             }\n@@ -3860,7 +3859,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n \n             ref other => {\n                 tcx.sess.span_err(it.span,\n-                                  fmt!(\"unrecognized intrinsic function: `%s`\",\n+                                  format!(\"unrecognized intrinsic function: `{}`\",\n                                        *other));\n                 return;\n             }\n@@ -3876,14 +3875,14 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = i_ty.generics.type_param_defs.len();\n     if i_n_tps != n_tps {\n-        tcx.sess.span_err(it.span, fmt!(\"intrinsic has wrong number \\\n-                                         of type parameters: found %u, \\\n-                                         expected %u\", i_n_tps, n_tps));\n+        tcx.sess.span_err(it.span, format!(\"intrinsic has wrong number \\\n+                                         of type parameters: found {}, \\\n+                                         expected {}\", i_n_tps, n_tps));\n     } else {\n         require_same_types(\n             tcx, None, false, it.span, i_ty.ty, fty,\n-            || fmt!(\"intrinsic has wrong type: \\\n-                      expected `%s`\",\n+            || format!(\"intrinsic has wrong type: \\\n+                      expected `{}`\",\n                      ppaux::ty_to_str(ccx.tcx, fty)));\n     }\n }"}, {"sha": "edc2947d890042f68975f3746e061ca1bb67d3ea", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -68,7 +68,7 @@ fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::Def) -> ty::Region {\n             }\n         }\n         _ => {\n-            tcx.sess.bug(fmt!(\"unexpected def in encl_region_of_def: %?\",\n+            tcx.sess.bug(format!(\"unexpected def in encl_region_of_def: {:?}\",\n                               def))\n         }\n     }\n@@ -211,7 +211,7 @@ fn visit_local(rcx: &mut Rcx, l: @ast::Local) {\n \n fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: &mut Rcx) {\n     let tcx = rcx.fcx.tcx();\n-    debug!(\"regionck::visit_pat(pat=%s)\", pat.repr(tcx));\n+    debug2!(\"regionck::visit_pat(pat={})\", pat.repr(tcx));\n     do pat_util::pat_bindings(tcx.def_map, pat) |_, id, span, _| {\n         // If we have a variable that contains region'd data, that\n         // data will be accessible from anywhere that the variable is\n@@ -244,7 +244,7 @@ fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: &mut Rcx) {\n }\n \n fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n-    debug!(\"regionck::visit_expr(e=%s, repeating_scope=%?)\",\n+    debug2!(\"regionck::visit_expr(e={}, repeating_scope={:?})\",\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n     let has_method_map = rcx.fcx.inh.method_map.contains_key(&expr.id);\n@@ -302,7 +302,7 @@ fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n     {\n         let r = rcx.fcx.inh.adjustments.find(&expr.id);\n         for &adjustment in r.iter() {\n-            debug!(\"adjustment=%?\", adjustment);\n+            debug2!(\"adjustment={:?}\", adjustment);\n             match *adjustment {\n                 @ty::AutoDerefRef(\n                     ty::AutoDerefRef {autoderefs: autoderefs, autoref: opt_autoref}) =>\n@@ -515,7 +515,7 @@ fn constrain_callee(rcx: &mut Rcx,\n             //\n             // tcx.sess.span_bug(\n             //     callee_expr.span,\n-            //     fmt!(\"Calling non-function: %s\", callee_ty.repr(tcx)));\n+            //     format!(\"Calling non-function: {}\", callee_ty.repr(tcx)));\n         }\n     }\n }\n@@ -535,7 +535,7 @@ fn constrain_call(rcx: &mut Rcx,\n     //! appear in the arguments appropriately.\n \n     let tcx = rcx.fcx.tcx();\n-    debug!(\"constrain_call(call_expr=%s, implicitly_ref_args=%?)\",\n+    debug2!(\"constrain_call(call_expr={}, implicitly_ref_args={:?})\",\n            call_expr.repr(tcx), implicitly_ref_args);\n     let callee_ty = rcx.resolve_node_type(callee_id);\n     if ty::type_is_error(callee_ty) {\n@@ -597,7 +597,7 @@ fn constrain_derefs(rcx: &mut Rcx,\n     let tcx = rcx.fcx.tcx();\n     let r_deref_expr = ty::re_scope(deref_expr.id);\n     for i in range(0u, derefs) {\n-        debug!(\"constrain_derefs(deref_expr=?, derefd_ty=%s, derefs=%?/%?\",\n+        debug2!(\"constrain_derefs(deref_expr=?, derefd_ty={}, derefs={:?}/{:?}\",\n                rcx.fcx.infcx().ty_to_str(derefd_ty),\n                i, derefs);\n \n@@ -638,7 +638,7 @@ fn constrain_index(rcx: &mut Rcx,\n      * includes the deref expr.\n      */\n \n-    debug!(\"constrain_index(index_expr=?, indexed_ty=%s\",\n+    debug2!(\"constrain_index(index_expr=?, indexed_ty={}\",\n            rcx.fcx.infcx().ty_to_str(indexed_ty));\n \n     let r_index_expr = ty::re_scope(index_expr.id);\n@@ -662,13 +662,13 @@ fn constrain_free_variables(rcx: &mut Rcx,\n      */\n \n     let tcx = rcx.fcx.ccx.tcx;\n-    debug!(\"constrain_free_variables(%s, %s)\",\n+    debug2!(\"constrain_free_variables({}, {})\",\n            region.repr(tcx), expr.repr(tcx));\n     for freevar in get_freevars(tcx, expr.id).iter() {\n-        debug!(\"freevar def is %?\", freevar.def);\n+        debug2!(\"freevar def is {:?}\", freevar.def);\n         let def = freevar.def;\n         let en_region = encl_region_of_def(rcx.fcx, def);\n-        debug!(\"en_region = %s\", en_region.repr(tcx));\n+        debug2!(\"en_region = {}\", en_region.repr(tcx));\n         rcx.fcx.mk_subr(true, infer::FreeVariable(freevar.span),\n                         region, en_region);\n     }\n@@ -692,8 +692,8 @@ fn constrain_regions_in_type_of_node(\n     let ty0 = rcx.resolve_node_type(id);\n     let adjustment = rcx.fcx.inh.adjustments.find_copy(&id);\n     let ty = ty::adjust_ty(tcx, origin.span(), ty0, adjustment);\n-    debug!(\"constrain_regions_in_type_of_node(\\\n-            ty=%s, ty0=%s, id=%d, minimum_lifetime=%?, adjustment=%?)\",\n+    debug2!(\"constrain_regions_in_type_of_node(\\\n+            ty={}, ty0={}, id={}, minimum_lifetime={:?}, adjustment={:?})\",\n            ty_to_str(tcx, ty), ty_to_str(tcx, ty0),\n            id, minimum_lifetime, adjustment);\n     constrain_regions_in_type(rcx, minimum_lifetime, origin, ty)\n@@ -722,12 +722,12 @@ fn constrain_regions_in_type(\n     let e = rcx.errors_reported;\n     let tcx = rcx.fcx.ccx.tcx;\n \n-    debug!(\"constrain_regions_in_type(minimum_lifetime=%s, ty=%s)\",\n+    debug2!(\"constrain_regions_in_type(minimum_lifetime={}, ty={})\",\n            region_to_str(tcx, \"\", false, minimum_lifetime),\n            ty_to_str(tcx, ty));\n \n     do relate_nested_regions(tcx, Some(minimum_lifetime), ty) |r_sub, r_sup| {\n-        debug!(\"relate(r_sub=%s, r_sup=%s)\",\n+        debug2!(\"relate(r_sub={}, r_sup={})\",\n                region_to_str(tcx, \"\", false, r_sub),\n                region_to_str(tcx, \"\", false, r_sup));\n \n@@ -813,7 +813,7 @@ pub mod guarantor {\n          * to the lifetime of its guarantor (if any).\n          */\n \n-        debug!(\"guarantor::for_addr_of(base=?)\");\n+        debug2!(\"guarantor::for_addr_of(base=?)\");\n \n         let guarantor = guarantor(rcx, base);\n         link(rcx, expr.span, expr.id, guarantor);\n@@ -826,9 +826,9 @@ pub mod guarantor {\n          * linked to the lifetime of its guarantor (if any).\n          */\n \n-        debug!(\"regionck::for_match()\");\n+        debug2!(\"regionck::for_match()\");\n         let discr_guarantor = guarantor(rcx, discr);\n-        debug!(\"discr_guarantor=%s\", discr_guarantor.repr(rcx.tcx()));\n+        debug2!(\"discr_guarantor={}\", discr_guarantor.repr(rcx.tcx()));\n         for arm in arms.iter() {\n             for pat in arm.pats.iter() {\n                 link_ref_bindings_in_pat(rcx, *pat, discr_guarantor);\n@@ -847,10 +847,10 @@ pub mod guarantor {\n          * region pointers.\n          */\n \n-        debug!(\"guarantor::for_autoref(autoref=%?)\", autoref);\n+        debug2!(\"guarantor::for_autoref(autoref={:?})\", autoref);\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n-        debug!(\"    unadjusted cat=%?\", expr_ct.cat);\n+        debug2!(\"    unadjusted cat={:?}\", expr_ct.cat);\n         expr_ct = apply_autoderefs(\n             rcx, expr, autoderefs, expr_ct);\n \n@@ -898,10 +898,10 @@ pub mod guarantor {\n          */\n \n         let tcx = rcx.tcx();\n-        debug!(\"guarantor::for_by_ref(expr=%s, callee_scope=%?)\",\n+        debug2!(\"guarantor::for_by_ref(expr={}, callee_scope={:?})\",\n                expr.repr(tcx), callee_scope);\n         let expr_cat = categorize(rcx, expr);\n-        debug!(\"guarantor::for_by_ref(expr=%?, callee_scope=%?) category=%?\",\n+        debug2!(\"guarantor::for_by_ref(expr={:?}, callee_scope={:?}) category={:?}\",\n                expr.id, callee_scope, expr_cat);\n         let minimum_lifetime = ty::re_scope(callee_scope);\n         for guarantor in expr_cat.guarantor.iter() {\n@@ -921,7 +921,7 @@ pub mod guarantor {\n          * to the lifetime of its guarantor (if any).\n          */\n \n-        debug!(\"link(id=%?, guarantor=%?)\", id, guarantor);\n+        debug2!(\"link(id={:?}, guarantor={:?})\", id, guarantor);\n \n         let bound = match guarantor {\n             None => {\n@@ -939,7 +939,7 @@ pub mod guarantor {\n         let rptr_ty = rcx.resolve_node_type(id);\n         if !ty::type_is_bot(rptr_ty) {\n             let tcx = rcx.fcx.ccx.tcx;\n-            debug!(\"rptr_ty=%s\", ty_to_str(tcx, rptr_ty));\n+            debug2!(\"rptr_ty={}\", ty_to_str(tcx, rptr_ty));\n             let r = ty::ty_region(tcx, span, rptr_ty);\n             rcx.fcx.mk_subr(true, infer::Reborrow(span), r, bound);\n         }\n@@ -977,7 +977,7 @@ pub mod guarantor {\n          * `&expr`).\n          */\n \n-        debug!(\"guarantor()\");\n+        debug2!(\"guarantor()\");\n         match expr.node {\n             ast::ExprUnary(_, ast::UnDeref, b) => {\n                 let cat = categorize(rcx, b);\n@@ -1035,15 +1035,15 @@ pub mod guarantor {\n                     rcx.fcx.tcx(), rcx.fcx.inh.method_map, expr));\n                 None\n             }\n-            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n         }\n     }\n \n     fn categorize(rcx: &mut Rcx, expr: @ast::Expr) -> ExprCategorization {\n-        debug!(\"categorize()\");\n+        debug2!(\"categorize()\");\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n-        debug!(\"before adjustments, cat=%?\", expr_ct.cat);\n+        debug2!(\"before adjustments, cat={:?}\", expr_ct.cat);\n \n         match rcx.fcx.inh.adjustments.find(&expr.id) {\n             Some(&@ty::AutoAddEnv(*)) => {\n@@ -1056,7 +1056,7 @@ pub mod guarantor {\n             }\n \n             Some(&@ty::AutoDerefRef(ref adjustment)) => {\n-                debug!(\"adjustment=%?\", adjustment);\n+                debug2!(\"adjustment={:?}\", adjustment);\n \n                 expr_ct = apply_autoderefs(\n                     rcx, expr, adjustment.autoderefs, expr_ct);\n@@ -1067,7 +1067,7 @@ pub mod guarantor {\n                     Some(ty::AutoUnsafe(_)) => {\n                         expr_ct.cat.guarantor = None;\n                         expr_ct.cat.pointer = OtherPointer;\n-                        debug!(\"autoref, cat=%?\", expr_ct.cat);\n+                        debug2!(\"autoref, cat={:?}\", expr_ct.cat);\n                     }\n                     Some(ty::AutoPtr(r, _)) |\n                     Some(ty::AutoBorrowVec(r, _)) |\n@@ -1078,22 +1078,22 @@ pub mod guarantor {\n                         // expression will be some sort of borrowed pointer.\n                         expr_ct.cat.guarantor = None;\n                         expr_ct.cat.pointer = BorrowedPointer(r);\n-                        debug!(\"autoref, cat=%?\", expr_ct.cat);\n+                        debug2!(\"autoref, cat={:?}\", expr_ct.cat);\n                     }\n                 }\n             }\n \n             None => {}\n         }\n \n-        debug!(\"result=%?\", expr_ct.cat);\n+        debug2!(\"result={:?}\", expr_ct.cat);\n         return expr_ct.cat;\n     }\n \n     fn categorize_unadjusted(rcx: &mut Rcx,\n                              expr: @ast::Expr)\n                           -> ExprCategorizationType {\n-        debug!(\"categorize_unadjusted()\");\n+        debug2!(\"categorize_unadjusted()\");\n \n         let guarantor = {\n             if rcx.fcx.inh.method_map.contains_key(&expr.id) {\n@@ -1138,12 +1138,12 @@ pub mod guarantor {\n                 None => {\n                     tcx.sess.span_bug(\n                         expr.span,\n-                        fmt!(\"Autoderef but type not derefable: %s\",\n+                        format!(\"Autoderef but type not derefable: {}\",\n                              ty_to_str(tcx, ct.ty)));\n                 }\n             }\n \n-            debug!(\"autoderef, cat=%?\", ct.cat);\n+            debug2!(\"autoderef, cat={:?}\", ct.cat);\n         }\n         return ct;\n     }\n@@ -1205,7 +1205,7 @@ pub mod guarantor {\n          * other pointers.\n          */\n \n-        debug!(\"link_ref_bindings_in_pat(pat=%s, guarantor=%?)\",\n+        debug2!(\"link_ref_bindings_in_pat(pat={}, guarantor={:?})\",\n                rcx.fcx.pat_to_str(pat), guarantor);\n \n         match pat.node {"}, {"sha": "1aae00edf51931cea8cc4898cf5957a45af28552", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -38,25 +38,25 @@ pub fn replace_bound_regions_in_fn_sig(\n \n     for &t in opt_self_ty.iter() { all_tys.push(t) }\n \n-    debug!(\"replace_bound_regions_in_fn_sig(self_ty=%?, fn_sig=%s, \\\n-            all_tys=%?)\",\n+    debug2!(\"replace_bound_regions_in_fn_sig(self_ty={:?}, fn_sig={}, \\\n+            all_tys={:?})\",\n            opt_self_ty.map(|t| ppaux::ty_to_str(tcx, *t)),\n            ppaux::fn_sig_to_str(tcx, fn_sig),\n            all_tys.map(|t| ppaux::ty_to_str(tcx, *t)));\n     let _i = indenter();\n \n     let isr = do create_bound_region_mapping(tcx, isr, all_tys) |br| {\n-        debug!(\"br=%?\", br);\n+        debug2!(\"br={:?}\", br);\n         mapf(br)\n     };\n     let new_fn_sig = ty::fold_sig(fn_sig, |t| {\n         replace_bound_regions(tcx, isr, t)\n     });\n     let new_self_ty = opt_self_ty.map(|t| replace_bound_regions(tcx, isr, *t));\n \n-    debug!(\"result of replace_bound_regions_in_fn_sig: \\\n-            new_self_ty=%?, \\\n-            fn_sig=%s\",\n+    debug2!(\"result of replace_bound_regions_in_fn_sig: \\\n+            new_self_ty={:?}, \\\n+            fn_sig={}\",\n            new_self_ty.map(|t| ppaux::ty_to_str(tcx, *t)),\n            ppaux::fn_sig_to_str(tcx, &new_fn_sig));\n \n@@ -146,8 +146,8 @@ pub fn replace_bound_regions_in_fn_sig(\n                   None if in_fn => r,\n                   None => {\n                     tcx.sess.bug(\n-                        fmt!(\"Bound region not found in \\\n-                              in_scope_regions list: %s\",\n+                        format!(\"Bound region not found in \\\n+                              in_scope_regions list: {}\",\n                              region_to_str(tcx, \"\", false, r)));\n                   }\n                 }\n@@ -255,7 +255,7 @@ pub fn relate_free_regions(\n      * Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n      */\n \n-    debug!(\"relate_free_regions >>\");\n+    debug2!(\"relate_free_regions >>\");\n \n     let mut all_tys = ~[];\n     for arg in fn_sig.inputs.iter() {\n@@ -266,7 +266,7 @@ pub fn relate_free_regions(\n     }\n \n     for &t in all_tys.iter() {\n-        debug!(\"relate_free_regions(t=%s)\", ppaux::ty_to_str(tcx, t));\n+        debug2!(\"relate_free_regions(t={})\", ppaux::ty_to_str(tcx, t));\n         relate_nested_regions(tcx, None, t, |a, b| {\n             match (&a, &b) {\n                 (&ty::re_free(free_a), &ty::re_free(free_b)) => {\n@@ -277,5 +277,5 @@ pub fn relate_free_regions(\n         })\n     }\n \n-    debug!(\"<< relate_free_regions\");\n+    debug2!(\"<< relate_free_regions\");\n }"}, {"sha": "146be8b85ad97584c36321c1938ccbbf87a835aa", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -87,9 +87,9 @@ fn lookup_vtables(vcx: &VtableContext,\n                   type_param_defs: &[ty::TypeParameterDef],\n                   substs: &ty::substs,\n                   is_early: bool) -> vtable_res {\n-    debug!(\"lookup_vtables(location_info=%?, \\\n-            type_param_defs=%s, \\\n-            substs=%s\",\n+    debug2!(\"lookup_vtables(location_info={:?}, \\\n+            type_param_defs={}, \\\n+            substs={}\",\n            location_info,\n            type_param_defs.repr(vcx.tcx()),\n            substs.repr(vcx.tcx()));\n@@ -108,11 +108,11 @@ fn lookup_vtables(vcx: &VtableContext,\n     result.reverse();\n \n     assert_eq!(substs.tps.len(), result.len());\n-    debug!(\"lookup_vtables result(\\\n-            location_info=%?, \\\n-            type_param_defs=%s, \\\n-            substs=%s, \\\n-            result=%s)\",\n+    debug2!(\"lookup_vtables result(\\\n+            location_info={:?}, \\\n+            type_param_defs={}, \\\n+            substs={}, \\\n+            result={})\",\n            location_info,\n            type_param_defs.repr(vcx.tcx()),\n            substs.repr(vcx.tcx()),\n@@ -142,32 +142,32 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n         // Substitute the values of the type parameters that may\n         // appear in the bound.\n         let trait_ref = substs.map_default(trait_ref, |substs| {\n-            debug!(\"about to subst: %s, %s\",\n+            debug2!(\"about to subst: {}, {}\",\n                    trait_ref.repr(tcx), substs.repr(tcx));\n             trait_ref.subst(tcx, *substs)\n         });\n \n-        debug!(\"after subst: %s\", trait_ref.repr(tcx));\n+        debug2!(\"after subst: {}\", trait_ref.repr(tcx));\n \n         match lookup_vtable(vcx, location_info, ty, trait_ref, is_early) {\n             Some(vtable) => param_result.push(vtable),\n             None => {\n                 vcx.tcx().sess.span_fatal(\n                     location_info.span,\n-                    fmt!(\"failed to find an implementation of \\\n-                          trait %s for %s\",\n+                    format!(\"failed to find an implementation of \\\n+                          trait {} for {}\",\n                          vcx.infcx.trait_ref_to_str(trait_ref),\n                          vcx.infcx.ty_to_str(ty)));\n             }\n         }\n         true\n     };\n \n-    debug!(\"lookup_vtables_for_param result(\\\n-            location_info=%?, \\\n-            type_param_bounds=%s, \\\n-            ty=%s, \\\n-            result=%s)\",\n+    debug2!(\"lookup_vtables_for_param result(\\\n+            location_info={:?}, \\\n+            type_param_bounds={}, \\\n+            ty={}, \\\n+            result={})\",\n            location_info,\n            type_param_bounds.repr(vcx.tcx()),\n            ty.repr(vcx.tcx()),\n@@ -211,7 +211,7 @@ fn relate_trait_refs(vcx: &VtableContext,\n                 let tcx = vcx.tcx();\n                 tcx.sess.span_err(\n                     location_info.span,\n-                    fmt!(\"expected %s, but found %s (%s)\",\n+                    format!(\"expected {}, but found {} ({})\",\n                          ppaux::trait_ref_to_str(tcx, &r_exp_trait_ref),\n                          ppaux::trait_ref_to_str(tcx, &r_act_trait_ref),\n                          ty::type_err_to_str(tcx, err)));\n@@ -228,7 +228,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                  is_early: bool)\n     -> Option<vtable_origin>\n {\n-    debug!(\"lookup_vtable(ty=%s, trait_ref=%s)\",\n+    debug2!(\"lookup_vtable(ty={}, trait_ref={})\",\n            vcx.infcx.ty_to_str(ty),\n            vcx.infcx.trait_ref_to_str(trait_ref));\n     let _i = indenter();\n@@ -291,7 +291,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n     let mut n_bound = 0;\n     let mut ret = None;\n     do ty::each_bound_trait_and_supertraits(tcx, bounds) |bound_trait_ref| {\n-        debug!(\"checking bounds trait %s\",\n+        debug2!(\"checking bounds trait {}\",\n                bound_trait_ref.repr(vcx.tcx()));\n \n         if bound_trait_ref.def_id == trait_ref.def_id {\n@@ -300,7 +300,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n                               bound_trait_ref,\n                               trait_ref);\n             let vtable = vtable_param(param, n_bound);\n-            debug!(\"found param vtable: %?\",\n+            debug2!(\"found param vtable: {:?}\",\n                    vtable);\n             ret = Some(vtable);\n             false\n@@ -383,7 +383,7 @@ fn search_for_vtable(vcx: &VtableContext,\n \n         // Now, in the previous example, for_ty is bound to\n         // the type self_ty, and substs is bound to [T].\n-        debug!(\"The self ty is %s and its substs are %s\",\n+        debug2!(\"The self ty is {} and its substs are {}\",\n                vcx.infcx.ty_to_str(for_ty),\n                vcx.infcx.tys_to_str(substs.tps));\n \n@@ -397,8 +397,8 @@ fn search_for_vtable(vcx: &VtableContext,\n         // some value of U) with some_trait<T>. This would fail if T\n         // and U weren't compatible.\n \n-        debug!(\"(checking vtable) @2 relating trait \\\n-                ty %s to of_trait_ref %s\",\n+        debug2!(\"(checking vtable) @2 relating trait \\\n+                ty {} to of_trait_ref {}\",\n                vcx.infcx.trait_ref_to_str(trait_ref),\n                vcx.infcx.trait_ref_to_str(of_trait_ref));\n \n@@ -435,9 +435,9 @@ fn search_for_vtable(vcx: &VtableContext,\n             }\n         };\n \n-        debug!(\"The fixed-up substs are %s - \\\n+        debug2!(\"The fixed-up substs are {} - \\\n                 they will be unified with the bounds for \\\n-                the target ty, %s\",\n+                the target ty, {}\",\n                vcx.infcx.tys_to_str(substs_f.tps),\n                vcx.infcx.trait_ref_to_str(trait_ref));\n \n@@ -487,7 +487,7 @@ fn fixup_substs(vcx: &VtableContext,\n     do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n         match ty::get(*t_f).sty {\n           ty::ty_trait(_, ref substs_f, _, _, _) => (*substs_f).clone(),\n-          _ => fail!(\"t_f should be a trait\")\n+          _ => fail2!(\"t_f should be a trait\")\n         }\n     }\n }\n@@ -502,8 +502,8 @@ fn fixup_ty(vcx: &VtableContext,\n         Err(e) if !is_early => {\n             tcx.sess.span_fatal(\n                 location_info.span,\n-                fmt!(\"cannot determine a type \\\n-                      for this bounded type parameter: %s\",\n+                format!(\"cannot determine a type \\\n+                      for this bounded type parameter: {}\",\n                      fixup_err_to_str(e)))\n         }\n         Err(_) => {\n@@ -533,7 +533,7 @@ fn connect_trait_tps(vcx: &VtableContext,\n fn insert_vtables(fcx: @mut FnCtxt,\n                   callee_id: ast::NodeId,\n                   vtables: vtable_res) {\n-    debug!(\"insert_vtables(callee_id=%d, vtables=%?)\",\n+    debug2!(\"insert_vtables(callee_id={}, vtables={:?})\",\n            callee_id, vtables.repr(fcx.tcx()));\n     fcx.inh.vtable_map.insert(callee_id, vtables);\n }\n@@ -554,23 +554,23 @@ pub fn location_info_for_item(item: @ast::item) -> LocationInfo {\n pub fn early_resolve_expr(ex: @ast::Expr,\n                           fcx: @mut FnCtxt,\n                           is_early: bool) {\n-    debug!(\"vtable: early_resolve_expr() ex with id %? (early: %b): %s\",\n+    debug2!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n            ex.id, is_early, expr_to_str(ex, fcx.tcx().sess.intr()));\n     let _indent = indenter();\n \n     let cx = fcx.ccx;\n     match ex.node {\n       ast::ExprPath(*) => {\n         do fcx.opt_node_ty_substs(ex.id) |substs| {\n-            debug!(\"vtable resolution on parameter bounds for expr %s\",\n+            debug2!(\"vtable resolution on parameter bounds for expr {}\",\n                    ex.repr(fcx.tcx()));\n             let def = cx.tcx.def_map.get_copy(&ex.id);\n             let did = ast_util::def_id_of_def(def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n-            debug!(\"early resolve expr: def %? %?, %?, %s\", ex.id, did, def,\n+            debug2!(\"early resolve expr: def {:?} {:?}, {:?}, {}\", ex.id, did, def,\n                    fcx.infcx().ty_to_str(item_ty.ty));\n             if has_trait_bounds(*item_ty.generics.type_param_defs) {\n-                debug!(\"early_resolve_expr: looking up vtables for type params %s\",\n+                debug2!(\"early_resolve_expr: looking up vtables for type params {}\",\n                        item_ty.generics.type_param_defs.repr(fcx.tcx()));\n                 let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n@@ -596,7 +596,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n       ast::ExprMethodCall(callee_id, _, _, _, _, _) => {\n         match ty::method_call_type_param_defs(cx.tcx, fcx.inh.method_map, ex.id) {\n           Some(type_param_defs) => {\n-            debug!(\"vtable resolution on parameter bounds for method call %s\",\n+            debug2!(\"vtable resolution on parameter bounds for method call {}\",\n                    ex.repr(fcx.tcx()));\n             if has_trait_bounds(*type_param_defs) {\n                 let substs = fcx.node_ty_substs(callee_id);\n@@ -612,7 +612,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n         }\n       }\n       ast::ExprCast(src, _) => {\n-          debug!(\"vtable resolution on expr %s\", ex.repr(fcx.tcx()));\n+          debug2!(\"vtable resolution on expr {}\", ex.repr(fcx.tcx()));\n           let target_ty = fcx.expr_ty(ex);\n           match ty::get(target_ty).sty {\n               // Bounds of type's contents are not checked here, but in kind.rs.\n@@ -635,7 +635,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                       (&ty::ty_rptr(_, mt), ty::RegionTraitStore(*))\n                         if !mutability_allowed(mt.mutbl, target_mutbl) => {\n                           fcx.tcx().sess.span_err(ex.span,\n-                                                  fmt!(\"types differ in mutability\"));\n+                                                  format!(\"types differ in mutability\"));\n                       }\n \n                       (&ty::ty_box(mt), ty::BoxTraitStore) |\n@@ -691,24 +691,24 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                       (_, ty::UniqTraitStore) => {\n                           fcx.ccx.tcx.sess.span_err(\n                               ex.span,\n-                              fmt!(\"can only cast an ~-pointer \\\n-                                    to a ~-object, not a %s\",\n+                              format!(\"can only cast an ~-pointer \\\n+                                    to a ~-object, not a {}\",\n                                    ty::ty_sort_str(fcx.tcx(), ty)));\n                       }\n \n                       (_, ty::BoxTraitStore) => {\n                           fcx.ccx.tcx.sess.span_err(\n                               ex.span,\n-                              fmt!(\"can only cast an @-pointer \\\n-                                    to an @-object, not a %s\",\n+                              format!(\"can only cast an @-pointer \\\n+                                    to an @-object, not a {}\",\n                                    ty::ty_sort_str(fcx.tcx(), ty)));\n                       }\n \n                       (_, ty::RegionTraitStore(_)) => {\n                           fcx.ccx.tcx.sess.span_err(\n                               ex.span,\n-                              fmt!(\"can only cast an &-pointer \\\n-                                    to an &-object, not a %s\",\n+                              format!(\"can only cast an &-pointer \\\n+                                    to an &-object, not a {}\",\n                                    ty::ty_sort_str(fcx.tcx(), ty)));\n                       }\n                   }\n@@ -753,7 +753,7 @@ pub fn resolve_impl(ccx: @mut CrateCtxt, impl_item: @ast::item) {\n                 trait_bounds: ~[trait_ref]\n             };\n             let t = ty::node_id_to_type(ccx.tcx, impl_item.id);\n-            debug!(\"=== Doing a self lookup now.\");\n+            debug2!(\"=== Doing a self lookup now.\");\n             // Right now, we don't have any place to store this.\n             // We will need to make one so we can use this information\n             // for compiling default methods that refer to supertraits."}, {"sha": "4f281ce5f45701bc67c2a5d8c167334febc6c5a8", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -41,8 +41,8 @@ fn resolve_type_vars_in_type(fcx: @mut FnCtxt, sp: Span, typ: ty::t)\n             if !fcx.ccx.tcx.sess.has_errors() {\n                 fcx.ccx.tcx.sess.span_err(\n                     sp,\n-                    fmt!(\"cannot determine a type \\\n-                          for this expression: %s\",\n+                    format!(\"cannot determine a type \\\n+                          for this expression: {}\",\n                          infer::fixup_err_to_str(e)))\n             }\n             return None;\n@@ -70,8 +70,8 @@ fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n                 for t in r.iter() {\n                     let method_map = fcx.ccx.method_map;\n                     let new_entry = method_map_entry { self_ty: *t, ..*mme };\n-                    debug!(\"writeback::resolve_method_map_entry(id=%?, \\\n-                            new_entry=%?)\",\n+                    debug2!(\"writeback::resolve_method_map_entry(id={:?}, \\\n+                            new_entry={:?})\",\n                            id, new_entry);\n                     method_map.insert(id, new_entry);\n                 }\n@@ -88,7 +88,7 @@ fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n             let r_origins = resolve_origins(fcx, sp, *origins);\n             let vtable_map = fcx.ccx.vtable_map;\n             vtable_map.insert(id, r_origins);\n-            debug!(\"writeback::resolve_vtable_map_entry(id=%d, vtables=%?)\",\n+            debug2!(\"writeback::resolve_vtable_map_entry(id={}, vtables={:?})\",\n                    id, r_origins.repr(fcx.tcx()));\n         }\n     }\n@@ -128,12 +128,12 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                 Err(e) => {\n                     // This should not, I think, happen:\n                     fcx.ccx.tcx.sess.span_err(\n-                        sp, fmt!(\"cannot resolve bound for closure: %s\",\n+                        sp, format!(\"cannot resolve bound for closure: {}\",\n                                  infer::fixup_err_to_str(e)));\n                 }\n                 Ok(r1) => {\n                     let resolved_adj = @ty::AutoAddEnv(r1, s);\n-                    debug!(\"Adjustments for node %d: %?\", id, resolved_adj);\n+                    debug2!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n                     fcx.tcx().adjustments.insert(id, resolved_adj);\n                 }\n             }\n@@ -146,7 +146,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                     Err(e) => {\n                         // This should not, I think, happen.\n                         fcx.ccx.tcx.sess.span_err(\n-                            sp, fmt!(\"cannot resolve scope of borrow: %s\",\n+                            sp, format!(\"cannot resolve scope of borrow: {}\",\n                                      infer::fixup_err_to_str(e)));\n                         r\n                     }\n@@ -162,7 +162,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                 autoderefs: adj.autoderefs,\n                 autoref: resolved_autoref,\n             });\n-            debug!(\"Adjustments for node %d: %?\", id, resolved_adj);\n+            debug2!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n             fcx.tcx().adjustments.insert(id, resolved_adj);\n         }\n     }\n@@ -176,7 +176,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n       }\n \n       Some(t) => {\n-        debug!(\"resolve_type_vars_for_node(id=%d, n_ty=%s, t=%s)\",\n+        debug2!(\"resolve_type_vars_for_node(id={}, n_ty={}, t={})\",\n                id, ppaux::ty_to_str(tcx, n_ty), ppaux::ty_to_str(tcx, t));\n         write_ty_to_tcx(tcx, id, t);\n         let mut ret = Some(t);\n@@ -284,7 +284,7 @@ fn visit_pat(p: @ast::Pat, wbcx: &mut WbCtxt) {\n     }\n \n     resolve_type_vars_for_node(wbcx, p.span, p.id);\n-    debug!(\"Type for pattern binding %s (id %d) resolved to %s\",\n+    debug2!(\"Type for pattern binding {} (id {}) resolved to {}\",\n            pat_to_str(p, wbcx.fcx.ccx.tcx.sess.intr()), p.id,\n            wbcx.fcx.infcx().ty_to_str(\n                ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n@@ -297,7 +297,7 @@ fn visit_local(l: @ast::Local, wbcx: &mut WbCtxt) {\n     let var_ty = wbcx.fcx.local_ty(l.span, l.id);\n     match resolve_type(wbcx.fcx.infcx(), var_ty, resolve_all | force_all) {\n         Ok(lty) => {\n-            debug!(\"Type for local %s (id %d) resolved to %s\",\n+            debug2!(\"Type for local {} (id {}) resolved to {}\",\n                    pat_to_str(l.pat, wbcx.fcx.tcx().sess.intr()),\n                    l.id,\n                    wbcx.fcx.infcx().ty_to_str(lty));\n@@ -306,8 +306,8 @@ fn visit_local(l: @ast::Local, wbcx: &mut WbCtxt) {\n         Err(e) => {\n             wbcx.fcx.ccx.tcx.sess.span_err(\n                 l.span,\n-                fmt!(\"cannot determine a type \\\n-                      for this local variable: %s\",\n+                format!(\"cannot determine a type \\\n+                      for this local variable: {}\",\n                      infer::fixup_err_to_str(e)));\n             wbcx.success = false;\n         }"}, {"sha": "f6c24e3cd231a494ab0259747705cf87984583bc", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -76,7 +76,7 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n \n     match get(resolved_type).sty {\n         ty_enum(*) | ty_trait(*) | ty_struct(*) => {\n-            debug!(\"(getting base type) found base type\");\n+            debug2!(\"(getting base type) found base type\");\n             Some(resolved_type)\n         }\n \n@@ -85,7 +85,7 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n         ty_infer(*) | ty_param(*) | ty_self(*) | ty_type | ty_opaque_box |\n         ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) | ty_err | ty_box(_) |\n         ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {\n-            debug!(\"(getting base type) no base type; found %?\",\n+            debug2!(\"(getting base type) no base type; found {:?}\",\n                    get(original_type).sty);\n             None\n         }\n@@ -135,7 +135,7 @@ pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n                     return Some(def_id);\n                 }\n                 _ => {\n-                    fail!(\"get_base_type() returned a type that wasn't an \\\n+                    fail2!(\"get_base_type() returned a type that wasn't an \\\n                            enum, struct, or trait\");\n                 }\n             }\n@@ -160,7 +160,7 @@ struct CoherenceCheckVisitor { cc: CoherenceChecker }\n impl visit::Visitor<()> for CoherenceCheckVisitor {\n     fn visit_item(&mut self, item:@item, _:()) {\n \n-//                debug!(\"(checking coherence) item '%s'\",\n+//                debug2!(\"(checking coherence) item '{}'\",\n //                       self.cc.crate_context.tcx.sess.str_of(item.ident));\n \n                 match item.node {\n@@ -266,8 +266,8 @@ impl CoherenceChecker {\n         // base type.\n \n         if associated_traits.len() == 0 {\n-            debug!(\"(checking implementation) no associated traits for item \\\n-                    '%s'\",\n+            debug2!(\"(checking implementation) no associated traits for item \\\n+                    '{}'\",\n                    self.crate_context.tcx.sess.str_of(item.ident));\n \n             match get_base_type_def_id(self.inference_context,\n@@ -290,7 +290,7 @@ impl CoherenceChecker {\n         for associated_trait in associated_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(\n                 self.crate_context.tcx, associated_trait.ref_id);\n-            debug!(\"(checking implementation) adding impl for trait '%s', item '%s'\",\n+            debug2!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n                    trait_ref.repr(self.crate_context.tcx),\n                    self.crate_context.tcx.sess.str_of(item.ident));\n \n@@ -325,7 +325,7 @@ impl CoherenceChecker {\n                                        trait_ref: &ty::TraitRef,\n                                        all_methods: &mut ~[@Method]) {\n         let tcx = self.crate_context.tcx;\n-        debug!(\"instantiate_default_methods(impl_id=%?, trait_ref=%s)\",\n+        debug2!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n                impl_id, trait_ref.repr(tcx));\n \n         let impl_poly_type = ty::lookup_item_type(tcx, impl_id);\n@@ -336,7 +336,7 @@ impl CoherenceChecker {\n             let new_id = tcx.sess.next_node_id();\n             let new_did = local_def(new_id);\n \n-            debug!(\"new_did=%? trait_method=%s\", new_did, trait_method.repr(tcx));\n+            debug2!(\"new_did={:?} trait_method={}\", new_did, trait_method.repr(tcx));\n \n             // Create substitutions for the various trait parameters.\n             let new_method_ty =\n@@ -348,7 +348,7 @@ impl CoherenceChecker {\n                     *trait_method,\n                     Some(trait_method.def_id));\n \n-            debug!(\"new_method_ty=%s\", new_method_ty.repr(tcx));\n+            debug2!(\"new_method_ty={}\", new_method_ty.repr(tcx));\n             all_methods.push(new_method_ty);\n \n             // construct the polytype for the method based on the method_ty\n@@ -364,7 +364,7 @@ impl CoherenceChecker {\n                 generics: new_generics,\n                 ty: ty::mk_bare_fn(tcx, new_method_ty.fty.clone())\n             };\n-            debug!(\"new_polytype=%s\", new_polytype.repr(tcx));\n+            debug2!(\"new_polytype={}\", new_polytype.repr(tcx));\n \n             tcx.tcache.insert(new_did, new_polytype);\n             tcx.methods.insert(new_did, new_method_ty);\n@@ -440,7 +440,7 @@ impl CoherenceChecker {\n                         let session = self.crate_context.tcx.sess;\n                         session.span_err(\n                             self.span_of_impl(implementation_b),\n-                            fmt!(\"conflicting implementations for trait `%s`\",\n+                            format!(\"conflicting implementations for trait `{}`\",\n                                  ty::item_path_str(self.crate_context.tcx,\n                                                    trait_def_id)));\n                         session.span_note(self.span_of_impl(implementation_a),\n@@ -557,11 +557,11 @@ impl CoherenceChecker {\n \n         let r = ty::trait_methods(tcx, trait_did);\n         for method in r.iter() {\n-            debug!(\"checking for %s\", method.ident.repr(tcx));\n+            debug2!(\"checking for {}\", method.ident.repr(tcx));\n             if provided_names.contains(&method.ident.name) { loop; }\n \n             tcx.sess.span_err(trait_ref_span,\n-                              fmt!(\"missing method `%s`\",\n+                              format!(\"missing method `{}`\",\n                                    tcx.sess.str_of(method.ident)));\n         }\n     }"}, {"sha": "e5b01fea0617b7666bc98bcf9165650b3afebb4a", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -129,8 +129,8 @@ impl AstConv for CrateCtxt {\n                 ty_of_foreign_item(self, foreign_item, abis)\n               }\n               ref x => {\n-                self.tcx.sess.bug(fmt!(\"unexpected sort of item \\\n-                                        in get_item_ty(): %?\", (*x)));\n+                self.tcx.sess.bug(format!(\"unexpected sort of item \\\n+                                        in get_item_ty(): {:?}\", (*x)));\n               }\n             }\n         }\n@@ -347,7 +347,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n         let substd_type_param_defs = m.generics.type_param_defs.subst(tcx, &substs);\n         new_type_param_defs.push_all(*substd_type_param_defs);\n \n-        debug!(\"static method %s type_param_defs=%s ty=%s, substs=%s\",\n+        debug2!(\"static method {} type_param_defs={} ty={}, substs={}\",\n                m.def_id.repr(tcx),\n                new_type_param_defs.repr(tcx),\n                ty.repr(tcx),\n@@ -453,7 +453,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                            trait_m: &ty::Method,\n                            trait_substs: &ty::substs,\n                            self_ty: ty::t) {\n-    debug!(\"compare_impl_method()\");\n+    debug2!(\"compare_impl_method()\");\n     let infcx = infer::new_infer_ctxt(tcx);\n \n     let impl_m = &cm.mty;\n@@ -470,7 +470,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         (&ast::sty_static, _) => {\n             tcx.sess.span_err(\n                 cm.span,\n-                fmt!(\"method `%s` has a `%s` declaration in the impl, \\\n+                format!(\"method `{}` has a `{}` declaration in the impl, \\\n                       but not in the trait\",\n                      tcx.sess.str_of(trait_m.ident),\n                      explicit_self_to_str(&impl_m.explicit_self, tcx.sess.intr())));\n@@ -479,7 +479,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         (_, &ast::sty_static) => {\n             tcx.sess.span_err(\n                 cm.span,\n-                fmt!(\"method `%s` has a `%s` declaration in the trait, \\\n+                format!(\"method `{}` has a `{}` declaration in the trait, \\\n                       but not in the impl\",\n                      tcx.sess.str_of(trait_m.ident),\n                      explicit_self_to_str(&trait_m.explicit_self, tcx.sess.intr())));\n@@ -495,8 +495,8 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     if num_impl_m_type_params != num_trait_m_type_params {\n         tcx.sess.span_err(\n             cm.span,\n-            fmt!(\"method `%s` has %u type %s, but its trait \\\n-                  declaration has %u type %s\",\n+            format!(\"method `{}` has {} type {}, but its trait \\\n+                  declaration has {} type {}\",\n                  tcx.sess.str_of(trait_m.ident),\n                  num_impl_m_type_params,\n                  pluralize(num_impl_m_type_params, ~\"parameter\"),\n@@ -508,8 +508,8 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     if impl_m.fty.sig.inputs.len() != trait_m.fty.sig.inputs.len() {\n         tcx.sess.span_err(\n             cm.span,\n-            fmt!(\"method `%s` has %u parameter%s \\\n-                  but the trait has %u\",\n+            format!(\"method `{}` has {} parameter{} \\\n+                  but the trait has {}\",\n                  tcx.sess.str_of(trait_m.ident),\n                  impl_m.fty.sig.inputs.len(),\n                  if impl_m.fty.sig.inputs.len() == 1 { \"\" } else { \"s\" },\n@@ -529,8 +529,8 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         if !extra_bounds.is_empty() {\n            tcx.sess.span_err(\n                cm.span,\n-               fmt!(\"in method `%s`, \\\n-                     type parameter %u requires `%s`, \\\n+               format!(\"in method `{}`, \\\n+                     type parameter {} requires `{}`, \\\n                      which is not required by \\\n                      the corresponding type parameter \\\n                      in the trait declaration\",\n@@ -548,10 +548,10 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         {\n             tcx.sess.span_err(\n                 cm.span,\n-                fmt!(\"in method `%s`, \\\n-                      type parameter %u has %u trait %s, but the \\\n+                format!(\"in method `{}`, \\\n+                      type parameter {} has {} trait {}, but the \\\n                       corresponding type parameter in \\\n-                      the trait declaration has %u trait %s\",\n+                      the trait declaration has {} trait {}\",\n                      tcx.sess.str_of(trait_m.ident),\n                      i, impl_param_def.bounds.trait_bounds.len(),\n                      pluralize(impl_param_def.bounds.trait_bounds.len(),\n@@ -632,10 +632,10 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     //   that correspond to the parameters we will find on the impl\n     // - replace self region with a fresh, dummy region\n     let impl_fty = {\n-        debug!(\"impl_fty (pre-subst): %s\", ppaux::ty_to_str(tcx, impl_fty));\n+        debug2!(\"impl_fty (pre-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n         replace_bound_self(tcx, impl_fty, dummy_self_r)\n     };\n-    debug!(\"impl_fty (post-subst): %s\", ppaux::ty_to_str(tcx, impl_fty));\n+    debug2!(\"impl_fty (post-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n     let trait_fty = {\n         let num_trait_m_type_params = trait_m.generics.type_param_defs.len();\n         let dummy_tps = do vec::from_fn(num_trait_m_type_params) |i| {\n@@ -649,19 +649,19 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             self_ty: Some(self_ty),\n             tps: vec::append(trait_tps, dummy_tps)\n         };\n-        debug!(\"trait_fty (pre-subst): %s substs=%s\",\n+        debug2!(\"trait_fty (pre-subst): {} substs={}\",\n                trait_fty.repr(tcx), substs.repr(tcx));\n         ty::subst(tcx, &substs, trait_fty)\n     };\n-    debug!(\"trait_fty (post-subst): %s\", trait_fty.repr(tcx));\n+    debug2!(\"trait_fty (post-subst): {}\", trait_fty.repr(tcx));\n \n     match infer::mk_subty(infcx, false, infer::MethodCompatCheck(cm.span),\n                           impl_fty, trait_fty) {\n         result::Ok(()) => {}\n         result::Err(ref terr) => {\n             tcx.sess.span_err(\n                 cm.span,\n-                fmt!(\"method `%s` has an incompatible type: %s\",\n+                format!(\"method `{}` has an incompatible type: {}\",\n                      tcx.sess.str_of(trait_m.ident),\n                      ty::type_err_to_str(tcx, terr)));\n             ty::note_and_explain_type_err(tcx, terr);\n@@ -709,7 +709,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n                 // This method is not part of the trait\n                 tcx.sess.span_err(\n                     impl_m.span,\n-                    fmt!(\"method `%s` is not a member of trait `%s`\",\n+                    format!(\"method `{}` is not a member of trait `{}`\",\n                          tcx.sess.str_of(impl_m.mty.ident),\n                          path_to_str(&a_trait_ty.path, tcx.sess.intr())));\n             }\n@@ -835,7 +835,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n         if ty_param.bounds.len() > 0 {\n             ccx.tcx.sess.span_err(\n                 span,\n-                fmt!(\"trait bounds are not allowed in %s definitions\",\n+                format!(\"trait bounds are not allowed in {} definitions\",\n                      thing));\n         }\n     }\n@@ -844,7 +844,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n     let tcx = ccx.tcx;\n     let rp = tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n-    debug!(\"convert: item %s with id %d rp %?\",\n+    debug2!(\"convert: item {} with id {} rp {:?}\",\n            tcx.sess.str_of(it.ident), it.id, rp);\n     match it.node {\n       // These don't define types.\n@@ -1000,8 +1000,8 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::foreign_item) {\n     let abis = match ccx.tcx.items.find(&i.id) {\n         Some(&ast_map::node_foreign_item(_, abis, _, _)) => abis,\n         ref x => {\n-            ccx.tcx.sess.bug(fmt!(\"unexpected sort of item \\\n-                                   in get_item_ty(): %?\", (*x)));\n+            ccx.tcx.sess.bug(format!(\"unexpected sort of item \\\n+                                   in get_item_ty(): {:?}\", (*x)));\n         }\n     };\n \n@@ -1038,7 +1038,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n         _ => {\n             ccx.tcx.sess.span_fatal(\n                 ast_trait_ref.path.span,\n-                fmt!(\"%s is not a trait\",\n+                format!(\"{} is not a trait\",\n                     path_to_str(&ast_trait_ref.path,\n                                 ccx.tcx.sess.intr())));\n         }\n@@ -1051,7 +1051,7 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n     } else {\n         match ccx.tcx.items.get(&trait_id.node) {\n             &ast_map::node_item(item, _) => trait_def_of_item(ccx, item),\n-            _ => ccx.tcx.sess.bug(fmt!(\"get_trait_def(%d): not an item\",\n+            _ => ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n                                        trait_id.node))\n         }\n     }\n@@ -1083,7 +1083,7 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n-                fmt!(\"trait_def_of_item invoked on %?\", s));\n+                format!(\"trait_def_of_item invoked on {:?}\", s));\n         }\n     }\n }\n@@ -1120,7 +1120,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n             },\n             ty: ty::mk_bare_fn(ccx.tcx, tofd)\n         };\n-        debug!(\"type of %s (id %d) is %s\",\n+        debug2!(\"type of {} (id {}) is {}\",\n                tcx.sess.str_of(it.ident),\n                it.id,\n                ppaux::ty_to_str(tcx, tpt.ty));\n@@ -1161,7 +1161,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n       ast::item_trait(*) => {\n           tcx.sess.span_bug(\n               it.span,\n-              fmt!(\"Invoked ty_of_item on trait\"));\n+              format!(\"Invoked ty_of_item on trait\"));\n       }\n       ast::item_struct(_, ref generics) => {\n           let (ty_generics, substs) = mk_item_substs(ccx, generics, rp, None);\n@@ -1174,8 +1174,8 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n           return tpt;\n       }\n       ast::item_impl(*) | ast::item_mod(_) |\n-      ast::item_foreign_mod(_) => fail!(),\n-      ast::item_mac(*) => fail!(\"item macros unimplemented\")\n+      ast::item_foreign_mod(_) => fail2!(),\n+      ast::item_mac(*) => fail2!(\"item macros unimplemented\")\n     }\n }\n \n@@ -1222,7 +1222,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                         def_id: local_def(param.id),\n                         bounds: bounds\n                     };\n-                    debug!(\"def for param: %s\", def.repr(ccx.tcx));\n+                    debug2!(\"def for param: {}\", def.repr(ccx.tcx));\n                     ccx.tcx.ty_param_defs.insert(param.id, def);\n                     def\n                 }"}, {"sha": "8d1eaf34256bdfe1ed189492d94aeda54490bc63", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -87,7 +87,7 @@ pub struct Coerce(CombineFields);\n \n impl Coerce {\n     pub fn tys(&self, a: ty::t, b: ty::t) -> CoerceResult {\n-        debug!(\"Coerce.tys(%s => %s)\",\n+        debug2!(\"Coerce.tys({} => {})\",\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n         let _indent = indenter();\n@@ -172,8 +172,8 @@ impl Coerce {\n             Err(e) => {\n                 self.infcx.tcx.sess.span_bug(\n                     self.trace.origin.span(),\n-                    fmt!(\"Failed to resolve even without \\\n-                          any force options: %?\", e));\n+                    format!(\"Failed to resolve even without \\\n+                          any force options: {:?}\", e));\n             }\n         }\n     }\n@@ -184,7 +184,7 @@ impl Coerce {\n                                    b: ty::t,\n                                    mt_b: ty::mt)\n                                    -> CoerceResult {\n-        debug!(\"coerce_borrowed_pointer(a=%s, sty_a=%?, b=%s, mt_b=%?)\",\n+        debug2!(\"coerce_borrowed_pointer(a={}, sty_a={:?}, b={}, mt_b={:?})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx), mt_b);\n \n@@ -221,7 +221,7 @@ impl Coerce {\n                                   sty_a: &ty::sty,\n                                   b: ty::t)\n                                   -> CoerceResult {\n-        debug!(\"coerce_borrowed_string(a=%s, sty_a=%?, b=%s)\",\n+        debug2!(\"coerce_borrowed_string(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n \n@@ -248,7 +248,7 @@ impl Coerce {\n                                   b: ty::t,\n                                   mt_b: ty::mt)\n                                   -> CoerceResult {\n-        debug!(\"coerce_borrowed_vector(a=%s, sty_a=%?, b=%s)\",\n+        debug2!(\"coerce_borrowed_vector(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n \n@@ -277,7 +277,7 @@ impl Coerce {\n                               b: ty::t,\n                               b_mutbl: ast::Mutability) -> CoerceResult\n     {\n-        debug!(\"coerce_borrowed_object(a=%s, sty_a=%?, b=%s)\",\n+        debug2!(\"coerce_borrowed_object(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n \n@@ -306,7 +306,7 @@ impl Coerce {\n                               sty_a: &ty::sty,\n                               b: ty::t)\n                               -> CoerceResult {\n-        debug!(\"coerce_borrowed_fn(a=%s, sty_a=%?, b=%s)\",\n+        debug2!(\"coerce_borrowed_fn(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n \n@@ -361,7 +361,7 @@ impl Coerce {\n          * \"rust\" fn`) into a closure.\n          */\n \n-        debug!(\"coerce_from_bare_fn(a=%s, b=%s)\",\n+        debug2!(\"coerce_from_bare_fn(a={}, b={})\",\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n \n         if !fn_ty_a.abis.is_rust() {\n@@ -389,7 +389,7 @@ impl Coerce {\n                              b: ty::t,\n                              mt_b: ty::mt)\n                              -> CoerceResult {\n-        debug!(\"coerce_unsafe_ptr(a=%s, sty_a=%?, b=%s)\",\n+        debug2!(\"coerce_unsafe_ptr(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n "}, {"sha": "3f6248eae1236b14ec91abfe9b264d6d404103d5", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -116,7 +116,7 @@ pub trait Combine {\n                 // substs and one of them has a self_ty and one\n                 // doesn't...? I could be wrong about this.\n                 self.infcx().tcx.sess.bug(\n-                                          fmt!(\"substitution a had a self_ty \\\n+                                          format!(\"substitution a had a self_ty \\\n                                                and substitution b didn't, \\\n                                                or vice versa\"));\n             }\n@@ -270,7 +270,7 @@ pub trait Combine {\n     fn vstores(&self, vk: ty::terr_vstore_kind,\n                a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n \n-        debug!(\"%s.vstores(a=%?, b=%?)\", self.tag(), a, b);\n+        debug2!(\"{}.vstores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n             (ty::vstore_slice(a_r), ty::vstore_slice(b_r)) => {\n@@ -295,7 +295,7 @@ pub trait Combine {\n                     b: ty::TraitStore)\n                  -> cres<ty::TraitStore> {\n \n-        debug!(\"%s.trait_stores(a=%?, b=%?)\", self.tag(), a, b);\n+        debug2!(\"{}.trait_stores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n             (ty::RegionTraitStore(a_r), ty::RegionTraitStore(b_r)) => {\n@@ -365,7 +365,7 @@ pub fn eq_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> ures {\n \n pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n                           -> ures {\n-    debug!(\"eq_regions(%s, %s)\",\n+    debug2!(\"eq_regions({}, {})\",\n            a.inf_str(this.infcx()),\n            b.inf_str(this.infcx()));\n     let sub = this.sub();\n@@ -406,8 +406,8 @@ pub fn eq_opt_regions<C:Combine>(\n         // consistently have a region parameter or not have a\n         // region parameter.\n         this.infcx().tcx.sess.bug(\n-            fmt!(\"substitution a had opt_region %s and \\\n-                  b had opt_region %s\",\n+            format!(\"substitution a had opt_region {} and \\\n+                  b had opt_region {}\",\n                  a.inf_str(this.infcx()),\n                  b.inf_str(this.infcx())));\n       }\n@@ -446,7 +446,7 @@ pub fn super_tys<C:Combine>(\n       (&ty::ty_infer(TyVar(_)), _) |\n       (_, &ty::ty_infer(TyVar(_))) => {\n         tcx.sess.bug(\n-            fmt!(\"%s: bot and var types should have been handled (%s,%s)\",\n+            format!(\"{}: bot and var types should have been handled ({},{})\",\n                  this.tag(),\n                  a.inf_str(this.infcx()),\n                  b.inf_str(this.infcx())));"}, {"sha": "3f38850c8ffda4648baa44fcfc09aef000f1e950", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -163,7 +163,7 @@ impl ErrorReporting for InferCtxt {\n \n         self.tcx.sess.span_err(\n             trace.origin.span(),\n-            fmt!(\"%s: %s (%s)\",\n+            format!(\"{}: {} ({})\",\n                  message_root_str,\n                  expected_found_str,\n                  ty::type_err_to_str(tcx, terr)));\n@@ -173,7 +173,7 @@ impl ErrorReporting for InferCtxt {\n \n     fn values_str(@mut self, values: &ValuePairs) -> Option<~str> {\n         /*!\n-         * Returns a string of the form \"expected `%s` but found `%s`\",\n+         * Returns a string of the form \"expected `{}` but found `{}`\",\n          * or None if this is a derived error.\n          */\n         match *values {\n@@ -201,7 +201,7 @@ impl ErrorReporting for InferCtxt {\n             return None;\n         }\n \n-        Some(fmt!(\"expected `%s` but found `%s`\",\n+        Some(format!(\"expected `{}` but found `{}`\",\n                   expected.user_string(self.tcx),\n                   found.user_string(self.tcx)))\n     }\n@@ -284,7 +284,7 @@ impl ErrorReporting for InferCtxt {\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    fmt!(\"index of slice outside its lifetime\"));\n+                    format!(\"index of slice outside its lifetime\"));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"the slice is only valid for \",\n@@ -375,7 +375,7 @@ impl ErrorReporting for InferCtxt {\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    fmt!(\"in type `%s`, pointer has a longer lifetime than \\\n+                    format!(\"in type `{}`, pointer has a longer lifetime than \\\n                           the data it references\",\n                          ty.user_string(self.tcx)));\n                 note_and_explain_region(\n@@ -400,7 +400,7 @@ impl ErrorReporting for InferCtxt {\n                                sup_region: Region) {\n         self.tcx.sess.span_err(\n             var_origin.span(),\n-            fmt!(\"cannot infer an appropriate lifetime \\\n+            format!(\"cannot infer an appropriate lifetime \\\n                   due to conflicting requirements\"));\n \n         note_and_explain_region(\n@@ -411,7 +411,7 @@ impl ErrorReporting for InferCtxt {\n \n         self.tcx.sess.span_note(\n             sup_origin.span(),\n-            fmt!(\"...due to the following expression\"));\n+            format!(\"...due to the following expression\"));\n \n         note_and_explain_region(\n             self.tcx,\n@@ -421,7 +421,7 @@ impl ErrorReporting for InferCtxt {\n \n         self.tcx.sess.span_note(\n             sub_origin.span(),\n-            fmt!(\"...due to the following expression\"));\n+            format!(\"...due to the following expression\"));\n     }\n \n     fn report_sup_sup_conflict(@mut self,\n@@ -432,7 +432,7 @@ impl ErrorReporting for InferCtxt {\n                                region2: Region) {\n         self.tcx.sess.span_err(\n             var_origin.span(),\n-            fmt!(\"cannot infer an appropriate lifetime \\\n+            format!(\"cannot infer an appropriate lifetime \\\n                   due to conflicting requirements\"));\n \n         note_and_explain_region(\n@@ -443,7 +443,7 @@ impl ErrorReporting for InferCtxt {\n \n         self.tcx.sess.span_note(\n             origin1.span(),\n-            fmt!(\"...due to the following expression\"));\n+            format!(\"...due to the following expression\"));\n \n         note_and_explain_region(\n             self.tcx,\n@@ -453,7 +453,7 @@ impl ErrorReporting for InferCtxt {\n \n         self.tcx.sess.span_note(\n             origin2.span(),\n-            fmt!(\"...due to the following expression\"));\n+            format!(\"...due to the following expression\"));\n     }\n }\n "}, {"sha": "5e9eb51cbb64df369d629a23106c2d338939d36d", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -44,7 +44,7 @@ impl Combine for Glb {\n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx.tcx;\n \n-        debug!(\"%s.mts(%s, %s)\",\n+        debug2!(\"{}.mts({}, {})\",\n                self.tag(),\n                mt_to_str(tcx, a),\n                mt_to_str(tcx, b));\n@@ -100,7 +100,7 @@ impl Combine for Glb {\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        debug!(\"%s.regions(%?, %?)\",\n+        debug2!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -121,7 +121,7 @@ impl Combine for Glb {\n         // Note: this is a subtle algorithm.  For a full explanation,\n         // please see the large comment in `region_inference.rs`.\n \n-        debug!(\"%s.fn_sigs(%?, %?)\",\n+        debug2!(\"{}.fn_sigs({:?}, {:?})\",\n                self.tag(), a.inf_str(self.infcx), b.inf_str(self.infcx));\n         let _indenter = indenter();\n \n@@ -143,7 +143,7 @@ impl Combine for Glb {\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = %s\", sig0.inf_str(self.infcx));\n+        debug2!(\"sig0 = {}\", sig0.inf_str(self.infcx));\n \n         // Generalize the regions appearing in fn_ty0 if possible\n         let new_vars =\n@@ -155,7 +155,7 @@ impl Combine for Glb {\n                 |r, _in_fn| generalize_region(self, snapshot,\n                                               new_vars, a_isr, a_vars, b_vars,\n                                               r));\n-        debug!(\"sig1 = %s\", sig1.inf_str(self.infcx));\n+        debug2!(\"sig1 = {}\", sig1.inf_str(self.infcx));\n         return Ok(sig1);\n \n         fn generalize_region(this: &Glb,\n@@ -237,7 +237,7 @@ impl Combine for Glb {\n                 Some(x) => x,\n                 None => this.infcx.tcx.sess.span_bug(\n                             this.trace.origin.span(),\n-                            fmt!(\"could not find original bound region for %?\", r))\n+                            format!(\"could not find original bound region for {:?}\", r))\n             }\n         }\n "}, {"sha": "919ad68a818fa7fec68fe90e6c1be027f4a2e9fb", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -131,7 +131,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         let a_bounds = node_a.possible_types.clone();\n         let b_bounds = node_b.possible_types.clone();\n \n-        debug!(\"vars(%s=%s <: %s=%s)\",\n+        debug2!(\"vars({}={} <: {}={})\",\n                a_id.to_str(), a_bounds.inf_str(self.infcx),\n                b_id.to_str(), b_bounds.inf_str(self.infcx));\n \n@@ -179,7 +179,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         let a_bounds = &node_a.possible_types;\n         let b_bounds = &Bounds { lb: None, ub: Some(b.clone()) };\n \n-        debug!(\"var_sub_t(%s=%s <: %s)\",\n+        debug2!(\"var_sub_t({}={} <: {})\",\n                a_id.to_str(),\n                a_bounds.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -203,7 +203,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         let b_id = node_b.root.clone();\n         let b_bounds = &node_b.possible_types;\n \n-        debug!(\"t_sub_var(%s <: %s=%s)\",\n+        debug2!(\"t_sub_var({} <: {}={})\",\n                a.inf_str(self.infcx),\n                b_id.to_str(),\n                b_bounds.inf_str(self.infcx));\n@@ -222,7 +222,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n          *\n          * Combines two bounds into a more general bound. */\n \n-        debug!(\"merge_bnd(%s,%s)\",\n+        debug2!(\"merge_bnd({},{})\",\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n         let _r = indenter();\n@@ -273,7 +273,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         //       A     \\ / A\n         //              B\n \n-        debug!(\"merge(%s,%s,%s)\",\n+        debug2!(\"merge({},{},{})\",\n                v_id.to_str(),\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -290,7 +290,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         let ub = if_ok!(self.merge_bnd(&a.ub, &b.ub, LatticeValue::glb));\n         let lb = if_ok!(self.merge_bnd(&a.lb, &b.lb, LatticeValue::lub));\n         let bounds = Bounds { lb: lb, ub: ub };\n-        debug!(\"merge(%s): bounds=%s\",\n+        debug2!(\"merge({}): bounds={}\",\n                v_id.to_str(),\n                bounds.inf_str(self.infcx));\n \n@@ -305,7 +305,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n                                                a: &Bound<T>,\n                                                b: &Bound<T>)\n                                                -> ures {\n-        debug!(\"bnds(%s <: %s)\", a.inf_str(self.infcx),\n+        debug2!(\"bnds({} <: {})\", a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n         let _r = indenter();\n \n@@ -370,7 +370,7 @@ pub fn super_lattice_tys<L:LatticeDir + TyLatticeDir + Combine>(\n     this: &L,\n     a: ty::t,\n     b: ty::t) -> cres<ty::t> {\n-    debug!(\"%s.lattice_tys(%s, %s)\", this.tag(),\n+    debug2!(\"{}.lattice_tys({}, {})\", this.tag(),\n            a.inf_str(this.infcx()),\n            b.inf_str(this.infcx()));\n     let _r = indenter();\n@@ -448,7 +448,7 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n     let a_bounds = &nde_a.possible_types;\n     let b_bounds = &nde_b.possible_types;\n \n-    debug!(\"%s.lattice_vars(%s=%s <: %s=%s)\",\n+    debug2!(\"{}.lattice_vars({}={} <: {}={})\",\n            this.tag(),\n            a_vid.to_str(), a_bounds.inf_str(this.infcx()),\n            b_vid.to_str(), b_bounds.inf_str(this.infcx()));\n@@ -494,7 +494,7 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n     // The comments in this function are written for LUB, but they\n     // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n \n-    debug!(\"%s.lattice_var_and_t(%s=%s <: %s)\",\n+    debug2!(\"{}.lattice_var_and_t({}={} <: {})\",\n            this.tag(),\n            a_id.to_str(),\n            a_bounds.inf_str(this.infcx()),\n@@ -503,13 +503,13 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n     match this.bnd(a_bounds) {\n         Some(ref a_bnd) => {\n             // If a has an upper bound, return the LUB(a.ub, b)\n-            debug!(\"bnd=Some(%s)\", a_bnd.inf_str(this.infcx()));\n+            debug2!(\"bnd=Some({})\", a_bnd.inf_str(this.infcx()));\n             lattice_dir_op(a_bnd, b)\n         }\n         None => {\n             // If a does not have an upper bound, make b the upper bound of a\n             // and then return b.\n-            debug!(\"bnd=None\");\n+            debug2!(\"bnd=None\");\n             let a_bounds = this.with_bnd(a_bounds, (*b).clone());\n             do this.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then {\n                 this.infcx().set(a_id.clone(),\n@@ -532,7 +532,7 @@ pub fn var_ids<T:Combine>(this: &T, isr: isr_alist) -> ~[RegionVid] {\n             r => {\n                 this.infcx().tcx.sess.span_bug(\n                     this.trace().origin.span(),\n-                    fmt!(\"Found non-region-vid: %?\", r));\n+                    format!(\"Found non-region-vid: {:?}\", r));\n             }\n         }\n         true"}, {"sha": "c8974a722fd88de6df8edaccd6b9e52a42077f51", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -50,7 +50,7 @@ impl Combine for Lub {\n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx.tcx;\n \n-        debug!(\"%s.mts(%s, %s)\",\n+        debug2!(\"{}.mts({}, {})\",\n                self.tag(),\n                mt_to_str(tcx, a),\n                mt_to_str(tcx, b));\n@@ -106,7 +106,7 @@ impl Combine for Lub {\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        debug!(\"%s.regions(%?, %?)\",\n+        debug2!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -134,7 +134,7 @@ impl Combine for Lub {\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = %s\", sig0.inf_str(self.infcx));\n+        debug2!(\"sig0 = {}\", sig0.inf_str(self.infcx));\n \n         // Generalize the regions appearing in sig0 if possible\n         let new_vars =\n@@ -154,7 +154,7 @@ impl Combine for Lub {\n                              r0: ty::Region) -> ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n-                debug!(\"generalize_region(r0=%?): not new variable\", r0);\n+                debug2!(\"generalize_region(r0={:?}): not new variable\", r0);\n                 return r0;\n             }\n \n@@ -164,8 +164,8 @@ impl Combine for Lub {\n             // *related* to regions that pre-date the LUB computation\n             // stay as they are.\n             if !tainted.iter().all(|r| is_var_in_set(new_vars, *r)) {\n-                debug!(\"generalize_region(r0=%?): \\\n-                        non-new-variables found in %?\",\n+                debug2!(\"generalize_region(r0={:?}): \\\n+                        non-new-variables found in {:?}\",\n                        r0, tainted);\n                 return r0;\n             }\n@@ -179,8 +179,8 @@ impl Combine for Lub {\n             do list::each(a_isr) |pair| {\n                 let (a_br, a_r) = *pair;\n                 if tainted.iter().any(|x| x == &a_r) {\n-                    debug!(\"generalize_region(r0=%?): \\\n-                            replacing with %?, tainted=%?\",\n+                    debug2!(\"generalize_region(r0={:?}): \\\n+                            replacing with {:?}, tainted={:?}\",\n                            r0, a_br, tainted);\n                     ret = Some(ty::re_bound(a_br));\n                     false\n@@ -193,7 +193,7 @@ impl Combine for Lub {\n                 Some(x) => x,\n                 None => this.infcx.tcx.sess.span_bug(\n                             this.trace.origin.span(),\n-                            fmt!(\"Region %? is not associated with \\\n+                            format!(\"Region {:?} is not associated with \\\n                                   any bound region from A!\", r0))\n             }\n         }"}, {"sha": "89e9f626ca581f77e1178d7da491318642321f6a", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -244,7 +244,7 @@ pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n       cyclic_ty(_) => ~\"cyclic type of infinite size\",\n       unresolved_region(_) => ~\"unconstrained region\",\n       region_var_bound_by_region_var(r1, r2) => {\n-        fmt!(\"region var %? bound by another region var %?; this is \\\n+        format!(\"region var {:?} bound by another region var {:?}; this is \\\n               a bug in rustc\", r1, r2)\n       }\n     }\n@@ -285,7 +285,7 @@ pub fn common_supertype(cx: @mut InferCtxt,\n      * not possible, reports an error and returns ty::err.\n      */\n \n-    debug!(\"common_supertype(%s, %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug2!(\"common_supertype({}, {})\", a.inf_str(cx), b.inf_str(cx));\n \n     let trace = TypeTrace {\n         origin: origin,\n@@ -311,7 +311,7 @@ pub fn mk_subty(cx: @mut InferCtxt,\n                 a: ty::t,\n                 b: ty::t)\n              -> ures {\n-    debug!(\"mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug2!(\"mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n             let trace = TypeTrace {\n@@ -324,7 +324,7 @@ pub fn mk_subty(cx: @mut InferCtxt,\n }\n \n pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n-    debug!(\"can_mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug2!(\"can_mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n             let trace = TypeTrace {\n@@ -341,7 +341,7 @@ pub fn mk_subr(cx: @mut InferCtxt,\n                origin: SubregionOrigin,\n                a: ty::Region,\n                b: ty::Region) {\n-    debug!(\"mk_subr(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug2!(\"mk_subr({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     cx.region_vars.start_snapshot();\n     cx.region_vars.make_subregion(origin, a, b);\n     cx.region_vars.commit();\n@@ -353,7 +353,7 @@ pub fn mk_eqty(cx: @mut InferCtxt,\n                a: ty::t,\n                b: ty::t)\n             -> ures {\n-    debug!(\"mk_eqty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug2!(\"mk_eqty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n             let trace = TypeTrace {\n@@ -373,7 +373,7 @@ pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n                          b: @ty::TraitRef)\n     -> ures\n {\n-    debug!(\"mk_sub_trait_refs(%s <: %s)\",\n+    debug2!(\"mk_sub_trait_refs({} <: {})\",\n            a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n@@ -403,7 +403,7 @@ pub fn mk_coercety(cx: @mut InferCtxt,\n                    a: ty::t,\n                    b: ty::t)\n                 -> CoerceResult {\n-    debug!(\"mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug2!(\"mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n             let trace = TypeTrace {\n@@ -416,7 +416,7 @@ pub fn mk_coercety(cx: @mut InferCtxt,\n }\n \n pub fn can_mk_coercety(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n-    debug!(\"can_mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug2!(\"can_mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n             let trace = TypeTrace {\n@@ -539,7 +539,7 @@ impl InferCtxt {\n     }\n \n     pub fn rollback_to(&mut self, snapshot: &Snapshot) {\n-        debug!(\"rollback!\");\n+        debug2!(\"rollback!\");\n         rollback_to(&mut self.ty_var_bindings, snapshot.ty_var_bindings_len);\n \n         rollback_to(&mut self.int_var_bindings,\n@@ -554,7 +554,7 @@ impl InferCtxt {\n     pub fn commit<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         assert!(!self.in_snapshot());\n \n-        debug!(\"commit()\");\n+        debug2!(\"commit()\");\n         do indent {\n             let r = self.try(|| f());\n \n@@ -567,7 +567,7 @@ impl InferCtxt {\n \n     /// Execute `f`, unroll bindings on failure\n     pub fn try<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n-        debug!(\"try()\");\n+        debug2!(\"try()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n             let r = f();\n@@ -581,7 +581,7 @@ impl InferCtxt {\n \n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n-        debug!(\"probe()\");\n+        debug2!(\"probe()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n             let r = f();\n@@ -654,7 +654,7 @@ impl InferCtxt {\n \n     pub fn tys_to_str(@mut self, ts: &[ty::t]) -> ~str {\n         let tstrs = ts.map(|t| self.ty_to_str(*t));\n-        fmt!(\"(%s)\", tstrs.connect(\", \"))\n+        format!(\"({})\", tstrs.connect(\", \"))\n     }\n \n     pub fn trait_ref_to_str(@mut self, t: &ty::TraitRef) -> ~str {\n@@ -690,8 +690,8 @@ impl InferCtxt {\n             }\n             _ => {\n                 self.tcx.sess.bug(\n-                    fmt!(\"resolve_type_vars_if_possible() yielded %s \\\n-                          when supplied with %s\",\n+                    format!(\"resolve_type_vars_if_possible() yielded {} \\\n+                          when supplied with {}\",\n                          self.ty_to_str(dummy0),\n                          self.ty_to_str(dummy1)));\n             }\n@@ -725,21 +725,21 @@ impl InferCtxt {\n                                                 expected_ty: Option<ty::t>,\n                                                 actual_ty: ~str,\n                                                 err: Option<&ty::type_err>) {\n-        debug!(\"hi! expected_ty = %?, actual_ty = %s\", expected_ty, actual_ty);\n+        debug2!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n         let error_str = do err.map_move_default(~\"\") |t_err| {\n-            fmt!(\" (%s)\", ty::type_err_to_str(self.tcx, t_err))\n+            format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n         };\n         let resolved_expected = do expected_ty.map_move |e_ty| {\n             self.resolve_type_vars_if_possible(e_ty)\n         };\n         if !resolved_expected.map_move_default(false, |e| { ty::type_is_error(e) }) {\n             match resolved_expected {\n                 None => self.tcx.sess.span_err(sp,\n-                            fmt!(\"%s%s\", mk_msg(None, actual_ty), error_str)),\n+                            format!(\"{}{}\", mk_msg(None, actual_ty), error_str)),\n                 Some(e) => {\n                     self.tcx.sess.span_err(sp,\n-                        fmt!(\"%s%s\", mk_msg(Some(self.ty_to_str(e)), actual_ty), error_str));\n+                        format!(\"{}{}\", mk_msg(Some(self.ty_to_str(e)), actual_ty), error_str));\n                 }\n             }\n             for err in err.iter() {\n@@ -776,7 +776,7 @@ impl InferCtxt {\n             _ => {\n                 // if I leave out : ~str, it infers &str and complains\n                 |actual: ~str| {\n-                    fmt!(\"mismatched types: expected `%s` but found `%s`\",\n+                    format!(\"mismatched types: expected `{}` but found `{}`\",\n                          self.ty_to_str(resolved_expected), actual)\n                 }\n             }\n@@ -792,7 +792,7 @@ impl InferCtxt {\n             replace_bound_regions_in_fn_sig(self.tcx, @Nil, None, fsig, |br| {\n                 let rvar = self.next_region_var(\n                     BoundRegionInFnType(trace.origin.span(), br));\n-                debug!(\"Bound region %s maps to %?\",\n+                debug2!(\"Bound region {} maps to {:?}\",\n                        bound_region_to_str(self.tcx, \"\", false, br),\n                        rvar);\n                 rvar\n@@ -819,7 +819,7 @@ impl TypeTrace {\n \n impl Repr for TypeTrace {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n-        fmt!(\"TypeTrace(%s)\", self.origin.repr(tcx))\n+        format!(\"TypeTrace({})\", self.origin.repr(tcx))\n     }\n }\n \n@@ -840,13 +840,13 @@ impl TypeOrigin {\n impl Repr for TypeOrigin {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n-            MethodCompatCheck(a) => fmt!(\"MethodCompatCheck(%s)\", a.repr(tcx)),\n-            ExprAssignable(a) => fmt!(\"ExprAssignable(%s)\", a.repr(tcx)),\n-            Misc(a) => fmt!(\"Misc(%s)\", a.repr(tcx)),\n-            RelateTraitRefs(a) => fmt!(\"RelateTraitRefs(%s)\", a.repr(tcx)),\n-            RelateSelfType(a) => fmt!(\"RelateSelfType(%s)\", a.repr(tcx)),\n-            MatchExpression(a) => fmt!(\"MatchExpression(%s)\", a.repr(tcx)),\n-            IfExpression(a) => fmt!(\"IfExpression(%s)\", a.repr(tcx)),\n+            MethodCompatCheck(a) => format!(\"MethodCompatCheck({})\", a.repr(tcx)),\n+            ExprAssignable(a) => format!(\"ExprAssignable({})\", a.repr(tcx)),\n+            Misc(a) => format!(\"Misc({})\", a.repr(tcx)),\n+            RelateTraitRefs(a) => format!(\"RelateTraitRefs({})\", a.repr(tcx)),\n+            RelateSelfType(a) => format!(\"RelateSelfType({})\", a.repr(tcx)),\n+            MatchExpression(a) => format!(\"MatchExpression({})\", a.repr(tcx)),\n+            IfExpression(a) => format!(\"IfExpression({})\", a.repr(tcx)),\n         }\n     }\n }\n@@ -876,21 +876,23 @@ impl SubregionOrigin {\n impl Repr for SubregionOrigin {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n-            Subtype(a) => fmt!(\"Subtype(%s)\", a.repr(tcx)),\n-            InfStackClosure(a) => fmt!(\"InfStackClosure(%s)\", a.repr(tcx)),\n-            InvokeClosure(a) => fmt!(\"InvokeClosure(%s)\", a.repr(tcx)),\n-            DerefPointer(a) => fmt!(\"DerefPointer(%s)\", a.repr(tcx)),\n-            FreeVariable(a) => fmt!(\"FreeVariable(%s)\", a.repr(tcx)),\n-            IndexSlice(a) => fmt!(\"IndexSlice(%s)\", a.repr(tcx)),\n-            RelateObjectBound(a) => fmt!(\"RelateObjectBound(%s)\", a.repr(tcx)),\n-            Reborrow(a) => fmt!(\"Reborrow(%s)\", a.repr(tcx)),\n-            ReferenceOutlivesReferent(_, a) => fmt!(\"ReferenceOutlivesReferent(%s)\", a.repr(tcx)),\n-            BindingTypeIsNotValidAtDecl(a) => fmt!(\"BindingTypeIsNotValidAtDecl(%s)\", a.repr(tcx)),\n-            CallRcvr(a) => fmt!(\"CallRcvr(%s)\", a.repr(tcx)),\n-            CallArg(a) => fmt!(\"CallArg(%s)\", a.repr(tcx)),\n-            CallReturn(a) => fmt!(\"CallReturn(%s)\", a.repr(tcx)),\n-            AddrOf(a) => fmt!(\"AddrOf(%s)\", a.repr(tcx)),\n-            AutoBorrow(a) => fmt!(\"AutoBorrow(%s)\", a.repr(tcx)),\n+            Subtype(a) => format!(\"Subtype({})\", a.repr(tcx)),\n+            InfStackClosure(a) => format!(\"InfStackClosure({})\", a.repr(tcx)),\n+            InvokeClosure(a) => format!(\"InvokeClosure({})\", a.repr(tcx)),\n+            DerefPointer(a) => format!(\"DerefPointer({})\", a.repr(tcx)),\n+            FreeVariable(a) => format!(\"FreeVariable({})\", a.repr(tcx)),\n+            IndexSlice(a) => format!(\"IndexSlice({})\", a.repr(tcx)),\n+            RelateObjectBound(a) => format!(\"RelateObjectBound({})\", a.repr(tcx)),\n+            Reborrow(a) => format!(\"Reborrow({})\", a.repr(tcx)),\n+            ReferenceOutlivesReferent(_, a) =>\n+                format!(\"ReferenceOutlivesReferent({})\", a.repr(tcx)),\n+            BindingTypeIsNotValidAtDecl(a) =>\n+                format!(\"BindingTypeIsNotValidAtDecl({})\", a.repr(tcx)),\n+            CallRcvr(a) => format!(\"CallRcvr({})\", a.repr(tcx)),\n+            CallArg(a) => format!(\"CallArg({})\", a.repr(tcx)),\n+            CallReturn(a) => format!(\"CallReturn({})\", a.repr(tcx)),\n+            AddrOf(a) => format!(\"AddrOf({})\", a.repr(tcx)),\n+            AutoBorrow(a) => format!(\"AutoBorrow({})\", a.repr(tcx)),\n         }\n     }\n }\n@@ -916,20 +918,20 @@ impl RegionVariableOrigin {\n impl Repr for RegionVariableOrigin {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n-            MiscVariable(a) => fmt!(\"MiscVariable(%s)\", a.repr(tcx)),\n-            PatternRegion(a) => fmt!(\"PatternRegion(%s)\", a.repr(tcx)),\n-            AddrOfRegion(a) => fmt!(\"AddrOfRegion(%s)\", a.repr(tcx)),\n-            AddrOfSlice(a) => fmt!(\"AddrOfSlice(%s)\", a.repr(tcx)),\n-            Autoref(a) => fmt!(\"Autoref(%s)\", a.repr(tcx)),\n-            Coercion(a) => fmt!(\"Coercion(%s)\", a.repr(tcx)),\n-            BoundRegionInFnCall(a, b) => fmt!(\"BoundRegionInFnCall(%s,%s)\",\n+            MiscVariable(a) => format!(\"MiscVariable({})\", a.repr(tcx)),\n+            PatternRegion(a) => format!(\"PatternRegion({})\", a.repr(tcx)),\n+            AddrOfRegion(a) => format!(\"AddrOfRegion({})\", a.repr(tcx)),\n+            AddrOfSlice(a) => format!(\"AddrOfSlice({})\", a.repr(tcx)),\n+            Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n+            Coercion(a) => format!(\"Coercion({})\", a.repr(tcx)),\n+            BoundRegionInFnCall(a, b) => format!(\"BoundRegionInFnCall({},{})\",\n                                               a.repr(tcx), b.repr(tcx)),\n-            BoundRegionInFnType(a, b) => fmt!(\"BoundRegionInFnType(%s,%s)\",\n+            BoundRegionInFnType(a, b) => format!(\"BoundRegionInFnType({},{})\",\n                                               a.repr(tcx), b.repr(tcx)),\n-            BoundRegionInTypeOrImpl(a) => fmt!(\"BoundRegionInTypeOrImpl(%s)\",\n+            BoundRegionInTypeOrImpl(a) => format!(\"BoundRegionInTypeOrImpl({})\",\n                                                a.repr(tcx)),\n-            BoundRegionInCoherence => fmt!(\"BoundRegionInCoherence\"),\n-            BoundRegionError(a) => fmt!(\"BoundRegionError(%s)\", a.repr(tcx)),\n+            BoundRegionInCoherence => format!(\"BoundRegionInCoherence\"),\n+            BoundRegionError(a) => format!(\"BoundRegionError({})\", a.repr(tcx)),\n         }\n     }\n }"}, {"sha": "e5492453b98e2ffd201b7f3ef765011100853117", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -130,7 +130,7 @@ impl RegionVarBindings {\n     }\n \n     pub fn start_snapshot(&mut self) -> uint {\n-        debug!(\"RegionVarBindings: snapshot()=%u\", self.undo_log.len());\n+        debug2!(\"RegionVarBindings: snapshot()={}\", self.undo_log.len());\n         if self.in_snapshot() {\n             self.undo_log.len()\n         } else {\n@@ -140,17 +140,17 @@ impl RegionVarBindings {\n     }\n \n     pub fn commit(&mut self) {\n-        debug!(\"RegionVarBindings: commit()\");\n+        debug2!(\"RegionVarBindings: commit()\");\n         while self.undo_log.len() > 0 {\n             self.undo_log.pop();\n         }\n     }\n \n     pub fn rollback_to(&mut self, snapshot: uint) {\n-        debug!(\"RegionVarBindings: rollback_to(%u)\", snapshot);\n+        debug2!(\"RegionVarBindings: rollback_to({})\", snapshot);\n         while self.undo_log.len() > snapshot {\n             let undo_item = self.undo_log.pop();\n-            debug!(\"undo_item=%?\", undo_item);\n+            debug2!(\"undo_item={:?}\", undo_item);\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n@@ -181,7 +181,7 @@ impl RegionVarBindings {\n         if self.in_snapshot() {\n             self.undo_log.push(AddVar(vid));\n         }\n-        debug!(\"created new region variable %? with origin %?\",\n+        debug2!(\"created new region variable {:?} with origin {:?}\",\n                vid, origin.repr(self.tcx));\n         return vid;\n     }\n@@ -218,7 +218,7 @@ impl RegionVarBindings {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n-        debug!(\"RegionVarBindings: add_constraint(%?)\", constraint);\n+        debug2!(\"RegionVarBindings: add_constraint({:?})\", constraint);\n \n         if self.constraints.insert(constraint, origin) {\n             if self.in_snapshot() {\n@@ -234,7 +234,7 @@ impl RegionVarBindings {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n-        debug!(\"RegionVarBindings: make_subregion(%?, %?)\", sub, sup);\n+        debug2!(\"RegionVarBindings: make_subregion({:?}, {:?})\", sub, sup);\n         match (sub, sup) {\n           (re_infer(ReVar(sub_id)), re_infer(ReVar(sup_id))) => {\n             self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n@@ -248,12 +248,12 @@ impl RegionVarBindings {\n           (re_bound(br), _) => {\n             self.tcx.sess.span_bug(\n                 origin.span(),\n-                fmt!(\"Cannot relate bound region as subregion: %?\", br));\n+                format!(\"Cannot relate bound region as subregion: {:?}\", br));\n           }\n           (_, re_bound(br)) => {\n             self.tcx.sess.span_bug(\n                 origin.span(),\n-                fmt!(\"Cannot relate bound region as superregion: %?\", br));\n+                format!(\"Cannot relate bound region as superregion: {:?}\", br));\n           }\n           _ => {\n             self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n@@ -269,7 +269,7 @@ impl RegionVarBindings {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n-        debug!(\"RegionVarBindings: lub_regions(%?, %?)\", a, b);\n+        debug2!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (re_static, _) | (_, re_static) => {\n                 re_static // nothing lives longer than static\n@@ -292,7 +292,7 @@ impl RegionVarBindings {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n-        debug!(\"RegionVarBindings: glb_regions(%?, %?)\", a, b);\n+        debug2!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (re_static, r) | (r, re_static) => {\n                 // static lives longer than everything else\n@@ -312,12 +312,12 @@ impl RegionVarBindings {\n         if self.values.is_empty() {\n             self.tcx.sess.span_bug(\n                 self.var_origins[rid.to_uint()].span(),\n-                fmt!(\"Attempt to resolve region variable before values have \\\n+                format!(\"Attempt to resolve region variable before values have \\\n                       been computed!\"));\n         }\n \n         let v = self.values.with_ref(|values| values[rid.to_uint()]);\n-        debug!(\"RegionVarBindings: resolve_var(%?=%u)=%?\",\n+        debug2!(\"RegionVarBindings: resolve_var({:?}={})={:?}\",\n                rid, rid.to_uint(), v);\n         match v {\n             Value(r) => r,\n@@ -367,7 +367,7 @@ impl RegionVarBindings {\n         }\n         relate(self, a, re_infer(ReVar(c)));\n         relate(self, b, re_infer(ReVar(c)));\n-        debug!(\"combine_vars() c=%?\", c);\n+        debug2!(\"combine_vars() c={:?}\", c);\n         re_infer(ReVar(c))\n     }\n \n@@ -390,7 +390,7 @@ impl RegionVarBindings {\n          * regions.\n          */\n \n-        debug!(\"tainted(snapshot=%u, r0=%?)\", snapshot, r0);\n+        debug2!(\"tainted(snapshot={}, r0={:?})\", snapshot, r0);\n         let _indenter = indenter();\n \n         let undo_len = self.undo_log.len();\n@@ -404,7 +404,7 @@ impl RegionVarBindings {\n             // nb: can't use uint::range() here because result_set grows\n             let r = result_set[result_index];\n \n-            debug!(\"result_index=%u, r=%?\", result_index, r);\n+            debug2!(\"result_index={}, r={:?}\", result_index, r);\n \n             let mut undo_index = snapshot;\n             while undo_index < undo_len {\n@@ -469,7 +469,7 @@ impl RegionVarBindings {\n     errors are reported.\n     */\n     pub fn resolve_regions(&mut self) -> OptVec<RegionResolutionError> {\n-        debug!(\"RegionVarBindings: resolve_regions()\");\n+        debug2!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = opt_vec::Empty;\n         let v = self.infer_variable_values(&mut errors);\n         self.values.put_back(v);\n@@ -496,8 +496,8 @@ impl RegionVarBindings {\n           (re_infer(ReVar(v_id)), _) | (_, re_infer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n                 self.var_origins[v_id.to_uint()].span(),\n-                fmt!(\"lub_concrete_regions invoked with \\\n-                      non-concrete regions: %?, %?\", a, b));\n+                format!(\"lub_concrete_regions invoked with \\\n+                      non-concrete regions: {:?}, {:?}\", a, b));\n           }\n \n           (f @ re_free(ref fr), re_scope(s_id)) |\n@@ -582,7 +582,7 @@ impl RegionVarBindings {\n                             a: Region,\n                             b: Region)\n                          -> cres<Region> {\n-        debug!(\"glb_concrete_regions(%?, %?)\", a, b);\n+        debug2!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (re_static, r) | (r, re_static) => {\n                 // static lives longer than everything else\n@@ -598,8 +598,8 @@ impl RegionVarBindings {\n             (_, re_infer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n                     self.var_origins[v_id.to_uint()].span(),\n-                    fmt!(\"glb_concrete_regions invoked with \\\n-                          non-concrete regions: %?, %?\", a, b));\n+                    format!(\"glb_concrete_regions invoked with \\\n+                          non-concrete regions: {:?}, {:?}\", a, b));\n             }\n \n             (re_free(ref fr), s @ re_scope(s_id)) |\n@@ -691,7 +691,7 @@ impl RegionVarBindings {\n         // scopes or two free regions.  So, if one of\n         // these scopes is a subscope of the other, return\n         // it.  Otherwise fail.\n-        debug!(\"intersect_scopes(scope_a=%?, scope_b=%?, region_a=%?, region_b=%?)\",\n+        debug2!(\"intersect_scopes(scope_a={:?}, scope_b={:?}, region_a={:?}, region_b={:?})\",\n                scope_a, scope_b, region_a, region_b);\n         let rm = self.tcx.region_maps;\n         match rm.nearest_common_ancestor(scope_a, scope_b) {\n@@ -778,13 +778,13 @@ impl RegionVarBindings {\n                    b_vid: RegionVid,\n                    b_data: &mut VarData)\n                    -> bool {\n-        debug!(\"expand_node(%?, %? == %?)\",\n+        debug2!(\"expand_node({:?}, {:?} == {:?})\",\n                a_region, b_vid, b_data.value);\n \n         b_data.classification = Expanding;\n         match b_data.value {\n           NoValue => {\n-            debug!(\"Setting initial value of %? to %?\", b_vid, a_region);\n+            debug2!(\"Setting initial value of {:?} to {:?}\", b_vid, a_region);\n \n             b_data.value = Value(a_region);\n             return true;\n@@ -796,7 +796,7 @@ impl RegionVarBindings {\n                 return false;\n             }\n \n-            debug!(\"Expanding value of %? from %? to %?\",\n+            debug2!(\"Expanding value of {:?} from {:?} to {:?}\",\n                    b_vid, cur_region, lub);\n \n             b_data.value = Value(lub);\n@@ -843,7 +843,7 @@ impl RegionVarBindings {\n                      a_data: &mut VarData,\n                      b_region: Region)\n                      -> bool {\n-        debug!(\"contract_node(%? == %?/%?, %?)\",\n+        debug2!(\"contract_node({:?} == {:?}/{:?}, {:?})\",\n                a_vid, a_data.value, a_data.classification, b_region);\n \n         return match a_data.value {\n@@ -876,7 +876,7 @@ impl RegionVarBindings {\n                       b_region: Region)\n                    -> bool {\n             if !this.is_subregion_of(a_region, b_region) {\n-                debug!(\"Setting %? to ErrorValue: %? not subregion of %?\",\n+                debug2!(\"Setting {:?} to ErrorValue: {:?} not subregion of {:?}\",\n                        a_vid, a_region, b_region);\n                 a_data.value = ErrorValue;\n             }\n@@ -894,14 +894,14 @@ impl RegionVarBindings {\n                     if glb == a_region {\n                         false\n                     } else {\n-                        debug!(\"Contracting value of %? from %? to %?\",\n+                        debug2!(\"Contracting value of {:?} from {:?} to {:?}\",\n                                a_vid, a_region, glb);\n                         a_data.value = Value(glb);\n                         true\n                     }\n                 }\n                 Err(_) => {\n-                    debug!(\"Setting %? to ErrorValue: no glb of %?, %?\",\n+                    debug2!(\"Setting {:?} to ErrorValue: no glb of {:?}, {:?}\",\n                            a_vid, a_region, b_region);\n                     a_data.value = ErrorValue;\n                     false\n@@ -930,7 +930,7 @@ impl RegionVarBindings {\n                 loop;\n             }\n \n-            debug!(\"ConcreteFailure: !(sub <= sup): sub=%?, sup=%?\",\n+            debug2!(\"ConcreteFailure: !(sub <= sup): sub={:?}, sup={:?}\",\n                    sub, sup);\n             let origin = self.constraints.get_copy(constraint);\n             errors.push(ConcreteFailure(origin, sub, sup));\n@@ -943,7 +943,7 @@ impl RegionVarBindings {\n         errors: &mut OptVec<RegionResolutionError>)\n         -> ~[VarValue]\n     {\n-        debug!(\"extract_values_and_collect_conflicts()\");\n+        debug2!(\"extract_values_and_collect_conflicts()\");\n \n         // This is the best way that I have found to suppress\n         // duplicate and related errors. Basically we keep a set of\n@@ -1095,8 +1095,8 @@ impl RegionVarBindings {\n \n         self.tcx.sess.span_bug(\n             self.var_origins[node_idx.to_uint()].span(),\n-            fmt!(\"collect_error_for_expanding_node() could not find error \\\n-                  for var %?, lower_bounds=%s, upper_bounds=%s\",\n+            format!(\"collect_error_for_expanding_node() could not find error \\\n+                  for var {:?}, lower_bounds={}, upper_bounds={}\",\n                  node_idx,\n                  lower_bounds.map(|x| x.region).repr(self.tcx),\n                  upper_bounds.map(|x| x.region).repr(self.tcx)));\n@@ -1140,8 +1140,8 @@ impl RegionVarBindings {\n \n         self.tcx.sess.span_bug(\n             self.var_origins[node_idx.to_uint()].span(),\n-            fmt!(\"collect_error_for_contracting_node() could not find error \\\n-                  for var %?, upper_bounds=%s\",\n+            format!(\"collect_error_for_contracting_node() could not find error \\\n+                  for var {:?}, upper_bounds={}\",\n                  node_idx,\n                  upper_bounds.map(|x| x.region).repr(self.tcx)));\n     }\n@@ -1182,8 +1182,8 @@ impl RegionVarBindings {\n                 state.dup_found = true;\n             }\n \n-            debug!(\"collect_concrete_regions(orig_node_idx=%?, node_idx=%?, \\\n-                    classification=%?)\",\n+            debug2!(\"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?}, \\\n+                    classification={:?})\",\n                    orig_node_idx, node_idx, classification);\n \n             // figure out the direction from which this node takes its\n@@ -1204,7 +1204,7 @@ impl RegionVarBindings {\n                          graph: &RegionGraph,\n                          source_vid: RegionVid,\n                          dir: Direction) {\n-            debug!(\"process_edges(source_vid=%?, dir=%?)\", source_vid, dir);\n+            debug2!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n             let source_node_index = NodeIndex(source_vid.to_uint());\n             do graph.each_adjacent_edge(source_node_index, dir) |_, edge| {\n@@ -1240,31 +1240,31 @@ impl RegionVarBindings {\n         while changed {\n             changed = false;\n             iteration += 1;\n-            debug!(\"---- %s Iteration #%u\", tag, iteration);\n+            debug2!(\"---- {} Iteration \\\\#{}\", tag, iteration);\n             for (constraint, _) in self.constraints.iter() {\n                 let edge_changed = body(constraint);\n                 if edge_changed {\n-                    debug!(\"Updated due to constraint %s\",\n+                    debug2!(\"Updated due to constraint {}\",\n                            constraint.repr(self.tcx));\n                     changed = true;\n                 }\n             }\n         }\n-        debug!(\"---- %s Complete after %u iteration(s)\", tag, iteration);\n+        debug2!(\"---- {} Complete after {} iteration(s)\", tag, iteration);\n     }\n \n }\n \n impl Repr for Constraint {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n-            ConstrainVarSubVar(a, b) => fmt!(\"ConstrainVarSubVar(%s, %s)\",\n+            ConstrainVarSubVar(a, b) => format!(\"ConstrainVarSubVar({}, {})\",\n                                              a.repr(tcx), b.repr(tcx)),\n-            ConstrainRegSubVar(a, b) => fmt!(\"ConstrainRegSubVar(%s, %s)\",\n+            ConstrainRegSubVar(a, b) => format!(\"ConstrainRegSubVar({}, {})\",\n                                              a.repr(tcx), b.repr(tcx)),\n-            ConstrainVarSubReg(a, b) => fmt!(\"ConstrainVarSubReg(%s, %s)\",\n+            ConstrainVarSubReg(a, b) => format!(\"ConstrainVarSubReg({}, {})\",\n                                              a.repr(tcx), b.repr(tcx)),\n-            ConstrainRegSubReg(a, b) => fmt!(\"ConstrainRegSubReg(%s, %s)\",\n+            ConstrainRegSubReg(a, b) => format!(\"ConstrainRegSubReg({}, {})\",\n                                              a.repr(tcx), b.repr(tcx)),\n         }\n     }"}, {"sha": "57e0ecf874532520075109ae8845f07a642fad6c", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -104,7 +104,7 @@ impl ResolveState {\n     pub fn resolve_type_chk(&mut self, typ: ty::t) -> fres<ty::t> {\n         self.err = None;\n \n-        debug!(\"Resolving %s (modes=%x)\",\n+        debug2!(\"Resolving {} (modes={:x})\",\n                ty_to_str(self.infcx.tcx, typ),\n                self.modes);\n \n@@ -116,7 +116,7 @@ impl ResolveState {\n         assert!(self.v_seen.is_empty());\n         match self.err {\n           None => {\n-            debug!(\"Resolved to %s + %s (modes=%x)\",\n+            debug2!(\"Resolved to {} + {} (modes={:x})\",\n                    ty_to_str(self.infcx.tcx, rty),\n                    ty_to_str(self.infcx.tcx, rty),\n                    self.modes);\n@@ -137,7 +137,7 @@ impl ResolveState {\n     }\n \n     pub fn resolve_type(&mut self, typ: ty::t) -> ty::t {\n-        debug!(\"resolve_type(%s)\", typ.inf_str(self.infcx));\n+        debug2!(\"resolve_type({})\", typ.inf_str(self.infcx));\n         let _i = indenter();\n \n         if !ty::type_needs_infer(typ) {\n@@ -179,7 +179,7 @@ impl ResolveState {\n     }\n \n     pub fn resolve_region(&mut self, orig: ty::Region) -> ty::Region {\n-        debug!(\"Resolve_region(%s)\", orig.inf_str(self.infcx));\n+        debug2!(\"Resolve_region({})\", orig.inf_str(self.infcx));\n         match orig {\n           ty::re_infer(ty::ReVar(rid)) => self.resolve_region_var(rid),\n           _ => orig"}, {"sha": "ad251a5be9e9597a7946269635f31bc531f478bb", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -56,7 +56,7 @@ impl Combine for Sub {\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        debug!(\"%s.regions(%s, %s)\",\n+        debug2!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -65,7 +65,7 @@ impl Combine for Sub {\n     }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n-        debug!(\"mts(%s <: %s)\", a.inf_str(self.infcx), b.inf_str(self.infcx));\n+        debug2!(\"mts({} <: {})\", a.inf_str(self.infcx), b.inf_str(self.infcx));\n \n         if a.mutbl != b.mutbl {\n             return Err(ty::terr_mutability);\n@@ -110,7 +110,7 @@ impl Combine for Sub {\n     }\n \n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        debug!(\"%s.tys(%s, %s)\", self.tag(),\n+        debug2!(\"{}.tys({}, {})\", self.tag(),\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n         if a == b { return Ok(a); }\n         let _indenter = indenter();\n@@ -143,7 +143,7 @@ impl Combine for Sub {\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n-        debug!(\"fn_sigs(a=%s, b=%s)\",\n+        debug2!(\"fn_sigs(a={}, b={})\",\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n         let _indenter = indenter();\n \n@@ -172,15 +172,15 @@ impl Combine for Sub {\n             do replace_bound_regions_in_fn_sig(self.infcx.tcx, @Nil,\n                                               None, b) |br| {\n                 let skol = self.infcx.region_vars.new_skolemized(br);\n-                debug!(\"Bound region %s skolemized to %?\",\n+                debug2!(\"Bound region {} skolemized to {:?}\",\n                        bound_region_to_str(self.infcx.tcx, \"\", false, br),\n                        skol);\n                 skol\n             }\n         };\n \n-        debug!(\"a_sig=%s\", a_sig.inf_str(self.infcx));\n-        debug!(\"b_sig=%s\", b_sig.inf_str(self.infcx));\n+        debug2!(\"a_sig={}\", a_sig.inf_str(self.infcx));\n+        debug2!(\"b_sig={}\", b_sig.inf_str(self.infcx));\n \n         // Compare types now that bound regions have been replaced.\n         let sig = if_ok!(super_fn_sigs(self, &a_sig, &b_sig));"}, {"sha": "8792a068671d381a1b0b26dd0cd4fde944bc75d7", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -100,7 +100,7 @@ impl Env {\n         return match search_mod(self, &self.crate.node.module, 0, names) {\n             Some(id) => id,\n             None => {\n-                fail!(\"No item found: `%s`\", names.connect(\"::\"));\n+                fail2!(\"No item found: `%s`\", names.connect(\"::\"));\n             }\n         };\n \n@@ -153,15 +153,15 @@ impl Env {\n \n     pub fn assert_subtype(&self, a: ty::t, b: ty::t) {\n         if !self.is_subtype(a, b) {\n-            fail!(\"%s is not a subtype of %s, but it should be\",\n+            fail2!(\"%s is not a subtype of %s, but it should be\",\n                   self.ty_to_str(a),\n                   self.ty_to_str(b));\n         }\n     }\n \n     pub fn assert_not_subtype(&self, a: ty::t, b: ty::t) {\n         if self.is_subtype(a, b) {\n-            fail!(\"%s is a subtype of %s, but it shouldn't be\",\n+            fail2!(\"%s is a subtype of %s, but it shouldn't be\",\n                   self.ty_to_str(a),\n                   self.ty_to_str(b));\n         }\n@@ -223,14 +223,14 @@ impl Env {\n     pub fn glb() -> Glb { Glb(self.infcx.combine_fields(true, dummy_sp())) }\n \n     pub fn resolve_regions(exp_count: uint) {\n-        debug!(\"resolve_regions(%u)\", exp_count);\n+        debug2!(\"resolve_regions(%u)\", exp_count);\n \n         self.infcx.resolve_regions();\n         if self.err_messages.len() != exp_count {\n             for msg in self.err_messages.iter() {\n-                debug!(\"Error encountered: %s\", *msg);\n+                debug2!(\"Error encountered: %s\", *msg);\n             }\n-            fmt!(\"Resolving regions encountered %u errors but expected %u!\",\n+            format!(\"Resolving regions encountered %u errors but expected %u!\",\n                  self.err_messages.len(),\n                  exp_count);\n         }\n@@ -240,7 +240,7 @@ impl Env {\n     pub fn check_lub(&self, t1: ty::t, t2: ty::t, t_lub: ty::t) {\n         match self.lub().tys(t1, t2) {\n             Err(e) => {\n-                fail!(\"Unexpected error computing LUB: %?\", e)\n+                fail2!(\"Unexpected error computing LUB: %?\", e)\n             }\n             Ok(t) => {\n                 self.assert_eq(t, t_lub);\n@@ -256,13 +256,13 @@ impl Env {\n \n     /// Checks that `GLB(t1,t2) == t_glb`\n     pub fn check_glb(&self, t1: ty::t, t2: ty::t, t_glb: ty::t) {\n-        debug!(\"check_glb(t1=%s, t2=%s, t_glb=%s)\",\n+        debug2!(\"check_glb(t1=%s, t2=%s, t_glb=%s)\",\n                self.ty_to_str(t1),\n                self.ty_to_str(t2),\n                self.ty_to_str(t_glb));\n         match self.glb().tys(t1, t2) {\n             Err(e) => {\n-                fail!(\"Unexpected error computing LUB: %?\", e)\n+                fail2!(\"Unexpected error computing LUB: %?\", e)\n             }\n             Ok(t) => {\n                 self.assert_eq(t, t_glb);\n@@ -281,7 +281,7 @@ impl Env {\n         match self.lub().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n-                fail!(\"Unexpected success computing LUB: %?\", self.ty_to_str(t))\n+                fail2!(\"Unexpected success computing LUB: %?\", self.ty_to_str(t))\n             }\n         }\n     }\n@@ -291,7 +291,7 @@ impl Env {\n         match self.glb().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n-                fail!(\"Unexpected success computing GLB: %?\", self.ty_to_str(t))\n+                fail2!(\"Unexpected success computing GLB: %?\", self.ty_to_str(t))\n             }\n         }\n     }"}, {"sha": "2bb7a994593d7d45f3ff644778a8c9208eacffbd", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -31,7 +31,7 @@ impl InferStr for ty::t {\n \n impl InferStr for FnSig {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n-        fmt!(\"(%s) -> %s\",\n+        format!(\"({}) -> {}\",\n              self.inputs.map(|a| a.inf_str(cx)).connect(\", \"),\n              self.output.inf_str(cx))\n     }\n@@ -45,7 +45,7 @@ impl InferStr for ty::mt {\n \n impl InferStr for ty::Region {\n     fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n-        fmt!(\"%?\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n@@ -60,7 +60,7 @@ impl<V:InferStr> InferStr for Bound<V> {\n \n impl<T:InferStr> InferStr for Bounds<T> {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n-        fmt!(\"{%s <: %s}\",\n+        format!(\"\\\\{{} <: {}\\\\}\",\n              self.lb.inf_str(cx),\n              self.ub.inf_str(cx))\n     }\n@@ -69,8 +69,8 @@ impl<T:InferStr> InferStr for Bounds<T> {\n impl<V:Vid + ToStr,T:InferStr> InferStr for VarValue<V, T> {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         match *self {\n-          Redirect(ref vid) => fmt!(\"Redirect(%s)\", vid.to_str()),\n-          Root(ref pt, rk) => fmt!(\"Root(%s, %s)\", pt.inf_str(cx),\n+          Redirect(ref vid) => format!(\"Redirect({})\", vid.to_str()),\n+          Root(ref pt, rk) => format!(\"Root({}, {})\", pt.inf_str(cx),\n                                rk.to_str_radix(10u))\n         }\n     }"}, {"sha": "c05306a27be429fddbc1007e4328da3372c2995a", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -85,8 +85,8 @@ impl UnifyInferCtxtMethods for InferCtxt {\n             let var_val = match vb.vals.find(&vid_u) {\n                 Some(&ref var_val) => (*var_val).clone(),\n                 None => {\n-                    tcx.sess.bug(fmt!(\n-                        \"failed lookup of vid `%u`\", vid_u));\n+                    tcx.sess.bug(format!(\n+                        \"failed lookup of vid `{}`\", vid_u));\n                 }\n             };\n             match var_val {\n@@ -116,7 +116,7 @@ impl UnifyInferCtxtMethods for InferCtxt {\n          * Sets the value for `vid` to `new_v`.  `vid` MUST be a root node!\n          */\n \n-        debug!(\"Updating variable %s to %s\",\n+        debug2!(\"Updating variable {} to {}\",\n                vid.to_str(), new_v.inf_str(self));\n \n         let vb = UnifyVid::appropriate_vals_and_bindings(self);\n@@ -134,8 +134,8 @@ impl UnifyInferCtxtMethods for InferCtxt {\n         // Rank optimization: if you don't know what it is, check\n         // out <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n \n-        debug!(\"unify(node_a(id=%?, rank=%?), \\\n-                node_b(id=%?, rank=%?))\",\n+        debug2!(\"unify(node_a(id={:?}, rank={:?}), \\\n+                node_b(id={:?}, rank={:?}))\",\n                node_a.root, node_a.rank,\n                node_b.root, node_b.rank);\n "}, {"sha": "5db706765e9b8f660bd6d95c93c32ff9a4aa94d3", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -178,15 +178,15 @@ impl Repr for vtable_origin {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n-                fmt!(\"vtable_static(%?:%s, %s, %s)\",\n+                format!(\"vtable_static({:?}:{}, {}, {})\",\n                      def_id,\n                      ty::item_path_str(tcx, def_id),\n                      tys.repr(tcx),\n                      vtable_res.repr(tcx))\n             }\n \n             vtable_param(x, y) => {\n-                fmt!(\"vtable_param(%?, %?)\", x, y)\n+                format!(\"vtable_param({:?}, {:?})\", x, y)\n             }\n         }\n     }\n@@ -208,7 +208,7 @@ pub struct impl_res {\n \n impl Repr for impl_res {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n-        fmt!(\"impl_res {trait_vtables=%s, self_vtables=%s}\",\n+        format!(\"impl_res \\\\{trait_vtables={}, self_vtables={}\\\\}\",\n              self.trait_vtables.repr(tcx),\n              self.self_vtables.repr(tcx))\n     }\n@@ -226,15 +226,15 @@ pub struct CrateCtxt {\n \n // Functions that write types into the node type table\n pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n-    debug!(\"write_ty_to_tcx(%d, %s)\", node_id, ppaux::ty_to_str(tcx, ty));\n+    debug2!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_str(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n     tcx.node_types.insert(node_id as uint, ty);\n }\n pub fn write_substs_to_tcx(tcx: ty::ctxt,\n                            node_id: ast::NodeId,\n                            substs: ~[ty::t]) {\n     if substs.len() > 0u {\n-        debug!(\"write_substs_to_tcx(%d, %?)\", node_id,\n+        debug2!(\"write_substs_to_tcx({}, {:?})\", node_id,\n                substs.map(|t| ppaux::ty_to_str(tcx, *t)));\n         assert!(substs.iter().all(|t| !ty::type_needs_infer(*t)));\n         tcx.node_type_substs.insert(node_id, substs);\n@@ -361,12 +361,12 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             });\n \n             require_same_types(tcx, None, false, main_span, main_t, se_ty,\n-                || fmt!(\"main function expects type: `%s`\",\n+                || format!(\"main function expects type: `{}`\",\n                         ppaux::ty_to_str(ccx.tcx, se_ty)));\n         }\n         _ => {\n             tcx.sess.span_bug(main_span,\n-                              fmt!(\"main has a non-function type: found `%s`\",\n+                              format!(\"main has a non-function type: found `{}`\",\n                                    ppaux::ty_to_str(tcx, main_t)));\n         }\n     }\n@@ -409,12 +409,12 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             });\n \n             require_same_types(tcx, None, false, start_span, start_t, se_ty,\n-                || fmt!(\"start function expects type: `%s`\", ppaux::ty_to_str(ccx.tcx, se_ty)));\n+                || format!(\"start function expects type: `{}`\", ppaux::ty_to_str(ccx.tcx, se_ty)));\n \n         }\n         _ => {\n             tcx.sess.span_bug(start_span,\n-                              fmt!(\"start has a non-function type: found `%s`\",\n+                              format!(\"start has a non-function type: found `{}`\",\n                                    ppaux::ty_to_str(tcx, start_t)));\n         }\n     }"}, {"sha": "f6483a48ed00dfad377b9c2b6c53405e07d4c481", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -235,7 +235,7 @@ impl RegionScope for TypeRscope {\n             None => {\n                 // if the self region is used, region parameterization should\n                 // have inferred that this type is RP\n-                fail!(\"region parameterization should have inferred that \\\n+                fail2!(\"region parameterization should have inferred that \\\n                         this type is RP\");\n             }\n             Some(ref region_parameterization) => {"}, {"sha": "a7065624395663a16c1a2fea3f755db19375d916", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -135,7 +135,7 @@ pub fn version(argv0: &str) {\n }\n \n pub fn usage(argv0: &str) {\n-    let message = fmt!(\"Usage: %s [OPTIONS] INPUT\", argv0);\n+    let message = format!(\"Usage: {} [OPTIONS] INPUT\", argv0);\n     println!(\"{}\\n\\\n Additional help:\n     -W help             Print 'lint' options and default settings\n@@ -388,7 +388,7 @@ pub fn monitor(f: ~fn(@diagnostic::Emitter)) {\n                 }\n             }\n             // Fail so the process returns a failure code\n-            fail!();\n+            fail2!();\n         }\n     }\n }"}, {"sha": "5058be7c16623daf3d2a058aeaf2ebe60ee6871a", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -29,9 +29,9 @@ pub fn time<T, U>(do_it: bool, what: ~str, u: U, f: &fn(U) -> T) -> T {\n pub fn indent<R>(op: &fn() -> R) -> R {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`\n     // to make debug output more readable.\n-    debug!(\">>\");\n+    debug2!(\">>\");\n     let r = op();\n-    debug!(\"<< (Result = %?)\", r);\n+    debug2!(\"<< (Result = {:?})\", r);\n     r\n }\n \n@@ -40,7 +40,7 @@ pub struct _indenter {\n }\n \n impl Drop for _indenter {\n-    fn drop(&mut self) { debug!(\"<<\"); }\n+    fn drop(&mut self) { debug2!(\"<<\"); }\n }\n \n pub fn _indenter(_i: ()) -> _indenter {\n@@ -50,7 +50,7 @@ pub fn _indenter(_i: ()) -> _indenter {\n }\n \n pub fn indenter() -> _indenter {\n-    debug!(\">>\");\n+    debug2!(\">>\");\n     _indenter(())\n }\n \n@@ -120,7 +120,7 @@ pub fn local_rhs_span(l: @ast::Local, def: Span) -> Span {\n \n pub fn pluralize(n: uint, s: ~str) -> ~str {\n     if n == 1 { s }\n-    else { fmt!(\"%ss\", s) }\n+    else { format!(\"{}s\", s) }\n }\n \n // A set of node IDs (used to keep track of which node IDs are for statements)"}, {"sha": "bbca28f134f8daedfef47b6aff0176e51db3adc9", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80558be38226eb50e6f6d574d7f6ae7e727346/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1b80558be38226eb50e6f6d574d7f6ae7e727346", "patch": "@@ -51,11 +51,11 @@ pub fn note_and_explain_region(cx: ctxt,\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n             span,\n-            fmt!(\"%s%s%s\", prefix, (*str), suffix));\n+            format!(\"{}{}{}\", prefix, (*str), suffix));\n       }\n       (ref str, None) => {\n         cx.sess.note(\n-            fmt!(\"%s%s%s\", prefix, (*str), suffix));\n+            format!(\"{}{}{}\", prefix, (*str), suffix));\n       }\n     }\n }\n@@ -98,29 +98,29 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n           }\n           Some(_) | None => {\n             // this really should not happen\n-            (fmt!(\"unknown scope: %d.  Please report a bug.\", node_id),\n+            (format!(\"unknown scope: {}.  Please report a bug.\", node_id),\n              None)\n           }\n         }\n       }\n \n       re_free(ref fr) => {\n         let prefix = match fr.bound_region {\n-          br_anon(idx) => fmt!(\"the anonymous lifetime #%u defined on\",\n+          br_anon(idx) => format!(\"the anonymous lifetime \\\\#{} defined on\",\n                                idx + 1),\n-          br_fresh(_) => fmt!(\"an anonymous lifetime defined on\"),\n-          _ => fmt!(\"the lifetime %s as defined on\",\n+          br_fresh(_) => format!(\"an anonymous lifetime defined on\"),\n+          _ => format!(\"the lifetime {} as defined on\",\n                     bound_region_ptr_to_str(cx, fr.bound_region))\n         };\n \n         match cx.items.find(&fr.scope_id) {\n           Some(&ast_map::node_block(ref blk)) => {\n             let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n-            (fmt!(\"%s %s\", prefix, msg), opt_span)\n+            (format!(\"{} {}\", prefix, msg), opt_span)\n           }\n           Some(_) | None => {\n             // this really should not happen\n-            (fmt!(\"%s node %d\", prefix, fr.scope_id), None)\n+            (format!(\"{} node {}\", prefix, fr.scope_id), None)\n           }\n         }\n       }\n@@ -132,15 +132,15 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n       re_infer(_) | re_bound(_) => {\n-        (fmt!(\"lifetime %?\", region), None)\n+        (format!(\"lifetime {:?}\", region), None)\n       }\n     };\n \n     fn explain_span(cx: ctxt, heading: &str, span: Span)\n         -> (~str, Option<Span>)\n     {\n         let lo = cx.sess.codemap.lookup_char_pos_adj(span.lo);\n-        (fmt!(\"the %s at %u:%u\", heading,\n+        (format!(\"the {} at {}:{}\", heading,\n               lo.line, lo.col.to_uint()), Some(span))\n     }\n }\n@@ -154,11 +154,11 @@ pub fn bound_region_to_str(cx: ctxt,\n                            br: bound_region) -> ~str {\n     let space_str = if space { \" \" } else { \"\" };\n \n-    if cx.sess.verbose() { return fmt!(\"%s%?%s\", prefix, br, space_str); }\n+    if cx.sess.verbose() { return format!(\"{}{:?}{}\", prefix, br, space_str); }\n \n     match br {\n-      br_named(id)         => fmt!(\"%s'%s%s\", prefix, cx.sess.str_of(id), space_str),\n-      br_self              => fmt!(\"%s'self%s\", prefix, space_str),\n+      br_named(id)         => format!(\"{}'{}{}\", prefix, cx.sess.str_of(id), space_str),\n+      br_self              => format!(\"{}'self{}\", prefix, space_str),\n       br_anon(_)           => prefix.to_str(),\n       br_fresh(_)          => prefix.to_str(),\n       br_cap_avoid(_, br)  => bound_region_to_str(cx, prefix, space, *br)\n@@ -168,37 +168,37 @@ pub fn bound_region_to_str(cx: ctxt,\n pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n     match cx.items.find(&node_id) {\n       Some(&ast_map::node_block(ref blk)) => {\n-        fmt!(\"<block at %s>\",\n+        format!(\"<block at {}>\",\n              cx.sess.codemap.span_to_str(blk.span))\n       }\n       Some(&ast_map::node_expr(expr)) => {\n         match expr.node {\n           ast::ExprCall(*) => {\n-            fmt!(\"<call at %s>\",\n+            format!(\"<call at {}>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n           ast::ExprMatch(*) => {\n-            fmt!(\"<match at %s>\",\n+            format!(\"<match at {}>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n           ast::ExprAssignOp(*) |\n           ast::ExprUnary(*) |\n           ast::ExprBinary(*) |\n           ast::ExprIndex(*) => {\n-            fmt!(\"<method at %s>\",\n+            format!(\"<method at {}>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n           _ => {\n-            fmt!(\"<expression at %s>\",\n+            format!(\"<expression at {}>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n         }\n       }\n       None => {\n-        fmt!(\"<unknown-%d>\", node_id)\n+        format!(\"<unknown-{}>\", node_id)\n       }\n       _ => { cx.sess.bug(\n-          fmt!(\"re_scope refers to %s\",\n+          format!(\"re_scope refers to {}\",\n                ast_map::node_id_to_str(cx.items, node_id,\n                                        token::get_ident_interner()))) }\n     }\n@@ -215,7 +215,7 @@ pub fn region_to_str(cx: ctxt, prefix: &str, space: bool, region: Region) -> ~st\n     let space_str = if space { \" \" } else { \"\" };\n \n     if cx.sess.verbose() {\n-        return fmt!(\"%s%?%s\", prefix, region, space_str);\n+        return format!(\"{}{:?}{}\", prefix, region, space_str);\n     }\n \n     // These printouts are concise.  They do not contain all the information\n@@ -230,8 +230,8 @@ pub fn region_to_str(cx: ctxt, prefix: &str, space: bool, region: Region) -> ~st\n             bound_region_to_str(cx, prefix, space, br)\n         }\n         re_infer(ReVar(_)) => prefix.to_str(),\n-        re_static => fmt!(\"%s'static%s\", prefix, space_str),\n-        re_empty => fmt!(\"%s'<empty>%s\", prefix, space_str)\n+        re_static => format!(\"{}'static{}\", prefix, space_str),\n+        re_empty => format!(\"{}'<empty>{}\", prefix, space_str)\n     }\n }\n \n@@ -248,12 +248,12 @@ pub fn mt_to_str(cx: ctxt, m: &mt) -> ~str {\n \n pub fn mt_to_str_wrapped(cx: ctxt, before: &str, m: &mt, after: &str) -> ~str {\n     let mstr = mutability_to_str(m.mutbl);\n-    return fmt!(\"%s%s%s%s\", mstr, before, ty_to_str(cx, m.ty), after);\n+    return format!(\"{}{}{}{}\", mstr, before, ty_to_str(cx, m.ty), after);\n }\n \n pub fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n     match vs {\n-      ty::vstore_fixed(n) => fmt!(\"%u\", n),\n+      ty::vstore_fixed(n) => format!(\"{}\", n),\n       ty::vstore_uniq => ~\"~\",\n       ty::vstore_box => ~\"@\",\n       ty::vstore_slice(r) => region_ptr_to_str(cx, r)\n@@ -271,25 +271,25 @@ pub fn trait_store_to_str(cx: ctxt, s: ty::TraitStore) -> ~str {\n pub fn vstore_ty_to_str(cx: ctxt, mt: &mt, vs: ty::vstore) -> ~str {\n     match vs {\n         ty::vstore_fixed(_) => {\n-            fmt!(\"[%s, .. %s]\", mt_to_str(cx, mt), vstore_to_str(cx, vs))\n+            format!(\"[{}, .. {}]\", mt_to_str(cx, mt), vstore_to_str(cx, vs))\n         }\n         _ => {\n-            fmt!(\"%s%s\", vstore_to_str(cx, vs), mt_to_str_wrapped(cx, \"[\", mt, \"]\"))\n+            format!(\"{}{}\", vstore_to_str(cx, vs), mt_to_str_wrapped(cx, \"[\", mt, \"]\"))\n         }\n     }\n }\n \n pub fn vec_map_to_str<T>(ts: &[T], f: &fn(t: &T) -> ~str) -> ~str {\n     let tstrs = ts.map(f);\n-    fmt!(\"[%s]\", tstrs.connect(\", \"))\n+    format!(\"[{}]\", tstrs.connect(\", \"))\n }\n \n pub fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n     vec_map_to_str(ts, |t| ty_to_str(cx, *t))\n }\n \n pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n-    fmt!(\"fn%s -> %s\",\n+    format!(\"fn{} -> {}\",\n          tys_to_str(cx, typ.inputs.map(|a| *a)),\n          ty_to_str(cx, typ.output))\n }\n@@ -397,7 +397,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                        &m.fty.sig) + \";\"\n     }\n     fn field_to_str(cx: ctxt, f: field) -> ~str {\n-        return fmt!(\"%s: %s\", cx.sess.str_of(f.ident), mt_to_str(cx, &f.mt));\n+        return format!(\"{}: {}\", cx.sess.str_of(f.ident), mt_to_str(cx, &f.mt));\n     }\n \n     // if there is an id, print that instead of the structural type:\n@@ -425,7 +425,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_rptr(r, ref tm) => {\n         region_ptr_to_str(cx, r) + mt_to_str(cx, tm)\n       }\n-      ty_unboxed_vec(ref tm) => { fmt!(\"unboxed_vec<%s>\", mt_to_str(cx, tm)) }\n+      ty_unboxed_vec(ref tm) => { format!(\"unboxed_vec<{}>\", mt_to_str(cx, tm)) }\n       ty_type => ~\"type\",\n       ty_tup(ref elems) => {\n         let strs = elems.map(|elem| ty_to_str(cx, *elem));\n@@ -447,10 +447,10 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n               }\n               None => {\n                   // This should not happen...\n-                  fmt!(\"BUG[%?]\", id)\n+                  format!(\"BUG[{:?}]\", id)\n               }\n           };\n-          if !cx.sess.verbose() { ident } else { fmt!(\"%s:%?\", ident, did) }\n+          if !cx.sess.verbose() { ident } else { format!(\"{}:{:?}\", ident, did) }\n       }\n       ty_self(*) => ~\"Self\",\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n@@ -464,13 +464,13 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         let ty = parameterized(cx, base, &substs.regions, substs.tps);\n         let bound_sep = if bounds.is_empty() { \"\" } else { \":\" };\n         let bound_str = bounds.repr(cx);\n-        fmt!(\"%s%s%s%s%s\", trait_store_to_str(cx, s), mutability_to_str(mutbl), ty,\n+        format!(\"{}{}{}{}{}\", trait_store_to_str(cx, s), mutability_to_str(mutbl), ty,\n                            bound_sep, bound_str)\n       }\n       ty_evec(ref mt, vs) => {\n         vstore_ty_to_str(cx, mt, vs)\n       }\n-      ty_estr(vs) => fmt!(\"%s%s\", vstore_to_str(cx, vs), \"str\"),\n+      ty_estr(vs) => format!(\"{}{}\", vstore_to_str(cx, vs), \"str\"),\n       ty_opaque_box => ~\"@?\",\n       ty_opaque_closure_ptr(ast::BorrowedSigil) => ~\"&closure\",\n       ty_opaque_closure_ptr(ast::ManagedSigil) => ~\"@closure\",\n@@ -498,9 +498,9 @@ pub fn parameterized(cx: ctxt,\n     }\n \n     if strs.len() > 0u {\n-        fmt!(\"%s<%s>\", base, strs.connect(\",\"))\n+        format!(\"{}<{}>\", base, strs.connect(\",\"))\n     } else {\n-        fmt!(\"%s\", base)\n+        format!(\"{}\", base)\n     }\n }\n \n@@ -514,7 +514,7 @@ impl<T:Repr> Repr for Option<T> {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match self {\n             &None => ~\"None\",\n-            &Some(ref t) => fmt!(\"Some(%s)\", t.repr(tcx))\n+            &Some(ref t) => format!(\"Some({})\", t.repr(tcx))\n         }\n     }\n }\n@@ -560,7 +560,7 @@ impl<T:Repr> Repr for ~[T] {\n \n impl Repr for ty::TypeParameterDef {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"TypeParameterDef {%?, bounds: %s}\",\n+        format!(\"TypeParameterDef \\\\{{:?}, bounds: {}\\\\}\",\n              self.def_id, self.bounds.repr(tcx))\n     }\n }\n@@ -573,7 +573,7 @@ impl Repr for ty::t {\n \n impl Repr for ty::substs {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"substs(regions=%s, self_ty=%s, tps=%s)\",\n+        format!(\"substs(regions={}, self_ty={}, tps={})\",\n              self.regions.repr(tcx),\n              self.self_ty.repr(tcx),\n              self.tps.repr(tcx))\n@@ -615,15 +615,15 @@ impl Repr for ty::TraitRef {\n \n impl Repr for ast::Expr {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"expr(%d: %s)\",\n+        format!(\"expr({}: {})\",\n              self.id,\n              pprust::expr_to_str(self, tcx.sess.intr()))\n     }\n }\n \n impl Repr for ast::Pat {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"pat(%d: %s)\",\n+        format!(\"pat({}: {})\",\n              self.id,\n              pprust::pat_to_str(self, tcx.sess.intr()))\n     }\n@@ -654,35 +654,35 @@ impl Repr for ast::DefId {\n                 Some(&ast_map::node_trait_method(*)) |\n                 Some(&ast_map::node_variant(*)) |\n                 Some(&ast_map::node_struct_ctor(*)) => {\n-                    return fmt!(\"%?:%s\", *self, ty::item_path_str(tcx, *self));\n+                    return format!(\"{:?}:{}\", *self, ty::item_path_str(tcx, *self));\n                 }\n                 _ => {}\n             }\n         }\n-        return fmt!(\"%?\", *self);\n+        return format!(\"{:?}\", *self);\n     }\n }\n \n impl Repr for ty::ty_param_bounds_and_ty {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"ty_param_bounds_and_ty {generics: %s, ty: %s}\",\n+        format!(\"ty_param_bounds_and_ty \\\\{generics: {}, ty: {}\\\\}\",\n              self.generics.repr(tcx),\n              self.ty.repr(tcx))\n     }\n }\n \n impl Repr for ty::Generics {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"Generics {type_param_defs: %s, region_param: %?}\",\n+        format!(\"Generics \\\\{type_param_defs: {}, region_param: {:?}\\\\}\",\n              self.type_param_defs.repr(tcx),\n              self.region_param)\n     }\n }\n \n impl Repr for ty::Method {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"method {ident: %s, generics: %s, transformed_self_ty: %s, \\\n-              fty: %s, explicit_self: %s, vis: %s, def_id: %s}\",\n+        format!(\"method \\\\{ident: {}, generics: {}, transformed_self_ty: {}, \\\n+              fty: {}, explicit_self: {}, vis: {}, def_id: {}\\\\}\",\n              self.ident.repr(tcx),\n              self.generics.repr(tcx),\n              self.transformed_self_ty.repr(tcx),\n@@ -701,19 +701,19 @@ impl Repr for ast::Ident {\n \n impl Repr for ast::explicit_self_ {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n-        fmt!(\"%?\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ast::visibility {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n-        fmt!(\"%?\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::BareFnTy {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"BareFnTy {purity: %?, abis: %s, sig: %s}\",\n+        format!(\"BareFnTy \\\\{purity: {:?}, abis: {}, sig: {}\\\\}\",\n              self.purity,\n              self.abis.to_str(),\n              self.sig.repr(tcx))\n@@ -728,9 +728,9 @@ impl Repr for ty::FnSig {\n \n impl Repr for typeck::method_map_entry {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"method_map_entry {self_arg: %s, \\\n-              explicit_self: %s, \\\n-              origin: %s}\",\n+        format!(\"method_map_entry \\\\{self_arg: {}, \\\n+              explicit_self: {}, \\\n+              origin: {}\\\\}\",\n              self.self_ty.repr(tcx),\n              self.explicit_self.repr(tcx),\n              self.origin.repr(tcx))\n@@ -741,7 +741,7 @@ impl Repr for typeck::method_origin {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match self {\n             &typeck::method_static(def_id) => {\n-                fmt!(\"method_static(%s)\", def_id.repr(tcx))\n+                format!(\"method_static({})\", def_id.repr(tcx))\n             }\n             &typeck::method_param(ref p) => {\n                 p.repr(tcx)\n@@ -755,7 +755,7 @@ impl Repr for typeck::method_origin {\n \n impl Repr for typeck::method_param {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"method_param(%s,%?,%?,%?)\",\n+        format!(\"method_param({},{:?},{:?},{:?})\",\n              self.trait_id.repr(tcx),\n              self.method_num,\n              self.param_num,\n@@ -765,7 +765,7 @@ impl Repr for typeck::method_param {\n \n impl Repr for typeck::method_object {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"method_object(%s,%?,%?)\",\n+        format!(\"method_object({},{:?},{:?})\",\n              self.trait_id.repr(tcx),\n              self.method_num,\n              self.real_index)\n@@ -775,7 +775,7 @@ impl Repr for typeck::method_object {\n \n impl Repr for ty::RegionVid {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n-        fmt!(\"%?\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n \n@@ -784,7 +784,7 @@ impl Repr for ty::TraitStore {\n         match self {\n             &ty::BoxTraitStore => ~\"@Trait\",\n             &ty::UniqTraitStore => ~\"~Trait\",\n-            &ty::RegionTraitStore(r) => fmt!(\"&%s Trait\", r.repr(tcx))\n+            &ty::RegionTraitStore(r) => format!(\"&{} Trait\", r.repr(tcx))\n         }\n     }\n }\n@@ -807,7 +807,7 @@ impl Repr for ast_map::path_elt {\n \n impl Repr for ty::BuiltinBound {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n-        fmt!(\"%?\", *self)\n+        format!(\"{:?}\", *self)\n     }\n }\n "}]}