{"sha": "190802cfca41df76fd7ef45d2915c89938a5904a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MDgwMmNmY2E0MWRmNzZmZDdlZjQ1ZDI5MTVjODk5MzhhNTkwNGE=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-10-20T20:09:36Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-10-22T13:33:30Z"}, "message": "Pattern match over PlaceRef rather than Place\n\nThis prepares the code base for when projection is interned. Place's\nprojection field is going to be `&List<PlaceElem<'tcx>>` so we won't be\nable to pattern match against it.", "tree": {"sha": "1c3348f5c02bf974be99a51a8b2c7a9f48b15a46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c3348f5c02bf974be99a51a8b2c7a9f48b15a46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/190802cfca41df76fd7ef45d2915c89938a5904a", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAl2vBSwACgkQiMlBzaHU\nZDLUvQ/+JoYoDSumEgvt0SfDaA295KymzbfLU8V/BRzdIfphGYyUkR7YsSmre/yr\nlh8eAI42zFf/dYRnHrZHz1uThVnV6IvPZ7TUDCgA5aZsGIJbj+0A8RnfxdBADv6O\nLrde6JlF1+ZR3oKEV/jDTvvWZXFCtr+O1uOvKsvzShMMTlxMwr5tffu4OmRF1BzK\n+ZbuC5xAOW2Y9ftuqxQNqtlylL3L3Jh9XKURnq3kL4Ge4DL56MiWf85t4ncdquMG\nT4O0RS3tAShxA90xPp8Wzv8JiFzGr4L+1NoQm8NW+HzNUuZVby44bD3/4yfeQsAc\noWQD4G3XTtbJr0s96Jq5kAhOpXTPYDn+TefmgSZe/vz0PBWUcge+CbJH8r5Zh4/v\npQRTBV3Ba8xmqmpRkiYYMn+FdTbfRNLVjEGeigZj8yENo8zmA3+Oup0k7xCfMFqT\ntyI61rTIpUSSA/o/Y4m/lSoZYKdc3CnAwZ8B4oj7zahkwEZIn0ICQKJMfTFArrTy\nhzOWifthCIaqj3cqaCjigBHH6WUzPssNIBo9+uDGT8dcLyVkKjZb5oRpzAJTBASl\nYJVQOAmbc5TTu9SKXAONkB5PZNrjBDNrRXTbeVTSC36rPnJ9APMVVAjDHmzClAQ5\nu9/mpV5qXqdI7bC/XICzM+MZmHV6uEJVuBp0rizCBfDTKwFQyRg=\n=mr8O\n-----END PGP SIGNATURE-----", "payload": "tree 1c3348f5c02bf974be99a51a8b2c7a9f48b15a46\nparent 270541221f25b761d6aeb0e1900d807755857774\nauthor Santiago Pastorino <spastorino@gmail.com> 1571602176 -0400\ncommitter Santiago Pastorino <spastorino@gmail.com> 1571751210 -0300\n\nPattern match over PlaceRef rather than Place\n\nThis prepares the code base for when projection is interned. Place's\nprojection field is going to be `&List<PlaceElem<'tcx>>` so we won't be\nable to pattern match against it.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/190802cfca41df76fd7ef45d2915c89938a5904a", "html_url": "https://github.com/rust-lang/rust/commit/190802cfca41df76fd7ef45d2915c89938a5904a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/190802cfca41df76fd7ef45d2915c89938a5904a/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "270541221f25b761d6aeb0e1900d807755857774", "url": "https://api.github.com/repos/rust-lang/rust/commits/270541221f25b761d6aeb0e1900d807755857774", "html_url": "https://github.com/rust-lang/rust/commit/270541221f25b761d6aeb0e1900d807755857774"}], "stats": {"total": 1527, "additions": 707, "deletions": 820}, "files": [{"sha": "6e509f51754176174a6af3e9667cfd88a042ff5f", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -1908,15 +1908,15 @@ impl<'tcx> Place<'tcx> {\n     //\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n-        match self {\n-            Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n+        match self.as_ref() {\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: &[],\n             } |\n-            Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [ProjectionElem::Deref],\n-            } => Some(*local),\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: &[ProjectionElem::Deref],\n+            } => Some(local),\n             _ => None,\n         }\n     }"}, {"sha": "604deffcf949bd7ffad5df2bc583f34ccb310f04", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -191,10 +191,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                     location: Location) {\n         debug!(\"visit_assign(place={:?}, rvalue={:?})\", place, rvalue);\n \n-        if let mir::Place {\n-            base: mir::PlaceBase::Local(index),\n-            projection: box [],\n-        } = *place {\n+        if let Some(index) = place.as_local() {\n             self.assign(index, location);\n             let decl_span = self.fx.mir.local_decls[index].source_info.span;\n             if !self.fx.rvalue_creates_operand(rvalue, decl_span) {"}, {"sha": "28441cae26e3fb3025bd085071b2374d05995690", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 34, "deletions": 50, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -2,7 +2,7 @@ use rustc_index::vec::Idx;\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable, Instance};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, FnTypeExt};\n-use rustc::mir::{self, Place, PlaceBase, Static, StaticKind};\n+use rustc::mir::{self, PlaceBase, Static, StaticKind};\n use rustc::mir::interpret::PanicInfo;\n use rustc_target::abi::call::{ArgType, FnType, PassMode};\n use rustc_target::spec::abi::Abi;\n@@ -630,53 +630,43 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // checked by const-qualification, which also\n                 // promotes any complex rvalues to constants.\n                 if i == 2 && intrinsic.unwrap().starts_with(\"simd_shuffle\") {\n-                    match *arg {\n+                    match arg {\n                         // The shuffle array argument is usually not an explicit constant,\n                         // but specified directly in the code. This means it gets promoted\n                         // and we can then extract the value by evaluating the promoted.\n-                        mir::Operand::Copy(\n-                            Place {\n-                                base: PlaceBase::Static(box Static {\n-                                    kind: StaticKind::Promoted(promoted, _),\n+                        mir::Operand::Copy(place) | mir::Operand::Move(place) => {\n+                            if let mir::PlaceRef {\n+                                base:\n+                                    &PlaceBase::Static(box Static {\n+                                        kind: StaticKind::Promoted(promoted, _),\n+                                        ty,\n+                                        def_id: _,\n+                                    }),\n+                                projection: &[],\n+                            } = place.as_ref()\n+                            {\n+                                let param_env = ty::ParamEnv::reveal_all();\n+                                let cid = mir::interpret::GlobalId {\n+                                    instance: self.instance,\n+                                    promoted: Some(promoted),\n+                                };\n+                                let c = bx.tcx().const_eval(param_env.and(cid));\n+                                let (llval, ty) = self.simd_shuffle_indices(\n+                                    &bx,\n+                                    terminator.source_info.span,\n                                     ty,\n-                                    def_id: _,\n-                                }),\n-                                projection: box [],\n+                                    c,\n+                                );\n+                                return OperandRef {\n+                                    val: Immediate(llval),\n+                                    layout: bx.layout_of(ty),\n+                                };\n+                            } else {\n+                                span_bug!(span, \"shuffle indices must be constant\");\n                             }\n-                        ) |\n-                        mir::Operand::Move(\n-                            Place {\n-                                base: PlaceBase::Static(box Static {\n-                                    kind: StaticKind::Promoted(promoted, _),\n-                                    ty,\n-                                    def_id: _,\n-                                }),\n-                                projection: box [],\n-                            }\n-                        ) => {\n-                            let param_env = ty::ParamEnv::reveal_all();\n-                            let cid = mir::interpret::GlobalId {\n-                                instance: self.instance,\n-                                promoted: Some(promoted),\n-                            };\n-                            let c = bx.tcx().const_eval(param_env.and(cid));\n-                            let (llval, ty) = self.simd_shuffle_indices(\n-                                &bx,\n-                                terminator.source_info.span,\n-                                ty,\n-                                c,\n-                            );\n-                            return OperandRef {\n-                                val: Immediate(llval),\n-                                layout: bx.layout_of(ty),\n-                            };\n-\n-                        }\n-                        mir::Operand::Copy(_) |\n-                        mir::Operand::Move(_) => {\n-                            span_bug!(span, \"shuffle indices must be constant\");\n                         }\n-                        mir::Operand::Constant(ref constant) => {\n+\n+                        mir::Operand::Constant(constant) => {\n                             let c = self.eval_mir_constant(constant);\n                             let (llval, ty) = self.simd_shuffle_indices(\n                                 &bx,\n@@ -1117,10 +1107,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n         }\n-        let dest = if let mir::Place {\n-            base: mir::PlaceBase::Local(index),\n-            projection: box [],\n-        } = *dest {\n+        let dest = if let Some(index) = dest.as_local() {\n             match self.locals[index] {\n                 LocalRef::Place(dest) => dest,\n                 LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n@@ -1178,10 +1165,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         src: &mir::Operand<'tcx>,\n         dst: &mir::Place<'tcx>\n     ) {\n-        if let mir::Place {\n-            base: mir::PlaceBase::Local(index),\n-            projection: box [],\n-        } = *dst {\n+        if let Some(index) = dst.as_local() {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n                 LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),"}, {"sha": "1608f222bc614f6de0606052719af0bc00427c05", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -530,10 +530,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Bx::Value {\n         // ZST are passed as operands and require special handling\n         // because codegen_place() panics if Local is operand.\n-        if let mir::Place {\n-            base: mir::PlaceBase::Local(index),\n-            projection: box [],\n-        } = *place {\n+        if let Some(index) = place.as_local() {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.kind {\n                     let n = n.eval_usize(bx.cx().tcx(), ty::ParamEnv::reveal_all());"}, {"sha": "43d5c2570b705e4f66cd4a68deec17679bd90c84", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -17,11 +17,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.set_debug_loc(&mut bx, statement.source_info);\n         match statement.kind {\n             mir::StatementKind::Assign(box(ref place, ref rvalue)) => {\n-                if let mir::Place {\n-                    base: mir::PlaceBase::Local(index),\n-                    projection: box [],\n-                } = place {\n-                    match self.locals[*index] {\n+                if let Some(index) = place.as_local() {\n+                    match self.locals[index] {\n                         LocalRef::Place(cg_dest) => {\n                             self.codegen_rvalue(bx, cg_dest, rvalue)\n                         }\n@@ -30,7 +27,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                         LocalRef::Operand(None) => {\n                             let (mut bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n-                            if let Some(name) = self.mir.local_decls[*index].name {\n+                            if let Some(name) = self.mir.local_decls[index].name {\n                                 match operand.val {\n                                     OperandValue::Ref(x, ..) |\n                                     OperandValue::Immediate(x) => {\n@@ -44,7 +41,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     }\n                                 }\n                             }\n-                            self.locals[*index] = LocalRef::Operand(Some(operand));\n+                            self.locals[index] = LocalRef::Operand(Some(operand));\n                             bx\n                         }\n                         LocalRef::Operand(Some(op)) => {"}, {"sha": "98641031c1787514ca2e461d5bf8b36f3cf5e588", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -315,10 +315,7 @@ impl<'a, 'tcx> GatherBorrows<'a, 'tcx> {\n         //    TEMP = &foo\n         //\n         // so extract `temp`.\n-        let temp = if let &mir::Place {\n-            base: mir::PlaceBase::Local(temp),\n-            projection: box [],\n-        } = assigned_place {\n+        let temp = if let Some(temp) = assigned_place.as_local() {\n             temp\n         } else {\n             span_bug!("}, {"sha": "9b7a5caa6d913b74cb6ba5361df671c7f7aa6d5d", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 147, "deletions": 166, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -239,11 +239,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         );\n                     }\n                 }\n-                let span = if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = place {\n-                    let decl = &self.body.local_decls[*local];\n+                let span = if let Some(local) = place.as_local() {\n+                    let decl = &self.body.local_decls[local];\n                     Some(decl.source_info.span)\n                 } else {\n                     None\n@@ -611,7 +608,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     projection,\n                 } = first_borrowed_place;\n \n-                let mut cursor = &**projection;\n+                let mut cursor = projection.as_ref();\n                 while let [proj_base @ .., elem] = cursor {\n                     cursor = proj_base;\n \n@@ -635,7 +632,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     projection,\n                 } = second_borrowed_place;\n \n-                let mut cursor = &**projection;\n+                let mut cursor = projection.as_ref();\n                 while let [proj_base @ .., elem] = cursor {\n                     cursor = proj_base;\n \n@@ -1124,26 +1121,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         let (place_desc, note) = if let Some(place_desc) = opt_place_desc {\n-            let local_kind = match borrow.borrowed_place {\n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } => {\n-                    match self.body.local_kind(local) {\n-                        LocalKind::ReturnPointer\n-                        | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n-                        LocalKind::Var => \"local variable \",\n-                        LocalKind::Arg\n-                        if !self.upvars.is_empty()\n-                            && local == Local::new(1) => {\n-                            \"variable captured by `move` \"\n-                        }\n-                        LocalKind::Arg => {\n-                            \"function parameter \"\n-                        }\n+            let local_kind = if let Some(local) = borrow.borrowed_place.as_local() {\n+                match self.body.local_kind(local) {\n+                    LocalKind::ReturnPointer\n+                    | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n+                    LocalKind::Var => \"local variable \",\n+                    LocalKind::Arg\n+                    if !self.upvars.is_empty()\n+                        && local == Local::new(1) => {\n+                        \"variable captured by `move` \"\n+                    }\n+                    LocalKind::Arg => {\n+                        \"function parameter \"\n                     }\n                 }\n-                _ => \"local data \",\n+            } else {\n+                \"local data \"\n             };\n             (\n                 format!(\"{}`{}`\", local_kind, place_desc),\n@@ -1480,10 +1473,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         assigned_span: Span,\n         err_place: &Place<'tcx>,\n     ) {\n-        let (from_arg, local_decl) = if let Place {\n-            base: PlaceBase::Local(local),\n-            projection: box [],\n-        } = *err_place {\n+        let (from_arg, local_decl) = if let Some(local) = err_place.as_local() {\n             if let LocalKind::Arg = self.body.local_kind(local) {\n                 (true, Some(&self.body.local_decls[local]))\n             } else {\n@@ -1643,11 +1633,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 reservation\n             );\n             // Check that the initial assignment of the reserve location is into a temporary.\n-            let mut target = *match reservation {\n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } if self.body.local_kind(*local) == LocalKind::Temp => local,\n+            let mut target = match reservation.as_local() {\n+                Some(local) if self.body.local_kind(local) == LocalKind::Temp => local,\n                 _ => return None,\n             };\n \n@@ -1659,127 +1646,122 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n                     target, stmt\n                 );\n-                if let StatementKind::Assign(\n-                    box(\n-                        Place {\n-                            base: PlaceBase::Local(assigned_to),\n-                            projection: box [],\n-                        },\n-                        rvalue\n-                    )\n-                ) = &stmt.kind {\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n-                         rvalue={:?}\",\n-                        assigned_to, rvalue\n-                    );\n-                    // Check if our `target` was captured by a closure.\n-                    if let Rvalue::Aggregate(\n-                        box AggregateKind::Closure(def_id, substs),\n-                        operands,\n-                    ) = rvalue\n-                    {\n-                        for operand in operands {\n-                            let assigned_from = match operand {\n-                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                if let StatementKind::Assign(box(place, rvalue)) = &stmt.kind {\n+                    if let Some(assigned_to) = place.as_local() {\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n+                             rvalue={:?}\",\n+                            assigned_to, rvalue\n+                        );\n+                        // Check if our `target` was captured by a closure.\n+                        if let Rvalue::Aggregate(\n+                            box AggregateKind::Closure(def_id, substs),\n+                            operands,\n+                        ) = rvalue\n+                        {\n+                            for operand in operands {\n+                                let assigned_from = match operand {\n+                                    Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                        assigned_from\n+                                    }\n+                                    _ => continue,\n+                                };\n+                                debug!(\n+                                    \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n                                     assigned_from\n-                                }\n-                                _ => continue,\n-                            };\n-                            debug!(\n-                                \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n-                                assigned_from\n-                            );\n-\n-                            // Find the local from the operand.\n-                            let assigned_from_local = match assigned_from.local_or_deref_local() {\n-                                Some(local) => local,\n-                                None => continue,\n-                            };\n+                                );\n \n-                            if assigned_from_local != target {\n-                                continue;\n-                            }\n+                                // Find the local from the operand.\n+                                let assigned_from_local = match assigned_from.local_or_deref_local()\n+                                {\n+                                    Some(local) => local,\n+                                    None => continue,\n+                                };\n \n-                            // If a closure captured our `target` and then assigned\n-                            // into a place then we should annotate the closure in\n-                            // case it ends up being assigned into the return place.\n-                            annotated_closure = self.annotate_fn_sig(\n-                                *def_id,\n-                                self.infcx.closure_sig(*def_id, *substs),\n-                            );\n-                            debug!(\n-                                \"annotate_argument_and_return_for_borrow: \\\n-                                 annotated_closure={:?} assigned_from_local={:?} \\\n-                                 assigned_to={:?}\",\n-                                annotated_closure, assigned_from_local, assigned_to\n-                            );\n+                                if assigned_from_local != target {\n+                                    continue;\n+                                }\n \n-                            if *assigned_to == mir::RETURN_PLACE {\n-                                // If it was assigned directly into the return place, then\n-                                // return now.\n-                                return annotated_closure;\n-                            } else {\n-                                // Otherwise, update the target.\n-                                target = *assigned_to;\n+                                // If a closure captured our `target` and then assigned\n+                                // into a place then we should annotate the closure in\n+                                // case it ends up being assigned into the return place.\n+                                annotated_closure = self.annotate_fn_sig(\n+                                    *def_id,\n+                                    self.infcx.closure_sig(*def_id, *substs),\n+                                );\n+                                debug!(\n+                                    \"annotate_argument_and_return_for_borrow: \\\n+                                     annotated_closure={:?} assigned_from_local={:?} \\\n+                                     assigned_to={:?}\",\n+                                    annotated_closure, assigned_from_local, assigned_to\n+                                );\n+\n+                                if assigned_to == mir::RETURN_PLACE {\n+                                    // If it was assigned directly into the return place, then\n+                                    // return now.\n+                                    return annotated_closure;\n+                                } else {\n+                                    // Otherwise, update the target.\n+                                    target = assigned_to;\n+                                }\n                             }\n-                        }\n \n-                        // If none of our closure's operands matched, then skip to the next\n-                        // statement.\n-                        continue;\n-                    }\n+                            // If none of our closure's operands matched, then skip to the next\n+                            // statement.\n+                            continue;\n+                        }\n \n-                    // Otherwise, look at other types of assignment.\n-                    let assigned_from = match rvalue {\n-                        Rvalue::Ref(_, _, assigned_from) => assigned_from,\n-                        Rvalue::Use(operand) => match operand {\n-                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                assigned_from\n-                            }\n+                        // Otherwise, look at other types of assignment.\n+                        let assigned_from = match rvalue {\n+                            Rvalue::Ref(_, _, assigned_from) => assigned_from,\n+                            Rvalue::Use(operand) => match operand {\n+                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                    assigned_from\n+                                }\n+                                _ => continue,\n+                            },\n                             _ => continue,\n-                        },\n-                        _ => continue,\n-                    };\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: \\\n-                         assigned_from={:?}\",\n-                        assigned_from,\n-                    );\n+                        };\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from={:?}\",\n+                            assigned_from,\n+                        );\n \n-                    // Find the local from the rvalue.\n-                    let assigned_from_local = match assigned_from.local_or_deref_local() {\n-                        Some(local) => local,\n-                        None => continue,\n-                    };\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: \\\n-                         assigned_from_local={:?}\",\n-                        assigned_from_local,\n-                    );\n+                        // Find the local from the rvalue.\n+                        let assigned_from_local = match assigned_from.local_or_deref_local() {\n+                            Some(local) => local,\n+                            None => continue,\n+                        };\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from_local={:?}\",\n+                            assigned_from_local,\n+                        );\n \n-                    // Check if our local matches the target - if so, we've assigned our\n-                    // borrow to a new place.\n-                    if assigned_from_local != target {\n-                        continue;\n-                    }\n+                        // Check if our local matches the target - if so, we've assigned our\n+                        // borrow to a new place.\n+                        if assigned_from_local != target {\n+                            continue;\n+                        }\n \n-                    // If we assigned our `target` into a new place, then we should\n-                    // check if it was the return place.\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: \\\n-                         assigned_from_local={:?} assigned_to={:?}\",\n-                        assigned_from_local, assigned_to\n-                    );\n-                    if *assigned_to == mir::RETURN_PLACE {\n-                        // If it was then return the annotated closure if there was one,\n-                        // else, annotate this function.\n-                        return annotated_closure.or_else(fallback);\n-                    }\n+                        // If we assigned our `target` into a new place, then we should\n+                        // check if it was the return place.\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from_local={:?} assigned_to={:?}\",\n+                            assigned_from_local, assigned_to\n+                        );\n+                        if assigned_to == mir::RETURN_PLACE {\n+                            // If it was then return the annotated closure if there was one,\n+                            // else, annotate this function.\n+                            return annotated_closure.or_else(fallback);\n+                        }\n \n-                    // If we didn't assign into the return place, then we just update\n-                    // the target.\n-                    target = *assigned_to;\n+                        // If we didn't assign into the return place, then we just update\n+                        // the target.\n+                        target = assigned_to;\n+                    }\n                 }\n             }\n \n@@ -1790,38 +1772,37 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 target, terminator\n             );\n             if let TerminatorKind::Call {\n-                destination: Some((Place {\n-                    base: PlaceBase::Local(assigned_to),\n-                    projection: box [],\n-                }, _)),\n+                destination: Some((place, _)),\n                 args,\n                 ..\n             } = &terminator.kind\n             {\n-                debug!(\n-                    \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n-                    assigned_to, args\n-                );\n-                for operand in args {\n-                    let assigned_from = match operand {\n-                        Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                            assigned_from\n-                        }\n-                        _ => continue,\n-                    };\n+                if let Some(assigned_to) = place.as_local() {\n                     debug!(\n-                        \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n-                        assigned_from,\n+                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n+                        assigned_to, args\n                     );\n-\n-                    if let Some(assigned_from_local) = assigned_from.local_or_deref_local() {\n+                    for operand in args {\n+                        let assigned_from = match operand {\n+                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                assigned_from\n+                            }\n+                            _ => continue,\n+                        };\n                         debug!(\n-                            \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n-                            assigned_from_local,\n+                            \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                            assigned_from,\n                         );\n \n-                        if *assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n-                            return annotated_closure.or_else(fallback);\n+                        if let Some(assigned_from_local) = assigned_from.local_or_deref_local() {\n+                            debug!(\n+                                \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n+                                assigned_from_local,\n+                            );\n+\n+                            if assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n+                                return annotated_closure.or_else(fallback);\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "4036e9db33b34ca7cadad224c5407279b10634d3", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -838,12 +838,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .get(location.statement_index)\n         {\n             Some(&Statement {\n-                kind: StatementKind::Assign(box(Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                }, _)),\n+                kind: StatementKind::Assign(box(ref place, _)),\n                 ..\n-            }) => local,\n+            }) => {\n+                if let Some(local) = place.as_local() {\n+                    local\n+                } else {\n+                    return OtherUse(use_span);\n+                }\n+            }\n             _ => return OtherUse(use_span),\n         };\n "}, {"sha": "c3369e872151a1b7e6d4c524b5dfc43fd5107454", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 54, "deletions": 59, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -1133,15 +1133,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Special case: you can assign a immutable local variable\n         // (e.g., `x = ...`) so long as it has never been initialized\n         // before (at this point in the flow).\n-        if let Place {\n-            base: PlaceBase::Local(local),\n-            projection: box [],\n-        } = place_span.0 {\n-            if let Mutability::Not = self.body.local_decls[*local].mutability {\n+        if let Some(local) = place_span.0.as_local() {\n+            if let Mutability::Not = self.body.local_decls[local].mutability {\n                 // check for reassignments to immutable local variables\n                 self.check_if_reassignment_to_immutable_state(\n                     location,\n-                    *local,\n+                    local,\n                     place_span,\n                     flow_state,\n                 );\n@@ -1288,60 +1285,58 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // captures of a closure are copied/moved directly\n         // when generating MIR.\n         match *operand {\n-            Operand::Move(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }) |\n-            Operand::Copy(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }) if self.body.local_decls[local].is_user_variable.is_none() => {\n-                if self.body.local_decls[local].ty.is_mutable_ptr() {\n-                    // The variable will be marked as mutable by the borrow.\n-                    return;\n-                }\n-                // This is an edge case where we have a `move` closure\n-                // inside a non-move closure, and the inner closure\n-                // contains a mutation:\n-                //\n-                // let mut i = 0;\n-                // || { move || { i += 1; }; };\n-                //\n-                // In this case our usual strategy of assuming that the\n-                // variable will be captured by mutable reference is\n-                // wrong, since `i` can be copied into the inner\n-                // closure from a shared reference.\n-                //\n-                // As such we have to search for the local that this\n-                // capture comes from and mark it as being used as mut.\n-\n-                let temp_mpi = self.move_data.rev_lookup.find_local(local);\n-                let init = if let [init_index] = *self.move_data.init_path_map[temp_mpi] {\n-                    &self.move_data.inits[init_index]\n-                } else {\n-                    bug!(\"temporary should be initialized exactly once\")\n-                };\n-\n-                let loc = match init.location {\n-                    InitLocation::Statement(stmt) => stmt,\n-                    _ => bug!(\"temporary initialized in arguments\"),\n-                };\n-\n-                let bbd = &self.body[loc.block];\n-                let stmt = &bbd.statements[loc.statement_index];\n-                debug!(\"temporary assigned in: stmt={:?}\", stmt);\n-\n-                if let StatementKind::Assign(box(_, Rvalue::Ref(_, _, ref source))) = stmt.kind {\n-                    propagate_closure_used_mut_place(self, source);\n-                } else {\n-                    bug!(\"closures should only capture user variables \\\n-                        or references to user variables\");\n+            Operand::Move(ref place) | Operand::Copy(ref place) => {\n+                match place.as_local() {\n+                    Some(local) if self.body.local_decls[local].is_user_variable.is_none() => {\n+                        if self.body.local_decls[local].ty.is_mutable_ptr() {\n+                            // The variable will be marked as mutable by the borrow.\n+                            return;\n+                        }\n+                        // This is an edge case where we have a `move` closure\n+                        // inside a non-move closure, and the inner closure\n+                        // contains a mutation:\n+                        //\n+                        // let mut i = 0;\n+                        // || { move || { i += 1; }; };\n+                        //\n+                        // In this case our usual strategy of assuming that the\n+                        // variable will be captured by mutable reference is\n+                        // wrong, since `i` can be copied into the inner\n+                        // closure from a shared reference.\n+                        //\n+                        // As such we have to search for the local that this\n+                        // capture comes from and mark it as being used as mut.\n+\n+                        let temp_mpi = self.move_data.rev_lookup.find_local(local);\n+                        let init = if let [init_index] = *self.move_data.init_path_map[temp_mpi] {\n+                            &self.move_data.inits[init_index]\n+                        } else {\n+                            bug!(\"temporary should be initialized exactly once\")\n+                        };\n+\n+                        let loc = match init.location {\n+                            InitLocation::Statement(stmt) => stmt,\n+                            _ => bug!(\"temporary initialized in arguments\"),\n+                        };\n+\n+                        let bbd = &self.body[loc.block];\n+                        let stmt = &bbd.statements[loc.statement_index];\n+                        debug!(\"temporary assigned in: stmt={:?}\", stmt);\n+\n+                        if let StatementKind::Assign(box (_, Rvalue::Ref(_, _, ref source))) =\n+                            stmt.kind\n+                        {\n+                            propagate_closure_used_mut_place(self, source);\n+                        } else {\n+                            bug!(\n+                                \"closures should only capture user variables \\\n+                                 or references to user variables\"\n+                            );\n+                        }\n+                    }\n+                    _ => propagate_closure_used_mut_place(self, place),\n                 }\n             }\n-            Operand::Move(ref place)\n-            | Operand::Copy(ref place) => {\n-                propagate_closure_used_mut_place(self, place);\n-            }\n             Operand::Constant(..) => {}\n         }\n     }\n@@ -1702,7 +1697,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"check_if_assigned_path_is_moved place: {:?}\", place);\n \n         // None case => assigning to `x` does not require `x` be initialized.\n-        let mut cursor = &*place.projection;\n+        let mut cursor = &*place.projection.as_ref();\n         while let [proj_base @ .., elem] = cursor {\n             cursor = proj_base;\n "}, {"sha": "d9e958d9450017fec5973fab06b1e5844aea54f8", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -89,45 +89,41 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 // If that ever stops being the case, then the ever initialized\n                 // flow could be used.\n                 if let Some(StatementKind::Assign(\n-                    box(\n-                        Place {\n-                            base: PlaceBase::Local(local),\n-                            projection: box [],\n-                        },\n-                        Rvalue::Use(Operand::Move(move_from))\n-                    )\n+                    box(place, Rvalue::Use(Operand::Move(move_from)))\n                 )) = self.body.basic_blocks()[location.block]\n                     .statements\n                     .get(location.statement_index)\n                     .map(|stmt| &stmt.kind)\n                 {\n-                    let local_decl = &self.body.local_decls[*local];\n-                    // opt_match_place is the\n-                    // match_span is the span of the expression being matched on\n-                    // match *x.y { ... }        match_place is Some(*x.y)\n-                    //       ^^^^                match_span is the span of *x.y\n-                    //\n-                    // opt_match_place is None for let [mut] x = ... statements,\n-                    // whether or not the right-hand side is a place expression\n-                    if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                        opt_match_place: Some((ref opt_match_place, match_span)),\n-                        binding_mode: _,\n-                        opt_ty_info: _,\n-                        pat_span: _,\n-                    }))) = local_decl.is_user_variable\n-                    {\n-                        let stmt_source_info = self.body.source_info(location);\n-                        self.append_binding_error(\n-                            grouped_errors,\n-                            kind,\n-                            original_path,\n-                            move_from,\n-                            *local,\n-                            opt_match_place,\n-                            match_span,\n-                            stmt_source_info.span,\n-                        );\n-                        return;\n+                    if let Some(local) = place.as_local() {\n+                        let local_decl = &self.body.local_decls[local];\n+                        // opt_match_place is the\n+                        // match_span is the span of the expression being matched on\n+                        // match *x.y { ... }        match_place is Some(*x.y)\n+                        //       ^^^^                match_span is the span of *x.y\n+                        //\n+                        // opt_match_place is None for let [mut] x = ... statements,\n+                        // whether or not the right-hand side is a place expression\n+                        if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                            opt_match_place: Some((ref opt_match_place, match_span)),\n+                            binding_mode: _,\n+                            opt_ty_info: _,\n+                            pat_span: _,\n+                        }))) = local_decl.is_user_variable\n+                        {\n+                            let stmt_source_info = self.body.source_info(location);\n+                            self.append_binding_error(\n+                                grouped_errors,\n+                                kind,\n+                                original_path,\n+                                move_from,\n+                                local,\n+                                opt_match_place,\n+                                match_span,\n+                                stmt_source_info.span,\n+                            );\n+                            return;\n+                        }\n                     }\n                 }\n \n@@ -307,11 +303,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let upvar_field = self.prefixes(move_place.as_ref(), PrefixSet::All)\n             .find_map(|p| self.is_upvar_field_projection(p));\n \n-        let deref_base = match &deref_target_place.projection {\n-            box [proj_base @ .., ProjectionElem::Deref] => {\n+        let deref_base = match deref_target_place.projection.as_ref() {\n+            &[ref proj_base @ .., ProjectionElem::Deref] => {\n                 PlaceRef {\n                     base: &deref_target_place.base,\n-                    projection: proj_base,\n+                    projection: &proj_base,\n                 }\n             }\n             _ => bug!(\"deref_target_place is not a deref projection\"),"}, {"sha": "68b33331a1ffbfa64bce4b197ea65338c68c8ba1", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -49,10 +49,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [],\n             } => {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                if let Place {\n-                    base: PlaceBase::Local(_),\n-                    projection: box [],\n-                } = access_place {\n+                if access_place.as_local().is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n                     let name = self.body.local_decls[*local]\n@@ -153,10 +150,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }),\n                 projection: [],\n             } => {\n-                if let Place {\n-                    base: PlaceBase::Static(_),\n-                    projection: box [],\n-                } = access_place {\n+                if let PlaceRef {\n+                    base: &PlaceBase::Static(_),\n+                    projection: &[],\n+                } = access_place.as_ref() {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();\n                 } else {"}, {"sha": "cae303039a19430e5f371da8de73e362d4ced40e", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -8,8 +8,8 @@ use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{\n-    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, ProjectionElem, Rvalue,\n-    SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n+    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, PlaceRef, ProjectionElem,\n+    Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n };\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, RegionVid, Ty};\n@@ -211,14 +211,14 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n             // - if it's a deeper projection, we have to filter which\n             //   of the borrows are killed: the ones whose `borrowed_place`\n             //   conflicts with the `place`.\n-            match place {\n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n+            match place.as_ref() {\n+                PlaceRef {\n+                    base: &PlaceBase::Local(local),\n+                    projection: &[],\n                 } |\n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [ProjectionElem::Deref],\n+                PlaceRef {\n+                    base: &PlaceBase::Local(local),\n+                    projection: &[ProjectionElem::Deref],\n                 } => {\n                     debug!(\n                         \"Recording `killed` facts for borrows of local={:?} at location={:?}\",\n@@ -229,21 +229,21 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                         all_facts,\n                         self.borrow_set,\n                         self.location_table,\n-                        local,\n+                        &local,\n                         location,\n                     );\n                 }\n \n-                Place {\n-                    base: PlaceBase::Static(_),\n+                PlaceRef {\n+                    base: &PlaceBase::Static(_),\n                     ..\n                 } => {\n                     // Ignore kills of static or static mut variables.\n                 }\n \n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [.., _],\n+                PlaceRef {\n+                    base: &PlaceBase::Local(local),\n+                    projection: &[.., _],\n                 } => {\n                     // Kill conflicting borrows of the innermost local.\n                     debug!(\n@@ -252,7 +252,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                         local, location\n                     );\n \n-                    if let Some(borrow_indices) = self.borrow_set.local_map.get(local) {\n+                    if let Some(borrow_indices) = self.borrow_set.local_map.get(&local) {\n                         for &borrow_index in borrow_indices {\n                             let places_conflict = places_conflict::places_conflict(\n                                 self.infcx.tcx,"}, {"sha": "26bead3047d5d3ce62bde8df861e120f94256182", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 71, "deletions": 85, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -6,8 +6,8 @@ use crate::borrow_check::nll::region_infer::{Cause, RegionName};\n use crate::borrow_check::nll::ConstraintDescription;\n use crate::borrow_check::{MirBorrowckCtxt, WriteKind};\n use rustc::mir::{\n-    CastKind, ConstraintCategory, FakeReadCause, Local, Location, Body, Operand, Place, PlaceBase,\n-    Rvalue, Statement, StatementKind, TerminatorKind,\n+    CastKind, ConstraintCategory, FakeReadCause, Local, Location, Body, Operand, Place, Rvalue,\n+    Statement, StatementKind, TerminatorKind,\n };\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::adjustment::{PointerCast};\n@@ -273,12 +273,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let mut should_note_order = false;\n                 if body.local_decls[local].name.is_some() {\n                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n-                        if let Place {\n-                            base: PlaceBase::Local(borrowed_local),\n-                            projection: box [],\n-                        } = place {\n-                             if body.local_decls[*borrowed_local].name.is_some()\n-                                && local != *borrowed_local\n+                        if let Some(borrowed_local) = place.as_local() {\n+                             if body.local_decls[borrowed_local].name.is_some()\n+                                && local != borrowed_local\n                             {\n                                 should_note_order = true;\n                             }\n@@ -494,22 +491,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // Just point to the function, to reduce the chance of overlapping spans.\n                         let function_span = match func {\n                             Operand::Constant(c) => c.span,\n-                            Operand::Copy(Place {\n-                                base: PlaceBase::Local(l),\n-                                projection: box [],\n-                            }) |\n-                            Operand::Move(Place {\n-                                base: PlaceBase::Local(l),\n-                                projection: box [],\n-                            }) => {\n-                                let local_decl = &self.body.local_decls[*l];\n-                                if local_decl.name.is_none() {\n-                                    local_decl.source_info.span\n+                            Operand::Copy(place) |\n+                            Operand::Move(place) => {\n+                                if let Some(l) = place.as_local() {\n+                                    let local_decl = &self.body.local_decls[l];\n+                                    if local_decl.name.is_none() {\n+                                        local_decl.source_info.span\n+                                    } else {\n+                                        span\n+                                    }\n                                 } else {\n                                     span\n                                 }\n                             }\n-                            _ => span,\n                         };\n                         return (LaterUseKind::Call, function_span);\n                     } else {\n@@ -542,14 +536,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // it which simplifies the termination logic.\n         let mut queue = vec![location];\n         let mut target = if let Some(&Statement {\n-            kind: StatementKind::Assign(box(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }, _)),\n+            kind: StatementKind::Assign(box(ref place, _)),\n             ..\n-        }) = stmt\n-        {\n-            local\n+        }) = stmt {\n+            if let Some(local) = place.as_local() {\n+                local\n+            } else {\n+                return false;\n+            }\n         } else {\n             return false;\n         };\n@@ -582,17 +576,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // If we see a use, we should check whether it is our data, and if so\n                         // update the place that we're looking for to that new place.\n                         Rvalue::Use(operand) => match operand {\n-                            Operand::Copy(Place {\n-                                base: PlaceBase::Local(from),\n-                                projection: box [],\n-                            })\n-                            | Operand::Move(Place {\n-                                base: PlaceBase::Local(from),\n-                                projection: box [],\n-                            })\n-                                if *from == target =>\n-                            {\n-                                target = into;\n+                            Operand::Copy(place)\n+                            | Operand::Move(place) => {\n+                                if let Some(from) = place.as_local() {\n+                                    if from == target {\n+                                        target = into;\n+                                    }\n+                                }\n                             }\n                             _ => {}\n                         },\n@@ -601,28 +591,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         Rvalue::Cast(\n                             CastKind::Pointer(PointerCast::Unsize), operand, ty\n                         ) => match operand {\n-                            Operand::Copy(Place {\n-                                base: PlaceBase::Local(from),\n-                                projection: box [],\n-                            })\n-                            | Operand::Move(Place {\n-                                base: PlaceBase::Local(from),\n-                                projection: box [],\n-                            })\n-                                if *from == target =>\n-                            {\n-                                debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n-                                // Check the type for a trait object.\n-                                return match ty.kind {\n-                                    // `&dyn Trait`\n-                                    ty::Ref(_, ty, _) if ty.is_trait() => true,\n-                                    // `Box<dyn Trait>`\n-                                    _ if ty.is_box() && ty.boxed_ty().is_trait() => true,\n-                                    // `dyn Trait`\n-                                    _ if ty.is_trait() => true,\n-                                    // Anything else.\n-                                    _ => false,\n-                                };\n+                            Operand::Copy(place)\n+                            | Operand::Move(place) => {\n+                                if let Some(from) = place.as_local() {\n+                                    if from == target {\n+                                        debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n+                                        // Check the type for a trait object.\n+                                        return match ty.kind {\n+                                            // `&dyn Trait`\n+                                            ty::Ref(_, ty, _) if ty.is_trait() => true,\n+                                            // `Box<dyn Trait>`\n+                                            _ if ty.is_box() && ty.boxed_ty().is_trait() => true,\n+                                            // `dyn Trait`\n+                                            _ if ty.is_trait() => true,\n+                                            // Anything else.\n+                                            _ => false,\n+                                        };\n+                                    }\n+                                }\n+                                return false;\n                             }\n                             _ => return false,\n                         },\n@@ -638,34 +625,33 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 debug!(\"was_captured_by_trait_object: terminator={:?}\", terminator);\n \n                 if let TerminatorKind::Call {\n-                    destination: Some((Place {\n-                        base: PlaceBase::Local(dest),\n-                        projection: box [],\n-                    }, block)),\n+                    destination: Some((place, block)),\n                     args,\n                     ..\n-                } = &terminator.kind\n-                {\n-                    debug!(\n-                        \"was_captured_by_trait_object: target={:?} dest={:?} args={:?}\",\n-                        target, dest, args\n-                    );\n-                    // Check if one of the arguments to this function is the target place.\n-                    let found_target = args.iter().any(|arg| {\n-                        if let Operand::Move(Place {\n-                            base: PlaceBase::Local(potential),\n-                            projection: box [],\n-                        }) = arg {\n-                            *potential == target\n-                        } else {\n-                            false\n-                        }\n-                    });\n+                } = &terminator.kind {\n+                    if let Some(dest) = place.as_local() {\n+                        debug!(\n+                            \"was_captured_by_trait_object: target={:?} dest={:?} args={:?}\",\n+                            target, dest, args\n+                        );\n+                        // Check if one of the arguments to this function is the target place.\n+                        let found_target = args.iter().any(|arg| {\n+                            if let Operand::Move(place) = arg {\n+                                if let Some(potential) = place.as_local() {\n+                                    potential == target\n+                                } else {\n+                                    false\n+                                }\n+                            } else {\n+                                false\n+                            }\n+                        });\n \n-                    // If it is, follow this to the next block and update the target.\n-                    if found_target {\n-                        target = *dest;\n-                        queue.push(block.start_location());\n+                        // If it is, follow this to the next block and update the target.\n+                        if found_target {\n+                            target = dest;\n+                            queue.push(block.start_location());\n+                        }\n                     }\n                 }\n             }"}, {"sha": "b5560fe6751bd9be3120baa66a030578f139a2b4", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -480,13 +480,13 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         if place.projection.is_empty() {\n             if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n-                let is_promoted = match place {\n-                    Place {\n-                        base: PlaceBase::Static(box Static {\n+                let is_promoted = match place.as_ref() {\n+                    PlaceRef {\n+                        base: &PlaceBase::Static(box Static {\n                             kind: StaticKind::Promoted(..),\n                             ..\n                         }),\n-                        projection: box [],\n+                        projection: &[],\n                     } => true,\n                     _ => false,\n                 };\n@@ -1366,11 +1366,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // they are not caused by the user, but rather artifacts\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n-                let category = match *place {\n-                    Place {\n-                        base: PlaceBase::Local(RETURN_PLACE),\n-                        projection: box [],\n-                    } => if let BorrowCheckContext {\n+                let category = match place.as_local() {\n+                    Some(RETURN_PLACE) => if let BorrowCheckContext {\n                         universal_regions:\n                             UniversalRegions {\n                                 defining_ty: DefiningTy::Const(def_id, _),\n@@ -1386,10 +1383,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     } else {\n                         ConstraintCategory::Return\n                     },\n-                    Place {\n-                        base: PlaceBase::Local(l),\n-                        projection: box [],\n-                    } if !body.local_decls[l].is_user_variable.is_some() => {\n+                    Some(l) if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,\n@@ -1675,11 +1669,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Some((ref dest, _target_block)) => {\n                 let dest_ty = dest.ty(body, tcx).ty;\n                 let dest_ty = self.normalize(dest_ty, term_location);\n-                let category = match *dest {\n-                    Place {\n-                        base: PlaceBase::Local(RETURN_PLACE),\n-                        projection: box [],\n-                    } => {\n+                let category = match dest.as_local() {\n+                    Some(RETURN_PLACE) => {\n                         if let BorrowCheckContext {\n                             universal_regions:\n                                 UniversalRegions {\n@@ -1698,10 +1689,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             ConstraintCategory::Return\n                         }\n                     }\n-                    Place {\n-                        base: PlaceBase::Local(l),\n-                        projection: box [],\n-                    } if !body.local_decls[l].is_user_variable.is_some() => {\n+                    Some(l) if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,\n@@ -2432,7 +2420,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             location, borrow_region, borrowed_place\n         );\n \n-        let mut cursor = &*borrowed_place.projection;\n+        let mut cursor = borrowed_place.projection.as_ref();\n         while let [proj_base @ .., elem] = cursor {\n             cursor = proj_base;\n "}, {"sha": "264e4807af07e9c9e8056a296035c722ff0ef5fb", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -64,14 +64,8 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n \n     // This Local/Local case is handled by the more general code below, but\n     // it's so common that it's a speed win to check for it first.\n-    if let Place {\n-        base: PlaceBase::Local(l1),\n-        projection: box [],\n-    } = borrow_place {\n-        if let PlaceRef {\n-            base: PlaceBase::Local(l2),\n-            projection: [],\n-        } = access_place {\n+    if let Some(l1) = borrow_place.as_local() {\n+        if let Some(l2) = access_place.as_local() {\n             return l1 == l2;\n         }\n     }"}, {"sha": "95471afb7884f74d06c8cb67450b01b5b22086ba", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -1,7 +1,5 @@\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{\n-    Local, Location, Place, PlaceBase, Statement, StatementKind, TerminatorKind\n-};\n+use rustc::mir::{Local, Location, Place, PlaceBase, Statement, StatementKind, TerminatorKind};\n \n use rustc_data_structures::fx::FxHashSet;\n \n@@ -118,10 +116,7 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n                     \"assignment of {:?} to {:?}, adding {:?} to used mutable set\",\n                     path.place, local, path.place\n                 );\n-                if let Place {\n-                    base: PlaceBase::Local(user_local),\n-                    projection: box [],\n-                } = path.place {\n+                if let Some(user_local) = path.place.as_local() {\n                     self.mbcx.used_mut.insert(user_local);\n                 }\n             }"}, {"sha": "43ee6557634fb4a8d50d0a908ed8be447267dea6", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -496,28 +496,28 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let arg_place = unpack!(block = this.as_place(block, arg));\n \n-        let mutability = match arg_place {\n-            Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n+        let mutability = match arg_place.as_ref() {\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: &[],\n             } => this.local_decls[local].mutability,\n-            Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [ProjectionElem::Deref],\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: &[ProjectionElem::Deref],\n             } => {\n                 debug_assert!(\n                     this.local_decls[local].is_ref_for_guard(),\n                     \"Unexpected capture place\",\n                 );\n                 this.local_decls[local].mutability\n             }\n-            Place {\n+            PlaceRef {\n                 ref base,\n-                projection: box [ref proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n+                projection: &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             }\n-            | Place {\n+            | PlaceRef {\n                 ref base,\n-                projection: box [\n+                projection: &[\n                     ref proj_base @ ..,\n                     ProjectionElem::Field(upvar_index, _),\n                     ProjectionElem::Deref"}, {"sha": "b86bb21f6e39000c97a3fbd12b0fa04afaf127a4", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -1293,7 +1293,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Insert a Shallow borrow of the prefixes of any fake borrows.\n         for place in fake_borrows\n         {\n-            let mut cursor = &*place.projection;\n+            let mut cursor = place.projection.as_ref();\n             while let [proj_base @ .., elem] = cursor {\n                 cursor = proj_base;\n "}, {"sha": "1b3d8641f204e32cb25786f4ba2cd2b5f588ee05", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -926,46 +926,43 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // If constants and statics, we don't generate StorageLive for this\n             // temporary, so don't try to generate StorageDead for it either.\n             _ if self.local_scope().is_none() => (),\n-            Operand::Copy(Place {\n-                base: PlaceBase::Local(cond_temp),\n-                projection: box [],\n-            })\n-            | Operand::Move(Place {\n-                base: PlaceBase::Local(cond_temp),\n-                projection: box [],\n-            }) => {\n-                // Manually drop the condition on both branches.\n-                let top_scope = self.scopes.scopes.last_mut().unwrap();\n-                let top_drop_data = top_scope.drops.pop().unwrap();\n-\n-                match top_drop_data.kind {\n-                    DropKind::Value { .. } => {\n-                        bug!(\"Drop scheduled on top of condition variable\")\n-                    }\n-                    DropKind::Storage => {\n-                        let source_info = top_scope.source_info(top_drop_data.span);\n-                        let local = top_drop_data.local;\n-                        assert_eq!(local, cond_temp, \"Drop scheduled on top of condition\");\n-                        self.cfg.push(\n-                            true_block,\n-                            Statement {\n-                                source_info,\n-                                kind: StatementKind::StorageDead(local)\n-                            },\n-                        );\n-                        self.cfg.push(\n-                            false_block,\n-                            Statement {\n-                                source_info,\n-                                kind: StatementKind::StorageDead(local)\n-                            },\n-                        );\n+            Operand::Copy(place)\n+            | Operand::Move(place) => {\n+                if let Some(cond_temp) = place.as_local() {\n+                    // Manually drop the condition on both branches.\n+                    let top_scope = self.scopes.scopes.last_mut().unwrap();\n+                    let top_drop_data = top_scope.drops.pop().unwrap();\n+\n+                    match top_drop_data.kind {\n+                        DropKind::Value { .. } => {\n+                            bug!(\"Drop scheduled on top of condition variable\")\n+                        }\n+                        DropKind::Storage => {\n+                            let source_info = top_scope.source_info(top_drop_data.span);\n+                            let local = top_drop_data.local;\n+                            assert_eq!(local, cond_temp, \"Drop scheduled on top of condition\");\n+                            self.cfg.push(\n+                                true_block,\n+                                Statement {\n+                                    source_info,\n+                                    kind: StatementKind::StorageDead(local)\n+                                },\n+                            );\n+                            self.cfg.push(\n+                                false_block,\n+                                Statement {\n+                                    source_info,\n+                                    kind: StatementKind::StorageDead(local)\n+                                },\n+                            );\n+                        }\n                     }\n-                }\n \n-                top_scope.invalidate_cache(true, self.is_generator, true);\n+                    top_scope.invalidate_cache(true, self.is_generator, true);\n+                } else {\n+                    bug!(\"Expected as_local_operand to produce a temporary\");\n+                }\n             }\n-            _ => bug!(\"Expected as_local_operand to produce a temporary\"),\n         }\n \n         (true_block, false_block)"}, {"sha": "1b81032bfe62fd62306bf7c4df629013cc1ce09d", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -157,10 +157,12 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         // Since `propagate_call_unwind` doesn't exist, we have to kill the\n         // destination here, and then gen it again in `propagate_call_return`.\n         if let TerminatorKind::Call {\n-            destination: Some((Place { base: PlaceBase::Local(local), projection: box [] }, _)),\n+            destination: Some((ref place, _)),\n             ..\n         } = self.body[loc.block].terminator().kind {\n-            sets.kill(local);\n+            if let Some(local) = place.as_local() {\n+                sets.kill(local);\n+            }\n         }\n         self.check_for_move(sets, loc);\n     }"}, {"sha": "b599f4799446df4669651f91f306004ac1cac176", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -327,7 +327,7 @@ impl<'tcx> MoveData<'tcx> {\n     pub fn base_local(&self, mut mpi: MovePathIndex) -> Option<Local> {\n         loop {\n             let path = &self.move_paths[mpi];\n-            if let Place { base: PlaceBase::Local(l), projection: box [] } = path.place {\n+            if let Some(l) = path.place.as_local() {\n                 return Some(l);\n             }\n             if let Some(parent) = path.parent {"}, {"sha": "c8605e22e1084b2b445c663671177c3f4776ff5c", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -164,8 +164,8 @@ pub trait Qualif {\n \n             Rvalue::Ref(_, _, ref place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n-                if let box [proj_base @ .., elem] = &place.projection {\n-                    if ProjectionElem::Deref == *elem {\n+                if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n+                    if ProjectionElem::Deref == elem {\n                         let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.kind {\n                             return Self::in_place(cx, per_local, PlaceRef {"}, {"sha": "fc9290d638018372d89578686a83ac0c13493c3a", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -56,16 +56,16 @@ where\n     fn assign_qualif_direct(&mut self, place: &mir::Place<'tcx>, value: bool) {\n         debug_assert!(!place.is_indirect());\n \n-        match (value, place) {\n-            (true, mir::Place { base: mir::PlaceBase::Local(local), .. }) => {\n-                self.qualifs_per_local.insert(*local);\n+        match (value, place.as_ref()) {\n+            (true, mir::PlaceRef { base: &mir::PlaceBase::Local(local), .. }) => {\n+                self.qualifs_per_local.insert(local);\n             }\n \n             // For now, we do not clear the qualif if a local is overwritten in full by\n             // an unqualified rvalue (e.g. `y = 5`). This is to be consistent\n             // with aggregates where we overwrite all fields with assignments, which would not\n             // get this feature.\n-            (false, mir::Place { base: mir::PlaceBase::Local(_local), projection: box [] }) => {\n+            (false, mir::PlaceRef { base: &mir::PlaceBase::Local(_local), projection: &[] }) => {\n                 // self.qualifs_per_local.remove(*local);\n             }\n \n@@ -101,11 +101,10 @@ where\n \n         // If a local with no projections is moved from (e.g. `x` in `y = x`), record that\n         // it no longer needs to be dropped.\n-        if let mir::Operand::Move(mir::Place {\n-            base: mir::PlaceBase::Local(local),\n-            projection: box [],\n-        }) = *operand {\n-            self.qualifs_per_local.remove(local);\n+        if let mir::Operand::Move(place) = operand {\n+            if let Some(local) = place.as_local() {\n+                self.qualifs_per_local.remove(local);\n+            }\n         }\n     }\n "}, {"sha": "76a73adf03836368e96935659505a089016ffe31", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -244,8 +244,8 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n             // Special-case reborrows to be more like a copy of a reference.\n             let mut reborrow_place = None;\n-            if let box [proj_base @ .., elem] = &place.projection {\n-                if *elem == ProjectionElem::Deref {\n+            if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n+                if elem == ProjectionElem::Deref {\n                     let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         reborrow_place = Some(proj_base);\n@@ -376,12 +376,15 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             );\n \n             if rvalue_has_mut_interior {\n-                let is_derived_from_illegal_borrow = match *borrowed_place {\n+                let is_derived_from_illegal_borrow = match borrowed_place.as_local() {\n                     // If an unprojected local was borrowed and its value was the result of an\n                     // illegal borrow, suppress this error and mark the result of this borrow as\n                     // illegal as well.\n-                    Place { base: PlaceBase::Local(borrowed_local), projection: box [] }\n-                        if self.derived_from_illegal_borrow.contains(borrowed_local) => true,\n+                    Some(borrowed_local)\n+                        if self.derived_from_illegal_borrow.contains(borrowed_local) =>\n+                    {\n+                        true\n+                    }\n \n                     // Otherwise proceed normally: check the legality of a mutable borrow in this\n                     // context.\n@@ -394,7 +397,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 // FIXME: should we also clear `derived_from_illegal_borrow` when a local is\n                 // assigned a new value?\n                 if is_derived_from_illegal_borrow {\n-                    if let Place { base: PlaceBase::Local(dest), projection: box [] } = *dest {\n+                    if let Some(dest) = dest.as_local() {\n                         self.derived_from_illegal_borrow.insert(dest);\n                     }\n                 }\n@@ -571,10 +574,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                     return;\n                 }\n \n-                let needs_drop = if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = *dropped_place {\n+                let needs_drop = if let Some(local) = dropped_place.as_local() {\n                     // Use the span where the local was declared as the span of the drop error.\n                     err_span = self.body.local_decls[local].source_info.span;\n                     self.qualifs.needs_drop.contains(local)"}, {"sha": "029754dede22291df1dbe7bec5687a3620cb1b5c", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -407,8 +407,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         place: &Place<'tcx>,\n         is_mut_use: bool,\n     ) {\n-        let mut cursor = &*place.projection;\n-        while let [proj_base @ .., elem] = cursor {\n+        let mut cursor = place.projection.as_ref();\n+        while let &[ref proj_base @ .., elem] = cursor {\n             cursor = proj_base;\n \n             match elem {"}, {"sha": "dc6cb9650f05e66b93eaa2054c4068d7cca873c3", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -7,10 +7,9 @@ use std::cell::Cell;\n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{\n-    AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue,\n-    Local, UnOp, StatementKind, Statement, LocalKind,\n-    TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo, BinOp,\n-    SourceScope, SourceScopeLocalData, LocalDecl, BasicBlock,\n+    AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue, Local, UnOp,\n+    StatementKind, Statement, LocalKind, TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo,\n+    BinOp, SourceScope, SourceScopeLocalData, LocalDecl, BasicBlock,\n };\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, MutVisitor, NonMutatingUseContext,\n@@ -525,18 +524,21 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // (e.g. for CTFE) it can never happen. But here in const_prop\n             // unknown data is uninitialized, so if e.g. a function argument is unsized\n             // and has a reference taken, we get an ICE.\n-            Rvalue::Ref(_, _, Place { base: PlaceBase::Local(local), projection: box [] }) => {\n-                trace!(\"checking Ref({:?})\", place);\n-                let alive =\n-                    if let LocalValue::Live(_) = self.ecx.frame().locals[*local].value {\n-                        true\n-                    } else {\n-                        false\n-                    };\n+            Rvalue::Ref(_, _, place_ref) => {\n+                trace!(\"checking Ref({:?})\", place_ref);\n \n-                if !alive {\n-                    trace!(\"skipping Ref({:?}) to uninitialized local\", place);\n-                    return None;\n+                if let Some(local) = place_ref.as_local() {\n+                    let alive =\n+                        if let LocalValue::Live(_) = self.ecx.frame().locals[local].value {\n+                            true\n+                        } else {\n+                            false\n+                        };\n+\n+                    if !alive {\n+                        trace!(\"skipping Ref({:?}) to uninitialized local\", place);\n+                        return None;\n+                    }\n                 }\n             }\n \n@@ -706,10 +708,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                 .ty(&self.local_decls, self.tcx)\n                 .ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n-                if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = *place {\n+                if let Some(local) = place.as_local() {\n                     let source = statement.source_info;\n                     if let Some(()) = self.const_prop(rval, place_layout, source, place) {\n                         if self.can_const_prop[local] {"}, {"sha": "c20726eceba9a9fae49504b4ba0f9f6a32d0ded7", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 53, "deletions": 62, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -19,9 +19,7 @@\n //! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n //! future.\n \n-use rustc::mir::{\n-    Constant, Local, LocalKind, Location, Place, PlaceBase, Body, Operand, Rvalue, StatementKind\n-};\n+use rustc::mir::{Constant, Local, LocalKind, Location, Place, Body, Operand, Rvalue, StatementKind};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n use crate::transform::{MirPass, MirSource};\n@@ -92,28 +90,32 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                     };\n \n                     // That use of the source must be an assignment.\n-                    match statement.kind {\n-                        StatementKind::Assign(\n-                            box(\n-                                Place {\n-                                    base: PlaceBase::Local(local),\n-                                    projection: box [],\n-                                },\n-                                Rvalue::Use(ref operand)\n-                            )\n-                        ) if local == dest_local => {\n-                            let maybe_action = match *operand {\n-                                Operand::Copy(ref src_place) |\n-                                Operand::Move(ref src_place) => {\n-                                    Action::local_copy(&body, &def_use_analysis, src_place)\n-                                }\n-                                Operand::Constant(ref src_constant) => {\n-                                    Action::constant(src_constant)\n+                    match &statement.kind {\n+                        StatementKind::Assign(box(place, Rvalue::Use(operand))) => {\n+                            if let Some(local) = place.as_local() {\n+                                if local == dest_local {\n+                                    let maybe_action = match operand {\n+                                        Operand::Copy(ref src_place) |\n+                                        Operand::Move(ref src_place) => {\n+                                            Action::local_copy(&body, &def_use_analysis, src_place)\n+                                        }\n+                                        Operand::Constant(ref src_constant) => {\n+                                            Action::constant(src_constant)\n+                                        }\n+                                    };\n+                                    match maybe_action {\n+                                        Some(this_action) => action = this_action,\n+                                        None => continue,\n+                                    }\n+                                } else {\n+                                    debug!(\"  Can't copy-propagate local: source use is not an \\\n+                                    assignment\");\n+                                    continue\n                                 }\n-                            };\n-                            match maybe_action {\n-                                Some(this_action) => action = this_action,\n-                                None => continue,\n+                            } else {\n+                                debug!(\"  Can't copy-propagate local: source use is not an \\\n+                                    assignment\");\n+                                continue\n                             }\n                         }\n                         _ => {\n@@ -148,31 +150,20 @@ fn eliminate_self_assignments(\n         for def in dest_use_info.defs_not_including_drop() {\n             let location = def.location;\n             if let Some(stmt) = body[location.block].statements.get(location.statement_index) {\n-                match stmt.kind {\n-                    StatementKind::Assign(\n-                        box(\n-                            Place {\n-                                base: PlaceBase::Local(local),\n-                                projection: box [],\n-                            },\n-                            Rvalue::Use(Operand::Copy(Place {\n-                                base: PlaceBase::Local(src_local),\n-                                projection: box [],\n-                            })),\n-                        )\n-                    ) |\n-                    StatementKind::Assign(\n-                        box(\n-                            Place {\n-                                base: PlaceBase::Local(local),\n-                                projection: box [],\n-                            },\n-                            Rvalue::Use(Operand::Move(Place {\n-                                base: PlaceBase::Local(src_local),\n-                                projection: box [],\n-                            })),\n-                        )\n-                    ) if local == dest_local && dest_local == src_local => {}\n+                match &stmt.kind {\n+                    StatementKind::Assign(box (place, Rvalue::Use(Operand::Copy(src_place))))\n+                    | StatementKind::Assign(box (place, Rvalue::Use(Operand::Move(src_place)))) => {\n+                        if let (Some(local), Some(src_local)) =\n+                            (place.as_local(), src_place.as_local())\n+                        {\n+                            if local == dest_local && dest_local == src_local {\n+                            } else {\n+                                continue;\n+                            }\n+                        } else {\n+                            continue;\n+                        }\n+                    }\n                     _ => {\n                         continue;\n                     }\n@@ -198,10 +189,7 @@ impl<'tcx> Action<'tcx> {\n     fn local_copy(body: &Body<'tcx>, def_use_analysis: &DefUseAnalysis, src_place: &Place<'tcx>)\n                   -> Option<Action<'tcx>> {\n         // The source must be a local.\n-        let src_local = if let Place {\n-            base: PlaceBase::Local(local),\n-            projection: box [],\n-        } = *src_place {\n+        let src_local = if let Some(local) = src_place.as_local() {\n             local\n         } else {\n             debug!(\"  Can't copy-propagate local: source is not a local\");\n@@ -354,15 +342,18 @@ impl<'tcx> MutVisitor<'tcx> for ConstantPropagationVisitor<'tcx> {\n     fn visit_operand(&mut self, operand: &mut Operand<'tcx>, location: Location) {\n         self.super_operand(operand, location);\n \n-        match *operand {\n-            Operand::Copy(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }) |\n-            Operand::Move(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }) if local == self.dest_local => {}\n+        match operand {\n+            Operand::Copy(place) |\n+            Operand::Move(place) => {\n+                if let Some(local) = place.as_local() {\n+                    if local == self.dest_local {\n+                    } else {\n+                        return;\n+                    }\n+                } else {\n+                    return;\n+                }\n+            }\n             _ => return,\n         }\n "}, {"sha": "d0cb1b8297a59ebdee928aa303388ad1faf0b23b", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -864,17 +864,24 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n \n     for (block, block_data) in body.basic_blocks().iter_enumerated() {\n         let (target, unwind, source_info) = match block_data.terminator() {\n-            &Terminator {\n+            Terminator {\n                 source_info,\n                 kind: TerminatorKind::Drop {\n-                    location: Place {\n-                        base: PlaceBase::Local(local),\n-                        projection: box [],\n-                    },\n+                    location,\n                     target,\n                     unwind\n                 }\n-            } if local == gen => (target, unwind, source_info),\n+            } => {\n+                if let Some(local) = location.as_local() {\n+                    if local == gen {\n+                        (target, unwind, source_info)\n+                    } else {\n+                        continue;\n+                    }\n+                } else {\n+                    continue;\n+                }\n+            }\n             _ => continue,\n         };\n         let unwind = if block_data.is_cleanup {\n@@ -884,10 +891,10 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n         };\n         elaborate_drop(\n             &mut elaborator,\n-            source_info,\n+            *source_info,\n             &Place::from(gen),\n             (),\n-            target,\n+            *target,\n             unwind,\n             block,\n         );"}, {"sha": "353d89cf086634ff8e01c59537421afc91ced7b1", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -587,13 +587,12 @@ impl Inliner<'tcx> {\n         // FIXME: Analysis of the usage of the arguments to avoid\n         // unnecessary temporaries.\n \n-        if let Operand::Move(Place {\n-            base: PlaceBase::Local(local),\n-            projection: box [],\n-        }) = arg {\n-            if caller_body.local_kind(local) == LocalKind::Temp {\n-                // Reuse the operand if it's a temporary already\n-                return local;\n+        if let Operand::Move(place) = &arg {\n+            if let Some(local) = place.as_local() {\n+                if caller_body.local_kind(local) == LocalKind::Temp {\n+                    // Reuse the operand if it's a temporary already\n+                    return local;\n+                }\n             }\n         }\n \n@@ -650,14 +649,9 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n \n     fn make_integrate_local(&self, local: &Local) -> Local {\n         if *local == RETURN_PLACE {\n-            match self.destination {\n-                Place {\n-                    base: PlaceBase::Local(l),\n-                    projection: box [],\n-                } => {\n-                    return l;\n-                },\n-                ref place => bug!(\"Return place is {:?}, not local\", place)\n+            match self.destination.as_local() {\n+                Some(l) => return l,\n+                ref place => bug!(\"Return place is {:?}, not local\", place),\n             }\n         }\n \n@@ -686,17 +680,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n         context: PlaceContext,\n         location: Location,\n     ) {\n-        match place {\n-            Place {\n-                base: PlaceBase::Local(RETURN_PLACE),\n-                projection: box [],\n-            } => {\n-                // Return pointer; update the place itself\n-                *place = self.destination.clone();\n-            },\n-            _ => {\n-                self.super_place(place, context, location);\n-            }\n+        if let Some(RETURN_PLACE) = place.as_local() {\n+            // Return pointer; update the place itself\n+            *place = self.destination.clone();\n+        } else {\n+            self.super_place(place, context, location);\n         }\n     }\n "}, {"sha": "08668716fee11f3381c16743f76b54bbb51d1715", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -1,7 +1,8 @@\n //! Performs various peephole optimizations.\n \n-use rustc::mir::{Constant, Location, Place, PlaceBase, Body, Operand, ProjectionElem, Rvalue,\n-    Local};\n+use rustc::mir::{\n+    Constant, Location, Place, PlaceBase, PlaceRef, Body, Operand, ProjectionElem, Rvalue, Local\n+};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -40,20 +41,18 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n         if self.optimizations.and_stars.remove(&location) {\n             debug!(\"replacing `&*`: {:?}\", rvalue);\n-            let new_place = match *rvalue {\n-                Rvalue::Ref(_, _, Place {\n-                    ref mut base,\n-                    projection: ref mut projection @ box [.., _],\n-                }) => {\n-                    if let box [proj_l @ .., proj_r] = projection {\n-                        let place = Place {\n-                            // Replace with dummy\n-                            base: mem::replace(base, PlaceBase::Local(Local::new(0))),\n-                            projection: proj_l.to_vec().into_boxed_slice(),\n-                        };\n-                        *projection = vec![proj_r.clone()].into_boxed_slice();\n+            let new_place = match rvalue {\n+                Rvalue::Ref(_, _, place) => {\n+                    if let &[ref proj_l @ .., proj_r] = place.projection.as_ref() {\n+                        let new_projection = proj_l.to_vec().into_boxed_slice();\n+\n+                        place.projection = vec![proj_r.clone()].into_boxed_slice();\n \n-                        place\n+                        Place {\n+                            // Replace with dummy\n+                            base: mem::replace(&mut place.base, PlaceBase::Local(Local::new(0))),\n+                            projection: new_projection,\n+                        }\n                     } else {\n                         unreachable!();\n                     }\n@@ -91,12 +90,14 @@ impl OptimizationFinder<'b, 'tcx> {\n \n impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        if let Rvalue::Ref(_, _, Place {\n-            base,\n-            projection: box [proj_base @ .., ProjectionElem::Deref],\n-        }) = rvalue {\n-            if Place::ty_from(base, proj_base, self.body, self.tcx).ty.is_region_ptr() {\n-                self.optimizations.and_stars.insert(location);\n+        if let Rvalue::Ref(_, _, place) = rvalue {\n+            if let PlaceRef {\n+                base,\n+                projection: &[ref proj_base @ .., ProjectionElem::Deref],\n+            } = place.as_ref() {\n+                if Place::ty_from(base, proj_base, self.body, self.tcx).ty.is_region_ptr() {\n+                    self.optimizations.and_stars.insert(location);\n+                }\n             }\n         }\n "}, {"sha": "f13d49e3f54fe75f112a282f7ef6d4387ff632b7", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -434,14 +434,13 @@ pub fn promote_candidates<'tcx>(\n         match candidate {\n             Candidate::Repeat(Location { block, statement_index }) |\n             Candidate::Ref(Location { block, statement_index }) => {\n-                match body[block].statements[statement_index].kind {\n-                    StatementKind::Assign(box(Place {\n-                        base: PlaceBase::Local(local),\n-                        projection: box [],\n-                    }, _)) => {\n-                        if temps[local] == TempState::PromotedOut {\n-                            // Already promoted.\n-                            continue;\n+                match &body[block].statements[statement_index].kind {\n+                    StatementKind::Assign(box(place, _)) => {\n+                        if let Some(local) = place.as_local() {\n+                            if temps[local] == TempState::PromotedOut {\n+                                // Already promoted.\n+                                continue;\n+                            }\n                         }\n                     }\n                     _ => {}\n@@ -487,28 +486,30 @@ pub fn promote_candidates<'tcx>(\n     let promoted = |index: Local| temps[index] == TempState::PromotedOut;\n     for block in body.basic_blocks_mut() {\n         block.statements.retain(|statement| {\n-            match statement.kind {\n-                StatementKind::Assign(box(Place {\n-                    base: PlaceBase::Local(index),\n-                    projection: box [],\n-                }, _)) |\n+            match &statement.kind {\n+                StatementKind::Assign(box(place, _)) => {\n+                    if let Some(index) = place.as_local() {\n+                        !promoted(index)\n+                    } else {\n+                        true\n+                    }\n+                }\n                 StatementKind::StorageLive(index) |\n                 StatementKind::StorageDead(index) => {\n-                    !promoted(index)\n+                    !promoted(*index)\n                 }\n                 _ => true\n             }\n         });\n         let terminator = block.terminator_mut();\n-        match terminator.kind {\n-            TerminatorKind::Drop { location: Place {\n-                base: PlaceBase::Local(index),\n-                projection: box [],\n-            }, target, .. } => {\n-                if promoted(index) {\n-                    terminator.kind = TerminatorKind::Goto {\n-                        target,\n-                    };\n+        match &terminator.kind {\n+            TerminatorKind::Drop { location: place, target, .. } => {\n+                if let Some(index) = place.as_local() {\n+                    if promoted(index) {\n+                        terminator.kind = TerminatorKind::Goto {\n+                            target: *target,\n+                        };\n+                    }\n                 }\n             }\n             _ => {}"}, {"sha": "6aba91f416299ebc3743592b1838b511f8b34d95", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -292,8 +292,8 @@ trait Qualif {\n \n             Rvalue::Ref(_, _, ref place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n-                if let box [proj_base @ .., elem] = &place.projection {\n-                    if ProjectionElem::Deref == *elem {\n+                if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n+                    if ProjectionElem::Deref == elem {\n                         let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.kind {\n                             return Self::in_place(cx, PlaceRef {\n@@ -1041,26 +1041,24 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             match *candidate {\n                 Candidate::Repeat(Location { block: bb, statement_index: stmt_idx }) => {\n                     if let StatementKind::Assign(box(_, Rvalue::Repeat(\n-                        Operand::Move(Place {\n-                            base: PlaceBase::Local(index),\n-                            projection: box [],\n-                        }),\n+                        Operand::Move(place),\n                         _\n-                    ))) = self.body[bb].statements[stmt_idx].kind {\n-                        promoted_temps.insert(index);\n+                    ))) = &self.body[bb].statements[stmt_idx].kind {\n+                        if let Some(index) = place.as_local() {\n+                            promoted_temps.insert(index);\n+                        }\n                     }\n                 }\n                 Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n                     if let StatementKind::Assign(\n                         box(\n                             _,\n-                            Rvalue::Ref(_, _, Place {\n-                                base: PlaceBase::Local(index),\n-                                projection: box [],\n-                            })\n+                            Rvalue::Ref(_, _, place)\n                         )\n-                    ) = self.body[bb].statements[stmt_idx].kind {\n-                        promoted_temps.insert(index);\n+                    ) = &self.body[bb].statements[stmt_idx].kind {\n+                        if let Some(index) = place.as_local() {\n+                            promoted_temps.insert(index);\n+                        }\n                     }\n                 }\n                 Candidate::Argument { .. } => {}\n@@ -1237,10 +1235,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         match *operand {\n             Operand::Move(ref place) => {\n                 // Mark the consumed locals to indicate later drops are noops.\n-                if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = *place {\n+                if let Some(local) = place.as_local() {\n                     self.cx.per_local[NeedsDrop].remove(local);\n                 }\n             }\n@@ -1256,8 +1251,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n             // Special-case reborrows.\n             let mut reborrow_place = None;\n-            if let box [proj_base @ .., elem] = &place.projection {\n-                if *elem == ProjectionElem::Deref {\n+            if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n+                if elem == ProjectionElem::Deref {\n                     let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         reborrow_place = Some(proj_base);\n@@ -1568,10 +1563,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 unleash_miri!(self);\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n-                let needs_drop = if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = *place {\n+                let needs_drop = if let Some(local) = place.as_local() {\n                     if NeedsDrop::in_local(self, local) {\n                         Some(self.body.local_decls[local].source_info.span)\n                     } else {\n@@ -1817,16 +1809,17 @@ fn remove_drop_and_storage_dead_on_promoted_locals(\n             }\n         });\n         let terminator = block.terminator_mut();\n-        match terminator.kind {\n+        match &terminator.kind {\n             TerminatorKind::Drop {\n-                location: Place {\n-                    base: PlaceBase::Local(index),\n-                    projection: box [],\n-                },\n+                location,\n                 target,\n                 ..\n-            } if promoted_temps.contains(index) => {\n-                terminator.kind = TerminatorKind::Goto { target };\n+            } => {\n+                if let Some(index) = location.as_local() {\n+                    if promoted_temps.contains(index) {\n+                        terminator.kind = TerminatorKind::Goto { target: *target };\n+                    }\n+                }\n             }\n             _ => {}\n         }"}, {"sha": "c4e44091bc90d8f0049e3911ac751616768c4b03", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -259,8 +259,8 @@ fn check_place(\n     def_id: DefId,\n     body: &Body<'tcx>\n ) -> McfResult {\n-    let mut cursor = &*place.projection;\n-    while let [proj_base @ .., elem] = cursor {\n+    let mut cursor = place.projection.as_ref();\n+    while let &[ref proj_base @ .., elem] = cursor {\n         cursor = proj_base;\n         match elem {\n             ProjectionElem::Downcast(..) => {"}, {"sha": "130393e2c4c865f359586ca96cf75f88374ce139", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -32,7 +32,7 @@ impl RemoveNoopLandingPads {\n         nop_landing_pads: &BitSet<BasicBlock>,\n     ) -> bool {\n         for stmt in &body[bb].statements {\n-            match stmt.kind {\n+            match &stmt.kind {\n                 StatementKind::FakeRead(..) |\n                 StatementKind::StorageLive(_) |\n                 StatementKind::StorageDead(_) |\n@@ -41,12 +41,13 @@ impl RemoveNoopLandingPads {\n                     // These are all nops in a landing pad\n                 }\n \n-                StatementKind::Assign(box(Place {\n-                    base: PlaceBase::Local(_),\n-                    projection: box [],\n-                }, Rvalue::Use(_))) => {\n-                    // Writing to a local (e.g., a drop flag) does not\n-                    // turn a landing pad to a non-nop\n+                StatementKind::Assign(box(place, Rvalue::Use(_))) => {\n+                    if place.as_local().is_some() {\n+                        // Writing to a local (e.g., a drop flag) does not\n+                        // turn a landing pad to a non-nop\n+                    } else {\n+                        return false;\n+                    }\n                 }\n \n                 StatementKind::Assign { .. } |"}, {"sha": "aada7641df67ac616b712585a8fb489e4a41e7f5", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -155,8 +155,8 @@ fn value_assigned_to_local<'a, 'tcx>(\n     local: Local,\n ) -> Option<&'a mir::Rvalue<'tcx>> {\n     if let mir::StatementKind::Assign(box (place, rvalue)) = &stmt.kind {\n-        if let mir::Place { base: mir::PlaceBase::Local(l), projection: box [] } = place {\n-            if local == *l {\n+        if let Some(l) = place.as_local() {\n+            if local == l {\n                 return Some(&*rvalue);\n             }\n         }\n@@ -192,7 +192,7 @@ impl PeekCall {\n         tcx: TyCtxt<'tcx>,\n         terminator: &mir::Terminator<'tcx>,\n     ) -> Option<Self> {\n-        use mir::{Operand, Place, PlaceBase};\n+        use mir::Operand;\n \n         let span = terminator.source_info.span;\n         if let mir::TerminatorKind::Call { func: Operand::Constant(func), args, .. } =\n@@ -207,14 +207,23 @@ impl PeekCall {\n \n                 assert_eq!(args.len(), 1);\n                 let kind = PeekCallKind::from_arg_ty(substs.type_at(0));\n-                let arg = match args[0] {\n-                    | Operand::Copy(Place { base: PlaceBase::Local(local), projection: box [] })\n-                    | Operand::Move(Place { base: PlaceBase::Local(local), projection: box [] })\n-                    => local,\n-\n+                let arg = match &args[0] {\n+                    Operand::Copy(place) | Operand::Move(place) => {\n+                        if let Some(local) = place.as_local() {\n+                            local\n+                        } else {\n+                            tcx.sess.diagnostic().span_err(\n+                                span,\n+                                \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\",\n+                            );\n+                            return None;\n+                        }\n+                    }\n                     _ => {\n                         tcx.sess.diagnostic().span_err(\n-                            span, \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\");\n+                            span,\n+                            \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\",\n+                        );\n                         return None;\n                     }\n                 };\n@@ -277,12 +286,11 @@ impl<'tcx> RustcPeekAt<'tcx> for IndirectlyMutableLocals<'_, 'tcx> {\n         call: PeekCall,\n     ) {\n         warn!(\"peek_at: place={:?}\", place);\n-        let local = match place {\n-            mir::Place { base: mir::PlaceBase::Local(l), projection: box [] } => *l,\n-            _ => {\n-                tcx.sess.span_err(call.span, \"rustc_peek: argument was not a local\");\n-                return;\n-            }\n+        let local = if let Some(l) = place.as_local() {\n+            l\n+        } else {\n+            tcx.sess.span_err(call.span, \"rustc_peek: argument was not a local\");\n+            return;\n         };\n \n         if !flow_state.contains(local) {"}, {"sha": "07a7def3ea2569f2acb205a92d8d4ca4929975bc", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -61,7 +61,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n         if let Rvalue::Use(Operand::Move(ref src_place)) = rvalue {\n-            if let box [proj_base @ .., elem] = &src_place.projection {\n+            if let &[ref proj_base @ .., elem] = src_place.projection.as_ref() {\n                 if let ProjectionElem::ConstantIndex{offset: _,\n                                                      min_length: _,\n                                                      from_end: false} = elem {\n@@ -203,18 +203,17 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut {\n                 if let StatementKind::Assign(box(ref dst_place, ref rval)) = statement.kind {\n                     if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = *rval {\n                         let items : Vec<_> = items.iter().map(|item| {\n-                            if let Operand::Move(Place {\n-                                base: PlaceBase::Local(local),\n-                                projection: box [],\n-                            }) = item {\n-                                let local_use = &visitor.locals_use[*local];\n-                                let opt_index_and_place =\n-                                    Self::try_get_item_source(local_use, body);\n-                                // each local should be used twice:\n-                                //  in assign and in aggregate statements\n-                                if local_use.use_count == 2 && opt_index_and_place.is_some() {\n-                                    let (index, src_place) = opt_index_and_place.unwrap();\n-                                    return Some((local_use, index, src_place));\n+                            if let Operand::Move(place) = item {\n+                                if let Some(local) = place.as_local() {\n+                                    let local_use = &visitor.locals_use[local];\n+                                    let opt_index_and_place =\n+                                        Self::try_get_item_source(local_use, body);\n+                                    // each local should be used twice:\n+                                    //  in assign and in aggregate statements\n+                                    if local_use.use_count == 2 && opt_index_and_place.is_some() {\n+                                        let (index, src_place) = opt_index_and_place.unwrap();\n+                                        return Some((local_use, index, src_place));\n+                                    }\n                                 }\n                             }\n                             None\n@@ -293,33 +292,27 @@ impl RestoreSubsliceArrayMoveOut {\n             if block.statements.len() > location.statement_index {\n                 let statement = &block.statements[location.statement_index];\n                 if let StatementKind::Assign(\n-                    box(\n-                        Place {\n-                            base: PlaceBase::Local(_),\n-                            projection: box [],\n-                        },\n-                        Rvalue::Use(Operand::Move(Place {\n-                            base: _,\n-                            projection: box [.., ProjectionElem::ConstantIndex {\n-                                offset, min_length: _, from_end: false\n-                            }],\n-                        })),\n-                    )\n+                    box(place, Rvalue::Use(Operand::Move(src_place)))\n                 ) = &statement.kind {\n-                    // FIXME remove once we can use slices patterns\n-                    if let StatementKind::Assign(\n-                        box(\n-                            _,\n-                            Rvalue::Use(Operand::Move(Place {\n+                    if let (Some(_), PlaceRef {\n+                        base: _,\n+                        projection: &[.., ProjectionElem::ConstantIndex {\n+                            offset, min_length: _, from_end: false\n+                        }],\n+                    }) = (place.as_local(), src_place.as_ref()) {\n+                        if let StatementKind::Assign(\n+                            box(_, Rvalue::Use(Operand::Move(place)))\n+                        ) = &statement.kind {\n+                            if let PlaceRef {\n                                 base,\n-                                projection: box [proj_base @ .., _],\n-                            })),\n-                        )\n-                    ) = &statement.kind {\n-                        return Some((*offset, PlaceRef {\n-                            base,\n-                            projection: proj_base,\n-                        }))\n+                                projection: &[ref proj_base @ .., _],\n+                            } = place.as_ref() {\n+                                return Some((offset, PlaceRef {\n+                                    base,\n+                                    projection: proj_base,\n+                                }))\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "f949fcf0745f01cf95cb07dd3ec9ffb6268f8481", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/190802cfca41df76fd7ef45d2915c89938a5904a/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=190802cfca41df76fd7ef45d2915c89938a5904a", "patch": "@@ -38,8 +38,8 @@ fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx>, local_decls: &L, place: &Place<'\n where\n     L: HasLocalDecls<'tcx>,\n {\n-    let mut cursor = &*place.projection;\n-    while let [proj_base @ .., elem] = cursor {\n+    let mut cursor = place.projection.as_ref();\n+    while let &[ref proj_base @ .., elem] = cursor {\n         cursor = proj_base;\n \n         match elem {"}]}