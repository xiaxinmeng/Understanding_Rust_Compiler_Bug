{"sha": "919cf42feb30238fc5d0a74e7a576551f3468bba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxOWNmNDJmZWIzMDIzOGZjNWQwYTc0ZTdhNTc2NTUxZjM0NjhiYmE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-14T01:41:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-14T01:41:17Z"}, "message": "Rollup merge of #57992 - Matthias247:waker4, r=cramertj\n\nUpdate the future/task API\n\nThis change updates the future and task API as discussed in the stabilization RFC at https://github.com/rust-lang/rfcs/pull/2592.\n\nChanges:\n- Replacing UnsafeWake with RawWaker and RawWakerVtable\n- Removal of LocalWaker\n- Removal of Arc-based Wake trait", "tree": {"sha": "e3a55900003e38b0cbf9e63b9eefaff69d4feca7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3a55900003e38b0cbf9e63b9eefaff69d4feca7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/919cf42feb30238fc5d0a74e7a576551f3468bba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcZMc+CRBK7hj4Ov3rIwAAdHIIALIBQy/Tmb242ja1HcMyS8d/\nAWCR1USc3htos6BGfhCHwN2Fh+NdukP1Ra2IWCzaxlX6KP6/9GqxgAbLNjf7dUdp\nfM2T5TOnPPXHizS74raAGTiN3J9wu+4I7L4x/LtnRf+s23jaGvzOdZ+JbIlU7Rp6\nIWac9M5wDzef+cut55JbEKMm8+yovEy74rMJ93dhagjGJ6wI5GR3OaPOUpTnGlbm\nJGfUq56Zl7xdy9V13P08QW9k3J5TXRj9b2C0/n/U7D5NnL5WdXIrKg/6FNAVtcwD\nslmW2Ak78CSziAvjggQkIM2RLFmm3+hklAadNZJ1W3c7pR5Tjv8GFTRcULGnUgg=\n=ZwxH\n-----END PGP SIGNATURE-----\n", "payload": "tree e3a55900003e38b0cbf9e63b9eefaff69d4feca7\nparent aa896f30bb7f848b8becf54b614b8eadcef22a26\nparent 871338c3aed87cb84f02ebd7fd9b447966d5b05d\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1550108477 +0100\ncommitter GitHub <noreply@github.com> 1550108477 +0100\n\nRollup merge of #57992 - Matthias247:waker4, r=cramertj\n\nUpdate the future/task API\n\nThis change updates the future and task API as discussed in the stabilization RFC at https://github.com/rust-lang/rfcs/pull/2592.\n\nChanges:\n- Replacing UnsafeWake with RawWaker and RawWakerVtable\n- Removal of LocalWaker\n- Removal of Arc-based Wake trait\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/919cf42feb30238fc5d0a74e7a576551f3468bba", "html_url": "https://github.com/rust-lang/rust/commit/919cf42feb30238fc5d0a74e7a576551f3468bba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/919cf42feb30238fc5d0a74e7a576551f3468bba/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa896f30bb7f848b8becf54b614b8eadcef22a26", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa896f30bb7f848b8becf54b614b8eadcef22a26", "html_url": "https://github.com/rust-lang/rust/commit/aa896f30bb7f848b8becf54b614b8eadcef22a26"}, {"sha": "871338c3aed87cb84f02ebd7fd9b447966d5b05d", "url": "https://api.github.com/repos/rust-lang/rust/commits/871338c3aed87cb84f02ebd7fd9b447966d5b05d", "html_url": "https://github.com/rust-lang/rust/commit/871338c3aed87cb84f02ebd7fd9b447966d5b05d"}], "stats": {"total": 709, "additions": 239, "deletions": 470}, "files": [{"sha": "51549f92d4dbf02e50a2a48c21ff8339988c2e3b", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=919cf42feb30238fc5d0a74e7a576551f3468bba", "patch": "@@ -71,7 +71,7 @@ use core::ops::{\n     CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Receiver, Generator, GeneratorState\n };\n use core::ptr::{self, NonNull, Unique};\n-use core::task::{LocalWaker, Poll};\n+use core::task::{Waker, Poll};\n \n use crate::vec::Vec;\n use crate::raw_vec::RawVec;\n@@ -896,7 +896,7 @@ impl<G: ?Sized + Generator> Generator for Pin<Box<G>> {\n impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n     type Output = F::Output;\n \n-    fn poll(mut self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        F::poll(Pin::new(&mut *self), lw)\n+    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut *self), waker)\n     }\n }"}, {"sha": "95b9dacf8565aa5ea9357e26bded9031129ac3d6", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=919cf42feb30238fc5d0a74e7a576551f3468bba", "patch": "@@ -132,10 +132,6 @@ mod macros;\n \n pub mod alloc;\n \n-#[unstable(feature = \"futures_api\",\n-           reason = \"futures in libcore are unstable\",\n-           issue = \"50547\")]\n-pub mod task;\n // Primitive types using the heaps above\n \n // Need to conditionally define the mod from `boxed.rs` to avoid"}, {"sha": "2261dabe2779af4b35d35107db0db391023b879d", "filename": "src/liballoc/task.rs", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/aa896f30bb7f848b8becf54b614b8eadcef22a26/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa896f30bb7f848b8becf54b614b8eadcef22a26/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=aa896f30bb7f848b8becf54b614b8eadcef22a26", "patch": "@@ -1,130 +0,0 @@\n-//! Types and Traits for working with asynchronous tasks.\n-\n-pub use core::task::*;\n-\n-#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n-pub use if_arc::*;\n-\n-#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n-mod if_arc {\n-    use super::*;\n-    use core::marker::PhantomData;\n-    use core::mem;\n-    use core::ptr::{self, NonNull};\n-    use crate::sync::Arc;\n-\n-    /// A way of waking up a specific task.\n-    ///\n-    /// Any task executor must provide a way of signaling that a task it owns\n-    /// is ready to be `poll`ed again. Executors do so by implementing this trait.\n-    pub trait Wake: Send + Sync {\n-        /// Indicates that the associated task is ready to make progress and should\n-        /// be `poll`ed.\n-        ///\n-        /// Executors generally maintain a queue of \"ready\" tasks; `wake` should place\n-        /// the associated task onto this queue.\n-        fn wake(arc_self: &Arc<Self>);\n-\n-        /// Indicates that the associated task is ready to make progress and should\n-        /// be `poll`ed. This function is like `wake`, but can only be called from the\n-        /// thread on which this `Wake` was created.\n-        ///\n-        /// Executors generally maintain a queue of \"ready\" tasks; `wake_local` should place\n-        /// the associated task onto this queue.\n-        #[inline]\n-        unsafe fn wake_local(arc_self: &Arc<Self>) {\n-            Self::wake(arc_self);\n-        }\n-    }\n-\n-    #[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n-    struct ArcWrapped<T>(PhantomData<T>);\n-\n-    unsafe impl<T: Wake + 'static> UnsafeWake for ArcWrapped<T> {\n-        #[inline]\n-        unsafe fn clone_raw(&self) -> Waker {\n-            let me: *const ArcWrapped<T> = self;\n-            let arc = (*(&me as *const *const ArcWrapped<T> as *const Arc<T>)).clone();\n-            Waker::from(arc)\n-        }\n-\n-        #[inline]\n-        unsafe fn drop_raw(&self) {\n-            let mut me: *const ArcWrapped<T> = self;\n-            let me = &mut me as *mut *const ArcWrapped<T> as *mut Arc<T>;\n-            ptr::drop_in_place(me);\n-        }\n-\n-        #[inline]\n-        unsafe fn wake(&self) {\n-            let me: *const ArcWrapped<T> = self;\n-            T::wake(&*(&me as *const *const ArcWrapped<T> as *const Arc<T>))\n-        }\n-\n-        #[inline]\n-        unsafe fn wake_local(&self) {\n-            let me: *const ArcWrapped<T> = self;\n-            T::wake_local(&*(&me as *const *const ArcWrapped<T> as *const Arc<T>))\n-        }\n-    }\n-\n-    impl<T> From<Arc<T>> for Waker\n-        where T: Wake + 'static,\n-    {\n-        fn from(rc: Arc<T>) -> Self {\n-            unsafe {\n-                let ptr = mem::transmute::<Arc<T>, NonNull<ArcWrapped<T>>>(rc);\n-                Waker::new(ptr)\n-            }\n-        }\n-    }\n-\n-    /// Creates a `LocalWaker` from a local `wake`.\n-    ///\n-    /// This function requires that `wake` is \"local\" (created on the current thread).\n-    /// The resulting `LocalWaker` will call `wake.wake_local()` when awoken, and\n-    /// will call `wake.wake()` if awoken after being converted to a `Waker`.\n-    #[inline]\n-    pub unsafe fn local_waker<W: Wake + 'static>(wake: Arc<W>) -> LocalWaker {\n-        let ptr = mem::transmute::<Arc<W>, NonNull<ArcWrapped<W>>>(wake);\n-        LocalWaker::new(ptr)\n-    }\n-\n-    struct NonLocalAsLocal<T>(ArcWrapped<T>);\n-\n-    unsafe impl<T: Wake + 'static> UnsafeWake for NonLocalAsLocal<T> {\n-        #[inline]\n-        unsafe fn clone_raw(&self) -> Waker {\n-            self.0.clone_raw()\n-        }\n-\n-        #[inline]\n-        unsafe fn drop_raw(&self) {\n-            self.0.drop_raw()\n-        }\n-\n-        #[inline]\n-        unsafe fn wake(&self) {\n-            self.0.wake()\n-        }\n-\n-        #[inline]\n-        unsafe fn wake_local(&self) {\n-            // Since we're nonlocal, we can't call wake_local\n-            self.0.wake()\n-        }\n-    }\n-\n-    /// Creates a `LocalWaker` from a non-local `wake`.\n-    ///\n-    /// This function is similar to `local_waker`, but does not require that `wake`\n-    /// is local to the current thread. The resulting `LocalWaker` will call\n-    /// `wake.wake()` when awoken.\n-    #[inline]\n-    pub fn local_waker_from_nonlocal<W: Wake + 'static>(wake: Arc<W>) -> LocalWaker {\n-        unsafe {\n-            let ptr = mem::transmute::<Arc<W>, NonNull<NonLocalAsLocal<W>>>(wake);\n-            LocalWaker::new(ptr)\n-        }\n-    }\n-}"}, {"sha": "02457e00054c8eb0f19f8d95a1d9a2300f53f942", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=919cf42feb30238fc5d0a74e7a576551f3468bba", "patch": "@@ -5,7 +5,7 @@\n use marker::Unpin;\n use ops;\n use pin::Pin;\n-use task::{Poll, LocalWaker};\n+use task::{Poll, Waker};\n \n /// A future represents an asynchronous computation.\n ///\n@@ -19,13 +19,14 @@ use task::{Poll, LocalWaker};\n /// final value. This method does not block if the value is not ready. Instead,\n /// the current task is scheduled to be woken up when it's possible to make\n /// further progress by `poll`ing again. The wake up is performed using\n-/// `cx.waker()`, a handle for waking up the current task.\n+/// the `waker` argument of the `poll()` method, which is a handle for waking\n+/// up the current task.\n ///\n /// When using a future, you generally won't call `poll` directly, but instead\n /// `await!` the value.\n #[must_use = \"futures do nothing unless polled\"]\n pub trait Future {\n-    /// The result of the `Future`.\n+    /// The type of value produced on completion.\n     type Output;\n \n     /// Attempt to resolve the future to a final value, registering\n@@ -42,16 +43,16 @@ pub trait Future {\n     /// Once a future has finished, clients should not `poll` it again.\n     ///\n     /// When a future is not ready yet, `poll` returns `Poll::Pending` and\n-    /// stores a clone of the [`LocalWaker`] to be woken once the future can\n+    /// stores a clone of the [`Waker`] to be woken once the future can\n     /// make progress. For example, a future waiting for a socket to become\n-    /// readable would call `.clone()` on the [`LocalWaker`] and store it.\n+    /// readable would call `.clone()` on the [`Waker`] and store it.\n     /// When a signal arrives elsewhere indicating that the socket is readable,\n-    /// `[LocalWaker::wake]` is called and the socket future's task is awoken.\n+    /// `[Waker::wake]` is called and the socket future's task is awoken.\n     /// Once a task has been woken up, it should attempt to `poll` the future\n     /// again, which may or may not produce a final value.\n     ///\n     /// Note that on multiple calls to `poll`, only the most recent\n-    /// [`LocalWaker`] passed to `poll` should be scheduled to receive a\n+    /// [`Waker`] passed to `poll` should be scheduled to receive a\n     /// wakeup.\n     ///\n     /// # Runtime characteristics\n@@ -67,44 +68,35 @@ pub trait Future {\n     /// typically do *not* suffer the same problems of \"all wakeups must poll\n     /// all events\"; they are more like `epoll(4)`.\n     ///\n-    /// An implementation of `poll` should strive to return quickly, and must\n-    /// *never* block. Returning quickly prevents unnecessarily clogging up\n+    /// An implementation of `poll` should strive to return quickly, and should\n+    /// not block. Returning quickly prevents unnecessarily clogging up\n     /// threads or event loops. If it is known ahead of time that a call to\n     /// `poll` may end up taking awhile, the work should be offloaded to a\n     /// thread pool (or something similar) to ensure that `poll` can return\n     /// quickly.\n     ///\n-    /// # [`LocalWaker`], [`Waker`] and thread-safety\n-    ///\n-    /// The `poll` function takes a [`LocalWaker`], an object which knows how to\n-    /// awaken the current task. [`LocalWaker`] is not `Send` nor `Sync`, so in\n-    /// order to make thread-safe futures the [`LocalWaker::into_waker`] method\n-    /// should be used to convert the [`LocalWaker`] into a thread-safe version.\n-    /// [`LocalWaker::wake`] implementations have the ability to be more\n-    /// efficient, however, so when thread safety is not necessary,\n-    /// [`LocalWaker`] should be preferred.\n+    /// An implementation of `poll` may also never cause memory unsafety.\n     ///\n     /// # Panics\n     ///\n     /// Once a future has completed (returned `Ready` from `poll`),\n     /// then any future calls to `poll` may panic, block forever, or otherwise\n-    /// cause bad behavior. The `Future` trait itself provides no guarantees\n-    /// about the behavior of `poll` after a future has completed.\n+    /// cause any kind of bad behavior expect causing memory unsafety.\n+    /// The `Future` trait itself provides no guarantees about the behavior\n+    /// of `poll` after a future has completed.\n     ///\n     /// [`Poll::Pending`]: ../task/enum.Poll.html#variant.Pending\n     /// [`Poll::Ready(val)`]: ../task/enum.Poll.html#variant.Ready\n-    /// [`LocalWaker`]: ../task/struct.LocalWaker.html\n-    /// [`LocalWaker::into_waker`]: ../task/struct.LocalWaker.html#method.into_waker\n-    /// [`LocalWaker::wake`]: ../task/struct.LocalWaker.html#method.wake\n     /// [`Waker`]: ../task/struct.Waker.html\n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output>;\n+    /// [`Waker::wake`]: ../task/struct.Waker.html#method.wake\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output>;\n }\n \n impl<'a, F: ?Sized + Future + Unpin> Future for &'a mut F {\n     type Output = F::Output;\n \n-    fn poll(mut self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        F::poll(Pin::new(&mut **self), lw)\n+    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut **self), waker)\n     }\n }\n \n@@ -115,7 +107,7 @@ where\n {\n     type Output = <<P as ops::Deref>::Target as Future>::Output;\n \n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        Pin::get_mut(self).as_mut().poll(lw)\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        Pin::get_mut(self).as_mut().poll(waker)\n     }\n }"}, {"sha": "9b8f59811620083edf04be7e8cb1b8795d2d1253", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=919cf42feb30238fc5d0a74e7a576551f3468bba", "patch": "@@ -8,4 +8,4 @@ mod poll;\n pub use self::poll::Poll;\n \n mod wake;\n-pub use self::wake::{Waker, LocalWaker, UnsafeWake};\n+pub use self::wake::{Waker, RawWaker, RawWakerVTable};"}, {"sha": "21f0a8cea4168a87667a3aa571545aa92091a4d5", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 112, "deletions": 234, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=919cf42feb30238fc5d0a74e7a576551f3468bba", "patch": "@@ -4,281 +4,159 @@\n \n use fmt;\n use marker::Unpin;\n-use ptr::NonNull;\n+\n+/// A `RawWaker` allows the implementor of a task executor to create a [`Waker`]\n+/// which provides customized wakeup behavior.\n+///\n+/// [vtable]: https://en.wikipedia.org/wiki/Virtual_method_table\n+///\n+/// It consists of a data pointer and a [virtual function pointer table (vtable)][vtable] that\n+/// customizes the behavior of the `RawWaker`.\n+#[derive(PartialEq, Debug)]\n+pub struct RawWaker {\n+    /// A data pointer, which can be used to store arbitrary data as required\n+    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`\n+    /// that is associated with the task.\n+    /// The value of this field gets passed to all functions that are part of\n+    /// the vtable as the first parameter.\n+    data: *const (),\n+    /// Virtual function pointer table that customizes the behavior of this waker.\n+    vtable: &'static RawWakerVTable,\n+}\n+\n+impl RawWaker {\n+    /// Creates a new `RawWaker` from the provided `data` pointer and `vtable`.\n+    ///\n+    /// The `data` pointer can be used to store arbitrary data as required\n+    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`\n+    /// that is associated with the task.\n+    /// The value of this poiner will get passed to all functions that are part\n+    /// of the `vtable` as the first parameter.\n+    ///\n+    /// The `vtable` customizes the behavior of a `Waker` which gets created\n+    /// from a `RawWaker`. For each operation on the `Waker`, the associated\n+    /// function in the `vtable` of the underlying `RawWaker` will be called.\n+    pub const fn new(data: *const (), vtable: &'static RawWakerVTable) -> RawWaker {\n+        RawWaker {\n+            data,\n+            vtable,\n+        }\n+    }\n+}\n+\n+/// A virtual function pointer table (vtable) that specifies the behavior\n+/// of a [`RawWaker`].\n+///\n+/// The pointer passed to all functions inside the vtable is the `data` pointer\n+/// from the enclosing [`RawWaker`] object.\n+///\n+/// The functions inside this struct are only intended be called on the `data`\n+/// pointer of a properly constructed [`RawWaker`] object from inside the\n+/// [`RawWaker`] implementation. Calling one of the contained functions using\n+/// any other `data` pointer will cause undefined behavior.\n+#[derive(PartialEq, Copy, Clone, Debug)]\n+pub struct RawWakerVTable {\n+    /// This function will be called when the [`RawWaker`] gets cloned, e.g. when\n+    /// the [`Waker`] in which the [`RawWaker`] is stored gets cloned.\n+    ///\n+    /// The implementation of this function must retain all resources that are\n+    /// required for this additional instance of a [`RawWaker`] and associated\n+    /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup\n+    /// of the same task that would have been awoken by the original [`RawWaker`].\n+    pub clone: unsafe fn(*const ()) -> RawWaker,\n+\n+    /// This function will be called when `wake` is called on the [`Waker`].\n+    /// It must wake up the task associated with this [`RawWaker`].\n+    ///\n+    /// The implemention of this function must not consume the provided data\n+    /// pointer.\n+    pub wake: unsafe fn(*const ()),\n+\n+    /// This function gets called when a [`RawWaker`] gets dropped.\n+    ///\n+    /// The implementation of this function must make sure to release any\n+    /// resources that are associated with this instance of a [`RawWaker`] and\n+    /// associated task.\n+    pub drop: unsafe fn(*const ()),\n+}\n \n /// A `Waker` is a handle for waking up a task by notifying its executor that it\n /// is ready to be run.\n ///\n-/// This handle contains a trait object pointing to an instance of the `UnsafeWake`\n-/// trait, allowing notifications to get routed through it.\n+/// This handle encapsulates a [`RawWaker`] instance, which defines the\n+/// executor-specific wakeup behavior.\n+///\n+/// Implements [`Clone`], [`Send`], and [`Sync`].\n #[repr(transparent)]\n pub struct Waker {\n-    inner: NonNull<dyn UnsafeWake>,\n+    waker: RawWaker,\n }\n \n impl Unpin for Waker {}\n unsafe impl Send for Waker {}\n unsafe impl Sync for Waker {}\n \n impl Waker {\n-    /// Constructs a new `Waker` directly.\n-    ///\n-    /// Note that most code will not need to call this. Implementers of the\n-    /// `UnsafeWake` trait will typically provide a wrapper that calls this\n-    /// but you otherwise shouldn't call it directly.\n-    ///\n-    /// If you're working with the standard library then it's recommended to\n-    /// use the `Waker::from` function instead which works with the safe\n-    /// `Arc` type and the safe `Wake` trait.\n-    #[inline]\n-    pub unsafe fn new(inner: NonNull<dyn UnsafeWake>) -> Self {\n-        Waker { inner }\n-    }\n-\n     /// Wake up the task associated with this `Waker`.\n-    #[inline]\n     pub fn wake(&self) {\n-        unsafe { self.inner.as_ref().wake() }\n+        // The actual wakeup call is delegated through a virtual function call\n+        // to the implementation which is defined by the executor.\n+\n+        // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+        // to initialize `wake` and `data` requiring the user to acknowledge\n+        // that the contract of `RawWaker` is upheld.\n+        unsafe { (self.waker.vtable.wake)(self.waker.data) }\n     }\n \n-    /// Returns `true` if or not this `Waker` and `other` awaken the same task.\n+    /// Returns whether or not this `Waker` and other `Waker` have awaken the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n     /// when the `Waker`s would awaken the same task. However, if this function\n-    /// returns `true`, it is guaranteed that the `Waker`s will awaken the same\n-    /// task.\n+    /// returns `true`, it is guaranteed that the `Waker`s will awaken the same task.\n     ///\n     /// This function is primarily used for optimization purposes.\n-    #[inline]\n     pub fn will_wake(&self, other: &Waker) -> bool {\n-        self.inner == other.inner\n+        self.waker == other.waker\n     }\n \n-    /// Returns `true` if or not this `Waker` and `other` `LocalWaker` awaken\n-    /// the same task.\n+    /// Creates a new `Waker` from [`RawWaker`].\n     ///\n-    /// This function works on a best-effort basis, and may return false even\n-    /// when the `Waker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `Waker`s will awaken the same\n-    /// task.\n-    ///\n-    /// This function is primarily used for optimization purposes.\n-    #[inline]\n-    pub fn will_wake_local(&self, other: &LocalWaker) -> bool {\n-        self.will_wake(&other.0)\n+    /// The behavior of the returned `Waker` is undefined if the contract defined\n+    /// in [`RawWaker`]'s and [`RawWakerVTable`]'s documentation is not upheld.\n+    /// Therefore this method is unsafe.\n+    pub unsafe fn new_unchecked(waker: RawWaker) -> Waker {\n+        Waker {\n+            waker,\n+        }\n     }\n }\n \n impl Clone for Waker {\n-    #[inline]\n     fn clone(&self) -> Self {\n-        unsafe {\n-            self.inner.as_ref().clone_raw()\n+        Waker {\n+            // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+            // to initialize `clone` and `data` requiring the user to acknowledge\n+            // that the contract of [`RawWaker`] is upheld.\n+            waker: unsafe { (self.waker.vtable.clone)(self.waker.data) },\n         }\n     }\n }\n \n-impl fmt::Debug for Waker {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Waker\")\n-            .finish()\n-    }\n-}\n-\n impl Drop for Waker {\n-    #[inline]\n     fn drop(&mut self) {\n-        unsafe {\n-            self.inner.as_ref().drop_raw()\n-        }\n-    }\n-}\n-\n-/// A `LocalWaker` is a handle for waking up a task by notifying its executor that it\n-/// is ready to be run.\n-///\n-/// This is similar to the `Waker` type, but cannot be sent across threads.\n-/// Task executors can use this type to implement more optimized single-threaded wakeup\n-/// behavior.\n-#[repr(transparent)]\n-#[derive(Clone)]\n-pub struct LocalWaker(Waker);\n-\n-impl Unpin for LocalWaker {}\n-impl !Send for LocalWaker {}\n-impl !Sync for LocalWaker {}\n-\n-impl LocalWaker {\n-    /// Constructs a new `LocalWaker` directly.\n-    ///\n-    /// Note that most code will not need to call this. Implementers of the\n-    /// `UnsafeWake` trait will typically provide a wrapper that calls this\n-    /// but you otherwise shouldn't call it directly.\n-    ///\n-    /// If you're working with the standard library then it's recommended to\n-    /// use the `local_waker_from_nonlocal` or `local_waker` to convert a `Waker`\n-    /// into a `LocalWaker`.\n-    ///\n-    /// For this function to be used safely, it must be sound to call `inner.wake_local()`\n-    /// on the current thread.\n-    #[inline]\n-    pub unsafe fn new(inner: NonNull<dyn UnsafeWake>) -> Self {\n-        LocalWaker(Waker::new(inner))\n-    }\n-\n-    /// Borrows this `LocalWaker` as a `Waker`.\n-    ///\n-    /// `Waker` is nearly identical to `LocalWaker`, but is threadsafe\n-    /// (implements `Send` and `Sync`).\n-    #[inline]\n-    pub fn as_waker(&self) -> &Waker {\n-        &self.0\n-    }\n-\n-    /// Converts this `LocalWaker` into a `Waker`.\n-    ///\n-    /// `Waker` is nearly identical to `LocalWaker`, but is threadsafe\n-    /// (implements `Send` and `Sync`).\n-    #[inline]\n-    pub fn into_waker(self) -> Waker {\n-        self.0\n-    }\n-\n-    /// Wake up the task associated with this `LocalWaker`.\n-    #[inline]\n-    pub fn wake(&self) {\n-        unsafe { self.0.inner.as_ref().wake_local() }\n-    }\n-\n-    /// Returns `true` if or not this `LocalWaker` and `other` `LocalWaker` awaken the same task.\n-    ///\n-    /// This function works on a best-effort basis, and may return false even\n-    /// when the `LocalWaker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `LocalWaker`s will awaken the same\n-    /// task.\n-    ///\n-    /// This function is primarily used for optimization purposes.\n-    #[inline]\n-    pub fn will_wake(&self, other: &LocalWaker) -> bool {\n-        self.0.will_wake(&other.0)\n-    }\n-\n-    /// Returns `true` if or not this `LocalWaker` and `other` `Waker` awaken the same task.\n-    ///\n-    /// This function works on a best-effort basis, and may return false even\n-    /// when the `Waker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `LocalWaker`s will awaken the same\n-    /// task.\n-    ///\n-    /// This function is primarily used for optimization purposes.\n-    #[inline]\n-    pub fn will_wake_nonlocal(&self, other: &Waker) -> bool {\n-        self.0.will_wake(other)\n-    }\n-}\n-\n-impl From<LocalWaker> for Waker {\n-    /// Converts a `LocalWaker` into a `Waker`.\n-    ///\n-    /// This conversion turns a `!Sync` `LocalWaker` into a `Sync` `Waker`, allowing a wakeup\n-    /// object to be sent to another thread, but giving up its ability to do specialized\n-    /// thread-local wakeup behavior.\n-    #[inline]\n-    fn from(local_waker: LocalWaker) -> Self {\n-        local_waker.0\n+        // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+        // to initialize `drop` and `data` requiring the user to acknowledge\n+        // that the contract of `RawWaker` is upheld.\n+        unsafe { (self.waker.vtable.drop)(self.waker.data) }\n     }\n }\n \n-impl fmt::Debug for LocalWaker {\n+impl fmt::Debug for Waker {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"LocalWaker\")\n+        let vtable_ptr = self.waker.vtable as *const RawWakerVTable;\n+        f.debug_struct(\"Waker\")\n+            .field(\"data\", &self.waker.data)\n+            .field(\"vtable\", &vtable_ptr)\n             .finish()\n     }\n }\n-\n-/// An unsafe trait for implementing custom memory management for a `Waker` or `LocalWaker`.\n-///\n-/// A `Waker` conceptually is a cloneable trait object for `Wake`, and is\n-/// most often essentially just `Arc<dyn Wake>`. However, in some contexts\n-/// (particularly `no_std`), it's desirable to avoid `Arc` in favor of some\n-/// custom memory management strategy. This trait is designed to allow for such\n-/// customization.\n-///\n-/// When using `std`, a default implementation of the `UnsafeWake` trait is provided for\n-/// `Arc<T>` where `T: Wake`.\n-pub unsafe trait UnsafeWake: Send + Sync {\n-    /// Creates a clone of this `UnsafeWake` and stores it behind a `Waker`.\n-    ///\n-    /// This function will create a new uniquely owned handle that under the\n-    /// hood references the same notification instance. In other words calls\n-    /// to `wake` on the returned handle should be equivalent to calls to\n-    /// `wake` on this handle.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped.\n-    unsafe fn clone_raw(&self) -> Waker;\n-\n-    /// Drops this instance of `UnsafeWake`, deallocating resources\n-    /// associated with it.\n-    ///\n-    // FIXME(cramertj):\n-    /// This method is intended to have a signature such as:\n-    ///\n-    /// ```ignore (not-a-doctest)\n-    /// fn drop_raw(self: *mut Self);\n-    /// ```\n-    ///\n-    /// Unfortunately, in Rust today that signature is not object safe.\n-    /// Nevertheless it's recommended to implement this function *as if* that\n-    /// were its signature. As such it is not safe to call on an invalid\n-    /// pointer, nor is the validity of the pointer guaranteed after this\n-    /// function returns.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped.\n-    unsafe fn drop_raw(&self);\n-\n-    /// Indicates that the associated task is ready to make progress and should\n-    /// be `poll`ed.\n-    ///\n-    /// Executors generally maintain a queue of \"ready\" tasks; `wake` should place\n-    /// the associated task onto this queue.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Implementations should avoid panicking, but clients should also be prepared\n-    /// for panics.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped.\n-    unsafe fn wake(&self);\n-\n-    /// Indicates that the associated task is ready to make progress and should\n-    /// be `poll`ed. This function is the same as `wake`, but can only be called\n-    /// from the thread that this `UnsafeWake` is \"local\" to. This allows for\n-    /// implementors to provide specialized wakeup behavior specific to the current\n-    /// thread. This function is called by `LocalWaker::wake`.\n-    ///\n-    /// Executors generally maintain a queue of \"ready\" tasks; `wake_local` should place\n-    /// the associated task onto this queue.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Implementations should avoid panicking, but clients should also be prepared\n-    /// for panics.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped, and that the\n-    /// `UnsafeWake` hasn't moved from the thread on which it was created.\n-    unsafe fn wake_local(&self) {\n-        self.wake()\n-    }\n-}"}, {"sha": "aa784746122db71e82ccc8896d491d67a2587333", "filename": "src/libstd/future.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=919cf42feb30238fc5d0a74e7a576551f3468bba", "patch": "@@ -5,7 +5,7 @@ use core::marker::Unpin;\n use core::pin::Pin;\n use core::option::Option;\n use core::ptr::NonNull;\n-use core::task::{LocalWaker, Poll};\n+use core::task::{Waker, Poll};\n use core::ops::{Drop, Generator, GeneratorState};\n \n #[doc(inline)]\n@@ -32,21 +32,21 @@ impl<T: Generator<Yield = ()>> !Unpin for GenFuture<T> {}\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n     type Output = T::Return;\n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n         // Safe because we're !Unpin + !Drop mapping to a ?Unpin value\n         let gen = unsafe { Pin::map_unchecked_mut(self, |s| &mut s.0) };\n-        set_task_waker(lw, || match gen.resume() {\n+        set_task_waker(waker, || match gen.resume() {\n             GeneratorState::Yielded(()) => Poll::Pending,\n             GeneratorState::Complete(x) => Poll::Ready(x),\n         })\n     }\n }\n \n thread_local! {\n-    static TLS_WAKER: Cell<Option<NonNull<LocalWaker>>> = Cell::new(None);\n+    static TLS_WAKER: Cell<Option<NonNull<Waker>>> = Cell::new(None);\n }\n \n-struct SetOnDrop(Option<NonNull<LocalWaker>>);\n+struct SetOnDrop(Option<NonNull<Waker>>);\n \n impl Drop for SetOnDrop {\n     fn drop(&mut self) {\n@@ -58,12 +58,12 @@ impl Drop for SetOnDrop {\n \n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n /// Sets the thread-local task context used by async/await futures.\n-pub fn set_task_waker<F, R>(lw: &LocalWaker, f: F) -> R\n+pub fn set_task_waker<F, R>(waker: &Waker, f: F) -> R\n where\n     F: FnOnce() -> R\n {\n     let old_waker = TLS_WAKER.with(|tls_waker| {\n-        tls_waker.replace(Some(NonNull::from(lw)))\n+        tls_waker.replace(Some(NonNull::from(waker)))\n     });\n     let _reset_waker = SetOnDrop(old_waker);\n     f()\n@@ -78,7 +78,7 @@ where\n /// retrieved by a surrounding call to get_task_waker.\n pub fn get_task_waker<F, R>(f: F) -> R\n where\n-    F: FnOnce(&LocalWaker) -> R\n+    F: FnOnce(&Waker) -> R\n {\n     let waker_ptr = TLS_WAKER.with(|tls_waker| {\n         // Clear the entry so that nested `get_task_waker` calls\n@@ -88,7 +88,7 @@ where\n     let _reset_waker = SetOnDrop(waker_ptr);\n \n     let waker_ptr = waker_ptr.expect(\n-        \"TLS LocalWaker not set. This is a rustc bug. \\\n+        \"TLS Waker not set. This is a rustc bug. \\\n         Please file an issue on https://github.com/rust-lang/rust.\");\n     unsafe { f(waker_ptr.as_ref()) }\n }\n@@ -99,5 +99,5 @@ pub fn poll_with_tls_waker<F>(f: Pin<&mut F>) -> Poll<F::Output>\n where\n     F: Future\n {\n-    get_task_waker(|lw| F::poll(f, lw))\n+    get_task_waker(|waker| F::poll(f, waker))\n }"}, {"sha": "4f900e8cbad2d17be96337255645854191900459", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=919cf42feb30238fc5d0a74e7a576551f3468bba", "patch": "@@ -463,8 +463,6 @@ pub mod task {\n     //! Types and Traits for working with asynchronous tasks.\n     #[doc(inline)]\n     pub use core::task::*;\n-    #[doc(inline)]\n-    pub use alloc_crate::task::*;\n }\n \n #[unstable(feature = \"futures_api\","}, {"sha": "862fdf051ccd10b1d6344c4802c18ed94246fba5", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=919cf42feb30238fc5d0a74e7a576551f3468bba", "patch": "@@ -12,7 +12,7 @@ use panicking;\n use ptr::{Unique, NonNull};\n use rc::Rc;\n use sync::{Arc, Mutex, RwLock, atomic};\n-use task::{LocalWaker, Poll};\n+use task::{Waker, Poll};\n use thread::Result;\n \n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n@@ -323,9 +323,9 @@ impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n impl<'a, F: Future> Future for AssertUnwindSafe<F> {\n     type Output = F::Output;\n \n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n         let pinned_field = unsafe { Pin::map_unchecked_mut(self, |x| &mut x.0) };\n-        F::poll(pinned_field, lw)\n+        F::poll(pinned_field, waker)\n     }\n }\n "}, {"sha": "b4f07ab33214cca85abd97673399deeaea057a9d", "filename": "src/test/compile-fail/must_use-in-stdlib-traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs?ref=919cf42feb30238fc5d0a74e7a576551f3468bba", "patch": "@@ -4,7 +4,7 @@\n use std::iter::Iterator;\n use std::future::Future;\n \n-use std::task::{Poll, LocalWaker};\n+use std::task::{Poll, Waker};\n use std::pin::Pin;\n use std::unimplemented;\n \n@@ -13,7 +13,7 @@ struct MyFuture;\n impl Future for MyFuture {\n    type Output = u32;\n \n-   fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<u32> {\n+   fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<u32> {\n       Poll::Pending\n    }\n }"}, {"sha": "1843feed927a23ede730677397cdf7196c78b8a8", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=919cf42feb30238fc5d0a74e7a576551f3468bba", "patch": "@@ -1,25 +1,28 @@\n // edition:2018\n+// aux-build:arc_wake.rs\n \n #![feature(arbitrary_self_types, async_await, await_macro, futures_api)]\n \n+extern crate arc_wake;\n+\n use std::pin::Pin;\n use std::future::Future;\n use std::sync::{\n     Arc,\n     atomic::{self, AtomicUsize},\n };\n use std::task::{\n-    LocalWaker, Poll, Wake,\n-    local_waker_from_nonlocal,\n+    Poll, Waker,\n };\n+use arc_wake::ArcWake;\n \n struct Counter {\n     wakes: AtomicUsize,\n }\n \n-impl Wake for Counter {\n-    fn wake(this: &Arc<Self>) {\n-        this.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n+impl ArcWake for Counter {\n+    fn wake(arc_self: &Arc<Self>) {\n+        arc_self.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n     }\n }\n \n@@ -29,11 +32,11 @@ fn wake_and_yield_once() -> WakeOnceThenComplete { WakeOnceThenComplete(false) }\n \n impl Future for WakeOnceThenComplete {\n     type Output = ();\n-    fn poll(mut self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<()> {\n+    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<()> {\n         if self.0 {\n             Poll::Ready(())\n         } else {\n-            lw.wake();\n+            waker.wake();\n             self.0 = true;\n             Poll::Pending\n         }\n@@ -130,7 +133,7 @@ where\n {\n     let mut fut = Box::pin(f(9));\n     let counter = Arc::new(Counter { wakes: AtomicUsize::new(0) });\n-    let waker = local_waker_from_nonlocal(counter.clone());\n+    let waker = ArcWake::into_waker(counter.clone());\n     assert_eq!(0, counter.wakes.load(atomic::Ordering::SeqCst));\n     assert_eq!(Poll::Pending, fut.as_mut().poll(&waker));\n     assert_eq!(1, counter.wakes.load(atomic::Ordering::SeqCst));"}, {"sha": "034e378af7f19267fab999cfd1852bbc4db8b06a", "filename": "src/test/run-pass/auxiliary/arc_wake.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs?ref=919cf42feb30238fc5d0a74e7a576551f3468bba", "patch": "@@ -0,0 +1,56 @@\n+// edition:2018\n+\n+#![feature(arbitrary_self_types, futures_api)]\n+\n+use std::sync::Arc;\n+use std::task::{\n+    Poll, Waker, RawWaker, RawWakerVTable,\n+};\n+\n+macro_rules! waker_vtable {\n+    ($ty:ident) => {\n+        &RawWakerVTable {\n+            clone: clone_arc_raw::<$ty>,\n+            drop: drop_arc_raw::<$ty>,\n+            wake: wake_arc_raw::<$ty>,\n+        }\n+    };\n+}\n+\n+pub trait ArcWake {\n+    fn wake(arc_self: &Arc<Self>);\n+\n+    fn into_waker(wake: Arc<Self>) -> Waker where Self: Sized\n+    {\n+        let ptr = Arc::into_raw(wake) as *const();\n+\n+        unsafe {\n+            Waker::new_unchecked(RawWaker::new(ptr, waker_vtable!(Self)))\n+        }\n+    }\n+}\n+\n+unsafe fn increase_refcount<T: ArcWake>(data: *const()) {\n+    // Retain Arc by creating a copy\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    let arc_clone = arc.clone();\n+    // Forget the Arcs again, so that the refcount isn't decrased\n+    let _ = Arc::into_raw(arc);\n+    let _ = Arc::into_raw(arc_clone);\n+}\n+\n+unsafe fn clone_arc_raw<T: ArcWake>(data: *const()) -> RawWaker {\n+    increase_refcount::<T>(data);\n+    RawWaker::new(data, waker_vtable!(T))\n+}\n+\n+unsafe fn drop_arc_raw<T: ArcWake>(data: *const()) {\n+    // Drop Arc\n+    let _: Arc<T> = Arc::from_raw(data as *const T);\n+}\n+\n+unsafe fn wake_arc_raw<T: ArcWake>(data: *const()) {\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    ArcWake::wake(&arc);\n+    let _ = Arc::into_raw(arc);\n+}"}, {"sha": "fd4b585d3457273026d65391dcf3c03d3981ad36", "filename": "src/test/run-pass/futures-api.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919cf42feb30238fc5d0a74e7a576551f3468bba/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffutures-api.rs?ref=919cf42feb30238fc5d0a74e7a576551f3468bba", "patch": "@@ -1,71 +1,57 @@\n+// aux-build:arc_wake.rs\n+\n #![feature(arbitrary_self_types, futures_api)]\n #![allow(unused)]\n \n+extern crate arc_wake;\n+\n use std::future::Future;\n use std::pin::Pin;\n-use std::rc::Rc;\n use std::sync::{\n     Arc,\n     atomic::{self, AtomicUsize},\n };\n use std::task::{\n-    Poll, Wake, Waker, LocalWaker,\n-    local_waker, local_waker_from_nonlocal,\n+    Poll, Waker,\n };\n+use arc_wake::ArcWake;\n \n struct Counter {\n-    local_wakes: AtomicUsize,\n-    nonlocal_wakes: AtomicUsize,\n+    wakes: AtomicUsize,\n }\n \n-impl Wake for Counter {\n-    fn wake(this: &Arc<Self>) {\n-        this.nonlocal_wakes.fetch_add(1, atomic::Ordering::SeqCst);\n-    }\n-\n-    unsafe fn wake_local(this: &Arc<Self>) {\n-        this.local_wakes.fetch_add(1, atomic::Ordering::SeqCst);\n+impl ArcWake for Counter {\n+    fn wake(arc_self: &Arc<Self>) {\n+        arc_self.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n     }\n }\n \n struct MyFuture;\n \n impl Future for MyFuture {\n     type Output = ();\n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        // Wake once locally\n-        lw.wake();\n-        // Wake twice non-locally\n-        let waker = lw.clone().into_waker();\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        // Wake twice\n         waker.wake();\n         waker.wake();\n         Poll::Ready(())\n     }\n }\n \n-fn test_local_waker() {\n+fn test_waker() {\n     let counter = Arc::new(Counter {\n-        local_wakes: AtomicUsize::new(0),\n-        nonlocal_wakes: AtomicUsize::new(0),\n+        wakes: AtomicUsize::new(0),\n     });\n-    let waker = unsafe { local_waker(counter.clone()) };\n-    assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(&waker));\n-    assert_eq!(1, counter.local_wakes.load(atomic::Ordering::SeqCst));\n-    assert_eq!(2, counter.nonlocal_wakes.load(atomic::Ordering::SeqCst));\n-}\n+    let waker = ArcWake::into_waker(counter.clone());\n+    assert_eq!(2, Arc::strong_count(&counter));\n \n-fn test_local_as_nonlocal_waker() {\n-    let counter = Arc::new(Counter {\n-        local_wakes: AtomicUsize::new(0),\n-        nonlocal_wakes: AtomicUsize::new(0),\n-    });\n-    let waker: LocalWaker = local_waker_from_nonlocal(counter.clone());\n     assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(&waker));\n-    assert_eq!(0, counter.local_wakes.load(atomic::Ordering::SeqCst));\n-    assert_eq!(3, counter.nonlocal_wakes.load(atomic::Ordering::SeqCst));\n+    assert_eq!(2, counter.wakes.load(atomic::Ordering::SeqCst));\n+\n+    drop(waker);\n+    assert_eq!(1, Arc::strong_count(&counter));\n }\n \n fn main() {\n-    test_local_waker();\n-    test_local_as_nonlocal_waker();\n+    test_waker();\n }"}, {"sha": "3a6750151f7d8e138668ac54624c34f9dd8d84f3", "filename": "src/test/rustdoc-js/substring.js", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa896f30bb7f848b8becf54b614b8eadcef22a26/src%2Ftest%2Frustdoc-js%2Fsubstring.js", "raw_url": "https://github.com/rust-lang/rust/raw/aa896f30bb7f848b8becf54b614b8eadcef22a26/src%2Ftest%2Frustdoc-js%2Fsubstring.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fsubstring.js?ref=aa896f30bb7f848b8becf54b614b8eadcef22a26", "patch": "@@ -1,10 +0,0 @@\n-// exact-check\n-\n-const QUERY = 'waker_from';\n-\n-const EXPECTED = {\n-    'others': [\n-        { 'path': 'std::task', 'name': 'local_waker_from_nonlocal' },\n-        { 'path': 'alloc::task', 'name': 'local_waker_from_nonlocal' },\n-    ],\n-};"}]}