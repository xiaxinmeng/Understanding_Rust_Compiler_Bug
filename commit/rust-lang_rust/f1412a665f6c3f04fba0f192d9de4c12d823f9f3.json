{"sha": "f1412a665f6c3f04fba0f192d9de4c12d823f9f3", "node_id": "C_kwDOAAsO6NoAKGYxNDEyYTY2NWY2YzNmMDRmYmEwZjE5MmQ5ZGU0YzEyZDgyM2Y5ZjM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-09-10T13:26:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-10T13:26:08Z"}, "message": "Rollup merge of #101614 - compiler-errors:rpitit-eq, r=jackh726\n\nEquate fn outputs when inferring RPITIT hidden types\n\nWhen we are trying to infer the hidden types for RPITITs, we need to equate the output tys instead of just subtyping them. For example:\n\n```rust\ntrait Foo { fn bar() -> impl Sized {} }\n\nimpl Foo for () { fn bar() -> &'static str { \"\" } }\n```\n\nIf we just subtype the signatures `fn() -> &'static str <: fn() -> _#1t` (where `_#1t` is the variable we've used to infer `impl Sized`), we'll end up `&'static str <: _#1t`, which causes us to infer `_#1t = #'_#2r str`, where `'_#2r` is unconstrained, which gets fixed up to `ReEmpty`, and which is certainly not what we want.\n\nI can't actually think of a way to make this fail to compile, because during borrowck we've already done the method probe, and so we just look at the `impl` method signature and see the `&'static str` any time we call `<() as Foo>::bar()`. But this _does_ cause the ICE [here](https://github.com/rust-lang/rust/pull/98559#issuecomment-1241891994) in `@jackh726's` \"Remove ReEmpty\" PR (#98559) to stop ICEing, because after that PR we were leaking unconstrained region variables into the typeck results.\n\nr? types", "tree": {"sha": "b9c66defc18d3330e4f5bcca9f419feea739122d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9c66defc18d3330e4f5bcca9f419feea739122d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1412a665f6c3f04fba0f192d9de4c12d823f9f3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjHJBwCRBK7hj4Ov3rIwAAFH4IAGUbyKF6DfuuqI7Nq79hEZVj\n7FSImr+JE/4sqfjT1TwIZ3+WrEHeu8E4uGRJzvNlbrO/TquOFPeGIJ3wIlrTboVm\nnr1eqvsM47yU9kuNrHYFcBvmS6BAa6QbgtBmpl8iCCun5GXFsfjJI8peBzRtfwu/\nhvL2HGF8ISFDBfPhaSTPjlGi6M0XMr7ew8Eyp7JWFDdkQHgv9t7DcVni0p0wA+rG\n0R5hOP/AZyUFl2ITaqg2ofCfHYP4jEWQCVnVzFohuugl8uVpAJjDBnhp3aIoDmH4\nqNlEi1YZQNH/NfgJxweaY/3vYdBiIC27bO7ze4YItODkJ4HgH5+KsC3svDkS+RE=\n=h2Tl\n-----END PGP SIGNATURE-----\n", "payload": "tree b9c66defc18d3330e4f5bcca9f419feea739122d\nparent 33d54c4f737a99e8acdec1377fc0f105ad24635d\nparent 022e3fe550406c3fbdb64f241381bc14b1937cfb\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1662816368 +0530\ncommitter GitHub <noreply@github.com> 1662816368 +0530\n\nRollup merge of #101614 - compiler-errors:rpitit-eq, r=jackh726\n\nEquate fn outputs when inferring RPITIT hidden types\n\nWhen we are trying to infer the hidden types for RPITITs, we need to equate the output tys instead of just subtyping them. For example:\n\n```rust\ntrait Foo { fn bar() -> impl Sized {} }\n\nimpl Foo for () { fn bar() -> &'static str { \"\" } }\n```\n\nIf we just subtype the signatures `fn() -> &'static str <: fn() -> _#1t` (where `_#1t` is the variable we've used to infer `impl Sized`), we'll end up `&'static str <: _#1t`, which causes us to infer `_#1t = #'_#2r str`, where `'_#2r` is unconstrained, which gets fixed up to `ReEmpty`, and which is certainly not what we want.\n\nI can't actually think of a way to make this fail to compile, because during borrowck we've already done the method probe, and so we just look at the `impl` method signature and see the `&'static str` any time we call `<() as Foo>::bar()`. But this _does_ cause the ICE [here](https://github.com/rust-lang/rust/pull/98559#issuecomment-1241891994) in `@jackh726's` \"Remove ReEmpty\" PR (#98559) to stop ICEing, because after that PR we were leaking unconstrained region variables into the typeck results.\n\nr? types\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1412a665f6c3f04fba0f192d9de4c12d823f9f3", "html_url": "https://github.com/rust-lang/rust/commit/f1412a665f6c3f04fba0f192d9de4c12d823f9f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1412a665f6c3f04fba0f192d9de4c12d823f9f3/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33d54c4f737a99e8acdec1377fc0f105ad24635d", "url": "https://api.github.com/repos/rust-lang/rust/commits/33d54c4f737a99e8acdec1377fc0f105ad24635d", "html_url": "https://github.com/rust-lang/rust/commit/33d54c4f737a99e8acdec1377fc0f105ad24635d"}, {"sha": "022e3fe550406c3fbdb64f241381bc14b1937cfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/022e3fe550406c3fbdb64f241381bc14b1937cfb", "html_url": "https://github.com/rust-lang/rust/commit/022e3fe550406c3fbdb64f241381bc14b1937cfb"}], "stats": {"total": 19, "additions": 17, "deletions": 2}, "files": [{"sha": "13a96df77b69d51699496629a0e0d9731540fa90", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f1412a665f6c3f04fba0f192d9de4c12d823f9f3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1412a665f6c3f04fba0f192d9de4c12d823f9f3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=f1412a665f6c3f04fba0f192d9de4c12d823f9f3", "patch": "@@ -295,12 +295,26 @@ pub(super) fn compare_predicates_and_trait_impl_trait_tys<'tcx>(\n         // type would be more appropriate. In other places we have a `Vec<Span>`\n         // corresponding to their `Vec<Predicate>`, but we don't have that here.\n         // Fixing this would improve the output of test `issue-83765.rs`.\n-        let sub_result = infcx\n+        let mut result = infcx\n             .at(&cause, param_env)\n             .sup(trait_fty, impl_fty)\n             .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok));\n \n-        if let Err(terr) = sub_result {\n+        // HACK(RPITIT): #101614. When we are trying to infer the hidden types for\n+        // RPITITs, we need to equate the output tys instead of just subtyping. If\n+        // we just use `sup` above, we'll end up `&'static str <: _#1t`, which causes\n+        // us to infer `_#1t = #'_#2r str`, where `'_#2r` is unconstrained, which gets\n+        // fixed up to `ReEmpty`, and which is certainly not what we want.\n+        if trait_fty.has_infer_types() {\n+            result = result.and_then(|()| {\n+                infcx\n+                    .at(&cause, param_env)\n+                    .eq(trait_sig.output(), impl_sig.output())\n+                    .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok))\n+            });\n+        }\n+\n+        if let Err(terr) = result {\n             debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n \n             let (impl_err_span, trait_err_span) =\n@@ -445,6 +459,7 @@ pub(super) fn compare_predicates_and_trait_impl_trait_tys<'tcx>(\n                             region\n                         }\n                     });\n+                    debug!(%ty);\n                     collected_tys.insert(def_id, ty);\n                 }\n                 Err(err) => {"}]}