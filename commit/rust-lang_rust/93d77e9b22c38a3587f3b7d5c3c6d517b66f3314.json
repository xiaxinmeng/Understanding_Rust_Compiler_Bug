{"sha": "93d77e9b22c38a3587f3b7d5c3c6d517b66f3314", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZDc3ZTliMjJjMzhhMzU4N2YzYjdkNWMzYzZkNTE3YjY2ZjMzMTQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-07T08:32:21Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-15T18:12:19Z"}, "message": "remove our own copy of salsa\n\nsalsa-rs/salsa is faster and more type safe", "tree": {"sha": "68176b00f4f17c1fddf4c856f66e4143f5e5db86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68176b00f4f17c1fddf4c856f66e4143f5e5db86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93d77e9b22c38a3587f3b7d5c3c6d517b66f3314", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93d77e9b22c38a3587f3b7d5c3c6d517b66f3314", "html_url": "https://github.com/rust-lang/rust/commit/93d77e9b22c38a3587f3b7d5c3c6d517b66f3314", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93d77e9b22c38a3587f3b7d5c3c6d517b66f3314/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64b879d6a9aa61cf2ebe0154a292aa33e6412745", "url": "https://api.github.com/repos/rust-lang/rust/commits/64b879d6a9aa61cf2ebe0154a292aa33e6412745", "html_url": "https://github.com/rust-lang/rust/commit/64b879d6a9aa61cf2ebe0154a292aa33e6412745"}], "stats": {"total": 471, "additions": 0, "deletions": 471}, "files": [{"sha": "9eb83234f0cbe92f802314002f4aaa198ccfd721", "filename": "crates/salsa/Cargo.toml", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64b879d6a9aa61cf2ebe0154a292aa33e6412745/crates%2Fsalsa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/64b879d6a9aa61cf2ebe0154a292aa33e6412745/crates%2Fsalsa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsalsa%2FCargo.toml?ref=64b879d6a9aa61cf2ebe0154a292aa33e6412745", "patch": "@@ -1,8 +0,0 @@\n-[package]\n-name = \"salsa\"\n-version = \"0.1.0\"\n-authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n-\n-[dependencies]\n-parking_lot = \"0.6.3\"\n-im = \"12.0.0\""}, {"sha": "35deed37417c5ba2559669cd575f02589dfdcd7b", "filename": "crates/salsa/src/lib.rs", "status": "removed", "additions": 0, "deletions": 293, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/64b879d6a9aa61cf2ebe0154a292aa33e6412745/crates%2Fsalsa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b879d6a9aa61cf2ebe0154a292aa33e6412745/crates%2Fsalsa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsalsa%2Fsrc%2Flib.rs?ref=64b879d6a9aa61cf2ebe0154a292aa33e6412745", "patch": "@@ -1,293 +0,0 @@\n-extern crate im;\n-extern crate parking_lot;\n-\n-use std::{\n-    sync::Arc,\n-    collections::{HashSet, HashMap},\n-    cell::RefCell,\n-};\n-use parking_lot::Mutex;\n-\n-pub type GroundQueryFn<T, D> = Box<Fn(&T, &D) -> (D, OutputFingerprint) + Send + Sync + 'static>;\n-pub type QueryFn<T, D> = Box<Fn(&QueryCtx<T, D>, &D) -> (D, OutputFingerprint) + Send + Sync + 'static>;\n-\n-#[derive(Debug)]\n-pub struct Db<T, D> {\n-    db: Arc<DbState<T, D>>,\n-    query_config: Arc<QueryConfig<T, D>>,\n-}\n-\n-pub struct QueryConfig<T, D> {\n-    ground_fn: HashMap<QueryTypeId, GroundQueryFn<T, D>>,\n-    query_fn: HashMap<QueryTypeId, QueryFn<T, D>>,\n-}\n-\n-impl<T, D> ::std::fmt::Debug for QueryConfig<T, D> {\n-    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n-        ::std::fmt::Display::fmt(\"QueryConfig { ... }\", f)\n-    }\n-}\n-\n-#[derive(Debug)]\n-struct DbState<T, D> {\n-    ground_data: T,\n-    gen: Gen,\n-    graph: Mutex<im::HashMap<QueryId, (Gen, Arc<QueryRecord<D>>)>>,\n-}\n-\n-#[derive(Debug)]\n-struct QueryRecord<D> {\n-    params: D,\n-    output: D,\n-    output_fingerprint: OutputFingerprint,\n-    deps: Vec<(QueryId, OutputFingerprint)>,\n-}\n-\n-impl<T, D> DbState<T, D> {\n-    fn record(\n-        &self,\n-        query_id: QueryId,\n-        params: D,\n-        output: D,\n-        output_fingerprint: OutputFingerprint,\n-        deps: Vec<(QueryId, OutputFingerprint)>,\n-    ) {\n-        let gen = self.gen;\n-        let record = QueryRecord {\n-            params,\n-            output,\n-            output_fingerprint,\n-            deps,\n-        };\n-        self.graph.lock().insert(query_id, (gen, Arc::new(record)));\n-    }\n-}\n-\n-impl<T, D> QueryConfig<T, D> {\n-    pub fn new() -> Self {\n-        QueryConfig {\n-            ground_fn: HashMap::new(),\n-            query_fn: HashMap::new(),\n-        }\n-    }\n-    pub fn with_ground_query(\n-        mut self,\n-        query_type: QueryTypeId,\n-        query_fn: GroundQueryFn<T, D>\n-    ) -> Self {\n-        let prev = self.ground_fn.insert(query_type, query_fn);\n-        assert!(prev.is_none());\n-        self\n-    }\n-    pub fn with_query(\n-        mut self,\n-        query_type: QueryTypeId,\n-        query_fn: QueryFn<T, D>,\n-    ) -> Self {\n-        let prev = self.query_fn.insert(query_type, query_fn);\n-        assert!(prev.is_none());\n-        self\n-    }\n-}\n-\n-pub struct QueryCtx<T, D> {\n-    db: Arc<DbState<T, D>>,\n-    query_config: Arc<QueryConfig<T, D>>,\n-    stack: RefCell<Vec<Vec<(QueryId, OutputFingerprint)>>>,\n-    executed: RefCell<Vec<QueryTypeId>>,\n-}\n-\n-impl<T, D> QueryCtx<T, D>\n-where\n-    D: Clone\n-{\n-    fn new(db: &Db<T, D>) -> QueryCtx<T, D> {\n-        QueryCtx {\n-            db: Arc::clone(&db.db),\n-            query_config: Arc::clone(&db.query_config),\n-            stack: RefCell::new(vec![Vec::new()]),\n-            executed: RefCell::new(Vec::new()),\n-        }\n-    }\n-    pub fn get(\n-        &self,\n-        query_id: QueryId,\n-        params: D,\n-    ) -> D {\n-        let (res, output_fingerprint) = self.get_inner(query_id, params);\n-        self.record_dep(query_id, output_fingerprint);\n-        res\n-    }\n-    pub fn trace(&self) -> Vec<QueryTypeId> {\n-        ::std::mem::replace(&mut *self.executed.borrow_mut(), Vec::new())\n-    }\n-\n-    fn get_inner(\n-        &self,\n-        query_id: QueryId,\n-        params: D,\n-    ) -> (D, OutputFingerprint) {\n-        let (gen, record) = {\n-            let guard = self.db.graph.lock();\n-            match guard.get(&query_id).map(|it| it.clone()){\n-                None => {\n-                    drop(guard);\n-                    return self.force(query_id, params);\n-                },\n-                Some(it) => it,\n-            }\n-        };\n-        if gen == self.db.gen {\n-            return (record.output.clone(), record.output_fingerprint)\n-        }\n-        if self.query_config.ground_fn.contains_key(&query_id.0) {\n-            let (invalidated, record) = {\n-                let guard = self.db.graph.lock();\n-                let (gen, ref record) = guard[&query_id];\n-                (gen == INVALIDATED, record.clone())\n-            };\n-            if invalidated {\n-                return self.force(query_id, params);\n-            } else {\n-                return (record.output.clone(), record.output_fingerprint);\n-            }\n-        }\n-        for (dep_query_id, prev_fingerprint) in record.deps.iter().cloned() {\n-            let dep_params: D = {\n-                let guard = self.db.graph.lock();\n-                guard[&dep_query_id]\n-                .1\n-                .params\n-                .clone()\n-            };\n-            if prev_fingerprint != self.get_inner(dep_query_id, dep_params).1 {\n-                return self.force(query_id, params)\n-            }\n-        }\n-        let gen = self.db.gen;\n-        {\n-            let mut guard = self.db.graph.lock();\n-            guard[&query_id].0 = gen;\n-        }\n-        (record.output.clone(), record.output_fingerprint)\n-    }\n-    fn force(\n-        &self,\n-        query_id: QueryId,\n-        params: D,\n-    ) -> (D, OutputFingerprint) {\n-        self.executed.borrow_mut().push(query_id.0);\n-        self.stack.borrow_mut().push(Vec::new());\n-\n-        let (res, output_fingerprint) = if let Some(f) = self.query_config.ground_fn.get(&query_id.0) {\n-            f(&self.db.ground_data, &params)\n-        } else if let Some(f) = self.query_config.query_fn.get(&query_id.0) {\n-            f(self, &params)\n-        } else {\n-            panic!(\"unknown query type: {:?}\", query_id.0);\n-        };\n-\n-        let res: D = res.into();\n-\n-        let deps = self.stack.borrow_mut().pop().unwrap();\n-        self.db.record(query_id, params, res.clone(), output_fingerprint, deps);\n-        (res, output_fingerprint)\n-    }\n-    fn record_dep(\n-        &self,\n-        query_id: QueryId,\n-        output_fingerprint: OutputFingerprint,\n-    ) -> () {\n-        let mut stack = self.stack.borrow_mut();\n-        let deps = stack.last_mut().unwrap();\n-        deps.push((query_id, output_fingerprint))\n-    }\n-}\n-\n-pub struct Invalidations {\n-    types: HashSet<QueryTypeId>,\n-    ids: Vec<QueryId>,\n-}\n-\n-impl Invalidations {\n-    pub fn new() -> Invalidations {\n-        Invalidations {\n-            types: HashSet::new(),\n-            ids: Vec::new(),\n-        }\n-    }\n-    pub fn invalidate(\n-        &mut self,\n-        query_type: QueryTypeId,\n-        params: impl Iterator<Item=InputFingerprint>,\n-    ) {\n-        self.types.insert(query_type);\n-        self.ids.extend(params.map(|it| QueryId(query_type, it)))\n-    }\n-}\n-\n-impl<T, D> Db<T, D>\n-where\n-    D: Clone\n-{\n-    pub fn new(query_config: QueryConfig<T, D>, ground_data: T) -> Db<T, D> {\n-        Db {\n-            db: Arc::new(DbState { ground_data, gen: Gen(0), graph: Default::default() }),\n-            query_config: Arc::new(query_config),\n-        }\n-    }\n-    pub fn ground_data(&self) -> &T {\n-        &self.db.ground_data\n-    }\n-    pub fn with_ground_data(\n-        &self,\n-        ground_data: T,\n-        invalidations: Invalidations,\n-    ) -> Db<T, D> {\n-        for id in self.query_config.ground_fn.keys() {\n-            assert!(\n-                invalidations.types.contains(id),\n-                \"all ground queries must be invalidated\"\n-            );\n-        }\n-\n-        let gen = Gen(self.db.gen.0 + 1);\n-        let mut graph = self.db.graph.lock().clone();\n-        for id in invalidations.ids {\n-            if let Some((gen, _)) = graph.get_mut(&id) {\n-                *gen = INVALIDATED;\n-            }\n-        }\n-        let graph = Mutex::new(graph);\n-        Db {\n-            db: Arc::new(DbState { ground_data, gen, graph }),\n-            query_config: Arc::clone(&self.query_config)\n-        }\n-    }\n-    pub fn query_ctx(&self) -> QueryCtx<T, D> {\n-        QueryCtx::new(self)\n-    }\n-    pub fn get(\n-        &self,\n-        query_id: QueryId,\n-        params: D,\n-    ) -> (D, Vec<QueryTypeId>) {\n-        let ctx = self.query_ctx();\n-        let res = ctx.get(query_id, params.into());\n-        let executed = ::std::mem::replace(&mut *ctx.executed.borrow_mut(), Vec::new());\n-        (res, executed)\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-struct Gen(u64);\n-const INVALIDATED: Gen = Gen(!0);\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct InputFingerprint(pub u64);\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct OutputFingerprint(pub u64);\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct QueryTypeId(pub u16);\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct QueryId(pub QueryTypeId, pub InputFingerprint);\n-"}, {"sha": "aed9219bee1fb5da5c0af202aff86240f3f11547", "filename": "crates/salsa/tests/integration.rs", "status": "removed", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/64b879d6a9aa61cf2ebe0154a292aa33e6412745/crates%2Fsalsa%2Ftests%2Fintegration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b879d6a9aa61cf2ebe0154a292aa33e6412745/crates%2Fsalsa%2Ftests%2Fintegration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsalsa%2Ftests%2Fintegration.rs?ref=64b879d6a9aa61cf2ebe0154a292aa33e6412745", "patch": "@@ -1,170 +0,0 @@\n-extern crate salsa;\n-use std::{\n-    iter::once,\n-    sync::Arc,\n-    collections::hash_map::{HashMap, DefaultHasher},\n-    any::Any,\n-    hash::{Hash, Hasher},\n-};\n-\n-type State = HashMap<u32, String>;\n-type Data = Arc<Any + Send + Sync + 'static>;\n-const GET_TEXT: salsa::QueryTypeId = salsa::QueryTypeId(1);\n-const GET_FILES: salsa::QueryTypeId = salsa::QueryTypeId(2);\n-const FILE_NEWLINES: salsa::QueryTypeId = salsa::QueryTypeId(3);\n-const TOTAL_NEWLINES: salsa::QueryTypeId = salsa::QueryTypeId(4);\n-\n-fn mk_ground_query<T, R>(\n-    state: &State,\n-    params: &Data,\n-    f: fn(&State, &T) -> R,\n-) -> (Data, salsa::OutputFingerprint)\n-where\n-    T: 'static,\n-    R: Hash + Send + Sync + 'static,\n-{\n-    let params = params.downcast_ref().unwrap();\n-    let result = f(state, params);\n-    let fingerprint = o_print(&result);\n-    (Arc::new(result), fingerprint)\n-}\n-\n-fn get<T, R>(db: &salsa::Db<State, Data>, query_type: salsa::QueryTypeId, param: T) -> (Arc<R>, Vec<salsa::QueryTypeId>)\n-where\n-    T: Hash + Send + Sync + 'static,\n-    R: Send + Sync + 'static,\n-{\n-    let i_print = i_print(&param);\n-    let param = Arc::new(param);\n-    let (res, trace) = db.get(salsa::QueryId(query_type, i_print), param);\n-    (res.downcast().unwrap(), trace)\n-}\n-\n-struct QueryCtx<'a>(&'a salsa::QueryCtx<State, Data>);\n-\n-impl<'a> QueryCtx<'a> {\n-    fn get_text(&self, id: u32) -> Arc<String> {\n-        let i_print = i_print(&id);\n-        let text = self.0.get(salsa::QueryId(GET_TEXT, i_print), Arc::new(id));\n-        text.downcast().unwrap()\n-    }\n-    fn get_files(&self) -> Arc<Vec<u32>> {\n-        let i_print = i_print(&());\n-        let files = self.0.get(salsa::QueryId(GET_FILES, i_print), Arc::new(()));\n-        let res = files.downcast().unwrap();\n-        res\n-    }\n-    fn get_n_lines(&self, id: u32) -> usize {\n-        let i_print = i_print(&id);\n-        let n_lines = self.0.get(salsa::QueryId(FILE_NEWLINES, i_print), Arc::new(id));\n-        *n_lines.downcast().unwrap()\n-    }\n-}\n-\n-fn mk_query<T, R>(\n-    query_ctx: &salsa::QueryCtx<State, Data>,\n-    params: &Data,\n-    f: fn(QueryCtx, &T) -> R,\n-) -> (Data, salsa::OutputFingerprint)\n-where\n-    T: 'static,\n-    R: Hash + Send + Sync + 'static,\n-{\n-    let params: &T = params.downcast_ref().unwrap();\n-    let query_ctx = QueryCtx(query_ctx);\n-    let result = f(query_ctx, params);\n-    let fingerprint = o_print(&result);\n-    (Arc::new(result), fingerprint)\n-}\n-\n-fn mk_queries() -> salsa::QueryConfig<State, Data> {\n-    salsa::QueryConfig::<State, Data>::new()\n-        .with_ground_query(GET_TEXT, Box::new(|state, id| {\n-            mk_ground_query::<u32, String>(state, id, |state, id| state[id].clone())\n-        }))\n-        .with_ground_query(GET_FILES, Box::new(|state, id| {\n-            mk_ground_query::<(), Vec<u32>>(state, id, |state, &()| state.keys().cloned().collect())\n-        }))\n-        .with_query(FILE_NEWLINES, Box::new(|query_ctx, id| {\n-            mk_query(query_ctx, id, |query_ctx, &id| {\n-                let text = query_ctx.get_text(id);\n-                text.lines().count()\n-            })\n-        }))\n-        .with_query(TOTAL_NEWLINES, Box::new(|query_ctx, id| {\n-            mk_query(query_ctx, id, |query_ctx, &()| {\n-                let mut total = 0;\n-                for &id in query_ctx.get_files().iter() {\n-                    total += query_ctx.get_n_lines(id)\n-                }\n-                total\n-            })\n-        }))\n-}\n-\n-#[test]\n-fn test_number_of_lines() {\n-    let mut state = State::new();\n-    let db = salsa::Db::new(mk_queries(), state.clone());\n-    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n-    assert_eq!(*newlines, 0);\n-    assert_eq!(trace.len(), 2);\n-    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n-    assert_eq!(*newlines, 0);\n-    assert_eq!(trace.len(), 0);\n-\n-    state.insert(1, \"hello\\nworld\".to_string());\n-    let mut inv = salsa::Invalidations::new();\n-    inv.invalidate(GET_TEXT, once(i_print(&1u32)));\n-    inv.invalidate(GET_FILES, once(i_print(&())));\n-    let db = db.with_ground_data(state.clone(), inv);\n-    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n-    assert_eq!(*newlines, 2);\n-    assert_eq!(trace.len(), 4);\n-\n-    state.insert(2, \"spam\\neggs\".to_string());\n-    let mut inv = salsa::Invalidations::new();\n-    inv.invalidate(GET_TEXT, once(i_print(&2u32)));\n-    inv.invalidate(GET_FILES, once(i_print(&())));\n-    let db = db.with_ground_data(state.clone(), inv);\n-    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n-    assert_eq!(*newlines, 4);\n-    assert_eq!(trace.len(), 4);\n-\n-    let mut invs = vec![];\n-    for i in 0..10 {\n-        let id = i + 10;\n-        invs.push(i_print(&id));\n-        state.insert(id, \"spam\".to_string());\n-    }\n-    let mut inv = salsa::Invalidations::new();\n-    inv.invalidate(GET_TEXT, invs.into_iter());\n-    inv.invalidate(GET_FILES, once(i_print(&())));\n-    let db = db.with_ground_data(state.clone(), inv);\n-    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n-    assert_eq!(*newlines, 14);\n-    assert_eq!(trace.len(), 22);\n-\n-    state.insert(15, String::new());\n-    let mut inv = salsa::Invalidations::new();\n-    inv.invalidate(GET_TEXT, once(i_print(&15u32)));\n-    inv.invalidate(GET_FILES, once(i_print(&())));\n-    let db = db.with_ground_data(state.clone(), inv);\n-    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n-    assert_eq!(*newlines, 13);\n-    assert_eq!(trace.len(), 4);\n-}\n-\n-fn o_print<T: Hash>(x: &T) -> salsa::OutputFingerprint {\n-    let mut hasher = DefaultHasher::new();\n-    x.hash(&mut hasher);\n-    let hash = hasher.finish();\n-    salsa::OutputFingerprint(hash)\n-}\n-\n-fn i_print<T: Hash>(x: &T) -> salsa::InputFingerprint {\n-    let mut hasher = DefaultHasher::new();\n-    x.hash(&mut hasher);\n-    let hash = hasher.finish();\n-    salsa::InputFingerprint(hash)\n-}"}]}