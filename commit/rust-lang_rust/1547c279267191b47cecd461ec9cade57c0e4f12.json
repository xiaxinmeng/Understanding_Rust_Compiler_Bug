{"sha": "1547c279267191b47cecd461ec9cade57c0e4f12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NDdjMjc5MjY3MTkxYjQ3Y2VjZDQ2MWVjOWNhZGU1N2MwZTRmMTI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-20T13:33:04Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-20T13:33:04Z"}, "message": "Fix caching bug in resolve, get rid of enumness kludge\n\nCloses #1911", "tree": {"sha": "b1ddce5e93c6c09516f768e706d39b0a743a4af8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1ddce5e93c6c09516f768e706d39b0a743a4af8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1547c279267191b47cecd461ec9cade57c0e4f12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1547c279267191b47cecd461ec9cade57c0e4f12", "html_url": "https://github.com/rust-lang/rust/commit/1547c279267191b47cecd461ec9cade57c0e4f12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1547c279267191b47cecd461ec9cade57c0e4f12/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "928364b98b61e7a88b26a01cd6acb78fb68430e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/928364b98b61e7a88b26a01cd6acb78fb68430e4", "html_url": "https://github.com/rust-lang/rust/commit/928364b98b61e7a88b26a01cd6acb78fb68430e4"}], "stats": {"total": 161, "additions": 55, "deletions": 106}, "files": [{"sha": "62cf9fd652352a7240371b5b9db63e04ecf598ad", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 55, "deletions": 106, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/1547c279267191b47cecd461ec9cade57c0e4f12/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1547c279267191b47cecd461ec9cade57c0e4f12/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=1547c279267191b47cecd461ec9cade57c0e4f12", "patch": "@@ -72,7 +72,7 @@ fn new_ext_hash() -> ext_hash {\n     fn hash(v: key) -> uint {\n         ret str::hash(v.ident) + util::common::hash_def(v.did) +\n                 alt v.ns {\n-                  ns_val(_) { 1u }\n+                  ns_val { 1u }\n                   ns_type { 2u }\n                   ns_module { 3u }\n                 };\n@@ -147,15 +147,7 @@ type env =\n // since export restrictions should only be applied for the former.\n enum dir { inside, outside, }\n \n-// There are two types of ns_value enum: \"definitely a enum\"; and \"enum or\n-// other value\". This is so that lookup can behave differently when looking up\n-// a variable name that's not yet in scope to check if it's already bound to a\n-// enum.\n-enum namespace { ns_val(enumness), ns_type, ns_module, }\n-enum enumness {\n-    definite_enum,\n-    value_or_enum\n-}\n+enum namespace { ns_val, ns_type, ns_module, }\n \n fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n    {def_map: def_map, exp_map: exp_map, impl_map: impl_map} {\n@@ -399,7 +391,7 @@ fn check_unused_imports(e: @env) {\n \n fn resolve_capture_item(e: @env, sc: scopes, &&cap_item: @ast::capture_item) {\n     let dcur = lookup_in_scope_strict(\n-        *e, sc, cap_item.span, cap_item.name, ns_val(value_or_enum));\n+        *e, sc, cap_item.span, cap_item.name, ns_val);\n     maybe_insert(e, cap_item.id, dcur);\n }\n \n@@ -436,7 +428,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           ast::expr_path(p) {\n             maybe_insert(e, exp.id,\n                          lookup_path_strict(*e, sc, exp.span, p.node,\n-                                            ns_val(value_or_enum)));\n+                                            ns_val));\n           }\n           ast::expr_fn(_, _, _, cap_clause) {\n             let rci = bind resolve_capture_item(e, sc, _);\n@@ -472,15 +464,13 @@ fn resolve_names(e: @env, c: @ast::crate) {\n     }\n     fn walk_constr(e: @env, p: @ast::path, sp: span, id: node_id, sc: scopes,\n                    _v: vt<scopes>) {\n-        maybe_insert(e, id, lookup_path_strict(*e, sc,\n-                         sp, p.node, ns_val(value_or_enum)));\n+        maybe_insert(e, id, lookup_path_strict(*e, sc, sp, p.node, ns_val));\n     }\n     fn walk_pat(e: @env, pat: @ast::pat, sc: scopes, v: vt<scopes>) {\n         visit::visit_pat(pat, sc, v);\n         alt pat.node {\n           ast::pat_enum(p, _) {\n-            alt lookup_path_strict(*e, sc, p.span, p.node,\n-                                           ns_val(value_or_enum)) {\n+            alt lookup_path_strict(*e, sc, p.span, p.node, ns_val) {\n               some(fnd@ast::def_variant(_,_)) {\n                 e.def_map.insert(pat.id, fnd);\n               }\n@@ -495,13 +485,12 @@ fn resolve_names(e: @env, c: @ast::crate) {\n            variable a refers to a nullary enum. */\n           ast::pat_ident(p, none) {\n               alt lookup_in_scope(*e, sc, p.span, path_to_ident(p),\n-                                    ns_val(definite_enum)) {\n+                                  ns_val, false) {\n                 some(fnd@ast::def_variant(_,_)) {\n                     e.def_map.insert(pat.id, fnd);\n                 }\n-                _ {\n-                    // Binds a var -- nothing needs to be done\n-                }\n+                // Binds a var -- nothing needs to be done\n+                _ {}\n               }\n           }\n           _ { }\n@@ -651,10 +640,8 @@ fn visit_local_with_scope(e: @env, loc: @local, sc:scopes, v:vt<scopes>) {\n     // to enum foo, or is it binding a new name foo?)\n     alt loc.node.pat.node {\n       pat_ident(an_ident,_) {\n-          // Be sure to pass definite_enum to lookup_in_scope so that\n-          // if this is a name that's being shadowed, we don't die\n-          alt lookup_in_scope(*e, sc, loc.span,\n-                 path_to_ident(an_ident), ns_val(definite_enum)) {\n+          alt lookup_in_scope(*e, sc, loc.span, path_to_ident(an_ident),\n+                              ns_val, false) {\n               some(ast::def_variant(enum_id,variant_id)) {\n                   // Declaration shadows a enum that's in scope.\n                   // That's an error.\n@@ -701,8 +688,7 @@ fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n }\n \n fn resolve_constr(e: @env, c: @ast::constr, sc: scopes, _v: vt<scopes>) {\n-    alt lookup_path_strict(*e, sc, c.span, c.node.path.node,\n-                           ns_val(value_or_enum)) {\n+    alt lookup_path_strict(*e, sc, c.span, c.node.path.node, ns_val) {\n        some(d@ast::def_fn(_,ast::pure_fn)) {\n          e.def_map.insert(c.node.id, d);\n        }\n@@ -720,7 +706,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n     fn register(e: env, id: node_id, cx: ctxt, sp: codemap::span,\n                 name: ast::ident, lookup: fn(namespace) -> option<def>,\n                 impls: [@_impl]) {\n-        let val = lookup(ns_val(value_or_enum)), typ = lookup(ns_type),\n+        let val = lookup(ns_val), typ = lookup(ns_type),\n             md = lookup(ns_module);\n         if is_none(val) && is_none(typ) && is_none(md) &&\n            vec::len(impls) == 0u {\n@@ -781,9 +767,9 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n     let end_id = ids[n_idents - 1u];\n     if n_idents == 1u {\n         register(e, defid.node, in_scope(sc), sp, name,\n-                 {|ns| lookup_in_scope(e, sc, sp, end_id, ns) }, []);\n+                 {|ns| lookup_in_scope(e, sc, sp, end_id, ns, true) }, []);\n     } else {\n-        alt lookup_in_scope(e, sc, sp, ids[0], ns_module) {\n+        alt lookup_in_scope(e, sc, sp, ids[0], ns_module, true) {\n           none {\n             unresolved_err(e, in_scope(sc), sp, ids[0], ns_name(ns_module));\n           }\n@@ -830,12 +816,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n fn ns_name(ns: namespace) -> str {\n     alt ns {\n       ns_type { \"typename\" }\n-      ns_val(v) {\n-          alt (v) {\n-              value_or_enum { \"name\" }\n-              definite_enum    { \"enum\" }\n-          }\n-      }\n+      ns_val { \"name\" }\n       ns_module { \"modulename\" }\n     }\n }\n@@ -929,7 +910,7 @@ fn lookup_path_strict(e: env, sc: scopes, sp: span, pth: ast::path_,\n \n fn lookup_in_scope_strict(e: env, sc: scopes, sp: span, name: ident,\n                           ns: namespace) -> option<def> {\n-    alt lookup_in_scope(e, sc, sp, name, ns) {\n+    alt lookup_in_scope(e, sc, sp, name, ns, true) {\n       none {\n         unresolved_err(e, in_scope(sc), sp, name, ns_name(ns));\n         ret none;\n@@ -974,8 +955,8 @@ fn def_is_ty_arg(d: def) -> bool {\n     ret alt d { ast::def_ty_param(_, _) { true } _ { false } };\n }\n \n-fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n-   -> option<def> {\n+fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace,\n+                   check_capture: bool) -> option<def> {\n \n     fn in_scope(e: env, sp: span, name: ident, s: scope, ns: namespace) ->\n        option<def> {\n@@ -1033,13 +1014,12 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n                   if ns == ns_type {\n                     ret lookup_in_ty_params(e, name, tps);\n                   }\n-                  if ns == ns_val(value_or_enum) && name == it.ident {\n+                  if ns == ns_val && name == it.ident {\n                       ret some(ast::def_fn(local_def(ctor.node.id),\n                                            ast::impure_fn));\n                   }\n-                  if ns == ns_val(value_or_enum) {\n-                          ret lookup_in_class(local_def(it.id),\n-                                              members, name);\n+                  if ns == ns_val {\n+                      ret lookup_in_class(local_def(it.id), members, name);\n                   }\n                   // FIXME: AST allows other items to appear in a class,\n                   // but that might not be wise\n@@ -1048,29 +1028,25 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n             }\n           }\n           scope_method(id, tps) {\n-            if (name == \"self\" && ns == ns_val(value_or_enum)) {\n+            if (name == \"self\" && ns == ns_val) {\n                 ret some(ast::def_self(id));\n             } else if ns == ns_type {\n                 ret lookup_in_ty_params(e, name, tps);\n             }\n           }\n           scope_native_item(it) {\n-            alt it.node {\n+            alt check it.node {\n               ast::native_item_fn(decl, ty_params) {\n                 ret lookup_in_fn(e, name, decl, ty_params, ns);\n               }\n-              _ {\n-                  e.sess.span_bug(it.span, \"lookup_in_scope: \\\n-                    scope_native_item doesn't refer to a native item\");\n-              }\n             }\n           }\n           scope_bare_fn(decl, _, ty_params) |\n           scope_fn_expr(decl, _, ty_params) {\n             ret lookup_in_fn(e, name, decl, ty_params, ns);\n           }\n           scope_loop(local) {\n-            if ns == ns_val(value_or_enum) {\n+            if ns == ns_val {\n                 alt lookup_in_pat(e, name, local.node.pat) {\n                   some(nid) { ret some(ast::def_binding(nid)); }\n                   _ { }\n@@ -1081,7 +1057,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n             ret lookup_in_block(e, name, sp, b.node, *pos, *loc, ns);\n           }\n           scope_arm(a) {\n-            if ns == ns_val(value_or_enum) {\n+            if ns == ns_val {\n                 alt lookup_in_pat(e, name, a.pats[0]) {\n                   some(nid) { ret some(ast::def_binding(nid)); }\n                   _ { ret none; }\n@@ -1104,24 +1080,15 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n                some(df_) {\n                  let df = df_;\n                  let local = def_is_local(df), self_scope = def_is_self(df);\n-                 if left_fn && local || left_fn_level2 && self_scope\n-                   || scope_is_fn(hd) && left_fn && def_is_ty_arg(df) {\n-                    let msg = alt ns {\n-                      ns_type {\n-                        \"attempt to use a type argument out of scope\"\n-                      }\n-                      ns_val(v) {\n-                          alt(v) {\n-                            /* If we were looking for a enum, at this point\n-                               we know it's bound to a non-enum value, and\n-                               we can return none instead of failing */\n-                            definite_enum { ret none; }\n-                            _ { \"attempted dynamic environment-capture\" }\n-                          }\n-                      }\n-                      _ { \"attempted dynamic environment-capture\" }\n-                    };\n-                    e.sess.span_fatal(sp, msg);\n+                 if check_capture &&\n+                     (left_fn && local || left_fn_level2 && self_scope\n+                      || scope_is_fn(hd) && left_fn && def_is_ty_arg(df)) {\n+                     let msg = if ns == ns_type {\n+                         \"attempt to use a type argument out of scope\"\n+                     } else {\n+                         \"attempted dynamic environment-capture\"\n+                     };\n+                     e.sess.span_fatal(sp, msg);\n                 } else if local || self_scope {\n                     let i = vec::len(closing);\n                     while i > 0u {\n@@ -1177,7 +1144,7 @@ fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n                 ty_params: [ast::ty_param],\n                 ns: namespace) -> option<def> {\n     alt ns {\n-      ns_val(value_or_enum) {\n+      ns_val {\n         for a: ast::arg in decl.inputs {\n             if str::eq(a.ident, name) {\n                 ret some(ast::def_arg(a.id, a.mode));\n@@ -1230,8 +1197,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                     while j > 0u {\n                         j -= 1u;\n                         let loc = locs[j];\n-                        if ns == ns_val(value_or_enum)\n-                                     && (i < pos || j < loc_pos) {\n+                        if ns == ns_val && (i < pos || j < loc_pos) {\n                             alt lookup_in_pat(e, name, loc.node.pat) {\n                               some(nid) {\n                                 ret some(ast::def_local(nid,\n@@ -1252,7 +1218,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                         }\n                     } else {\n                         alt ns {\n-                           ns_val(_) {\n+                           ns_val {\n                                for v: ast::variant in variants {\n                                   if str::eq(v.node.name, name) {\n                                      let i = v.node.id;\n@@ -1332,11 +1298,11 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n     alt i.node {\n       ast::item_const(_, _) {\n-        if ns == ns_val(value_or_enum) {\n+        if ns == ns_val {\n             ret some(ast::def_const(local_def(i.id))); }\n       }\n       ast::item_fn(decl, _, _) {\n-        if ns == ns_val(value_or_enum) {\n+        if ns == ns_val {\n             ret some(ast::def_fn(local_def(i.id), decl.purity));\n         }\n       }\n@@ -1351,7 +1317,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n       }\n       ast::item_res(_, _, _, _, ctor_id) {\n         alt ns {\n-          ns_val(value_or_enum) {\n+          ns_val {\n             ret some(ast::def_fn(local_def(ctor_id), ast::impure_fn));\n           }\n           ns_type { ret some(ast::def_ty(local_def(i.id))); }\n@@ -1441,8 +1407,7 @@ fn lookup_import(e: env, defid: def_id, ns: namespace) -> option<def> {\n         if e.used_imports.track {\n             e.used_imports.data += [defid.node];\n         }\n-        ret alt ns { ns_val(_) { val } ns_type { typ }\n-            ns_module { md } };\n+        ret alt ns { ns_val { val } ns_type { typ } ns_module { md } };\n       }\n       is_glob(_,_,_) {\n           e.sess.bug(\"lookup_import: can't handle is_glob\");\n@@ -1530,7 +1495,7 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n     if vec::len(matches) == 0u {\n         ret none;\n         }\n-    else if vec::len(matches) == 1u || ns == ns_val(definite_enum) {\n+    else if vec::len(matches) == 1u {\n         ret some(matches[0].def);\n     } else {\n         for match: glob_imp_def in matches {\n@@ -1548,14 +1513,8 @@ fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n     // absence takes the place of todo()\n     if !info.glob_imported_names.contains_key(id) {\n         info.glob_imported_names.insert(id, glob_resolving(sp));\n-        // kludge\n-        let val_ns = if wanted_ns == ns_val(definite_enum) {\n-            ns_val(definite_enum)\n-        } else {\n-            ns_val(value_or_enum)\n-        };\n         let globs = info.glob_imports;\n-        let val = lookup_in_globs(e, globs, sp, id, val_ns, dr);\n+        let val = lookup_in_globs(e, globs, sp, id, ns_val, dr);\n         let typ = lookup_in_globs(e, globs, sp, id, ns_type, dr);\n         let md = lookup_in_globs(e, globs, sp, id, ns_module, dr);\n         info.glob_imported_names.insert(id, glob_resolved(val, typ, md));\n@@ -1566,9 +1525,9 @@ fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n       }\n       glob_resolved(val, typ, md) {\n         ret alt wanted_ns {\n-                ns_val(_) { val }\n-                ns_type { typ }\n-                ns_module { md }\n+          ns_val { val }\n+          ns_type { typ }\n+          ns_module { md }\n         };\n       }\n     }\n@@ -1584,7 +1543,7 @@ fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n       mie_item(item) { ret found_def_item(item, ns); }\n       mie_enum_variant(variant_idx, variants, parent_id, parent_span) {\n          alt ns {\n-            ns_val(_) {\n+            ns_val {\n                let vid = variants[variant_idx].node.id;\n                ret some(ast::def_variant(local_def(parent_id),\n                                         local_def(vid)));\n@@ -1595,7 +1554,7 @@ fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n       mie_native_item(native_item) {\n         alt native_item.node {\n           ast::native_item_fn(decl, _) {\n-            if ns == ns_val(value_or_enum) {\n+            if ns == ns_val {\n                 ret some(ast::def_fn(local_def(native_item.id),\n                                      decl.purity));\n             }\n@@ -1718,12 +1677,11 @@ fn index_nmod(md: ast::native_mod) -> mod_index {\n // External lookups\n fn ns_for_def(d: def) -> namespace {\n     alt d {\n-      ast::def_variant(_, _) { ns_val(definite_enum) }\n+      ast::def_variant(_, _) { ns_val }\n       ast::def_fn(_, _) | ast::def_self(_) |\n       ast::def_const(_) | ast::def_arg(_, _) | ast::def_local(_, _) |\n       ast::def_upvar(_, _, _) |  ast::def_self(_) |\n-      ast::def_class_field(_,_) | ast::def_class_method(_,_)\n-          { ns_val(value_or_enum) }\n+      ast::def_class_field(_,_) | ast::def_class_method(_,_) { ns_val }\n       ast::def_mod(_) | ast::def_native_mod(_) { ns_module }\n       ast::def_ty(_) | ast::def_binding(_) | ast::def_use(_) |\n       ast::def_ty_param(_, _) | ast::def_prim_ty(_) | ast::def_class(_)\n@@ -1735,15 +1693,7 @@ fn ns_for_def(d: def) -> namespace {\n // if we're searching for a value, it's ok if we found\n // a enum\n fn ns_ok(wanted:namespace, actual:namespace) -> bool {\n-    alt actual {\n-      ns_val(definite_enum) {\n-        alt wanted {\n-          ns_val(_) { true }\n-          _ { false }\n-        }\n-      }\n-      _ { wanted == actual}\n-    }\n+    wanted == actual\n }\n \n fn lookup_external(e: env, cnum: int, ids: [ident], ns: namespace) ->\n@@ -1784,7 +1734,7 @@ fn check_mod_name(e: env, name: ident, entries: list<mod_index_entry>) {\n     loop {\n         alt entries {\n           cons(entry, rest) {\n-            if !is_none(lookup_in_mie(e, entry, ns_val(value_or_enum))) {\n+            if !is_none(lookup_in_mie(e, entry, ns_val)) {\n                 if saw_value {\n                     dup(e, mie_span(entry), \"\", name);\n                 } else { saw_value = true; }\n@@ -1999,7 +1949,7 @@ fn check_exports(e: @env) {\n                     alt mie {\n                       mie_item(item) {\n                         let defs =\n-                            [ found_def_item(item, ns_val(value_or_enum)),\n+                            [ found_def_item(item, ns_val),\n                              found_def_item(item, ns_type),\n                              found_def_item(item, ns_module) ];\n                         for d in defs {\n@@ -2026,8 +1976,7 @@ fn check_exports(e: @env) {\n     fn lookup_glob_any(e: @env, info: @indexed_mod, sp: span,\n                        ident: ident, export_id: node_id) -> bool {\n         let m = lookup_glob_in_mod(*e, info, sp, ident, ns_module, inside);\n-        let v = lookup_glob_in_mod(*e, info, sp, ident, ns_val(value_or_enum),\n-                                   inside);\n+        let v = lookup_glob_in_mod(*e, info, sp, ident, ns_val, inside);\n         let t = lookup_glob_in_mod(*e, info, sp, ident, ns_type, inside);\n         maybe_add_reexport(e, export_id, m);\n         maybe_add_reexport(e, export_id, v);"}]}