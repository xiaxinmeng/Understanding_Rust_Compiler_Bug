{"sha": "95089224993616ad1d976a4a5586c3f8f9f159ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1MDg5MjI0OTkzNjE2YWQxZDk3NmE0YTU1ODZjM2Y4ZjlmMTU5YWQ=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-12-28T05:05:45Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-01-09T17:35:50Z"}, "message": "Replace uses of DepGraph.in_ignore with DepGraph.with_ignore", "tree": {"sha": "7a85e34c6d30602854ce34e23894c886229a7408", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a85e34c6d30602854ce34e23894c886229a7408"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95089224993616ad1d976a4a5586c3f8f9f159ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95089224993616ad1d976a4a5586c3f8f9f159ad", "html_url": "https://github.com/rust-lang/rust/commit/95089224993616ad1d976a4a5586c3f8f9f159ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95089224993616ad1d976a4a5586c3f8f9f159ad/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e33c89ff1518359c4bd5fbed1571ea00cb3b146", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e33c89ff1518359c4bd5fbed1571ea00cb3b146", "html_url": "https://github.com/rust-lang/rust/commit/2e33c89ff1518359c4bd5fbed1571ea00cb3b146"}], "stats": {"total": 534, "additions": 273, "deletions": 261}, "files": [{"sha": "55ec8adb5fbf3131ad02837a5da7cdf0b92ed1d0", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=95089224993616ad1d976a4a5586c3f8f9f159ad", "patch": "@@ -141,14 +141,22 @@ impl DepGraph {\n         DepGraphQuery::new(&nodes[..], &edges[..])\n     }\n \n-    pub fn in_ignore<'graph>(&'graph self) -> Option<raii::IgnoreTask<'graph>> {\n-        self.data.as_ref().map(|data| raii::IgnoreTask::new(&data.current))\n+    pub fn assert_ignored(&self)\n+    {\n+        if let Some(ref data) = self.data {\n+            match data.current.borrow().task_stack.last() {\n+                Some(&OpenTask::Ignore) | None => {\n+                    // ignored\n+                }\n+                _ => panic!(\"expected an ignore context\")\n+            }\n+        }\n     }\n \n     pub fn with_ignore<OP,R>(&self, op: OP) -> R\n         where OP: FnOnce() -> R\n     {\n-        let _task = self.in_ignore();\n+        let _task = self.data.as_ref().map(|data| raii::IgnoreTask::new(&data.current));\n         op()\n     }\n "}, {"sha": "481c551bc292f8d48dcc3ec0b439b93fa2f17022", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=95089224993616ad1d976a4a5586c3f8f9f159ad", "patch": "@@ -180,7 +180,7 @@ pub fn lower_crate(sess: &Session,\n     // We're constructing the HIR here; we don't care what we will\n     // read, since we haven't even constructed the *input* to\n     // incr. comp. yet.\n-    let _ignore = dep_graph.in_ignore();\n+    dep_graph.assert_ignored();\n \n     LoweringContext {\n         crate_root: std_inject::injected_crate_name(),"}, {"sha": "a4c931115833240b3da4ed53b891c3523c337202", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=95089224993616ad1d976a4a5586c3f8f9f159ad", "patch": "@@ -20,16 +20,16 @@ pub fn check_crate<'hir>(hir_map: &hir::map::Map<'hir>) {\n         errors: vec![],\n     };\n \n-    hir_map.dep_graph.with_ignore(|| {\n-        hir_map.krate().visit_all_item_likes(&mut outer_visitor);\n-        if !outer_visitor.errors.is_empty() {\n-            let message = outer_visitor\n-                .errors\n-                .iter()\n-                .fold(String::new(), |s1, s2| s1 + \"\\n\" + s2);\n-            bug!(\"{}\", message);\n-        }\n-    });\n+    hir_map.dep_graph.assert_ignored();\n+\n+    hir_map.krate().visit_all_item_likes(&mut outer_visitor);\n+    if !outer_visitor.errors.is_empty() {\n+        let message = outer_visitor\n+            .errors\n+            .iter()\n+            .fold(String::new(), |s1, s2| s1 + \"\\n\" + s2);\n+        bug!(\"{}\", message);\n+    }\n }\n \n struct HirIdValidator<'a, 'hir: 'a> {"}, {"sha": "a553f30568951b91ea54be7c0da4f52b868b7855", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 126, "deletions": 126, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=95089224993616ad1d976a4a5586c3f8f9f159ad", "patch": "@@ -165,113 +165,113 @@ impl<'sess> OnDiskCache<'sess> {\n         where E: ty_codec::TyEncoder\n      {\n         // Serializing the DepGraph should not modify it:\n-        let _in_ignore = tcx.dep_graph.in_ignore();\n-\n-        // Allocate FileMapIndices\n-        let (file_to_file_index, file_index_to_stable_id) = {\n-            let mut file_to_file_index = FxHashMap();\n-            let mut file_index_to_stable_id = FxHashMap();\n-\n-            for (index, file) in tcx.sess.codemap().files().iter().enumerate() {\n-                let index = FileMapIndex(index as u32);\n-                let file_ptr: *const FileMap = &**file as *const _;\n-                file_to_file_index.insert(file_ptr, index);\n-                file_index_to_stable_id.insert(index, StableFilemapId::new(&file));\n-            }\n-\n-            (file_to_file_index, file_index_to_stable_id)\n-        };\n-\n-        let mut encoder = CacheEncoder {\n-            tcx,\n-            encoder,\n-            type_shorthands: FxHashMap(),\n-            predicate_shorthands: FxHashMap(),\n-            expn_info_shorthands: FxHashMap(),\n-            codemap: CachingCodemapView::new(tcx.sess.codemap()),\n-            file_to_file_index,\n-        };\n-\n-        // Load everything into memory so we can write it out to the on-disk\n-        // cache. The vast majority of cacheable query results should already\n-        // be in memory, so this should be a cheap operation.\n-        tcx.dep_graph.exec_cache_promotions(tcx);\n-\n-        // Encode query results\n-        let mut query_result_index = EncodedQueryResultIndex::new();\n-\n-        {\n-            use ty::maps::queries::*;\n-            let enc = &mut encoder;\n-            let qri = &mut query_result_index;\n-\n-            // Encode TypeckTables\n-            encode_query_results::<typeck_tables_of, _>(tcx, enc, qri)?;\n-            encode_query_results::<optimized_mir, _>(tcx, enc, qri)?;\n-            encode_query_results::<unsafety_check_result, _>(tcx, enc, qri)?;\n-            encode_query_results::<borrowck, _>(tcx, enc, qri)?;\n-            encode_query_results::<mir_borrowck, _>(tcx, enc, qri)?;\n-            encode_query_results::<mir_const_qualif, _>(tcx, enc, qri)?;\n-            encode_query_results::<def_symbol_name, _>(tcx, enc, qri)?;\n-            encode_query_results::<const_is_rvalue_promotable_to_static, _>(tcx, enc, qri)?;\n-            encode_query_results::<contains_extern_indicator, _>(tcx, enc, qri)?;\n-            encode_query_results::<symbol_name, _>(tcx, enc, qri)?;\n-            encode_query_results::<trans_fulfill_obligation, _>(tcx, enc, qri)?;\n-            encode_query_results::<check_match, _>(tcx, enc, qri)?;\n-        }\n+        tcx.dep_graph.with_ignore(|| {\n+            // Allocate FileMapIndices\n+            let (file_to_file_index, file_index_to_stable_id) = {\n+                let mut file_to_file_index = FxHashMap();\n+                let mut file_index_to_stable_id = FxHashMap();\n+\n+                for (index, file) in tcx.sess.codemap().files().iter().enumerate() {\n+                    let index = FileMapIndex(index as u32);\n+                    let file_ptr: *const FileMap = &**file as *const _;\n+                    file_to_file_index.insert(file_ptr, index);\n+                    file_index_to_stable_id.insert(index, StableFilemapId::new(&file));\n+                }\n \n-        // Encode diagnostics\n-        let diagnostics_index = {\n-            let mut diagnostics_index = EncodedDiagnosticsIndex::new();\n-\n-            for (dep_node_index, diagnostics) in self.current_diagnostics\n-                                                     .borrow()\n-                                                     .iter() {\n-                let pos = AbsoluteBytePos::new(encoder.position());\n-                // Let's make sure we get the expected type here:\n-                let diagnostics: &EncodedDiagnostics = diagnostics;\n-                let dep_node_index =\n-                    SerializedDepNodeIndex::new(dep_node_index.index());\n-                encoder.encode_tagged(dep_node_index, diagnostics)?;\n-                diagnostics_index.push((dep_node_index, pos));\n+                (file_to_file_index, file_index_to_stable_id)\n+            };\n+\n+            let mut encoder = CacheEncoder {\n+                tcx,\n+                encoder,\n+                type_shorthands: FxHashMap(),\n+                predicate_shorthands: FxHashMap(),\n+                expn_info_shorthands: FxHashMap(),\n+                codemap: CachingCodemapView::new(tcx.sess.codemap()),\n+                file_to_file_index,\n+            };\n+\n+            // Load everything into memory so we can write it out to the on-disk\n+            // cache. The vast majority of cacheable query results should already\n+            // be in memory, so this should be a cheap operation.\n+            tcx.dep_graph.exec_cache_promotions(tcx);\n+\n+            // Encode query results\n+            let mut query_result_index = EncodedQueryResultIndex::new();\n+\n+            {\n+                use ty::maps::queries::*;\n+                let enc = &mut encoder;\n+                let qri = &mut query_result_index;\n+\n+                // Encode TypeckTables\n+                encode_query_results::<typeck_tables_of, _>(tcx, enc, qri)?;\n+                encode_query_results::<optimized_mir, _>(tcx, enc, qri)?;\n+                encode_query_results::<unsafety_check_result, _>(tcx, enc, qri)?;\n+                encode_query_results::<borrowck, _>(tcx, enc, qri)?;\n+                encode_query_results::<mir_borrowck, _>(tcx, enc, qri)?;\n+                encode_query_results::<mir_const_qualif, _>(tcx, enc, qri)?;\n+                encode_query_results::<def_symbol_name, _>(tcx, enc, qri)?;\n+                encode_query_results::<const_is_rvalue_promotable_to_static, _>(tcx, enc, qri)?;\n+                encode_query_results::<contains_extern_indicator, _>(tcx, enc, qri)?;\n+                encode_query_results::<symbol_name, _>(tcx, enc, qri)?;\n+                encode_query_results::<trans_fulfill_obligation, _>(tcx, enc, qri)?;\n+                encode_query_results::<check_match, _>(tcx, enc, qri)?;\n             }\n \n-            diagnostics_index\n-        };\n+            // Encode diagnostics\n+            let diagnostics_index = {\n+                let mut diagnostics_index = EncodedDiagnosticsIndex::new();\n+\n+                for (dep_node_index, diagnostics) in self.current_diagnostics\n+                                                        .borrow()\n+                                                        .iter() {\n+                    let pos = AbsoluteBytePos::new(encoder.position());\n+                    // Let's make sure we get the expected type here:\n+                    let diagnostics: &EncodedDiagnostics = diagnostics;\n+                    let dep_node_index =\n+                        SerializedDepNodeIndex::new(dep_node_index.index());\n+                    encoder.encode_tagged(dep_node_index, diagnostics)?;\n+                    diagnostics_index.push((dep_node_index, pos));\n+                }\n \n-        let sorted_cnums = sorted_cnums_including_local_crate(tcx);\n-        let prev_cnums: Vec<_> = sorted_cnums.iter().map(|&cnum| {\n-            let crate_name = tcx.original_crate_name(cnum).as_str().to_string();\n-            let crate_disambiguator = tcx.crate_disambiguator(cnum);\n-            (cnum.as_u32(), crate_name, crate_disambiguator)\n-        }).collect();\n-\n-        // Encode the file footer\n-        let footer_pos = encoder.position() as u64;\n-        encoder.encode_tagged(TAG_FILE_FOOTER, &Footer {\n-            file_index_to_stable_id,\n-            prev_cnums,\n-            query_result_index,\n-            diagnostics_index,\n-        })?;\n-\n-        // Encode the position of the footer as the last 8 bytes of the\n-        // file so we know where to look for it.\n-        IntEncodedWithFixedSize(footer_pos).encode(encoder.encoder)?;\n-\n-        // DO NOT WRITE ANYTHING TO THE ENCODER AFTER THIS POINT! The address\n-        // of the footer must be the last thing in the data stream.\n-\n-        return Ok(());\n-\n-        fn sorted_cnums_including_local_crate(tcx: TyCtxt) -> Vec<CrateNum> {\n-            let mut cnums = vec![LOCAL_CRATE];\n-            cnums.extend_from_slice(&tcx.crates()[..]);\n-            cnums.sort_unstable();\n-            // Just to be sure...\n-            cnums.dedup();\n-            cnums\n-        }\n+                diagnostics_index\n+            };\n+\n+            let sorted_cnums = sorted_cnums_including_local_crate(tcx);\n+            let prev_cnums: Vec<_> = sorted_cnums.iter().map(|&cnum| {\n+                let crate_name = tcx.original_crate_name(cnum).as_str().to_string();\n+                let crate_disambiguator = tcx.crate_disambiguator(cnum);\n+                (cnum.as_u32(), crate_name, crate_disambiguator)\n+            }).collect();\n+\n+            // Encode the file footer\n+            let footer_pos = encoder.position() as u64;\n+            encoder.encode_tagged(TAG_FILE_FOOTER, &Footer {\n+                file_index_to_stable_id,\n+                prev_cnums,\n+                query_result_index,\n+                diagnostics_index,\n+            })?;\n+\n+            // Encode the position of the footer as the last 8 bytes of the\n+            // file so we know where to look for it.\n+            IntEncodedWithFixedSize(footer_pos).encode(encoder.encoder)?;\n+\n+            // DO NOT WRITE ANYTHING TO THE ENCODER AFTER THIS POINT! The address\n+            // of the footer must be the last thing in the data stream.\n+\n+            return Ok(());\n+\n+            fn sorted_cnums_including_local_crate(tcx: TyCtxt) -> Vec<CrateNum> {\n+                let mut cnums = vec![LOCAL_CRATE];\n+                cnums.extend_from_slice(&tcx.crates()[..]);\n+                cnums.sort_unstable();\n+                // Just to be sure...\n+                cnums.dedup();\n+                cnums\n+            }\n+        })\n     }\n \n     /// Load a diagnostic emitted during the previous compilation session.\n@@ -380,30 +380,30 @@ impl<'sess> OnDiskCache<'sess> {\n                         prev_cnums: &[(u32, String, CrateDisambiguator)])\n                         -> IndexVec<CrateNum, Option<CrateNum>>\n     {\n-        let _in_ignore = tcx.dep_graph.in_ignore();\n-\n-        let current_cnums = tcx.all_crate_nums(LOCAL_CRATE).iter().map(|&cnum| {\n-            let crate_name = tcx.original_crate_name(cnum)\n-                                .as_str()\n-                                .to_string();\n-            let crate_disambiguator = tcx.crate_disambiguator(cnum);\n-            ((crate_name, crate_disambiguator), cnum)\n-        }).collect::<FxHashMap<_,_>>();\n-\n-        let map_size = prev_cnums.iter()\n-                                 .map(|&(cnum, ..)| cnum)\n-                                 .max()\n-                                 .unwrap_or(0) + 1;\n-        let mut map = IndexVec::new();\n-        map.resize(map_size as usize, None);\n-\n-        for &(prev_cnum, ref crate_name, crate_disambiguator) in prev_cnums {\n-            let key = (crate_name.clone(), crate_disambiguator);\n-            map[CrateNum::from_u32(prev_cnum)] = current_cnums.get(&key).cloned();\n-        }\n+        tcx.dep_graph.with_ignore(|| {\n+            let current_cnums = tcx.all_crate_nums(LOCAL_CRATE).iter().map(|&cnum| {\n+                let crate_name = tcx.original_crate_name(cnum)\n+                                    .as_str()\n+                                    .to_string();\n+                let crate_disambiguator = tcx.crate_disambiguator(cnum);\n+                ((crate_name, crate_disambiguator), cnum)\n+            }).collect::<FxHashMap<_,_>>();\n+\n+            let map_size = prev_cnums.iter()\n+                                    .map(|&(cnum, ..)| cnum)\n+                                    .max()\n+                                    .unwrap_or(0) + 1;\n+            let mut map = IndexVec::new();\n+            map.resize(map_size as usize, None);\n+\n+            for &(prev_cnum, ref crate_name, crate_disambiguator) in prev_cnums {\n+                let key = (crate_name.clone(), crate_disambiguator);\n+                map[CrateNum::from_u32(prev_cnum)] = current_cnums.get(&key).cloned();\n+            }\n \n-        map[LOCAL_CRATE] = Some(LOCAL_CRATE);\n-        map\n+            map[LOCAL_CRATE] = Some(LOCAL_CRATE);\n+            map\n+        })\n     }\n }\n "}, {"sha": "8d3b2bc47ec9dbcc6e9efbf8d7a39059b47dee01", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=95089224993616ad1d976a4a5586c3f8f9f159ad", "patch": "@@ -191,7 +191,7 @@ pub fn compile_input(sess: &Session,\n                            || hir_map::map_crate(sess, cstore, &mut hir_forest, &defs));\n \n         {\n-            let _ignore = hir_map.dep_graph.in_ignore();\n+            hir_map.dep_graph.assert_ignored();\n             controller_entry_point!(after_hir_lowering,\n                                     sess,\n                                     CompileState::state_after_hir_lowering(input,\n@@ -233,18 +233,18 @@ pub fn compile_input(sess: &Session,\n                                     |tcx, analysis, rx, result| {\n             {\n                 // Eventually, we will want to track plugins.\n-                let _ignore = tcx.dep_graph.in_ignore();\n-\n-                let mut state = CompileState::state_after_analysis(input,\n-                                                                   sess,\n-                                                                   outdir,\n-                                                                   output,\n-                                                                   opt_crate,\n-                                                                   tcx.hir.krate(),\n-                                                                   &analysis,\n-                                                                   tcx,\n-                                                                   &crate_name);\n-                (control.after_analysis.callback)(&mut state);\n+                tcx.dep_graph.with_ignore(|| {\n+                    let mut state = CompileState::state_after_analysis(input,\n+                                                                       sess,\n+                                                                       outdir,\n+                                                                       output,\n+                                                                       opt_crate,\n+                                                                       tcx.hir.krate(),\n+                                                                       &analysis,\n+                                                                       tcx,\n+                                                                       &crate_name);\n+                    (control.after_analysis.callback)(&mut state);\n+                });\n \n                 if control.after_analysis.stop == Compilation::Stop {\n                     return result.and_then(|_| Err(CompileIncomplete::Stopped));"}, {"sha": "6ce6929af5cabf6e9b959b4245e607ed2f473a81", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=95089224993616ad1d976a4a5586c3f8f9f159ad", "patch": "@@ -243,8 +243,9 @@ impl PpSourceMode {\n                         tcx,\n                         tables: Cell::new(&empty_tables)\n                     };\n-                    let _ignore = tcx.dep_graph.in_ignore();\n-                    f(&annotation, hir_map.forest.krate())\n+                    tcx.dep_graph.with_ignore(|| {\n+                        f(&annotation, hir_map.forest.krate())\n+                    })\n                 }),\n                              sess)\n             }"}, {"sha": "9fa29380dc64609fdbd4f0bb41374e887bb5e34a", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=95089224993616ad1d976a4a5586c3f8f9f159ad", "patch": "@@ -61,38 +61,38 @@ use syntax::ast;\n use syntax_pos::Span;\n \n pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let _ignore = tcx.dep_graph.in_ignore();\n-\n-    if tcx.sess.opts.debugging_opts.dump_dep_graph {\n-        dump_graph(tcx);\n-    }\n-\n-    // if the `rustc_attrs` feature is not enabled, then the\n-    // attributes we are interested in cannot be present anyway, so\n-    // skip the walk.\n-    if !tcx.sess.features.borrow().rustc_attrs {\n-        return;\n-    }\n+    tcx.dep_graph.with_ignore(|| {\n+        if tcx.sess.opts.debugging_opts.dump_dep_graph {\n+            dump_graph(tcx);\n+        }\n \n-    // Find annotations supplied by user (if any).\n-    let (if_this_changed, then_this_would_need) = {\n-        let mut visitor = IfThisChanged { tcx,\n-                                          if_this_changed: vec![],\n-                                          then_this_would_need: vec![] };\n-        visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.hir.krate().attrs);\n-        tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n-        (visitor.if_this_changed, visitor.then_this_would_need)\n-    };\n+        // if the `rustc_attrs` feature is not enabled, then the\n+        // attributes we are interested in cannot be present anyway, so\n+        // skip the walk.\n+        if !tcx.sess.features.borrow().rustc_attrs {\n+            return;\n+        }\n \n-    if !if_this_changed.is_empty() || !then_this_would_need.is_empty() {\n-        assert!(tcx.sess.opts.debugging_opts.query_dep_graph,\n-                \"cannot use the `#[{}]` or `#[{}]` annotations \\\n-                 without supplying `-Z query-dep-graph`\",\n-                ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED);\n-    }\n+        // Find annotations supplied by user (if any).\n+        let (if_this_changed, then_this_would_need) = {\n+            let mut visitor = IfThisChanged { tcx,\n+                                            if_this_changed: vec![],\n+                                            then_this_would_need: vec![] };\n+            visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.hir.krate().attrs);\n+            tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+            (visitor.if_this_changed, visitor.then_this_would_need)\n+        };\n+\n+        if !if_this_changed.is_empty() || !then_this_would_need.is_empty() {\n+            assert!(tcx.sess.opts.debugging_opts.query_dep_graph,\n+                    \"cannot use the `#[{}]` or `#[{}]` annotations \\\n+                    without supplying `-Z query-dep-graph`\",\n+                    ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED);\n+        }\n \n-    // Check paths.\n-    check_paths(tcx, &if_this_changed, &then_this_would_need);\n+        // Check paths.\n+        check_paths(tcx, &if_this_changed, &then_this_would_need);\n+    })\n }\n \n type Sources = Vec<(Span, DefId, DepNode)>;"}, {"sha": "f543b1c09213ce62a95995f5a5fe134927d6cee6", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=95089224993616ad1d976a4a5586c3f8f9f159ad", "patch": "@@ -223,25 +223,26 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         return;\n     }\n \n-    let _ignore = tcx.dep_graph.in_ignore();\n-    let krate = tcx.hir.krate();\n-    let mut dirty_clean_visitor = DirtyCleanVisitor {\n-        tcx,\n-        checked_attrs: FxHashSet(),\n-    };\n-    krate.visit_all_item_likes(&mut dirty_clean_visitor);\n-\n-    let mut all_attrs = FindAllAttrs {\n-        tcx,\n-        attr_names: vec![ATTR_DIRTY, ATTR_CLEAN],\n-        found_attrs: vec![],\n-    };\n-    intravisit::walk_crate(&mut all_attrs, krate);\n-\n-    // Note that we cannot use the existing \"unused attribute\"-infrastructure\n-    // here, since that is running before trans. This is also the reason why\n-    // all trans-specific attributes are `Whitelisted` in syntax::feature_gate.\n-    all_attrs.report_unchecked_attrs(&dirty_clean_visitor.checked_attrs);\n+    tcx.dep_graph.with_ignore(|| {\n+        let krate = tcx.hir.krate();\n+        let mut dirty_clean_visitor = DirtyCleanVisitor {\n+            tcx,\n+            checked_attrs: FxHashSet(),\n+        };\n+        krate.visit_all_item_likes(&mut dirty_clean_visitor);\n+\n+        let mut all_attrs = FindAllAttrs {\n+            tcx,\n+            attr_names: vec![ATTR_DIRTY, ATTR_CLEAN],\n+            found_attrs: vec![],\n+        };\n+        intravisit::walk_crate(&mut all_attrs, krate);\n+\n+        // Note that we cannot use the existing \"unused attribute\"-infrastructure\n+        // here, since that is running before trans. This is also the reason why\n+        // all trans-specific attributes are `Whitelisted` in syntax::feature_gate.\n+        all_attrs.report_unchecked_attrs(&dirty_clean_visitor.checked_attrs);\n+    })\n }\n \n pub struct DirtyCleanVisitor<'a, 'tcx:'a> {"}, {"sha": "e51587e1cd3b405d2214216e74cc88b2ac18c6e1", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=95089224993616ad1d976a4a5586c3f8f9f159ad", "patch": "@@ -27,27 +27,28 @@ use super::work_product;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     debug!(\"save_dep_graph()\");\n-    let _ignore = tcx.dep_graph.in_ignore();\n-    let sess = tcx.sess;\n-    if sess.opts.incremental.is_none() {\n-        return;\n-    }\n-\n-    time(sess.time_passes(), \"persist query result cache\", || {\n-        save_in(sess,\n-                query_cache_path(sess),\n-                |e| encode_query_cache(tcx, e));\n-    });\n+    tcx.dep_graph.with_ignore(|| {\n+        let sess = tcx.sess;\n+        if sess.opts.incremental.is_none() {\n+            return;\n+        }\n \n-    if tcx.sess.opts.debugging_opts.incremental_queries {\n-        time(sess.time_passes(), \"persist dep-graph\", || {\n+        time(sess.time_passes(), \"persist query result cache\", || {\n             save_in(sess,\n-                    dep_graph_path(sess),\n-                    |e| encode_dep_graph(tcx, e));\n+                    query_cache_path(sess),\n+                    |e| encode_query_cache(tcx, e));\n         });\n-    }\n \n-    dirty_clean::check_dirty_clean_annotations(tcx);\n+        if tcx.sess.opts.debugging_opts.incremental_queries {\n+            time(sess.time_passes(), \"persist dep-graph\", || {\n+                save_in(sess,\n+                        dep_graph_path(sess),\n+                        |e| encode_dep_graph(tcx, e));\n+            });\n+        }\n+\n+        dirty_clean::check_dirty_clean_annotations(tcx);\n+    })\n }\n \n pub fn save_work_products(sess: &Session, dep_graph: &DepGraph) {\n@@ -56,7 +57,7 @@ pub fn save_work_products(sess: &Session, dep_graph: &DepGraph) {\n     }\n \n     debug!(\"save_work_products()\");\n-    let _ignore = dep_graph.in_ignore();\n+    dep_graph.assert_ignored();\n     let path = work_products_path(sess);\n     save_in(sess, path, |e| encode_work_products(dep_graph, e));\n "}, {"sha": "a52eaf2b2edd072a16ad61b53cedc53bc5f0d192", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=95089224993616ad1d976a4a5586c3f8f9f159ad", "patch": "@@ -858,14 +858,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     fn encode_fn_arg_names_for_body(&mut self, body_id: hir::BodyId)\n                                     -> LazySeq<ast::Name> {\n-        let _ignore = self.tcx.dep_graph.in_ignore();\n-        let body = self.tcx.hir.body(body_id);\n-        self.lazy_seq(body.arguments.iter().map(|arg| {\n-            match arg.pat.node {\n-                PatKind::Binding(_, _, name, _) => name.node,\n-                _ => Symbol::intern(\"\")\n-            }\n-        }))\n+        self.tcx.dep_graph.with_ignore(|| {\n+            let body = self.tcx.hir.body(body_id);\n+            self.lazy_seq(body.arguments.iter().map(|arg| {\n+                match arg.pat.node {\n+                    PatKind::Binding(_, _, name, _) => name.node,\n+                    _ => Symbol::intern(\"\")\n+                }\n+            }))\n+        })\n     }\n \n     fn encode_fn_arg_names(&mut self, names: &[Spanned<ast::Name>])"}, {"sha": "fd2c2237c32d68de07325e0f0db474c3e0da146c", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=95089224993616ad1d976a4a5586c3f8f9f159ad", "patch": "@@ -119,19 +119,18 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         where DATA: DepGraphRead\n     {\n         assert!(id.is_local());\n-        let tcx: TyCtxt<'b, 'tcx, 'tcx> = self.ecx.tcx;\n \n         // We don't track this since we are explicitly computing the incr. comp.\n         // hashes anyway. In theory we could do some tracking here and use it to\n         // avoid rehashing things (and instead cache the hashes) but it's\n         // unclear whether that would be a win since hashing is cheap enough.\n-        let _task = tcx.dep_graph.in_ignore();\n+        self.ecx.tcx.dep_graph.with_ignore(move || {\n+            let mut entry_builder = IsolatedEncoder::new(self.ecx);\n+            let entry = op(&mut entry_builder, data);\n+            let entry = entry_builder.lazy(&entry);\n \n-        let mut entry_builder = IsolatedEncoder::new(self.ecx);\n-        let entry = op(&mut entry_builder, data);\n-        let entry = entry_builder.lazy(&entry);\n-\n-        self.items.record(id, entry);\n+            self.items.record(id, entry);\n+        })\n     }\n \n     pub fn into_items(self) -> Index {"}, {"sha": "b282837750e5429ca4d5c1bf99c1c78946551d5e", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=95089224993616ad1d976a4a5586c3f8f9f159ad", "patch": "@@ -1077,21 +1077,21 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n     config: Option<Config>,\n     mut handler: H,\n ) {\n-    let _ignore = tcx.dep_graph.in_ignore();\n+    tcx.dep_graph.with_ignore(|| {\n+        assert!(analysis.glob_map.is_some());\n \n-    assert!(analysis.glob_map.is_some());\n+        info!(\"Dumping crate {}\", cratename);\n \n-    info!(\"Dumping crate {}\", cratename);\n-\n-    let save_ctxt = SaveContext {\n-        tcx,\n-        tables: &ty::TypeckTables::empty(None),\n-        analysis,\n-        span_utils: SpanUtils::new(&tcx.sess),\n-        config: find_config(config),\n-    };\n+        let save_ctxt = SaveContext {\n+            tcx,\n+            tables: &ty::TypeckTables::empty(None),\n+            analysis,\n+            span_utils: SpanUtils::new(&tcx.sess),\n+            config: find_config(config),\n+        };\n \n-    handler.save(save_ctxt, krate, cratename)\n+        handler.save(save_ctxt, krate, cratename)\n+    })\n }\n \n fn find_config(supplied: Option<Config>) -> Config {"}, {"sha": "1986b7f5863682a857b13f1308e00436b026471d", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=95089224993616ad1d976a4a5586c3f8f9f159ad", "patch": "@@ -39,16 +39,16 @@ const CFG: &'static str = \"cfg\";\n enum Disposition { Reused, Translated }\n \n pub(crate) fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let _ignore = tcx.dep_graph.in_ignore();\n-\n-    if tcx.sess.opts.incremental.is_none() {\n-        return;\n-    }\n+    tcx.dep_graph.with_ignore(|| {\n+        if tcx.sess.opts.incremental.is_none() {\n+            return;\n+        }\n \n-    let ams = AssertModuleSource { tcx };\n-    for attr in &tcx.hir.krate().attrs {\n-        ams.check_attr(attr);\n-    }\n+        let ams = AssertModuleSource { tcx };\n+        for attr in &tcx.hir.krate().attrs {\n+            ams.check_attr(attr);\n+        }\n+    })\n }\n \n struct AssertModuleSource<'a, 'tcx: 'a> {"}, {"sha": "15c142cf947c89b5e2a476b2d19fc475580766aa", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95089224993616ad1d976a4a5586c3f8f9f159ad/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=95089224993616ad1d976a4a5586c3f8f9f159ad", "patch": "@@ -32,10 +32,11 @@ pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         return;\n     }\n \n-    let _ignore = tcx.dep_graph.in_ignore();\n-    let mut visitor = SymbolNamesTest { tcx: tcx };\n-    // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n-    tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+    tcx.dep_graph.with_ignore(|| {\n+        let mut visitor = SymbolNamesTest { tcx: tcx };\n+        // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n+        tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+    })\n }\n \n struct SymbolNamesTest<'a, 'tcx:'a> {"}]}