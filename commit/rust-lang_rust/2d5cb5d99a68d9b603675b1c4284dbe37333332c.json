{"sha": "2d5cb5d99a68d9b603675b1c4284dbe37333332c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNWNiNWQ5OWE2OGQ5YjYwMzY3NWIxYzQyODRkYmUzNzMzMzMzMmM=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-10-26T20:49:51Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-10-28T01:25:19Z"}, "message": "Integrate the code in the digest and cryptoutil modules directly into the sha1 module.", "tree": {"sha": "c5bcb630d21739824839e9d0cfd71405c5aa8979", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5bcb630d21739824839e9d0cfd71405c5aa8979"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d5cb5d99a68d9b603675b1c4284dbe37333332c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d5cb5d99a68d9b603675b1c4284dbe37333332c", "html_url": "https://github.com/rust-lang/rust/commit/2d5cb5d99a68d9b603675b1c4284dbe37333332c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d5cb5d99a68d9b603675b1c4284dbe37333332c/comments", "author": null, "committer": null, "parents": [{"sha": "ff9e573a6752cde4760fafdb94f7337c9e133905", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff9e573a6752cde4760fafdb94f7337c9e133905", "html_url": "https://github.com/rust-lang/rust/commit/ff9e573a6752cde4760fafdb94f7337c9e133905"}], "stats": {"total": 680, "additions": 315, "deletions": 365}, "files": [{"sha": "55199b1f2cc76d114165948fccceebce70199b0c", "filename": "src/librustpkg/cryptoutil.rs", "status": "removed", "additions": 0, "deletions": 271, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/ff9e573a6752cde4760fafdb94f7337c9e133905/src%2Flibrustpkg%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9e573a6752cde4760fafdb94f7337c9e133905/src%2Flibrustpkg%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcryptoutil.rs?ref=ff9e573a6752cde4760fafdb94f7337c9e133905", "patch": "@@ -1,271 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::num::{Zero, CheckedAdd};\n-use std::vec::bytes::{MutableByteVector, copy_memory};\n-\n-\n-/// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n-/// format.\n-pub fn write_u32_be(dst: &mut[u8], input: u32) {\n-    use std::cast::transmute;\n-    use std::unstable::intrinsics::to_be32;\n-    assert!(dst.len() == 4);\n-    unsafe {\n-        let x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n-        *x = to_be32(input as i32);\n-    }\n-}\n-\n-/// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n-pub fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n-    use std::cast::transmute;\n-    use std::unstable::intrinsics::to_be32;\n-    assert!(dst.len() * 4 == input.len());\n-    unsafe {\n-        let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n-        let mut y: *i32 = transmute(input.unsafe_ref(0));\n-        do dst.len().times() {\n-            *x = to_be32(*y);\n-            x = x.offset(1);\n-            y = y.offset(1);\n-        }\n-    }\n-}\n-\n-\n-trait ToBits {\n-    /// Convert the value in bytes to the number of bits, a tuple where the 1st item is the\n-    /// high-order value and the 2nd item is the low order value.\n-    fn to_bits(self) -> (Self, Self);\n-}\n-\n-impl ToBits for u64 {\n-    fn to_bits(self) -> (u64, u64) {\n-        return (self >> 61, self << 3);\n-    }\n-}\n-\n-/// Adds the specified number of bytes to the bit count. fail!() if this would cause numeric\n-/// overflow.\n-pub fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n-    let (new_high_bits, new_low_bits) = bytes.to_bits();\n-\n-    if new_high_bits > Zero::zero() {\n-        fail!(\"Numeric overflow occured.\")\n-    }\n-\n-    match bits.checked_add(&new_low_bits) {\n-        Some(x) => return x,\n-        None => fail!(\"Numeric overflow occured.\")\n-    }\n-}\n-\n-\n-/// A FixedBuffer, likes its name implies, is a fixed size buffer. When the buffer becomes full, it\n-/// must be processed. The input() method takes care of processing and then clearing the buffer\n-/// automatically. However, other methods do not and require the caller to process the buffer. Any\n-/// method that modifies the buffer directory or provides the caller with bytes that can be modifies\n-/// results in those bytes being marked as used by the buffer.\n-pub trait FixedBuffer {\n-    /// Input a vector of bytes. If the buffer becomes full, process it with the provided\n-    /// function and then clear the buffer.\n-    fn input(&mut self, input: &[u8], func: &fn(&[u8]));\n-\n-    /// Reset the buffer.\n-    fn reset(&mut self);\n-\n-    /// Zero the buffer up until the specified index. The buffer position currently must not be\n-    /// greater than that index.\n-    fn zero_until(&mut self, idx: uint);\n-\n-    /// Get a slice of the buffer of the specified size. There must be at least that many bytes\n-    /// remaining in the buffer.\n-    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8];\n-\n-    /// Get the current buffer. The buffer must already be full. This clears the buffer as well.\n-    fn full_buffer<'s>(&'s mut self) -> &'s [u8];\n-\n-    /// Get the current position of the buffer.\n-    fn position(&self) -> uint;\n-\n-    /// Get the number of bytes remaining in the buffer until it is full.\n-    fn remaining(&self) -> uint;\n-\n-    /// Get the size of the buffer\n-    fn size(&self) -> uint;\n-}\n-\n-\n-/// A fixed size buffer of 64 bytes useful for cryptographic operations.\n-pub struct FixedBuffer64 {\n-    priv buffer: [u8, ..64],\n-    priv buffer_idx: uint,\n-}\n-\n-impl FixedBuffer64 {\n-    /// Create a new buffer\n-    pub fn new() -> FixedBuffer64 {\n-        return FixedBuffer64 {\n-            buffer: [0u8, ..64],\n-            buffer_idx: 0\n-        };\n-    }\n-}\n-\n-impl FixedBuffer for FixedBuffer64 {\n-    fn input(&mut self, input: &[u8], func: &fn(&[u8])) {\n-        let mut i = 0;\n-\n-        // FIXME: #6304 - This local variable shouldn't be necessary.\n-        let size = 64;\n-\n-        // If there is already data in the buffer, copy as much as we can into it and process\n-        // the data if the buffer becomes full.\n-        if self.buffer_idx != 0 {\n-            let buffer_remaining = size - self.buffer_idx;\n-            if input.len() >= buffer_remaining {\n-                    copy_memory(\n-                        self.buffer.mut_slice(self.buffer_idx, size),\n-                        input.slice_to(buffer_remaining),\n-                        buffer_remaining);\n-                self.buffer_idx = 0;\n-                func(self.buffer);\n-                i += buffer_remaining;\n-            } else {\n-                copy_memory(\n-                    self.buffer.mut_slice(self.buffer_idx, self.buffer_idx + input.len()),\n-                    input,\n-                    input.len());\n-                self.buffer_idx += input.len();\n-                return;\n-            }\n-        }\n-\n-        // While we have at least a full buffer size chunks's worth of data, process that data\n-        // without copying it into the buffer\n-        while input.len() - i >= size {\n-            func(input.slice(i, i + size));\n-            i += size;\n-        }\n-\n-        // Copy any input data into the buffer. At this point in the method, the ammount of\n-        // data left in the input vector will be less than the buffer size and the buffer will\n-        // be empty.\n-        let input_remaining = input.len() - i;\n-        copy_memory(\n-            self.buffer.mut_slice(0, input_remaining),\n-            input.slice_from(i),\n-            input.len() - i);\n-        self.buffer_idx += input_remaining;\n-    }\n-\n-    fn reset(&mut self) {\n-        self.buffer_idx = 0;\n-    }\n-\n-    fn zero_until(&mut self, idx: uint) {\n-        assert!(idx >= self.buffer_idx);\n-        self.buffer.mut_slice(self.buffer_idx, idx).set_memory(0);\n-        self.buffer_idx = idx;\n-    }\n-\n-    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n-        self.buffer_idx += len;\n-        return self.buffer.mut_slice(self.buffer_idx - len, self.buffer_idx);\n-    }\n-\n-    fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n-        assert!(self.buffer_idx == 64);\n-        self.buffer_idx = 0;\n-        return self.buffer.slice_to(64);\n-    }\n-\n-    fn position(&self) -> uint { self.buffer_idx }\n-\n-    fn remaining(&self) -> uint { 64 - self.buffer_idx }\n-\n-    fn size(&self) -> uint { 64 }\n-}\n-\n-\n-/// The StandardPadding trait adds a method useful for various hash algorithms to a FixedBuffer\n-/// struct.\n-pub trait StandardPadding {\n-    /// Add standard padding to the buffer. The buffer must not be full when this method is called\n-    /// and is guaranteed to have exactly rem remaining bytes when it returns. If there are not at\n-    /// least rem bytes available, the buffer will be zero padded, processed, cleared, and then\n-    /// filled with zeros again until only rem bytes are remaining.\n-    fn standard_padding(&mut self, rem: uint, func: &fn(&[u8]));\n-}\n-\n-impl <T: FixedBuffer> StandardPadding for T {\n-    fn standard_padding(&mut self, rem: uint, func: &fn(&[u8])) {\n-        let size = self.size();\n-\n-        self.next(1)[0] = 128;\n-\n-        if self.remaining() < rem {\n-            self.zero_until(size);\n-            func(self.full_buffer());\n-        }\n-\n-        self.zero_until(size - rem);\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-pub mod test {\n-    use std::rand::{IsaacRng, Rng};\n-    use std::vec;\n-    use extra::hex::FromHex;\n-\n-    use cryptoutil::add_bytes_to_bits;\n-    use digest::Digest;\n-\n-    /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n-    /// correct.\n-    pub fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n-        let total_size = 1000000;\n-        let buffer = vec::from_elem(blocksize * 2, 'a' as u8);\n-        let mut rng = IsaacRng::new_unseeded();\n-        let mut count = 0;\n-\n-        digest.reset();\n-\n-        while count < total_size {\n-            let next: uint = rng.gen_range(0, 2 * blocksize + 1);\n-            let remaining = total_size - count;\n-            let size = if next > remaining { remaining } else { next };\n-            digest.input(buffer.slice_to(size));\n-            count += size;\n-        }\n-\n-        let result_str = digest.result_str();\n-        let result_bytes = digest.result_bytes();\n-\n-        assert_eq!(expected, result_str.as_slice());\n-        assert_eq!(expected.from_hex().unwrap(), result_bytes);\n-    }\n-\n-    // A normal addition - no overflow occurs\n-    #[test]\n-    fn test_add_bytes_to_bits_ok() {\n-        assert!(add_bytes_to_bits::<u64>(100, 10) == 180);\n-    }\n-\n-    // A simple failure case - adding 1 to the max value\n-    #[test]\n-    #[should_fail]\n-    fn test_add_bytes_to_bits_overflow() {\n-        add_bytes_to_bits::<u64>(Bounded::max_value(), 1);\n-    }\n-}"}, {"sha": "f0dccf7c2e21238b5404db7b79e7164f9c87848a", "filename": "src/librustpkg/digest.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ff9e573a6752cde4760fafdb94f7337c9e133905/src%2Flibrustpkg%2Fdigest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9e573a6752cde4760fafdb94f7337c9e133905/src%2Flibrustpkg%2Fdigest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fdigest.rs?ref=ff9e573a6752cde4760fafdb94f7337c9e133905", "patch": "@@ -1,81 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Common functionality related to cryptographic digest functions\n-\n-use std::vec;\n-\n-use extra::hex::ToHex;\n-\n-\n-/**\n- * The Digest trait specifies an interface common to digest functions, such as SHA-1 and the SHA-2\n- * family of digest functions.\n- */\n-pub trait Digest {\n-    /**\n-     * Provide message data.\n-     *\n-     * # Arguments\n-     *\n-     * * input - A vector of message data\n-     */\n-    fn input(&mut self, input: &[u8]);\n-\n-    /**\n-     * Retrieve the digest result. This method may be called multiple times.\n-     *\n-     * # Arguments\n-     *\n-     * * out - the vector to hold the result. Must be large enough to contain output_bits().\n-     */\n-    fn result(&mut self, out: &mut [u8]);\n-\n-    /**\n-     * Reset the digest. This method must be called after result() and before supplying more\n-     * data.\n-     */\n-    fn reset(&mut self);\n-\n-    /**\n-     * Get the output size in bits.\n-     */\n-    fn output_bits(&self) -> uint;\n-\n-    /**\n-     * Convenience function that feeds a string into a digest.\n-     *\n-     * # Arguments\n-     *\n-     * * `input` The string to feed into the digest\n-     */\n-    fn input_str(&mut self, input: &str) {\n-        self.input(input.as_bytes());\n-    }\n-\n-    /**\n-     * Convenience function that retrieves the result of a digest as a\n-     * newly allocated vec of bytes.\n-     */\n-    fn result_bytes(&mut self) -> ~[u8] {\n-        let mut buf = vec::from_elem((self.output_bits()+7)/8, 0u8);\n-        self.result(buf);\n-        buf\n-    }\n-\n-    /**\n-     * Convenience function that retrieves the result of a digest as a\n-     * ~str in hexadecimal format.\n-     */\n-    fn result_str(&mut self) -> ~str {\n-        self.result_bytes().to_hex()\n-    }\n-}\n-"}, {"sha": "95a2c5b170231b172383e934b06d4eecfdee81ff", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d5cb5d99a68d9b603675b1c4284dbe37333332c/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5cb5d99a68d9b603675b1c4284dbe37333332c/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=2d5cb5d99a68d9b603675b1c4284dbe37333332c", "patch": "@@ -55,8 +55,6 @@ pub mod api;\n mod conditions;\n pub mod context;\n mod crate;\n-mod cryptoutil;\n-mod digest;\n pub mod exit_codes;\n mod installed_packages;\n mod messages;"}, {"sha": "d955fd1aa97d04426df99241f59dfa6cf7bf8ada", "filename": "src/librustpkg/sha1.rs", "status": "modified", "additions": 314, "deletions": 9, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/2d5cb5d99a68d9b603675b1c4284dbe37333332c/src%2Flibrustpkg%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5cb5d99a68d9b603675b1c4284dbe37333332c/src%2Flibrustpkg%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsha1.rs?ref=2d5cb5d99a68d9b603675b1c4284dbe37333332c", "patch": "@@ -26,10 +26,278 @@\n  * discouraged.\n  */\n \n+use std::num::Zero;\n+use std::vec;\n+use std::vec::bytes::{MutableByteVector, copy_memory};\n+use extra::hex::ToHex;\n+\n+/// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n+/// format.\n+fn write_u32_be(dst: &mut[u8], input: u32) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_be32;\n+    assert!(dst.len() == 4);\n+    unsafe {\n+        let x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n+        *x = to_be32(input as i32);\n+    }\n+}\n+\n+/// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n+fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_be32;\n+    assert!(dst.len() * 4 == input.len());\n+    unsafe {\n+        let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n+        let mut y: *i32 = transmute(input.unsafe_ref(0));\n+        do dst.len().times() {\n+            *x = to_be32(*y);\n+            x = x.offset(1);\n+            y = y.offset(1);\n+        }\n+    }\n+}\n+\n+trait ToBits {\n+    /// Convert the value in bytes to the number of bits, a tuple where the 1st item is the\n+    /// high-order value and the 2nd item is the low order value.\n+    fn to_bits(self) -> (Self, Self);\n+}\n+\n+impl ToBits for u64 {\n+    fn to_bits(self) -> (u64, u64) {\n+        return (self >> 61, self << 3);\n+    }\n+}\n+\n+/// Adds the specified number of bytes to the bit count. fail!() if this would cause numeric\n+/// overflow.\n+fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n+    let (new_high_bits, new_low_bits) = bytes.to_bits();\n+\n+    if new_high_bits > Zero::zero() {\n+        fail!(\"Numeric overflow occured.\")\n+    }\n+\n+    match bits.checked_add(&new_low_bits) {\n+        Some(x) => return x,\n+        None => fail!(\"Numeric overflow occured.\")\n+    }\n+}\n+\n+/// A FixedBuffer, likes its name implies, is a fixed size buffer. When the buffer becomes full, it\n+/// must be processed. The input() method takes care of processing and then clearing the buffer\n+/// automatically. However, other methods do not and require the caller to process the buffer. Any\n+/// method that modifies the buffer directory or provides the caller with bytes that can be modifies\n+/// results in those bytes being marked as used by the buffer.\n+trait FixedBuffer {\n+    /// Input a vector of bytes. If the buffer becomes full, process it with the provided\n+    /// function and then clear the buffer.\n+    fn input(&mut self, input: &[u8], func: &fn(&[u8]));\n+\n+    /// Reset the buffer.\n+    fn reset(&mut self);\n+\n+    /// Zero the buffer up until the specified index. The buffer position currently must not be\n+    /// greater than that index.\n+    fn zero_until(&mut self, idx: uint);\n+\n+    /// Get a slice of the buffer of the specified size. There must be at least that many bytes\n+    /// remaining in the buffer.\n+    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8];\n \n-use cryptoutil::{write_u32_be, read_u32v_be, add_bytes_to_bits, FixedBuffer, FixedBuffer64,\n-    StandardPadding};\n-use digest::Digest;\n+    /// Get the current buffer. The buffer must already be full. This clears the buffer as well.\n+    fn full_buffer<'s>(&'s mut self) -> &'s [u8];\n+\n+    /// Get the current position of the buffer.\n+    fn position(&self) -> uint;\n+\n+    /// Get the number of bytes remaining in the buffer until it is full.\n+    fn remaining(&self) -> uint;\n+\n+    /// Get the size of the buffer\n+    fn size(&self) -> uint;\n+}\n+\n+/// A fixed size buffer of 64 bytes useful for cryptographic operations.\n+struct FixedBuffer64 {\n+    priv buffer: [u8, ..64],\n+    priv buffer_idx: uint,\n+}\n+\n+impl FixedBuffer64 {\n+    /// Create a new buffer\n+    fn new() -> FixedBuffer64 {\n+        return FixedBuffer64 {\n+            buffer: [0u8, ..64],\n+            buffer_idx: 0\n+        };\n+    }\n+}\n+\n+impl FixedBuffer for FixedBuffer64 {\n+    fn input(&mut self, input: &[u8], func: &fn(&[u8])) {\n+        let mut i = 0;\n+\n+        let size = 64;\n+\n+        // If there is already data in the buffer, copy as much as we can into it and process\n+        // the data if the buffer becomes full.\n+        if self.buffer_idx != 0 {\n+            let buffer_remaining = size - self.buffer_idx;\n+            if input.len() >= buffer_remaining {\n+                    copy_memory(\n+                        self.buffer.mut_slice(self.buffer_idx, size),\n+                        input.slice_to(buffer_remaining),\n+                        buffer_remaining);\n+                self.buffer_idx = 0;\n+                func(self.buffer);\n+                i += buffer_remaining;\n+            } else {\n+                copy_memory(\n+                    self.buffer.mut_slice(self.buffer_idx, self.buffer_idx + input.len()),\n+                    input,\n+                    input.len());\n+                self.buffer_idx += input.len();\n+                return;\n+            }\n+        }\n+\n+        // While we have at least a full buffer size chunks's worth of data, process that data\n+        // without copying it into the buffer\n+        while input.len() - i >= size {\n+            func(input.slice(i, i + size));\n+            i += size;\n+        }\n+\n+        // Copy any input data into the buffer. At this point in the method, the ammount of\n+        // data left in the input vector will be less than the buffer size and the buffer will\n+        // be empty.\n+        let input_remaining = input.len() - i;\n+        copy_memory(\n+            self.buffer.mut_slice(0, input_remaining),\n+            input.slice_from(i),\n+            input.len() - i);\n+        self.buffer_idx += input_remaining;\n+    }\n+\n+    fn reset(&mut self) {\n+        self.buffer_idx = 0;\n+    }\n+\n+    fn zero_until(&mut self, idx: uint) {\n+        assert!(idx >= self.buffer_idx);\n+        self.buffer.mut_slice(self.buffer_idx, idx).set_memory(0);\n+        self.buffer_idx = idx;\n+    }\n+\n+    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n+        self.buffer_idx += len;\n+        return self.buffer.mut_slice(self.buffer_idx - len, self.buffer_idx);\n+    }\n+\n+    fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n+        assert!(self.buffer_idx == 64);\n+        self.buffer_idx = 0;\n+        return self.buffer.slice_to(64);\n+    }\n+\n+    fn position(&self) -> uint { self.buffer_idx }\n+\n+    fn remaining(&self) -> uint { 64 - self.buffer_idx }\n+\n+    fn size(&self) -> uint { 64 }\n+}\n+\n+/// The StandardPadding trait adds a method useful for various hash algorithms to a FixedBuffer\n+/// struct.\n+trait StandardPadding {\n+    /// Add standard padding to the buffer. The buffer must not be full when this method is called\n+    /// and is guaranteed to have exactly rem remaining bytes when it returns. If there are not at\n+    /// least rem bytes available, the buffer will be zero padded, processed, cleared, and then\n+    /// filled with zeros again until only rem bytes are remaining.\n+    fn standard_padding(&mut self, rem: uint, func: &fn(&[u8]));\n+}\n+\n+impl <T: FixedBuffer> StandardPadding for T {\n+    fn standard_padding(&mut self, rem: uint, func: &fn(&[u8])) {\n+        let size = self.size();\n+\n+        self.next(1)[0] = 128;\n+\n+        if self.remaining() < rem {\n+            self.zero_until(size);\n+            func(self.full_buffer());\n+        }\n+\n+        self.zero_until(size - rem);\n+    }\n+}\n+\n+/**\n+ * The Digest trait specifies an interface common to digest functions, such as SHA-1 and the SHA-2\n+ * family of digest functions.\n+ */\n+pub trait Digest {\n+    /**\n+     * Provide message data.\n+     *\n+     * # Arguments\n+     *\n+     * * input - A vector of message data\n+     */\n+    fn input(&mut self, input: &[u8]);\n+\n+    /**\n+     * Retrieve the digest result. This method may be called multiple times.\n+     *\n+     * # Arguments\n+     *\n+     * * out - the vector to hold the result. Must be large enough to contain output_bits().\n+     */\n+    fn result(&mut self, out: &mut [u8]);\n+\n+    /**\n+     * Reset the digest. This method must be called after result() and before supplying more\n+     * data.\n+     */\n+    fn reset(&mut self);\n+\n+    /**\n+     * Get the output size in bits.\n+     */\n+    fn output_bits(&self) -> uint;\n+\n+    /**\n+     * Convenience function that feeds a string into a digest.\n+     *\n+     * # Arguments\n+     *\n+     * * `input` The string to feed into the digest\n+     */\n+    fn input_str(&mut self, input: &str) {\n+        self.input(input.as_bytes());\n+    }\n+\n+    /**\n+     * Convenience function that retrieves the result of a digest as a\n+     * newly allocated vec of bytes.\n+     */\n+    fn result_bytes(&mut self) -> ~[u8] {\n+        let mut buf = vec::from_elem((self.output_bits()+7)/8, 0u8);\n+        self.result(buf);\n+        buf\n+    }\n+\n+    /**\n+     * Convenience function that retrieves the result of a digest as a\n+     * ~str in hexadecimal format.\n+     */\n+    fn result_str(&mut self) -> ~str {\n+        self.result_bytes().to_hex()\n+    }\n+}\n \n /*\n  * A SHA-1 implementation derived from Paul E. Jones's reference\n@@ -180,9 +448,10 @@ impl Digest for Sha1 {\n \n #[cfg(test)]\n mod tests {\n-    use cryptoutil::test::test_digest_1million_random;\n-    use digest::Digest;\n-    use sha1::Sha1;\n+    use std::rand::{IsaacRng, Rng};\n+    use std::vec;\n+    use extra::hex::FromHex;\n+    use super::{Digest, Sha1, add_bytes_to_bits};\n \n     #[deriving(Clone)]\n     struct Test {\n@@ -287,6 +556,31 @@ mod tests {\n         }\n     }\n \n+    /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n+    /// correct.\n+    fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n+        let total_size = 1000000;\n+        let buffer = vec::from_elem(blocksize * 2, 'a' as u8);\n+        let mut rng = IsaacRng::new_unseeded();\n+        let mut count = 0;\n+\n+        digest.reset();\n+\n+        while count < total_size {\n+            let next: uint = rng.gen_range(0, 2 * blocksize + 1);\n+            let remaining = total_size - count;\n+            let size = if next > remaining { remaining } else { next };\n+            digest.input(buffer.slice_to(size));\n+            count += size;\n+        }\n+\n+        let result_str = digest.result_str();\n+        let result_bytes = digest.result_bytes();\n+\n+        assert_eq!(expected, result_str.as_slice());\n+        assert_eq!(expected.from_hex().unwrap(), result_bytes);\n+    }\n+\n     #[test]\n     fn test_1million_random_sha1() {\n         let mut sh = Sha1::new();\n@@ -295,13 +589,25 @@ mod tests {\n             64,\n             \"34aa973cd4c4daa4f61eeb2bdbad27316534016f\");\n     }\n+\n+    // A normal addition - no overflow occurs\n+    #[test]\n+    fn test_add_bytes_to_bits_ok() {\n+        assert!(add_bytes_to_bits::<u64>(100, 10) == 180);\n+    }\n+\n+    // A simple failure case - adding 1 to the max value\n+    #[test]\n+    #[should_fail]\n+    fn test_add_bytes_to_bits_overflow() {\n+        add_bytes_to_bits::<u64>(Bounded::max_value(), 1);\n+    }\n }\n \n #[cfg(test)]\n mod bench {\n     use extra::test::BenchHarness;\n-\n-    use sha1::Sha1;\n+    use super::Sha1;\n \n     #[bench]\n     pub fn sha1_10(bh: & mut BenchHarness) {\n@@ -332,5 +638,4 @@ mod bench {\n         }\n         bh.bytes = bytes.len() as u64;\n     }\n-\n }"}, {"sha": "3adb33ec2f45580b04fcc17e57904c1be0f8fda0", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d5cb5d99a68d9b603675b1c4284dbe37333332c/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5cb5d99a68d9b603675b1c4284dbe37333332c/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=2d5cb5d99a68d9b603675b1c4284dbe37333332c", "patch": "@@ -12,8 +12,7 @@ use std::rt::io;\n use std::rt::io::extensions::ReaderUtil;\n use std::rt::io::file::FileInfo;\n use extra::workcache;\n-use sha1::Sha1;\n-use digest::Digest;\n+use sha1::{Digest, Sha1};\n \n /// Hashes the file contents along with the last-modified time\n pub fn digest_file_with_date(path: &Path) -> ~str {"}]}