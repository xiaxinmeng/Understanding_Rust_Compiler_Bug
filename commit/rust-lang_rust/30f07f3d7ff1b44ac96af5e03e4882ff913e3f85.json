{"sha": "30f07f3d7ff1b44ac96af5e03e4882ff913e3f85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZjA3ZjNkN2ZmMWI0NGFjOTZhZjVlMDNlNDg4MmZmOTEzZTNmODU=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-30T05:32:15Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-30T05:32:15Z"}, "message": "Re-implement support for downcast lvalues.", "tree": {"sha": "0f7504b09a8c0113a0ffc347fa621b3f8d3d4213", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f7504b09a8c0113a0ffc347fa621b3f8d3d4213"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30f07f3d7ff1b44ac96af5e03e4882ff913e3f85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30f07f3d7ff1b44ac96af5e03e4882ff913e3f85", "html_url": "https://github.com/rust-lang/rust/commit/30f07f3d7ff1b44ac96af5e03e4882ff913e3f85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30f07f3d7ff1b44ac96af5e03e4882ff913e3f85/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f533e3ae065af3f05cbd09f47a45245f37f9712", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f533e3ae065af3f05cbd09f47a45245f37f9712", "html_url": "https://github.com/rust-lang/rust/commit/0f533e3ae065af3f05cbd09f47a45245f37f9712"}], "stats": {"total": 74, "additions": 38, "deletions": 36}, "files": [{"sha": "66a75dd4d56b25656698e3ea1093509ec8f4904f", "filename": "src/interpreter.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/30f07f3d7ff1b44ac96af5e03e4882ff913e3f85/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f07f3d7ff1b44ac96af5e03e4882ff913e3f85/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=30f07f3d7ff1b44ac96af5e03e4882ff913e3f85", "patch": "@@ -84,7 +84,8 @@ struct Lvalue {\n enum LvalueExtra {\n     None,\n     Length(u64),\n-    // Vtable(memory::AllocId),\n+    // TODO(tsion): Vtable(memory::AllocId),\n+    DowncastVariant(usize),\n }\n \n #[derive(Clone)]\n@@ -231,8 +232,10 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n                 let discr_ptr = try!(self.eval_lvalue(discr)).to_ptr();\n-                let discr_size =\n-                    self.lvalue_layout(discr).size(&self.tcx.data_layout).bytes() as usize;\n+                let discr_size = self\n+                    .type_layout(self.lvalue_ty(discr))\n+                    .size(&self.tcx.data_layout)\n+                    .bytes() as usize;\n                 let discr_val = try!(self.memory.read_uint(discr_ptr, discr_size));\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n@@ -252,7 +255,7 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n \n             Switch { ref discr, ref targets, adt_def } => {\n                 let adt_ptr = try!(self.eval_lvalue(discr)).to_ptr();\n-                let adt_layout = self.lvalue_layout(discr);\n+                let adt_layout = self.type_layout(self.lvalue_ty(discr));\n                 let discr_size = match *adt_layout {\n                     Layout::General { discr, .. } => discr.size().bytes(),\n                     _ => panic!(\"attmpted to switch on non-aggregate type\"),\n@@ -590,7 +593,7 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n     {\n         let dest = try!(self.eval_lvalue(lvalue)).to_ptr();\n         let dest_ty = self.lvalue_ty(lvalue);\n-        let dest_layout = self.lvalue_layout(lvalue);\n+        let dest_layout = self.type_layout(dest_ty);\n \n         use rustc::mir::repr::Rvalue::*;\n         match *rvalue {\n@@ -693,6 +696,8 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                         let len_ptr = dest.offset(self.memory.pointer_size as isize);\n                         try!(self.memory.write_usize(len_ptr, len));\n                     }\n+                    LvalueExtra::DowncastVariant(..) =>\n+                        panic!(\"attempted to take a reference to an enum downcast lvalue\"),\n                 }\n             }\n \n@@ -745,7 +750,7 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         match *op {\n             Consume(ref lvalue) =>\n                 Ok(try!(self.eval_lvalue(lvalue)).to_ptr()),\n-            Constant(mir::Constant { ref literal, ty, .. }) => {\n+            Constant(mir::Constant { ref literal, .. }) => {\n                 use rustc::mir::repr::Literal::*;\n                 match *literal {\n                     Value { ref value } => Ok(try!(self.const_to_ptr(value))),\n@@ -755,22 +760,6 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         }\n     }\n \n-    // TODO(tsion): Replace this inefficient hack with a wrapper like LvalueTy (e.g. LvalueLayout).\n-    fn lvalue_layout(&self, lvalue: &mir::Lvalue<'tcx>) -> &'tcx Layout {\n-        use rustc::mir::tcx::LvalueTy;\n-        match self.mir().lvalue_ty(self.tcx, lvalue) {\n-            LvalueTy::Ty { ty } => self.type_layout(ty),\n-            LvalueTy::Downcast { adt_def, substs, variant_index } => {\n-                let field_tys = adt_def.variants[variant_index].fields.iter()\n-                    .map(|f| f.ty(self.tcx, substs));\n-\n-                // FIXME(tsion): Handle LvalueTy::Downcast better somehow...\n-                unimplemented!();\n-                // self.repr_arena.alloc(self.make_aggregate_layout(iter::once(field_tys)))\n-            }\n-        }\n-    }\n-\n     fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<Lvalue> {\n         use rustc::mir::repr::Lvalue::*;\n         let ptr = match *lvalue {\n@@ -783,32 +772,45 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n             Static(_def_id) => unimplemented!(),\n \n             Projection(ref proj) => {\n-                let base_ptr = try!(self.eval_lvalue(&proj.base)).ptr;\n-                let base_layout = self.lvalue_layout(&proj.base);\n+                let base = try!(self.eval_lvalue(&proj.base));\n                 let base_ty = self.lvalue_ty(&proj.base);\n+                let base_layout = self.type_layout(base_ty);\n \n                 use rustc::mir::repr::ProjectionElem::*;\n                 match proj.elem {\n-                    Field(field, _) => match *base_layout {\n-                        Layout::Univariant { ref variant, .. } => {\n-                            let offset = variant.field_offset(field.index()).bytes();\n-                            base_ptr.offset(offset as isize)\n-                        }\n-                        _ => panic!(\"field access on non-product type: {:?}\", base_layout),\n+                    Field(field, _) => {\n+                        let variant = match *base_layout {\n+                            Layout::Univariant { ref variant, .. } => variant,\n+                            Layout::General { ref variants, .. } => {\n+                                if let LvalueExtra::DowncastVariant(variant_idx) = base.extra {\n+                                    &variants[variant_idx]\n+                                } else {\n+                                    panic!(\"field access on enum had no variant index\");\n+                                }\n+                            }\n+                            _ => panic!(\"field access on non-product type: {:?}\", base_layout),\n+                        };\n+\n+                        let offset = variant.field_offset(field.index()).bytes();\n+                        base.ptr.offset(offset as isize)\n                     },\n \n-                    Downcast(..) => match *base_layout {\n-                        Layout::General { discr, .. } =>\n-                            base_ptr.offset(discr.size().bytes() as isize),\n+                    Downcast(_, variant) => match *base_layout {\n+                        Layout::General { discr, .. } => {\n+                            return Ok(Lvalue {\n+                                ptr: base.ptr.offset(discr.size().bytes() as isize),\n+                                extra: LvalueExtra::DowncastVariant(variant),\n+                            });\n+                        }\n                         _ => panic!(\"variant downcast on non-aggregate type: {:?}\", base_layout),\n                     },\n \n                     Deref => {\n                         let pointee_ty = pointee_type(base_ty).expect(\"Deref of non-pointer\");\n-                        let ptr = try!(self.memory.read_ptr(base_ptr));\n+                        let ptr = try!(self.memory.read_ptr(base.ptr));\n                         let extra = match pointee_ty.sty {\n                             ty::TySlice(_) | ty::TyStr => {\n-                                let len_ptr = base_ptr.offset(self.memory.pointer_size as isize);\n+                                let len_ptr = base.ptr.offset(self.memory.pointer_size as isize);\n                                 let len = try!(self.memory.read_usize(len_ptr));\n                                 LvalueExtra::Length(len)\n                             }\n@@ -826,7 +828,7 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                         };\n                         let n_ptr = try!(self.eval_operand(operand));\n                         let n = try!(self.memory.read_usize(n_ptr));\n-                        base_ptr.offset(n as isize * elem_size as isize)\n+                        base.ptr.offset(n as isize * elem_size as isize)\n                     }\n \n                     ConstantIndex { .. } => unimplemented!(),"}]}