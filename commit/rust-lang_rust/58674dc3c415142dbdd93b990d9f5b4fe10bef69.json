{"sha": "58674dc3c415142dbdd93b990d9f5b4fe10bef69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4Njc0ZGMzYzQxNTE0MmRiZGQ5M2I5OTBkOWY1YjRmZTEwYmVmNjk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-15T17:29:22Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-15T21:00:05Z"}, "message": "ModuleTreeDescriptor", "tree": {"sha": "d30f60432f96e256d20e805e1f62a3084f61644a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d30f60432f96e256d20e805e1f62a3084f61644a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58674dc3c415142dbdd93b990d9f5b4fe10bef69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58674dc3c415142dbdd93b990d9f5b4fe10bef69", "html_url": "https://github.com/rust-lang/rust/commit/58674dc3c415142dbdd93b990d9f5b4fe10bef69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58674dc3c415142dbdd93b990d9f5b4fe10bef69/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d59413c895e7b49ed2ad01be35871e417a57a43c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d59413c895e7b49ed2ad01be35871e417a57a43c", "html_url": "https://github.com/rust-lang/rust/commit/d59413c895e7b49ed2ad01be35871e417a57a43c"}], "stats": {"total": 444, "additions": 306, "deletions": 138}, "files": [{"sha": "1111a4f87469ba270c127206fa2c1079a753ebc5", "filename": "crates/libanalysis/src/db/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/58674dc3c415142dbdd93b990d9f5b4fe10bef69/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58674dc3c415142dbdd93b990d9f5b4fe10bef69/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs?ref=58674dc3c415142dbdd93b990d9f5b4fe10bef69", "patch": "@@ -68,22 +68,32 @@ pub(crate) fn file_set(ctx: QueryCtx) -> Arc<(Vec<FileId>, FileResolverImp)> {\n pub(crate) use self::queries::file_syntax;\n \n mod queries {\n+    use std::sync::Arc;\n     use libsyntax2::File;\n+    use libeditor::LineIndex;\n     use {FileId};\n     use super::{Query, QueryCtx, QueryRegistry, file_text};\n \n     pub(crate) fn register_queries(reg: &mut QueryRegistry) {\n-        reg.add(FILE_SYNTAX, \"FILE_SYNTAX\")\n+        reg.add(FILE_SYNTAX, \"FILE_SYNTAX\");\n+        reg.add(FILE_LINES, \"FILE_LINES\");\n     }\n \n     pub(crate) fn file_syntax(ctx: QueryCtx, file_id: FileId) -> File {\n         (&*ctx.get(FILE_SYNTAX, file_id)).clone()\n     }\n+    pub(crate) fn file_lines(ctx: QueryCtx, file_id: FileId) -> Arc<LineIndex> {\n+        ctx.get(FILE_LINES, file_id)\n+    }\n \n     pub(super) const FILE_SYNTAX: Query<FileId, File> = Query(16, |ctx, file_id: &FileId| {\n         let text = file_text(ctx, *file_id);\n         File::parse(&*text)\n     });\n+    pub(super) const FILE_LINES: Query<FileId, LineIndex> = Query(17, |ctx, file_id: &FileId| {\n+        let text = file_text(ctx, *file_id);\n+        LineIndex::new(&*text)\n+    });\n }\n \n impl QueryRegistry {"}, {"sha": "e21ee728ff2c9e1242a7b9ca44f5cc212f9310b8", "filename": "crates/libanalysis/src/descriptors.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/58674dc3c415142dbdd93b990d9f5b4fe10bef69/crates%2Flibanalysis%2Fsrc%2Fdescriptors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58674dc3c415142dbdd93b990d9f5b4fe10bef69/crates%2Flibanalysis%2Fsrc%2Fdescriptors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdescriptors.rs?ref=58674dc3c415142dbdd93b990d9f5b4fe10bef69", "patch": "@@ -0,0 +1,217 @@\n+use std::{\n+    collections::BTreeMap,\n+};\n+use relative_path::RelativePathBuf;\n+use libsyntax2::{\n+    SmolStr,\n+    ast::{self, NameOwner},\n+};\n+use {\n+    FileId,\n+    imp::FileResolverImp,\n+};\n+\n+#[derive(Debug, Hash)]\n+pub struct ModuleDescriptor {\n+    pub submodules: Vec<Submodule>\n+}\n+\n+impl ModuleDescriptor {\n+    pub fn new(root: ast::Root) -> ModuleDescriptor {\n+        let submodules = modules(root)\n+            .map(|(name, _)| Submodule { name })\n+            .collect();\n+\n+        ModuleDescriptor { submodules } }\n+}\n+\n+fn modules<'a>(root: ast::Root<'a>) -> impl Iterator<Item=(SmolStr, ast::Module<'a>)> {\n+    root\n+        .modules()\n+        .filter_map(|module| {\n+            let name = module.name()?.text();\n+            if !module.has_semi() {\n+                return None;\n+            }\n+            Some((name, module))\n+        })\n+}\n+\n+#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n+pub struct Submodule {\n+    pub name: SmolStr,\n+}\n+\n+#[derive(Hash)]\n+pub(crate) struct ModuleTreeDescriptor {\n+    nodes: Vec<NodeData>,\n+    links: Vec<LinkData>,\n+    file_id2node: BTreeMap<FileId, Node>,\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+struct Node(usize);\n+#[derive(Hash)]\n+struct NodeData {\n+    file_id: FileId,\n+    links: Vec<Link>,\n+    parents: Vec<Link>\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct Link(usize);\n+#[derive(Hash)]\n+struct LinkData {\n+    owner: Node,\n+    name: SmolStr,\n+    points_to: Vec<Node>,\n+    problem: Option<Problem>,\n+}\n+\n+\n+#[derive(Clone, Debug, Hash)]\n+pub enum Problem {\n+    UnresolvedModule {\n+        candidate: RelativePathBuf,\n+    },\n+    NotDirOwner {\n+        move_to: RelativePathBuf,\n+        candidate: RelativePathBuf,\n+    }\n+}\n+\n+impl ModuleTreeDescriptor {\n+    pub(crate) fn new<'a>(\n+        files: impl Iterator<Item=(FileId, &'a ModuleDescriptor)> + Clone,\n+        file_resolver: &FileResolverImp,\n+    ) -> ModuleTreeDescriptor {\n+        let mut file_id2node = BTreeMap::new();\n+        let mut nodes: Vec<NodeData> = files.clone().enumerate()\n+            .map(|(idx, (file_id, _))| {\n+                file_id2node.insert(file_id, Node(idx));\n+                NodeData {\n+                    file_id,\n+                    links: Vec::new(),\n+                    parents: Vec::new(),\n+                }\n+            })\n+            .collect();\n+        let mut links = Vec::new();\n+\n+        for (idx, (file_id, descr)) in files.enumerate() {\n+            let owner = Node(idx);\n+            for sub in descr.submodules.iter() {\n+                let link = Link(links.len());\n+                nodes[owner.0].links.push(link);\n+                let (points_to, problem) = resolve_submodule(file_id, &sub.name, file_resolver);\n+                let points_to = points_to\n+                    .into_iter()\n+                    .map(|file_id| {\n+                        let node = file_id2node[&file_id];\n+                        nodes[node.0].parents.push(link);\n+                        node\n+                    })\n+                    .collect();\n+\n+                links.push(LinkData {\n+                    owner,\n+                    name: sub.name.clone(),\n+                    points_to,\n+                    problem,\n+                })\n+\n+            }\n+        }\n+\n+        ModuleTreeDescriptor {\n+            nodes, links, file_id2node\n+        }\n+    }\n+\n+    pub(crate) fn parent_modules(&self, file_id: FileId) -> Vec<Link> {\n+        let node = self.file_id2node[&file_id];\n+        self.node(node)\n+            .parents\n+            .clone()\n+    }\n+    pub(crate) fn child_module_by_name(&self, file_id: FileId, name: &str) -> Vec<FileId> {\n+        let node = self.file_id2node[&file_id];\n+        self.node(node)\n+            .links\n+            .iter()\n+            .filter(|it| it.name(self) == name)\n+            .map(|link| link.owner(self))\n+            .collect()\n+    }\n+    pub(crate) fn problems<'a, 'b>(&'b self, file_id: FileId, root: ast::Root<'a>) -> Vec<(ast::Name<'a>, &'b Problem)> {\n+        let node = self.file_id2node[&file_id];\n+        self.node(node)\n+            .links\n+            .iter()\n+            .filter_map(|&link| {\n+                let problem = self.link(link).problem.as_ref()?;\n+                let name = link.bind_source(self, root).name()?;\n+                Some((name, problem))\n+            })\n+            .collect()\n+    }\n+\n+    fn node(&self, node: Node) -> &NodeData {\n+        &self.nodes[node.0]\n+    }\n+    fn link(&self, link: Link) -> &LinkData {\n+        &self.links[link.0]\n+    }\n+}\n+\n+impl Link {\n+    pub(crate) fn name(self, tree: &ModuleTreeDescriptor) -> SmolStr {\n+        tree.link(self).name.clone()\n+    }\n+    pub(crate) fn owner(self, tree: &ModuleTreeDescriptor) -> FileId {\n+        let owner = tree.link(self).owner;\n+        tree.node(owner).file_id\n+    }\n+    pub(crate) fn bind_source<'a>(self, tree: &ModuleTreeDescriptor, root: ast::Root<'a>) -> ast::Module<'a> {\n+        modules(root)\n+            .filter(|(name, _)| name == &tree.link(self).name)\n+            .next()\n+            .unwrap()\n+            .1\n+    }\n+}\n+\n+\n+fn resolve_submodule(\n+    file_id: FileId,\n+    name: &SmolStr,\n+    file_resolver: &FileResolverImp\n+) -> (Vec<FileId>, Option<Problem>) {\n+    let mod_name = file_resolver.file_stem(file_id);\n+    let is_dir_owner =\n+        mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n+\n+    let file_mod = RelativePathBuf::from(format!(\"../{}.rs\", name));\n+    let dir_mod = RelativePathBuf::from(format!(\"../{}/mod.rs\", name));\n+    let points_to: Vec<FileId>;\n+    let problem: Option<Problem>;\n+    if is_dir_owner {\n+        points_to = [&file_mod, &dir_mod].iter()\n+            .filter_map(|path| file_resolver.resolve(file_id, path))\n+            .collect();\n+        problem = if points_to.is_empty() {\n+            Some(Problem::UnresolvedModule {\n+                candidate: file_mod,\n+            })\n+        } else {\n+            None\n+        }\n+    } else {\n+        points_to = Vec::new();\n+        problem = Some(Problem::NotDirOwner {\n+            move_to: RelativePathBuf::from(format!(\"../{}/mod.rs\", mod_name)),\n+            candidate: file_mod,\n+        });\n+    }\n+    (points_to, problem)\n+}"}, {"sha": "8734813f49cecb88ff97dc17367ba98c47706ebc", "filename": "crates/libanalysis/src/imp.rs", "status": "modified", "additions": 55, "deletions": 69, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/58674dc3c415142dbdd93b990d9f5b4fe10bef69/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58674dc3c415142dbdd93b990d9f5b4fe10bef69/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fimp.rs?ref=58674dc3c415142dbdd93b990d9f5b4fe10bef69", "patch": "@@ -18,8 +18,8 @@ use libsyntax2::{\n use {\n     FileId, FileResolver, Query, Diagnostic, SourceChange, SourceFileEdit, Position, FileSystemEdit,\n     JobToken, CrateGraph, CrateId,\n-    module_map::{ModuleMap, Problem},\n     roots::{SourceRoot, ReadonlySourceRoot, WritableSourceRoot},\n+    descriptors::{ModuleTreeDescriptor, Problem},\n };\n \n \n@@ -148,25 +148,24 @@ impl AnalysisImpl {\n     }\n     pub fn parent_module(&self, file_id: FileId) -> Vec<(FileId, FileSymbol)> {\n         let root = self.root(file_id);\n-        let module_map = root.module_map();\n-        let id = module_map.file2module(file_id);\n-        module_map\n-            .parent_modules(id, &|file_id| root.syntax(file_id))\n-            .into_iter()\n-            .map(|(id, name, node)| {\n-                let id = module_map.module2file(id);\n+        let module_tree = root.module_tree();\n+        module_tree.parent_modules(file_id)\n+            .iter()\n+            .map(|link| {\n+                let file_id = link.owner(&module_tree);\n+                let syntax = root.syntax(file_id);\n+                let decl = link.bind_source(&module_tree, syntax.ast());\n                 let sym = FileSymbol {\n-                    name,\n-                    node_range: node.range(),\n+                    name: link.name(&module_tree),\n+                    node_range: decl.syntax().range(),\n                     kind: MODULE,\n                 };\n-                (id, sym)\n+                (file_id, sym)\n             })\n             .collect()\n     }\n-\n     pub fn crate_for(&self, file_id: FileId) -> Vec<CrateId> {\n-        let module_map = self.root(file_id).module_map();\n+        let module_tree = self.root(file_id).module_tree();\n         let crate_graph = &self.data.crate_graph;\n         let mut res = Vec::new();\n         let mut work = VecDeque::new();\n@@ -177,11 +176,10 @@ impl AnalysisImpl {\n                 res.push(crate_id);\n                 continue;\n             }\n-            let mid = module_map.file2module(id);\n-            let parents = module_map\n-                .parent_module_ids(mid, &|file_id| self.file_syntax(file_id))\n+            let parents = module_tree\n+                .parent_modules(id)\n                 .into_iter()\n-                .map(|id| module_map.module2file(id))\n+                .map(|link| link.owner(&module_tree))\n                 .filter(|&id| visited.insert(id));\n             work.extend(parents);\n         }\n@@ -197,7 +195,7 @@ impl AnalysisImpl {\n         token: &JobToken,\n     ) -> Vec<(FileId, FileSymbol)> {\n         let root = self.root(file_id);\n-        let module_map = root.module_map();\n+        let module_tree = root.module_tree();\n         let file = root.syntax(file_id);\n         let syntax = file.syntax();\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, offset) {\n@@ -206,7 +204,7 @@ impl AnalysisImpl {\n         if let Some(name) = find_node_at_offset::<ast::Name>(syntax, offset) {\n             if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n                 if module.has_semi() {\n-                    let file_ids = self.resolve_module(module_map, file_id, module);\n+                    let file_ids = self.resolve_module(&*module_tree, file_id, module);\n \n                     let res = file_ids.into_iter().map(|id| {\n                         let name = module.name()\n@@ -229,55 +227,51 @@ impl AnalysisImpl {\n \n     pub fn diagnostics(&self, file_id: FileId) -> Vec<Diagnostic> {\n         let root = self.root(file_id);\n-        let module_map = root.module_map();\n+        let module_tree  = root.module_tree();\n         let syntax = root.syntax(file_id);\n \n         let mut res = libeditor::diagnostics(&syntax)\n             .into_iter()\n             .map(|d| Diagnostic { range: d.range, message: d.msg, fix: None })\n             .collect::<Vec<_>>();\n \n-        module_map.problems(\n-            file_id,\n-            &|file_id| self.file_syntax(file_id),\n-            |name_node, problem| {\n-                let diag = match problem {\n-                    Problem::UnresolvedModule { candidate } => {\n-                        let create_file = FileSystemEdit::CreateFile {\n-                            anchor: file_id,\n-                            path: candidate.clone(),\n-                        };\n-                        let fix = SourceChange {\n-                            label: \"create module\".to_string(),\n-                            source_file_edits: Vec::new(),\n-                            file_system_edits: vec![create_file],\n-                            cursor_position: None,\n-                        };\n-                        Diagnostic {\n-                            range: name_node.syntax().range(),\n-                            message: \"unresolved module\".to_string(),\n-                            fix: Some(fix),\n-                        }\n+        for (name_node, problem) in module_tree.problems(file_id, syntax.ast()) {\n+            let diag = match problem {\n+                Problem::UnresolvedModule { candidate } => {\n+                    let create_file = FileSystemEdit::CreateFile {\n+                        anchor: file_id,\n+                        path: candidate.clone(),\n+                    };\n+                    let fix = SourceChange {\n+                        label: \"create module\".to_string(),\n+                        source_file_edits: Vec::new(),\n+                        file_system_edits: vec![create_file],\n+                        cursor_position: None,\n+                    };\n+                    Diagnostic {\n+                        range: name_node.syntax().range(),\n+                        message: \"unresolved module\".to_string(),\n+                        fix: Some(fix),\n                     }\n-                    Problem::NotDirOwner { move_to, candidate } => {\n-                        let move_file = FileSystemEdit::MoveFile { file: file_id, path: move_to.clone() };\n-                        let create_file = FileSystemEdit::CreateFile { anchor: file_id, path: move_to.join(candidate) };\n-                        let fix = SourceChange {\n-                            label: \"move file and create module\".to_string(),\n-                            source_file_edits: Vec::new(),\n-                            file_system_edits: vec![move_file, create_file],\n-                            cursor_position: None,\n-                        };\n-                        Diagnostic {\n-                            range: name_node.syntax().range(),\n-                            message: \"can't declare module at this location\".to_string(),\n-                            fix: Some(fix),\n-                        }\n+                }\n+                Problem::NotDirOwner { move_to, candidate } => {\n+                    let move_file = FileSystemEdit::MoveFile { file: file_id, path: move_to.clone() };\n+                    let create_file = FileSystemEdit::CreateFile { anchor: file_id, path: move_to.join(candidate) };\n+                    let fix = SourceChange {\n+                        label: \"move file and create module\".to_string(),\n+                        source_file_edits: Vec::new(),\n+                        file_system_edits: vec![move_file, create_file],\n+                        cursor_position: None,\n+                    };\n+                    Diagnostic {\n+                        range: name_node.syntax().range(),\n+                        message: \"can't declare module at this location\".to_string(),\n+                        fix: Some(fix),\n                     }\n-                };\n-                res.push(diag)\n-            }\n-        );\n+                }\n+            };\n+            res.push(diag)\n+        }\n         res\n     }\n \n@@ -307,20 +301,12 @@ impl AnalysisImpl {\n         self.world_symbols(query, token)\n     }\n \n-    fn resolve_module(&self, module_map: &ModuleMap, file_id: FileId, module: ast::Module) -> Vec<FileId> {\n+    fn resolve_module(&self, module_tree: &ModuleTreeDescriptor, file_id: FileId, module: ast::Module) -> Vec<FileId> {\n         let name = match module.name() {\n             Some(name) => name.text(),\n             None => return Vec::new(),\n         };\n-        let id = module_map.file2module(file_id);\n-        module_map\n-            .child_module_by_name(\n-                id, name.as_str(),\n-                &|file_id| self.file_syntax(file_id),\n-            )\n-            .into_iter()\n-            .map(|id| module_map.module2file(id))\n-            .collect()\n+        module_tree.child_module_by_name(file_id, name.as_str())\n     }\n \n     fn reindex(&self) {"}, {"sha": "ea3a2870223753ac28be6970b2bba6e93d727689", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58674dc3c415142dbdd93b990d9f5b4fe10bef69/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58674dc3c415142dbdd93b990d9f5b4fe10bef69/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=58674dc3c415142dbdd93b990d9f5b4fe10bef69", "patch": "@@ -19,6 +19,7 @@ mod imp;\n mod job;\n mod roots;\n mod db;\n+mod descriptors;\n \n use std::{\n     sync::Arc,"}, {"sha": "fb298a315d8e6bee61e752e23476aa0101be156d", "filename": "crates/libanalysis/src/module_map_db/descr.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d59413c895e7b49ed2ad01be35871e417a57a43c/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db%2Fdescr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d59413c895e7b49ed2ad01be35871e417a57a43c/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db%2Fdescr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db%2Fdescr.rs?ref=d59413c895e7b49ed2ad01be35871e417a57a43c", "patch": "@@ -1,29 +0,0 @@\n-use libsyntax2::{\n-    SmolStr,\n-    ast::{self, NameOwner},\n-};\n-\n-#[derive(Debug, Hash)]\n-pub struct ModuleDescr {\n-    pub submodules: Vec<Submodule>\n-}\n-\n-impl ModuleDescr {\n-    pub fn new(root: ast::Root) -> ModuleDescr {\n-        let submodules = root\n-            .modules()\n-            .filter_map(|module| {\n-                let name = module.name()?.text();\n-                if !module.has_semi() {\n-                    return None;\n-                }\n-                Some(Submodule { name })\n-            }).collect();\n-\n-        ModuleDescr { submodules } }\n-}\n-\n-#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n-pub struct Submodule {\n-    pub name: SmolStr,\n-}"}, {"sha": "adad943da50a0903cf08b9959784d9defdba8dd4", "filename": "crates/libanalysis/src/module_map_db/mod.rs", "status": "modified", "additions": 16, "deletions": 31, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/58674dc3c415142dbdd93b990d9f5b4fe10bef69/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58674dc3c415142dbdd93b990d9f5b4fe10bef69/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db%2Fmod.rs?ref=58674dc3c415142dbdd93b990d9f5b4fe10bef69", "patch": "@@ -1,55 +1,40 @@\n-mod descr;\n-\n use std::sync::Arc;\n use {\n     FileId,\n     db::{\n         Query, QueryRegistry, QueryCtx,\n         file_syntax, file_set\n     },\n-    module_map::resolve_submodule,\n+    descriptors::{ModuleDescriptor, ModuleTreeDescriptor}\n };\n \n pub(crate) fn register_queries(reg: &mut QueryRegistry) {\n     reg.add(MODULE_DESCR, \"MODULE_DESCR\");\n-    reg.add(RESOLVE_SUBMODULE, \"RESOLVE_SUBMODULE\");\n-    reg.add(PARENT_MODULE, \"PARENT_MODULE\");\n+}\n+\n+pub(crate) fn module_tree(ctx: QueryCtx) -> Arc<ModuleTreeDescriptor> {\n+    ctx.get(MODULE_TREE, ())\n }\n \n impl<'a> QueryCtx<'a> {\n-    fn module_descr(&self, file_id: FileId) -> Arc<descr::ModuleDescr> {\n+    fn module_descr(&self, file_id: FileId) -> Arc<ModuleDescriptor> {\n         self.get(MODULE_DESCR, file_id)\n     }\n-    fn resolve_submodule(&self, file_id: FileId, submod: descr::Submodule) -> Arc<Vec<FileId>> {\n-        self.get(RESOLVE_SUBMODULE, (file_id, submod))\n-    }\n }\n \n-const MODULE_DESCR: Query<FileId, descr::ModuleDescr> = Query(30, |ctx, &file_id| {\n+const MODULE_DESCR: Query<FileId, ModuleDescriptor> = Query(30, |ctx, &file_id| {\n     let file = file_syntax(ctx, file_id);\n-    descr::ModuleDescr::new(file.ast())\n+    ModuleDescriptor::new(file.ast())\n });\n \n-const RESOLVE_SUBMODULE: Query<(FileId, descr::Submodule), Vec<FileId>> = Query(31, |ctx, params| {\n-    let files = file_set(ctx);\n-    resolve_submodule(params.0, &params.1.name, &files.1).0\n-});\n-\n-const PARENT_MODULE: Query<FileId, Vec<FileId>> = Query(40, |ctx, file_id| {\n-    let files = file_set(ctx);\n-    let res = files.0.iter()\n-        .map(|&parent_id| (parent_id, ctx.module_descr(parent_id)))\n-        .filter(|(parent_id, descr)| {\n-            descr.submodules.iter()\n-                .any(|subm| {\n-                    ctx.resolve_submodule(*parent_id, subm.clone())\n-                        .iter()\n-                        .any(|it| it == file_id)\n-                })\n-        })\n-        .map(|(id, _)| id)\n-        .collect();\n-    res\n+const MODULE_TREE: Query<(), ModuleTreeDescriptor> = Query(31, |ctx, _| {\n+    let file_set = file_set(ctx);\n+    let mut files = Vec::new();\n+    for &file_id in file_set.0.iter() {\n+        let module_descr = ctx.get(MODULE_DESCR, file_id);\n+        files.push((file_id, module_descr));\n+    }\n+    ModuleTreeDescriptor::new(files.iter().map(|(file_id, descr)| (*file_id, &**descr)), &file_set.1)\n });\n \n #[cfg(test)]"}, {"sha": "b925fd24d53ac2124c6caf0e621fade8ac0f48e3", "filename": "crates/libanalysis/src/roots.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/58674dc3c415142dbdd93b990d9f5b4fe10bef69/crates%2Flibanalysis%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58674dc3c415142dbdd93b990d9f5b4fe10bef69/crates%2Flibanalysis%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Froots.rs?ref=58674dc3c415142dbdd93b990d9f5b4fe10bef69", "patch": "@@ -15,11 +15,15 @@ use {\n     imp::FileResolverImp,\n     module_map::{ModuleMap, ChangeKind},\n     symbol_index::SymbolIndex,\n+    descriptors::ModuleTreeDescriptor,\n };\n \n pub(crate) trait SourceRoot {\n     fn contains(&self, file_id: FileId) -> bool;\n-    fn module_map(&self) -> &ModuleMap;\n+    fn module_tree(&self) -> Arc<ModuleTreeDescriptor> {\n+        unimplemented!()\n+    }\n+    // fn module_map(&self) -> &ModuleMap;\n     fn lines(&self, file_id: FileId) -> &LineIndex;\n     fn syntax(&self, file_id: FileId) -> &File;\n     fn symbols<'a>(&'a self, acc: &mut Vec<&'a SymbolIndex>);\n@@ -74,9 +78,6 @@ impl SourceRoot for WritableSourceRoot {\n     fn contains(&self, file_id: FileId) -> bool {\n         self.file_map.contains_key(&file_id)\n     }\n-    fn module_map(&self) -> &ModuleMap {\n-        &self.module_map\n-    }\n     fn lines(&self, file_id: FileId) -> &LineIndex {\n         self.data(file_id).lines()\n     }\n@@ -175,9 +176,6 @@ impl SourceRoot for ReadonlySourceRoot {\n     fn contains(&self, file_id: FileId) -> bool {\n         self.file_map.contains_key(&file_id)\n     }\n-    fn module_map(&self) -> &ModuleMap {\n-        &self.module_map\n-    }\n     fn lines(&self, file_id: FileId) -> &LineIndex {\n         self.data(file_id).lines()\n     }"}, {"sha": "9cd8da3a893fbc2bc574a2108d31556f1f109181", "filename": "crates/libeditor/src/line_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58674dc3c415142dbdd93b990d9f5b4fe10bef69/crates%2Flibeditor%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58674dc3c415142dbdd93b990d9f5b4fe10bef69/crates%2Flibeditor%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fline_index.rs?ref=58674dc3c415142dbdd93b990d9f5b4fe10bef69", "patch": "@@ -1,7 +1,7 @@\n use superslice::Ext;\n use ::TextUnit;\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, Hash)]\n pub struct LineIndex {\n     newlines: Vec<TextUnit>,\n }"}]}