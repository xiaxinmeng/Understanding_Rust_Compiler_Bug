{"sha": "2561b7ea062f0c07f27d9ebdf0c355ab29a4edf9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1NjFiN2VhMDYyZjBjMDdmMjdkOWViZGYwYzM1NWFiMjlhNGVkZjk=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-06T08:46:50Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-11T10:40:24Z"}, "message": "move from_iter_insteam_of_collect to its own module", "tree": {"sha": "6f16adb75b7e4f617795e7cef98a9bdf1c7c184f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f16adb75b7e4f617795e7cef98a9bdf1c7c184f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2561b7ea062f0c07f27d9ebdf0c355ab29a4edf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2561b7ea062f0c07f27d9ebdf0c355ab29a4edf9", "html_url": "https://github.com/rust-lang/rust/commit/2561b7ea062f0c07f27d9ebdf0c355ab29a4edf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2561b7ea062f0c07f27d9ebdf0c355ab29a4edf9/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c8d143515a19b04a404765ecb8145a183dc2186", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c8d143515a19b04a404765ecb8145a183dc2186", "html_url": "https://github.com/rust-lang/rust/commit/0c8d143515a19b04a404765ecb8145a183dc2186"}], "stats": {"total": 129, "additions": 69, "deletions": 60}, "files": [{"sha": "e50d0a3340026d466f521ca5660bbe65c6935405", "filename": "clippy_lints/src/methods/from_iter_instead_of_collect.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2561b7ea062f0c07f27d9ebdf0c355ab29a4edf9/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2561b7ea062f0c07f27d9ebdf0c355ab29a4edf9/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs?ref=2561b7ea062f0c07f27d9ebdf0c355ab29a4edf9", "patch": "@@ -0,0 +1,67 @@\n+use crate::utils::{get_trait_def_id, implements_trait, paths, span_lint_and_sugg, sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::ty::Ty;\n+\n+use super::FROM_ITER_INSTEAD_OF_COLLECT;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    let arg_ty = cx.typeck_results().expr_ty(&args[0]);\n+\n+    if_chain! {\n+        if let Some(from_iter_id) = get_trait_def_id(cx, &paths::FROM_ITERATOR);\n+        if let Some(iter_id) = get_trait_def_id(cx, &paths::ITERATOR);\n+\n+        if implements_trait(cx, ty, from_iter_id, &[]) && implements_trait(cx, arg_ty, iter_id, &[]);\n+        then {\n+            // `expr` implements `FromIterator` trait\n+            let iter_expr = sugg::Sugg::hir(cx, &args[0], \"..\").maybe_par();\n+            let turbofish = extract_turbofish(cx, expr, ty);\n+            let sugg = format!(\"{}.collect::<{}>()\", iter_expr, turbofish);\n+            span_lint_and_sugg(\n+                cx,\n+                FROM_ITER_INSTEAD_OF_COLLECT,\n+                expr.span,\n+                \"usage of `FromIterator::from_iter`\",\n+                \"use `.collect()` instead of `::from_iter()`\",\n+                sugg,\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+}\n+\n+fn extract_turbofish(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ty: Ty<'tcx>) -> String {\n+    if_chain! {\n+        let call_site = expr.span.source_callsite();\n+        if let Ok(snippet) = cx.sess().source_map().span_to_snippet(call_site);\n+        let snippet_split = snippet.split(\"::\").collect::<Vec<_>>();\n+        if let Some((_, elements)) = snippet_split.split_last();\n+\n+        then {\n+            // is there a type specifier? (i.e.: like `<u32>` in `collections::BTreeSet::<u32>::`)\n+            if let Some(type_specifier) = snippet_split.iter().find(|e| e.starts_with('<') && e.ends_with('>')) {\n+                // remove the type specifier from the path elements\n+                let without_ts = elements.iter().filter_map(|e| {\n+                    if e == type_specifier { None } else { Some((*e).to_string()) }\n+                }).collect::<Vec<_>>();\n+                // join and add the type specifier at the end (i.e.: `collections::BTreeSet<u32>`)\n+                format!(\"{}{}\", without_ts.join(\"::\"), type_specifier)\n+            } else {\n+                // type is not explicitly specified so wildcards are needed\n+                // i.e.: 2 wildcards in `std::collections::BTreeMap<&i32, &char>`\n+                let ty_str = ty.to_string();\n+                let start = ty_str.find('<').unwrap_or(0);\n+                let end = ty_str.find('>').unwrap_or_else(|| ty_str.len());\n+                let nb_wildcard = ty_str[start..end].split(',').count();\n+                let wildcards = format!(\"_{}\", \", _\".repeat(nb_wildcard - 1));\n+                format!(\"{}<{}>\", elements.join(\"::\"), wildcards)\n+            }\n+        } else {\n+            ty.to_string()\n+        }\n+    }\n+}"}, {"sha": "9a0ef6c01c1a26e5a990f6128f8e3bbf1f6a2f6f", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 60, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2561b7ea062f0c07f27d9ebdf0c355ab29a4edf9/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2561b7ea062f0c07f27d9ebdf0c355ab29a4edf9/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=2561b7ea062f0c07f27d9ebdf0c355ab29a4edf9", "patch": "@@ -5,6 +5,7 @@ mod expect_used;\n mod filetype_is_file;\n mod filter_map_identity;\n mod filter_next;\n+mod from_iter_instead_of_collect;\n mod get_unwrap;\n mod implicit_clone;\n mod inefficient_to_string;\n@@ -1761,7 +1762,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             hir::ExprKind::Call(ref func, ref args) => {\n                 if let hir::ExprKind::Path(path) = &func.kind {\n                     if match_qpath(path, &[\"from_iter\"]) {\n-                        lint_from_iter(cx, expr, args);\n+                        from_iter_instead_of_collect::check(cx, expr, args);\n                     }\n                 }\n             },\n@@ -3440,65 +3441,6 @@ fn is_bool(ty: &hir::Ty<'_>) -> bool {\n     }\n }\n \n-fn lint_from_iter(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let ty = cx.typeck_results().expr_ty(expr);\n-    let arg_ty = cx.typeck_results().expr_ty(&args[0]);\n-\n-    if_chain! {\n-        if let Some(from_iter_id) = get_trait_def_id(cx, &paths::FROM_ITERATOR);\n-        if let Some(iter_id) = get_trait_def_id(cx, &paths::ITERATOR);\n-\n-        if implements_trait(cx, ty, from_iter_id, &[]) && implements_trait(cx, arg_ty, iter_id, &[]);\n-        then {\n-            // `expr` implements `FromIterator` trait\n-            let iter_expr = sugg::Sugg::hir(cx, &args[0], \"..\").maybe_par();\n-            let turbofish = extract_turbofish(cx, expr, ty);\n-            let sugg = format!(\"{}.collect::<{}>()\", iter_expr, turbofish);\n-            span_lint_and_sugg(\n-                cx,\n-                FROM_ITER_INSTEAD_OF_COLLECT,\n-                expr.span,\n-                \"usage of `FromIterator::from_iter`\",\n-                \"use `.collect()` instead of `::from_iter()`\",\n-                sugg,\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-    }\n-}\n-\n-fn extract_turbofish(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ty: Ty<'tcx>) -> String {\n-    if_chain! {\n-        let call_site = expr.span.source_callsite();\n-        if let Ok(snippet) = cx.sess().source_map().span_to_snippet(call_site);\n-        let snippet_split = snippet.split(\"::\").collect::<Vec<_>>();\n-        if let Some((_, elements)) = snippet_split.split_last();\n-\n-        then {\n-            // is there a type specifier? (i.e.: like `<u32>` in `collections::BTreeSet::<u32>::`)\n-            if let Some(type_specifier) = snippet_split.iter().find(|e| e.starts_with('<') && e.ends_with('>')) {\n-                // remove the type specifier from the path elements\n-                let without_ts = elements.iter().filter_map(|e| {\n-                    if e == type_specifier { None } else { Some((*e).to_string()) }\n-                }).collect::<Vec<_>>();\n-                // join and add the type specifier at the end (i.e.: `collections::BTreeSet<u32>`)\n-                format!(\"{}{}\", without_ts.join(\"::\"), type_specifier)\n-            } else {\n-                // type is not explicitly specified so wildcards are needed\n-                // i.e.: 2 wildcards in `std::collections::BTreeMap<&i32, &char>`\n-                let ty_str = ty.to_string();\n-                let start = ty_str.find('<').unwrap_or(0);\n-                let end = ty_str.find('>').unwrap_or_else(|| ty_str.len());\n-                let nb_wildcard = ty_str[start..end].split(',').count();\n-                let wildcards = format!(\"_{}\", \", _\".repeat(nb_wildcard - 1));\n-                format!(\"{}<{}>\", elements.join(\"::\"), wildcards)\n-            }\n-        } else {\n-            ty.to_string()\n-        }\n-    }\n-}\n-\n fn fn_header_equals(expected: hir::FnHeader, actual: hir::FnHeader) -> bool {\n     expected.constness == actual.constness\n         && expected.unsafety == actual.unsafety"}]}