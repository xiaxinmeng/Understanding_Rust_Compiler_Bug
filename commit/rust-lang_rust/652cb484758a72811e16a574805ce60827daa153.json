{"sha": "652cb484758a72811e16a574805ce60827daa153", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MmNiNDg0NzU4YTcyODExZTE2YTU3NDgwNWNlNjA4MjdkYWExNTM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-04T02:18:51Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-04T02:18:59Z"}, "message": "Assortment of additional work on vec-append. Not done yet.", "tree": {"sha": "6dfe80b6c6f6c09131ccee0b424071bda4d5b183", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dfe80b6c6f6c09131ccee0b424071bda4d5b183"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/652cb484758a72811e16a574805ce60827daa153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/652cb484758a72811e16a574805ce60827daa153", "html_url": "https://github.com/rust-lang/rust/commit/652cb484758a72811e16a574805ce60827daa153", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/652cb484758a72811e16a574805ce60827daa153/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "629eba1d066ba4295baf4bfed41cae240c527af5", "url": "https://api.github.com/repos/rust-lang/rust/commits/629eba1d066ba4295baf4bfed41cae240c527af5", "html_url": "https://github.com/rust-lang/rust/commit/629eba1d066ba4295baf4bfed41cae240c527af5"}], "stats": {"total": 99, "additions": 73, "deletions": 26}, "files": [{"sha": "dd058590ae25522fe6c8b3695b14f6b043342398", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/652cb484758a72811e16a574805ce60827daa153/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652cb484758a72811e16a574805ce60827daa153/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=652cb484758a72811e16a574805ce60827daa153", "patch": "@@ -71,8 +71,8 @@ fn bzero_glue_name() -> str {\n     ret \"rust_bzero_glue\";\n }\n \n-fn vec_grow_glue_name() -> str {\n-    ret \"rust_vec_grow_glue\";\n+fn vec_append_glue_name() -> str {\n+    ret \"rust_vec_append_glue\";\n }\n \n fn upcall_glue_name(int n) -> str {"}, {"sha": "038e0baf84fb1ff26c33eb7305e09f06d58f4c76", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 62, "deletions": 24, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/652cb484758a72811e16a574805ce60827daa153/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652cb484758a72811e16a574805ce60827daa153/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=652cb484758a72811e16a574805ce60827daa153", "patch": "@@ -58,7 +58,7 @@ type glue_fns = rec(ValueRef activate_glue,\n                     ValueRef no_op_type_glue,\n                     ValueRef memcpy_glue,\n                     ValueRef bzero_glue,\n-                    ValueRef vec_grow_glue);\n+                    ValueRef vec_append_glue);\n \n type tag_info = rec(type_handle th);\n \n@@ -2296,17 +2296,39 @@ fn trans_integral_compare(@block_ctxt cx, ast.binop op, @ty.t intype,\n     ret cx.build.ICmp(cmp, lhs, rhs);\n }\n \n-fn trans_sequence_append(@block_ctxt cx, @ty.t t,\n-                         ValueRef lhs, ValueRef rhs) -> result {\n-    cx.fcx.ccx.sess.unimpl(\"sequence append\");\n-    fail;\n+fn trans_vec_append(@block_ctxt cx, @ty.t t,\n+                    ValueRef lhs, ValueRef rhs) -> result {\n+\n+    auto elt_ty = ty.sequence_element_type(t);\n+\n+    auto skip_null = C_bool(false);\n+    alt (t.struct) {\n+        case (ty.ty_str) { skip_null = C_bool(true); }\n+        case (_) { }\n+    }\n+\n+    auto bcx = cx;\n+\n+    auto llvec_tydesc = get_tydesc(bcx, t);\n+    bcx = llvec_tydesc.bcx;\n+\n+    auto llelt_tydesc = get_tydesc(bcx, elt_ty);\n+    bcx = llelt_tydesc.bcx;\n+\n+    ret res(cx, cx.build.FastCall(cx.fcx.ccx.glues.memcpy_glue,\n+                                  vec(cx.fcx.lltaskptr,\n+                                      llvec_tydesc.val,\n+                                      llelt_tydesc.val,\n+                                      lhs,\n+                                      load_scalar_or_boxed(cx, rhs, t),\n+                                      skip_null)));\n }\n \n-fn trans_sequence_add(@block_ctxt cx, @ty.t t,\n-                      ValueRef lhs, ValueRef rhs) -> result {\n+fn trans_vec_add(@block_ctxt cx, @ty.t t,\n+                 ValueRef lhs, ValueRef rhs) -> result {\n     auto r = alloc_ty(cx, t);\n     r = copy_ty(r.bcx, INIT, r.val, lhs, t);\n-    ret trans_sequence_append(r.bcx, t, lhs, rhs);\n+    ret trans_vec_append(r.bcx, t, lhs, rhs);\n }\n \n \n@@ -2316,7 +2338,7 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op, @ty.t intype,\n     alt (op) {\n         case (ast.add) {\n             if (ty.type_is_sequence(intype)) {\n-                ret trans_sequence_add(cx, intype, lhs, rhs);\n+                ret trans_vec_add(cx, intype, lhs, rhs);\n             }\n             ret res(cx, cx.build.Add(lhs, rhs));\n         }\n@@ -5296,9 +5318,9 @@ fn make_bzero_glue(ModuleRef llmod) -> ValueRef {\n     ret fun;\n }\n \n-fn make_vec_grow_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n+fn make_vec_append_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n     /*\n-     * Args to vec_grow_glue:\n+     * Args to vec_append_glue:\n      *\n      *   0. (Implicit) task ptr\n      *\n@@ -5309,31 +5331,35 @@ fn make_vec_grow_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n      *      elements can be copied to a newly alloc'ed vec if one must be\n      *      created.\n      *\n-     *   3. Alias to vec that needs to grow (i.e. ptr to ptr to rust_vec).\n+     *   3. Dst vec alias (i.e. ptr to ptr to rust_vec, we will mutate it).\n+     *\n+     *   4. Src vec (i.e. ptr to rust_vec).\n      *\n-     *   4. Number of bytes of growth requested\n+     *   5. Flag indicating whether to skip trailing null on dst.\n      *\n      */\n \n     auto ty = T_fn(vec(T_taskptr(tn),\n                        T_ptr(T_tydesc(tn)),\n                        T_ptr(T_tydesc(tn)),\n                        T_ptr(T_ptr(T_vec(T_int()))), // a lie.\n-                       T_int()), T_void());\n+                       T_ptr(T_vec(T_int())), // a lie.\n+                       T_bool()), T_void());\n \n-    auto llfn = decl_fastcall_fn(llmod, abi.vec_grow_glue_name(), ty);\n+    auto llfn = decl_fastcall_fn(llmod, abi.vec_append_glue_name(), ty);\n     ret llfn;\n }\n \n-fn trans_vec_grow_glue(@crate_ctxt cx) {\n+fn trans_vec_append_glue(@crate_ctxt cx) {\n \n-    auto llfn = cx.glues.vec_grow_glue;\n+    auto llfn = cx.glues.vec_append_glue;\n \n     let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 0u);\n     let ValueRef llvec_tydesc = llvm.LLVMGetParam(llfn, 1u);\n     let ValueRef llelt_tydesc = llvm.LLVMGetParam(llfn, 2u);\n-    let ValueRef llvec_ptr = llvm.LLVMGetParam(llfn, 3u);\n-    let ValueRef llnbytes = llvm.LLVMGetParam(llfn, 4u);\n+    let ValueRef lldst_vec_ptr = llvm.LLVMGetParam(llfn, 3u);\n+    let ValueRef llsrc_vec = llvm.LLVMGetParam(llfn, 4u);\n+    let ValueRef llskipnull = llvm.LLVMGetParam(llfn, 5u);\n \n     auto fcx = @rec(llfn=llfn,\n                     lltaskptr=lltaskptr,\n@@ -5349,12 +5375,23 @@ fn trans_vec_grow_glue(@crate_ctxt cx) {\n \n     auto bcx = new_top_block_ctxt(fcx);\n \n-    auto llneed_copy_ptr = bcx.build.Alloca(T_int());\n+    // First the dst vec needs to grow to accommodate the src vec.\n+    // To do this we have to figure out how many bytes to add.\n+    auto n_bytes =\n+        bcx.build.Load(bcx.build.GEP(llsrc_vec,\n+                                     vec(C_int(0),\n+                                         C_int(abi.vec_elt_fill))));\n \n+    n_bytes = bcx.build.Select(llskipnull,\n+                               bcx.build.Sub(n_bytes, C_int(1)),\n+                               n_bytes);\n+\n+\n+    auto llneed_copy_ptr = bcx.build.Alloca(T_int());\n     auto llnew_vec_res =\n         trans_upcall(bcx, \"upcall_vec_grow\",\n-                     vec(vp2i(bcx, bcx.build.Load(llvec_ptr)),\n-                         llnbytes,\n+                     vec(vp2i(bcx, bcx.build.Load(lldst_vec_ptr)),\n+                         n_bytes,\n                          vp2i(bcx, llneed_copy_ptr),\n                          vp2i(bcx, llvec_tydesc)));\n \n@@ -5364,6 +5401,7 @@ fn trans_vec_grow_glue(@crate_ctxt cx) {\n                           T_ptr(T_vec(T_int())) // a lie.\n                           );\n \n+\n     // FIXME: complete this.\n \n     bcx.build.RetVoid();\n@@ -5396,7 +5434,7 @@ fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n              no_op_type_glue = make_no_op_type_glue(llmod, tn),\n              memcpy_glue = make_memcpy_glue(llmod),\n              bzero_glue = make_bzero_glue(llmod),\n-             vec_grow_glue = make_vec_grow_glue(llmod, tn));\n+             vec_append_glue = make_vec_append_glue(llmod, tn));\n }\n \n fn trans_crate(session.session sess, @ast.crate crate, str output,\n@@ -5456,7 +5494,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n \n     trans_mod(cx, crate.node.module);\n     trans_exit_task_glue(cx);\n-    trans_vec_grow_glue(cx);\n+    trans_vec_append_glue(cx);\n     create_crate_constant(cx);\n     if (!shared) {\n         trans_main_fn(cx, cx.crate_ptr);"}, {"sha": "2fc3160cc0103b1b8f1f5ee2b02661bf73b8f62e", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/652cb484758a72811e16a574805ce60827daa153/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652cb484758a72811e16a574805ce60827daa153/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=652cb484758a72811e16a574805ce60827daa153", "patch": "@@ -417,6 +417,15 @@ fn type_is_sequence(@t ty) -> bool {\n     fail;\n }\n \n+fn sequence_element_type(@t ty) -> @t {\n+    alt (ty.struct) {\n+        case (ty_str)     { ret plain_ty(ty_machine(common.ty_u8)); }\n+        case (ty_vec(?e)) { ret e; }\n+    }\n+    fail;\n+}\n+\n+\n fn type_is_tup_like(@t ty) -> bool {\n     alt (ty.struct) {\n         case (ty_box(_))    { ret true; }"}]}