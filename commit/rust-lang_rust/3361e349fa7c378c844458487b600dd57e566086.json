{"sha": "3361e349fa7c378c844458487b600dd57e566086", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzNjFlMzQ5ZmE3YzM3OGM4NDQ0NTg0ODdiNjAwZGQ1N2U1NjYwODY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-07-26T12:55:13Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-07-26T12:55:13Z"}, "message": "Don't return anything from codegen_with_call_return_arg", "tree": {"sha": "8c43fef5712e77e935f997e26d840b06bc719001", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c43fef5712e77e935f997e26d840b06bc719001"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3361e349fa7c378c844458487b600dd57e566086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3361e349fa7c378c844458487b600dd57e566086", "html_url": "https://github.com/rust-lang/rust/commit/3361e349fa7c378c844458487b600dd57e566086", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3361e349fa7c378c844458487b600dd57e566086/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83da1e0d5abade2dda76bca0548b9431054c7d36", "url": "https://api.github.com/repos/rust-lang/rust/commits/83da1e0d5abade2dda76bca0548b9431054c7d36", "html_url": "https://github.com/rust-lang/rust/commit/83da1e0d5abade2dda76bca0548b9431054c7d36"}], "stats": {"total": 123, "additions": 60, "deletions": 63}, "files": [{"sha": "ff7a7f819bcf791c1620ac43c04d65b1798d0457", "filename": "src/abi/mod.rs", "status": "modified", "additions": 56, "deletions": 57, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/3361e349fa7c378c844458487b600dd57e566086/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3361e349fa7c378c844458487b600dd57e566086/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=3361e349fa7c378c844458487b600dd57e566086", "patch": "@@ -424,66 +424,65 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     };\n \n     let ret_place = destination.map(|(place, _)| place);\n-    let (call_inst, call_args) = self::returning::codegen_with_call_return_arg(\n-        fx,\n-        &fn_abi.ret,\n-        ret_place,\n-        |fx, return_ptr| {\n-            let regular_args_count = args.len();\n-            let mut call_args: Vec<Value> = return_ptr\n-                .into_iter()\n-                .chain(first_arg_override.into_iter())\n-                .chain(\n-                    args.into_iter()\n-                        .enumerate()\n-                        .skip(if first_arg_override.is_some() { 1 } else { 0 })\n-                        .map(|(i, arg)| adjust_arg_for_abi(fx, arg, &fn_abi.args[i]).into_iter())\n-                        .flatten(),\n-                )\n-                .collect::<Vec<_>>();\n-\n-            if instance.map(|inst| inst.def.requires_caller_location(fx.tcx)).unwrap_or(false) {\n-                // Pass the caller location for `#[track_caller]`.\n-                let caller_location = fx.get_caller_location(span);\n-                call_args.extend(\n-                    adjust_arg_for_abi(fx, caller_location, &fn_abi.args[regular_args_count])\n-                        .into_iter(),\n-                );\n-                assert_eq!(fn_abi.args.len(), regular_args_count + 1);\n-            } else {\n-                assert_eq!(fn_abi.args.len(), regular_args_count);\n-            }\n-\n-            let call_inst = match func_ref {\n-                CallTarget::Direct(func_ref) => fx.bcx.ins().call(func_ref, &call_args),\n-                CallTarget::Indirect(sig, func_ptr) => {\n-                    fx.bcx.ins().call_indirect(sig, func_ptr, &call_args)\n-                }\n-            };\n+    self::returning::codegen_with_call_return_arg(fx, &fn_abi.ret, ret_place, |fx, return_ptr| {\n+        let regular_args_count = args.len();\n+        let mut call_args: Vec<Value> = return_ptr\n+            .into_iter()\n+            .chain(first_arg_override.into_iter())\n+            .chain(\n+                args.into_iter()\n+                    .enumerate()\n+                    .skip(if first_arg_override.is_some() { 1 } else { 0 })\n+                    .map(|(i, arg)| adjust_arg_for_abi(fx, arg, &fn_abi.args[i]).into_iter())\n+                    .flatten(),\n+            )\n+            .collect::<Vec<_>>();\n+\n+        if instance.map(|inst| inst.def.requires_caller_location(fx.tcx)).unwrap_or(false) {\n+            // Pass the caller location for `#[track_caller]`.\n+            let caller_location = fx.get_caller_location(span);\n+            call_args.extend(\n+                adjust_arg_for_abi(fx, caller_location, &fn_abi.args[regular_args_count])\n+                    .into_iter(),\n+            );\n+            assert_eq!(fn_abi.args.len(), regular_args_count + 1);\n+        } else {\n+            assert_eq!(fn_abi.args.len(), regular_args_count);\n+        }\n \n-            (call_inst, call_args)\n-        },\n-    );\n+        let call_inst = match func_ref {\n+            CallTarget::Direct(func_ref) => fx.bcx.ins().call(func_ref, &call_args),\n+            CallTarget::Indirect(sig, func_ptr) => {\n+                fx.bcx.ins().call_indirect(sig, func_ptr, &call_args)\n+            }\n+        };\n \n-    // FIXME find a cleaner way to support varargs\n-    if fn_sig.c_variadic {\n-        if !matches!(fn_sig.abi, Abi::C { .. }) {\n-            fx.tcx.sess.span_fatal(span, &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi));\n+        // FIXME find a cleaner way to support varargs\n+        if fn_sig.c_variadic {\n+            if !matches!(fn_sig.abi, Abi::C { .. }) {\n+                fx.tcx\n+                    .sess\n+                    .span_fatal(span, &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi));\n+            }\n+            let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n+            let abi_params = call_args\n+                .into_iter()\n+                .map(|arg| {\n+                    let ty = fx.bcx.func.dfg.value_type(arg);\n+                    if !ty.is_int() {\n+                        // FIXME set %al to upperbound on float args once floats are supported\n+                        fx.tcx\n+                            .sess\n+                            .span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n+                    }\n+                    AbiParam::new(ty)\n+                })\n+                .collect::<Vec<AbiParam>>();\n+            fx.bcx.func.dfg.signatures[sig_ref].params = abi_params;\n         }\n-        let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n-        let abi_params = call_args\n-            .into_iter()\n-            .map(|arg| {\n-                let ty = fx.bcx.func.dfg.value_type(arg);\n-                if !ty.is_int() {\n-                    // FIXME set %al to upperbound on float args once floats are supported\n-                    fx.tcx.sess.span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n-                }\n-                AbiParam::new(ty)\n-            })\n-            .collect::<Vec<AbiParam>>();\n-        fx.bcx.func.dfg.signatures[sig_ref].params = abi_params;\n-    }\n+\n+        call_inst\n+    });\n \n     if let Some((_, dest)) = destination {\n         let ret_block = fx.get_block(dest);"}, {"sha": "e5e06d1bd63c840b6a337ed2beb4ec495ac52758", "filename": "src/abi/returning.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3361e349fa7c378c844458487b600dd57e566086/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3361e349fa7c378c844458487b600dd57e566086/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=3361e349fa7c378c844458487b600dd57e566086", "patch": "@@ -99,12 +99,12 @@ pub(super) fn codegen_return_param<'tcx>(\n \n /// Invokes the closure with if necessary a value representing the return pointer. When the closure\n /// returns the call return value(s) if any are written to the correct place.\n-pub(super) fn codegen_with_call_return_arg<'tcx, T>(\n+pub(super) fn codegen_with_call_return_arg<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     ret_arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     ret_place: Option<CPlace<'tcx>>,\n-    f: impl FnOnce(&mut FunctionCx<'_, '_, 'tcx>, Option<Value>) -> (Inst, T),\n-) -> (Inst, T) {\n+    f: impl FnOnce(&mut FunctionCx<'_, '_, 'tcx>, Option<Value>) -> Inst,\n+) {\n     let return_ptr = match ret_arg_abi.mode {\n         PassMode::Ignore => None,\n         PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => match ret_place {\n@@ -117,7 +117,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx, T>(\n         PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => None,\n     };\n \n-    let (call_inst, meta) = f(fx, return_ptr);\n+    let call_inst = f(fx, return_ptr);\n \n     match ret_arg_abi.mode {\n         PassMode::Ignore => {}\n@@ -155,8 +155,6 @@ pub(super) fn codegen_with_call_return_arg<'tcx, T>(\n             unreachable!(\"unsized return value\")\n         }\n     }\n-\n-    (call_inst, meta)\n }\n \n /// Codegen a return instruction with the right return value(s) if any."}]}