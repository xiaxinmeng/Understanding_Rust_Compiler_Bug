{"sha": "bd382ee6434e995153302135816685cc9cc80441", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMzgyZWU2NDM0ZTk5NTE1MzMwMjEzNTgxNjY4NWNjOWNjODA0NDE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-16T02:35:39Z"}, "committer": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-08-16T23:37:09Z"}, "message": "std::rt: Touch up idle logic", "tree": {"sha": "245fdf777c871263dc8af7df1dd4377d30a586d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/245fdf777c871263dc8af7df1dd4377d30a586d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd382ee6434e995153302135816685cc9cc80441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd382ee6434e995153302135816685cc9cc80441", "html_url": "https://github.com/rust-lang/rust/commit/bd382ee6434e995153302135816685cc9cc80441", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd382ee6434e995153302135816685cc9cc80441/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "066ca17eaae239a666579fc80fe9047aaac0599d", "url": "https://api.github.com/repos/rust-lang/rust/commits/066ca17eaae239a666579fc80fe9047aaac0599d", "html_url": "https://github.com/rust-lang/rust/commit/066ca17eaae239a666579fc80fe9047aaac0599d"}], "stats": {"total": 52, "additions": 36, "deletions": 16}, "files": [{"sha": "c0481d06493dd1eaf691bb4ff9ea006c40bdf16b", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bd382ee6434e995153302135816685cc9cc80441/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd382ee6434e995153302135816685cc9cc80441/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=bd382ee6434e995153302135816685cc9cc80441", "patch": "@@ -79,7 +79,7 @@ pub struct Scheduler {\n     /// A fast XorShift rng for scheduler use\n     rng: XorShiftRng,\n     /// An IdleWatcher\n-    idle_watcher: IdleWatcher,\n+    idle_watcher: Option<IdleWatcher>,\n     /// A flag to indicate whether or not the idle callback is active.\n     idle_flag: bool\n }\n@@ -128,9 +128,6 @@ impl Scheduler {\n                        friend: Option<SchedHandle>)\n         -> Scheduler {\n \n-        let mut event_loop = event_loop;\n-        let idle_watcher = IdleWatcher::new(event_loop.uvio.uv_loop());\n-\n         Scheduler {\n             sleeper_list: sleeper_list,\n             message_queue: MessageQueue::new(),\n@@ -146,8 +143,8 @@ impl Scheduler {\n             run_anything: run_anything,\n             friend_handle: friend,\n             rng: XorShiftRng::new(),\n-            idle_watcher: idle_watcher,\n-            idle_flag: true\n+            idle_watcher: None,\n+            idle_flag: false\n         }\n     }\n \n@@ -175,9 +172,7 @@ impl Scheduler {\n         // Before starting our first task, make sure the idle callback\n         // is active. As we do not start in the sleep state this is\n         // important.\n-        do this.idle_watcher.start |_idle_watcher, _status| {\n-            Scheduler::run_sched_once();\n-        }\n+        this.activate_idle();\n \n         // Now, as far as all the scheduler state is concerned, we are\n         // inside the \"scheduler\" context. So we can act like the\n@@ -318,23 +313,43 @@ impl Scheduler {\n         Local::put(sched);\n     }\n \n-    fn activate_idle(&mut self) {        \n+    fn activate_idle(&mut self) {\n+        rtdebug!(\"activating idle\");\n         if self.idle_flag {\n+            rtassert!(self.idle_watcher.is_some());\n             rtdebug!(\"idle flag already set, not reactivating idle watcher\");\n         } else {\n             rtdebug!(\"idle flag was false, reactivating idle watcher\");\n             self.idle_flag = true;\n-            self.idle_watcher.restart();\n+            if self.idle_watcher.is_none() {\n+                // There's no idle handle yet. Create one\n+                let mut idle_watcher = IdleWatcher::new(self.event_loop.uvio.uv_loop());\n+                do idle_watcher.start |_idle_watcher, _status| {\n+                    Scheduler::run_sched_once();\n+                }\n+                self.idle_watcher = Some(idle_watcher);\n+            } else {\n+                self.idle_watcher.get_mut_ref().restart();\n+            }\n         }            \n     }\n \n     fn pause_idle(&mut self) {\n-        if !self.idle_flag {\n-            rtdebug!(\"idle flag false, not stopping idle watcher\");\n+        rtassert!(self.idle_watcher.is_some());\n+        rtassert!(self.idle_flag);\n+\n+        rtdebug!(\"stopping idle watcher\");\n+\n+        self.idle_flag = false;\n+        if !self.no_sleep {\n+            self.idle_watcher.get_mut_ref().stop();\n         } else {\n-            rtdebug!(\"idle flag true, stopping idle watcher\");\n-            self.idle_flag = false;\n-            self.idle_watcher.stop();\n+            rtdebug!(\"closing idle watcher\");\n+            // The scheduler is trying to exit. Destroy the idle watcher\n+            // to drop the reference to the event loop.\n+            let mut idle_watcher = self.idle_watcher.take_unwrap();\n+            idle_watcher.stop();\n+            idle_watcher.close(||());\n         }\n     }\n \n@@ -357,10 +372,15 @@ impl Scheduler {\n \n         let this = self;\n \n+        rtdebug!(\"enqueuing task\");\n+\n         // We push the task onto our local queue clone.\n         this.work_queue.push(task);\n //        this.event_loop.callback(Scheduler::run_sched_once);\n \n+        // There is definitely work to be done later. Make sure we wake up for it.\n+        this.activate_idle();\n+\n         // We've made work available. Notify a\n         // sleeping scheduler.\n "}]}