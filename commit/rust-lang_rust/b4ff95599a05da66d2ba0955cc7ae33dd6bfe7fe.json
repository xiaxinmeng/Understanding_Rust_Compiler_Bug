{"sha": "b4ff95599a05da66d2ba0955cc7ae33dd6bfe7fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZmY5NTU5OWEwNWRhNjZkMmJhMDk1NWNjN2FlMzNkZDZiZmU3ZmU=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-30T16:39:31Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-30T17:16:12Z"}, "message": "std: Deny overlong encodings in UTF-8\n\nAn 'overlong encoding' is a codepoint encoded non-minimally using the\nutf-8 format. Denying these enforce each codepoint to have only one\nvalid representation in utf-8.\n\nAn example is byte sequence 0xE0 0x80 0x80 which could be interpreted as\nU+0, but it's an overlong encoding since the canonical form is just\n0x00.\n\nAnother example is 0xE0 0x80 0xAF which was previously accepted and is\nan overlong encoding of the solidus \"/\". Directory traversal characters\nlike / and . form the most compelling argument for why this commit is\nsecurity critical.\n\nFactor out common UTF-8 decoding expressions as macros. This commit will\npartly duplicate UTF-8 decoding, so it is now present in both\nfn is_utf8() and .char_range_at(); the latter using an assumption of\na valid str.", "tree": {"sha": "70f18857ae1c2653becbaa20e8aaecfc1b51eed2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70f18857ae1c2653becbaa20e8aaecfc1b51eed2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4ff95599a05da66d2ba0955cc7ae33dd6bfe7fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4ff95599a05da66d2ba0955cc7ae33dd6bfe7fe", "html_url": "https://github.com/rust-lang/rust/commit/b4ff95599a05da66d2ba0955cc7ae33dd6bfe7fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4ff95599a05da66d2ba0955cc7ae33dd6bfe7fe/comments", "author": null, "committer": null, "parents": [{"sha": "6dd185930d850b653ae4e5f4c37c3f1a2b64e4cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dd185930d850b653ae4e5f4c37c3f1a2b64e4cf", "html_url": "https://github.com/rust-lang/rust/commit/6dd185930d850b653ae4e5f4c37c3f1a2b64e4cf"}], "stats": {"total": 53, "additions": 45, "deletions": 8}, "files": [{"sha": "9695bd16be3876cf43ff83b3948823ca80feda78", "filename": "src/libstd/str.rs", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b4ff95599a05da66d2ba0955cc7ae33dd6bfe7fe/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4ff95599a05da66d2ba0955cc7ae33dd6bfe7fe/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=b4ff95599a05da66d2ba0955cc7ae33dd6bfe7fe", "patch": "@@ -564,6 +564,18 @@ fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n Section: Misc\n */\n \n+// Return the initial codepoint accumulator for the first byte.\n+// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n+// for width 3, and 3 bits for width 4\n+macro_rules! utf8_first_byte(\n+    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as uint)\n+)\n+\n+// return the value of $ch updated with continuation byte $byte\n+macro_rules! utf8_acc_cont_byte(\n+    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as uint)\n+)\n+\n /// Determines if a vector of bytes contains valid UTF-8\n pub fn is_utf8(v: &[u8]) -> bool {\n     let mut i = 0u;\n@@ -577,11 +589,26 @@ pub fn is_utf8(v: &[u8]) -> bool {\n \n             let nexti = i + w;\n             if nexti > total { return false; }\n+            // 1. Make sure the correct number of continuation bytes are present\n+            // 2. Check codepoint ranges (deny overlong encodings)\n+            //    2-byte encoding is for codepoints  \\u0080 to  \\u07ff\n+            //    3-byte encoding is for codepoints  \\u0800 to  \\uffff\n+            //    4-byte encoding is for codepoints \\u10000 to \\u10ffff\n \n+            //    2-byte encodings are correct if the width and continuation match up\n             if v[i + 1] & 192u8 != TAG_CONT_U8 { return false; }\n             if w > 2 {\n+                let mut ch;\n+                ch = utf8_first_byte!(v[i], w);\n+                ch = utf8_acc_cont_byte!(ch, v[i + 1]);\n                 if v[i + 2] & 192u8 != TAG_CONT_U8 { return false; }\n-                if w > 3 && (v[i + 3] & 192u8 != TAG_CONT_U8) { return false; }\n+                ch = utf8_acc_cont_byte!(ch, v[i + 2]);\n+                if w == 3 && ch < MAX_TWO_B { return false; }\n+                if w > 3 {\n+                    if v[i + 3] & 192u8 != TAG_CONT_U8 { return false; }\n+                    ch = utf8_acc_cont_byte!(ch, v[i + 3]);\n+                    if ch < MAX_THREE_B || ch >= MAX_UNICODE { return false; }\n+                }\n             }\n \n             i = nexti;\n@@ -738,6 +765,7 @@ static MAX_TWO_B: uint = 2048u;\n static TAG_THREE_B: uint = 224u;\n static MAX_THREE_B: uint = 65536u;\n static TAG_FOUR_B: uint = 240u;\n+static MAX_UNICODE: uint = 1114112u;\n \n /// Unsafe operations\n pub mod raw {\n@@ -1665,12 +1693,10 @@ impl<'self> StrSlice<'self> for &'self str {\n             let w = UTF8_CHAR_WIDTH[val] as uint;\n             assert!((w != 0));\n \n-            // First byte is special, only want bottom 5 bits for width 2, 4 bits\n-            // for width 3, and 3 bits for width 4\n-            val &= 0x7Fu >> w;\n-            val = (val << 6) | (s[i + 1] & 63u8) as uint;\n-            if w > 2 { val = (val << 6) | (s[i + 2] & 63u8) as uint; }\n-            if w > 3 { val = (val << 6) | (s[i + 3] & 63u8) as uint; }\n+            val = utf8_first_byte!(val, w);\n+            val = utf8_acc_cont_byte!(val, s[i + 1]);\n+            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n+            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n \n             return CharRange {ch: val as char, next: i + w};\n         }\n@@ -2035,7 +2061,7 @@ impl OwnedStr for ~str {\n     /// Appends a character to the back of a string\n     #[inline]\n     fn push_char(&mut self, c: char) {\n-        assert!(c as uint <= 0x10ffff); // FIXME: #7609: should be enforced on all `char`\n+        assert!((c as uint) < MAX_UNICODE); // FIXME: #7609: should be enforced on all `char`\n         unsafe {\n             let code = c as uint;\n             let nb = if code < MAX_ONE_B { 1u }\n@@ -2802,6 +2828,17 @@ mod tests {\n         assert_eq!(ss, from_bytes(bb));\n     }\n \n+    #[test]\n+    fn test_is_utf8_deny_overlong() {\n+        assert!(!is_utf8([0xc0, 0x80]));\n+        assert!(!is_utf8([0xc0, 0xae]));\n+        assert!(!is_utf8([0xe0, 0x80, 0x80]));\n+        assert!(!is_utf8([0xe0, 0x80, 0xaf]));\n+        assert!(!is_utf8([0xe0, 0x81, 0x81]));\n+        assert!(!is_utf8([0xf0, 0x82, 0x82, 0xac]));\n+    }\n+\n+\n     #[test]\n     #[ignore(cfg(windows))]\n     fn test_from_bytes_fail() {"}]}