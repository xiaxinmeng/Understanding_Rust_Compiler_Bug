{"sha": "0c2674f9475d3f45964a4b59e1de39c1731d1cee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMjY3NGY5NDc1ZDNmNDU5NjRhNGI1OWUxZGUzOWMxNzMxZDFjZWU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-04T00:01:34Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-04T00:03:19Z"}, "message": "libstd: Make URL parsing not require unique strings, and have URLs implement FromStr.\n\nI considered changing FromStr to return a Result<E> parameterized\nover an error type E, but I decided that was premature abstraction.\nIf you want the URL parsing error, call url::from_str() directly.", "tree": {"sha": "b1eaa69e15354ef2382a1a791f656d66ddbefc10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1eaa69e15354ef2382a1a791f656d66ddbefc10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c2674f9475d3f45964a4b59e1de39c1731d1cee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c2674f9475d3f45964a4b59e1de39c1731d1cee", "html_url": "https://github.com/rust-lang/rust/commit/0c2674f9475d3f45964a4b59e1de39c1731d1cee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c2674f9475d3f45964a4b59e1de39c1731d1cee/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aedabf1a3308925fc6087a93c58f1002ef4c0fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aedabf1a3308925fc6087a93c58f1002ef4c0fa", "html_url": "https://github.com/rust-lang/rust/commit/5aedabf1a3308925fc6087a93c58f1002ef4c0fa"}], "stats": {"total": 26, "additions": 19, "deletions": 7}, "files": [{"sha": "b670ae58acef1a445036f2bcbceac80df28cf0d6", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0c2674f9475d3f45964a4b59e1de39c1731d1cee/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c2674f9475d3f45964a4b59e1de39c1731d1cee/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=0c2674f9475d3f45964a4b59e1de39c1731d1cee", "patch": "@@ -5,6 +5,9 @@ import map;\n import map::{hashmap, str_hash};\n import io::{Reader, ReaderUtil};\n import dvec::DVec;\n+import from_str::FromStr;\n+import result::{Err, Ok};\n+import to_str::ToStr;\n \n export Url, url, userinfo, query;\n export from_str, to_str;\n@@ -338,7 +341,7 @@ fn query_to_str(query: Query) -> ~str {\n }\n \n // returns the scheme and the rest of the url, or a parsing error\n-fn get_scheme(rawurl: ~str) -> result::Result<(~str, ~str), @~str> {\n+fn get_scheme(rawurl: &str) -> result::Result<(~str, ~str), @~str> {\n     for str::each_chari(rawurl) |i,c| {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => again,\n@@ -384,11 +387,11 @@ impl Input: Eq {\n }\n \n // returns userinfo, host, port, and unparsed part, or an error\n-fn get_authority(rawurl: ~str) ->\n+fn get_authority(rawurl: &str) ->\n     result::Result<(Option<UserInfo>, ~str, Option<~str>, ~str), @~str> {\n     if !str::starts_with(rawurl, ~\"//\") {\n         // there is no authority.\n-        return result::Ok((option::None, ~\"\", option::None, copy rawurl));\n+        return result::Ok((option::None, ~\"\", option::None, rawurl.to_str()));\n     }\n \n     enum State {\n@@ -514,7 +517,7 @@ fn get_authority(rawurl: ~str) ->\n \n     let end = end; // make end immutable so it can be captured\n \n-    let host_is_end_plus_one = || {\n+    let host_is_end_plus_one: &fn() -> bool = || {\n         end+1 == len\n             && !['?', '#', '/'].contains(rawurl[end] as char)\n     };\n@@ -553,7 +556,7 @@ fn get_authority(rawurl: ~str) ->\n \n \n // returns the path and unparsed part of url, or an error\n-fn get_path(rawurl: ~str, authority : bool) ->\n+fn get_path(rawurl: &str, authority : bool) ->\n     result::Result<(~str, ~str), @~str> {\n     let len = str::len(rawurl);\n     let mut end = len;\n@@ -584,7 +587,7 @@ fn get_path(rawurl: ~str, authority : bool) ->\n }\n \n // returns the parsed query and the fragment, if present\n-fn get_query_fragment(rawurl: ~str) ->\n+fn get_query_fragment(rawurl: &str) ->\n     result::Result<(Query, Option<~str>), @~str> {\n     if !str::starts_with(rawurl, ~\"?\") {\n         if str::starts_with(rawurl, ~\"#\") {\n@@ -616,7 +619,7 @@ fn get_query_fragment(rawurl: ~str) ->\n  *\n  */\n \n-fn from_str(rawurl: ~str) -> result::Result<Url, ~str> {\n+fn from_str(rawurl: &str) -> result::Result<Url, ~str> {\n     // scheme\n     let mut schm = get_scheme(rawurl);\n     if result::is_err(schm) {\n@@ -650,6 +653,15 @@ fn from_str(rawurl: ~str) -> result::Result<Url, ~str> {\n                        port, path, query, fragment));\n }\n \n+impl Url : FromStr {\n+    static fn from_str(s: &str) -> Option<Url> {\n+        match from_str(s) {\n+            Ok(url) => Some(url),\n+            Err(_) => None\n+        }\n+    }\n+}\n+\n /**\n  * Format a `url` as a string\n  *"}]}