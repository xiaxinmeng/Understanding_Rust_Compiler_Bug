{"sha": "5ec36c358f74fe83332231e774ea20a21d165120", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlYzM2YzM1OGY3NGZlODMzMzIyMzFlNzc0ZWEyMGEyMWQxNjUxMjA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-04T02:11:49Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-07T05:19:41Z"}, "message": "std: Extract librustrt out of libstd\n\nAs part of the libstd facade efforts, this commit extracts the runtime interface\nout of the standard library into a standalone crate, librustrt. This crate will\nprovide the following services:\n\n* Definition of the rtio interface\n* Definition of the Runtime interface\n* Implementation of the Task structure\n* Implementation of task-local-data\n* Implementation of task failure via unwinding via libunwind\n* Implementation of runtime initialization and shutdown\n* Implementation of thread-local-storage for the local rust Task\n\nNotably, this crate avoids the following services:\n\n* Thread creation and destruction. The crate does not require the knowledge of\n  an OS threading system, and as a result it seemed best to leave out the\n  `rt::thread` module from librustrt. The librustrt module does depend on\n  mutexes, however.\n* Implementation of backtraces. There is no inherent requirement for the runtime\n  to be able to generate backtraces. As will be discussed later, this\n  functionality continues to live in libstd rather than librustrt.\n\nAs usual, a number of architectural changes were required to make this crate\npossible. Users of \"stable\" functionality will not be impacted by this change,\nbut users of the `std::rt` module will likely note the changes. A list of\narchitectural changes made is:\n\n* The stdout/stderr handles no longer live directly inside of the `Task`\n  structure. This is a consequence of librustrt not knowing about `std::io`.\n  These two handles are now stored inside of task-local-data.\n\n  The handles were originally stored inside of the `Task` for perf reasons, and\n  TLD is not currently as fast as it could be. For comparison, 100k prints goes\n  from 59ms to 68ms (a 15% slowdown). This appeared to me to be an acceptable\n  perf loss for the successful extraction of a librustrt crate.\n\n* The `rtio` module was forced to duplicate more functionality of `std::io`. As\n  the module no longer depends on `std::io`, `rtio` now defines structures such\n  as socket addresses, addrinfo fiddly bits, etc. The primary change made was\n  that `rtio` now defines its own `IoError` type. This type is distinct from\n  `std::io::IoError` in that it does not have an enum for what error occurred,\n  but rather a platform-specific error code.\n\n  The native and green libraries will be updated in later commits for this\n  change, and the bulk of this effort was put behind updating the two libraries\n  for this change (with `rtio`).\n\n* Printing a message on task failure (along with the backtrace) continues to\n  live in libstd, not in librustrt. This is a consequence of the above decision\n  to move the stdout/stderr handles to TLD rather than inside the `Task` itself.\n  The unwinding API now supports registration of global callback functions which\n  will be invoked when a task fails, allowing for libstd to register a function\n  to print a message and a backtrace.\n\n  The API for registering a callback is experimental and unsafe, as the\n  ramifications of running code on unwinding is pretty hairy.\n\n* The `std::unstable::mutex` module has moved to `std::rt::mutex`.\n\n* The `std::unstable::sync` module has been moved to `std::rt::exclusive` and\n  the type has been rewritten to not internally have an Arc and to have an RAII\n  guard structure when locking. Old code should stop using `Exclusive` in favor\n  of the primitives in `libsync`, but if necessary, old code should port to\n  `Arc<Exclusive<T>>`.\n\n* The local heap has been stripped down to have fewer debugging options. None of\n  these were tested, and none of these have been used in a very long time.\n\n[breaking-change]", "tree": {"sha": "290670162c10365e09f24562d68b88fb92275c51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/290670162c10365e09f24562d68b88fb92275c51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ec36c358f74fe83332231e774ea20a21d165120", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ec36c358f74fe83332231e774ea20a21d165120", "html_url": "https://github.com/rust-lang/rust/commit/5ec36c358f74fe83332231e774ea20a21d165120", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ec36c358f74fe83332231e774ea20a21d165120/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3f9aa9ef8657304006fcbe4759a263720b8592c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f9aa9ef8657304006fcbe4759a263720b8592c", "html_url": "https://github.com/rust-lang/rust/commit/a3f9aa9ef8657304006fcbe4759a263720b8592c"}], "stats": {"total": 2553, "additions": 1300, "deletions": 1253}, "files": [{"sha": "433490f6f5dbfd4985b52b7d53c2bb0ab794c477", "filename": "mk/crates.mk", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -51,7 +51,7 @@\n \n TARGET_CRATES := libc std green rustuv native flate arena glob term semver \\\n                  uuid serialize sync getopts collections num test time rand \\\n-                 url log regex graphviz core rlibc alloc debug\n+                 url log regex graphviz core rlibc alloc debug rustrt\n HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros fmt_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n@@ -60,7 +60,9 @@ DEPS_core :=\n DEPS_rlibc :=\n DEPS_alloc := core libc native:jemalloc\n DEPS_debug := std\n-DEPS_std := core rand libc alloc collections native:rustrt native:backtrace\n+DEPS_rustrt := alloc core libc collections native:rustrt_native\n+DEPS_std := core libc rand alloc collections rustrt \\\n+\tnative:rust_builtin native:backtrace\n DEPS_graphviz := std\n DEPS_green := std native:context_switch\n DEPS_rustuv := std native:uv native:uv_support"}, {"sha": "a75cb8aa4deb2f3a88e8dcb38db56b71fed4614d", "filename": "mk/rt.mk", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -35,8 +35,8 @@\n # that's per-target so you're allowed to conditionally add files based on the\n # target.\n ################################################################################\n-NATIVE_LIBS := rustrt hoedown uv_support morestack miniz context_switch \\\n-\t\trust_test_helpers\n+NATIVE_LIBS := rust_builtin hoedown uv_support morestack miniz context_switch \\\n+\t\trustrt_native rust_test_helpers\n \n # $(1) is the target triple\n define NATIVE_LIBRARIES\n@@ -52,8 +52,9 @@ NATIVE_DEPS_hoedown_$(1) := hoedown/src/autolink.c \\\n \t\t\thoedown/src/version.c\n NATIVE_DEPS_uv_support_$(1) := rust_uv.c\n NATIVE_DEPS_miniz_$(1) = miniz.c\n-NATIVE_DEPS_rustrt_$(1) := rust_builtin.c \\\n-\t\t\trust_android_dummy.c \\\n+NATIVE_DEPS_rust_builtin_$(1) := rust_builtin.c \\\n+\t\t\trust_android_dummy.c\n+NATIVE_DEPS_rustrt_native_$(1) := \\\n \t\t\trust_try.ll \\\n \t\t\tarch/$$(HOST_$(1))/record_sp.S\n NATIVE_DEPS_rust_test_helpers_$(1) := rust_test_helpers.c"}, {"sha": "7942a1569ed2f491ba8d6c1197113be32920636d", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -98,6 +98,20 @@ macro_rules! try(\n     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n )\n \n+/// Writing a formatted string into a writer\n+#[macro_export]\n+macro_rules! write(\n+    ($dst:expr, $($arg:tt)*) => (format_args_method!($dst, write_fmt, $($arg)*))\n+)\n+\n+/// Writing a formatted string plus a newline into a writer\n+#[macro_export]\n+macro_rules! writeln(\n+    ($dst:expr, $fmt:expr $($arg:tt)*) => (\n+        write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n+    )\n+)\n+\n #[cfg(test)]\n macro_rules! vec( ($($e:expr),*) => ({\n     let mut _v = ::std::vec::Vec::new();"}, {"sha": "0789bf7f906f6928749e7e8522c97d760cc7f8ec", "filename": "src/librustrt/args.rs", "status": "renamed", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -18,10 +18,9 @@\n //! discover the command line arguments.\n //!\n //! FIXME #7756: Would be nice for this to not exist.\n-//! FIXME #7756: This has a lot of C glue for lack of globals.\n \n-use option::Option;\n-use vec::Vec;\n+use core::prelude::*;\n+use collections::vec::Vec;\n \n /// One-time global initialization.\n pub unsafe fn init(argc: int, argv: **u8) { imp::init(argc, argv) }\n@@ -44,14 +43,14 @@ pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"freebsd\")]\n mod imp {\n-    use clone::Clone;\n-    use iter::Iterator;\n-    use option::{Option, Some, None};\n-    use owned::Box;\n-    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    use mem;\n-    use vec::Vec;\n-    use ptr::RawPtr;\n+    use core::prelude::*;\n+\n+    use alloc::owned::Box;\n+    use collections::vec::Vec;\n+    use core::mem;\n+    use core::slice;\n+\n+    use mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n     static mut global_args_ptr: uint = 0;\n     static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n@@ -100,24 +99,23 @@ mod imp {\n         unsafe { mem::transmute(&global_args_ptr) }\n     }\n \n-    // Copied from `os`.\n     unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> Vec<Vec<u8>> {\n-        use c_str::CString;\n-        use ptr::RawPtr;\n-        use libc;\n-        use vec::Vec;\n-\n         Vec::from_fn(argc as uint, |i| {\n-            let cs = CString::new(*(argv as **libc::c_char).offset(i as int), false);\n-            Vec::from_slice(cs.as_bytes_no_nul())\n+            let base = *argv.offset(i as int);\n+            let mut len = 0;\n+            while *base.offset(len) != 0 { len += 1; }\n+            slice::raw::buf_as_slice(base, len as uint, |slice| {\n+                Vec::from_slice(slice)\n+            })\n         })\n     }\n \n     #[cfg(test)]\n     mod tests {\n-        use prelude::*;\n+        use std::prelude::*;\n+        use std::finally::Finally;\n+\n         use super::*;\n-        use finally::Finally;\n \n         #[test]\n         fn smoke_test() {\n@@ -149,8 +147,8 @@ mod imp {\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"win32\")]\n mod imp {\n-    use option::Option;\n-    use vec::Vec;\n+    use core::prelude::*;\n+    use collections::vec::Vec;\n \n     pub unsafe fn init(_argc: int, _argv: **u8) {\n     }", "previous_filename": "src/libstd/rt/args.rs"}, {"sha": "d38d06950bf8bb16dc9b92a2060e12dda5240bac", "filename": "src/librustrt/at_exit_imp.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fat_exit_imp.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of running at_exit routines\n+//!\n+//! Documentation can be found on the `rt::at_exit` function.\n+\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use collections::vec::Vec;\n+use core::atomics;\n+use core::mem;\n+\n+use exclusive::Exclusive;\n+\n+type Queue = Exclusive<Vec<proc():Send>>;\n+\n+static mut QUEUE: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n+static mut RUNNING: atomics::AtomicBool = atomics::INIT_ATOMIC_BOOL;\n+\n+pub fn init() {\n+    let state: Box<Queue> = box Exclusive::new(Vec::new());\n+    unsafe {\n+        rtassert!(!RUNNING.load(atomics::SeqCst));\n+        rtassert!(QUEUE.swap(mem::transmute(state), atomics::SeqCst) == 0);\n+    }\n+}\n+\n+pub fn push(f: proc():Send) {\n+    unsafe {\n+        // Note that the check against 0 for the queue pointer is not atomic at\n+        // all with respect to `run`, meaning that this could theoretically be a\n+        // use-after-free. There's not much we can do to protect against that,\n+        // however. Let's just assume a well-behaved runtime and go from there!\n+        rtassert!(!RUNNING.load(atomics::SeqCst));\n+        let queue = QUEUE.load(atomics::SeqCst);\n+        rtassert!(queue != 0);\n+        (*(queue as *Queue)).lock().push(f);\n+    }\n+}\n+\n+pub fn run() {\n+    let cur = unsafe {\n+        rtassert!(!RUNNING.load(atomics::SeqCst));\n+        let queue = QUEUE.swap(0, atomics::SeqCst);\n+        rtassert!(queue != 0);\n+\n+        let queue: Box<Queue> = mem::transmute(queue);\n+        mem::replace(&mut *queue.lock(), Vec::new())\n+    };\n+\n+    for to_run in cur.move_iter() {\n+        to_run();\n+    }\n+}"}, {"sha": "fd290491eaf1e1208a50782ec707ed5ba3a84572", "filename": "src/librustrt/bookkeeping.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fbookkeeping.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -18,11 +18,9 @@\n //! each respective runtime to make sure that they call increment() and\n //! decrement() manually.\n \n-#![experimental] // this is a massive code smell\n-#![doc(hidden)]\n+use core::atomics;\n \n-use sync::atomics;\n-use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+use mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n static mut TASK_COUNT: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n static mut TASK_LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;", "previous_filename": "src/libstd/rt/bookkeeping.rs"}, {"sha": "1690c54285c23abd2fc7fed80107dba4d6aeea68", "filename": "src/librustrt/c_str.rs", "status": "renamed", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -65,24 +65,17 @@ fn main() {\n \n */\n \n-use clone::Clone;\n-use cmp::PartialEq;\n-use container::Container;\n-use iter::{Iterator, range};\n-use kinds::marker;\n+use core::prelude::*;\n+\n+use alloc::libc_heap::malloc_raw;\n+use collections::string::String;\n+use core::kinds::marker;\n+use core::mem;\n+use core::ptr;\n+use core::raw::Slice;\n+use core::slice;\n+use core::str;\n use libc;\n-use mem;\n-use ops::Drop;\n-use option::{Option, Some, None};\n-use ptr::RawPtr;\n-use ptr;\n-use raw::Slice;\n-use rt::libc_heap::malloc_raw;\n-use slice::{ImmutableVector, MutableVector};\n-use slice;\n-use str::StrSlice;\n-use str;\n-use string::String;\n \n /// The representation of a C String.\n ///\n@@ -454,11 +447,12 @@ pub unsafe fn from_c_multistring(buf: *libc::c_char,\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n-    use super::*;\n+    use std::prelude::*;\n+    use std::ptr;\n+    use std::task;\n     use libc;\n-    use ptr;\n-    use str::StrSlice;\n+\n+    use super::*;\n \n     #[test]\n     fn test_str_multistring_parsing() {\n@@ -574,7 +568,6 @@ mod tests {\n \n     #[test]\n     fn test_to_c_str_fail() {\n-        use task;\n         assert!(task::try(proc() { \"he\\x00llo\".to_c_str() }).is_err());\n     }\n \n@@ -700,10 +693,9 @@ mod tests {\n \n #[cfg(test)]\n mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n+    use test::Bencher;\n     use libc;\n-    use prelude::*;\n+    use std::prelude::*;\n \n     #[inline]\n     fn check(s: &str, c_str: *libc::c_char) {", "previous_filename": "src/libstd/c_str.rs"}, {"sha": "62313965768a6e623b545a4b83819ad1ccc579ea", "filename": "src/librustrt/exclusive.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fexclusive.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use core::ty::Unsafe;\n+use mutex;\n+\n+/// An OS mutex over some data.\n+///\n+/// This is not a safe primitive to use, it is unaware of the libgreen\n+/// scheduler, as well as being easily susceptible to misuse due to the usage of\n+/// the inner NativeMutex.\n+///\n+/// > **Note**: This type is not recommended for general use. The mutex provided\n+/// >           as part of `libsync` should almost always be favored.\n+pub struct Exclusive<T> {\n+    lock: mutex::NativeMutex,\n+    data: Unsafe<T>,\n+}\n+\n+/// An RAII guard returned via `lock`\n+pub struct ExclusiveGuard<'a, T> {\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _data: &'a mut T,\n+    _guard: mutex::LockGuard<'a>,\n+}\n+\n+impl<T: Send> Exclusive<T> {\n+    /// Creates a new `Exclusive` which will protect the data provided.\n+    pub fn new(user_data: T) -> Exclusive<T> {\n+        Exclusive {\n+            lock: unsafe { mutex::NativeMutex::new() },\n+            data: Unsafe::new(user_data),\n+        }\n+    }\n+\n+    /// Acquires this lock, returning a guard which the data is accessed through\n+    /// and from which that lock will be unlocked.\n+    ///\n+    /// This method is unsafe due to many of the same reasons that the\n+    /// NativeMutex itself is unsafe.\n+    pub unsafe fn lock<'a>(&'a self) -> ExclusiveGuard<'a, T> {\n+        let guard = self.lock.lock();\n+        let data = &mut *self.data.get();\n+\n+        ExclusiveGuard {\n+            _data: data,\n+            _guard: guard,\n+        }\n+    }\n+}\n+\n+impl<'a, T: Send> ExclusiveGuard<'a, T> {\n+    // The unsafety here should be ok because our loan guarantees that the lock\n+    // itself is not moving\n+    pub fn signal(&self) {\n+        unsafe { self._guard.signal() }\n+    }\n+    pub fn wait(&self) {\n+        unsafe { self._guard.wait() }\n+    }\n+}\n+\n+impl<'a, T: Send> Deref<T> for ExclusiveGuard<'a, T> {\n+    fn deref<'a>(&'a self) -> &'a T { &*self._data }\n+}\n+impl<'a, T: Send> DerefMut<T> for ExclusiveGuard<'a, T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self._data }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::prelude::*;\n+    use alloc::arc::Arc;\n+    use super::Exclusive;\n+    use std::task;\n+\n+    #[test]\n+    fn exclusive_new_arc() {\n+        unsafe {\n+            let mut futures = Vec::new();\n+\n+            let num_tasks = 10;\n+            let count = 10;\n+\n+            let total = Arc::new(Exclusive::new(box 0));\n+\n+            for _ in range(0u, num_tasks) {\n+                let total = total.clone();\n+                let (tx, rx) = channel();\n+                futures.push(rx);\n+\n+                task::spawn(proc() {\n+                    for _ in range(0u, count) {\n+                        **total.lock() += 1;\n+                    }\n+                    tx.send(());\n+                });\n+            };\n+\n+            for f in futures.mut_iter() { f.recv() }\n+\n+            assert_eq!(**total.lock(), num_tasks * count);\n+        }\n+    }\n+}"}, {"sha": "506df10aab26a1598a0b3913af01096e9fe0125b", "filename": "src/librustrt/lib.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -0,0 +1,163 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_id = \"rustrt#0.11.0-pre\"]\n+#![license = \"MIT/ASL2\"]\n+#![crate_type = \"rlib\"]\n+#![crate_type = \"dylib\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+       html_root_url = \"http://doc.rust-lang.org/\")]\n+#![feature(macro_rules, phase, globs, thread_local, managed_boxes, asm)]\n+#![no_std]\n+#![experimental]\n+\n+#[phase(syntax, link)]\n+extern crate core;\n+extern crate alloc;\n+extern crate libc;\n+extern crate collections;\n+\n+#[cfg(test)] extern crate realrustrt = \"rustrt\";\n+#[cfg(test)] extern crate test;\n+#[cfg(test)] extern crate native;\n+#[cfg(test)] #[phase(syntax, link)] extern crate std;\n+\n+pub use self::util::{Stdio, Stdout, Stderr};\n+pub use self::unwind::{begin_unwind, begin_unwind_fmt};\n+\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::any::Any;\n+\n+use task::{Task, BlockedTask, TaskOpts};\n+\n+mod macros;\n+\n+mod at_exit_imp;\n+mod local_ptr;\n+mod thread_local_storage;\n+mod util;\n+mod libunwind;\n+\n+pub mod args;\n+pub mod bookkeeping;\n+pub mod exclusive;\n+pub mod local;\n+pub mod local_data;\n+pub mod local_heap;\n+pub mod mutex;\n+pub mod rtio;\n+pub mod stack;\n+pub mod task;\n+pub mod unwind;\n+pub mod c_str;\n+\n+/// The interface to the current runtime.\n+///\n+/// This trait is used as the abstraction between 1:1 and M:N scheduling. The\n+/// two independent crates, libnative and libgreen, both have objects which\n+/// implement this trait. The goal of this trait is to encompass all the\n+/// fundamental differences in functionality between the 1:1 and M:N runtime\n+/// modes.\n+pub trait Runtime {\n+    // Necessary scheduling functions, used for channels and blocking I/O\n+    // (sometimes).\n+    fn yield_now(~self, cur_task: Box<Task>);\n+    fn maybe_yield(~self, cur_task: Box<Task>);\n+    fn deschedule(~self, times: uint, cur_task: Box<Task>,\n+                  f: |BlockedTask| -> Result<(), BlockedTask>);\n+    fn reawaken(~self, to_wake: Box<Task>);\n+\n+    // Miscellaneous calls which are very different depending on what context\n+    // you're in.\n+    fn spawn_sibling(~self,\n+                     cur_task: Box<Task>,\n+                     opts: TaskOpts,\n+                     f: proc():Send);\n+    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;\n+    /// The (low, high) edges of the current stack.\n+    fn stack_bounds(&self) -> (uint, uint); // (lo, hi)\n+    fn can_block(&self) -> bool;\n+\n+    // FIXME: This is a serious code smell and this should not exist at all.\n+    fn wrap(~self) -> Box<Any>;\n+}\n+\n+/// The default error code of the rust runtime if the main task fails instead\n+/// of exiting cleanly.\n+pub static DEFAULT_ERROR_CODE: int = 101;\n+\n+/// One-time runtime initialization.\n+///\n+/// Initializes global state, including frobbing\n+/// the crate's logging flags, registering GC\n+/// metadata, and storing the process arguments.\n+pub fn init(argc: int, argv: **u8) {\n+    // FIXME: Derefing these pointers is not safe.\n+    // Need to propagate the unsafety to `start`.\n+    unsafe {\n+        args::init(argc, argv);\n+        local_ptr::init();\n+        at_exit_imp::init();\n+    }\n+\n+    // FIXME(#14344) this shouldn't be necessary\n+    collections::fixme_14344_be_sure_to_link_to_collections();\n+    alloc::fixme_14344_be_sure_to_link_to_collections();\n+}\n+\n+/// Enqueues a procedure to run when the runtime is cleaned up\n+///\n+/// The procedure passed to this function will be executed as part of the\n+/// runtime cleanup phase. For normal rust programs, this means that it will run\n+/// after all other tasks have exited.\n+///\n+/// The procedure is *not* executed with a local `Task` available to it, so\n+/// primitives like logging, I/O, channels, spawning, etc, are *not* available.\n+/// This is meant for \"bare bones\" usage to clean up runtime details, this is\n+/// not meant as a general-purpose \"let's clean everything up\" function.\n+///\n+/// It is forbidden for procedures to register more `at_exit` handlers when they\n+/// are running, and doing so will lead to a process abort.\n+pub fn at_exit(f: proc():Send) {\n+    at_exit_imp::push(f);\n+}\n+\n+/// One-time runtime cleanup.\n+///\n+/// This function is unsafe because it performs no checks to ensure that the\n+/// runtime has completely ceased running. It is the responsibility of the\n+/// caller to ensure that the runtime is entirely shut down and nothing will be\n+/// poking around at the internal components.\n+///\n+/// Invoking cleanup while portions of the runtime are still in use may cause\n+/// undefined behavior.\n+pub unsafe fn cleanup() {\n+    bookkeeping::wait_for_other_tasks();\n+    at_exit_imp::run();\n+    args::cleanup();\n+    local_ptr::cleanup();\n+}\n+\n+// FIXME: these probably shouldn't be public...\n+#[doc(hidden)]\n+pub mod shouldnt_be_public {\n+    #[cfg(not(test))]\n+    pub use super::local_ptr::native::maybe_tls_key;\n+    #[cfg(not(windows), not(target_os = \"android\"))]\n+    pub use super::local_ptr::compiled::RT_TLS_PTR;\n+}\n+\n+#[cfg(not(test))]\n+mod std {\n+    pub use core::{fmt, option, cmp};\n+}"}, {"sha": "846ec248805e96d5e940f6d9d3b45f80e12a4709", "filename": "src/librustrt/libunwind.rs", "status": "renamed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -79,10 +79,6 @@ pub type _Unwind_Exception_Cleanup_Fn =\n         extern \"C\" fn(unwind_code: _Unwind_Reason_Code,\n                       exception: *_Unwind_Exception);\n \n-pub type _Unwind_Trace_Fn =\n-        extern \"C\" fn(ctx: *_Unwind_Context,\n-                      arg: *libc::c_void) -> _Unwind_Reason_Code;\n-\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"win32\")]\n@@ -97,67 +93,4 @@ extern \"C\" {\n     pub fn _Unwind_RaiseException(exception: *_Unwind_Exception)\n                 -> _Unwind_Reason_Code;\n     pub fn _Unwind_DeleteException(exception: *_Unwind_Exception);\n-    pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n-                             trace_argument: *libc::c_void)\n-                -> _Unwind_Reason_Code;\n-\n-    #[cfg(not(target_os = \"android\"),\n-          not(target_os = \"linux\", target_arch = \"arm\"))]\n-    pub fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t;\n-    #[cfg(not(target_os = \"android\"),\n-          not(target_os = \"linux\", target_arch = \"arm\"))]\n-    pub fn _Unwind_FindEnclosingFunction(pc: *libc::c_void) -> *libc::c_void;\n-}\n-\n-// On android, the function _Unwind_GetIP is a macro, and this is the expansion\n-// of the macro. This is all copy/pasted directly from the header file with the\n-// definition of _Unwind_GetIP.\n-#[cfg(target_os = \"android\")]\n-#[cfg(target_os = \"linux\", target_arch = \"arm\")]\n-pub unsafe fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t {\n-    #[repr(C)]\n-    enum _Unwind_VRS_Result {\n-        _UVRSR_OK = 0,\n-        _UVRSR_NOT_IMPLEMENTED = 1,\n-        _UVRSR_FAILED = 2,\n-    }\n-    #[repr(C)]\n-    enum _Unwind_VRS_RegClass {\n-        _UVRSC_CORE = 0,\n-        _UVRSC_VFP = 1,\n-        _UVRSC_FPA = 2,\n-        _UVRSC_WMMXD = 3,\n-        _UVRSC_WMMXC = 4,\n-    }\n-    #[repr(C)]\n-    enum _Unwind_VRS_DataRepresentation {\n-        _UVRSD_UINT32 = 0,\n-        _UVRSD_VFPX = 1,\n-        _UVRSD_FPAX = 2,\n-        _UVRSD_UINT64 = 3,\n-        _UVRSD_FLOAT = 4,\n-        _UVRSD_DOUBLE = 5,\n-    }\n-\n-    type _Unwind_Word = libc::c_uint;\n-    extern {\n-        fn _Unwind_VRS_Get(ctx: *_Unwind_Context,\n-                           klass: _Unwind_VRS_RegClass,\n-                           word: _Unwind_Word,\n-                           repr: _Unwind_VRS_DataRepresentation,\n-                           data: *mut libc::c_void) -> _Unwind_VRS_Result;\n-    }\n-\n-    let mut val: _Unwind_Word = 0;\n-    let ptr = &mut val as *mut _Unwind_Word;\n-    let _ = _Unwind_VRS_Get(ctx, _UVRSC_CORE, 15, _UVRSD_UINT32,\n-                            ptr as *mut libc::c_void);\n-    (val & !1) as libc::uintptr_t\n-}\n-\n-// This function also doesn't exist on android or arm/linux, so make it a no-op\n-#[cfg(target_os = \"android\")]\n-#[cfg(target_os = \"linux\", target_arch = \"arm\")]\n-pub unsafe fn _Unwind_FindEnclosingFunction(pc: *libc::c_void) -> *libc::c_void {\n-    pc\n }", "previous_filename": "src/libstd/rt/libunwind.rs"}, {"sha": "7fe9dbc6d4ff554d81cbe5a3e375d40ed988de38", "filename": "src/librustrt/local.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::Option;\n-use owned::Box;\n-use rt::task::Task;\n-use rt::local_ptr;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use local_ptr;\n+use task::Task;\n \n /// Encapsulates some task-local data.\n pub trait Local<Borrowed> {\n@@ -52,11 +53,10 @@ impl Local<local_ptr::Borrowed<Task>> for Task {\n \n #[cfg(test)]\n mod test {\n-    use option::{None, Option};\n-    use rt::thread::Thread;\n+    use std::prelude::*;\n+    use std::rt::thread::Thread;\n     use super::*;\n-    use owned::Box;\n-    use rt::task::Task;\n+    use task::Task;\n \n     #[test]\n     fn thread_local_task_smoke_test() {", "previous_filename": "src/libstd/rt/local.rs"}, {"sha": "88c154045c6e2196ba7bee762b76ddbdbfc4a316", "filename": "src/librustrt/local_data.rs", "status": "renamed", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -38,18 +38,16 @@ assert_eq!(*key_vector.get().unwrap(), ~[4]);\n // Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation\n // magic.\n \n-use iter::{Iterator};\n-use kinds::Send;\n-use kinds::marker;\n-use mem::replace;\n-use mem;\n-use ops::{Drop, Deref};\n-use option::{None, Option, Some};\n-use owned::Box;\n-use raw;\n-use rt::task::{Task, LocalStorage};\n-use slice::{ImmutableVector, MutableVector};\n-use vec::Vec;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use collections::vec::Vec;\n+use core::kinds::marker;\n+use core::mem;\n+use core::raw;\n+\n+use local::Local;\n+use task::{Task, LocalStorage};\n \n /**\n  * Indexes a task-local data slot. This pointer is used for comparison to\n@@ -111,10 +109,10 @@ unsafe fn get_local_map() -> Option<&mut Map> {\n         // If this is the first time we've accessed TLS, perform similar\n         // actions to the oldsched way of doing things.\n         &LocalStorage(ref mut slot) => {\n-            *slot = Some(vec!());\n+            *slot = Some(Vec::new());\n             match *slot {\n                 Some(ref mut map_ptr) => { return Some(map_ptr) }\n-                None => unreachable!(),\n+                None => fail!(\"unreachable code\"),\n             }\n         }\n     }\n@@ -192,7 +190,7 @@ impl<T: 'static> KeyValue<T> {\n \n         match pos {\n             Some(i) => {\n-                replace(map.get_mut(i), newval).map(|(_, data, _)| {\n+                mem::replace(map.get_mut(i), newval).map(|(_, data, _)| {\n                     // Move `data` into transmute to get out the memory that it\n                     // owns, we must free it manually later.\n                     let t: raw::TraitObject = unsafe { mem::transmute(data) };\n@@ -277,10 +275,9 @@ impl<T: 'static> Drop for Ref<T> {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use std::prelude::*;\n     use super::*;\n-    use owned::Box;\n-    use task;\n+    use std::task;\n \n     #[test]\n     fn test_tls_multitask() {", "previous_filename": "src/libstd/local_data.rs"}, {"sha": "52fe5c35a268fbd3a0d9844d580fceeb5b362765", "filename": "src/librustrt/local_heap.rs", "status": "renamed", "additions": 85, "deletions": 94, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_heap.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -10,55 +10,45 @@\n \n //! The local, garbage collected heap\n \n+use core::prelude::*;\n+\n+use alloc::libc_heap;\n use alloc::util;\n-use iter::Iterator;\n use libc::{c_void, free};\n-use mem;\n-use ops::Drop;\n-use option::{Option, None, Some};\n-use ptr::RawPtr;\n-use ptr;\n-use raw;\n-use rt::libc_heap;\n-use rt::local::Local;\n-use rt::task::Task;\n-use slice::{ImmutableVector, Vector};\n-use vec::Vec;\n-\n-// This has no meaning with out rtdebug also turned on.\n-#[cfg(rtdebug)]\n-static TRACK_ALLOCATIONS: int = 0;\n-#[cfg(rtdebug)]\n-static MAGIC: u32 = 0xbadc0ffe;\n+\n+use core::mem;\n+use core::ptr;\n+use core::raw;\n+use local::Local;\n+use task::Task;\n+\n+static RC_IMMORTAL : uint = 0x77777777;\n \n pub type Box = raw::Box<()>;\n \n pub struct MemoryRegion {\n-    allocations: Vec<*AllocHeader>,\n     live_allocations: uint,\n }\n \n pub struct LocalHeap {\n     memory_region: MemoryRegion,\n-\n     live_allocs: *mut raw::Box<()>,\n }\n \n impl LocalHeap {\n-    #[inline]\n     pub fn new() -> LocalHeap {\n-        let region = MemoryRegion {\n-            allocations: Vec::new(),\n-            live_allocations: 0,\n-        };\n         LocalHeap {\n-            memory_region: region,\n+            memory_region: MemoryRegion { live_allocations: 0 },\n             live_allocs: ptr::mut_null(),\n         }\n     }\n \n     #[inline]\n-    pub fn alloc(&mut self, drop_glue: fn(*mut u8), size: uint, align: uint) -> *mut Box {\n+    #[allow(deprecated)]\n+    pub fn alloc(&mut self,\n+                 drop_glue: fn(*mut u8),\n+                 size: uint,\n+                 align: uint) -> *mut Box {\n         let total_size = util::get_box_size(size, align);\n         let alloc = self.memory_region.malloc(total_size);\n         {\n@@ -119,6 +109,63 @@ impl LocalHeap {\n \n         self.memory_region.free(alloc);\n     }\n+\n+    pub unsafe fn annihilate(&mut self) {\n+        let mut n_total_boxes = 0u;\n+\n+        // Pass 1: Make all boxes immortal.\n+        //\n+        // In this pass, nothing gets freed, so it does not matter whether\n+        // we read the next field before or after the callback.\n+        self.each_live_alloc(true, |_, alloc| {\n+            n_total_boxes += 1;\n+            (*alloc).ref_count = RC_IMMORTAL;\n+        });\n+\n+        // Pass 2: Drop all boxes.\n+        //\n+        // In this pass, unique-managed boxes may get freed, but not\n+        // managed boxes, so we must read the `next` field *after* the\n+        // callback, as the original value may have been freed.\n+        self.each_live_alloc(false, |_, alloc| {\n+            let drop_glue = (*alloc).drop_glue;\n+            let data = &mut (*alloc).data as *mut ();\n+            drop_glue(data as *mut u8);\n+        });\n+\n+        // Pass 3: Free all boxes.\n+        //\n+        // In this pass, managed boxes may get freed (but not\n+        // unique-managed boxes, though I think that none of those are\n+        // left), so we must read the `next` field before, since it will\n+        // not be valid after.\n+        self.each_live_alloc(true, |me, alloc| {\n+            me.free(alloc);\n+        });\n+\n+        if debug_mem() {\n+            // We do logging here w/o allocation.\n+            rterrln!(\"total boxes annihilated: {}\", n_total_boxes);\n+        }\n+    }\n+\n+    unsafe fn each_live_alloc(&mut self, read_next_before: bool,\n+                              f: |&mut LocalHeap, alloc: *mut raw::Box<()>|) {\n+        //! Walks the internal list of allocations\n+\n+        let mut alloc = self.live_allocs;\n+        while alloc != ptr::mut_null() {\n+            let next_before = (*alloc).next;\n+\n+            f(self, alloc);\n+\n+            if read_next_before {\n+                alloc = next_before;\n+            } else {\n+                alloc = (*alloc).next;\n+            }\n+        }\n+    }\n }\n \n impl Drop for LocalHeap {\n@@ -127,43 +174,11 @@ impl Drop for LocalHeap {\n     }\n }\n \n-#[cfg(rtdebug)]\n-struct AllocHeader {\n-    magic: u32,\n-    index: i32,\n-    size: u32,\n-}\n-#[cfg(not(rtdebug))]\n struct AllocHeader;\n \n impl AllocHeader {\n-    #[cfg(rtdebug)]\n-    fn init(&mut self, size: u32) {\n-        if TRACK_ALLOCATIONS > 0 {\n-            self.magic = MAGIC;\n-            self.index = -1;\n-            self.size = size;\n-        }\n-    }\n-    #[cfg(not(rtdebug))]\n     fn init(&mut self, _size: u32) {}\n-\n-    #[cfg(rtdebug)]\n-    fn assert_sane(&self) {\n-        if TRACK_ALLOCATIONS > 0 {\n-            rtassert!(self.magic == MAGIC);\n-        }\n-    }\n-    #[cfg(not(rtdebug))]\n     fn assert_sane(&self) {}\n-\n-    #[cfg(rtdebug)]\n-    fn update_size(&mut self, size: u32) {\n-        if TRACK_ALLOCATIONS > 0 {\n-            self.size = size;\n-        }\n-    }\n-    #[cfg(not(rtdebug))]\n     fn update_size(&mut self, _size: u32) {}\n \n     fn as_box(&mut self) -> *mut Box {\n@@ -183,6 +198,17 @@ impl AllocHeader {\n     }\n }\n \n+#[cfg(unix)]\n+fn debug_mem() -> bool {\n+    // FIXME: Need to port the environment struct to newsched\n+    false\n+}\n+\n+#[cfg(windows)]\n+fn debug_mem() -> bool {\n+    false\n+}\n+\n impl MemoryRegion {\n     #[inline]\n     fn malloc(&mut self, size: uint) -> *mut Box {\n@@ -230,39 +256,10 @@ impl MemoryRegion {\n         }\n     }\n \n-    #[cfg(rtdebug)]\n-    fn claim(&mut self, alloc: &mut AllocHeader) {\n-        alloc.assert_sane();\n-        if TRACK_ALLOCATIONS > 1 {\n-            alloc.index = self.allocations.len() as i32;\n-            self.allocations.push(&*alloc as *AllocHeader);\n-        }\n-    }\n-    #[cfg(not(rtdebug))]\n     #[inline]\n     fn claim(&mut self, _alloc: &mut AllocHeader) {}\n-\n-    #[cfg(rtdebug)]\n-    fn release(&mut self, alloc: &AllocHeader) {\n-        alloc.assert_sane();\n-        if TRACK_ALLOCATIONS > 1 {\n-            rtassert!(self.allocations.as_slice()[alloc.index] == alloc as *AllocHeader);\n-            self.allocations.as_mut_slice()[alloc.index] = ptr::null();\n-        }\n-    }\n-    #[cfg(not(rtdebug))]\n     #[inline]\n     fn release(&mut self, _alloc: &AllocHeader) {}\n-\n-    #[cfg(rtdebug)]\n-    fn update(&mut self, alloc: &mut AllocHeader, orig: *AllocHeader) {\n-        alloc.assert_sane();\n-        if TRACK_ALLOCATIONS > 1 {\n-            rtassert!(self.allocations.as_slice()[alloc.index] == orig);\n-            self.allocations.as_mut_slice()[alloc.index] = &*alloc as *AllocHeader;\n-        }\n-    }\n-    #[cfg(not(rtdebug))]\n     #[inline]\n     fn update(&mut self, _alloc: &mut AllocHeader, _orig: *AllocHeader) {}\n }\n@@ -272,11 +269,9 @@ impl Drop for MemoryRegion {\n         if self.live_allocations != 0 {\n             rtabort!(\"leaked managed memory ({} objects)\", self.live_allocations);\n         }\n-        rtassert!(self.allocations.as_slice().iter().all(|s| s.is_null()));\n     }\n }\n \n-\n #[cfg(not(test))]\n #[lang=\"malloc\"]\n #[inline]\n@@ -318,10 +313,6 @@ pub unsafe fn local_free(ptr: *u8) {\n     }\n }\n \n-pub fn live_allocs() -> *mut Box {\n-    Local::borrow(None::<Task>).heap.live_allocs\n-}\n-\n #[cfg(test)]\n mod bench {\n     extern crate test;", "previous_filename": "src/libstd/rt/local_heap.rs"}, {"sha": "91e3409892ea5f3d2da7027a57409f3429948794", "filename": "src/librustrt/local_ptr.rs", "status": "renamed", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_ptr.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -17,10 +17,10 @@\n \n #![allow(dead_code)]\n \n-use mem;\n-use ops::{Drop, Deref, DerefMut};\n-use owned::Box;\n-use ptr::RawPtr;\n+use core::prelude::*;\n+\n+use core::mem;\n+use alloc::owned::Box;\n \n #[cfg(windows)]               // mingw-w32 doesn't like thread_local things\n #[cfg(target_os = \"android\")] // see #10686\n@@ -83,13 +83,13 @@ pub unsafe fn borrow<T>() -> Borrowed<T> {\n /// it wherever possible.\n #[cfg(not(windows), not(target_os = \"android\"))]\n pub mod compiled {\n-    use mem;\n-    use option::{Option, Some, None};\n-    use owned::Box;\n-    use ptr::RawPtr;\n+    use core::prelude::*;\n+\n+    use alloc::owned::Box;\n+    use core::mem;\n \n     #[cfg(test)]\n-    pub use realstd::rt::shouldnt_be_public::RT_TLS_PTR;\n+    pub use realrustrt::shouldnt_be_public::RT_TLS_PTR;\n \n     #[cfg(not(test))]\n     #[thread_local]\n@@ -234,12 +234,12 @@ pub mod compiled {\n /// implementation uses the `thread_local_storage` module to provide a\n /// thread-local value.\n pub mod native {\n-    use mem;\n-    use option::{Option, Some, None};\n-    use owned::Box;\n-    use ptr::RawPtr;\n-    use ptr;\n-    use tls = rt::thread_local_storage;\n+    use core::prelude::*;\n+\n+    use alloc::owned::Box;\n+    use core::mem;\n+    use core::ptr;\n+    use tls = thread_local_storage;\n \n     static mut RT_TLS_KEY: tls::Key = -1;\n \n@@ -396,9 +396,9 @@ pub mod native {\n \n     #[inline] #[cfg(test)]\n     pub fn maybe_tls_key() -> Option<tls::Key> {\n-        use realstd;\n+        use realrustrt;\n         unsafe {\n-            mem::transmute(realstd::rt::shouldnt_be_public::maybe_tls_key())\n+            mem::transmute(realrustrt::shouldnt_be_public::maybe_tls_key())\n         }\n     }\n }", "previous_filename": "src/libstd/rt/local_ptr.rs"}, {"sha": "d4e92736a9d4d2ec38d72a690fba240335efe390", "filename": "src/librustrt/macros.rs", "status": "renamed", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmacros.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -16,8 +16,8 @@\n #![macro_escape]\n \n macro_rules! rterrln (\n-    ($($arg:tt)*) => ( {\n-        format_args!(::rt::util::dumb_println, $($arg)*)\n+    ($fmt:expr $($arg:tt)*) => ( {\n+        format_args!(::util::dumb_print, concat!($fmt, \"\\n\") $($arg)*)\n     } )\n )\n \n@@ -32,7 +32,7 @@ macro_rules! rtdebug (\n \n macro_rules! rtassert (\n     ( $arg:expr ) => ( {\n-        if ::rt::util::ENFORCE_SANITY {\n+        if ::util::ENFORCE_SANITY {\n             if !$arg {\n                 rtabort!(\" assertion failed: {}\", stringify!($arg));\n             }\n@@ -42,8 +42,5 @@ macro_rules! rtassert (\n \n \n macro_rules! rtabort (\n-    ($($arg:tt)*) => ( {\n-        use str::Str;\n-        ::rt::util::abort(format!($($arg)*).as_slice());\n-    } )\n+    ($($arg:tt)*) => (format_args!(::util::abort, $($arg)*))\n )", "previous_filename": "src/libstd/rt/macros.rs"}, {"sha": "fccbe4a15e948144cf8f67488107da5313951692", "filename": "src/librustrt/mutex.rs", "status": "renamed", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -33,7 +33,7 @@\n //! # Example\n //!\n //! ```rust\n-//! use std::unstable::mutex::{NativeMutex, StaticNativeMutex, NATIVE_MUTEX_INIT};\n+//! use std::rt::mutex::{NativeMutex, StaticNativeMutex, NATIVE_MUTEX_INIT};\n //!\n //! // Use a statically initialized mutex\n //! static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n@@ -58,8 +58,7 @@\n \n #![allow(non_camel_case_types)]\n \n-use option::{Option, None, Some};\n-use ops::Drop;\n+use core::prelude::*;\n \n /// A native mutex suitable for storing in statics (that is, it has\n /// the `destroy` method rather than a destructor).\n@@ -109,7 +108,7 @@ impl StaticNativeMutex {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    /// use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     /// static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n     /// unsafe {\n     ///     let _guard = LOCK.lock();\n@@ -183,7 +182,7 @@ impl NativeMutex {\n     ///\n     /// # Example\n     /// ```rust\n-    /// use std::unstable::mutex::NativeMutex;\n+    /// use std::rt::mutex::NativeMutex;\n     /// unsafe {\n     ///     let mut lock = NativeMutex::new();\n     ///\n@@ -264,8 +263,8 @@ mod imp {\n     use libc;\n     use self::os::{PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER,\n                    pthread_mutex_t, pthread_cond_t};\n-    use ty::Unsafe;\n-    use kinds::marker;\n+    use core::ty::Unsafe;\n+    use core::kinds::marker;\n \n     type pthread_mutexattr_t = libc::c_void;\n     type pthread_condattr_t = libc::c_void;\n@@ -432,11 +431,11 @@ mod imp {\n \n #[cfg(windows)]\n mod imp {\n-    use rt::libc_heap::malloc_raw;\n+    use alloc::libc_heap::malloc_raw;\n+    use core::atomics;\n+    use core::ptr;\n     use libc::{HANDLE, BOOL, LPSECURITY_ATTRIBUTES, c_void, DWORD, LPCSTR};\n     use libc;\n-    use ptr;\n-    use sync::atomics;\n \n     type LPCRITICAL_SECTION = *mut c_void;\n     static SPIN_COUNT: DWORD = 4000;\n@@ -563,11 +562,11 @@ mod imp {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use std::prelude::*;\n \n-    use mem::drop;\n+    use std::mem::drop;\n     use super::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    use rt::thread::Thread;\n+    use std::rt::thread::Thread;\n \n     #[test]\n     fn smoke_lock() {", "previous_filename": "src/libstd/unstable/mutex.rs"}, {"sha": "00f761bae2152e133780dea04f574ac05fe8f2a0", "filename": "src/librustrt/rtio.rs", "status": "renamed", "additions": 125, "deletions": 37, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -10,32 +10,18 @@\n \n //! The EventLoop and internal synchronous I/O interface.\n \n-use c_str::CString;\n-use comm::{Sender, Receiver};\n-use kinds::Send;\n+use core::prelude::*;\n+use alloc::owned::Box;\n+use collections::string::String;\n+use collections::vec::Vec;\n+use core::fmt;\n+use core::mem;\n use libc::c_int;\n use libc;\n-use mem;\n-use ops::Drop;\n-use option::{Option, Some, None};\n-use owned::Box;\n-use result::Err;\n-use rt::local::Local;\n-use rt::task::Task;\n-use vec::Vec;\n-\n-use ai = io::net::addrinfo;\n-use io;\n-use io::IoResult;\n-use io::net::ip::{IpAddr, SocketAddr};\n-use io::process::{StdioContainer, ProcessExit};\n-use io::signal::Signum;\n-use io::{FileMode, FileAccess, FileStat, FilePermission};\n-use io::{SeekStyle};\n \n-pub trait Callback {\n-    fn call(&mut self);\n-}\n+use c_str::CString;\n+use local::Local;\n+use task::Task;\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -50,6 +36,10 @@ pub trait EventLoop {\n     fn has_active_io(&self) -> bool;\n }\n \n+pub trait Callback {\n+    fn call(&mut self);\n+}\n+\n pub trait RemoteCallback {\n     /// Trigger the remote callback. Note that the number of times the\n     /// callback is run is not guaranteed. All that is guaranteed is\n@@ -172,9 +162,15 @@ impl<'a> LocalIo<'a> {\n     pub fn maybe_raise<T>(f: |io: &mut IoFactory| -> IoResult<T>)\n         -> IoResult<T>\n     {\n+        #[cfg(unix)] use ERROR = libc::EINVAL;\n+        #[cfg(windows)] use ERROR = libc::ERROR_CALL_NOT_IMPLEMENTED;\n         match LocalIo::borrow() {\n-            None => Err(io::standard_error(io::IoUnavailable)),\n             Some(mut io) => f(io.get()),\n+            None => Err(IoError {\n+                code: ERROR as uint,\n+                extra: 0,\n+                detail: None,\n+            }),\n         }\n     }\n \n@@ -185,11 +181,8 @@ impl<'a> LocalIo<'a> {\n     /// Returns the underlying I/O factory as a trait reference.\n     #[inline]\n     pub fn get<'a>(&'a mut self) -> &'a mut IoFactory {\n-        // FIXME(pcwalton): I think this is actually sound? Could borrow check\n-        // allow this safely?\n-        unsafe {\n-            mem::transmute_copy(&self.factory)\n-        }\n+        let f: &'a mut IoFactory = self.factory;\n+        f\n     }\n }\n \n@@ -206,7 +199,8 @@ pub trait IoFactory {\n     fn unix_connect(&mut self, path: &CString,\n                     timeout: Option<u64>) -> IoResult<Box<RtioPipe:Send>>;\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<ai::Hint>) -> IoResult<Vec<ai::Info>>;\n+                          hint: Option<AddrinfoHint>)\n+                          -> IoResult<Vec<AddrinfoInfo>>;\n \n     // filesystem operations\n     fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior)\n@@ -215,10 +209,8 @@ pub trait IoFactory {\n                -> IoResult<Box<RtioFileStream:Send>>;\n     fn fs_unlink(&mut self, path: &CString) -> IoResult<()>;\n     fn fs_stat(&mut self, path: &CString) -> IoResult<FileStat>;\n-    fn fs_mkdir(&mut self, path: &CString,\n-                mode: FilePermission) -> IoResult<()>;\n-    fn fs_chmod(&mut self, path: &CString,\n-                mode: FilePermission) -> IoResult<()>;\n+    fn fs_mkdir(&mut self, path: &CString, mode: uint) -> IoResult<()>;\n+    fn fs_chmod(&mut self, path: &CString, mode: uint) -> IoResult<()>;\n     fn fs_rmdir(&mut self, path: &CString) -> IoResult<()>;\n     fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()>;\n     fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n@@ -241,7 +233,7 @@ pub trait IoFactory {\n     fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<RtioPipe:Send>>;\n     fn tty_open(&mut self, fd: c_int, readable: bool)\n             -> IoResult<Box<RtioTTY:Send>>;\n-    fn signal(&mut self, signal: Signum, channel: Sender<Signum>)\n+    fn signal(&mut self, signal: int, cb: Box<Callback:Send>)\n         -> IoResult<Box<RtioSignal:Send>>;\n }\n \n@@ -300,8 +292,8 @@ pub trait RtioUdpSocket : RtioSocket {\n \n pub trait RtioTimer {\n     fn sleep(&mut self, msecs: u64);\n-    fn oneshot(&mut self, msecs: u64) -> Receiver<()>;\n-    fn period(&mut self, msecs: u64) -> Receiver<()>;\n+    fn oneshot(&mut self, msecs: u64, cb: Box<Callback:Send>);\n+    fn period(&mut self, msecs: u64, cb: Box<Callback:Send>);\n }\n \n pub trait RtioFileStream {\n@@ -359,3 +351,99 @@ pub trait PausableIdleCallback {\n }\n \n pub trait RtioSignal {}\n+\n+pub struct IoError {\n+    pub code: uint,\n+    pub extra: uint,\n+    pub detail: Option<String>,\n+}\n+\n+pub type IoResult<T> = Result<T, IoError>;\n+\n+#[deriving(PartialEq, Eq)]\n+pub enum IpAddr {\n+    Ipv4Addr(u8, u8, u8, u8),\n+    Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16),\n+}\n+\n+impl fmt::Show for IpAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Ipv4Addr(a, b, c, d) => write!(fmt, \"{}.{}.{}.{}\", a, b, c, d),\n+            Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+                write!(fmt,\n+                       \"{:04x}:{:04x}:{:04x}:{:04x}:{:04x}:{:04x}:{:04x}:{:04x}\",\n+                       a, b, c, d, e, f, g, h)\n+            }\n+        }\n+    }\n+}\n+\n+#[deriving(PartialEq, Eq)]\n+pub struct SocketAddr {\n+    pub ip: IpAddr,\n+    pub port: u16,\n+}\n+\n+pub enum StdioContainer {\n+    Ignored,\n+    InheritFd(i32),\n+    CreatePipe(bool, bool),\n+}\n+\n+pub enum ProcessExit {\n+    ExitStatus(int),\n+    ExitSignal(int),\n+}\n+\n+pub enum FileMode {\n+    Open,\n+    Append,\n+    Truncate,\n+}\n+\n+pub enum FileAccess {\n+    Read,\n+    Write,\n+    ReadWrite,\n+}\n+\n+pub struct FileStat {\n+    pub size: u64,\n+    pub kind: u64,\n+    pub perm: u64,\n+    pub created: u64,\n+    pub modified: u64,\n+    pub accessed: u64,\n+    pub device: u64,\n+    pub inode: u64,\n+    pub rdev: u64,\n+    pub nlink: u64,\n+    pub uid: u64,\n+    pub gid: u64,\n+    pub blksize: u64,\n+    pub blocks: u64,\n+    pub flags: u64,\n+    pub gen: u64,\n+}\n+\n+pub enum SeekStyle {\n+    SeekSet,\n+    SeekEnd,\n+    SeekCur,\n+}\n+\n+pub struct AddrinfoHint {\n+    pub family: uint,\n+    pub socktype: uint,\n+    pub protocol: uint,\n+    pub flags: uint,\n+}\n+\n+pub struct AddrinfoInfo {\n+    pub address: SocketAddr,\n+    pub family: uint,\n+    pub socktype: uint,\n+    pub protocol: uint,\n+    pub flags: uint,\n+}", "previous_filename": "src/libstd/rt/rtio.rs"}, {"sha": "148d93adc8485583c3a58f53bf7a4a87357e549a", "filename": "src/librustrt/stack.rs", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -33,12 +33,11 @@ pub static RED_ZONE: uint = 20 * 1024;\n #[cfg(not(test))] // in testing, use the original libstd's version\n #[lang = \"stack_exhausted\"]\n extern fn stack_exhausted() {\n-    use option::{Option, None, Some};\n-    use owned::Box;\n-    use rt::local::Local;\n-    use rt::task::Task;\n-    use str::Str;\n-    use intrinsics;\n+    use core::prelude::*;\n+    use alloc::owned::Box;\n+    use local::Local;\n+    use task::Task;\n+    use core::intrinsics;\n \n     unsafe {\n         // We're calling this function because the stack just ran out. We need", "previous_filename": "src/libstd/rt/stack.rs"}, {"sha": "f56b891ed9f37afcb32a22cb798b4a3f06342fa1", "filename": "src/librustrt/task.rs", "status": "renamed", "additions": 51, "deletions": 72, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -13,30 +13,23 @@\n //! local storage, and logging. Even a 'freestanding' Rust would likely want\n //! to implement this.\n \n+use core::prelude::*;\n+\n use alloc::arc::Arc;\n+use alloc::owned::{AnyOwnExt, Box};\n+use core::any::Any;\n+use core::iter::Take;\n+use core::mem;\n+use core::finally::Finally;\n+use core::atomics::{AtomicUint, SeqCst};\n \n-use cleanup;\n-use clone::Clone;\n-use comm::Sender;\n-use io::Writer;\n-use iter::{Iterator, Take};\n-use kinds::Send;\n use local_data;\n-use mem;\n-use ops::Drop;\n-use option::{Option, Some, None};\n-use owned::{AnyOwnExt, Box};\n-use prelude::drop;\n-use result::{Result, Ok, Err};\n-use rt::Runtime;\n-use rt::local::Local;\n-use rt::local_heap::LocalHeap;\n-use rt::rtio::LocalIo;\n-use rt::unwind::Unwinder;\n-use str::SendStr;\n-use sync::atomics::{AtomicUint, SeqCst};\n-use task::{TaskResult, TaskOpts};\n-use finally::Finally;\n+use Runtime;\n+use local::Local;\n+use local_heap::LocalHeap;\n+use rtio::LocalIo;\n+use unwind::Unwinder;\n+use collections::str::SendStr;\n \n /// The Task struct represents all state associated with a rust\n /// task. There are at this point two primary \"subtypes\" of task,\n@@ -52,12 +45,26 @@ pub struct Task {\n     pub destroyed: bool,\n     pub name: Option<SendStr>,\n \n-    pub stdout: Option<Box<Writer:Send>>,\n-    pub stderr: Option<Box<Writer:Send>>,\n-\n     imp: Option<Box<Runtime:Send>>,\n }\n \n+pub struct TaskOpts {\n+    /// Invoke this procedure with the result of the task when it finishes.\n+    pub on_exit: Option<proc(Result):Send>,\n+    /// A name for the task-to-be, for identification in failure messages\n+    pub name: Option<SendStr>,\n+    /// The size of the stack for the spawned task\n+    pub stack_size: Option<uint>,\n+}\n+\n+/// Indicates the manner in which a task exited.\n+///\n+/// A task that completes without failing is considered to exit successfully.\n+///\n+/// If you wish for this result's delivery to block until all\n+/// children tasks complete, recommend using a result future.\n+pub type Result = ::core::result::Result<(), Box<Any:Send>>;\n+\n pub struct GarbageCollector;\n pub struct LocalStorage(pub Option<local_data::Map>);\n \n@@ -69,17 +76,9 @@ pub enum BlockedTask {\n     Shared(Arc<AtomicUint>),\n }\n \n-pub enum DeathAction {\n-    /// Action to be done with the exit code. If set, also makes the task wait\n-    /// until all its watched children exit before collecting the status.\n-    Execute(proc(TaskResult):Send),\n-    /// A channel to send the result of the task on when the task exits\n-    SendMessage(Sender<TaskResult>),\n-}\n-\n /// Per-task state related to task death, killing, failure, etc.\n pub struct Death {\n-    pub on_exit: Option<DeathAction>,\n+    pub on_exit: Option<proc(Result):Send>,\n }\n \n pub struct BlockedTasks {\n@@ -96,8 +95,6 @@ impl Task {\n             death: Death::new(),\n             destroyed: false,\n             name: None,\n-            stdout: None,\n-            stderr: None,\n             imp: None,\n         }\n     }\n@@ -126,20 +123,6 @@ impl Task {\n \n             // Run the task main function, then do some cleanup.\n             f.finally(|| {\n-                #[allow(unused_must_use)]\n-                fn close_outputs() {\n-                    let mut task = Local::borrow(None::<Task>);\n-                    let stderr = task.stderr.take();\n-                    let stdout = task.stdout.take();\n-                    drop(task);\n-                    match stdout { Some(mut w) => { w.flush(); }, None => {} }\n-                    match stderr { Some(mut w) => { w.flush(); }, None => {} }\n-                }\n-\n-                // First, flush/destroy the user stdout/logger because these\n-                // destructors can run arbitrary code.\n-                close_outputs();\n-\n                 // First, destroy task-local storage. This may run user dtors.\n                 //\n                 // FIXME #8302: Dear diary. I'm so tired and confused.\n@@ -168,14 +151,11 @@ impl Task {\n                 drop(storage_map);\n \n                 // Destroy remaining boxes. Also may run user dtors.\n-                unsafe { cleanup::annihilate(); }\n-\n-                // Finally, just in case user dtors printed/logged during TLS\n-                // cleanup and annihilation, re-destroy stdout and the logger.\n-                // Note that these will have been initialized with a\n-                // runtime-provided type which we have control over what the\n-                // destructor does.\n-                close_outputs();\n+                let mut task = Local::borrow(None::<Task>);\n+                let mut heap = mem::replace(&mut task.heap, LocalHeap::new());\n+                drop(task);\n+                unsafe { heap.annihilate() }\n+                drop(heap);\n             })\n         };\n \n@@ -247,7 +227,7 @@ impl Task {\n     /// recommended to use this function directly, but rather communication\n     /// primitives in `std::comm` should be used.\n     pub fn deschedule(mut ~self, amt: uint,\n-                      f: |BlockedTask| -> Result<(), BlockedTask>) {\n+                      f: |BlockedTask| -> ::core::result::Result<(), BlockedTask>) {\n         let ops = self.imp.take_unwrap();\n         ops.deschedule(amt, self, f)\n     }\n@@ -303,6 +283,12 @@ impl Drop for Task {\n     }\n }\n \n+impl TaskOpts {\n+    pub fn new() -> TaskOpts {\n+        TaskOpts { on_exit: None, name: None, stack_size: None }\n+    }\n+}\n+\n impl Iterator<BlockedTask> for BlockedTasks {\n     fn next(&mut self) -> Option<BlockedTask> {\n         Some(Shared(self.inner.clone()))\n@@ -389,10 +375,9 @@ impl Death {\n     }\n \n     /// Collect failure exit codes from children and propagate them to a parent.\n-    pub fn collect_failure(&mut self, result: TaskResult) {\n+    pub fn collect_failure(&mut self, result: Result) {\n         match self.on_exit.take() {\n-            Some(Execute(f)) => f(result),\n-            Some(SendMessage(ch)) => { let _ = ch.send_opt(result); }\n+            Some(f) => f(result),\n             None => {}\n         }\n     }\n@@ -407,8 +392,8 @@ impl Drop for Death {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use prelude::*;\n-    use task;\n+    use std::prelude::*;\n+    use std::task;\n \n     #[test]\n     fn local_heap() {\n@@ -440,16 +425,11 @@ mod test {\n \n     #[test]\n     fn rng() {\n-        use rand::{StdRng, Rng};\n+        use std::rand::{StdRng, Rng};\n         let mut r = StdRng::new().ok().unwrap();\n         let _ = r.next_u32();\n     }\n \n-    #[test]\n-    fn logging() {\n-        info!(\"here i am. logging in a newsched task\");\n-    }\n-\n     #[test]\n     fn comm_stream() {\n         let (tx, rx) = channel();\n@@ -466,8 +446,7 @@ mod test {\n \n     #[test]\n     fn heap_cycles() {\n-        use cell::RefCell;\n-        use option::{Option, Some, None};\n+        use std::cell::RefCell;\n \n         struct List {\n             next: Option<@RefCell<List>>,\n@@ -485,7 +464,7 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_begin_unwind() {\n-        use rt::unwind::begin_unwind;\n+        use std::rt::unwind::begin_unwind;\n         begin_unwind(\"cause\", file!(), line!())\n     }\n ", "previous_filename": "src/libstd/rt/task.rs"}, {"sha": "2cdeb21fb83dde04f3dfd25c63d2b7577863764f", "filename": "src/librustrt/thread_local_storage.rs", "status": "renamed", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread_local_storage.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -10,26 +10,21 @@\n \n #![allow(dead_code)]\n \n-#[cfg(test)]\n-use owned::Box;\n-#[cfg(unix)]\n-use libc::c_int;\n-#[cfg(unix)]\n-use ptr::null;\n-#[cfg(windows)]\n-use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n+#[cfg(unix)] use libc::c_int;\n+#[cfg(unix)] use core::ptr::null;\n+#[cfg(windows)] use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n \n #[cfg(unix)]\n pub type Key = pthread_key_t;\n \n #[cfg(unix)]\n pub unsafe fn create(key: &mut Key) {\n-    assert_eq!(0, pthread_key_create(key, null()));\n+    assert!(pthread_key_create(key, null()) == 0);\n }\n \n #[cfg(unix)]\n pub unsafe fn set(key: Key, value: *mut u8) {\n-    assert_eq!(0, pthread_setspecific(key, value));\n+    assert!(pthread_setspecific(key, value) == 0);\n }\n \n #[cfg(unix)]\n@@ -39,7 +34,7 @@ pub unsafe fn get(key: Key) -> *mut u8 {\n \n #[cfg(unix)]\n pub unsafe fn destroy(key: Key) {\n-    assert_eq!(0, pthread_key_delete(key));\n+    assert!(pthread_key_delete(key) == 0);\n }\n \n #[cfg(target_os=\"macos\")]\n@@ -94,19 +89,25 @@ extern \"system\" {\n     fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n }\n \n-#[test]\n-fn tls_smoke_test() {\n-    use mem::transmute;\n-    unsafe {\n-        let mut key = 0;\n-        let value = box 20;\n-        create(&mut key);\n-        set(key, transmute(value));\n-        let value: Box<int> = transmute(get(key));\n-        assert_eq!(value, box 20);\n-        let value = box 30;\n-        set(key, transmute(value));\n-        let value: Box<int> = transmute(get(key));\n-        assert_eq!(value, box 30);\n+#[cfg(test)]\n+mod test {\n+    use std::prelude::*;\n+    use super::*;\n+\n+    #[test]\n+    fn tls_smoke_test() {\n+        use std::mem::transmute;\n+        unsafe {\n+            let mut key = 0;\n+            let value = box 20;\n+            create(&mut key);\n+            set(key, transmute(value));\n+            let value: Box<int> = transmute(get(key));\n+            assert_eq!(value, box 20);\n+            let value = box 30;\n+            set(key, transmute(value));\n+            let value: Box<int> = transmute(get(key));\n+            assert_eq!(value, box 30);\n+        }\n     }\n }", "previous_filename": "src/libstd/rt/thread_local_storage.rs"}, {"sha": "da6fd3644ce7fcc6d2acefa9f4a206bfbca09f47", "filename": "src/librustrt/unwind.rs", "status": "renamed", "additions": 172, "deletions": 177, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -8,73 +8,74 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Stack unwinding\n-\n-// Implementation of Rust stack unwinding\n-//\n-// For background on exception handling and stack unwinding please see\n-// \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n-// documents linked from it.\n-// These are also good reads:\n-//     http://theofilos.cs.columbia.edu/blog/2013/09/22/base_abi/\n-//     http://monoinfinito.wordpress.com/series/exception-handling-in-c/\n-//     http://www.airs.com/blog/index.php?s=exception+frames\n-//\n-// ~~~ A brief summary ~~~\n-// Exception handling happens in two phases: a search phase and a cleanup phase.\n-//\n-// In both phases the unwinder walks stack frames from top to bottom using\n-// information from the stack frame unwind sections of the current process's\n-// modules (\"module\" here refers to an OS module, i.e. an executable or a\n-// dynamic library).\n-//\n-// For each stack frame, it invokes the associated \"personality routine\", whose\n-// address is also stored in the unwind info section.\n-//\n-// In the search phase, the job of a personality routine is to examine exception\n-// object being thrown, and to decide whether it should be caught at that stack\n-// frame.  Once the handler frame has been identified, cleanup phase begins.\n-//\n-// In the cleanup phase, personality routines invoke cleanup code associated\n-// with their stack frames (i.e. destructors).  Once stack has been unwound down\n-// to the handler frame level, unwinding stops and the last personality routine\n-// transfers control to its' catch block.\n-//\n-// ~~~ Frame unwind info registration ~~~\n-// Each module has its' own frame unwind info section (usually \".eh_frame\"), and\n-// unwinder needs to know about all of them in order for unwinding to be able to\n-// cross module boundaries.\n-//\n-// On some platforms, like Linux, this is achieved by dynamically enumerating\n-// currently loaded modules via the dl_iterate_phdr() API and finding all\n-// .eh_frame sections.\n-//\n-// Others, like Windows, require modules to actively register their unwind info\n-// sections by calling __register_frame_info() API at startup.  In the latter\n-// case it is essential that there is only one copy of the unwinder runtime in\n-// the process.  This is usually achieved by linking to the dynamic version of\n-// the unwind runtime.\n-//\n-// Currently Rust uses unwind runtime provided by libgcc.\n-\n-use any::{Any, AnyRefExt};\n-use fmt;\n-use intrinsics;\n-use kinds::Send;\n-use mem;\n-use option::{Some, None, Option};\n-use owned::Box;\n-use prelude::drop;\n-use ptr::RawPtr;\n-use result::{Err, Ok, Result};\n-use rt::backtrace;\n-use rt::local::Local;\n-use rt::task::Task;\n-use str::Str;\n-use string::String;\n-use task::TaskResult;\n-\n-use uw = rt::libunwind;\n+//! Implementation of Rust stack unwinding\n+//!\n+//! For background on exception handling and stack unwinding please see\n+//! \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n+//! documents linked from it.\n+//! These are also good reads:\n+//!     http://theofilos.cs.columbia.edu/blog/2013/09/22/base_abi/\n+//!     http://monoinfinito.wordpress.com/series/exception-handling-in-c/\n+//!     http://www.airs.com/blog/index.php?s=exception+frames\n+//!\n+//! ## A brief summary\n+//!\n+//! Exception handling happens in two phases: a search phase and a cleanup phase.\n+//!\n+//! In both phases the unwinder walks stack frames from top to bottom using\n+//! information from the stack frame unwind sections of the current process's\n+//! modules (\"module\" here refers to an OS module, i.e. an executable or a\n+//! dynamic library).\n+//!\n+//! For each stack frame, it invokes the associated \"personality routine\", whose\n+//! address is also stored in the unwind info section.\n+//!\n+//! In the search phase, the job of a personality routine is to examine exception\n+//! object being thrown, and to decide whether it should be caught at that stack\n+//! frame.  Once the handler frame has been identified, cleanup phase begins.\n+//!\n+//! In the cleanup phase, personality routines invoke cleanup code associated\n+//! with their stack frames (i.e. destructors).  Once stack has been unwound down\n+//! to the handler frame level, unwinding stops and the last personality routine\n+//! transfers control to its' catch block.\n+//!\n+//! ## Frame unwind info registration\n+//!\n+//! Each module has its' own frame unwind info section (usually \".eh_frame\"), and\n+//! unwinder needs to know about all of them in order for unwinding to be able to\n+//! cross module boundaries.\n+//!\n+//! On some platforms, like Linux, this is achieved by dynamically enumerating\n+//! currently loaded modules via the dl_iterate_phdr() API and finding all\n+//! .eh_frame sections.\n+//!\n+//! Others, like Windows, require modules to actively register their unwind info\n+//! sections by calling __register_frame_info() API at startup.  In the latter\n+//! case it is essential that there is only one copy of the unwinder runtime in\n+//! the process.  This is usually achieved by linking to the dynamic version of\n+//! the unwind runtime.\n+//!\n+//! Currently Rust uses unwind runtime provided by libgcc.\n+\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use collections::string::String;\n+use collections::vec::Vec;\n+use core::any::Any;\n+use core::atomics;\n+use core::cmp;\n+use core::fmt;\n+use core::intrinsics;\n+use core::mem;\n+use core::raw::Closure;\n+use libc::c_void;\n+\n+use local::Local;\n+use task::{Task, Result};\n+use exclusive::Exclusive;\n+\n+use uw = libunwind;\n \n pub struct Unwinder {\n     unwinding: bool,\n@@ -86,6 +87,24 @@ struct Exception {\n     cause: Option<Box<Any:Send>>,\n }\n \n+pub type Callback = fn(msg: &Any:Send, file: &'static str, line: uint);\n+type Queue = Exclusive<Vec<Callback>>;\n+\n+// Variables used for invoking callbacks when a task starts to unwind.\n+//\n+// For more information, see below.\n+static MAX_CALLBACKS: uint = 16;\n+static mut CALLBACKS: [atomics::AtomicUint, ..MAX_CALLBACKS] =\n+        [atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT,\n+         atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT,\n+         atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT,\n+         atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT,\n+         atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT,\n+         atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT,\n+         atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT,\n+         atomics::INIT_ATOMIC_UINT, atomics::INIT_ATOMIC_UINT];\n+static mut CALLBACK_CNT: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n+\n impl Unwinder {\n     pub fn new() -> Unwinder {\n         Unwinder {\n@@ -158,6 +177,7 @@ pub unsafe fn try(f: ||) -> Result<(), Box<Any:Send>> {\n         }\n     }\n \n+    #[link(name = \"rustrt_native\", kind = \"static\")]\n     extern {\n         // Rust's try-catch\n         // When f(...) returns normally, the return value is null.\n@@ -227,7 +247,7 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n #[doc(hidden)]\n #[allow(visible_private_types)]\n pub mod eabi {\n-    use uw = rt::libunwind;\n+    use uw = libunwind;\n     use libc::c_int;\n \n     extern \"C\" {\n@@ -338,11 +358,26 @@ pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n #[inline(never)] #[cold]\n pub fn begin_unwind_fmt(msg: &fmt::Arguments, file: &'static str,\n                         line: uint) -> ! {\n+    use core::fmt::FormatWriter;\n+\n     // We do two allocations here, unfortunately. But (a) they're\n     // required with the current scheme, and (b) we don't handle\n     // failure + OOM properly anyway (see comment in begin_unwind\n     // below).\n-    begin_unwind_inner(box fmt::format(msg), file, line)\n+\n+    struct VecWriter<'a> { v: &'a mut Vec<u8> }\n+\n+    impl<'a> fmt::FormatWriter for VecWriter<'a> {\n+        fn write(&mut self, buf: &[u8]) -> fmt::Result {\n+            self.v.push_all(buf);\n+            Ok(())\n+        }\n+    }\n+\n+    let mut v = Vec::new();\n+    let _ = write!(&mut VecWriter { v: &mut v }, \"{}\", msg);\n+\n+    begin_unwind_inner(box String::from_utf8(v).unwrap(), file, line)\n }\n \n /// This is the entry point of unwinding for fail!() and assert!().\n@@ -373,122 +408,82 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> !\n fn begin_unwind_inner(msg: Box<Any:Send>,\n                       file: &'static str,\n                       line: uint) -> ! {\n-    // First up, print the message that we're failing\n-    print_failure(msg, file, line);\n-\n-    let opt_task: Option<Box<Task>> = Local::try_take();\n-    match opt_task {\n-        Some(mut task) => {\n-            // Now that we've printed why we're failing, do a check\n-            // to make sure that we're not double failing.\n-            //\n-            // If a task fails while it's already unwinding then we\n-            // have limited options. Currently our preference is to\n-            // just abort. In the future we may consider resuming\n-            // unwinding or otherwise exiting the task cleanly.\n-            if task.unwinder.unwinding {\n-                rterrln!(\"task failed during unwinding. aborting.\");\n-\n-                // Don't print the backtrace twice (it would have already been\n-                // printed if logging was enabled).\n-                if !backtrace::log_enabled() {\n-                    let mut err = ::rt::util::Stderr;\n-                    let _err = backtrace::write(&mut err);\n-                }\n-                unsafe { intrinsics::abort() }\n+    // First, invoke call the user-defined callbacks triggered on task failure.\n+    //\n+    // By the time that we see a callback has been registered (by reading\n+    // MAX_CALLBACKS), the actuall callback itself may have not been stored yet,\n+    // so we just chalk it up to a race condition and move on to the next\n+    // callback. Additionally, CALLBACK_CNT may briefly be higher than\n+    // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n+    let callbacks = unsafe {\n+        let amt = CALLBACK_CNT.load(atomics::SeqCst);\n+        CALLBACKS.slice_to(cmp::min(amt, MAX_CALLBACKS))\n+    };\n+    for cb in callbacks.iter() {\n+        match cb.load(atomics::SeqCst) {\n+            0 => {}\n+            n => {\n+                let f: Callback = unsafe { mem::transmute(n) };\n+                f(msg, file, line);\n             }\n-\n-            // Finally, we've printed our failure and figured out we're not in a\n-            // double failure, so flag that we've started to unwind and then\n-            // actually unwind.  Be sure that the task is in TLS so destructors\n-            // can do fun things like I/O.\n-            task.unwinder.unwinding = true;\n-            Local::put(task);\n         }\n-        None => {}\n+    };\n+\n+    // Now that we've run all the necessary unwind callbacks, we actually\n+    // perform the unwinding. If we don't have a task, then it's time to die\n+    // (hopefully someone printed something about this).\n+    let task: Box<Task> = match Local::try_take() {\n+        Some(task) => task,\n+        None => unsafe { intrinsics::abort() }\n+    };\n+\n+    if task.unwinder.unwinding {\n+        // If a task fails while it's already unwinding then we\n+        // have limited options. Currently our preference is to\n+        // just abort. In the future we may consider resuming\n+        // unwinding or otherwise exiting the task cleanly.\n+        rterrln!(\"task failed during unwinding. aborting.\");\n+        unsafe { intrinsics::abort() }\n     }\n-    rust_fail(msg)\n+\n+    // Put the task back in TLS because the unwinding process may run code which\n+    // requires the task. We need a handle to its unwinder, however, so after\n+    // this we unsafely extract it and continue along.\n+    Local::put(task);\n+    unsafe {\n+        let task: *mut Task = Local::unsafe_borrow();\n+        (*task).unwinder.begin_unwind(msg);\n+    }\n+    task.name = name;\n+    Local::put(task);\n }\n \n-/// Given a failure message and the location that it occurred, prints the\n-/// message to the local task's appropriate stream.\n+/// Register a callback to be invoked when a task unwinds.\n ///\n-/// This function currently handles three cases:\n+/// This is an unsafe and experimental API which allows for an arbitrary\n+/// callback to be invoked when a task fails. This callback is invoked on both\n+/// the initial unwinding and a double unwinding if one occurs. Additionally,\n+/// the local `Task` will be in place for the duration of the callback, and\n+/// the callback must ensure that it remains in place once the callback returns.\n ///\n-///     - There is no local task available. In this case the error is printed to\n-///       stderr.\n-///     - There is a local task available, but it does not have a stderr handle.\n-///       In this case the message is also printed to stderr.\n-///     - There is a local task available, and it has a stderr handle. The\n-///       message is printed to the handle given in this case.\n-fn print_failure(msg: &Any:Send, file: &str, line: uint) {\n-    let msg = match msg.as_ref::<&'static str>() {\n-        Some(s) => *s,\n-        None => match msg.as_ref::<String>() {\n-            Some(s) => s.as_slice(),\n-            None => \"Box<Any>\",\n+/// Only a limited number of callbacks can be registered, and this function\n+/// returns whether the callback was successfully registered or not. It is not\n+/// currently possible to unregister a callback once it has been registered.\n+#[experimental]\n+pub unsafe fn register(f: Callback) -> bool {\n+    match CALLBACK_CNT.fetch_add(1, atomics::SeqCst) {\n+        // The invocation code has knowledge of this window where the count has\n+        // been incremented, but the callback has not been stored. We're\n+        // guaranteed that the slot we're storing into is 0.\n+        n if n < MAX_CALLBACKS => {\n+            let prev = CALLBACKS[n].swap(mem::transmute(f), atomics::SeqCst);\n+            rtassert!(prev == 0);\n+            true\n         }\n-    };\n-\n-    // It is assumed that all reasonable rust code will have a local task at\n-    // all times. This means that this `try_take` will succeed almost all of\n-    // the time. There are border cases, however, when the runtime has\n-    // *almost* set up the local task, but hasn't quite gotten there yet. In\n-    // order to get some better diagnostics, we print on failure and\n-    // immediately abort the whole process if there is no local task\n-    // available.\n-    let mut task: Box<Task> = match Local::try_take() {\n-        Some(t) => t,\n-        None => {\n-            rterrln!(\"failed at '{}', {}:{}\", msg, file, line);\n-            if backtrace::log_enabled() {\n-                let mut err = ::rt::util::Stderr;\n-                let _err = backtrace::write(&mut err);\n-            } else {\n-                rterrln!(\"run with `RUST_BACKTRACE=1` to see a backtrace\");\n-            }\n-            return\n-        }\n-    };\n-\n-    // See comments in io::stdio::with_task_stdout as to why we have to be\n-    // careful when using an arbitrary I/O handle from the task. We\n-    // essentially need to dance to make sure when a task is in TLS when\n-    // running user code.\n-    let name = task.name.take();\n-    {\n-        let n = name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n-\n-        match task.stderr.take() {\n-            Some(mut stderr) => {\n-                Local::put(task);\n-                // FIXME: what to do when the task printing fails?\n-                let _err = write!(stderr,\n-                                  \"task '{}' failed at '{}', {}:{}\\n\",\n-                                  n, msg, file, line);\n-                if backtrace::log_enabled() {\n-                    let _err = backtrace::write(stderr);\n-                }\n-                task = Local::take();\n-\n-                match mem::replace(&mut task.stderr, Some(stderr)) {\n-                    Some(prev) => {\n-                        Local::put(task);\n-                        drop(prev);\n-                        task = Local::take();\n-                    }\n-                    None => {}\n-                }\n-            }\n-            None => {\n-                rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg, file, line);\n-                if backtrace::log_enabled() {\n-                    let mut err = ::rt::util::Stderr;\n-                    let _err = backtrace::write(&mut err);\n-                }\n-            }\n+        // If we accidentally bumped the count too high, pull it back.\n+        _ => {\n+            CALLBACK_CNT.store(MAX_CALLBACKS, atomics::SeqCst);\n+            false\n         }\n     }\n-    task.name = name;\n-    Local::put(task);\n }", "previous_filename": "src/libstd/rt/unwind.rs"}, {"sha": "0b517bcc7fb5c6cb316fcd790a52655bfd4c463d", "filename": "src/librustrt/util.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use core::cmp;\n+use core::fmt;\n+use core::intrinsics;\n+use core::slice;\n+use core::str;\n+use libc;\n+\n+// Indicates whether we should perform expensive sanity checks, including rtassert!\n+//\n+// FIXME: Once the runtime matures remove the `true` below to turn off rtassert,\n+//        etc.\n+pub static ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n+                                  cfg!(rtassert);\n+\n+pub struct Stdio(libc::c_int);\n+\n+pub static Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n+pub static Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n+\n+impl fmt::FormatWriter for Stdio {\n+    fn write(&mut self, data: &[u8]) -> fmt::Result {\n+        #[cfg(unix)]\n+        type WriteLen = libc::size_t;\n+        #[cfg(windows)]\n+        type WriteLen = libc::c_uint;\n+        unsafe {\n+            let Stdio(fd) = *self;\n+            libc::write(fd,\n+                        data.as_ptr() as *libc::c_void,\n+                        data.len() as WriteLen);\n+        }\n+        Ok(()) // yes, we're lying\n+    }\n+}\n+\n+pub fn dumb_print(args: &fmt::Arguments) {\n+    use core::fmt::FormatWriter;\n+    let mut w = Stderr;\n+    let _ = w.write_fmt(args);\n+}\n+\n+pub fn abort(args: &fmt::Arguments) -> ! {\n+    use core::fmt::FormatWriter;\n+\n+    struct BufWriter<'a> {\n+        buf: &'a mut [u8],\n+        pos: uint,\n+    }\n+    impl<'a> FormatWriter for BufWriter<'a> {\n+        fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n+            let left = self.buf.mut_slice_from(self.pos);\n+            let to_write = bytes.slice_to(cmp::min(bytes.len(), left.len()));\n+            slice::bytes::copy_memory(left, to_write);\n+            self.pos += to_write.len();\n+            Ok(())\n+        }\n+    }\n+\n+    // Convert the arguments into a stack-allocated string\n+    let mut msg = [0u8, ..512];\n+    let mut w = BufWriter { buf: msg, pos: 0 };\n+    let _ = write!(&mut w, \"{}\", args);\n+    let msg = str::from_utf8(w.buf.slice_to(w.pos)).unwrap_or(\"aborted\");\n+    let msg = if msg.is_empty() {\n+        \"aborted\"\n+    } else { \"aborted\" };\n+\n+    // Give some context to the message\n+    let hash = msg.bytes().fold(0, |accum, val| accum + (val as uint) );\n+    let quote = match hash % 10 {\n+        0 => \"\n+It was from the artists and poets that the pertinent answers came, and I\n+know that panic would have broken loose had they been able to compare notes.\n+As it was, lacking their original letters, I half suspected the compiler of\n+having asked leading questions, or of having edited the correspondence in\n+corroboration of what he had latently resolved to see.\",\n+        1 => \"\n+There are not many persons who know what wonders are opened to them in the\n+stories and visions of their youth; for when as children we listen and dream,\n+we think but half-formed thoughts, and when as men we try to remember, we are\n+dulled and prosaic with the poison of life. But some of us awake in the night\n+with strange phantasms of enchanted hills and gardens, of fountains that sing\n+in the sun, of golden cliffs overhanging murmuring seas, of plains that stretch\n+down to sleeping cities of bronze and stone, and of shadowy companies of heroes\n+that ride caparisoned white horses along the edges of thick forests; and then\n+we know that we have looked back through the ivory gates into that world of\n+wonder which was ours before we were wise and unhappy.\",\n+        2 => \"\n+Instead of the poems I had hoped for, there came only a shuddering blackness\n+and ineffable loneliness; and I saw at last a fearful truth which no one had\n+ever dared to breathe before \u2014 the unwhisperable secret of secrets \u2014 The fact\n+that this city of stone and stridor is not a sentient perpetuation of Old New\n+York as London is of Old London and Paris of Old Paris, but that it is in fact\n+quite dead, its sprawling body imperfectly embalmed and infested with queer\n+animate things which have nothing to do with it as it was in life.\",\n+        3 => \"\n+The ocean ate the last of the land and poured into the smoking gulf, thereby\n+giving up all it had ever conquered. From the new-flooded lands it flowed\n+again, uncovering death and decay; and from its ancient and immemorial bed it\n+trickled loathsomely, uncovering nighted secrets of the years when Time was\n+young and the gods unborn. Above the waves rose weedy remembered spires. The\n+moon laid pale lilies of light on dead London, and Paris stood up from its damp\n+grave to be sanctified with star-dust. Then rose spires and monoliths that were\n+weedy but not remembered; terrible spires and monoliths of lands that men never\n+knew were lands...\",\n+        4 => \"\n+There was a night when winds from unknown spaces whirled us irresistibly into\n+limitless vacuum beyond all thought and entity. Perceptions of the most\n+maddeningly untransmissible sort thronged upon us; perceptions of infinity\n+which at the time convulsed us with joy, yet which are now partly lost to my\n+memory and partly incapable of presentation to others.\",\n+        _ => \"You've met with a terrible fate, haven't you?\"\n+    };\n+    rterrln!(\"{}\", \"\");\n+    rterrln!(\"{}\", quote);\n+    rterrln!(\"{}\", \"\");\n+    rterrln!(\"fatal runtime error: {}\", msg);\n+    unsafe { intrinsics::abort(); }\n+}"}, {"sha": "2e51931f15a1336a046bf3a4dee3e5f978f1f05c", "filename": "src/libstd/cleanup.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a3f9aa9ef8657304006fcbe4759a263720b8592c/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f9aa9ef8657304006fcbe4759a263720b8592c/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=a3f9aa9ef8657304006fcbe4759a263720b8592c", "patch": "@@ -1,102 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![doc(hidden)]\n-\n-use ptr;\n-use raw;\n-\n-static RC_IMMORTAL : uint = 0x77777777;\n-\n-/*\n- * Box annihilation\n- *\n- * This runs at task death to free all boxes.\n- */\n-\n-unsafe fn each_live_alloc(read_next_before: bool,\n-                          f: |alloc: *mut raw::Box<()>| -> bool)\n-                          -> bool {\n-    //! Walks the internal list of allocations\n-\n-    use rt::local_heap;\n-\n-    let mut alloc = local_heap::live_allocs();\n-    while alloc != ptr::mut_null() {\n-        let next_before = (*alloc).next;\n-\n-        if !f(alloc) {\n-            return false;\n-        }\n-\n-        if read_next_before {\n-            alloc = next_before;\n-        } else {\n-            alloc = (*alloc).next;\n-        }\n-    }\n-    return true;\n-}\n-\n-#[cfg(unix)]\n-fn debug_mem() -> bool {\n-    // FIXME: Need to port the environment struct to newsched\n-    false\n-}\n-\n-#[cfg(windows)]\n-fn debug_mem() -> bool {\n-    false\n-}\n-\n-/// Destroys all managed memory (i.e. @ boxes) held by the current task.\n-pub unsafe fn annihilate() {\n-    use rt::local_heap::local_free;\n-\n-    let mut n_total_boxes = 0u;\n-\n-    // Pass 1: Make all boxes immortal.\n-    //\n-    // In this pass, nothing gets freed, so it does not matter whether\n-    // we read the next field before or after the callback.\n-    each_live_alloc(true, |alloc| {\n-        n_total_boxes += 1;\n-        (*alloc).ref_count = RC_IMMORTAL;\n-        true\n-    });\n-\n-    // Pass 2: Drop all boxes.\n-    //\n-    // In this pass, unique-managed boxes may get freed, but not\n-    // managed boxes, so we must read the `next` field *after* the\n-    // callback, as the original value may have been freed.\n-    each_live_alloc(false, |alloc| {\n-        let drop_glue = (*alloc).drop_glue;\n-        let data = &mut (*alloc).data as *mut ();\n-        drop_glue(data as *mut u8);\n-        true\n-    });\n-\n-    // Pass 3: Free all boxes.\n-    //\n-    // In this pass, managed boxes may get freed (but not\n-    // unique-managed boxes, though I think that none of those are\n-    // left), so we must read the `next` field before, since it will\n-    // not be valid after.\n-    each_live_alloc(true, |alloc| {\n-        local_free(alloc as *u8);\n-        true\n-    });\n-\n-    if debug_mem() {\n-        // We do logging here w/o allocation.\n-        println!(\"total boxes annihilated: {}\", n_total_boxes);\n-    }\n-}"}, {"sha": "903f39c7b06a3ef717f9acf304a7117b8a0c5f41", "filename": "src/libstd/failure.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use alloc::owned::Box;\n+use any::{Any, AnyRefExt};\n+use fmt;\n+use io::{Writer, IoResult};\n+use kinds::Send;\n+use option::{Some, None};\n+use result::Ok;\n+use rt::backtrace;\n+use rt::{Stderr, Stdio};\n+use rustrt::local::Local;\n+use rustrt::task::Task;\n+use str::Str;\n+use string::String;\n+\n+// Defined in this module instead of io::stdio so that the unwinding\n+local_data_key!(pub local_stderr: Box<Writer:Send>)\n+\n+impl Writer for Stdio {\n+    fn write(&mut self, bytes: &[u8]) -> IoResult<()> {\n+        fn fmt_write<F: fmt::FormatWriter>(f: &mut F, bytes: &[u8]) {\n+            let _ = f.write(bytes);\n+        }\n+        fmt_write(self, bytes);\n+        Ok(())\n+    }\n+}\n+\n+pub fn on_fail(obj: &Any:Send, file: &'static str, line: uint) {\n+    let msg = match obj.as_ref::<&'static str>() {\n+        Some(s) => *s,\n+        None => match obj.as_ref::<String>() {\n+            Some(s) => s.as_slice(),\n+            None => \"Box<Any>\",\n+        }\n+    };\n+    let mut err = Stderr;\n+\n+    // It is assumed that all reasonable rust code will have a local task at\n+    // all times. This means that this `exists` will return true almost all of\n+    // the time. There are border cases, however, when the runtime has\n+    // *almost* set up the local task, but hasn't quite gotten there yet. In\n+    // order to get some better diagnostics, we print on failure and\n+    // immediately abort the whole process if there is no local task\n+    // available.\n+    if !Local::exists(None::<Task>) {\n+        let _ = writeln!(&mut err, \"failed at '{}', {}:{}\", msg, file, line);\n+        if backtrace::log_enabled() {\n+            let _ = backtrace::write(&mut err);\n+        } else {\n+            let _ = writeln!(&mut err, \"run with `RUST_BACKTRACE=1` to \\\n+                                        see a backtrace\");\n+        }\n+        return\n+    }\n+\n+    // Peel the name out of local task so we can print it. We've got to be sure\n+    // that the local task is in TLS while we're printing as I/O may occur.\n+    let (name, unwinding) = {\n+        let mut t = Local::borrow(None::<Task>);\n+        (t.name.take(), t.unwinder.unwinding())\n+    };\n+    {\n+        let n = name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n+\n+        match local_stderr.replace(None) {\n+            Some(mut stderr) => {\n+                // FIXME: what to do when the task printing fails?\n+                let _ = writeln!(stderr,\n+                                 \"task '{}' failed at '{}', {}:{}\\n\",\n+                                 n, msg, file, line);\n+                if backtrace::log_enabled() {\n+                    let _ = backtrace::write(stderr);\n+                }\n+                local_stderr.replace(Some(stderr));\n+            }\n+            None => {\n+                let _ = writeln!(&mut err, \"task '{}' failed at '{}', {}:{}\",\n+                                 n, msg, file, line);\n+                if backtrace::log_enabled() {\n+                    let _ = backtrace::write(&mut err);\n+                }\n+            }\n+        }\n+\n+        // If this is a double failure, make sure that we printed a backtrace\n+        // for this failure.\n+        if unwinding && !backtrace::log_enabled() {\n+            let _ = backtrace::write(&mut err);\n+        }\n+    }\n+    Local::borrow(None::<Task>).name = name;\n+}"}, {"sha": "c892a73d9348433101e348968681400ee3b7ae96", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a3f9aa9ef8657304006fcbe4759a263720b8592c/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f9aa9ef8657304006fcbe4759a263720b8592c/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=a3f9aa9ef8657304006fcbe4759a263720b8592c", "patch": "@@ -1,74 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementation of running at_exit routines\n-//!\n-//! Documentation can be found on the `rt::at_exit` function.\n-\n-use iter::Iterator;\n-use kinds::Send;\n-use mem;\n-use option::{Some, None};\n-use owned::Box;\n-use ptr::RawPtr;\n-use slice::OwnedVector;\n-use unstable::sync::Exclusive;\n-use vec::Vec;\n-\n-type Queue = Exclusive<Vec<proc():Send>>;\n-\n-// You'll note that these variables are *not* atomic, and this is done on\n-// purpose. This module is designed to have init() called *once* in a\n-// single-task context, and then run() is called only once in another\n-// single-task context. As a result of this, only the `push` function is\n-// thread-safe, and it assumes that the `init` function has run previously.\n-static mut QUEUE: *mut Queue = 0 as *mut Queue;\n-static mut RUNNING: bool = false;\n-\n-pub fn init() {\n-    unsafe {\n-        rtassert!(!RUNNING);\n-        rtassert!(QUEUE.is_null());\n-        let state: Box<Queue> = box Exclusive::new(vec!());\n-        QUEUE = mem::transmute(state);\n-    }\n-}\n-\n-pub fn push(f: proc():Send) {\n-    unsafe {\n-        rtassert!(!RUNNING);\n-        rtassert!(!QUEUE.is_null());\n-        let state: &mut Queue = mem::transmute(QUEUE);\n-        let mut f = Some(f);\n-        state.with(|arr|  {\n-            arr.push(f.take_unwrap());\n-        });\n-    }\n-}\n-\n-pub fn run() {\n-    let vec = unsafe {\n-        rtassert!(!RUNNING);\n-        rtassert!(!QUEUE.is_null());\n-        RUNNING = true;\n-        let state: Box<Queue> = mem::transmute(QUEUE);\n-        QUEUE = 0 as *mut Queue;\n-        let mut vec = None;\n-        state.with(|arr| {\n-            vec = Some(mem::replace(arr, vec!()));\n-        });\n-        vec.take_unwrap()\n-    };\n-\n-\n-    for f in vec.move_iter() {\n-        f();\n-    }\n-}"}, {"sha": "4229e9ad32c212c82d1415b1e5d5d3a41b287e99", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 101, "deletions": 2, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -242,8 +242,7 @@ mod imp {\n     use mem;\n     use option::{Some, None, Option};\n     use result::{Ok, Err};\n-    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    use uw = rt::libunwind;\n+    use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n     struct Context<'a> {\n         idx: int,\n@@ -484,6 +483,106 @@ mod imp {\n         }\n         w.write(['\\n' as u8])\n     }\n+\n+    /// Unwind library interface used for backtraces\n+    ///\n+    /// Note that the native libraries come from librustrt, not this module.\n+    #[allow(non_camel_case_types)]\n+    #[allow(non_snake_case_functions)]\n+    mod uw {\n+        use libc;\n+\n+        #[repr(C)]\n+        pub enum _Unwind_Reason_Code {\n+            _URC_NO_REASON = 0,\n+            _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n+            _URC_FATAL_PHASE2_ERROR = 2,\n+            _URC_FATAL_PHASE1_ERROR = 3,\n+            _URC_NORMAL_STOP = 4,\n+            _URC_END_OF_STACK = 5,\n+            _URC_HANDLER_FOUND = 6,\n+            _URC_INSTALL_CONTEXT = 7,\n+            _URC_CONTINUE_UNWIND = 8,\n+            _URC_FAILURE = 9, // used only by ARM EABI\n+        }\n+\n+        pub enum _Unwind_Context {}\n+\n+        pub type _Unwind_Trace_Fn =\n+                extern fn(ctx: *_Unwind_Context,\n+                          arg: *libc::c_void) -> _Unwind_Reason_Code;\n+\n+        extern {\n+            pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n+                                     trace_argument: *libc::c_void)\n+                        -> _Unwind_Reason_Code;\n+\n+            #[cfg(not(target_os = \"android\"),\n+                  not(target_os = \"linux\", target_arch = \"arm\"))]\n+            pub fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t;\n+            #[cfg(not(target_os = \"android\"),\n+                  not(target_os = \"linux\", target_arch = \"arm\"))]\n+            pub fn _Unwind_FindEnclosingFunction(pc: *libc::c_void)\n+                -> *libc::c_void;\n+        }\n+\n+        // On android, the function _Unwind_GetIP is a macro, and this is the\n+        // expansion of the macro. This is all copy/pasted directly from the\n+        // header file with the definition of _Unwind_GetIP.\n+        #[cfg(target_os = \"android\")]\n+        #[cfg(target_os = \"linux\", target_arch = \"arm\")]\n+        pub unsafe fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t {\n+            #[repr(C)]\n+            enum _Unwind_VRS_Result {\n+                _UVRSR_OK = 0,\n+                _UVRSR_NOT_IMPLEMENTED = 1,\n+                _UVRSR_FAILED = 2,\n+            }\n+            #[repr(C)]\n+            enum _Unwind_VRS_RegClass {\n+                _UVRSC_CORE = 0,\n+                _UVRSC_VFP = 1,\n+                _UVRSC_FPA = 2,\n+                _UVRSC_WMMXD = 3,\n+                _UVRSC_WMMXC = 4,\n+            }\n+            #[repr(C)]\n+            enum _Unwind_VRS_DataRepresentation {\n+                _UVRSD_UINT32 = 0,\n+                _UVRSD_VFPX = 1,\n+                _UVRSD_FPAX = 2,\n+                _UVRSD_UINT64 = 3,\n+                _UVRSD_FLOAT = 4,\n+                _UVRSD_DOUBLE = 5,\n+            }\n+\n+            type _Unwind_Word = libc::c_uint;\n+            extern {\n+                fn _Unwind_VRS_Get(ctx: *_Unwind_Context,\n+                                   klass: _Unwind_VRS_RegClass,\n+                                   word: _Unwind_Word,\n+                                   repr: _Unwind_VRS_DataRepresentation,\n+                                   data: *mut libc::c_void)\n+                    -> _Unwind_VRS_Result;\n+            }\n+\n+            let mut val: _Unwind_Word = 0;\n+            let ptr = &mut val as *mut _Unwind_Word;\n+            let _ = _Unwind_VRS_Get(ctx, _UVRSC_CORE, 15, _UVRSD_UINT32,\n+                                    ptr as *mut libc::c_void);\n+            (val & !1) as libc::uintptr_t\n+        }\n+\n+        // This function also doesn't exist on android or arm/linux, so make it\n+        // a no-op\n+        #[cfg(target_os = \"android\")]\n+        #[cfg(target_os = \"linux\", target_arch = \"arm\")]\n+        pub unsafe fn _Unwind_FindEnclosingFunction(pc: *libc::c_void)\n+            -> *libc::c_void\n+        {\n+            pc\n+        }\n+    }\n }\n \n /// As always, windows has something very different than unix, we mainly want"}, {"sha": "7271464d1e92f00e73e629b1607cf4445df90f8c", "filename": "src/libstd/rt/env.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a3f9aa9ef8657304006fcbe4759a263720b8592c/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f9aa9ef8657304006fcbe4759a263720b8592c/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=a3f9aa9ef8657304006fcbe4759a263720b8592c", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Runtime environment settings\n-\n-use from_str::from_str;\n-use option::{Some, None};\n-use os;\n-use str::Str;\n-\n-// Note that these are all accessed without any synchronization.\n-// They are expected to be initialized once then left alone.\n-\n-static mut MIN_STACK: uint = 2 * 1024 * 1024;\n-/// This default corresponds to 20M of cache per scheduler (at the default size).\n-static mut MAX_CACHED_STACKS: uint = 10;\n-static mut DEBUG_BORROW: bool = false;\n-\n-pub fn init() {\n-    unsafe {\n-        match os::getenv(\"RUST_MIN_STACK\") {\n-            Some(s) => match from_str(s.as_slice()) {\n-                Some(i) => MIN_STACK = i,\n-                None => ()\n-            },\n-            None => ()\n-        }\n-        match os::getenv(\"RUST_MAX_CACHED_STACKS\") {\n-            Some(max) => {\n-                MAX_CACHED_STACKS =\n-                    from_str(max.as_slice()).expect(\"expected positive \\\n-                                                     integer in \\\n-                                                     RUST_MAX_CACHED_STACKS\")\n-            }\n-            None => ()\n-        }\n-        match os::getenv(\"RUST_DEBUG_BORROW\") {\n-            Some(_) => DEBUG_BORROW = true,\n-            None => ()\n-        }\n-    }\n-}\n-\n-pub fn min_stack() -> uint {\n-    unsafe { MIN_STACK }\n-}\n-\n-pub fn max_cached_stacks() -> uint {\n-    unsafe { MAX_CACHED_STACKS }\n-}\n-\n-pub fn debug_borrow() -> bool {\n-    unsafe { DEBUG_BORROW }\n-}"}, {"sha": "e8df7465a749eee8447594159371704dada21d68", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 12, "deletions": 138, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -54,159 +54,36 @@ Several modules in `core` are clients of `rt`:\n // FIXME: this should not be here.\n #![allow(missing_doc)]\n \n-use any::Any;\n-use kinds::Send;\n-use option::Option;\n-use owned::Box;\n-use result::Result;\n-use task::TaskOpts;\n+use failure;\n+use rustrt;\n \n-use self::task::{Task, BlockedTask};\n-\n-// this is somewhat useful when a program wants to spawn a \"reasonable\" number\n-// of workers based on the constraints of the system that it's running on.\n-// Perhaps this shouldn't be a `pub use` though and there should be another\n-// method...\n-pub use self::util::default_sched_threads;\n-\n-// Export unwinding facilities used by the failure macros\n-pub use self::unwind::{begin_unwind, begin_unwind_fmt};\n-\n-pub use self::util::{Stdio, Stdout, Stderr};\n+// TODO: dox\n+pub use self::util::{default_sched_threads, min_stack, running_on_valgrind};\n \n+// TODO: dox\n pub use alloc::{heap, libc_heap};\n-\n-// Used by I/O tests\n-#[experimental]\n-pub use self::util::running_on_valgrind;\n-\n-// FIXME: these probably shouldn't be public...\n-#[doc(hidden)]\n-pub mod shouldnt_be_public {\n-    #[cfg(not(test))]\n-    pub use super::local_ptr::native::maybe_tls_key;\n-    #[cfg(not(windows), not(target_os = \"android\"))]\n-    pub use super::local_ptr::compiled::RT_TLS_PTR;\n-}\n-\n-// Internal macros used by the runtime.\n-mod macros;\n-\n-/// Implementations of language-critical runtime features like @.\n-pub mod task;\n-\n-// The EventLoop and internal synchronous I/O interface.\n-pub mod rtio;\n-\n-// The Local trait for types that are accessible via thread-local\n-// or task-local storage.\n-pub mod local;\n+pub use rustrt::{task, local, mutex, exclusive, stack, args, rtio};\n+pub use rustrt::{Stdio, Stdout, Stderr, begin_unwind, begin_unwind_fmt};\n+pub use rustrt::{bookkeeping, at_exit, unwind, DEFAULT_ERROR_CODE, Runtime};\n \n // Bindings to system threading libraries.\n pub mod thread;\n \n-// The runtime configuration, read from environment variables.\n-pub mod env;\n-\n-// The local, managed heap\n-pub mod local_heap;\n-\n-// The runtime needs to be able to put a pointer into thread-local storage.\n-mod local_ptr;\n-\n-// Bindings to pthread/windows thread-local storage.\n-mod thread_local_storage;\n-\n-// Stack unwinding\n-pub mod unwind;\n-\n-// The interface to libunwind that rust is using.\n-mod libunwind;\n-\n // Simple backtrace functionality (to print on failure)\n pub mod backtrace;\n \n // Just stuff\n mod util;\n \n-// Global command line argument storage\n-pub mod args;\n-\n-// Support for running procedures when a program has exited.\n-mod at_exit_imp;\n-\n-// Bookkeeping for task counts\n-pub mod bookkeeping;\n-\n-// Stack overflow protection\n-pub mod stack;\n-\n-/// The default error code of the rust runtime if the main task fails instead\n-/// of exiting cleanly.\n-pub static DEFAULT_ERROR_CODE: int = 101;\n-\n-/// The interface to the current runtime.\n-///\n-/// This trait is used as the abstraction between 1:1 and M:N scheduling. The\n-/// two independent crates, libnative and libgreen, both have objects which\n-/// implement this trait. The goal of this trait is to encompass all the\n-/// fundamental differences in functionality between the 1:1 and M:N runtime\n-/// modes.\n-pub trait Runtime {\n-    // Necessary scheduling functions, used for channels and blocking I/O\n-    // (sometimes).\n-    fn yield_now(~self, cur_task: Box<Task>);\n-    fn maybe_yield(~self, cur_task: Box<Task>);\n-    fn deschedule(~self, times: uint, cur_task: Box<Task>,\n-                  f: |BlockedTask| -> Result<(), BlockedTask>);\n-    fn reawaken(~self, to_wake: Box<Task>);\n-\n-    // Miscellaneous calls which are very different depending on what context\n-    // you're in.\n-    fn spawn_sibling(~self,\n-                     cur_task: Box<Task>,\n-                     opts: TaskOpts,\n-                     f: proc():Send);\n-    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;\n-    /// The (low, high) edges of the current stack.\n-    fn stack_bounds(&self) -> (uint, uint); // (lo, hi)\n-    fn can_block(&self) -> bool;\n-\n-    // FIXME: This is a serious code smell and this should not exist at all.\n-    fn wrap(~self) -> Box<Any>;\n-}\n-\n /// One-time runtime initialization.\n ///\n /// Initializes global state, including frobbing\n /// the crate's logging flags, registering GC\n /// metadata, and storing the process arguments.\n+#[allow(experimental)]\n pub fn init(argc: int, argv: **u8) {\n-    // FIXME: Derefing these pointers is not safe.\n-    // Need to propagate the unsafety to `start`.\n-    unsafe {\n-        args::init(argc, argv);\n-        env::init();\n-        local_ptr::init();\n-        at_exit_imp::init();\n-    }\n-}\n-\n-/// Enqueues a procedure to run when the runtime is cleaned up\n-///\n-/// The procedure passed to this function will be executed as part of the\n-/// runtime cleanup phase. For normal rust programs, this means that it will run\n-/// after all other tasks have exited.\n-///\n-/// The procedure is *not* executed with a local `Task` available to it, so\n-/// primitives like logging, I/O, channels, spawning, etc, are *not* available.\n-/// This is meant for \"bare bones\" usage to clean up runtime details, this is\n-/// not meant as a general-purpose \"let's clean everything up\" function.\n-///\n-/// It is forbidden for procedures to register more `at_exit` handlers when they\n-/// are running, and doing so will lead to a process abort.\n-pub fn at_exit(f: proc():Send) {\n-    at_exit_imp::push(f);\n+    rustrt::init(argc, argv);\n+    unsafe { unwind::register(failure::on_fail); }\n }\n \n /// One-time runtime cleanup.\n@@ -219,8 +96,5 @@ pub fn at_exit(f: proc():Send) {\n /// Invoking cleanup while portions of the runtime are still in use may cause\n /// undefined behavior.\n pub unsafe fn cleanup() {\n-    bookkeeping::wait_for_other_tasks();\n-    at_exit_imp::run();\n-    args::cleanup();\n-    local_ptr::cleanup();\n+    rustrt::cleanup();\n }"}, {"sha": "670d4aa2061f1e0f477c077edd2c56041e6daf33", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 30, "deletions": 118, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec36c358f74fe83332231e774ea20a21d165120/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=5ec36c358f74fe83332231e774ea20a21d165120", "patch": "@@ -8,23 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use container::Container;\n-use fmt;\n use from_str::FromStr;\n-use io::IoResult;\n-use io;\n-use iter::Iterator;\n-use libc;\n+use from_str::from_str;\n use libc::uintptr_t;\n+use libc;\n use option::{Some, None, Option};\n use os;\n-use result::Ok;\n-use str::{Str, StrSlice};\n-use slice::ImmutableVector;\n-\n-// Indicates whether we should perform expensive sanity checks, including rtassert!\n-// FIXME: Once the runtime matures remove the `true` below to turn off rtassert, etc.\n-pub static ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) || cfg!(rtassert);\n+use str::Str;\n+use sync::atomics;\n \n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n@@ -37,6 +28,17 @@ pub fn num_cpus() -> uint {\n     }\n }\n \n+/// Dynamically inquire about whether we're running under V.\n+/// You should usually not use this unless your test definitely\n+/// can't run correctly un-altered. Valgrind is there to help\n+/// you notice weirdness in normal, un-doctored code paths!\n+pub fn running_on_valgrind() -> bool {\n+    extern {\n+        fn rust_running_on_valgrind() -> uintptr_t;\n+    }\n+    unsafe { rust_running_on_valgrind() != 0 }\n+}\n+\n /// Valgrind has a fixed-sized array (size around 2000) of segment descriptors\n /// wired into it; this is a hard limit and requires rebuilding valgrind if you\n /// want to go beyond it. Normally this is not a problem, but in some tests, we\n@@ -50,6 +52,20 @@ pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {\n     (cfg!(target_os=\"macos\")) && running_on_valgrind()\n }\n \n+pub fn min_stack() -> uint {\n+    static mut MIN: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n+    match unsafe { MIN.load(atomics::SeqCst) } {\n+        0 => {}\n+        n => return n - 1,\n+    }\n+    let amt = os::getenv(\"RUST_MIN_STACK\").and_then(|s| from_str(s.as_slice()));\n+    let amt = amt.unwrap_or(2 * 1024 * 1024);\n+    // 0 is our sentinel value, so ensure that we'll never see 0 after\n+    // initialization has run\n+    unsafe { MIN.store(amt + 1, atomics::SeqCst); }\n+    return amt;\n+}\n+\n /// Get's the number of scheduler threads requested by the environment\n /// either `RUST_THREADS` or `num_cpus`.\n pub fn default_sched_threads() -> uint {\n@@ -58,7 +74,7 @@ pub fn default_sched_threads() -> uint {\n             let opt_n: Option<uint> = FromStr::from_str(nstr.as_slice());\n             match opt_n {\n                 Some(n) if n > 0 => n,\n-                _ => rtabort!(\"`RUST_THREADS` is `{}`, should be a positive integer\", nstr)\n+                _ => fail!(\"`RUST_THREADS` is `{}`, should be a positive integer\", nstr)\n             }\n         }\n         None => {\n@@ -70,107 +86,3 @@ pub fn default_sched_threads() -> uint {\n         }\n     }\n }\n-\n-pub struct Stdio(libc::c_int);\n-\n-pub static Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n-pub static Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n-\n-impl io::Writer for Stdio {\n-    fn write(&mut self, data: &[u8]) -> IoResult<()> {\n-        #[cfg(unix)]\n-        type WriteLen = libc::size_t;\n-        #[cfg(windows)]\n-        type WriteLen = libc::c_uint;\n-        unsafe {\n-            let Stdio(fd) = *self;\n-            libc::write(fd,\n-                        data.as_ptr() as *libc::c_void,\n-                        data.len() as WriteLen);\n-        }\n-        Ok(()) // yes, we're lying\n-    }\n-}\n-\n-pub fn dumb_println(args: &fmt::Arguments) {\n-    use io::Writer;\n-    let mut w = Stderr;\n-    let _ = writeln!(&mut w, \"{}\", args);\n-}\n-\n-pub fn abort(msg: &str) -> ! {\n-    let msg = if !msg.is_empty() { msg } else { \"aborted\" };\n-    let hash = msg.chars().fold(0, |accum, val| accum + (val as uint) );\n-    let quote = match hash % 10 {\n-        0 => \"\n-It was from the artists and poets that the pertinent answers came, and I\n-know that panic would have broken loose had they been able to compare notes.\n-As it was, lacking their original letters, I half suspected the compiler of\n-having asked leading questions, or of having edited the correspondence in\n-corroboration of what he had latently resolved to see.\",\n-        1 => \"\n-There are not many persons who know what wonders are opened to them in the\n-stories and visions of their youth; for when as children we listen and dream,\n-we think but half-formed thoughts, and when as men we try to remember, we are\n-dulled and prosaic with the poison of life. But some of us awake in the night\n-with strange phantasms of enchanted hills and gardens, of fountains that sing\n-in the sun, of golden cliffs overhanging murmuring seas, of plains that stretch\n-down to sleeping cities of bronze and stone, and of shadowy companies of heroes\n-that ride caparisoned white horses along the edges of thick forests; and then\n-we know that we have looked back through the ivory gates into that world of\n-wonder which was ours before we were wise and unhappy.\",\n-        2 => \"\n-Instead of the poems I had hoped for, there came only a shuddering blackness\n-and ineffable loneliness; and I saw at last a fearful truth which no one had\n-ever dared to breathe before \u2014 the unwhisperable secret of secrets \u2014 The fact\n-that this city of stone and stridor is not a sentient perpetuation of Old New\n-York as London is of Old London and Paris of Old Paris, but that it is in fact\n-quite dead, its sprawling body imperfectly embalmed and infested with queer\n-animate things which have nothing to do with it as it was in life.\",\n-        3 => \"\n-The ocean ate the last of the land and poured into the smoking gulf, thereby\n-giving up all it had ever conquered. From the new-flooded lands it flowed\n-again, uncovering death and decay; and from its ancient and immemorial bed it\n-trickled loathsomely, uncovering nighted secrets of the years when Time was\n-young and the gods unborn. Above the waves rose weedy remembered spires. The\n-moon laid pale lilies of light on dead London, and Paris stood up from its damp\n-grave to be sanctified with star-dust. Then rose spires and monoliths that were\n-weedy but not remembered; terrible spires and monoliths of lands that men never\n-knew were lands...\",\n-        4 => \"\n-There was a night when winds from unknown spaces whirled us irresistibly into\n-limitless vacuum beyond all thought and entity. Perceptions of the most\n-maddeningly untransmissible sort thronged upon us; perceptions of infinity\n-which at the time convulsed us with joy, yet which are now partly lost to my\n-memory and partly incapable of presentation to others.\",\n-        _ => \"You've met with a terrible fate, haven't you?\"\n-    };\n-    ::alloc::util::make_stdlib_link_work(); // see comments in liballoc\n-    rterrln!(\"{}\", \"\");\n-    rterrln!(\"{}\", quote);\n-    rterrln!(\"{}\", \"\");\n-    rterrln!(\"fatal runtime error: {}\", msg);\n-\n-    {\n-        let mut err = Stderr;\n-        let _err = ::rt::backtrace::write(&mut err);\n-    }\n-    abort();\n-\n-    fn abort() -> ! {\n-        use intrinsics;\n-        unsafe { intrinsics::abort() }\n-    }\n-}\n-\n-/// Dynamically inquire about whether we're running under V.\n-/// You should usually not use this unless your test definitely\n-/// can't run correctly un-altered. Valgrind is there to help\n-/// you notice weirdness in normal, un-doctored code paths!\n-pub fn running_on_valgrind() -> bool {\n-    unsafe { rust_running_on_valgrind() != 0 }\n-}\n-\n-extern {\n-    fn rust_running_on_valgrind() -> uintptr_t;\n-}"}, {"sha": "f0f7e40ce09b88ed4c5793f73f13e4af104bf4fd", "filename": "src/libstd/unstable/sync.rs", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/a3f9aa9ef8657304006fcbe4759a263720b8592c/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f9aa9ef8657304006fcbe4759a263720b8592c/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=a3f9aa9ef8657304006fcbe4759a263720b8592c", "patch": "@@ -1,159 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use alloc::arc::Arc;\n-\n-use clone::Clone;\n-use kinds::Send;\n-use ty::Unsafe;\n-use unstable::mutex::NativeMutex;\n-\n-struct ExData<T> {\n-    lock: NativeMutex,\n-    failed: bool,\n-    data: T,\n-}\n-\n-/**\n- * An arc over mutable data that is protected by a lock. For library use only.\n- *\n- * # Safety note\n- *\n- * This uses a pthread mutex, not one that's aware of the userspace scheduler.\n- * The user of an Exclusive must be careful not to invoke any functions that may\n- * reschedule the task while holding the lock, or deadlock may result. If you\n- * need to block or deschedule while accessing shared state, use extra::sync::RWArc.\n- */\n-pub struct Exclusive<T> {\n-    x: Arc<Unsafe<ExData<T>>>\n-}\n-\n-impl<T:Send> Clone for Exclusive<T> {\n-    // Duplicate an Exclusive Arc, as std::arc::clone.\n-    fn clone(&self) -> Exclusive<T> {\n-        Exclusive { x: self.x.clone() }\n-    }\n-}\n-\n-impl<T:Send> Exclusive<T> {\n-    pub fn new(user_data: T) -> Exclusive<T> {\n-        let data = ExData {\n-            lock: unsafe {NativeMutex::new()},\n-            failed: false,\n-            data: user_data\n-        };\n-        Exclusive {\n-            x: Arc::new(Unsafe::new(data))\n-        }\n-    }\n-\n-    // Exactly like sync::MutexArc.access(). Same reason for being\n-    // unsafe.\n-    //\n-    // Currently, scheduling operations (i.e., descheduling, receiving on a pipe,\n-    // accessing the provided condition variable) are prohibited while inside\n-    // the Exclusive. Supporting that is a work in progress.\n-    #[inline]\n-    pub unsafe fn with<U>(&self, f: |x: &mut T| -> U) -> U {\n-        let rec = self.x.get();\n-        let _l = (*rec).lock.lock();\n-        if (*rec).failed {\n-            fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n-        }\n-        (*rec).failed = true;\n-        let result = f(&mut (*rec).data);\n-        (*rec).failed = false;\n-        result\n-    }\n-\n-    #[inline]\n-    pub unsafe fn with_imm<U>(&self, f: |x: &T| -> U) -> U {\n-        self.with(|x| f(x))\n-    }\n-\n-    #[inline]\n-    pub unsafe fn hold_and_signal(&self, f: |x: &mut T|) {\n-        let rec = self.x.get();\n-        let guard = (*rec).lock.lock();\n-        if (*rec).failed {\n-            fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n-        }\n-        (*rec).failed = true;\n-        f(&mut (*rec).data);\n-        (*rec).failed = false;\n-        guard.signal();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn hold_and_wait(&self, f: |x: &T| -> bool) {\n-        let rec = self.x.get();\n-        let l = (*rec).lock.lock();\n-        if (*rec).failed {\n-            fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n-        }\n-        (*rec).failed = true;\n-        let result = f(&(*rec).data);\n-        (*rec).failed = false;\n-        if result {\n-            l.wait();\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use option::*;\n-    use prelude::*;\n-    use super::Exclusive;\n-    use task;\n-\n-    #[test]\n-    fn exclusive_new_arc() {\n-        unsafe {\n-            let mut futures = Vec::new();\n-\n-            let num_tasks = 10;\n-            let count = 10;\n-\n-            let total = Exclusive::new(box 0);\n-\n-            for _ in range(0u, num_tasks) {\n-                let total = total.clone();\n-                let (tx, rx) = channel();\n-                futures.push(rx);\n-\n-                task::spawn(proc() {\n-                    for _ in range(0u, count) {\n-                        total.with(|count| **count += 1);\n-                    }\n-                    tx.send(());\n-                });\n-            };\n-\n-            for f in futures.mut_iter() { f.recv() }\n-\n-            total.with(|total| assert!(**total == num_tasks * count));\n-        }\n-    }\n-\n-    #[test] #[should_fail]\n-    fn exclusive_new_poison() {\n-        unsafe {\n-            // Tests that if one task fails inside of an Exclusive::new, subsequent\n-            // accesses will also fail.\n-            let x = Exclusive::new(1);\n-            let x2 = x.clone();\n-            let _ = task::try(proc() {\n-                x2.with(|one| assert_eq!(*one, 2))\n-            });\n-            x.with(|one| assert_eq!(*one, 1));\n-        }\n-    }\n-}"}]}