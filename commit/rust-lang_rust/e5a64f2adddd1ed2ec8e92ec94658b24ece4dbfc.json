{"sha": "e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1YTY0ZjJhZGRkZDFlZDJlYzhlOTJlYzk0NjU4YjI0ZWNlNGRiZmM=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-31T19:07:45Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-01T14:54:22Z"}, "message": "std: Remove the internal iterator methods from trait Set\n\n.intersection(), .union() etc methods in trait std::container::Set use\ninternal iters. Remove these methods from the trait.\n\nI reported issue #8154 for the reinstatement of iterator-based set algebra\nmethods to the Set trait.\n\nFor bitv and treemap, that lack Iterator implementations of set\noperations, preserve them as methods directly on the types themselves.\n\nFor HashSet, these methods are replaced by the present .union_iter()\netc.", "tree": {"sha": "ea0b6a6b2377a28f127ae2e583f9b795e3cf08a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea0b6a6b2377a28f127ae2e583f9b795e3cf08a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc", "html_url": "https://github.com/rust-lang/rust/commit/e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc/comments", "author": null, "committer": null, "parents": [{"sha": "310e0b6e92e2a5c48a96a0b5c0951d77e402dd75", "url": "https://api.github.com/repos/rust-lang/rust/commits/310e0b6e92e2a5c48a96a0b5c0951d77e402dd75", "html_url": "https://github.com/rust-lang/rust/commit/310e0b6e92e2a5c48a96a0b5c0951d77e402dd75"}], "stats": {"total": 174, "additions": 71, "deletions": 103}, "files": [{"sha": "85002029fc607f2bb245f6392e939acf7eb729d9", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc", "patch": "@@ -717,6 +717,41 @@ impl BitvSet {\n     pub fn iter<'a>(&'a self) -> BitvSetIterator<'a> {\n         BitvSetIterator {set: self, next_idx: 0}\n     }\n+\n+    pub fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n+        for self.common_iter(other).advance |(i, w1, w2)| {\n+            if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n+                return false;\n+            }\n+        }\n+        /* everything we have that they don't also shows up */\n+        self.outlier_iter(other).advance(|(mine, i, w)|\n+            !mine || iterate_bits(i, w, |b| f(&b))\n+        )\n+    }\n+\n+    pub fn symmetric_difference(&self, other: &BitvSet,\n+                            f: &fn(&uint) -> bool) -> bool {\n+        for self.common_iter(other).advance |(i, w1, w2)| {\n+            if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n+                return false;\n+            }\n+        }\n+        self.outlier_iter(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n+    }\n+\n+    pub fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n+        self.common_iter(other).advance(|(i, w1, w2)| iterate_bits(i, w1 & w2, |b| f(&b)))\n+    }\n+\n+    pub fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n+        for self.common_iter(other).advance |(i, w1, w2)| {\n+            if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n+                return false;\n+            }\n+        }\n+        self.outlier_iter(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n+    }\n }\n \n impl cmp::Eq for BitvSet {\n@@ -785,41 +820,6 @@ impl Set<uint> for BitvSet {\n     fn is_superset(&self, other: &BitvSet) -> bool {\n         other.is_subset(self)\n     }\n-\n-    fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n-        for self.common_iter(other).advance |(i, w1, w2)| {\n-            if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n-                return false;\n-            }\n-        }\n-        /* everything we have that they don't also shows up */\n-        self.outlier_iter(other).advance(|(mine, i, w)|\n-            !mine || iterate_bits(i, w, |b| f(&b))\n-        )\n-    }\n-\n-    fn symmetric_difference(&self, other: &BitvSet,\n-                            f: &fn(&uint) -> bool) -> bool {\n-        for self.common_iter(other).advance |(i, w1, w2)| {\n-            if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n-                return false;\n-            }\n-        }\n-        self.outlier_iter(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n-    }\n-\n-    fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n-        self.common_iter(other).advance(|(i, w1, w2)| iterate_bits(i, w1 & w2, |b| f(&b)))\n-    }\n-\n-    fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n-        for self.common_iter(other).advance |(i, w1, w2)| {\n-            if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n-                return false;\n-            }\n-        }\n-        self.outlier_iter(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n-    }\n }\n \n impl MutableSet<uint> for BitvSet {"}, {"sha": "8a2d6cfcf49d7010a0f288a1caa2fd042cbd937e", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc", "patch": "@@ -396,9 +396,40 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n         }\n         true\n     }\n+}\n+\n+impl<T: TotalOrd> MutableSet<T> for TreeSet<T> {\n+    /// Add a value to the set. Return true if the value was not already\n+    /// present in the set.\n+    #[inline]\n+    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+\n+    /// Remove a value from the set. Return true if the value was\n+    /// present in the set.\n+    #[inline]\n+    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+}\n+\n+impl<T: TotalOrd> TreeSet<T> {\n+    /// Create an empty TreeSet\n+    #[inline]\n+    pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n+\n+    /// Get a lazy iterator over the values in the set.\n+    /// Requires that it be frozen (immutable).\n+    #[inline]\n+    pub fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n+        TreeSetIterator{iter: self.map.iter()}\n+    }\n+\n+    /// Visit all values in reverse order\n+    #[inline]\n+    pub fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n+        self.map.each_key_reverse(f)\n+    }\n \n     /// Visit the values (in-order) representing the difference\n-    fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n+    pub fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -427,7 +458,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the symmetric difference\n-    fn symmetric_difference(&self, other: &TreeSet<T>,\n+    pub fn symmetric_difference(&self, other: &TreeSet<T>,\n                             f: &fn(&T) -> bool) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -461,7 +492,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the intersection\n-    fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n+    pub fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -487,7 +518,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the union\n-    fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n+    pub fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -519,37 +550,6 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n }\n \n-impl<T: TotalOrd> MutableSet<T> for TreeSet<T> {\n-    /// Add a value to the set. Return true if the value was not already\n-    /// present in the set.\n-    #[inline]\n-    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n-\n-    /// Remove a value from the set. Return true if the value was\n-    /// present in the set.\n-    #[inline]\n-    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n-}\n-\n-impl<T: TotalOrd> TreeSet<T> {\n-    /// Create an empty TreeSet\n-    #[inline]\n-    pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n-\n-    /// Get a lazy iterator over the values in the set.\n-    /// Requires that it be frozen (immutable).\n-    #[inline]\n-    pub fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n-        TreeSetIterator{iter: self.map.iter()}\n-    }\n-\n-    /// Visit all values in reverse order\n-    #[inline]\n-    pub fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n-        self.map.each_key_reverse(f)\n-    }\n-}\n-\n /// Lazy forward iterator over a set\n pub struct TreeSetIterator<'self, T> {\n     priv iter: TreeMapIterator<'self, T, ()>"}, {"sha": "10f3fc6586f58329bf56d86b9de99c646b67036c", "filename": "src/libstd/container.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc/src%2Flibstd%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc/src%2Flibstd%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcontainer.rs?ref=e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc", "patch": "@@ -87,17 +87,7 @@ pub trait Set<T>: Container {\n     /// Return true if the set is a superset of another\n     fn is_superset(&self, other: &Self) -> bool;\n \n-    /// Visit the values representing the difference\n-    fn difference(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n-\n-    /// Visit the values representing the symmetric difference\n-    fn symmetric_difference(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n-\n-    /// Visit the values representing the intersection\n-    fn intersection(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n-\n-    /// Visit the values representing the union\n-    fn union(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n+    // FIXME #8154: Add difference, sym. difference, intersection and union iterators\n }\n \n /// This trait represents actions which can be performed on sets to mutate"}, {"sha": "ca61f3e5ad80584bd4f4f6abd1e50f34bae16fe7", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=e5a64f2adddd1ed2ec8e92ec94658b24ece4dbfc", "patch": "@@ -672,28 +672,6 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n     fn is_superset(&self, other: &HashSet<T>) -> bool {\n         other.is_subset(self)\n     }\n-\n-    /// Visit the values representing the difference\n-    fn difference(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n-        self.difference_iter(other).advance(f)\n-    }\n-\n-    /// Visit the values representing the symmetric difference\n-    fn symmetric_difference(&self,\n-                            other: &HashSet<T>,\n-                            f: &fn(&T) -> bool) -> bool {\n-        self.symmetric_difference_iter(other).advance(f)\n-    }\n-\n-    /// Visit the values representing the intersection\n-    fn intersection(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n-        self.intersection_iter(other).advance(f)\n-    }\n-\n-    /// Visit the values representing the union\n-    fn union(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n-        self.union_iter(other).advance(f)\n-    }\n }\n \n impl<T:Hash + Eq> MutableSet<T> for HashSet<T> {"}]}