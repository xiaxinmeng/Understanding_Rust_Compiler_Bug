{"sha": "0d7e9933d3cac85bc1f11dc0fec67fcad77784ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkN2U5OTMzZDNjYWM4NWJjMWYxMWRjMGZlYzY3ZmNhZDc3Nzg0Y2E=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-06-18T20:08:20Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-07-13T01:53:36Z"}, "message": "Change RangeInclusive to a three-field struct.\n\nFix #45222.", "tree": {"sha": "1c0488fda11d56a39db22edb943b7e8e536d0b7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c0488fda11d56a39db22edb943b7e8e536d0b7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d7e9933d3cac85bc1f11dc0fec67fcad77784ca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAltIBiAACgkQ/vbIBR0O\nATzenA/8Cnuw2qhc7nQmrg1mqNcVPmDbRhLJHm5+ee6DQS9LLYewEq1a+Bu52DmZ\nkNpic4fBWjzIpMjczhE5f1PAtE9fOWmcO6DjojHMie7ZNCwpjiQPDpI9095CPgYq\npa/fwC0Mp8daTaz5tfv5eZN4GrMjMrRTOIk21BYlNdlWs4LwzHUmbR+1PeGMxseI\neXvxYwK4n9eWImf7St76I9y9wvhFhuGVa3fvIRkh0hwUWwEqMjZg7z5br5k7KL+r\nK0dYXvTNFUfbsjp3elDQRQWKdSkzYoxr0Uk/zVaU3bXEiPRfvZQ7LQhgpoZaj446\n9uTUx9PLnqmspzYPLJYnjQchXe3MgIXtffSJ2kVvGrwmDM+322oOZas1tetN+4xR\nLaJopf+a9drzqnZ0OhqT8Gbjp68KDXWEE+gGzQ0+KaDDjFxvwfoez5z+JuxBNRTM\n9sT1XcmFjvpPXHbsLEz69KN5R0ztFK2j3Lknf78pXEbzlOm7vv1Nx+YAYhdZ0n0T\nscTWc1rXyF5QfMzHB9oUX8iyBry9oNJG8tLZA43Ron1Cdb2t9REwiYaROX1r4/rg\ngZPup8uZA0eYTFGanbxzZ4iS46FmWhMps7E7KnPKvXS6MOiQohfpS6muHsmmQJMS\nW0/YSC//Ln9QHHerePjnC4oNvhNPDj/H/LMl+wdfhN4nib0haU0=\n=l1Gc\n-----END PGP SIGNATURE-----", "payload": "tree 1c0488fda11d56a39db22edb943b7e8e536d0b7d\nparent 7db82ccd765cbfe55c3d8a2c434bc6f9b986843d\nauthor kennytm <kennytm@gmail.com> 1529352500 +0800\ncommitter kennytm <kennytm@gmail.com> 1531446816 +0800\n\nChange RangeInclusive to a three-field struct.\n\nFix #45222.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d7e9933d3cac85bc1f11dc0fec67fcad77784ca", "html_url": "https://github.com/rust-lang/rust/commit/0d7e9933d3cac85bc1f11dc0fec67fcad77784ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d7e9933d3cac85bc1f11dc0fec67fcad77784ca/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7db82ccd765cbfe55c3d8a2c434bc6f9b986843d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7db82ccd765cbfe55c3d8a2c434bc6f9b986843d", "html_url": "https://github.com/rust-lang/rust/commit/7db82ccd765cbfe55c3d8a2c434bc6f9b986843d"}], "stats": {"total": 252, "additions": 155, "deletions": 97}, "files": [{"sha": "16849e84f275419a48eb661083149188497fc083", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 30, "deletions": 70, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/0d7e9933d3cac85bc1f11dc0fec67fcad77784ca/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7e9933d3cac85bc1f11dc0fec67fcad77784ca/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=0d7e9933d3cac85bc1f11dc0fec67fcad77784ca", "patch": "@@ -10,7 +10,7 @@\n \n use convert::TryFrom;\n use mem;\n-use ops::{self, Add, Sub, Try};\n+use ops::{self, Add, Sub};\n use usize;\n \n use super::{FusedIterator, TrustedLen};\n@@ -330,23 +330,23 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        if self.start <= self.end {\n-            if self.start < self.end {\n-                let n = self.start.add_one();\n-                Some(mem::replace(&mut self.start, n))\n-            } else {\n-                let last = self.start.replace_one();\n-                self.end.replace_zero();\n-                Some(last)\n-            }\n+        if self.is_empty() {\n+            self.is_iterating = Some(false);\n+            return None;\n+        }\n+        if self.start < self.end {\n+            let n = self.start.add_one();\n+            self.is_iterating = Some(true);\n+            Some(mem::replace(&mut self.start, n))\n         } else {\n-            None\n+            self.is_iterating = Some(false);\n+            Some(self.start.clone())\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if !(self.start <= self.end) {\n+        if self.is_empty() {\n             return (0, Some(0));\n         }\n \n@@ -358,25 +358,29 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<A> {\n+        if self.is_empty() {\n+            self.is_iterating = Some(false);\n+            return None;\n+        }\n+\n         if let Some(plus_n) = self.start.add_usize(n) {\n             use cmp::Ordering::*;\n \n             match plus_n.partial_cmp(&self.end) {\n                 Some(Less) => {\n+                    self.is_iterating = Some(true);\n                     self.start = plus_n.add_one();\n                     return Some(plus_n)\n                 }\n                 Some(Equal) => {\n-                    self.start.replace_one();\n-                    self.end.replace_zero();\n+                    self.is_iterating = Some(false);\n                     return Some(plus_n)\n                 }\n                 _ => {}\n             }\n         }\n \n-        self.start.replace_one();\n-        self.end.replace_zero();\n+        self.is_iterating = Some(false);\n         None\n     }\n \n@@ -394,68 +398,24 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n     fn max(mut self) -> Option<A> {\n         self.next_back()\n     }\n-\n-    #[inline]\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        let mut accum = init;\n-        if self.start <= self.end {\n-            loop {\n-                let (x, done) =\n-                    if self.start < self.end {\n-                        let n = self.start.add_one();\n-                        (mem::replace(&mut self.start, n), false)\n-                    } else {\n-                        self.end.replace_zero();\n-                        (self.start.replace_one(), true)\n-                    };\n-                accum = f(accum, x)?;\n-                if done { break }\n-            }\n-        }\n-        Try::from_ok(accum)\n-    }\n }\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n-        if self.start <= self.end {\n-            if self.start < self.end {\n-                let n = self.end.sub_one();\n-                Some(mem::replace(&mut self.end, n))\n-            } else {\n-                let last = self.end.replace_zero();\n-                self.start.replace_one();\n-                Some(last)\n-            }\n-        } else {\n-            None\n+        if self.is_empty() {\n+            self.is_iterating = Some(false);\n+            return None;\n         }\n-    }\n-\n-    #[inline]\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-    {\n-        let mut accum = init;\n-        if self.start <= self.end {\n-            loop {\n-                let (x, done) =\n-                    if self.start < self.end {\n-                        let n = self.end.sub_one();\n-                        (mem::replace(&mut self.end, n), false)\n-                    } else {\n-                        self.start.replace_one();\n-                        (self.end.replace_zero(), true)\n-                    };\n-                accum = f(accum, x)?;\n-                if done { break }\n-            }\n+        if self.start < self.end {\n+            let n = self.end.sub_one();\n+            self.is_iterating = Some(true);\n+            Some(mem::replace(&mut self.end, n))\n+        } else {\n+            self.is_iterating = Some(false);\n+            Some(self.end.clone())\n         }\n-        Try::from_ok(accum)\n     }\n }\n "}, {"sha": "3f9ac8a54bf2f1649e8250cea1b96887c2f965c1", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0d7e9933d3cac85bc1f11dc0fec67fcad77784ca/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7e9933d3cac85bc1f11dc0fec67fcad77784ca/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=0d7e9933d3cac85bc1f11dc0fec67fcad77784ca", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use fmt;\n+use hash::{Hash, Hasher};\n \n /// An unbounded range (`..`).\n ///\n@@ -326,15 +327,37 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// assert_eq!(arr[1..=2], [  1,2  ]);  // RangeInclusive\n /// ```\n #[doc(alias = \"..=\")]\n-#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[derive(Clone)]  // not Copy -- see #27186\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub struct RangeInclusive<Idx> {\n-    // FIXME: The current representation follows RFC 1980,\n-    // but it is known that LLVM is not able to optimize loops following that RFC.\n-    // Consider adding an extra `bool` field to indicate emptiness of the range.\n-    // See #45222 for performance test cases.\n     pub(crate) start: Idx,\n     pub(crate) end: Idx,\n+    pub(crate) is_iterating: Option<bool>,\n+    // This field is:\n+    //  - `None` when next() or next_back() was never called\n+    //  - `Some(true)` when `start <= end` assuming no overflow\n+    //  - `Some(false)` otherwise\n+    // The field cannot be a simple `bool` because the `..=` constructor can\n+    // accept non-PartialOrd types, also we want the constructor to be const.\n+}\n+\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+impl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.start == other.start && self.end == other.end\n+    }\n+}\n+\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+impl<Idx: Eq> Eq for RangeInclusive<Idx> {}\n+\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+impl<Idx: Hash> Hash for RangeInclusive<Idx> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.start.hash(state);\n+        self.end.hash(state);\n+    }\n }\n \n impl<Idx> RangeInclusive<Idx> {\n@@ -350,7 +373,7 @@ impl<Idx> RangeInclusive<Idx> {\n     #[stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")]\n     #[inline]\n     pub const fn new(start: Idx, end: Idx) -> Self {\n-        Self { start, end }\n+        Self { start, end, is_iterating: None }\n     }\n \n     /// Returns the lower bound of the range (inclusive).\n@@ -492,8 +515,9 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(r.is_empty());\n     /// ```\n     #[unstable(feature = \"range_is_empty\", reason = \"recently added\", issue = \"48111\")]\n+    #[inline]\n     pub fn is_empty(&self) -> bool {\n-        !(self.start <= self.end)\n+        !self.is_iterating.unwrap_or_else(|| self.start <= self.end)\n     }\n }\n "}, {"sha": "e6db4cb38ec23ba2486774c3e89dd99d0f6e7c9a", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0d7e9933d3cac85bc1f11dc0fec67fcad77784ca/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7e9933d3cac85bc1f11dc0fec67fcad77784ca/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=0d7e9933d3cac85bc1f11dc0fec67fcad77784ca", "patch": "@@ -2262,36 +2262,36 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n-        if self.end == usize::max_value() { None }\n-        else { (self.start..self.end + 1).get(slice) }\n+        if *self.end() == usize::max_value() { None }\n+        else { (*self.start()..self.end() + 1).get(slice) }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        if self.end == usize::max_value() { None }\n-        else { (self.start..self.end + 1).get_mut(slice) }\n+        if *self.end() == usize::max_value() { None }\n+        else { (*self.start()..self.end() + 1).get_mut(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (self.start..self.end + 1).get_unchecked(slice)\n+        (*self.start()..self.end() + 1).get_unchecked(slice)\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (self.start..self.end + 1).get_unchecked_mut(slice)\n+        (*self.start()..self.end() + 1).get_unchecked_mut(slice)\n     }\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n-        if self.end == usize::max_value() { slice_index_overflow_fail(); }\n-        (self.start..self.end + 1).index(slice)\n+        if *self.end() == usize::max_value() { slice_index_overflow_fail(); }\n+        (*self.start()..self.end() + 1).index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        if self.end == usize::max_value() { slice_index_overflow_fail(); }\n-        (self.start..self.end + 1).index_mut(slice)\n+        if *self.end() == usize::max_value() { slice_index_overflow_fail(); }\n+        (*self.start()..self.end() + 1).index_mut(slice)\n     }\n }\n "}, {"sha": "255e8a07d75492dc96aee5535f7b6f48e56ac2a7", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0d7e9933d3cac85bc1f11dc0fec67fcad77784ca/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7e9933d3cac85bc1f11dc0fec67fcad77784ca/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=0d7e9933d3cac85bc1f11dc0fec67fcad77784ca", "patch": "@@ -2004,31 +2004,31 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if self.end == usize::max_value() { None }\n-            else { (self.start..self.end+1).get(slice) }\n+            if *self.end() == usize::max_value() { None }\n+            else { (*self.start()..self.end()+1).get(slice) }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if self.end == usize::max_value() { None }\n-            else { (self.start..self.end+1).get_mut(slice) }\n+            if *self.end() == usize::max_value() { None }\n+            else { (*self.start()..self.end()+1).get_mut(slice) }\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            (self.start..self.end+1).get_unchecked(slice)\n+            (*self.start()..self.end()+1).get_unchecked(slice)\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            (self.start..self.end+1).get_unchecked_mut(slice)\n+            (*self.start()..self.end()+1).get_unchecked_mut(slice)\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n-            if self.end == usize::max_value() { str_index_overflow_fail(); }\n-            (self.start..self.end+1).index(slice)\n+            if *self.end() == usize::max_value() { str_index_overflow_fail(); }\n+            (*self.start()..self.end()+1).index(slice)\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            if self.end == usize::max_value() { str_index_overflow_fail(); }\n-            (self.start..self.end+1).index_mut(slice)\n+            if *self.end() == usize::max_value() { str_index_overflow_fail(); }\n+            (*self.start()..self.end()+1).index_mut(slice)\n         }\n     }\n "}, {"sha": "30a03243f0151efe68e91fb33a70ca69968285d6", "filename": "src/test/codegen/issue-45222.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0d7e9933d3cac85bc1f11dc0fec67fcad77784ca/src%2Ftest%2Fcodegen%2Fissue-45222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7e9933d3cac85bc1f11dc0fec67fcad77784ca/src%2Ftest%2Fcodegen%2Fissue-45222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-45222.rs?ref=0d7e9933d3cac85bc1f11dc0fec67fcad77784ca", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -O\n+// min-llvm-version 6.0\n+\n+#![crate_type = \"lib\"]\n+\n+// verify that LLVM recognizes a loop involving 0..=n and will const-fold it.\n+\n+//------------------------------------------------------------------------------\n+// Example from original issue #45222\n+\n+fn foo2(n: u64) -> u64 {\n+    let mut count = 0;\n+    for _ in 0..n {\n+        for j in (0..=n).rev() {\n+            count += j;\n+        }\n+    }\n+    count\n+}\n+\n+// CHECK-LABEL: @check_foo2\n+#[no_mangle]\n+pub fn check_foo2() -> u64 {\n+    // CHECK: ret i64 500005000000000\n+    foo2(100000)\n+}\n+\n+//------------------------------------------------------------------------------\n+// Simplified example of #45222\n+\n+fn triangle_inc(n: u64) -> u64 {\n+    let mut count = 0;\n+    for j in 0 ..= n {\n+        count += j;\n+    }\n+    count\n+}\n+\n+// CHECK-LABEL: @check_triangle_inc\n+#[no_mangle]\n+pub fn check_triangle_inc() -> u64 {\n+    // CHECK: ret i64 5000050000\n+    triangle_inc(100000)\n+}\n+\n+//------------------------------------------------------------------------------\n+// Demo in #48012\n+\n+fn foo3r(n: u64) -> u64 {\n+    let mut count = 0;\n+    (0..n).for_each(|_| {\n+        (0 ..= n).rev().for_each(|j| {\n+            count += j;\n+        })\n+    });\n+    count\n+}\n+\n+// CHECK-LABEL: @check_foo3r\n+#[no_mangle]\n+pub fn check_foo3r() -> u64 {\n+    // CHECK: ret i64 500005000000000\n+    foo3r(100000)\n+}"}]}