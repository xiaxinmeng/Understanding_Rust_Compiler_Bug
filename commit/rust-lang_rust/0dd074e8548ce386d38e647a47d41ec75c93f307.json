{"sha": "0dd074e8548ce386d38e647a47d41ec75c93f307", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkZDA3NGU4NTQ4Y2UzODZkMzhlNjQ3YTQ3ZDQxZWM3NWM5M2YzMDc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-24T19:34:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-07-02T16:25:23Z"}, "message": "more centril nits", "tree": {"sha": "ca6f87a2350abe7c8dcf15fbace9b27b430d47e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca6f87a2350abe7c8dcf15fbace9b27b430d47e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dd074e8548ce386d38e647a47d41ec75c93f307", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dd074e8548ce386d38e647a47d41ec75c93f307", "html_url": "https://github.com/rust-lang/rust/commit/0dd074e8548ce386d38e647a47d41ec75c93f307", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dd074e8548ce386d38e647a47d41ec75c93f307/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9f4d2ad1a6af13390f99a8e8bf153e77f40bc12", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9f4d2ad1a6af13390f99a8e8bf153e77f40bc12", "html_url": "https://github.com/rust-lang/rust/commit/d9f4d2ad1a6af13390f99a8e8bf153e77f40bc12"}], "stats": {"total": 69, "additions": 39, "deletions": 30}, "files": [{"sha": "6fb1bb42d2cfd396b7c75a3c5110aef71d86ddc6", "filename": "src/librustc_data_structures/graph/vec_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd074e8548ce386d38e647a47d41ec75c93f307/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd074e8548ce386d38e647a47d41ec75c93f307/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs?ref=0dd074e8548ce386d38e647a47d41ec75c93f307", "patch": "@@ -27,7 +27,7 @@ impl<N: Idx> VecGraph<N> {\n \n         let num_edges = edge_pairs.len();\n \n-        // Store the *target* of each edge into `edge_targets`\n+        // Store the *target* of each edge into `edge_targets`.\n         let edge_targets: Vec<N> = edge_pairs.iter().map(|&(_, target)| target).collect();\n \n         // Create the *edge starts* array. We are iterating over over"}, {"sha": "b5e2e111f38e518828a10d30581ed9badf3adef3", "filename": "src/librustc_mir/borrow_check/nll/member_constraints.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0dd074e8548ce386d38e647a47d41ec75c93f307/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd074e8548ce386d38e647a47d41ec75c93f307/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs?ref=0dd074e8548ce386d38e647a47d41ec75c93f307", "patch": "@@ -8,18 +8,18 @@ use std::ops::Index;\n use syntax_pos::Span;\n \n /// Compactly stores a set of `R0 member of [R1...Rn]` constraints,\n-/// indexed by the region R0.\n+/// indexed by the region `R0`.\n crate struct MemberConstraintSet<'tcx, R>\n where\n     R: Copy + Hash + Eq,\n {\n-    /// Stores the first \"member\" constraint for a given R0. This is an\n+    /// Stores the first \"member\" constraint for a given `R0`. This is an\n     /// index into the `constraints` vector below.\n     first_constraints: FxHashMap<R, NllMemberConstraintIndex>,\n \n     /// Stores the data about each `R0 member of [R1..Rn]` constraint.\n     /// These are organized into a linked list, so each constraint\n-    /// contains the index of the next constraint with the same R0.\n+    /// contains the index of the next constraint with the same `R0`.\n     constraints: IndexVec<NllMemberConstraintIndex, NllMemberConstraint<'tcx>>,\n \n     /// Stores the `R1..Rn` regions for *all* sets. For any given\n@@ -38,10 +38,10 @@ crate struct NllMemberConstraint<'tcx> {\n     /// The span where the hidden type was instantiated.\n     crate definition_span: Span,\n \n-    /// The hidden type in which R0 appears. (Used in error reporting.)\n+    /// The hidden type in which `R0` appears. (Used in error reporting.)\n     crate hidden_ty: Ty<'tcx>,\n \n-    /// The region R0.\n+    /// The region `R0`.\n     crate member_region_vid: ty::RegionVid,\n \n     /// Index of `R1` in `choice_regions` vector from `MemberConstraintSet`.\n@@ -68,6 +68,15 @@ impl Default for MemberConstraintSet<'tcx, ty::RegionVid> {\n }\n \n impl<'tcx> MemberConstraintSet<'tcx, ty::RegionVid> {\n+    /// Pushes a member constraint into the set.\n+    ///\n+    /// The input member constraint `m_c` is in the form produced by\n+    /// the the `rustc::infer` code.\n+    ///\n+    /// The `to_region_vid` callback fn is used to convert the regions\n+    /// within into `RegionVid` format -- it typically consults the\n+    /// `UniversalRegions` data structure that is known to the caller\n+    /// (but which this code is unaware of).\n     crate fn push_constraint(\n         &mut self,\n         m_c: &MemberConstraint<'tcx>,\n@@ -93,14 +102,14 @@ impl<'tcx> MemberConstraintSet<'tcx, ty::RegionVid> {\n     }\n }\n \n-impl<'tcx, R1> MemberConstraintSet<'tcx, R1>\n+impl<R1> MemberConstraintSet<'tcx, R1>\n where\n     R1: Copy + Hash + Eq,\n {\n     /// Remap the \"member region\" key using `map_fn`, producing a new\n-    /// pick-constraint set.  This is used in the NLL code to map from\n+    /// member constraint set.  This is used in the NLL code to map from\n     /// the original `RegionVid` to an scc index. In some cases, we\n-    /// may have multiple R1 values mapping to the same R2 key -- that\n+    /// may have multiple `R1` values mapping to the same `R2` key -- that\n     /// is ok, the two sets will be merged.\n     crate fn into_mapped<R2>(\n         self,\n@@ -112,12 +121,12 @@ where\n         // We can re-use most of the original data, just tweaking the\n         // linked list links a bit.\n         //\n-        // For example if we had two keys Ra and Rb that both now wind\n-        // up mapped to the same key S, we would append the linked\n-        // list for Ra onto the end of the linked list for Rb (or vice\n-        // versa) -- this basically just requires rewriting the final\n-        // link from one list to point at the othe other (see\n-        // `append_list`).\n+        // For example if we had two keys `Ra` and `Rb` that both now\n+        // wind up mapped to the same key `S`, we would append the\n+        // linked list for `Ra` onto the end of the linked list for\n+        // `Rb` (or vice versa) -- this basically just requires\n+        // rewriting the final link from one list to point at the othe\n+        // other (see `append_list`).\n \n         let MemberConstraintSet { first_constraints, mut constraints, choice_regions } = self;\n \n@@ -140,7 +149,7 @@ where\n     }\n }\n \n-impl<'tcx, R> MemberConstraintSet<'tcx, R>\n+impl<R> MemberConstraintSet<'tcx, R>\n where\n     R: Copy + Hash + Eq,\n {\n@@ -169,7 +178,7 @@ where\n     }\n \n     /// Returns the \"choice regions\" for a given member\n-    /// constraint. This is the R1..Rn from a constraint like:\n+    /// constraint. This is the `R1..Rn` from a constraint like:\n     ///\n     /// ```\n     /// R0 member of [R1..Rn]"}, {"sha": "9e08961f440f2ab42ae1c05eac54047e31c53228", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dd074e8548ce386d38e647a47d41ec75c93f307/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd074e8548ce386d38e647a47d41ec75c93f307/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=0dd074e8548ce386d38e647a47d41ec75c93f307", "patch": "@@ -221,7 +221,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .outgoing_edges(r, &self.constraints, fr_static);\n \n \n-            // But pick-constraints can also give rise to `'r: 'x`\n+            // But member constraints can also give rise to `'r: 'x`\n             // edges that were not part of the graph initially, so\n             // watch out for those.\n             let outgoing_edges_from_picks = self.applied_member_constraints(r)"}, {"sha": "7e83ea2aa4ed98ee7097fee4ebb9900dd7498ad0", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0dd074e8548ce386d38e647a47d41ec75c93f307/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd074e8548ce386d38e647a47d41ec75c93f307/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=0dd074e8548ce386d38e647a47d41ec75c93f307", "patch": "@@ -75,7 +75,7 @@ pub struct RegionInferenceContext<'tcx> {\n     /// The \"R0 member of [R1..Rn]\" constraints, indexed by SCC.\n     member_constraints: Rc<MemberConstraintSet<'tcx, ConstraintSccIndex>>,\n \n-    /// Records the pick-constraints that we applied to each scc.\n+    /// Records the member constraints that we applied to each scc.\n     /// This is useful for error reporting. Once constraint\n     /// propagation is done, this vector is sorted according to\n     /// `member_region_scc`.\n@@ -447,7 +447,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Once region solving has completed, this function will return\n-    /// the pick-constraints that were applied to the value of a given\n+    /// the member constraints that were applied to the value of a given\n     /// region `r`. See `AppliedMemberConstraint`.\n     fn applied_member_constraints(&self, r: impl ToRegionVid) -> &[AppliedMemberConstraint] {\n         let scc = self.constraint_sccs.scc(r.to_region_vid());\n@@ -598,7 +598,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        // Now take member constraints into account\n+        // Now take member constraints into account. \n         let member_constraints = self.member_constraints.clone();\n         for m_c_i in member_constraints.indices(scc_a) {\n             self.apply_member_constraint(\n@@ -615,7 +615,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n     }\n \n-    /// Invoked for each `member R0 of [R1..Rn]` constraint.\n+    /// Invoked for each `R0 member of [R1..Rn]` constraint.\n     ///\n     /// `scc` is the SCC containing R0, and `choice_regions` are the\n     /// `R1..Rn` regions -- they are always known to be universal\n@@ -659,16 +659,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         assert!(self.scc_universes[scc] == ty::UniverseIndex::ROOT);\n         debug_assert!(\n             self.scc_values.placeholders_contained_in(scc).next().is_none(),\n-            \"scc {:?} in a pick-constraint has placeholder value: {:?}\",\n+            \"scc {:?} in a member constraint has placeholder value: {:?}\",\n             scc,\n             self.scc_values.region_value_str(scc),\n         );\n \n         // The existing value for `scc` is a lower-bound. This will\n-        // consist of some set {P} + {LB} of points {P} and\n-        // lower-bound free regions {LB}. As each choice region O is a\n-        // free region, it will outlive the points. But we can only\n-        // consider the option O if O: LB.\n+        // consist of some set `{P} + {LB}` of points `{P}` and\n+        // lower-bound free regions `{LB}`. As each choice region `O`\n+        // is a free region, it will outlive the points. But we can\n+        // only consider the option `O` if `O: LB`.\n         choice_regions.retain(|&o_r| {\n             self.scc_values\n                 .universal_regions_outlived_by(scc)\n@@ -677,8 +677,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"apply_member_constraint: after lb, choice_regions={:?}\", choice_regions);\n \n         // Now find all the *upper bounds* -- that is, each UB is a\n-        // free region that must outlive the member region R0 (`UB:\n-        // R0`). Therefore, we need only keep an option O if `UB: O`\n+        // free region that must outlive the member region `R0` (`UB:\n+        // R0`). Therefore, we need only keep an option `O` if `UB: O`\n         // for all UB.\n         if choice_regions.len() > 1 {\n             let universal_region_relations = self.universal_region_relations.clone();\n@@ -755,7 +755,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // I wanted to return an `impl Iterator` here, but it's\n         // annoying because the `rev_constraint_graph` is in a local\n         // variable. We'd need a \"once-cell\" or some such thing to let\n-        // us borrow it for the right amount of time.\n+        // us borrow it for the right amount of time. -- nikomatsakis\n         let rev_constraint_graph = self.rev_constraint_graph();\n         let scc_values = &self.scc_values;\n         let mut duplicates = FxHashSet::default();"}]}