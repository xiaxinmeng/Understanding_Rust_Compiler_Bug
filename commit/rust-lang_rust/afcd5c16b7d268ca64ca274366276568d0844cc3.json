{"sha": "afcd5c16b7d268ca64ca274366276568d0844cc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmY2Q1YzE2YjdkMjY4Y2E2NGNhMjc0MzY2Mjc2NTY4ZDA4NDRjYzM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-29T09:59:15Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-30T10:45:57Z"}, "message": "Move region_scope_tree query to librustc_passes.", "tree": {"sha": "93ff87305e9bee3b505f8de5a63b7ada5908b89e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93ff87305e9bee3b505f8de5a63b7ada5908b89e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afcd5c16b7d268ca64ca274366276568d0844cc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afcd5c16b7d268ca64ca274366276568d0844cc3", "html_url": "https://github.com/rust-lang/rust/commit/afcd5c16b7d268ca64ca274366276568d0844cc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afcd5c16b7d268ca64ca274366276568d0844cc3/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca5a10f53e0b0b6be42861ac057f03f9f9d27fc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca5a10f53e0b0b6be42861ac057f03f9f9d27fc4", "html_url": "https://github.com/rust-lang/rust/commit/ca5a10f53e0b0b6be42861ac057f03f9f9d27fc4"}], "stats": {"total": 1402, "additions": 683, "deletions": 719}, "files": [{"sha": "7f9c4aec3e37e96bab37b3d288ecebb59d4dcce4", "filename": "src/librustc/middle/region.rs", "status": "added", "additions": 670, "deletions": 0, "changes": 670, "blob_url": "https://github.com/rust-lang/rust/blob/afcd5c16b7d268ca64ca274366276568d0844cc3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afcd5c16b7d268ca64ca274366276568d0844cc3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=afcd5c16b7d268ca64ca274366276568d0844cc3", "patch": "@@ -0,0 +1,670 @@\n+//! This file builds up the `ScopeTree`, which describes\n+//! the parent links in the region hierarchy.\n+//!\n+//! For more information about how MIR-based region-checking works,\n+//! see the [rustc guide].\n+//!\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n+\n+use crate::hir;\n+use crate::hir::def_id::DefId;\n+use crate::hir::Node;\n+use crate::ich::{NodeIdHashingMode, StableHashingContext};\n+use crate::ty::{self, DefIdTree, TyCtxt};\n+use crate::util::nodemap::FxHashMap;\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_index::vec::Idx;\n+use rustc_macros::HashStable;\n+use syntax_pos::{Span, DUMMY_SP};\n+\n+use std::fmt;\n+\n+/// Represents a statically-describable scope that can be used to\n+/// bound the lifetime/region for values.\n+///\n+/// `Node(node_id)`: Any AST node that has any scope at all has the\n+/// `Node(node_id)` scope. Other variants represent special cases not\n+/// immediately derivable from the abstract syntax tree structure.\n+///\n+/// `DestructionScope(node_id)` represents the scope of destructors\n+/// implicitly-attached to `node_id` that run immediately after the\n+/// expression for `node_id` itself. Not every AST node carries a\n+/// `DestructionScope`, but those that are `terminating_scopes` do;\n+/// see discussion with `ScopeTree`.\n+///\n+/// `Remainder { block, statement_index }` represents\n+/// the scope of user code running immediately after the initializer\n+/// expression for the indexed statement, until the end of the block.\n+///\n+/// So: the following code can be broken down into the scopes beneath:\n+///\n+/// ```text\n+/// let a = f().g( 'b: { let x = d(); let y = d(); x.h(y)  }   ) ;\n+///\n+///                                                              +-+ (D12.)\n+///                                                        +-+       (D11.)\n+///                                              +---------+         (R10.)\n+///                                              +-+                  (D9.)\n+///                                   +----------+                    (M8.)\n+///                                 +----------------------+          (R7.)\n+///                                 +-+                               (D6.)\n+///                      +----------+                                 (M5.)\n+///                    +-----------------------------------+          (M4.)\n+///         +--------------------------------------------------+      (M3.)\n+///         +--+                                                      (M2.)\n+/// +-----------------------------------------------------------+     (M1.)\n+///\n+///  (M1.): Node scope of the whole `let a = ...;` statement.\n+///  (M2.): Node scope of the `f()` expression.\n+///  (M3.): Node scope of the `f().g(..)` expression.\n+///  (M4.): Node scope of the block labeled `'b:`.\n+///  (M5.): Node scope of the `let x = d();` statement\n+///  (D6.): DestructionScope for temporaries created during M5.\n+///  (R7.): Remainder scope for block `'b:`, stmt 0 (let x = ...).\n+///  (M8.): Node scope of the `let y = d();` statement.\n+///  (D9.): DestructionScope for temporaries created during M8.\n+/// (R10.): Remainder scope for block `'b:`, stmt 1 (let y = ...).\n+/// (D11.): DestructionScope for temporaries and bindings from block `'b:`.\n+/// (D12.): DestructionScope for temporaries created during M1 (e.g., f()).\n+/// ```\n+///\n+/// Note that while the above picture shows the destruction scopes\n+/// as following their corresponding node scopes, in the internal\n+/// data structures of the compiler the destruction scopes are\n+/// represented as enclosing parents. This is sound because we use the\n+/// enclosing parent relationship just to ensure that referenced\n+/// values live long enough; phrased another way, the starting point\n+/// of each range is not really the important thing in the above\n+/// picture, but rather the ending point.\n+//\n+// FIXME(pnkfelix): this currently derives `PartialOrd` and `Ord` to\n+// placate the same deriving in `ty::FreeRegion`, but we may want to\n+// actually attach a more meaningful ordering to scopes than the one\n+// generated via deriving here.\n+#[derive(\n+    Clone,\n+    PartialEq,\n+    PartialOrd,\n+    Eq,\n+    Ord,\n+    Hash,\n+    Copy,\n+    RustcEncodable,\n+    RustcDecodable,\n+    HashStable\n+)]\n+pub struct Scope {\n+    pub id: hir::ItemLocalId,\n+    pub data: ScopeData,\n+}\n+\n+impl fmt::Debug for Scope {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.data {\n+            ScopeData::Node => write!(fmt, \"Node({:?})\", self.id),\n+            ScopeData::CallSite => write!(fmt, \"CallSite({:?})\", self.id),\n+            ScopeData::Arguments => write!(fmt, \"Arguments({:?})\", self.id),\n+            ScopeData::Destruction => write!(fmt, \"Destruction({:?})\", self.id),\n+            ScopeData::Remainder(fsi) => write!(\n+                fmt,\n+                \"Remainder {{ block: {:?}, first_statement_index: {}}}\",\n+                self.id,\n+                fsi.as_u32(),\n+            ),\n+        }\n+    }\n+}\n+\n+#[derive(\n+    Clone,\n+    PartialEq,\n+    PartialOrd,\n+    Eq,\n+    Ord,\n+    Hash,\n+    Debug,\n+    Copy,\n+    RustcEncodable,\n+    RustcDecodable,\n+    HashStable\n+)]\n+pub enum ScopeData {\n+    Node,\n+\n+    /// Scope of the call-site for a function or closure\n+    /// (outlives the arguments as well as the body).\n+    CallSite,\n+\n+    /// Scope of arguments passed to a function or closure\n+    /// (they outlive its body).\n+    Arguments,\n+\n+    /// Scope of destructors for temporaries of node-id.\n+    Destruction,\n+\n+    /// Scope following a `let id = expr;` binding in a block.\n+    Remainder(FirstStatementIndex),\n+}\n+\n+rustc_index::newtype_index! {\n+    /// Represents a subscope of `block` for a binding that is introduced\n+    /// by `block.stmts[first_statement_index]`. Such subscopes represent\n+    /// a suffix of the block. Note that each subscope does not include\n+    /// the initializer expression, if any, for the statement indexed by\n+    /// `first_statement_index`.\n+    ///\n+    /// For example, given `{ let (a, b) = EXPR_1; let c = EXPR_2; ... }`:\n+    ///\n+    /// * The subscope with `first_statement_index == 0` is scope of both\n+    ///   `a` and `b`; it does not include EXPR_1, but does include\n+    ///   everything after that first `let`. (If you want a scope that\n+    ///   includes EXPR_1 as well, then do not use `Scope::Remainder`,\n+    ///   but instead another `Scope` that encompasses the whole block,\n+    ///   e.g., `Scope::Node`.\n+    ///\n+    /// * The subscope with `first_statement_index == 1` is scope of `c`,\n+    ///   and thus does not include EXPR_2, but covers the `...`.\n+    pub struct FirstStatementIndex {\n+        derive [HashStable]\n+    }\n+}\n+\n+// compilation error if size of `ScopeData` is not the same as a `u32`\n+static_assert_size!(ScopeData, 4);\n+\n+impl Scope {\n+    /// Returns a item-local ID associated with this scope.\n+    ///\n+    /// N.B., likely to be replaced as API is refined; e.g., pnkfelix\n+    /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n+    pub fn item_local_id(&self) -> hir::ItemLocalId {\n+        self.id\n+    }\n+\n+    pub fn hir_id(&self, scope_tree: &ScopeTree) -> hir::HirId {\n+        match scope_tree.root_body {\n+            Some(hir_id) => hir::HirId { owner: hir_id.owner, local_id: self.item_local_id() },\n+            None => hir::DUMMY_HIR_ID,\n+        }\n+    }\n+\n+    /// Returns the span of this `Scope`. Note that in general the\n+    /// returned span may not correspond to the span of any `NodeId` in\n+    /// the AST.\n+    pub fn span(&self, tcx: TyCtxt<'_>, scope_tree: &ScopeTree) -> Span {\n+        let hir_id = self.hir_id(scope_tree);\n+        if hir_id == hir::DUMMY_HIR_ID {\n+            return DUMMY_SP;\n+        }\n+        let span = tcx.hir().span(hir_id);\n+        if let ScopeData::Remainder(first_statement_index) = self.data {\n+            if let Node::Block(ref blk) = tcx.hir().get(hir_id) {\n+                // Want span for scope starting after the\n+                // indexed statement and ending at end of\n+                // `blk`; reuse span of `blk` and shift `lo`\n+                // forward to end of indexed statement.\n+                //\n+                // (This is the special case aluded to in the\n+                // doc-comment for this method)\n+\n+                let stmt_span = blk.stmts[first_statement_index.index()].span;\n+\n+                // To avoid issues with macro-generated spans, the span\n+                // of the statement must be nested in that of the block.\n+                if span.lo() <= stmt_span.lo() && stmt_span.lo() <= span.hi() {\n+                    return Span::new(stmt_span.lo(), span.hi(), span.ctxt());\n+                }\n+            }\n+        }\n+        span\n+    }\n+}\n+\n+pub type ScopeDepth = u32;\n+\n+/// The region scope tree encodes information about region relationships.\n+#[derive(Default, Debug)]\n+pub struct ScopeTree {\n+    /// If not empty, this body is the root of this region hierarchy.\n+    pub root_body: Option<hir::HirId>,\n+\n+    /// The parent of the root body owner, if the latter is an\n+    /// an associated const or method, as impls/traits can also\n+    /// have lifetime parameters free in this body.\n+    pub root_parent: Option<hir::HirId>,\n+\n+    /// Maps from a scope ID to the enclosing scope id;\n+    /// this is usually corresponding to the lexical nesting, though\n+    /// in the case of closures the parent scope is the innermost\n+    /// conditional expression or repeating block. (Note that the\n+    /// enclosing scope ID for the block associated with a closure is\n+    /// the closure itself.)\n+    pub parent_map: FxHashMap<Scope, (Scope, ScopeDepth)>,\n+\n+    /// Maps from a variable or binding ID to the block in which that\n+    /// variable is declared.\n+    var_map: FxHashMap<hir::ItemLocalId, Scope>,\n+\n+    /// Maps from a `NodeId` to the associated destruction scope (if any).\n+    destruction_scopes: FxHashMap<hir::ItemLocalId, Scope>,\n+\n+    /// `rvalue_scopes` includes entries for those expressions whose\n+    /// cleanup scope is larger than the default. The map goes from the\n+    /// expression ID to the cleanup scope id. For rvalues not present in\n+    /// this table, the appropriate cleanup scope is the innermost\n+    /// enclosing statement, conditional expression, or repeating\n+    /// block (see `terminating_scopes`).\n+    /// In constants, None is used to indicate that certain expressions\n+    /// escape into 'static and should have no local cleanup scope.\n+    rvalue_scopes: FxHashMap<hir::ItemLocalId, Option<Scope>>,\n+\n+    /// Encodes the hierarchy of fn bodies. Every fn body (including\n+    /// closures) forms its own distinct region hierarchy, rooted in\n+    /// the block that is the fn body. This map points from the ID of\n+    /// that root block to the ID of the root block for the enclosing\n+    /// fn, if any. Thus the map structures the fn bodies into a\n+    /// hierarchy based on their lexical mapping. This is used to\n+    /// handle the relationships between regions in a fn and in a\n+    /// closure defined by that fn. See the \"Modeling closures\"\n+    /// section of the README in infer::region_constraints for\n+    /// more details.\n+    closure_tree: FxHashMap<hir::ItemLocalId, hir::ItemLocalId>,\n+\n+    /// If there are any `yield` nested within a scope, this map\n+    /// stores the `Span` of the last one and its index in the\n+    /// postorder of the Visitor traversal on the HIR.\n+    ///\n+    /// HIR Visitor postorder indexes might seem like a peculiar\n+    /// thing to care about. but it turns out that HIR bindings\n+    /// and the temporary results of HIR expressions are never\n+    /// storage-live at the end of HIR nodes with postorder indexes\n+    /// lower than theirs, and therefore don't need to be suspended\n+    /// at yield-points at these indexes.\n+    ///\n+    /// For an example, suppose we have some code such as:\n+    /// ```rust,ignore (example)\n+    ///     foo(f(), yield y, bar(g()))\n+    /// ```\n+    ///\n+    /// With the HIR tree (calls numbered for expository purposes)\n+    /// ```\n+    ///     Call#0(foo, [Call#1(f), Yield(y), Call#2(bar, Call#3(g))])\n+    /// ```\n+    ///\n+    /// Obviously, the result of `f()` was created before the yield\n+    /// (and therefore needs to be kept valid over the yield) while\n+    /// the result of `g()` occurs after the yield (and therefore\n+    /// doesn't). If we want to infer that, we can look at the\n+    /// postorder traversal:\n+    /// ```plain,ignore\n+    ///     `foo` `f` Call#1 `y` Yield `bar` `g` Call#3 Call#2 Call#0\n+    /// ```\n+    ///\n+    /// In which we can easily see that `Call#1` occurs before the yield,\n+    /// and `Call#3` after it.\n+    ///\n+    /// To see that this method works, consider:\n+    ///\n+    /// Let `D` be our binding/temporary and `U` be our other HIR node, with\n+    /// `HIR-postorder(U) < HIR-postorder(D)` (in our example, U would be\n+    /// the yield and D would be one of the calls). Let's show that\n+    /// `D` is storage-dead at `U`.\n+    ///\n+    /// Remember that storage-live/storage-dead refers to the state of\n+    /// the *storage*, and does not consider moves/drop flags.\n+    ///\n+    /// Then:\n+    ///     1. From the ordering guarantee of HIR visitors (see\n+    ///     `rustc::hir::intravisit`), `D` does not dominate `U`.\n+    ///     2. Therefore, `D` is *potentially* storage-dead at `U` (because\n+    ///     we might visit `U` without ever getting to `D`).\n+    ///     3. However, we guarantee that at each HIR point, each\n+    ///     binding/temporary is always either always storage-live\n+    ///     or always storage-dead. This is what is being guaranteed\n+    ///     by `terminating_scopes` including all blocks where the\n+    ///     count of executions is not guaranteed.\n+    ///     4. By `2.` and `3.`, `D` is *statically* storage-dead at `U`,\n+    ///     QED.\n+    ///\n+    /// This property ought to not on (3) in an essential way -- it\n+    /// is probably still correct even if we have \"unrestricted\" terminating\n+    /// scopes. However, why use the complicated proof when a simple one\n+    /// works?\n+    ///\n+    /// A subtle thing: `box` expressions, such as `box (&x, yield 2, &y)`. It\n+    /// might seem that a `box` expression creates a `Box<T>` temporary\n+    /// when it *starts* executing, at `HIR-preorder(BOX-EXPR)`. That might\n+    /// be true in the MIR desugaring, but it is not important in the semantics.\n+    ///\n+    /// The reason is that semantically, until the `box` expression returns,\n+    /// the values are still owned by their containing expressions. So\n+    /// we'll see that `&x`.\n+    pub yield_in_scope: FxHashMap<Scope, YieldData>,\n+\n+    /// The number of visit_expr and visit_pat calls done in the body.\n+    /// Used to sanity check visit_expr/visit_pat call count when\n+    /// calculating generator interiors.\n+    pub body_expr_count: FxHashMap<hir::BodyId, usize>,\n+}\n+\n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct YieldData {\n+    /// The `Span` of the yield.\n+    pub span: Span,\n+    /// The number of expressions and patterns appearing before the `yield` in the body plus one.\n+    pub expr_and_pat_count: usize,\n+    pub source: hir::YieldSource,\n+}\n+\n+impl<'tcx> ScopeTree {\n+    pub fn record_scope_parent(&mut self, child: Scope, parent: Option<(Scope, ScopeDepth)>) {\n+        debug!(\"{:?}.parent = {:?}\", child, parent);\n+\n+        if let Some(p) = parent {\n+            let prev = self.parent_map.insert(child, p);\n+            assert!(prev.is_none());\n+        }\n+\n+        // Record the destruction scopes for later so we can query them.\n+        if let ScopeData::Destruction = child.data {\n+            self.destruction_scopes.insert(child.item_local_id(), child);\n+        }\n+    }\n+\n+    pub fn each_encl_scope<E>(&self, mut e: E)\n+    where\n+        E: FnMut(Scope, Scope),\n+    {\n+        for (&child, &parent) in &self.parent_map {\n+            e(child, parent.0)\n+        }\n+    }\n+\n+    pub fn each_var_scope<E>(&self, mut e: E)\n+    where\n+        E: FnMut(&hir::ItemLocalId, Scope),\n+    {\n+        for (child, &parent) in self.var_map.iter() {\n+            e(child, parent)\n+        }\n+    }\n+\n+    pub fn opt_destruction_scope(&self, n: hir::ItemLocalId) -> Option<Scope> {\n+        self.destruction_scopes.get(&n).cloned()\n+    }\n+\n+    /// Records that `sub_closure` is defined within `sup_closure`. These IDs\n+    /// should be the ID of the block that is the fn body, which is\n+    /// also the root of the region hierarchy for that fn.\n+    pub fn record_closure_parent(\n+        &mut self,\n+        sub_closure: hir::ItemLocalId,\n+        sup_closure: hir::ItemLocalId,\n+    ) {\n+        debug!(\n+            \"record_closure_parent(sub_closure={:?}, sup_closure={:?})\",\n+            sub_closure, sup_closure\n+        );\n+        assert!(sub_closure != sup_closure);\n+        let previous = self.closure_tree.insert(sub_closure, sup_closure);\n+        assert!(previous.is_none());\n+    }\n+\n+    pub fn record_var_scope(&mut self, var: hir::ItemLocalId, lifetime: Scope) {\n+        debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n+        assert!(var != lifetime.item_local_id());\n+        self.var_map.insert(var, lifetime);\n+    }\n+\n+    pub fn record_rvalue_scope(&mut self, var: hir::ItemLocalId, lifetime: Option<Scope>) {\n+        debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n+        if let Some(lifetime) = lifetime {\n+            assert!(var != lifetime.item_local_id());\n+        }\n+        self.rvalue_scopes.insert(var, lifetime);\n+    }\n+\n+    /// Returns the narrowest scope that encloses `id`, if any.\n+    pub fn opt_encl_scope(&self, id: Scope) -> Option<Scope> {\n+        self.parent_map.get(&id).cloned().map(|(p, _)| p)\n+    }\n+\n+    /// Returns the narrowest scope that encloses `id`, if any.\n+    #[allow(dead_code)] // used in cfg\n+    pub fn encl_scope(&self, id: Scope) -> Scope {\n+        self.opt_encl_scope(id).unwrap()\n+    }\n+\n+    /// Returns the lifetime of the local variable `var_id`\n+    pub fn var_scope(&self, var_id: hir::ItemLocalId) -> Scope {\n+        self.var_map\n+            .get(&var_id)\n+            .cloned()\n+            .unwrap_or_else(|| bug!(\"no enclosing scope for id {:?}\", var_id))\n+    }\n+\n+    /// Returns the scope when the temp created by `expr_id` will be cleaned up.\n+    pub fn temporary_scope(&self, expr_id: hir::ItemLocalId) -> Option<Scope> {\n+        // Check for a designated rvalue scope.\n+        if let Some(&s) = self.rvalue_scopes.get(&expr_id) {\n+            debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n+            return s;\n+        }\n+\n+        // Otherwise, locate the innermost terminating scope\n+        // if there's one. Static items, for instance, won't\n+        // have an enclosing scope, hence no scope will be\n+        // returned.\n+        let mut id = Scope { id: expr_id, data: ScopeData::Node };\n+\n+        while let Some(&(p, _)) = self.parent_map.get(&id) {\n+            match p.data {\n+                ScopeData::Destruction => {\n+                    debug!(\"temporary_scope({:?}) = {:?} [enclosing]\", expr_id, id);\n+                    return Some(id);\n+                }\n+                _ => id = p,\n+            }\n+        }\n+\n+        debug!(\"temporary_scope({:?}) = None\", expr_id);\n+        return None;\n+    }\n+\n+    /// Returns the lifetime of the variable `id`.\n+    pub fn var_region(&self, id: hir::ItemLocalId) -> ty::RegionKind {\n+        let scope = ty::ReScope(self.var_scope(id));\n+        debug!(\"var_region({:?}) = {:?}\", id, scope);\n+        scope\n+    }\n+\n+    pub fn scopes_intersect(&self, scope1: Scope, scope2: Scope) -> bool {\n+        self.is_subscope_of(scope1, scope2) || self.is_subscope_of(scope2, scope1)\n+    }\n+\n+    /// Returns `true` if `subscope` is equal to or is lexically nested inside `superscope`, and\n+    /// `false` otherwise.\n+    pub fn is_subscope_of(&self, subscope: Scope, superscope: Scope) -> bool {\n+        let mut s = subscope;\n+        debug!(\"is_subscope_of({:?}, {:?})\", subscope, superscope);\n+        while superscope != s {\n+            match self.opt_encl_scope(s) {\n+                None => {\n+                    debug!(\"is_subscope_of({:?}, {:?}, s={:?})=false\", subscope, superscope, s);\n+                    return false;\n+                }\n+                Some(scope) => s = scope,\n+            }\n+        }\n+\n+        debug!(\"is_subscope_of({:?}, {:?})=true\", subscope, superscope);\n+\n+        return true;\n+    }\n+\n+    /// Returns the ID of the innermost containing body.\n+    pub fn containing_body(&self, mut scope: Scope) -> Option<hir::ItemLocalId> {\n+        loop {\n+            if let ScopeData::CallSite = scope.data {\n+                return Some(scope.item_local_id());\n+            }\n+\n+            scope = self.opt_encl_scope(scope)?;\n+        }\n+    }\n+\n+    /// Finds the nearest common ancestor of two scopes. That is, finds the\n+    /// smallest scope which is greater than or equal to both `scope_a` and\n+    /// `scope_b`.\n+    pub fn nearest_common_ancestor(&self, scope_a: Scope, scope_b: Scope) -> Scope {\n+        if scope_a == scope_b {\n+            return scope_a;\n+        }\n+\n+        let mut a = scope_a;\n+        let mut b = scope_b;\n+\n+        // Get the depth of each scope's parent. If either scope has no parent,\n+        // it must be the root, which means we can stop immediately because the\n+        // root must be the nearest common ancestor. (In practice, this is\n+        // moderately common.)\n+        let (parent_a, parent_a_depth) = match self.parent_map.get(&a) {\n+            Some(pd) => *pd,\n+            None => return a,\n+        };\n+        let (parent_b, parent_b_depth) = match self.parent_map.get(&b) {\n+            Some(pd) => *pd,\n+            None => return b,\n+        };\n+\n+        if parent_a_depth > parent_b_depth {\n+            // `a` is lower than `b`. Move `a` up until it's at the same depth\n+            // as `b`. The first move up is trivial because we already found\n+            // `parent_a` above; the loop does the remaining N-1 moves.\n+            a = parent_a;\n+            for _ in 0..(parent_a_depth - parent_b_depth - 1) {\n+                a = self.parent_map.get(&a).unwrap().0;\n+            }\n+        } else if parent_b_depth > parent_a_depth {\n+            // `b` is lower than `a`.\n+            b = parent_b;\n+            for _ in 0..(parent_b_depth - parent_a_depth - 1) {\n+                b = self.parent_map.get(&b).unwrap().0;\n+            }\n+        } else {\n+            // Both scopes are at the same depth, and we know they're not equal\n+            // because that case was tested for at the top of this function. So\n+            // we can trivially move them both up one level now.\n+            assert!(parent_a_depth != 0);\n+            a = parent_a;\n+            b = parent_b;\n+        }\n+\n+        // Now both scopes are at the same level. We move upwards in lockstep\n+        // until they match. In practice, this loop is almost always executed\n+        // zero times because `a` is almost always a direct ancestor of `b` or\n+        // vice versa.\n+        while a != b {\n+            a = self.parent_map.get(&a).unwrap().0;\n+            b = self.parent_map.get(&b).unwrap().0;\n+        }\n+\n+        a\n+    }\n+\n+    /// Assuming that the provided region was defined within this `ScopeTree`,\n+    /// returns the outermost `Scope` that the region outlives.\n+    pub fn early_free_scope(&self, tcx: TyCtxt<'tcx>, br: &ty::EarlyBoundRegion) -> Scope {\n+        let param_owner = tcx.parent(br.def_id).unwrap();\n+\n+        let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n+        let scope = tcx\n+            .hir()\n+            .maybe_body_owned_by(param_owner_id)\n+            .map(|body_id| tcx.hir().body(body_id).value.hir_id.local_id)\n+            .unwrap_or_else(|| {\n+                // The lifetime was defined on node that doesn't own a body,\n+                // which in practice can only mean a trait or an impl, that\n+                // is the parent of a method, and that is enforced below.\n+                if Some(param_owner_id) != self.root_parent {\n+                    tcx.sess.delay_span_bug(\n+                        DUMMY_SP,\n+                        &format!(\n+                            \"free_scope: {:?} not recognized by the \\\n+                              region scope tree for {:?} / {:?}\",\n+                            param_owner,\n+                            self.root_parent.map(|id| tcx.hir().local_def_id(id)),\n+                            self.root_body.map(|hir_id| DefId::local(hir_id.owner))\n+                        ),\n+                    );\n+                }\n+\n+                // The trait/impl lifetime is in scope for the method's body.\n+                self.root_body.unwrap().local_id\n+            });\n+\n+        Scope { id: scope, data: ScopeData::CallSite }\n+    }\n+\n+    /// Assuming that the provided region was defined within this `ScopeTree`,\n+    /// returns the outermost `Scope` that the region outlives.\n+    pub fn free_scope(&self, tcx: TyCtxt<'tcx>, fr: &ty::FreeRegion) -> Scope {\n+        let param_owner = match fr.bound_region {\n+            ty::BoundRegion::BrNamed(def_id, _) => tcx.parent(def_id).unwrap(),\n+            _ => fr.scope,\n+        };\n+\n+        // Ensure that the named late-bound lifetimes were defined\n+        // on the same function that they ended up being freed in.\n+        assert_eq!(param_owner, fr.scope);\n+\n+        let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n+        let body_id = tcx.hir().body_owned_by(param_owner_id);\n+        Scope { id: tcx.hir().body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n+    }\n+\n+    /// Checks whether the given scope contains a `yield`. If so,\n+    /// returns `Some((span, expr_count))` with the span of a yield we found and\n+    /// the number of expressions and patterns appearing before the `yield` in the body + 1.\n+    /// If there a are multiple yields in a scope, the one with the highest number is returned.\n+    pub fn yield_in_scope(&self, scope: Scope) -> Option<YieldData> {\n+        self.yield_in_scope.get(&scope).cloned()\n+    }\n+\n+    /// Gives the number of expressions visited in a body.\n+    /// Used to sanity check visit_expr call count when\n+    /// calculating generator interiors.\n+    pub fn body_expr_count(&self, body_id: hir::BodyId) -> Option<usize> {\n+        self.body_expr_count.get(&body_id).map(|r| *r)\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for ScopeTree {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        let ScopeTree {\n+            root_body,\n+            root_parent,\n+            ref body_expr_count,\n+            ref parent_map,\n+            ref var_map,\n+            ref destruction_scopes,\n+            ref rvalue_scopes,\n+            ref closure_tree,\n+            ref yield_in_scope,\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            root_body.hash_stable(hcx, hasher);\n+            root_parent.hash_stable(hcx, hasher);\n+        });\n+\n+        body_expr_count.hash_stable(hcx, hasher);\n+        parent_map.hash_stable(hcx, hasher);\n+        var_map.hash_stable(hcx, hasher);\n+        destruction_scopes.hash_stable(hcx, hasher);\n+        rvalue_scopes.hash_stable(hcx, hasher);\n+        closure_tree.hash_stable(hcx, hasher);\n+        yield_in_scope.hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "1ab285c216cbc6c68686e94f49a8cddea94ee70d", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/afcd5c16b7d268ca64ca274366276568d0844cc3/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afcd5c16b7d268ca64ca274366276568d0844cc3/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=afcd5c16b7d268ca64ca274366276568d0844cc3", "patch": "@@ -686,7 +686,6 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     stability::provide(providers);\n     rustc_passes::provide(providers);\n     rustc_traits::provide(providers);\n-    middle::region::provide(providers);\n     rustc_metadata::provide(providers);\n     lint::provide(providers);\n     rustc_lint::provide(providers);"}, {"sha": "8a10c8fe89d6278c26d708fd73f762bb9a7686dc", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afcd5c16b7d268ca64ca274366276568d0844cc3/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afcd5c16b7d268ca64ca274366276568d0844cc3/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=afcd5c16b7d268ca64ca274366276568d0844cc3", "patch": "@@ -31,6 +31,7 @@ mod lib_features;\n mod liveness;\n pub mod loops;\n mod reachable;\n+mod region;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     check_const::provide(providers);\n@@ -41,4 +42,5 @@ pub fn provide(providers: &mut Providers<'_>) {\n     liveness::provide(providers);\n     intrinsicck::provide(providers);\n     reachable::provide(providers);\n+    region::provide(providers);\n }"}, {"sha": "b828e014cfc9a5a10638438bba8483f13e5436f5", "filename": "src/librustc_passes/region.rs", "status": "modified", "additions": 11, "deletions": 718, "changes": 729, "blob_url": "https://github.com/rust-lang/rust/blob/afcd5c16b7d268ca64ca274366276568d0844cc3/src%2Flibrustc_passes%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afcd5c16b7d268ca64ca274366276568d0844cc3/src%2Flibrustc_passes%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fregion.rs?ref=afcd5c16b7d268ca64ca274366276568d0844cc3", "patch": "@@ -6,362 +6,22 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n \n-use crate::hir;\n-use crate::hir::def_id::DefId;\n-use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use crate::hir::Node;\n-use crate::hir::{Arm, Block, Expr, Local, Pat, PatKind, Stmt};\n-use crate::ich::{NodeIdHashingMode, StableHashingContext};\n-use crate::ty::query::Providers;\n-use crate::ty::{self, DefIdTree, TyCtxt};\n-use crate::util::nodemap::{FxHashMap, FxHashSet};\n-\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc::hir::Node;\n+use rustc::hir::{Arm, Block, Expr, Local, Pat, PatKind, Stmt};\n+use rustc::middle::region::*;\n+use rustc::ty::query::Providers;\n+use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::FxHashSet;\n+\n use rustc_index::vec::Idx;\n-use rustc_macros::HashStable;\n use syntax::source_map;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n \n-use std::fmt;\n use std::mem;\n \n-/// Represents a statically-describable scope that can be used to\n-/// bound the lifetime/region for values.\n-///\n-/// `Node(node_id)`: Any AST node that has any scope at all has the\n-/// `Node(node_id)` scope. Other variants represent special cases not\n-/// immediately derivable from the abstract syntax tree structure.\n-///\n-/// `DestructionScope(node_id)` represents the scope of destructors\n-/// implicitly-attached to `node_id` that run immediately after the\n-/// expression for `node_id` itself. Not every AST node carries a\n-/// `DestructionScope`, but those that are `terminating_scopes` do;\n-/// see discussion with `ScopeTree`.\n-///\n-/// `Remainder { block, statement_index }` represents\n-/// the scope of user code running immediately after the initializer\n-/// expression for the indexed statement, until the end of the block.\n-///\n-/// So: the following code can be broken down into the scopes beneath:\n-///\n-/// ```text\n-/// let a = f().g( 'b: { let x = d(); let y = d(); x.h(y)  }   ) ;\n-///\n-///                                                              +-+ (D12.)\n-///                                                        +-+       (D11.)\n-///                                              +---------+         (R10.)\n-///                                              +-+                  (D9.)\n-///                                   +----------+                    (M8.)\n-///                                 +----------------------+          (R7.)\n-///                                 +-+                               (D6.)\n-///                      +----------+                                 (M5.)\n-///                    +-----------------------------------+          (M4.)\n-///         +--------------------------------------------------+      (M3.)\n-///         +--+                                                      (M2.)\n-/// +-----------------------------------------------------------+     (M1.)\n-///\n-///  (M1.): Node scope of the whole `let a = ...;` statement.\n-///  (M2.): Node scope of the `f()` expression.\n-///  (M3.): Node scope of the `f().g(..)` expression.\n-///  (M4.): Node scope of the block labeled `'b:`.\n-///  (M5.): Node scope of the `let x = d();` statement\n-///  (D6.): DestructionScope for temporaries created during M5.\n-///  (R7.): Remainder scope for block `'b:`, stmt 0 (let x = ...).\n-///  (M8.): Node scope of the `let y = d();` statement.\n-///  (D9.): DestructionScope for temporaries created during M8.\n-/// (R10.): Remainder scope for block `'b:`, stmt 1 (let y = ...).\n-/// (D11.): DestructionScope for temporaries and bindings from block `'b:`.\n-/// (D12.): DestructionScope for temporaries created during M1 (e.g., f()).\n-/// ```\n-///\n-/// Note that while the above picture shows the destruction scopes\n-/// as following their corresponding node scopes, in the internal\n-/// data structures of the compiler the destruction scopes are\n-/// represented as enclosing parents. This is sound because we use the\n-/// enclosing parent relationship just to ensure that referenced\n-/// values live long enough; phrased another way, the starting point\n-/// of each range is not really the important thing in the above\n-/// picture, but rather the ending point.\n-//\n-// FIXME(pnkfelix): this currently derives `PartialOrd` and `Ord` to\n-// placate the same deriving in `ty::FreeRegion`, but we may want to\n-// actually attach a more meaningful ordering to scopes than the one\n-// generated via deriving here.\n-#[derive(\n-    Clone,\n-    PartialEq,\n-    PartialOrd,\n-    Eq,\n-    Ord,\n-    Hash,\n-    Copy,\n-    RustcEncodable,\n-    RustcDecodable,\n-    HashStable\n-)]\n-pub struct Scope {\n-    pub id: hir::ItemLocalId,\n-    pub data: ScopeData,\n-}\n-\n-impl fmt::Debug for Scope {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.data {\n-            ScopeData::Node => write!(fmt, \"Node({:?})\", self.id),\n-            ScopeData::CallSite => write!(fmt, \"CallSite({:?})\", self.id),\n-            ScopeData::Arguments => write!(fmt, \"Arguments({:?})\", self.id),\n-            ScopeData::Destruction => write!(fmt, \"Destruction({:?})\", self.id),\n-            ScopeData::Remainder(fsi) => write!(\n-                fmt,\n-                \"Remainder {{ block: {:?}, first_statement_index: {}}}\",\n-                self.id,\n-                fsi.as_u32(),\n-            ),\n-        }\n-    }\n-}\n-\n-#[derive(\n-    Clone,\n-    PartialEq,\n-    PartialOrd,\n-    Eq,\n-    Ord,\n-    Hash,\n-    Debug,\n-    Copy,\n-    RustcEncodable,\n-    RustcDecodable,\n-    HashStable\n-)]\n-pub enum ScopeData {\n-    Node,\n-\n-    /// Scope of the call-site for a function or closure\n-    /// (outlives the arguments as well as the body).\n-    CallSite,\n-\n-    /// Scope of arguments passed to a function or closure\n-    /// (they outlive its body).\n-    Arguments,\n-\n-    /// Scope of destructors for temporaries of node-id.\n-    Destruction,\n-\n-    /// Scope following a `let id = expr;` binding in a block.\n-    Remainder(FirstStatementIndex),\n-}\n-\n-rustc_index::newtype_index! {\n-    /// Represents a subscope of `block` for a binding that is introduced\n-    /// by `block.stmts[first_statement_index]`. Such subscopes represent\n-    /// a suffix of the block. Note that each subscope does not include\n-    /// the initializer expression, if any, for the statement indexed by\n-    /// `first_statement_index`.\n-    ///\n-    /// For example, given `{ let (a, b) = EXPR_1; let c = EXPR_2; ... }`:\n-    ///\n-    /// * The subscope with `first_statement_index == 0` is scope of both\n-    ///   `a` and `b`; it does not include EXPR_1, but does include\n-    ///   everything after that first `let`. (If you want a scope that\n-    ///   includes EXPR_1 as well, then do not use `Scope::Remainder`,\n-    ///   but instead another `Scope` that encompasses the whole block,\n-    ///   e.g., `Scope::Node`.\n-    ///\n-    /// * The subscope with `first_statement_index == 1` is scope of `c`,\n-    ///   and thus does not include EXPR_2, but covers the `...`.\n-    pub struct FirstStatementIndex {\n-        derive [HashStable]\n-    }\n-}\n-\n-// compilation error if size of `ScopeData` is not the same as a `u32`\n-static_assert_size!(ScopeData, 4);\n-\n-impl Scope {\n-    /// Returns a item-local ID associated with this scope.\n-    ///\n-    /// N.B., likely to be replaced as API is refined; e.g., pnkfelix\n-    /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n-    pub fn item_local_id(&self) -> hir::ItemLocalId {\n-        self.id\n-    }\n-\n-    pub fn hir_id(&self, scope_tree: &ScopeTree) -> hir::HirId {\n-        match scope_tree.root_body {\n-            Some(hir_id) => hir::HirId { owner: hir_id.owner, local_id: self.item_local_id() },\n-            None => hir::DUMMY_HIR_ID,\n-        }\n-    }\n-\n-    /// Returns the span of this `Scope`. Note that in general the\n-    /// returned span may not correspond to the span of any `NodeId` in\n-    /// the AST.\n-    pub fn span(&self, tcx: TyCtxt<'_>, scope_tree: &ScopeTree) -> Span {\n-        let hir_id = self.hir_id(scope_tree);\n-        if hir_id == hir::DUMMY_HIR_ID {\n-            return DUMMY_SP;\n-        }\n-        let span = tcx.hir().span(hir_id);\n-        if let ScopeData::Remainder(first_statement_index) = self.data {\n-            if let Node::Block(ref blk) = tcx.hir().get(hir_id) {\n-                // Want span for scope starting after the\n-                // indexed statement and ending at end of\n-                // `blk`; reuse span of `blk` and shift `lo`\n-                // forward to end of indexed statement.\n-                //\n-                // (This is the special case aluded to in the\n-                // doc-comment for this method)\n-\n-                let stmt_span = blk.stmts[first_statement_index.index()].span;\n-\n-                // To avoid issues with macro-generated spans, the span\n-                // of the statement must be nested in that of the block.\n-                if span.lo() <= stmt_span.lo() && stmt_span.lo() <= span.hi() {\n-                    return Span::new(stmt_span.lo(), span.hi(), span.ctxt());\n-                }\n-            }\n-        }\n-        span\n-    }\n-}\n-\n-pub type ScopeDepth = u32;\n-\n-/// The region scope tree encodes information about region relationships.\n-#[derive(Default, Debug)]\n-pub struct ScopeTree {\n-    /// If not empty, this body is the root of this region hierarchy.\n-    root_body: Option<hir::HirId>,\n-\n-    /// The parent of the root body owner, if the latter is an\n-    /// an associated const or method, as impls/traits can also\n-    /// have lifetime parameters free in this body.\n-    root_parent: Option<hir::HirId>,\n-\n-    /// Maps from a scope ID to the enclosing scope id;\n-    /// this is usually corresponding to the lexical nesting, though\n-    /// in the case of closures the parent scope is the innermost\n-    /// conditional expression or repeating block. (Note that the\n-    /// enclosing scope ID for the block associated with a closure is\n-    /// the closure itself.)\n-    parent_map: FxHashMap<Scope, (Scope, ScopeDepth)>,\n-\n-    /// Maps from a variable or binding ID to the block in which that\n-    /// variable is declared.\n-    var_map: FxHashMap<hir::ItemLocalId, Scope>,\n-\n-    /// Maps from a `NodeId` to the associated destruction scope (if any).\n-    destruction_scopes: FxHashMap<hir::ItemLocalId, Scope>,\n-\n-    /// `rvalue_scopes` includes entries for those expressions whose\n-    /// cleanup scope is larger than the default. The map goes from the\n-    /// expression ID to the cleanup scope id. For rvalues not present in\n-    /// this table, the appropriate cleanup scope is the innermost\n-    /// enclosing statement, conditional expression, or repeating\n-    /// block (see `terminating_scopes`).\n-    /// In constants, None is used to indicate that certain expressions\n-    /// escape into 'static and should have no local cleanup scope.\n-    rvalue_scopes: FxHashMap<hir::ItemLocalId, Option<Scope>>,\n-\n-    /// Encodes the hierarchy of fn bodies. Every fn body (including\n-    /// closures) forms its own distinct region hierarchy, rooted in\n-    /// the block that is the fn body. This map points from the ID of\n-    /// that root block to the ID of the root block for the enclosing\n-    /// fn, if any. Thus the map structures the fn bodies into a\n-    /// hierarchy based on their lexical mapping. This is used to\n-    /// handle the relationships between regions in a fn and in a\n-    /// closure defined by that fn. See the \"Modeling closures\"\n-    /// section of the README in infer::region_constraints for\n-    /// more details.\n-    closure_tree: FxHashMap<hir::ItemLocalId, hir::ItemLocalId>,\n-\n-    /// If there are any `yield` nested within a scope, this map\n-    /// stores the `Span` of the last one and its index in the\n-    /// postorder of the Visitor traversal on the HIR.\n-    ///\n-    /// HIR Visitor postorder indexes might seem like a peculiar\n-    /// thing to care about. but it turns out that HIR bindings\n-    /// and the temporary results of HIR expressions are never\n-    /// storage-live at the end of HIR nodes with postorder indexes\n-    /// lower than theirs, and therefore don't need to be suspended\n-    /// at yield-points at these indexes.\n-    ///\n-    /// For an example, suppose we have some code such as:\n-    /// ```rust,ignore (example)\n-    ///     foo(f(), yield y, bar(g()))\n-    /// ```\n-    ///\n-    /// With the HIR tree (calls numbered for expository purposes)\n-    /// ```\n-    ///     Call#0(foo, [Call#1(f), Yield(y), Call#2(bar, Call#3(g))])\n-    /// ```\n-    ///\n-    /// Obviously, the result of `f()` was created before the yield\n-    /// (and therefore needs to be kept valid over the yield) while\n-    /// the result of `g()` occurs after the yield (and therefore\n-    /// doesn't). If we want to infer that, we can look at the\n-    /// postorder traversal:\n-    /// ```plain,ignore\n-    ///     `foo` `f` Call#1 `y` Yield `bar` `g` Call#3 Call#2 Call#0\n-    /// ```\n-    ///\n-    /// In which we can easily see that `Call#1` occurs before the yield,\n-    /// and `Call#3` after it.\n-    ///\n-    /// To see that this method works, consider:\n-    ///\n-    /// Let `D` be our binding/temporary and `U` be our other HIR node, with\n-    /// `HIR-postorder(U) < HIR-postorder(D)` (in our example, U would be\n-    /// the yield and D would be one of the calls). Let's show that\n-    /// `D` is storage-dead at `U`.\n-    ///\n-    /// Remember that storage-live/storage-dead refers to the state of\n-    /// the *storage*, and does not consider moves/drop flags.\n-    ///\n-    /// Then:\n-    ///     1. From the ordering guarantee of HIR visitors (see\n-    ///     `rustc::hir::intravisit`), `D` does not dominate `U`.\n-    ///     2. Therefore, `D` is *potentially* storage-dead at `U` (because\n-    ///     we might visit `U` without ever getting to `D`).\n-    ///     3. However, we guarantee that at each HIR point, each\n-    ///     binding/temporary is always either always storage-live\n-    ///     or always storage-dead. This is what is being guaranteed\n-    ///     by `terminating_scopes` including all blocks where the\n-    ///     count of executions is not guaranteed.\n-    ///     4. By `2.` and `3.`, `D` is *statically* storage-dead at `U`,\n-    ///     QED.\n-    ///\n-    /// This property ought to not on (3) in an essential way -- it\n-    /// is probably still correct even if we have \"unrestricted\" terminating\n-    /// scopes. However, why use the complicated proof when a simple one\n-    /// works?\n-    ///\n-    /// A subtle thing: `box` expressions, such as `box (&x, yield 2, &y)`. It\n-    /// might seem that a `box` expression creates a `Box<T>` temporary\n-    /// when it *starts* executing, at `HIR-preorder(BOX-EXPR)`. That might\n-    /// be true in the MIR desugaring, but it is not important in the semantics.\n-    ///\n-    /// The reason is that semantically, until the `box` expression returns,\n-    /// the values are still owned by their containing expressions. So\n-    /// we'll see that `&x`.\n-    yield_in_scope: FxHashMap<Scope, YieldData>,\n-\n-    /// The number of visit_expr and visit_pat calls done in the body.\n-    /// Used to sanity check visit_expr/visit_pat call count when\n-    /// calculating generator interiors.\n-    body_expr_count: FxHashMap<hir::BodyId, usize>,\n-}\n-\n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct YieldData {\n-    /// The `Span` of the yield.\n-    pub span: Span,\n-    /// The number of expressions and patterns appearing before the `yield` in the body plus one.\n-    pub expr_and_pat_count: usize,\n-    pub source: hir::YieldSource,\n-}\n-\n #[derive(Debug, Copy, Clone)]\n pub struct Context {\n     /// The root of the current region tree. This is typically the id\n@@ -419,344 +79,6 @@ struct RegionResolutionVisitor<'tcx> {\n     terminating_scopes: FxHashSet<hir::ItemLocalId>,\n }\n \n-struct ExprLocatorVisitor {\n-    hir_id: hir::HirId,\n-    result: Option<usize>,\n-    expr_and_pat_count: usize,\n-}\n-\n-// This visitor has to have the same `visit_expr` calls as `RegionResolutionVisitor`\n-// since `expr_count` is compared against the results there.\n-impl<'tcx> Visitor<'tcx> for ExprLocatorVisitor {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n-        intravisit::walk_pat(self, pat);\n-\n-        self.expr_and_pat_count += 1;\n-\n-        if pat.hir_id == self.hir_id {\n-            self.result = Some(self.expr_and_pat_count);\n-        }\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        debug!(\"ExprLocatorVisitor - pre-increment {} expr = {:?}\", self.expr_and_pat_count, expr);\n-\n-        intravisit::walk_expr(self, expr);\n-\n-        self.expr_and_pat_count += 1;\n-\n-        debug!(\"ExprLocatorVisitor - post-increment {} expr = {:?}\", self.expr_and_pat_count, expr);\n-\n-        if expr.hir_id == self.hir_id {\n-            self.result = Some(self.expr_and_pat_count);\n-        }\n-    }\n-}\n-\n-impl<'tcx> ScopeTree {\n-    pub fn record_scope_parent(&mut self, child: Scope, parent: Option<(Scope, ScopeDepth)>) {\n-        debug!(\"{:?}.parent = {:?}\", child, parent);\n-\n-        if let Some(p) = parent {\n-            let prev = self.parent_map.insert(child, p);\n-            assert!(prev.is_none());\n-        }\n-\n-        // Record the destruction scopes for later so we can query them.\n-        if let ScopeData::Destruction = child.data {\n-            self.destruction_scopes.insert(child.item_local_id(), child);\n-        }\n-    }\n-\n-    pub fn each_encl_scope<E>(&self, mut e: E)\n-    where\n-        E: FnMut(Scope, Scope),\n-    {\n-        for (&child, &parent) in &self.parent_map {\n-            e(child, parent.0)\n-        }\n-    }\n-\n-    pub fn each_var_scope<E>(&self, mut e: E)\n-    where\n-        E: FnMut(&hir::ItemLocalId, Scope),\n-    {\n-        for (child, &parent) in self.var_map.iter() {\n-            e(child, parent)\n-        }\n-    }\n-\n-    pub fn opt_destruction_scope(&self, n: hir::ItemLocalId) -> Option<Scope> {\n-        self.destruction_scopes.get(&n).cloned()\n-    }\n-\n-    /// Records that `sub_closure` is defined within `sup_closure`. These IDs\n-    /// should be the ID of the block that is the fn body, which is\n-    /// also the root of the region hierarchy for that fn.\n-    fn record_closure_parent(\n-        &mut self,\n-        sub_closure: hir::ItemLocalId,\n-        sup_closure: hir::ItemLocalId,\n-    ) {\n-        debug!(\n-            \"record_closure_parent(sub_closure={:?}, sup_closure={:?})\",\n-            sub_closure, sup_closure\n-        );\n-        assert!(sub_closure != sup_closure);\n-        let previous = self.closure_tree.insert(sub_closure, sup_closure);\n-        assert!(previous.is_none());\n-    }\n-\n-    fn record_var_scope(&mut self, var: hir::ItemLocalId, lifetime: Scope) {\n-        debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.item_local_id());\n-        self.var_map.insert(var, lifetime);\n-    }\n-\n-    fn record_rvalue_scope(&mut self, var: hir::ItemLocalId, lifetime: Option<Scope>) {\n-        debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        if let Some(lifetime) = lifetime {\n-            assert!(var != lifetime.item_local_id());\n-        }\n-        self.rvalue_scopes.insert(var, lifetime);\n-    }\n-\n-    /// Returns the narrowest scope that encloses `id`, if any.\n-    pub fn opt_encl_scope(&self, id: Scope) -> Option<Scope> {\n-        self.parent_map.get(&id).cloned().map(|(p, _)| p)\n-    }\n-\n-    /// Returns the narrowest scope that encloses `id`, if any.\n-    #[allow(dead_code)] // used in cfg\n-    pub fn encl_scope(&self, id: Scope) -> Scope {\n-        self.opt_encl_scope(id).unwrap()\n-    }\n-\n-    /// Returns the lifetime of the local variable `var_id`\n-    pub fn var_scope(&self, var_id: hir::ItemLocalId) -> Scope {\n-        self.var_map\n-            .get(&var_id)\n-            .cloned()\n-            .unwrap_or_else(|| bug!(\"no enclosing scope for id {:?}\", var_id))\n-    }\n-\n-    /// Returns the scope when the temp created by `expr_id` will be cleaned up.\n-    pub fn temporary_scope(&self, expr_id: hir::ItemLocalId) -> Option<Scope> {\n-        // Check for a designated rvalue scope.\n-        if let Some(&s) = self.rvalue_scopes.get(&expr_id) {\n-            debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n-            return s;\n-        }\n-\n-        // Otherwise, locate the innermost terminating scope\n-        // if there's one. Static items, for instance, won't\n-        // have an enclosing scope, hence no scope will be\n-        // returned.\n-        let mut id = Scope { id: expr_id, data: ScopeData::Node };\n-\n-        while let Some(&(p, _)) = self.parent_map.get(&id) {\n-            match p.data {\n-                ScopeData::Destruction => {\n-                    debug!(\"temporary_scope({:?}) = {:?} [enclosing]\", expr_id, id);\n-                    return Some(id);\n-                }\n-                _ => id = p,\n-            }\n-        }\n-\n-        debug!(\"temporary_scope({:?}) = None\", expr_id);\n-        return None;\n-    }\n-\n-    /// Returns the lifetime of the variable `id`.\n-    pub fn var_region(&self, id: hir::ItemLocalId) -> ty::RegionKind {\n-        let scope = ty::ReScope(self.var_scope(id));\n-        debug!(\"var_region({:?}) = {:?}\", id, scope);\n-        scope\n-    }\n-\n-    pub fn scopes_intersect(&self, scope1: Scope, scope2: Scope) -> bool {\n-        self.is_subscope_of(scope1, scope2) || self.is_subscope_of(scope2, scope1)\n-    }\n-\n-    /// Returns `true` if `subscope` is equal to or is lexically nested inside `superscope`, and\n-    /// `false` otherwise.\n-    pub fn is_subscope_of(&self, subscope: Scope, superscope: Scope) -> bool {\n-        let mut s = subscope;\n-        debug!(\"is_subscope_of({:?}, {:?})\", subscope, superscope);\n-        while superscope != s {\n-            match self.opt_encl_scope(s) {\n-                None => {\n-                    debug!(\"is_subscope_of({:?}, {:?}, s={:?})=false\", subscope, superscope, s);\n-                    return false;\n-                }\n-                Some(scope) => s = scope,\n-            }\n-        }\n-\n-        debug!(\"is_subscope_of({:?}, {:?})=true\", subscope, superscope);\n-\n-        return true;\n-    }\n-\n-    /// Returns the ID of the innermost containing body.\n-    pub fn containing_body(&self, mut scope: Scope) -> Option<hir::ItemLocalId> {\n-        loop {\n-            if let ScopeData::CallSite = scope.data {\n-                return Some(scope.item_local_id());\n-            }\n-\n-            scope = self.opt_encl_scope(scope)?;\n-        }\n-    }\n-\n-    /// Finds the nearest common ancestor of two scopes. That is, finds the\n-    /// smallest scope which is greater than or equal to both `scope_a` and\n-    /// `scope_b`.\n-    pub fn nearest_common_ancestor(&self, scope_a: Scope, scope_b: Scope) -> Scope {\n-        if scope_a == scope_b {\n-            return scope_a;\n-        }\n-\n-        let mut a = scope_a;\n-        let mut b = scope_b;\n-\n-        // Get the depth of each scope's parent. If either scope has no parent,\n-        // it must be the root, which means we can stop immediately because the\n-        // root must be the nearest common ancestor. (In practice, this is\n-        // moderately common.)\n-        let (parent_a, parent_a_depth) = match self.parent_map.get(&a) {\n-            Some(pd) => *pd,\n-            None => return a,\n-        };\n-        let (parent_b, parent_b_depth) = match self.parent_map.get(&b) {\n-            Some(pd) => *pd,\n-            None => return b,\n-        };\n-\n-        if parent_a_depth > parent_b_depth {\n-            // `a` is lower than `b`. Move `a` up until it's at the same depth\n-            // as `b`. The first move up is trivial because we already found\n-            // `parent_a` above; the loop does the remaining N-1 moves.\n-            a = parent_a;\n-            for _ in 0..(parent_a_depth - parent_b_depth - 1) {\n-                a = self.parent_map.get(&a).unwrap().0;\n-            }\n-        } else if parent_b_depth > parent_a_depth {\n-            // `b` is lower than `a`.\n-            b = parent_b;\n-            for _ in 0..(parent_b_depth - parent_a_depth - 1) {\n-                b = self.parent_map.get(&b).unwrap().0;\n-            }\n-        } else {\n-            // Both scopes are at the same depth, and we know they're not equal\n-            // because that case was tested for at the top of this function. So\n-            // we can trivially move them both up one level now.\n-            assert!(parent_a_depth != 0);\n-            a = parent_a;\n-            b = parent_b;\n-        }\n-\n-        // Now both scopes are at the same level. We move upwards in lockstep\n-        // until they match. In practice, this loop is almost always executed\n-        // zero times because `a` is almost always a direct ancestor of `b` or\n-        // vice versa.\n-        while a != b {\n-            a = self.parent_map.get(&a).unwrap().0;\n-            b = self.parent_map.get(&b).unwrap().0;\n-        }\n-\n-        a\n-    }\n-\n-    /// Assuming that the provided region was defined within this `ScopeTree`,\n-    /// returns the outermost `Scope` that the region outlives.\n-    pub fn early_free_scope(&self, tcx: TyCtxt<'tcx>, br: &ty::EarlyBoundRegion) -> Scope {\n-        let param_owner = tcx.parent(br.def_id).unwrap();\n-\n-        let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n-        let scope = tcx\n-            .hir()\n-            .maybe_body_owned_by(param_owner_id)\n-            .map(|body_id| tcx.hir().body(body_id).value.hir_id.local_id)\n-            .unwrap_or_else(|| {\n-                // The lifetime was defined on node that doesn't own a body,\n-                // which in practice can only mean a trait or an impl, that\n-                // is the parent of a method, and that is enforced below.\n-                if Some(param_owner_id) != self.root_parent {\n-                    tcx.sess.delay_span_bug(\n-                        DUMMY_SP,\n-                        &format!(\n-                            \"free_scope: {:?} not recognized by the \\\n-                              region scope tree for {:?} / {:?}\",\n-                            param_owner,\n-                            self.root_parent.map(|id| tcx.hir().local_def_id(id)),\n-                            self.root_body.map(|hir_id| DefId::local(hir_id.owner))\n-                        ),\n-                    );\n-                }\n-\n-                // The trait/impl lifetime is in scope for the method's body.\n-                self.root_body.unwrap().local_id\n-            });\n-\n-        Scope { id: scope, data: ScopeData::CallSite }\n-    }\n-\n-    /// Assuming that the provided region was defined within this `ScopeTree`,\n-    /// returns the outermost `Scope` that the region outlives.\n-    pub fn free_scope(&self, tcx: TyCtxt<'tcx>, fr: &ty::FreeRegion) -> Scope {\n-        let param_owner = match fr.bound_region {\n-            ty::BoundRegion::BrNamed(def_id, _) => tcx.parent(def_id).unwrap(),\n-            _ => fr.scope,\n-        };\n-\n-        // Ensure that the named late-bound lifetimes were defined\n-        // on the same function that they ended up being freed in.\n-        assert_eq!(param_owner, fr.scope);\n-\n-        let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n-        let body_id = tcx.hir().body_owned_by(param_owner_id);\n-        Scope { id: tcx.hir().body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n-    }\n-\n-    /// Checks whether the given scope contains a `yield`. If so,\n-    /// returns `Some((span, expr_count))` with the span of a yield we found and\n-    /// the number of expressions and patterns appearing before the `yield` in the body + 1.\n-    /// If there a are multiple yields in a scope, the one with the highest number is returned.\n-    pub fn yield_in_scope(&self, scope: Scope) -> Option<YieldData> {\n-        self.yield_in_scope.get(&scope).cloned()\n-    }\n-\n-    /// Checks whether the given scope contains a `yield` and if that yield could execute\n-    /// after `expr`. If so, it returns the span of that `yield`.\n-    /// `scope` must be inside the body.\n-    pub fn yield_in_scope_for_expr(\n-        &self,\n-        scope: Scope,\n-        expr_hir_id: hir::HirId,\n-        body: &'tcx hir::Body<'tcx>,\n-    ) -> Option<Span> {\n-        self.yield_in_scope(scope).and_then(|YieldData { span, expr_and_pat_count, .. }| {\n-            let mut visitor =\n-                ExprLocatorVisitor { hir_id: expr_hir_id, result: None, expr_and_pat_count: 0 };\n-            visitor.visit_body(body);\n-            if expr_and_pat_count >= visitor.result.unwrap() { Some(span) } else { None }\n-        })\n-    }\n-\n-    /// Gives the number of expressions visited in a body.\n-    /// Used to sanity check visit_expr call count when\n-    /// calculating generator interiors.\n-    pub fn body_expr_count(&self, body_id: hir::BodyId) -> Option<usize> {\n-        self.body_expr_count.get(&body_id).map(|r| *r)\n-    }\n-}\n-\n /// Records the lifetime of a local variable as `cx.var_parent`\n fn record_var_lifetime(\n     visitor: &mut RegionResolutionVisitor<'_>,\n@@ -1505,32 +827,3 @@ fn region_scope_tree(tcx: TyCtxt<'_>, def_id: DefId) -> &ScopeTree {\n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers { region_scope_tree, ..*providers };\n }\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for ScopeTree {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let ScopeTree {\n-            root_body,\n-            root_parent,\n-            ref body_expr_count,\n-            ref parent_map,\n-            ref var_map,\n-            ref destruction_scopes,\n-            ref rvalue_scopes,\n-            ref closure_tree,\n-            ref yield_in_scope,\n-        } = *self;\n-\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            root_body.hash_stable(hcx, hasher);\n-            root_parent.hash_stable(hcx, hasher);\n-        });\n-\n-        body_expr_count.hash_stable(hcx, hasher);\n-        parent_map.hash_stable(hcx, hasher);\n-        var_map.hash_stable(hcx, hasher);\n-        destruction_scopes.hash_stable(hcx, hasher);\n-        rvalue_scopes.hash_stable(hcx, hasher);\n-        closure_tree.hash_stable(hcx, hasher);\n-        yield_in_scope.hash_stable(hcx, hasher);\n-    }\n-}"}]}