{"sha": "08f204e17f1f007d844743802e04d7f62689e966", "node_id": "C_kwDOAAsO6NoAKDA4ZjIwNGUxN2YxZjAwN2Q4NDQ3NDM4MDJlMDRkN2Y2MjY4OWU5NjY", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-04-04T21:15:29Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-04-09T02:23:52Z"}, "message": "rustdoc: migrate `document_type_layout` to askama", "tree": {"sha": "3b0b9d4f92f064c33440a66b4bdbdd1ba7df64c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b0b9d4f92f064c33440a66b4bdbdd1ba7df64c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08f204e17f1f007d844743802e04d7f62689e966", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08f204e17f1f007d844743802e04d7f62689e966", "html_url": "https://github.com/rust-lang/rust/commit/08f204e17f1f007d844743802e04d7f62689e966", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08f204e17f1f007d844743802e04d7f62689e966/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1be642ce3c24d1a0517c9bf91af926740618b01", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1be642ce3c24d1a0517c9bf91af926740618b01", "html_url": "https://github.com/rust-lang/rust/commit/d1be642ce3c24d1a0517c9bf91af926740618b01"}], "stats": {"total": 211, "additions": 112, "deletions": 99}, "files": [{"sha": "e089b55b9c4d1e4511567ab184a736b9f98c640f", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 67, "deletions": 99, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/08f204e17f1f007d844743802e04d7f62689e966/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f204e17f1f007d844743802e04d7f62689e966/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=08f204e17f1f007d844743802e04d7f62689e966", "patch": "@@ -5,13 +5,15 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::DefId;\n+use rustc_index::vec::IndexVec;\n use rustc_middle::middle::stability;\n use rustc_middle::span_bug;\n-use rustc_middle::ty::layout::LayoutError;\n+use rustc_middle::ty::layout::{LayoutError, TyAndLayout};\n use rustc_middle::ty::{self, Adt, TyCtxt};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_target::abi::{LayoutS, Primitive, TagEncoding, Variants};\n+use rustc_target::abi::{LayoutS, Primitive, TagEncoding, VariantIdx, Variants};\n+use std::borrow::Borrow;\n use std::cmp::Ordering;\n use std::fmt;\n use std::rc::Rc;\n@@ -1936,111 +1938,77 @@ fn document_type_layout<'a, 'cx: 'a>(\n     cx: &'a Context<'cx>,\n     ty_def_id: DefId,\n ) -> impl fmt::Display + 'a + Captures<'cx> {\n-    fn write_size_of_layout(mut w: impl fmt::Write, layout: &LayoutS, tag_size: u64) {\n-        if layout.abi.is_unsized() {\n-            write!(w, \"(unsized)\").unwrap();\n-        } else {\n-            let size = layout.size.bytes() - tag_size;\n-            write!(w, \"{size} byte{pl}\", pl = if size == 1 { \"\" } else { \"s\" }).unwrap();\n-            if layout.abi.is_uninhabited() {\n-                write!(\n-                    w,\n-                    \" (<a href=\\\"https://doc.rust-lang.org/stable/reference/glossary.html#uninhabited\\\">uninhabited</a>)\"\n-                ).unwrap();\n-            }\n-        }\n+    #[derive(Template)]\n+    #[template(path = \"type_layout.html\")]\n+    struct TypeLayout<'a, 'cx> {\n+        cx: &'a Context<'cx>,\n+        ty_def_id: DefId,\n     }\n \n-    display_fn(move |mut f| {\n-        if !cx.shared.show_type_layout {\n-            return Ok(());\n+    impl<'a, 'cx: 'a> TypeLayout<'a, 'cx> {\n+        fn variants<'b: 'a>(&'b self) -> Option<&'b IndexVec<VariantIdx, LayoutS>> {\n+            if let Variants::Multiple { variants, .. } =\n+                    self.type_layout().unwrap().layout.variants() && !variants.is_empty() {\n+                Some(&variants)\n+            } else {\n+                None\n+            }\n         }\n-\n-        writeln!(\n-            f,\n-            \"<h2 id=\\\"layout\\\" class=\\\"small-section-header\\\"> \\\n-            Layout<a href=\\\"#layout\\\" class=\\\"anchor\\\">\u00a7</a></h2>\"\n-        )?;\n-        writeln!(f, \"<div class=\\\"docblock\\\">\")?;\n-\n-        let tcx = cx.tcx();\n-        let param_env = tcx.param_env(ty_def_id);\n-        let ty = tcx.type_of(ty_def_id).subst_identity();\n-        match tcx.layout_of(param_env.and(ty)) {\n-            Ok(ty_layout) => {\n-                writeln!(\n-                    f,\n-                    \"<div class=\\\"warning\\\"><p><strong>Note:</strong> Most layout information is \\\n-                    <strong>completely unstable</strong> and may even differ between compilations. \\\n-                    The only exception is types with certain <code>repr(...)</code> attributes. \\\n-                    Please see the Rust Reference\u2019s \\\n-                    <a href=\\\"https://doc.rust-lang.org/reference/type-layout.html\\\">\u201cType Layout\u201d</a> \\\n-                    chapter for details on type layout guarantees.</p></div>\"\n-                )?;\n-                f.write_str(\"<p><strong>Size:</strong> \")?;\n-                write_size_of_layout(&mut f, &ty_layout.layout.0, 0);\n-                writeln!(f, \"</p>\")?;\n-                if let Variants::Multiple { variants, tag, tag_encoding, .. } =\n-                    &ty_layout.layout.variants()\n-                {\n-                    if !variants.is_empty() {\n-                        f.write_str(\n-                            \"<p><strong>Size for each variant:</strong></p>\\\n-                                <ul>\",\n+        fn type_layout<'b: 'a>(&'b self) -> Result<TyAndLayout<'cx>, LayoutError<'cx>> {\n+            let tcx = self.cx.tcx();\n+            let param_env = tcx.param_env(self.ty_def_id);\n+            let ty = tcx.type_of(self.ty_def_id).subst_identity();\n+            tcx.layout_of(param_env.and(ty))\n+        }\n+        fn variant_name<'b: 'a>(&'b self, index: VariantIdx) -> Symbol {\n+            let Adt(adt, _) = self.type_layout().unwrap().ty.kind() else {\n+                span_bug!(self.cx.tcx().def_span(self.ty_def_id), \"not an adt\")\n+            };\n+            adt.variant(index).name\n+        }\n+        fn tag_size<'b: 'a>(&'b self) -> u64 {\n+            if let Variants::Multiple { variants, tag, tag_encoding, .. } =\n+                    self.type_layout().unwrap().layout.variants() && !variants.is_empty() {\n+                if let TagEncoding::Niche { .. } = tag_encoding {\n+                    0\n+                } else if let Primitive::Int(i, _) = tag.primitive() {\n+                    i.size().bytes()\n+                } else {\n+                    span_bug!(self.cx.tcx().def_span(self.ty_def_id), \"tag is neither niche nor int\")\n+                }\n+            } else {\n+                0\n+            }\n+        }\n+        fn write_size<'b: 'a>(\n+            &'b self,\n+            layout: &'b LayoutS,\n+            tag_size: u64,\n+        ) -> impl fmt::Display + Captures<'cx> + Captures<'b> {\n+            display_fn(move |f| {\n+                if layout.abi.is_unsized() {\n+                    write!(f, \"(unsized)\")?;\n+                } else {\n+                    let size = layout.size.bytes() - tag_size;\n+                    write!(f, \"{size} byte{pl}\", pl = if size == 1 { \"\" } else { \"s\" })?;\n+                    if layout.abi.is_uninhabited() {\n+                        write!(\n+                            f,\n+                            \" (<a href=\\\"https://doc.rust-lang.org/stable/reference/glossary.html#uninhabited\\\">uninhabited</a>)\"\n                         )?;\n-\n-                        let Adt(adt, _) = ty_layout.ty.kind() else {\n-                            span_bug!(tcx.def_span(ty_def_id), \"not an adt\")\n-                        };\n-\n-                        let tag_size = if let TagEncoding::Niche { .. } = tag_encoding {\n-                            0\n-                        } else if let Primitive::Int(i, _) = tag.primitive() {\n-                            i.size().bytes()\n-                        } else {\n-                            span_bug!(tcx.def_span(ty_def_id), \"tag is neither niche nor int\")\n-                        };\n-\n-                        for (index, layout) in variants.iter_enumerated() {\n-                            let name = adt.variant(index).name;\n-                            write!(&mut f, \"<li><code>{name}</code>: \")?;\n-                            write_size_of_layout(&mut f, layout, tag_size);\n-                            writeln!(&mut f, \"</li>\")?;\n-                        }\n-                        f.write_str(\"</ul>\")?;\n                     }\n                 }\n-            }\n-            // This kind of layout error can occur with valid code, e.g. if you try to\n-            // get the layout of a generic type such as `Vec<T>`.\n-            Err(LayoutError::Unknown(_)) => {\n-                writeln!(\n-                    f,\n-                    \"<p><strong>Note:</strong> Unable to compute type layout, \\\n-                    possibly due to this type having generic parameters. \\\n-                    Layout can only be computed for concrete, fully-instantiated types.</p>\"\n-                )?;\n-            }\n-            // This kind of error probably can't happen with valid code, but we don't\n-            // want to panic and prevent the docs from building, so we just let the\n-            // user know that we couldn't compute the layout.\n-            Err(LayoutError::SizeOverflow(_)) => {\n-                writeln!(\n-                    f,\n-                    \"<p><strong>Note:</strong> Encountered an error during type layout; \\\n-                    the type was too big.</p>\"\n-                )?;\n-            }\n-            Err(LayoutError::NormalizationFailure(_, _)) => {\n-                writeln!(\n-                    f,\n-                    \"<p><strong>Note:</strong> Encountered an error during type layout; \\\n-                    the type failed to be normalized.</p>\"\n-                )?;\n-            }\n+                Ok(())\n+            })\n+        }\n+    }\n+\n+    display_fn(move |f| {\n+        if !cx.shared.show_type_layout {\n+            return Ok(());\n         }\n \n-        writeln!(f, \"</div>\")\n+        Ok(TypeLayout { cx, ty_def_id }.render_into(f).unwrap())\n     })\n }\n "}, {"sha": "70149d4e1ab852cbfabf16359faf1e3a1ddbe534", "filename": "src/librustdoc/html/templates/type_layout.html", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/08f204e17f1f007d844743802e04d7f62689e966/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Ftype_layout.html", "raw_url": "https://github.com/rust-lang/rust/raw/08f204e17f1f007d844743802e04d7f62689e966/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Ftype_layout.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Ftype_layout.html?ref=08f204e17f1f007d844743802e04d7f62689e966", "patch": "@@ -0,0 +1,45 @@\n+<h2 id=\"layout\" class=\"small-section-header\">  {# #}\n+    Layout<a href=\"#layout\" class=\"anchor\">\u00a7</a> {# #}\n+</h2> {# #}\n+<div class=\"docblock\"> {# #}\n+    {% match self.type_layout() %}\n+        {% when Ok(ty_layout) %}\n+            <div class=\"warning\"> {# #}\n+                <p> {# #}\n+                    <strong>Note:</strong> Most layout information is <strong>completely {#+ #}\n+                    unstable</strong> and may even differ between compilations. {#+ #}\n+                    The only exception is types with certain <code>repr(...)</code> {#+ #}\n+                    attributes. Please see the Rust Reference\u2019s {#+ #}\n+                    <a href=\"https://doc.rust-lang.org/reference/type-layout.html\">\u201cType Layout\u201d</a> {#+ #}\n+                    chapter for details on type layout guarantees. {# #}\n+                </p> {# #}\n+            </div> {# #}\n+            <p><strong>Size:</strong> {{ self.write_size(ty_layout.layout.0.borrow(), 0) | safe }}</p> {# #}\n+            {% if let Some(variants) = self.variants() %}\n+                <p><strong>Size for each variant:</strong></p> {# #}\n+                <ul> {# #}\n+                    {% for (index, layout) in variants.iter_enumerated() %}\n+                        <li> {# #}\n+                            <code>{{ self.variant_name(index.clone()) }}</code>: {#+ #}\n+                            {{ self.write_size(layout, self.tag_size()) | safe }}\n+                        </li> {# #}\n+                    {% endfor %}\n+                </ul> {# #}\n+            {% endif %}\n+        {# This kind of layout error can occur with valid code, e.g. if you try to\n+           get the layout of a generic type such as `Vec<T>`. #}\n+        {% when Err(LayoutError::Unknown(_)) %}\n+            <p><strong>Note:</strong> Unable to compute type layout, {#+ #}\n+            possibly due to this type having generic parameters. {#+ #}\n+            Layout can only be computed for concrete, fully-instantiated types.</p> {# #}\n+        {# This kind of error probably can't happen with valid code, but we don't\n+           want to panic and prevent the docs from building, so we just let the\n+           user know that we couldn't compute the layout. #}\n+        {% when Err(LayoutError::SizeOverflow(_)) %}\n+            <p><strong>Note:</strong> Encountered an error during type layout; {#+ #}\n+            the type was too big.</p> {# #}\n+        {% when Err(LayoutError::NormalizationFailure(_, _)) %}\n+            <p><strong>Note:</strong> Encountered an error during type layout; {#+ #}\n+            the type failed to be normalized.</p> {# #}\n+    {% endmatch %}\n+</div> {# #}"}]}