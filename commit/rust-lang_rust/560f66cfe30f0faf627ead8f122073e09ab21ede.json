{"sha": "560f66cfe30f0faf627ead8f122073e09ab21ede", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MGY2NmNmZTMwZjBmYWY2MjdlYWQ4ZjEyMjA3M2UwOWFiMjFlZGU=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-11-09T03:12:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-11-09T03:12:27Z"}, "message": "Merge pull request #2130 from topecongiro/soft-wrapping-doc-comments\n\nSoft wrapping doc comments", "tree": {"sha": "59cfb06ec52b8776b739bc5dd7e65655f3f61d5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59cfb06ec52b8776b739bc5dd7e65655f3f61d5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/560f66cfe30f0faf627ead8f122073e09ab21ede", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaA8ebCRBK7hj4Ov3rIwAAdHIIAIS4nis7FSfxw1ol6M36foxF\nCPqdQt8WLSZZhDIrQq/UZd5dmevWDqfg19E0fdpo63igIPq3mKhAx/gUP75Cv5lt\nokxXu/s3QdFHwTsZL7V6X0fjFpxBZ45bzlrp4PV+EbtUH7HgQNYHgfPc/c4GYUfV\nYET0pgJvZ5o4INmgoRc9UoLV+1W51lkyZWCJ6XcOEkc6Wdoi76vYxSguxNGt5Leh\nJkBbFK/xYjdnI0Ro14kpMyBe7po+HmHP8YoUsoKl5HUoGl1vqpWdn0QjWvbpfpJ9\nGOqw+eN9o0Twm/JDt2lAkjZ/9+lW8cJpFInjFjcR7Y9fuq5Yqog7DISqAZK/qVI=\n=OAnf\n-----END PGP SIGNATURE-----\n", "payload": "tree 59cfb06ec52b8776b739bc5dd7e65655f3f61d5e\nparent b1825c9d92ac18293fcd363fa6299cdc9f4d54b4\nparent e079cb81efd07088f074191f8acbf07c7dc0890b\nauthor Nick Cameron <nrc@ncameron.org> 1510197147 +1300\ncommitter GitHub <noreply@github.com> 1510197147 +1300\n\nMerge pull request #2130 from topecongiro/soft-wrapping-doc-comments\n\nSoft wrapping doc comments"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/560f66cfe30f0faf627ead8f122073e09ab21ede", "html_url": "https://github.com/rust-lang/rust/commit/560f66cfe30f0faf627ead8f122073e09ab21ede", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/560f66cfe30f0faf627ead8f122073e09ab21ede/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1825c9d92ac18293fcd363fa6299cdc9f4d54b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1825c9d92ac18293fcd363fa6299cdc9f4d54b4", "html_url": "https://github.com/rust-lang/rust/commit/b1825c9d92ac18293fcd363fa6299cdc9f4d54b4"}, {"sha": "e079cb81efd07088f074191f8acbf07c7dc0890b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e079cb81efd07088f074191f8acbf07c7dc0890b", "html_url": "https://github.com/rust-lang/rust/commit/e079cb81efd07088f074191f8acbf07c7dc0890b"}], "stats": {"total": 230, "additions": 140, "deletions": 90}, "files": [{"sha": "c613b3b8a551feeac8ddbcd1076214b9f4ea5346", "filename": "src/visitor.rs", "status": "modified", "additions": 127, "deletions": 88, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/560f66cfe30f0faf627ead8f122073e09ab21ede/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560f66cfe30f0faf627ead8f122073e09ab21ede/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=560f66cfe30f0faf627ead8f122073e09ab21ede", "patch": "@@ -19,7 +19,7 @@ use syntax::parse::ParseSess;\n use expr::rewrite_literal;\n use spanned::Spanned;\n use codemap::{LineRangeUtils, SpanUtils};\n-use comment::{contains_comment, recover_missing_comment_in_span, remove_trailing_white_spaces,\n+use comment::{combine_strs_with_missing_comments, contains_comment, remove_trailing_white_spaces,\n               CodeCharKind, CommentCodeSlices, FindUncommented};\n use comment::rewrite_comment;\n use config::{BraceStyle, Config};\n@@ -791,106 +791,145 @@ impl Rewrite for ast::Attribute {\n     }\n }\n \n+/// Returns the first group of attributes that fills the given predicate.\n+/// We consider two doc comments are in different group if they are separated by normal comments.\n+fn take_while_with_pred<'a, P>(\n+    context: &RewriteContext,\n+    attrs: &'a [ast::Attribute],\n+    pred: P,\n+) -> &'a [ast::Attribute]\n+where\n+    P: Fn(&ast::Attribute) -> bool,\n+{\n+    let mut last_index = 0;\n+    let mut iter = attrs.iter().enumerate().peekable();\n+    while let Some((i, attr)) = iter.next() {\n+        if !pred(attr) {\n+            break;\n+        }\n+        if let Some(&(_, next_attr)) = iter.peek() {\n+            // Extract comments between two attributes.\n+            let span_between_attr = mk_sp(attr.span.hi(), next_attr.span.lo());\n+            let snippet = context.snippet(span_between_attr);\n+            if snippet.chars().filter(|c| *c == '\\n').count() >= 2 || snippet.contains('/') {\n+                break;\n+            }\n+        }\n+        last_index = i;\n+    }\n+    if last_index == 0 {\n+        &[]\n+    } else {\n+        &attrs[..last_index + 1]\n+    }\n+}\n+\n+fn rewrite_first_group_attrs(\n+    context: &RewriteContext,\n+    attrs: &[ast::Attribute],\n+    shape: Shape,\n+) -> Option<(usize, String)> {\n+    if attrs.is_empty() {\n+        return Some((0, String::new()));\n+    }\n+    // Rewrite doc comments\n+    let sugared_docs = take_while_with_pred(context, attrs, |a| a.is_sugared_doc);\n+    if !sugared_docs.is_empty() {\n+        let snippet = sugared_docs\n+            .iter()\n+            .map(|a| context.snippet(a.span))\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+        return Some((\n+            sugared_docs.len(),\n+            rewrite_comment(&snippet, false, shape, context.config)?,\n+        ));\n+    }\n+    // Rewrite `#[derive(..)]`s.\n+    if context.config.merge_derives() {\n+        let derives = take_while_with_pred(context, attrs, is_derive);\n+        if !derives.is_empty() {\n+            let mut derive_args = vec![];\n+            for derive in derives {\n+                derive_args.append(&mut get_derive_args(context, derive)?);\n+            }\n+            return Some((\n+                derives.len(),\n+                format_derive(context, &derive_args, shape)?,\n+            ));\n+        }\n+    }\n+    // Rewrite the first attribute.\n+    Some((1, attrs[0].rewrite(context, shape)?))\n+}\n+\n+fn has_newlines_before_after_comment(comment: &str) -> (&str, &str) {\n+    // Look at before and after comment and see if there are any empty lines.\n+    let comment_begin = comment.chars().position(|c| c == '/');\n+    let len = comment_begin.unwrap_or_else(|| comment.len());\n+    let mlb = comment.chars().take(len).filter(|c| *c == '\\n').count() > 1;\n+    let mla = if comment_begin.is_none() {\n+        mlb\n+    } else {\n+        let comment_end = comment.chars().rev().position(|c| !c.is_whitespace());\n+        let len = comment_end.unwrap();\n+        comment\n+            .chars()\n+            .rev()\n+            .take(len)\n+            .filter(|c| *c == '\\n')\n+            .count() > 1\n+    };\n+    (if mlb { \"\\n\" } else { \"\" }, if mla { \"\\n\" } else { \"\" })\n+}\n+\n impl<'a> Rewrite for [ast::Attribute] {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if self.is_empty() {\n             return Some(String::new());\n         }\n-        let mut result = String::with_capacity(128);\n-        let indent = shape.indent.to_string(context.config);\n-\n-        let mut derive_args = Vec::new();\n-\n-        let mut iter = self.iter().enumerate().peekable();\n-        let mut insert_new_line = true;\n-        let mut is_prev_sugared_doc = false;\n-        while let Some((i, a)) = iter.next() {\n-            let a_str = a.rewrite(context, shape)?;\n-\n-            // Write comments and blank lines between attributes.\n-            if i > 0 {\n-                let comment = context.snippet(mk_sp(self[i - 1].span.hi(), a.span.lo()));\n-                // This particular horror show is to preserve line breaks in between doc\n-                // comments. An alternative would be to force such line breaks to start\n-                // with the usual doc comment token.\n-                let (multi_line_before, multi_line_after) = if a.is_sugared_doc\n-                    || is_prev_sugared_doc\n-                {\n-                    // Look at before and after comment and see if there are any empty lines.\n-                    let comment_begin = comment.chars().position(|c| c == '/');\n-                    let len = comment_begin.unwrap_or_else(|| comment.len());\n-                    let mlb = comment.chars().take(len).filter(|c| *c == '\\n').count() > 1;\n-                    let mla = if comment_begin.is_none() {\n-                        mlb\n-                    } else {\n-                        let comment_end = comment.chars().rev().position(|c| !c.is_whitespace());\n-                        let len = comment_end.unwrap();\n-                        comment\n-                            .chars()\n-                            .rev()\n-                            .take(len)\n-                            .filter(|c| *c == '\\n')\n-                            .count() > 1\n-                    };\n-                    (mlb, mla)\n-                } else {\n-                    (false, false)\n-                };\n-\n-                let comment = recover_missing_comment_in_span(\n-                    mk_sp(self[i - 1].span.hi(), a.span.lo()),\n+        let (first_group_len, first_group_str) = rewrite_first_group_attrs(context, self, shape)?;\n+        if self.len() == 1 || first_group_len == self.len() {\n+            Some(first_group_str)\n+        } else {\n+            let rest_str = self[first_group_len..].rewrite(context, shape)?;\n+            let missing_span = mk_sp(\n+                self[first_group_len - 1].span.hi(),\n+                self[first_group_len].span.lo(),\n+            );\n+            // Preserve an empty line before/after doc comments.\n+            if self[0].is_sugared_doc || self[first_group_len].is_sugared_doc {\n+                let snippet = context.snippet(missing_span);\n+                let (mla, mlb) = has_newlines_before_after_comment(&snippet);\n+                let comment = ::comment::recover_missing_comment_in_span(\n+                    missing_span,\n                     shape.with_max_width(context.config),\n                     context,\n                     0,\n                 )?;\n-\n-                if !comment.is_empty() {\n-                    if multi_line_before {\n-                        result.push('\\n');\n-                    }\n-                    result.push_str(&comment);\n-                    result.push('\\n');\n-                    if multi_line_after {\n-                        result.push('\\n')\n-                    }\n-                } else if insert_new_line {\n-                    result.push('\\n');\n-                    if multi_line_after {\n-                        result.push('\\n')\n-                    }\n-                }\n-\n-                if derive_args.is_empty() {\n-                    result.push_str(&indent);\n-                }\n-\n-                insert_new_line = true;\n-            }\n-\n-            // Write the attribute itself.\n-            if context.config.merge_derives() {\n-                // If the attribute is `#[derive(...)]`, take the arguments.\n-                if let Some(mut args) = get_derive_args(context, a) {\n-                    derive_args.append(&mut args);\n-                    match iter.peek() {\n-                        // If the next attribute is `#[derive(...)]` as well, skip rewriting.\n-                        Some(&(_, next_attr)) if is_derive(next_attr) => insert_new_line = false,\n-                        // If not, rewrite the merged derives.\n-                        _ => {\n-                            result.push_str(&format_derive(context, &derive_args, shape)?);\n-                            derive_args.clear();\n-                        }\n-                    }\n+                let comment = if comment.is_empty() {\n+                    format!(\"\\n{}\", mlb)\n                 } else {\n-                    result.push_str(&a_str);\n-                }\n+                    format!(\"{}{}\\n{}\", mla, comment, mlb)\n+                };\n+                Some(format!(\n+                    \"{}{}{}{}\",\n+                    first_group_str,\n+                    comment,\n+                    shape.indent.to_string(context.config),\n+                    rest_str\n+                ))\n             } else {\n-                result.push_str(&a_str);\n+                combine_strs_with_missing_comments(\n+                    context,\n+                    &first_group_str,\n+                    &rest_str,\n+                    missing_span,\n+                    shape,\n+                    false,\n+                )\n             }\n-\n-            is_prev_sugared_doc = a.is_sugared_doc;\n         }\n-        Some(result)\n     }\n }\n "}, {"sha": "ace8359409cd23c119a2cb06aa8f1b0c9be5ad81", "filename": "tests/source/soft-wrapping.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/560f66cfe30f0faf627ead8f122073e09ab21ede/tests%2Fsource%2Fsoft-wrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560f66cfe30f0faf627ead8f122073e09ab21ede/tests%2Fsource%2Fsoft-wrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fsoft-wrapping.rs?ref=560f66cfe30f0faf627ead8f122073e09ab21ede", "patch": "@@ -7,3 +7,9 @@\n // lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is\n // ggreater than or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits off\n // the result are the upper 96 bits of `a`.\n+\n+/// Compare the lowest `f32` of both inputs for greater than or equal. The\n+/// lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is\n+/// greater than or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits off\n+/// the result are the upper 96 bits of `a`.\n+fn foo() {}"}, {"sha": "b66f833a932c009b16a4d7deede9d82495266663", "filename": "tests/target/enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/560f66cfe30f0faf627ead8f122073e09ab21ede/tests%2Ftarget%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560f66cfe30f0faf627ead8f122073e09ab21ede/tests%2Ftarget%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fenum.rs?ref=560f66cfe30f0faf627ead8f122073e09ab21ede", "patch": "@@ -139,8 +139,7 @@ pub enum Bencoding<'i> {\n     Str(&'i [u8]),\n     Int(i64),\n     List(Vec<Bencoding<'i>>),\n-    /// A bencoded dict value. The first element the slice of bytes in the\n-    /// source that the dict is\n+    /// A bencoded dict value. The first element the slice of bytes in the source that the dict is\n     /// composed of. The second is the dict, decoded into an ordered map.\n     // TODO make Dict \"structlike\" AKA name the two values.\n     Dict(&'i [u8], BTreeMap<&'i [u8], Bencoding<'i>>),"}, {"sha": "58f3557fbe266f043fe989e68e38ba99b1c9a685", "filename": "tests/target/soft-wrapping.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/560f66cfe30f0faf627ead8f122073e09ab21ede/tests%2Ftarget%2Fsoft-wrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560f66cfe30f0faf627ead8f122073e09ab21ede/tests%2Ftarget%2Fsoft-wrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fsoft-wrapping.rs?ref=560f66cfe30f0faf627ead8f122073e09ab21ede", "patch": "@@ -7,3 +7,9 @@\n // lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is\n // ggreater than or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits\n // off the result are the upper 96 bits of `a`.\n+\n+/// Compare the lowest `f32` of both inputs for greater than or equal. The\n+/// lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is\n+/// greater than or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits\n+/// off the result are the upper 96 bits of `a`.\n+fn foo() {}"}]}