{"sha": "09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5OTY3NjY1ZWFhNWNhM2QyNTlmMGY1OWVmMjZjOGQyMzZiZjQ3YTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-17T02:51:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-17T02:51:53Z"}, "message": "auto merge of #14955 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "ae450abfecbe1fdec6f583cf7cf743c35663a4c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae450abfecbe1fdec6f583cf7cf743c35663a4c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "html_url": "https://github.com/rust-lang/rust/commit/09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc30abbcad282634fb99089eb9297e7cc4f26729", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc30abbcad282634fb99089eb9297e7cc4f26729", "html_url": "https://github.com/rust-lang/rust/commit/cc30abbcad282634fb99089eb9297e7cc4f26729"}, {"sha": "b9adb6c717627ab6dcc9298b79a8d44cfe2fc616", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9adb6c717627ab6dcc9298b79a8d44cfe2fc616", "html_url": "https://github.com/rust-lang/rust/commit/b9adb6c717627ab6dcc9298b79a8d44cfe2fc616"}], "stats": {"total": 1133, "additions": 777, "deletions": 356}, "files": [{"sha": "e85d3f013d361c2fe942ffb883bbf7fa17e72654", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -20,13 +20,13 @@ please do two things:\n \n Pull requests will be treated as \"review requests\", and we will give\n feedback we expect to see corrected on\n-[style](https://github.com/mozilla/rust/wiki/Note-style-guide) and\n+[style](https://github.com/rust-lang/rust/wiki/Note-style-guide) and\n substance before pulling.  Changes contributed via pull request should\n focus on a single issue at a time, like any other.  We will not accept\n pull-requests that try to \"sneak\" unrelated changes in.\n \n Normally, all pull requests must include regression tests (see\n-[Note-testsuite](https://github.com/mozilla/rust/wiki/Note-testsuite))\n+[Note-testsuite](https://github.com/rust-lang/rust/wiki/Note-testsuite))\n that test your change.  Occasionally, a change will be very difficult\n to test for.  In those cases, please include a note in your commit\n message explaining why.\n@@ -41,4 +41,4 @@ example, if it's 2014, and you change a Rust file that was created in\n ```\n \n For more details, please refer to\n-[Note-development-policy](https://github.com/mozilla/rust/wiki/Note-development-policy).\n+[Note-development-policy](https://github.com/rust-lang/rust/wiki/Note-development-policy)."}, {"sha": "a8a63a42066b9a9e9e4265f4104c5bf6520ba55d", "filename": "Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -98,8 +98,8 @@\n # This is hardly all there is to know of The Rust Build System's\n # mysteries. The tale continues on the wiki[1][2].\n #\n-# [1]: https://github.com/mozilla/rust/wiki/Note-build-system\n-# [2]: https://github.com/mozilla/rust/wiki/Note-testsuite\n+# [1]: https://github.com/rust-lang/rust/wiki/Note-build-system\n+# [2]: https://github.com/rust-lang/rust/wiki/Note-testsuite\n #\n # If you really feel like getting your hands dirty, then:\n #"}, {"sha": "5927fb292d8b964a99c9ce4f4108423659272e1b", "filename": "README.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -14,8 +14,8 @@ documentation.\n \n [installer]: http://www.rust-lang.org/install.html\n [tutorial]: http://doc.rust-lang.org/tutorial.html\n-[wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n-[win-wiki]: https://github.com/mozilla/rust/wiki/Using-Rust-on-Windows\n+[wiki-start]: https://github.com/rust-lang/rust/wiki/Note-getting-started-developing-Rust\n+[win-wiki]: https://github.com/rust-lang/rust/wiki/Using-Rust-on-Windows\n \n ## Building from Source\n \n@@ -38,7 +38,7 @@ documentation.\n \n     Or to build from the [repo] do:\n \n-        $ git clone https://github.com/mozilla/rust.git\n+        $ git clone https://github.com/rust-lang/rust.git\n         $ cd rust\n \n     Now that you have Rust's source code, you can configure and build it:\n@@ -58,7 +58,7 @@ documentation.\n 3. Read the [tutorial].\n 4. Enjoy!\n \n-[repo]: https://github.com/mozilla/rust\n+[repo]: https://github.com/rust-lang/rust\n [tarball]: http://static.rust-lang.org/dist/rust-nightly.tar.gz\n [tutorial]: http://doc.rust-lang.org/tutorial.html\n \n@@ -83,7 +83,7 @@ swap, it will take a very long time to build.\n \n There is a lot more documentation in the [wiki].\n \n-[wiki]: https://github.com/mozilla/rust/wiki\n+[wiki]: https://github.com/rust-lang/rust/wiki\n \n ## License\n "}, {"sha": "bdcfecd8ce903588b0512e9a81bf02dfa677887c", "filename": "configure", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/configure", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -421,6 +421,7 @@ opt llvm-static-stdcpp 0 \"statically link to libstdc++ for LLVM\"\n opt rpath 1 \"build rpaths into rustc itself\"\n opt nightly 0 \"build nightly packages\"\n opt verify-install 1 \"verify installed binaries work\"\n+opt jemalloc 1 \"build liballoc with jemalloc\"\n valopt prefix \"/usr/local\" \"set installation prefix\"\n valopt local-rust-root \"/usr/local\" \"set prefix for local rust binary\"\n valopt llvm-root \"\" \"set LLVM root\"\n@@ -1167,6 +1168,7 @@ putvar CFG_MANDIR\n putvar CFG_DISABLE_INJECT_STD_VERSION\n putvar CFG_JEMALLOC_ROOT\n putvar CFG_LIBUV_ROOT\n+putvar CFG_DISABLE_JEMALLOC\n \n # Avoid spurious warnings from clang by feeding it original source on\n # ccache-miss rather than preprocessed input."}, {"sha": "a71547893ad0b828e968814b24bc2cef28b8dadd", "filename": "man/rustc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -184,7 +184,7 @@ To build an executable with debug info:\n rustdoc\n \n .SH \"BUGS\"\n-See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues.\n+See <\\fBhttps://github.com/rust-lang/rust/issues\\fR> for issues.\n \n .SH \"AUTHOR\"\n See \\fBAUTHORS.txt\\fR in the Rust source distribution."}, {"sha": "82b7ee27b94879dbe59d61d75083c17da52d32e8", "filename": "man/rustdoc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/man%2Frustdoc.1", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/man%2Frustdoc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustdoc.1?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -87,7 +87,7 @@ The generated HTML can be viewed with any standard web browser.\n rustc\n \n .SH \"BUGS\"\n-See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues.\n+See <\\fBhttps://github.com/rust-lang/rust/issues\\fR> for issues.\n \n .SH \"AUTHOR\"\n See \\fBAUTHORS.txt\\fR in the Rust source distribution."}, {"sha": "b56f4d7a25f203564b532ade32aab3a90217fcc4", "filename": "mk/main.mk", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -360,10 +360,10 @@ endef\n #   contains spaces which confuse make.\n # * `LD_LIBRARY_PATH_ENV_HOSTDIR`: the entry to add to lookup path for the host\n # * `LD_LIBRARY_PATH_ENV_TARGETDIR`: the entry to add to lookup path for target\n-# \n+#\n # Below that, HOST_RPATH_VAR and TARGET_RPATH_VAR are defined in terms of the\n # above settings.\n-# \n+#\n define SREQ_CMDS\n \n ifeq ($$(OSTYPE_$(3)),apple-darwin)\n@@ -382,9 +382,9 @@ LD_LIBRARY_PATH_ENV_TARGETDIR$(1)_T_$(2)_H_$(3) := \\\n     $$(CURDIR)/$$(TLIB1_T_$(2)_H_$(CFG_BUILD))\n \n HOST_RPATH_VAR$(1)_T_$(2)_H_$(3) := \\\n-  $$(LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3))=$$$$$$(LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3)):$$(LD_LIBRARY_PATH_ENV_HOSTDIR$(1)_T_$(2)_H_$(3))\n+  $$(LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3))=$$(LD_LIBRARY_PATH_ENV_HOSTDIR$(1)_T_$(2)_H_$(3)):$$$$$$(LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3))\n TARGET_RPATH_VAR$(1)_T_$(2)_H_$(3) := \\\n-  $$(LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3))=$$$$$$(LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3)):$$(LD_LIBRARY_PATH_ENV_TARGETDIR$(1)_T_$(2)_H_$(3))\n+  $$(LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3))=$$(LD_LIBRARY_PATH_ENV_TARGETDIR$(1)_T_$(2)_H_$(3)):$$$$$$(LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3))\n \n RPATH_VAR$(1)_T_$(2)_H_$(3) := $$(HOST_RPATH_VAR$(1)_T_$(2)_H_$(3))\n "}, {"sha": "49b9d2aad8d2906026fe17f0468d4092e3e11a4d", "filename": "mk/rt.mk", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -306,6 +306,8 @@ $$(JEMALLOC_LOCAL_$(1)): $$(JEMALLOC_DEPS) $$(MKFILE_DEPS)\n \t\tEXTRA_CFLAGS=\"$$(CFG_CFLAGS_$(1)) $$(CFG_JEMALLOC_CFLAGS_$(1)) -g1\"\n \t$$(Q)$$(MAKE) -C \"$$(JEMALLOC_BUILD_DIR_$(1))\" build_lib_static\n \n+ifeq ($$(CFG_DISABLE_JEMALLOC),)\n+RUSTFLAGS_alloc := --cfg jemalloc\n ifeq ($(1),$$(CFG_BUILD))\n ifneq ($$(CFG_JEMALLOC_ROOT),)\n $$(JEMALLOC_LIB_$(1)): $$(CFG_JEMALLOC_ROOT)/libjemalloc_pic.a\n@@ -319,6 +321,10 @@ else\n $$(JEMALLOC_LIB_$(1)): $$(JEMALLOC_LOCAL_$(1))\n \t$$(Q)cp $$< $$@\n endif\n+else\n+$$(JEMALLOC_LIB_$(1)): $$(MKFILE_DEPS)\n+\t$$(Q)touch $$@\n+endif\n \n ################################################################################\n # compiler-rt"}, {"sha": "0f63ef9a430d0424323b0f69c8b55f9a664d8e90", "filename": "mk/target.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -84,6 +84,7 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4):\t\t\t\t    \\\n \t\t-L \"$$(RT_OUTPUT_DIR_$(2))\" \\\n \t\t-L \"$$(LLVM_LIBDIR_$(2))\" \\\n \t\t-L \"$$(dir $$(LLVM_STDCPP_LOCATION_$(2)))\" \\\n+\t\t$$(RUSTFLAGS_$(4)) \\\n \t\t--out-dir $$(@D) $$<\n \t@touch $$@\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES,\\"}, {"sha": "1989d6ef86797855d1f738fb2d2dfccb3f0dfb1f", "filename": "mk/tests.mk", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -91,7 +91,8 @@ endif\n define DEF_TARGET_COMMANDS\n \n ifdef CFG_UNIXY_$(1)\n-  CFG_RUN_TEST_$(1)=$$(call CFG_RUN_$(1),,$$(CFG_VALGRIND) $$(1))\n+  CFG_RUN_TEST_$(1)=$$(TARGET_RPATH_VAR$$(2)_T_$$(3)_H_$$(4)) \\\n+\t  $$(call CFG_RUN_$(1),,$$(CFG_VALGRIND) $$(1))\n endif\n \n ifdef CFG_WINDOWSY_$(1)\n@@ -105,13 +106,13 @@ ifdef CFG_WINDOWSY_$(1)\n                $$(if $$(findstring stage3,$$(1)), \\\n                     stage3/$$(CFG_LIBDIR_RELATIVE), \\\n                )))))/rustlib/$$(CFG_BUILD)/lib\n-  CFG_RUN_TEST_$(1)=$$(call CFG_RUN_$(1),$$(call CFG_TESTLIB_$(1),$$(1),$$(3)),$$(1))\n+  CFG_RUN_TEST_$(1)=$$(call CFG_RUN_$(1),$$(call CFG_TESTLIB_$(1),$$(1),$$(4)),$$(1))\n endif\n \n # Run the compiletest runner itself under valgrind\n ifdef CTEST_VALGRIND\n CFG_RUN_CTEST_$(1)=$$(RPATH_VAR$$(1)_T_$$(3)_H_$$(3)) \\\n-      $$(call CFG_RUN_TEST_$$(CFG_BUILD),$$(2),$$(3))\n+      $$(call CFG_RUN_TEST_$$(CFG_BUILD),$$(3),$$(4))\n else\n CFG_RUN_CTEST_$(1)=$$(RPATH_VAR$$(1)_T_$$(3)_H_$$(3)) \\\n       $$(call CFG_RUN_$$(CFG_BUILD),$$(TLIB$$(1)_T_$$(3)_H_$$(3)),$$(2))\n@@ -375,7 +376,8 @@ $(3)/stage$(1)/test/$(4)test-$(2)$$(X_$(2)):\t\t\t\t\\\n \t@$$(call E, rustc: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\t\\\n \t\t-L \"$$(RT_OUTPUT_DIR_$(2))\"\t\t\\\n-\t\t-L \"$$(LLVM_LIBDIR_$(2))\"\n+\t\t-L \"$$(LLVM_LIBDIR_$(2))\"\t\t\\\n+\t\t$$(RUSTFLAGS_$(4))\n \n endef\n \n@@ -391,7 +393,7 @@ check-stage$(1)-T-$(2)-H-$(3)-$(4)-exec: $$(call TEST_OK_FILE,$(1),$(2),$(3),$(4\n $$(call TEST_OK_FILE,$(1),$(2),$(3),$(4)): \\\n \t\t$(3)/stage$(1)/test/$(4)test-$(2)$$(X_$(2))\n \t@$$(call E, run: $$<)\n-\t$$(Q)$$(call CFG_RUN_TEST_$(2),$$<,$(2),$(3)) $$(TESTARGS) \\\n+\t$$(Q)$$(call CFG_RUN_TEST_$(2),$$<,$(1),$(2),$(3)) $$(TESTARGS) \\\n \t    --logfile $$(call TEST_LOG_FILE,$(1),$(2),$(3),$(4)) \\\n \t    $$(call CRATE_TEST_EXTRA_ARGS,$(1),$(2),$(3),$(4)) \\\n \t    && touch $$@"}, {"sha": "797477d29202d57d00c5eb0033059fbceef68c16", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -13,42 +13,41 @@ use std::str;\n use std::io::process::{ProcessExit, Command, Process, ProcessOutput};\n use std::dynamic_lib::DynamicLibrary;\n \n-fn target_env(lib_path: &str, prog: &str) -> Vec<(String, String)> {\n-    let prog = if cfg!(windows) {prog.slice_to(prog.len() - 4)} else {prog};\n-    let mut aux_path = prog.to_string();\n-    aux_path.push_str(\".libaux\");\n-\n+fn target_env(lib_path: &str, aux_path: Option<&str>) -> Vec<(String, String)> {\n     // Need to be sure to put both the lib_path and the aux path in the dylib\n     // search path for the child.\n     let mut path = DynamicLibrary::search_path();\n-    path.insert(0, Path::new(aux_path));\n+    match aux_path {\n+        Some(p) => path.insert(0, Path::new(p)),\n+        None => {}\n+    }\n     path.insert(0, Path::new(lib_path));\n \n     // Remove the previous dylib search path var\n     let var = DynamicLibrary::envvar();\n-    let mut env: Vec<(String,String)> =\n-        os::env().move_iter().map(|(a,b)|(a.to_string(), b.to_string())).collect();\n+    let mut env: Vec<(String,String)> = os::env();\n     match env.iter().position(|&(ref k, _)| k.as_slice() == var) {\n         Some(i) => { env.remove(i); }\n         None => {}\n     }\n \n     // Add the new dylib search path var\n     let newpath = DynamicLibrary::create_path(path.as_slice());\n-    env.push((var.to_string(),\n-              str::from_utf8(newpath.as_slice()).unwrap().to_string()));\n+    let newpath = str::from_utf8(newpath.as_slice()).unwrap().to_string();\n+    env.push((var.to_string(), newpath));\n     return env;\n }\n \n pub struct Result {pub status: ProcessExit, pub out: String, pub err: String}\n \n pub fn run(lib_path: &str,\n            prog: &str,\n+           aux_path: Option<&str>,\n            args: &[String],\n            env: Vec<(String, String)> ,\n            input: Option<String>) -> Option<Result> {\n \n-    let env = env.clone().append(target_env(lib_path, prog).as_slice());\n+    let env = env.clone().append(target_env(lib_path, aux_path).as_slice());\n     match Command::new(prog).args(args).env(env.as_slice()).spawn() {\n         Ok(mut process) => {\n             for input in input.iter() {\n@@ -69,11 +68,12 @@ pub fn run(lib_path: &str,\n \n pub fn run_background(lib_path: &str,\n            prog: &str,\n+           aux_path: Option<&str>,\n            args: &[String],\n            env: Vec<(String, String)> ,\n            input: Option<String>) -> Option<Process> {\n \n-    let env = env.clone().append(target_env(lib_path, prog).as_slice());\n+    let env = env.clone().append(target_env(lib_path, aux_path).as_slice());\n     match Command::new(prog).args(args).env(env.as_slice()).spawn() {\n         Ok(mut process) => {\n             for input in input.iter() {"}, {"sha": "1e07068dd6f6294fdf14fd246cce9ea7db96f0c5", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -230,6 +230,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n                     testfile: &Path,\n                     src: String,\n                     pretty_type: &str) -> ProcRes {\n+        let aux_dir = aux_output_dir_name(config, testfile);\n         compose_and_run(config,\n                         testfile,\n                         make_pp_args(config,\n@@ -238,6 +239,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                      pretty_type.to_string()),\n                         props.exec_env.clone(),\n                         config.compile_lib_path.as_slice(),\n+                        Some(aux_dir.as_str().unwrap()),\n                         Some(src))\n     }\n \n@@ -354,6 +356,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n             procsrv::run(\"\",\n                          config.adb_path.as_slice(),\n+                         None,\n                          [\n                             \"push\".to_string(),\n                             exe_file.as_str().unwrap().to_string(),\n@@ -365,6 +368,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n             procsrv::run(\"\",\n                          config.adb_path.as_slice(),\n+                         None,\n                          [\n                             \"forward\".to_string(),\n                             \"tcp:5039\".to_string(),\n@@ -385,6 +389,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             let mut process = procsrv::run_background(\"\",\n                                                       config.adb_path\n                                                             .as_slice(),\n+                                                      None,\n                                                       [\n                                                         \"shell\".to_string(),\n                                                         adb_arg.clone()\n@@ -425,6 +430,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                 status\n             } = procsrv::run(\"\",\n                              gdb_path.as_slice(),\n+                             None,\n                              debugger_opts.as_slice(),\n                              vec!((\"\".to_string(), \"\".to_string())),\n                              None)\n@@ -486,7 +492,8 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                                   testfile,\n                                                   proc_args,\n                                                   Vec::new(),\n-                                                  \"\",\n+                                                  config.run_lib_path.as_slice(),\n+                                                  None,\n                                                   None);\n         }\n     }\n@@ -994,11 +1001,13 @@ fn exec_compiled_test(config: &Config, props: &TestProps,\n         }\n \n         _=> {\n+            let aux_dir = aux_output_dir_name(config, testfile);\n             compose_and_run(config,\n                             testfile,\n                             make_run_args(config, props, testfile),\n                             env,\n                             config.run_lib_path.as_slice(),\n+                            Some(aux_dir.as_str().unwrap()),\n                             None)\n         }\n     }\n@@ -1045,6 +1054,7 @@ fn compose_and_run_compiler(\n                                      aux_args,\n                                      Vec::new(),\n                                      config.compile_lib_path.as_slice(),\n+                                     Some(aux_dir.as_str().unwrap()),\n                                      None);\n         if !auxres.status.success() {\n             fatal_proc_rec(\n@@ -1066,6 +1076,7 @@ fn compose_and_run_compiler(\n                     args,\n                     Vec::new(),\n                     config.compile_lib_path.as_slice(),\n+                    Some(aux_dir.as_str().unwrap()),\n                     input)\n }\n \n@@ -1078,9 +1089,10 @@ fn compose_and_run(config: &Config, testfile: &Path,\n                    ProcArgs{ args, prog }: ProcArgs,\n                    procenv: Vec<(String, String)> ,\n                    lib_path: &str,\n+                   aux_path: Option<&str>,\n                    input: Option<String>) -> ProcRes {\n     return program_output(config, testfile, lib_path,\n-                          prog, args, procenv, input);\n+                          prog, aux_path, args, procenv, input);\n }\n \n enum TargetLocation {\n@@ -1189,7 +1201,8 @@ fn split_maybe_args(argstr: &Option<String>) -> Vec<String> {\n }\n \n fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: String,\n-                  args: Vec<String> , env: Vec<(String, String)> ,\n+                  aux_path: Option<&str>, args: Vec<String>,\n+                  env: Vec<(String, String)>,\n                   input: Option<String>) -> ProcRes {\n     let cmdline =\n         {\n@@ -1205,6 +1218,7 @@ fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: String\n         status\n     } = procsrv::run(lib_path,\n                      prog.as_slice(),\n+                     aux_path,\n                      args.as_slice(),\n                      env,\n                      input).expect(format!(\"failed to exec `{}`\", prog).as_slice());\n@@ -1326,6 +1340,7 @@ fn _arm_exec_compiled_test(config: &Config,\n     // copy to target\n     let copy_result = procsrv::run(\"\",\n                                    config.adb_path.as_slice(),\n+                                   None,\n                                    [\n                                     \"push\".to_string(),\n                                     args.prog.clone(),\n@@ -1361,6 +1376,7 @@ fn _arm_exec_compiled_test(config: &Config,\n     }\n     procsrv::run(\"\",\n                  config.adb_path.as_slice(),\n+                 None,\n                  runargs.as_slice(),\n                  vec!((\"\".to_string(), \"\".to_string())), Some(\"\".to_string()))\n         .expect(format!(\"failed to exec `{}`\", config.adb_path).as_slice());\n@@ -1374,6 +1390,7 @@ fn _arm_exec_compiled_test(config: &Config,\n     let procsrv::Result{ out: exitcode_out, err: _, status: _ } =\n         procsrv::run(\"\",\n                      config.adb_path.as_slice(),\n+                     None,\n                      runargs.as_slice(),\n                      vec!((\"\".to_string(), \"\".to_string())),\n                      Some(\"\".to_string()))\n@@ -1397,6 +1414,7 @@ fn _arm_exec_compiled_test(config: &Config,\n     let procsrv::Result{ out: stdout_out, err: _, status: _ } =\n         procsrv::run(\"\",\n                      config.adb_path.as_slice(),\n+                     None,\n                      runargs.as_slice(),\n                      vec!((\"\".to_string(), \"\".to_string())),\n                      Some(\"\".to_string()))\n@@ -1411,6 +1429,7 @@ fn _arm_exec_compiled_test(config: &Config,\n     let procsrv::Result{ out: stderr_out, err: _, status: _ } =\n         procsrv::run(\"\",\n                      config.adb_path.as_slice(),\n+                     None,\n                      runargs.as_slice(),\n                      vec!((\"\".to_string(), \"\".to_string())),\n                      Some(\"\".to_string()))\n@@ -1438,6 +1457,7 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let copy_result = procsrv::run(\"\",\n                                            config.adb_path.as_slice(),\n+                                           None,\n                                            [\n                                             \"push\".to_string(),\n                                             file.as_str()\n@@ -1505,7 +1525,7 @@ fn compile_cc_with_clang_and_save_bitcode(config: &Config, _props: &TestProps,\n                    bitcodefile.as_str().unwrap().to_string(),\n                    testcc.as_str().unwrap().to_string())\n     };\n-    compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n+    compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None, None)\n }\n \n fn extract_function_from_bitcode(config: &Config, _props: &TestProps,\n@@ -1522,7 +1542,7 @@ fn extract_function_from_bitcode(config: &Config, _props: &TestProps,\n                    format!(\"-o={}\", extracted_bc.as_str().unwrap()),\n                    bitcodefile.as_str().unwrap().to_string())\n     };\n-    compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n+    compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None, None)\n }\n \n fn disassemble_extract(config: &Config, _props: &TestProps,\n@@ -1538,7 +1558,7 @@ fn disassemble_extract(config: &Config, _props: &TestProps,\n         args: vec!(format!(\"-o={}\", extracted_ll.as_str().unwrap()),\n                    extracted_bc.as_str().unwrap().to_string())\n     };\n-    compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n+    compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None, None)\n }\n \n "}, {"sha": "9057c13505741af2f8596ff0bf46276d673a0154", "filename": "src/doc/complement-bugreport.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Fcomplement-bugreport.md", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Fcomplement-bugreport.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-bugreport.md?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -22,7 +22,7 @@ If you don't have enough time for a search, then don't worry about that. Just su\n the bug. If it's a duplicate, somebody will notice that and close it during triage.\n \n If you have the time for it, it would be useful to type the text of the error\n-message you got [into the issue tracker search box](https://github.com/mozilla/rust/issues)\n+message you got [into the issue tracker search box](https://github.com/rust-lang/rust/issues)\n to see if there's an existing bug that resembles your problem. If there is,\n and it's an open bug, you can comment on that issue and say you are also affected.\n This will encourage the devs to fix it. But again, don't let this stop you from"}, {"sha": "c01f38a9af6ba84ad7195e0c7fe64d8acdfd078b", "filename": "src/doc/complement-design-faq.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Fcomplement-design-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Fcomplement-design-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-design-faq.md?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -111,14 +111,14 @@ match val.do_something() {\n [#3101][iss] is the issue that proposed making this the only behavior, with\n rationale and discussion.\n \n-[iss]: https://github.com/mozilla/rust/issues/3101\n+[iss]: https://github.com/rust-lang/rust/issues/3101\n \n ## No guaranteed tail-call optimization\n \n-In general, tail-call optimization is not guaranteed: see for a detailed\n-explanation with references. There is a [proposed extension][tce] that would\n-allow tail-call elimination in certain contexts. The compiler is still free to\n-optimize tail-calls [when it pleases][sco], however.\n+In general, tail-call optimization is not guaranteed: see [here][tml] for a\n+detailed explanation with references. There is a [proposed extension][tce] that\n+would allow tail-call elimination in certain contexts. The compiler is still\n+free to optimize tail-calls [when it pleases][sco], however.\n \n [tml]: https://mail.mozilla.org/pipermail/rust-dev/2013-April/003557.html\n [sco]: http://llvm.org/docs/CodeGenerator.html#sibling-call-optimization"}, {"sha": "ae58db9077cabd418abd9d673333244aefd06e24", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -5,9 +5,9 @@\n \n There aren't many large programs yet. The Rust [compiler][rustc], 60,000+ lines at the time of writing, is written in Rust. As the oldest body of Rust code it has gone through many iterations of the language, and some parts are nicer to look at than others. It may not be the best code to learn from, but [borrowck] and [resolve] were written recently.\n \n-[rustc]: https://github.com/mozilla/rust/tree/master/src/librustc\n-[resolve]: https://github.com/mozilla/rust/blob/master/src/librustc/middle/resolve.rs\n-[borrowck]: https://github.com/mozilla/rust/blob/master/src/librustc/middle/borrowck/\n+[rustc]: https://github.com/rust-lang/rust/tree/master/src/librustc\n+[resolve]: https://github.com/rust-lang/rust/blob/master/src/librustc/middle/resolve.rs\n+[borrowck]: https://github.com/rust-lang/rust/blob/master/src/librustc/middle/borrowck/\n \n A research browser engine called [Servo][servo], currently 30,000+ lines across more than a dozen crates, will be exercising a lot of Rust's distinctive type-system and concurrency features, and integrating many native libraries.\n \n@@ -21,9 +21,9 @@ Some examples that demonstrate different aspects of the language:\n * The extra library's [json] module. Enums and pattern matching\n \n [sprocketnes]: https://github.com/pcwalton/sprocketnes\n-[hash]: https://github.com/mozilla/rust/blob/master/src/libstd/hash/mod.rs\n-[HashMap]: https://github.com/mozilla/rust/blob/master/src/libcollections/hashmap.rs\n-[json]: https://github.com/mozilla/rust/blob/master/src/libserialize/json.rs\n+[hash]: https://github.com/rust-lang/rust/blob/master/src/libstd/hash/mod.rs\n+[HashMap]: https://github.com/rust-lang/rust/blob/master/src/libcollections/hashmap.rs\n+[json]: https://github.com/rust-lang/rust/blob/master/src/libserialize/json.rs\n \n You may also be interested in browsing [GitHub's Rust][github-rust] page.\n \n@@ -33,8 +33,8 @@ You may also be interested in browsing [GitHub's Rust][github-rust] page.\n \n Yes. All development happens in lock-step on all 3 target platforms. Using MinGW, not Cygwin. Note that the windows implementation currently has some limitations: in particular 64-bit build is [not fully supported yet][win64], and all executables created by rustc [depends on libgcc DLL at runtime][libgcc].\n \n-[win64]: https://github.com/mozilla/rust/issues/1237\n-[libgcc]: https://github.com/mozilla/rust/issues/11782\n+[win64]: https://github.com/rust-lang/rust/issues/1237\n+[libgcc]: https://github.com/rust-lang/rust/issues/11782\n \n ## Is it OO? How do I do this thing I normally do in an OO language?\n "}, {"sha": "addd767235c5d3f447738bdffa27c091c7266d0e", "filename": "src/doc/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -75,4 +75,4 @@ li {list-style-type: none; }\n     * [`#rust-internals`](http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust-internals) - compiler and libraries\n     * [`#rust-osdev`](http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust-osdev) - operating system development\n * The Rust community on [Reddit](http://reddit.com/r/rust)\n-* The Rust [wiki](http://github.com/mozilla/rust/wiki)\n+* The Rust [wiki](http://github.com/rust-lang/rust/wiki)"}, {"sha": "d30d7122986b6c54b4d330928b2378c3ec566f33", "filename": "src/doc/intro.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -361,7 +361,7 @@ fn main() {\n \n             // This is ugly for now, but will be replaced by\n             // `numbers[num as uint] += 1` in the near future.\n-            // See: https://github.com/mozilla/rust/issues/6515\n+            // See: https://github.com/rust-lang/rust/issues/6515\n             *numbers.get_mut(num as uint) = *numbers.get_mut(num as uint) + 1;\n \n             println!(\"{}\", *numbers.get(num as uint));"}, {"sha": "f28abcf1d524fcc7e2a512dd291c348413b082fa", "filename": "src/doc/po/ja/complement-lang-faq.md.po", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Fpo%2Fja%2Fcomplement-lang-faq.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Fpo%2Fja%2Fcomplement-lang-faq.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo%2Fja%2Fcomplement-lang-faq.md.po?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -34,46 +34,46 @@ msgstr \"## \u69cb\u9020\u4f53\"\n #: src/doc/complement-lang-faq.md:83\n #, fuzzy\n #| msgid \"\"\n-#| \"[bug-3319]: https://github.com/mozilla/rust/issues/3319 [wiki-start]: \"\n-#| \"https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\"\n+#| \"[bug-3319]: https://github.com/rust-lang/rust/issues/3319 [wiki-start]: \"\n+#| \"https://github.com/rust-lang/rust/wiki/Note-getting-started-developing-Rust\"\n msgid \"\"\n-\"[rustc]: https://github.com/mozilla/rust/tree/master/src/librustc [resolve]: \"\n-\"https://github.com/mozilla/rust/blob/master/src/librustc/middle/resolve.rs \"\n-\"[borrowck]: https://github.com/mozilla/rust/blob/master/src/librustc/middle/\"\n+\"[rustc]: https://github.com/rust-lang/rust/tree/master/src/librustc [resolve]: \"\n+\"https://github.com/rust-lang/rust/blob/master/src/librustc/middle/resolve.rs \"\n+\"[borrowck]: https://github.com/rust-lang/rust/blob/master/src/librustc/middle/\"\n \"borrowck/\"\n msgstr \"\"\n-\"[bug-3319]: https://github.com/mozilla/rust/issues/3319\\n\"\n-\"[wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-\"\n+\"[bug-3319]: https://github.com/rust-lang/rust/issues/3319\\n\"\n+\"[wiki-start]: https://github.com/rust-lang/rust/wiki/Note-getting-started-\"\n \"developing-Rust\"\n \n #. type: Plain text\n #: src/doc/complement-lang-faq.md:99\n #, fuzzy\n #| msgid \"\"\n-#| \"[bug-3319]: https://github.com/mozilla/rust/issues/3319 [wiki-start]: \"\n-#| \"https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\"\n+#| \"[bug-3319]: https://github.com/rust-lang/rust/issues/3319 [wiki-start]: \"\n+#| \"https://github.com/rust-lang/rust/wiki/Note-getting-started-developing-Rust\"\n msgid \"\"\n \"[sprocketnes]: https://github.com/pcwalton/sprocketnes [hash]: https://\"\n-\"github.com/mozilla/rust/blob/master/src/libstd/hash.rs [HashMap]: https://\"\n-\"github.com/mozilla/rust/blob/master/src/libstd/hashmap.rs [json]: https://\"\n-\"github.com/mozilla/rust/blob/master/src/libextra/json.rs\"\n+\"github.com/rust-lang/rust/blob/master/src/libstd/hash.rs [HashMap]: https://\"\n+\"github.com/rust-lang/rust/blob/master/src/libstd/hashmap.rs [json]: https://\"\n+\"github.com/rust-lang/rust/blob/master/src/libextra/json.rs\"\n msgstr \"\"\n-\"[bug-3319]: https://github.com/mozilla/rust/issues/3319\\n\"\n-\"[wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-\"\n+\"[bug-3319]: https://github.com/rust-lang/rust/issues/3319\\n\"\n+\"[wiki-start]: https://github.com/rust-lang/rust/wiki/Note-getting-started-\"\n \"developing-Rust\"\n \n #. type: Plain text\n #: src/doc/complement-lang-faq.md:110\n #, fuzzy\n #| msgid \"\"\n-#| \"[bug-3319]: https://github.com/mozilla/rust/issues/3319 [wiki-start]: \"\n-#| \"https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\"\n+#| \"[bug-3319]: https://github.com/rust-lang/rust/issues/3319 [wiki-start]: \"\n+#| \"https://github.com/rust-lang/rust/wiki/Note-getting-started-developing-Rust\"\n msgid \"\"\n-\"[unwind]: https://github.com/mozilla/rust/issues/908 [libgcc]: https://\"\n-\"github.com/mozilla/rust/issues/1603\"\n+\"[unwind]: https://github.com/rust-lang/rust/issues/908 [libgcc]: https://\"\n+\"github.com/rust-lang/rust/issues/1603\"\n msgstr \"\"\n-\"[bug-3319]: https://github.com/mozilla/rust/issues/3319\\n\"\n-\"[wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-\"\n+\"[bug-3319]: https://github.com/rust-lang/rust/issues/3319\\n\"\n+\"[wiki-start]: https://github.com/rust-lang/rust/wiki/Note-getting-started-\"\n \"developing-Rust\"\n \n #. type: Plain text"}, {"sha": "68c32ae9704a36bc74a66ffe7f8447a4549dfe8d", "filename": "src/doc/po/ja/tutorial.md.po", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -303,15 +303,15 @@ msgstr \"\"\n #: src/doc/tutorial.md:92\n #, fuzzy\n #| msgid \"\"\n-#| \"[bug-3319]: https://github.com/mozilla/rust/issues/3319 [wiki-start]: \"\n-#| \"https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\"\n+#| \"[bug-3319]: https://github.com/rust-lang/rust/issues/3319 [wiki-start]: \"\n+#| \"https://github.com/rust-lang/rust/wiki/Note-getting-started-developing-Rust\"\n msgid \"\"\n-\"[bug-3319]: https://github.com/mozilla/rust/issues/3319 [wiki-start]: \"\n-\"https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust \"\n-\"[git]: https://github.com/mozilla/rust.git\"\n+\"[bug-3319]: https://github.com/rust-lang/rust/issues/3319 [wiki-start]: \"\n+\"https://github.com/rust-lang/rust/wiki/Note-getting-started-developing-Rust \"\n+\"[git]: https://github.com/rust-lang/rust.git\"\n msgstr \"\"\n-\"[bug-3319]: https://github.com/mozilla/rust/issues/3319\\n\"\n-\"[wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-\"\n+\"[bug-3319]: https://github.com/rust-lang/rust/issues/3319\\n\"\n+\"[wiki-start]: https://github.com/rust-lang/rust/wiki/Note-getting-started-\"\n \"developing-Rust\"\n \n #. type: Plain text"}, {"sha": "b1f72f36ecb3a3b2a1e77b1396e913595d566b82", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -90,8 +90,8 @@ Snapshot binaries are currently built and tested on several platforms:\n You may find that other platforms work, but these are our \"tier 1\"\n supported build environments that are most likely to work.\n \n-[wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n-[git]: https://github.com/mozilla/rust.git\n+[wiki-start]: https://github.com/rust-lang/rust/wiki/Note-getting-started-developing-Rust\n+[git]: https://github.com/rust-lang/rust.git\n [rust-install]: http://www.rust-lang.org/install.html\n \n To build from source you will also need the following prerequisite\n@@ -183,7 +183,7 @@ There is ctags support via `src/etc/ctags.rust`, but many other\n tools and editors are not yet supported. If you end up writing a Rust\n mode for your favorite editor, let us know so that we can link to it.\n \n-[sublime]: http://github.com/dbp/sublime-rust\n+[sublime]: http://github.com/jhasse/sublime-rust\n [sublime-pkg]: http://wbond.net/sublime_packages/package_control\n \n # Syntax basics\n@@ -3345,6 +3345,6 @@ There is further documentation on the [wiki], however those tend to be even more\n [testing]: guide-testing.html\n [runtime]: guide-runtime.html\n [rustdoc]: rustdoc.html\n-[wiki]: https://github.com/mozilla/rust/wiki/Docs\n+[wiki]: https://github.com/rust-lang/rust/wiki/Docs\n \n-[wiki-packages]: https://github.com/mozilla/rust/wiki/Doc-packages,-editors,-and-other-tools\n+[wiki-packages]: https://github.com/rust-lang/rust/wiki/Doc-packages,-editors,-and-other-tools"}, {"sha": "49f0b183e16950647709c809220374c05c9338cf", "filename": "src/doc/version_info.html.template", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Fversion_info.html.template", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fdoc%2Fversion_info.html.template", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fversion_info.html.template?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -1,6 +1,6 @@\n <div id=\"versioninfo\">\n   <img src=\"http://www.rust-lang.org/logos/rust-logo-32x32-blk.png\" width=\"32\" height=\"32\" alt><br>\n   <span class=\"white-sticker\"><a href=\"http://rust-lang.org\">Rust</a> VERSION</span><br>\n-  <a href=\"http://github.com/mozilla/rust/commit/STAMP\"\n+  <a href=\"http://github.com/rust-lang/rust/commit/STAMP\"\n     class=\"hash white-sticker\">SHORT_HASH</a>\n </div>"}, {"sha": "818595b9dc1577dc7570dbf78e2dfcbe50091c8f", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -2,7 +2,7 @@\n \n ;; Version: 0.2.0\n ;; Author: Mozilla\n-;; Url: https://github.com/mozilla/rust\n+;; Url: https://github.com/rust-lang/rust\n ;; Keywords: languages\n \n ;;; Commentary:"}, {"sha": "bf421513cba75da6023dcbd93529a44bf601e6f0", "filename": "src/etc/generate-keyword-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fetc%2Fgenerate-keyword-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fetc%2Fgenerate-keyword-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-keyword-tests.py?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -13,7 +13,7 @@\n This script takes a list of keywords and generates a testcase, that checks\n if using the keyword as identifier fails, for every keyword. The generate\n test files are set read-only.\n-Test for https://github.com/mozilla/rust/issues/2275\n+Test for https://github.com/rust-lang/rust/issues/2275\n \n sample usage: src/etc/generate-keyword-tests.py as break\n \"\"\""}, {"sha": "4ec4f33d54559c991b196305e6c7af0a2dfe0b16", "filename": "src/etc/vim/plugin/rust.vim", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fetc%2Fvim%2Fplugin%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fetc%2Fvim%2Fplugin%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fplugin%2Frust.vim?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -0,0 +1,22 @@\n+\" Vim syntastic plugin helper\n+\" Language:     Rust\n+\" Maintainer:   Andrew Gallant <jamslam@gmail.com>\n+\n+if exists(\"g:loaded_syntastic_rust_filetype\")\n+  finish\n+endif\n+let g:loaded_syntastic_rust_filetype = 1\n+let s:save_cpo = &cpo\n+set cpo&vim\n+\n+\" This is to let Syntastic know about the Rust filetype.\n+\" It enables tab completion for the 'SyntasticInfo' command.\n+\" (This does not actually register the syntax checker.)\n+if exists('g:syntastic_extra_filetypes')\n+    call add(g:syntastic_extra_filetypes, 'rust')\n+else\n+    let g:syntastic_extra_filetypes = ['rust']\n+endif\n+\n+let &cpo = s:save_cpo\n+unlet s:save_cpo"}, {"sha": "5cd419ca732da3cecd7aeec0c8f86e6ff19f96ea", "filename": "src/etc/vim/syntax_checkers/rust/rustc.vim", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fetc%2Fvim%2Fsyntax_checkers%2Frust%2Frustc.vim", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fetc%2Fvim%2Fsyntax_checkers%2Frust%2Frustc.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax_checkers%2Frust%2Frustc.vim?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -0,0 +1,35 @@\n+\" Vim syntastic plugin\n+\" Language:     Rust\n+\" Maintainer:   Andrew Gallant <jamslam@gmail.com>\n+\"\n+\" See for details on how to add an external Syntastic checker:\n+\" https://github.com/scrooloose/syntastic/wiki/Syntax-Checker-Guide#external\n+\n+if exists(\"g:loaded_syntastic_rust_rustc_checker\")\n+    finish\n+endif\n+let g:loaded_syntastic_rust_rustc_checker = 1\n+\n+let s:save_cpo = &cpo\n+set cpo&vim\n+\n+function! SyntaxCheckers_rust_rustc_GetLocList() dict\n+    let makeprg = self.makeprgBuild({ 'args': '--parse-only' })\n+\n+    let errorformat  =\n+        \\ '%E%f:%l:%c: %\\d%#:%\\d%# %.%\\{-}error:%.%\\{-} %m,'   .\n+        \\ '%W%f:%l:%c: %\\d%#:%\\d%# %.%\\{-}warning:%.%\\{-} %m,' .\n+        \\ '%C%f:%l %m,' .\n+        \\ '%-Z%.%#'\n+\n+    return SyntasticMake({\n+        \\ 'makeprg': makeprg,\n+        \\ 'errorformat': errorformat })\n+endfunction\n+\n+call g:SyntasticRegistry.CreateAndRegisterChecker({\n+    \\ 'filetype': 'rust',\n+    \\ 'name': 'rustc'})\n+\n+let &cpo = s:save_cpo\n+unlet s:save_cpo"}, {"sha": "79a616b9555aa1a80c8688c424ab29ea3ccb6226", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 231, "deletions": 66, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -9,111 +9,83 @@\n // except according to those terms.\n \n // FIXME: #13994: port to the sized deallocation API when available\n-// FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias` and `nonnull`\n-\n-use core::intrinsics::{abort, cttz32};\n-use core::option::{None, Option};\n-use core::ptr::{RawPtr, mut_null, null};\n-use libc::{c_char, c_int, c_void, size_t};\n+// FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias`\n+//                and `nonnull`\n \n #[cfg(not(test))] use core::raw;\n #[cfg(not(test))] use util;\n \n-#[link(name = \"jemalloc\", kind = \"static\")]\n-extern {\n-    fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;\n-    fn je_rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n-    fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n-    fn je_dallocx(ptr: *mut c_void, flags: c_int);\n-    fn je_nallocx(size: size_t, flags: c_int) -> size_t;\n-    fn je_malloc_stats_print(write_cb: Option<extern \"C\" fn(cbopaque: *mut c_void, *c_char)>,\n-                             cbopaque: *mut c_void,\n-                             opts: *c_char);\n-}\n-\n-// -lpthread needs to occur after -ljemalloc, the earlier argument isn't enough\n-#[cfg(not(windows), not(target_os = \"android\"))]\n-#[link(name = \"pthread\")]\n-extern {}\n-\n-// MALLOCX_ALIGN(a) macro\n-#[inline(always)]\n-fn mallocx_align(a: uint) -> c_int { unsafe { cttz32(a as u32) as c_int } }\n-\n /// Return a pointer to `size` bytes of memory.\n ///\n-/// Behavior is undefined if the requested size is 0 or the alignment is not a power of 2. The\n-/// alignment must be no larger than the largest supported page size on the platform.\n+/// Behavior is undefined if the requested size is 0 or the alignment is not a\n+/// power of 2. The alignment must be no larger than the largest supported page\n+/// size on the platform.\n #[inline]\n pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n-    let ptr = je_mallocx(size as size_t, mallocx_align(align)) as *mut u8;\n-    if ptr.is_null() {\n-        abort()\n-    }\n-    ptr\n+    imp::allocate(size, align)\n }\n \n-/// Extend or shrink the allocation referenced by `ptr` to `size` bytes of memory.\n+/// Extend or shrink the allocation referenced by `ptr` to `size` bytes of\n+/// memory.\n ///\n-/// Behavior is undefined if the requested size is 0 or the alignment is not a power of 2. The\n-/// alignment must be no larger than the largest supported page size on the platform.\n+/// Behavior is undefined if the requested size is 0 or the alignment is not a\n+/// power of 2. The alignment must be no larger than the largest supported page\n+/// size on the platform.\n ///\n-/// The `old_size` and `align` parameters are the parameters that were used to create the\n-/// allocation referenced by `ptr`. The `old_size` parameter may also be the value returned by\n-/// `usable_size` for the requested size.\n+/// The `old_size` and `align` parameters are the parameters that were used to\n+/// create the allocation referenced by `ptr`. The `old_size` parameter may also\n+/// be the value returned by `usable_size` for the requested size.\n #[inline]\n-#[allow(unused_variable)] // for the parameter names in the documentation\n-pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint, old_size: uint) -> *mut u8 {\n-    let ptr = je_rallocx(ptr as *mut c_void, size as size_t, mallocx_align(align)) as *mut u8;\n-    if ptr.is_null() {\n-        abort()\n-    }\n-    ptr\n+pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n+                         old_size: uint) -> *mut u8 {\n+    imp::reallocate(ptr, size, align, old_size)\n }\n \n-/// Extend or shrink the allocation referenced by `ptr` to `size` bytes of memory in-place.\n+/// Extend or shrink the allocation referenced by `ptr` to `size` bytes of\n+/// memory in-place.\n ///\n-/// Return true if successful, otherwise false if the allocation was not altered.\n+/// Return true if successful, otherwise false if the allocation was not\n+/// altered.\n ///\n-/// Behavior is undefined if the requested size is 0 or the alignment is not a power of 2. The\n-/// alignment must be no larger than the largest supported page size on the platform.\n+/// Behavior is undefined if the requested size is 0 or the alignment is not a\n+/// power of 2. The alignment must be no larger than the largest supported page\n+/// size on the platform.\n ///\n /// The `old_size` and `align` parameters are the parameters that were used to\n /// create the allocation referenced by `ptr`. The `old_size` parameter may be\n /// any value in range_inclusive(requested_size, usable_size).\n #[inline]\n-#[allow(unused_variable)] // for the parameter names in the documentation\n-pub unsafe fn reallocate_inplace(ptr: *mut u8, size: uint, align: uint, old_size: uint) -> bool {\n-    je_xallocx(ptr as *mut c_void, size as size_t, 0, mallocx_align(align)) == size as size_t\n+pub unsafe fn reallocate_inplace(ptr: *mut u8, size: uint, align: uint,\n+                                 old_size: uint) -> bool {\n+    imp::reallocate_inplace(ptr, size, align, old_size)\n }\n \n /// Deallocate the memory referenced by `ptr`.\n ///\n /// The `ptr` parameter must not be null.\n ///\n-/// The `size` and `align` parameters are the parameters that were used to create the\n-/// allocation referenced by `ptr`. The `size` parameter may also be the value returned by\n-/// `usable_size` for the requested size.\n+/// The `size` and `align` parameters are the parameters that were used to\n+/// create the allocation referenced by `ptr`. The `size` parameter may also be\n+/// the value returned by `usable_size` for the requested size.\n #[inline]\n-#[allow(unused_variable)] // for the parameter names in the documentation\n pub unsafe fn deallocate(ptr: *mut u8, size: uint, align: uint) {\n-    je_dallocx(ptr as *mut c_void, mallocx_align(align))\n+    imp::deallocate(ptr, size, align)\n }\n \n-/// Return the usable size of an allocation created with the specified the `size` and `align`.\n+/// Return the usable size of an allocation created with the specified the\n+/// `size` and `align`.\n #[inline]\n pub fn usable_size(size: uint, align: uint) -> uint {\n-    unsafe { je_nallocx(size as size_t, mallocx_align(align)) as uint }\n+    imp::usable_size(size, align)\n }\n \n /// Print implementation-defined allocator statistics.\n ///\n-/// These statistics may be inconsistent if other threads use the allocator during the call.\n+/// These statistics may be inconsistent if other threads use the allocator\n+/// during the call.\n #[unstable]\n pub fn stats_print() {\n-    unsafe {\n-        je_malloc_stats_print(None, mut_null(), null())\n-    }\n+    imp::stats_print();\n }\n \n // The compiler never calls `exchange_free` on ~ZeroSizeType, so zero-size\n@@ -145,7 +117,8 @@ unsafe fn exchange_free(ptr: *mut u8, size: uint, align: uint) {\n #[lang=\"closure_exchange_malloc\"]\n #[inline]\n #[allow(deprecated)]\n-unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *mut u8 {\n+unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint,\n+                                  align: uint) -> *mut u8 {\n     let total_size = util::get_box_size(size, align);\n     let p = allocate(total_size, 8);\n \n@@ -155,6 +128,198 @@ unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint, align: uin\n     alloc as *mut u8\n }\n \n+#[cfg(jemalloc)]\n+mod imp {\n+    use core::option::{None, Option};\n+    use core::ptr::{RawPtr, mut_null, null};\n+    use core::num::Bitwise;\n+    use libc::{c_char, c_int, c_void, size_t};\n+\n+    #[link(name = \"jemalloc\", kind = \"static\")]\n+    extern {\n+        fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;\n+        fn je_rallocx(ptr: *mut c_void, size: size_t,\n+                      flags: c_int) -> *mut c_void;\n+        fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t,\n+                      flags: c_int) -> size_t;\n+        fn je_dallocx(ptr: *mut c_void, flags: c_int);\n+        fn je_nallocx(size: size_t, flags: c_int) -> size_t;\n+        fn je_malloc_stats_print(write_cb: Option<extern \"C\" fn(cbopaque: *mut c_void, *c_char)>,\n+                                 cbopaque: *mut c_void,\n+                                 opts: *c_char);\n+    }\n+\n+    // -lpthread needs to occur after -ljemalloc, the earlier argument isn't enough\n+    #[cfg(not(windows), not(target_os = \"android\"))]\n+    #[link(name = \"pthread\")]\n+    extern {}\n+\n+    // MALLOCX_ALIGN(a) macro\n+    #[inline(always)]\n+    fn mallocx_align(a: uint) -> c_int { a.trailing_zeros() as c_int }\n+\n+    #[inline]\n+    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+        let ptr = je_mallocx(size as size_t, mallocx_align(align)) as *mut u8;\n+        if ptr.is_null() {\n+            ::oom()\n+        }\n+        ptr\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n+                             _old_size: uint) -> *mut u8 {\n+        let ptr = je_rallocx(ptr as *mut c_void, size as size_t,\n+                             mallocx_align(align)) as *mut u8;\n+        if ptr.is_null() {\n+            ::oom()\n+        }\n+        ptr\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate_inplace(ptr: *mut u8, size: uint, align: uint,\n+                                     _old_size: uint) -> bool {\n+        je_xallocx(ptr as *mut c_void, size as size_t, 0,\n+                   mallocx_align(align)) == size as size_t\n+    }\n+\n+    #[inline]\n+    pub unsafe fn deallocate(ptr: *mut u8, _size: uint, align: uint) {\n+        je_dallocx(ptr as *mut c_void, mallocx_align(align))\n+    }\n+\n+    #[inline]\n+    pub fn usable_size(size: uint, align: uint) -> uint {\n+        unsafe { je_nallocx(size as size_t, mallocx_align(align)) as uint }\n+    }\n+\n+    pub fn stats_print() {\n+        unsafe {\n+            je_malloc_stats_print(None, mut_null(), null())\n+        }\n+    }\n+}\n+\n+#[cfg(not(jemalloc), unix)]\n+mod imp {\n+    use core::mem;\n+    use core::ptr;\n+    use libc;\n+    use libc_heap;\n+\n+    extern {\n+        fn posix_memalign(memptr: *mut *mut libc::c_void,\n+                          align: libc::size_t,\n+                          size: libc::size_t) -> libc::c_int;\n+    }\n+\n+    #[inline]\n+    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+        // The posix_memalign manpage states\n+        //\n+        //      alignment [...] must be a power of and a multiple of\n+        //      sizeof(void *)\n+        //\n+        // The `align` parameter to this function is the *minimum* alignment for\n+        // a block of memory, so we special case everything under `*uint` to\n+        // just pass it to malloc, which is guaranteed to align to at least the\n+        // size of `*uint`.\n+        if align < mem::size_of::<*uint>() {\n+            libc_heap::malloc_raw(size)\n+        } else {\n+            let mut out = 0 as *mut libc::c_void;\n+            let ret = posix_memalign(&mut out,\n+                                     align as libc::size_t,\n+                                     size as libc::size_t);\n+            if ret != 0 {\n+                ::oom();\n+            }\n+            out as *mut u8\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n+                             old_size: uint) -> *mut u8 {\n+        let new_ptr = allocate(size, align);\n+        ptr::copy_memory(new_ptr, ptr as *u8, old_size);\n+        deallocate(ptr, old_size, align);\n+        return new_ptr;\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate_inplace(_ptr: *mut u8, _size: uint, _align: uint,\n+                                     _old_size: uint) -> bool {\n+        false\n+    }\n+\n+    #[inline]\n+    pub unsafe fn deallocate(ptr: *mut u8, _size: uint, _align: uint) {\n+        libc::free(ptr as *mut libc::c_void)\n+    }\n+\n+    #[inline]\n+    pub fn usable_size(size: uint, _align: uint) -> uint {\n+        size\n+    }\n+\n+    pub fn stats_print() {\n+    }\n+}\n+\n+#[cfg(not(jemalloc), windows)]\n+mod imp {\n+    use libc::{c_void, size_t};\n+    use core::ptr::RawPtr;\n+\n+    extern {\n+        fn _aligned_malloc(size: size_t, align: size_t) -> *mut c_void;\n+        fn _aligned_realloc(block: *mut c_void, size: size_t,\n+                            align: size_t) -> *mut c_void;\n+        fn _aligned_free(ptr: *mut c_void);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+        let ptr = _aligned_malloc(size as size_t, align as size_t);\n+        if ptr.is_null() {\n+            ::oom();\n+        }\n+        ptr as *mut u8\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n+                             _old_size: uint) -> *mut u8 {\n+        let ptr = _aligned_realloc(ptr as *mut c_void, size as size_t,\n+                                   align as size_t);\n+        if ptr.is_null() {\n+            ::oom();\n+        }\n+        ptr as *mut u8\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate_inplace(_ptr: *mut u8, _size: uint, _align: uint,\n+                                     _old_size: uint) -> bool {\n+        false\n+    }\n+\n+    #[inline]\n+    pub unsafe fn deallocate(ptr: *mut u8, _size: uint, _align: uint) {\n+        _aligned_free(ptr as *mut c_void)\n+    }\n+\n+    #[inline]\n+    pub fn usable_size(size: uint, _align: uint) -> uint {\n+        size\n+    }\n+\n+    pub fn stats_print() {}\n+}\n+\n #[cfg(test)]\n mod bench {\n     extern crate test;"}, {"sha": "a947378f768c938f9b2014b506044f4a2556de23", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -94,6 +94,14 @@ pub mod owned;\n pub mod arc;\n pub mod rc;\n \n+/// Common OOM routine used by liballoc\n+fn oom() -> ! {\n+    // FIXME(#14674): This really needs to do something other than just abort\n+    //                here, but any printing done must be *guaranteed* to not\n+    //                allocate.\n+    unsafe { core::intrinsics::abort() }\n+}\n+\n // FIXME(#14344): When linking liballoc with libstd, this library will be linked\n //                as an rlib (it only exists as an rlib). It turns out that an\n //                optimized standard library doesn't actually use *any* symbols"}, {"sha": "25938ba0d54482c205b677b99633e841dc79535b", "filename": "src/liballoc/libc_heap.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fliballoc%2Flibc_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fliballoc%2Flibc_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flibc_heap.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -13,7 +13,6 @@\n \n use libc::{c_void, size_t, free, malloc, realloc};\n use core::ptr::{RawPtr, mut_null};\n-use core::intrinsics::abort;\n \n /// A wrapper around libc::malloc, aborting on out-of-memory\n #[inline]\n@@ -25,8 +24,7 @@ pub unsafe fn malloc_raw(size: uint) -> *mut u8 {\n     } else {\n         let p = malloc(size as size_t);\n         if p.is_null() {\n-            // we need a non-allocating way to print an error here\n-            abort();\n+            ::oom();\n         }\n         p as *mut u8\n     }\n@@ -43,8 +41,7 @@ pub unsafe fn realloc_raw(ptr: *mut u8, size: uint) -> *mut u8 {\n     } else {\n         let p = realloc(ptr as *mut c_void, size as size_t);\n         if p.is_null() {\n-            // we need a non-allocating way to print an error here\n-            abort();\n+            ::oom();\n         }\n         p as *mut u8\n     }"}, {"sha": "05d9988a13965a15029c2691c6ff3d435bf17c35", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -2592,7 +2592,7 @@ pub mod consts {\n             pub static PROT_GROWSUP : c_int = 0x020000000;\n \n             pub static MAP_TYPE : c_int = 0x000f;\n-            pub static MAP_ANONONYMOUS : c_int = 0x0020;\n+            pub static MAP_ANONYMOUS : c_int = 0x0020;\n             pub static MAP_32BIT : c_int = 0x0040;\n             pub static MAP_GROWSDOWN : c_int = 0x0100;\n             pub static MAP_DENYWRITE : c_int = 0x0800;\n@@ -2615,7 +2615,7 @@ pub mod consts {\n             pub static PROT_GROWSUP : c_int = 0x02000000;\n \n             pub static MAP_TYPE : c_int = 0x000f;\n-            pub static MAP_ANONONYMOUS : c_int = 0x0800;\n+            pub static MAP_ANONYMOUS : c_int = 0x0800;\n             pub static MAP_GROWSDOWN : c_int = 0x01000;\n             pub static MAP_DENYWRITE : c_int = 0x02000;\n             pub static MAP_EXECUTABLE : c_int = 0x04000;"}, {"sha": "15e751a283ee1bbb78266f8b77bd86f3af3dd23c", "filename": "src/librustc/README.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.txt?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -4,12 +4,12 @@ An informal guide to reading and working on the rustc compiler.\n If you wish to expand on this document, or have a more experienced\n Rust contributor add anything else to it, please get in touch:\n \n-https://github.com/mozilla/rust/wiki/Note-development-policy\n+https://github.com/rust-lang/rust/wiki/Note-development-policy\n (\"Communication\" subheading)\n \n or file a bug:\n \n-https://github.com/mozilla/rust/issues\n+https://github.com/rust-lang/rust/issues\n \n Your concerns are probably the same as someone else's.\n "}, {"sha": "ef3a00c26f204889347a88fefdbe32825807c549", "filename": "src/librustc/back/svh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fback%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fback%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fsvh.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -44,7 +44,7 @@\n //!\n //! # Relevant links\n //!\n-//! Original issue: https://github.com/mozilla/rust/issues/10207\n+//! Original issue: https://github.com/rust-lang/rust/issues/10207\n \n use std::fmt;\n use std::hash::Hash;\n@@ -270,7 +270,7 @@ mod svh_visitor {\n             ExprBlock(..)            => SawExprBlock,\n             ExprAssign(..)           => SawExprAssign,\n             ExprAssignOp(op, _, _)   => SawExprAssignOp(op),\n-            ExprField(_, id, _)      => SawExprField(content(id)),\n+            ExprField(_, id, _)      => SawExprField(content(id.node)),\n             ExprIndex(..)            => SawExprIndex,\n             ExprPath(..)             => SawExprPath,\n             ExprAddrOf(m, _)         => SawExprAddrOf(m),"}, {"sha": "1535239141862ca17fe64d330b62d754c5a0d9ea", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -235,7 +235,7 @@ impl<'a> Visitor<MarkSymbolVisitorContext> for MarkSymbolVisitor<'a> {\n                 self.lookup_and_handle_method(expr.id, expr.span);\n             }\n             ast::ExprField(ref lhs, ref ident, _) => {\n-                self.handle_field_access(&**lhs, ident);\n+                self.handle_field_access(&**lhs, &ident.node);\n             }\n             _ => ()\n         }"}, {"sha": "9b5930cf9ada30cc5361ba8a93cc1dd182537fda", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -447,7 +447,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n \n           ast::ExprField(ref base, f_name, _) => {\n             let base_cmt = if_ok!(self.cat_expr(&**base));\n-            Ok(self.cat_field(expr, base_cmt, f_name, expr_ty))\n+            Ok(self.cat_field(expr, base_cmt, f_name.node, expr_ty))\n           }\n \n           ast::ExprIndex(ref base, _) => {"}, {"sha": "f69dc8e31d69ba64e0cdadf5cb2c930025610d97", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -303,7 +303,7 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n                 match ty.node {\n                     ast::TyPath(_, _, id) => {\n                         match self.tcx.def_map.borrow().get_copy(&id) {\n-                            def::DefPrimTy(..) => {},\n+                            def::DefPrimTy(..) | def::DefTyParam(..) => {},\n                             def => {\n                                 let did = def.def_id();\n                                 if is_local(did) {\n@@ -801,7 +801,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n             ast::ExprField(ref base, ident, _) => {\n                 match ty::get(ty::expr_ty_adjusted(self.tcx, &**base)).sty {\n                     ty::ty_struct(id, _) => {\n-                        self.check_field(expr.span, id, NamedField(ident));\n+                        self.check_field(expr.span, id, NamedField(ident.node));\n                     }\n                     _ => {}\n                 }"}, {"sha": "53c09fcf283507af68fc20ec97de2cd1a32b873f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -5241,7 +5241,7 @@ impl<'a> Resolver<'a> {\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.search_for_traits_containing_method(ident.name);\n+                let traits = self.search_for_traits_containing_method(ident.node.name);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             ExprMethodCall(ident, _, _) => {"}, {"sha": "2b2f3b8fb0b5fd085ba00cdc24736f1bde36644d", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -1210,7 +1210,7 @@ impl<'l> Visitor<DxrVisitorEnv> for DxrVisitor<'l> {\n                     ty::ty_struct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n                         for f in fields.iter() {\n-                            if f.name == ident.name {\n+                            if f.name == ident.node.name {\n                                 let sub_span = self.span.span_for_last_ident(ex.span);\n                                 self.fmt.ref_str(recorder::VarRef,\n                                                  ex.span,"}, {"sha": "45019edc58bdf17dd7eda12c241fb03b060aa6c4", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -419,7 +419,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               let brepr = adt::represent_type(cx, bt);\n               let (bv, inlineable) = const_expr(cx, &**base, is_local);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n-                  let ix = ty::field_idx_strict(cx.tcx(), field.name, field_tys);\n+                  let ix = ty::field_idx_strict(cx.tcx(), field.node.name, field_tys);\n                   (adt::const_get_field(cx, &*brepr, bv, discr, ix), inlineable)\n               })\n           }"}, {"sha": "b934f23abb48c5f17444afe79a0529807c58b35e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 205, "deletions": 126, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -237,7 +237,7 @@ impl TypeMap {\n                                    metadata: DIType) {\n         if !self.type_to_metadata.insert(ty::type_id(type_), metadata) {\n             cx.sess().bug(format!(\"Type metadata for ty::t '{}' is already in the TypeMap!\",\n-                                  ppaux::ty_to_str(cx.tcx(), type_)).as_slice());\n+                                   ppaux::ty_to_str(cx.tcx(), type_)).as_slice());\n         }\n     }\n \n@@ -291,6 +291,8 @@ impl TypeMap {\n         //                             :return-type-uid: : (:bounds:)*}\n         // function             -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n         //                             :return-type-uid:}\n+        // unique vec box (~[]) -> {HEAP_VEC_BOX<:pointee-uid:>}\n+        // gc box               -> {GC_BOX<:pointee-uid:>}\n \n         match self.type_to_unique_id.find_copy(&ty::type_id(type_)) {\n             Some(unique_type_id) => return unique_type_id,\n@@ -552,6 +554,30 @@ impl TypeMap {\n         let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n         UniqueTypeId(interner_key)\n     }\n+\n+    fn get_unique_type_id_of_heap_vec_box(&mut self,\n+                                          cx: &CrateContext,\n+                                          element_type: ty::t)\n+                                       -> UniqueTypeId {\n+        let element_type_id = self.get_unique_type_id_of_type(cx, element_type);\n+        let heap_vec_box_type_id = format!(\"$$HEAP_VEC_BOX<{}>$$\",\n+                                           self.get_unique_type_id_as_string(element_type_id)\n+                                               .as_slice());\n+        let interner_key = self.unique_id_interner.intern(Rc::new(heap_vec_box_type_id));\n+        UniqueTypeId(interner_key)\n+    }\n+\n+    fn get_unique_type_id_of_gc_box(&mut self,\n+                                    cx: &CrateContext,\n+                                    element_type: ty::t)\n+                                 -> UniqueTypeId {\n+        let element_type_id = self.get_unique_type_id_of_type(cx, element_type);\n+        let gc_box_type_id = format!(\"$$GC_BOX<{}>$$\",\n+                                     self.get_unique_type_id_as_string(element_type_id)\n+                                         .as_slice());\n+        let interner_key = self.unique_id_interner.intern(Rc::new(gc_box_type_id));\n+        UniqueTypeId(interner_key)\n+    }\n }\n \n \n@@ -1677,9 +1703,9 @@ fn create_and_register_recursive_type_forward_declaration(\n impl RecursiveTypeDescription {\n     // Finishes up the description of the type in question (mostly by providing descriptions of the\n     // fields of the given type) and returns the final type metadata.\n-    fn finalize(&self, cx: &CrateContext) -> DICompositeType {\n+    fn finalize(&self, cx: &CrateContext) -> MetadataCreationResult {\n         match *self {\n-            FinalMetadata(metadata) => metadata,\n+            FinalMetadata(metadata) => MetadataCreationResult::new(metadata, false),\n             UnfinishedMetadata {\n                 unfinished_type,\n                 unique_type_id,\n@@ -1713,7 +1739,7 @@ impl RecursiveTypeDescription {\n                                               member_descriptions.as_slice(),\n                                               file_metadata,\n                                               codemap::DUMMY_SP);\n-                return metadata_stub;\n+                return MetadataCreationResult::new(metadata_stub, true);\n             }\n         }\n     }\n@@ -2459,14 +2485,22 @@ fn create_struct_stub(cx: &CrateContext,\n }\n \n fn at_box_metadata(cx: &CrateContext,\n+                   at_pointer_type: ty::t,\n                    content_type: ty::t,\n-                   unique_type_id: UniqueTypeId) -> DIType {\n+                   unique_type_id: UniqueTypeId)\n+                -> MetadataCreationResult {\n+    let content_type_metadata = type_metadata(cx, content_type, codemap::DUMMY_SP);\n+\n+    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n+        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n+        None => { /* proceed */ }\n+    };\n+\n     let content_type_name = ppaux::ty_to_str(cx.tcx(), content_type);\n     let content_type_name = content_type_name.as_slice();\n     let content_llvm_type = type_of::type_of(cx, content_type);\n-    let content_type_metadata = type_metadata(cx, content_type, codemap::DUMMY_SP);\n \n-    let box_type_name = format!(\"Boxed<{}>\", content_type_name);\n+    let box_type_name = format!(\"GcBox<{}>\", content_type_name);\n     let box_llvm_type = Type::at_box(cx, content_llvm_type);\n     let member_llvm_types = box_llvm_type.field_types();\n     assert!(box_layout_is_correct(cx,\n@@ -2513,16 +2547,24 @@ fn at_box_metadata(cx: &CrateContext,\n     let loc = span_start(cx, codemap::DUMMY_SP);\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n \n-    return composite_type_metadata(\n+    let gc_box_unique_id = debug_context(cx).type_map\n+                                            .borrow_mut()\n+                                            .get_unique_type_id_of_gc_box(cx, content_type);\n+\n+    let gc_box_metadata = composite_type_metadata(\n         cx,\n         box_llvm_type,\n         box_type_name.as_slice(),\n-        unique_type_id,\n+        gc_box_unique_id,\n         member_descriptions,\n         file_metadata,\n         file_metadata,\n         codemap::DUMMY_SP);\n \n+    let gc_pointer_metadata = pointer_type_metadata(cx, at_pointer_type, gc_box_metadata);\n+\n+    return MetadataCreationResult::new(gc_pointer_metadata, false);\n+\n     // Unfortunately, we cannot assert anything but the correct types here---and not whether the\n     // 'next' and 'prev' pointers are in the correct order.\n     fn box_layout_is_correct(cx: &CrateContext,\n@@ -2540,11 +2582,18 @@ fn at_box_metadata(cx: &CrateContext,\n \n \n fn fixed_vec_metadata(cx: &CrateContext,\n+                      unique_type_id: UniqueTypeId,\n                       element_type: ty::t,\n                       len: uint,\n                       span: Span)\n-                   -> DIType {\n+                   -> MetadataCreationResult {\n     let element_type_metadata = type_metadata(cx, element_type, span);\n+\n+    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n+        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n+        None => { /* proceed */ }\n+    };\n+\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let (element_type_size, element_type_align) = size_and_align_of(cx, element_llvm_type);\n \n@@ -2556,32 +2605,38 @@ fn fixed_vec_metadata(cx: &CrateContext,\n     };\n \n     let subscripts = create_DIArray(DIB(cx), [subrange]);\n-    return unsafe {\n+    let metadata = unsafe {\n         llvm::LLVMDIBuilderCreateArrayType(\n             DIB(cx),\n             bytes_to_bits(element_type_size * (len as u64)),\n             bytes_to_bits(element_type_align),\n             element_type_metadata,\n             subscripts)\n     };\n+\n+    return MetadataCreationResult::new(metadata, false);\n }\n \n fn heap_vec_metadata(cx: &CrateContext,\n-                     vec_type: ty::t,\n+                     vec_pointer_type: ty::t,\n                      element_type: ty::t,\n                      unique_type_id: UniqueTypeId,\n                      span: Span)\n-                  -> DICompositeType {\n-\n+                  -> MetadataCreationResult {\n     let element_type_metadata = type_metadata(cx, element_type, span);\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n \n-    let vec_llvm_type = Type::vec(cx, &element_llvm_type);\n-    let vec_type_name = ppaux::ty_to_str(cx.tcx(), vec_type);\n-    let vec_type_name = vec_type_name.as_slice();\n+    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n+        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n+        None => { /* proceed */ }\n+    };\n+\n+    let vecbox_llvm_type = Type::vec(cx, &element_llvm_type);\n+    let vec_pointer_type_name = ppaux::ty_to_str(cx.tcx(), vec_pointer_type);\n+    let vec_pointer_type_name = vec_pointer_type_name.as_slice();\n \n-    let member_llvm_types = vec_llvm_type.field_types();\n+    let member_llvm_types = vecbox_llvm_type.field_types();\n \n     let int_type_metadata = type_metadata(cx, ty::mk_int(), span);\n     let array_type_metadata = unsafe {\n@@ -2619,25 +2674,39 @@ fn heap_vec_metadata(cx: &CrateContext,\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n \n-    composite_type_metadata(\n-        cx,\n-        vec_llvm_type,\n-        vec_type_name,\n-        unique_type_id,\n-        member_descriptions,\n-        file_metadata,\n-        file_metadata,\n-        span)\n+    let vec_box_unique_id = debug_context(cx).type_map\n+                                             .borrow_mut()\n+                                             .get_unique_type_id_of_heap_vec_box(cx, element_type);\n+\n+    let vecbox_metadata = composite_type_metadata(cx,\n+                                                  vecbox_llvm_type,\n+                                                  vec_pointer_type_name,\n+                                                  vec_box_unique_id,\n+                                                  member_descriptions,\n+                                                  file_metadata,\n+                                                  file_metadata,\n+                                                  span);\n+\n+    MetadataCreationResult::new(pointer_type_metadata(cx, vec_pointer_type, vecbox_metadata), false)\n }\n \n fn vec_slice_metadata(cx: &CrateContext,\n                       vec_type: ty::t,\n                       element_type: ty::t,\n                       unique_type_id: UniqueTypeId,\n                       span: Span)\n-                   -> DICompositeType {\n+                   -> MetadataCreationResult {\n+    let data_ptr_type = ty::mk_ptr(cx.tcx(), ty::mt {\n+        ty: element_type,\n+        mutbl: ast::MutImmutable\n+    });\n+\n+    let element_type_metadata = type_metadata(cx, data_ptr_type, span);\n \n-    debug!(\"vec_slice_metadata: {:?}\", ty::get(vec_type));\n+    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n+        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n+        None => { /* proceed */ }\n+    };\n \n     let slice_llvm_type = type_of::type_of(cx, vec_type);\n     let slice_type_name = ppaux::ty_to_str(cx.tcx(), vec_type);\n@@ -2646,17 +2715,11 @@ fn vec_slice_metadata(cx: &CrateContext,\n     assert!(slice_layout_is_correct(cx,\n                                     member_llvm_types.as_slice(),\n                                     element_type));\n-\n-    let data_ptr_type = ty::mk_ptr(cx.tcx(), ty::mt {\n-        ty: element_type,\n-        mutbl: ast::MutImmutable\n-    });\n-\n     let member_descriptions = [\n         MemberDescription {\n             name: \"data_ptr\".to_string(),\n             llvm_type: *member_llvm_types.get(0),\n-            type_metadata: type_metadata(cx, data_ptr_type, span),\n+            type_metadata: element_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n@@ -2672,15 +2735,15 @@ fn vec_slice_metadata(cx: &CrateContext,\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n \n-    return composite_type_metadata(\n-        cx,\n-        slice_llvm_type,\n-        slice_type_name.as_slice(),\n-        unique_type_id,\n-        member_descriptions,\n-        file_metadata,\n-        file_metadata,\n-        span);\n+    let metadata = composite_type_metadata(cx,\n+                                           slice_llvm_type,\n+                                           slice_type_name.as_slice(),\n+                                           unique_type_id,\n+                                           member_descriptions,\n+                                           file_metadata,\n+                                           file_metadata,\n+                                           span);\n+    return MetadataCreationResult::new(metadata, false);\n \n     fn slice_layout_is_correct(cx: &CrateContext,\n                                member_llvm_types: &[Type],\n@@ -2693,12 +2756,12 @@ fn vec_slice_metadata(cx: &CrateContext,\n }\n \n fn subroutine_type_metadata(cx: &CrateContext,\n+                            unique_type_id: UniqueTypeId,\n                             signature: &ty::FnSig,\n                             span: Span)\n-                         -> DICompositeType {\n+                         -> MetadataCreationResult {\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n-\n     let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n \n     // return type\n@@ -2712,12 +2775,19 @@ fn subroutine_type_metadata(cx: &CrateContext,\n         signature_metadata.push(type_metadata(cx, argument_type, span));\n     }\n \n-    return unsafe {\n-        llvm::LLVMDIBuilderCreateSubroutineType(\n-            DIB(cx),\n-            file_metadata,\n-            create_DIArray(DIB(cx), signature_metadata.as_slice()))\n+    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n+        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n+        None => { /* proceed */ }\n     };\n+\n+    return MetadataCreationResult::new(\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateSubroutineType(\n+                DIB(cx),\n+                file_metadata,\n+                create_DIArray(DIB(cx), signature_metadata.as_slice()))\n+        },\n+        false);\n }\n \n fn trait_metadata(cx: &CrateContext,\n@@ -2758,28 +2828,32 @@ fn trait_metadata(cx: &CrateContext,\n                             definition_span)\n }\n \n-\n fn type_metadata(cx: &CrateContext,\n                  t: ty::t,\n                  usage_site_span: Span)\n               -> DIType {\n     // Get the unique type id of this type.\n     let unique_type_id = {\n         let mut type_map = debug_context(cx).type_map.borrow_mut();\n+        // First, try to find the type in TypeMap. If we have seen it before, we can exit early here\n         match type_map.find_metadata_for_type(t) {\n             Some(metadata) => {\n                 return metadata;\n             },\n             None => {\n+                // The ty::t is not in the TypeMap but maybe we have already seen an equivalent type\n+                // (e.g. only differing in region arguments). In order to find out, generate the\n+                // unique type id and look that up.\n                 let unique_type_id = type_map.get_unique_type_id_of_type(cx, t);\n                 match type_map.find_metadata_for_unique_id(unique_type_id) {\n                     Some(metadata) => {\n+                        // There is already an equivalent type in the TypeMap. Register this ty::t\n+                        // as an alias in the cache and return the cached metadata\n                         type_map.register_type_with_metadata(cx, t, metadata);\n                         return metadata;\n                     },\n                     None => {\n-                        // There really is no type metadata for this type, so proceed by creating\n-                        // it\n+                        // There really is no type metadata for this type, so proceed by creating it\n                         unique_type_id\n                     }\n                 }\n@@ -2799,106 +2873,87 @@ fn type_metadata(cx: &CrateContext,\n     )\n \n     let sty = &ty::get(t).sty;\n-    let (type_metadata, should_already_be_stored_in_typemap) = match *sty {\n+    let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n         ty::ty_nil      |\n         ty::ty_bot      |\n         ty::ty_bool     |\n         ty::ty_char     |\n         ty::ty_int(_)   |\n         ty::ty_uint(_)  |\n         ty::ty_float(_) => {\n-            (basic_type_metadata(cx, t), false)\n+            MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n         ty::ty_enum(def_id, _) => {\n-            let is_c_style_enum = match *adt::represent_type(cx, t) {\n-                adt::CEnum(..) => true,\n-                _ => false\n-            };\n-\n-            (prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span).finalize(cx),\n-             !is_c_style_enum)\n+            prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span).finalize(cx)\n         }\n         ty::ty_box(pointee_type) => {\n-            let box_content_metadata = at_box_metadata(cx, pointee_type, unique_type_id);\n-            return_if_created_in_meantime!();\n-            (pointer_type_metadata(cx, t, box_content_metadata), false)\n+            at_box_metadata(cx, t, pointee_type, unique_type_id)\n         }\n         ty::ty_vec(ref mt, Some(len)) => {\n-            (fixed_vec_metadata(cx, mt.ty, len, usage_site_span), false)\n+            fixed_vec_metadata(cx, unique_type_id, mt.ty, len, usage_site_span)\n         }\n         ty::ty_uniq(pointee_type) => {\n-            (match ty::get(pointee_type).sty {\n+            match ty::get(pointee_type).sty {\n                 ty::ty_vec(ref mt, None) => {\n-                    let vec_metadata = heap_vec_metadata(cx,\n-                                                         pointee_type,\n-                                                         mt.ty,\n-                                                         unique_type_id,\n-                                                         usage_site_span);\n-                    return_if_created_in_meantime!();\n-                    pointer_type_metadata(cx, t, vec_metadata)\n+                    heap_vec_metadata(cx, pointee_type, mt.ty, unique_type_id, usage_site_span)\n                 }\n                 ty::ty_str => {\n                     let i8_t = ty::mk_i8();\n-                    let vec_metadata = heap_vec_metadata(cx,\n-                                                         pointee_type,\n-                                                         i8_t,\n-                                                         unique_type_id,\n-                                                         usage_site_span);\n-                    pointer_type_metadata(cx, t, vec_metadata)\n+                    heap_vec_metadata(cx, pointee_type, i8_t, unique_type_id, usage_site_span)\n                 }\n                 _ => {\n                     let pointee_metadata = type_metadata(cx, pointee_type, usage_site_span);\n                     return_if_created_in_meantime!();\n-                    pointer_type_metadata(cx, t, pointee_metadata)\n+                    MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata),\n+                                                false)\n                 }\n-            }, false)\n+            }\n         }\n         ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n-            (match ty::get(mt.ty).sty {\n+            match ty::get(mt.ty).sty {\n                 ty::ty_vec(ref mt, None) => {\n                     vec_slice_metadata(cx, t, mt.ty, unique_type_id, usage_site_span)\n                 }\n                 ty::ty_str => {\n-                    let i8_t = ty::mk_i8();\n-                    vec_slice_metadata(cx, t, i8_t, unique_type_id, usage_site_span)\n+                    vec_slice_metadata(cx, t, ty::mk_i8(), unique_type_id, usage_site_span)\n                 }\n                 _ => {\n                     let pointee = type_metadata(cx, mt.ty, usage_site_span);\n                     return_if_created_in_meantime!();\n-                    pointer_type_metadata(cx, t, pointee)\n+                    MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee), false)\n                 }\n-            }, false)\n+            }\n         }\n         ty::ty_bare_fn(ref barefnty) => {\n-            (subroutine_type_metadata(cx, &barefnty.sig, usage_site_span), false)\n+            subroutine_type_metadata(cx, unique_type_id, &barefnty.sig, usage_site_span)\n         }\n         ty::ty_closure(ref closurety) => {\n-            (subroutine_type_metadata(cx, &closurety.sig, usage_site_span), false)\n+            subroutine_type_metadata(cx, unique_type_id, &closurety.sig, usage_site_span)\n         }\n         ty::ty_trait(box ty::TyTrait {\n                 def_id,\n                 ref substs,\n                 store,\n                 ref bounds\n             }) => {\n-            (trait_metadata(cx, def_id, t, substs, store, bounds, unique_type_id), false)\n+            MetadataCreationResult::new(\n+                trait_metadata(cx, def_id, t, substs, store, bounds, unique_type_id),\n+                false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n-            let struct_metadata = prepare_struct_metadata(cx,\n-                                                          t,\n-                                                          def_id,\n-                                                          substs,\n-                                                          unique_type_id,\n-                                                          usage_site_span).finalize(cx);\n-            (struct_metadata, true)\n+            prepare_struct_metadata(cx,\n+                                    t,\n+                                    def_id,\n+                                    substs,\n+                                    unique_type_id,\n+                                    usage_site_span).finalize(cx)\n         }\n         ty::ty_tup(ref elements) => {\n-            let tuple_metadata = prepare_tuple_metadata(cx,\n-                                                        t,\n-                                                        elements.as_slice(),\n-                                                        unique_type_id,\n-                                                        usage_site_span).finalize(cx);\n-            (tuple_metadata, true)\n+            prepare_tuple_metadata(cx,\n+                                   t,\n+                                   elements.as_slice(),\n+                                   unique_type_id,\n+                                   usage_site_span).finalize(cx)\n         }\n         _ => {\n             cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n@@ -2909,33 +2964,57 @@ fn type_metadata(cx: &CrateContext,\n     {\n         let mut type_map = debug_context(cx).type_map.borrow_mut();\n \n-        if should_already_be_stored_in_typemap {\n-            // Make sure that we already have a TypeMap entry entry for the ty::t.\n-            if type_map.find_metadata_for_type(t).is_none() {\n-                let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n-                let error_message = format!(\"Expected type metadata for ty::t '{}' to already be in\n-                                            the TypeMap but it was not (unique type id = {})\",\n-                                            ppaux::ty_to_str(cx.tcx(), t),\n-                                            unique_type_id_str.as_slice());\n-                cx.sess().span_bug(usage_site_span, error_message.as_slice());\n-            }\n-\n+        if already_stored_in_typemap {\n             // Also make sure that we already have a TypeMap entry entry for the unique type id.\n-            if type_map.find_metadata_for_unique_id(unique_type_id).is_none() {\n-                let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n-                let error_message = format!(\"Expected type metadata for unique type id '{}' to\n-                                            already be in the TypeMap but it was not. (ty::t = {})\",\n-                                            unique_type_id_str.as_slice(),\n-                                            ppaux::ty_to_str(cx.tcx(), t));\n-                cx.sess().span_bug(usage_site_span, error_message.as_slice());\n+            let metadata_for_uid = match type_map.find_metadata_for_unique_id(unique_type_id) {\n+                Some(metadata) => metadata,\n+                None => {\n+                    let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n+                    let error_message = format!(\"Expected type metadata for unique type id '{}' to \\\n+                        already be in the debuginfo::TypeMap but it was not. (ty::t = {})\",\n+                        unique_type_id_str.as_slice(),\n+                        ppaux::ty_to_str(cx.tcx(), t));\n+                    cx.sess().span_bug(usage_site_span, error_message.as_slice());\n+                }\n+            };\n+\n+            match type_map.find_metadata_for_type(t) {\n+                Some(metadata) => {\n+                    if metadata != metadata_for_uid {\n+                        let unique_type_id_str =\n+                            type_map.get_unique_type_id_as_string(unique_type_id);\n+                        let error_message = format!(\"Mismatch between ty::t and UniqueTypeId maps \\\n+                            in debuginfo::TypeMap. UniqueTypeId={}, ty::t={}\",\n+                            unique_type_id_str.as_slice(),\n+                            ppaux::ty_to_str(cx.tcx(), t));\n+                        cx.sess().span_bug(usage_site_span, error_message.as_slice());\n+                    }\n+                }\n+                None => {\n+                    type_map.register_type_with_metadata(cx, t, metadata);\n+                }\n             }\n         } else {\n-            type_map.register_type_with_metadata(cx, t, type_metadata);\n-            type_map.register_unique_id_with_metadata(cx, unique_type_id, type_metadata);\n+            type_map.register_type_with_metadata(cx, t, metadata);\n+            type_map.register_unique_id_with_metadata(cx, unique_type_id, metadata);\n         }\n     }\n \n-    type_metadata\n+    metadata\n+}\n+\n+struct MetadataCreationResult {\n+    metadata: DIType,\n+    already_stored_in_typemap: bool\n+}\n+\n+impl MetadataCreationResult {\n+    fn new(metadata: DIType, already_stored_in_typemap: bool) -> MetadataCreationResult {\n+        MetadataCreationResult {\n+            metadata: metadata,\n+            already_stored_in_typemap: already_stored_in_typemap\n+        }\n+    }\n }\n \n #[deriving(PartialEq)]"}, {"sha": "01ba6113c0d518902e43689904367b354db96a1d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -389,7 +389,7 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n             trans_def(bcx, expr, bcx.def(expr.id))\n         }\n         ast::ExprField(ref base, ident, _) => {\n-            trans_rec_field(bcx, &**base, ident)\n+            trans_rec_field(bcx, &**base, ident.node)\n         }\n         ast::ExprIndex(ref base, ref idx) => {\n             trans_index(bcx, expr, &**base, &**idx)"}, {"sha": "73b92e5b8684c1f4b931125a40be593713a4a770", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -2352,7 +2352,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n                    lvalue_pref: LvaluePreference,\n                    base: &ast::Expr,\n-                   field: ast::Name,\n+                   field: &ast::SpannedIdent,\n                    tys: &[ast::P<ast::Ty>]) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n@@ -2365,7 +2365,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     ty::ty_struct(base_id, ref substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_str(tcx, base_t));\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n-                        lookup_field_ty(tcx, base_id, fields.as_slice(), field, &(*substs))\n+                        lookup_field_ty(tcx, base_id, fields.as_slice(),\n+                                        field.node.name, &(*substs))\n                     }\n                     _ => None\n                 }\n@@ -2383,7 +2384,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         match method::lookup(fcx,\n                              expr,\n                              base,\n-                             field,\n+                             field.node.name,\n                              expr_t,\n                              tps.as_slice(),\n                              DontDerefArgs,\n@@ -2392,14 +2393,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                              IgnoreStaticMethods) {\n             Some(_) => {\n                 fcx.type_error_message(\n-                    expr.span,\n+                    field.span,\n                     |actual| {\n                         format!(\"attempted to take value of method `{}` on type \\\n-                                 `{}`\", token::get_name(field), actual)\n+                                 `{}`\", token::get_ident(field.node), actual)\n                     },\n                     expr_t, None);\n \n-                tcx.sess.span_note(expr.span,\n+                tcx.sess.span_note(field.span,\n                     \"maybe a missing `()` to call it? If not, try an anonymous function.\");\n             }\n \n@@ -2410,7 +2411,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         format!(\"attempted access of field `{}` on \\\n                                         type `{}`, but no field with that \\\n                                         name was found\",\n-                                       token::get_name(field),\n+                                       token::get_ident(field.node),\n                                        actual)\n                     },\n                     expr_t, None);\n@@ -3214,7 +3215,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n       }\n       ast::ExprField(ref base, ref field, ref tys) => {\n-        check_field(fcx, expr, lvalue_pref, &**base, field.name, tys.as_slice());\n+        check_field(fcx, expr, lvalue_pref, &**base, field, tys.as_slice());\n       }\n       ast::ExprIndex(ref base, ref idx) => {\n           check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);"}, {"sha": "ac8ca05f8d0162935091903d113a38967eefc4c9", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -351,8 +351,8 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n       ty_uint(t) => ast_util::uint_ty_to_str(t, None,\n                                              ast_util::AutoSuffix).to_string(),\n       ty_float(t) => ast_util::float_ty_to_str(t).to_string(),\n-      ty_box(typ) => format!(\"@{}\", ty_to_str(cx, typ)),\n-      ty_uniq(typ) => format!(\"~{}\", ty_to_str(cx, typ)),\n+      ty_box(typ) => format!(\"Gc<{}>\", ty_to_str(cx, typ)),\n+      ty_uniq(typ) => format!(\"Box<{}>\", ty_to_str(cx, typ)),\n       ty_ptr(ref tm) => format!(\"*{}\", mt_to_str(cx, tm)),\n       ty_rptr(r, ref tm) => {\n           let mut buf = region_ptr_to_str(cx, r);"}, {"sha": "17e939ef4306441303fd0b2ba029e7ecb9a67579", "filename": "src/librustrt/stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustrt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibrustrt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -146,7 +146,7 @@ pub unsafe fn record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n         // means that if we want to perform valid FFI on windows, then we need\n         // to ensure that the stack bounds are what they truly are for this\n         // task. More info can be found at:\n-        //   https://github.com/mozilla/rust/issues/3445#issuecomment-26114839\n+        //   https://github.com/rust-lang/rust/issues/3445#issuecomment-26114839\n         //\n         // stack range is at TIB: %gs:0x08 (top) and %gs:0x10 (bottom)\n         asm!(\"mov $0, %gs:0x08\" :: \"r\"(stack_hi) :: \"volatile\");"}, {"sha": "6ea7cde3b27dae96d845e7ae386863dc728c0b13", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -183,7 +183,7 @@ fn main() {\n \n ## Using `ToJson`\n \n-This example use the ToJson impl to deserialize the JSON string.\n+This example uses the ToJson impl to deserialize the JSON string.\n Example of `ToJson` trait implementation for TestStruct1.\n \n ```rust"}, {"sha": "dfbf61cc890b7f12282213f43e49f1a4eedbc4b7", "filename": "src/libstd/os.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -57,6 +57,16 @@ use libc::c_char;\n #[cfg(windows)]\n use str::OwnedStr;\n \n+/// Get the number of cores available\n+pub fn num_cpus() -> uint {\n+    unsafe {\n+        return rust_get_num_cpus();\n+    }\n+\n+    extern {\n+        fn rust_get_num_cpus() -> libc::uintptr_t;\n+    }\n+}\n \n pub static TMPBUF_SZ : uint = 1000u;\n static BUF_BYTES : uint = 2048u;\n@@ -1762,6 +1772,11 @@ mod tests {\n         n\n     }\n \n+    #[test]\n+    fn test_num_cpus() {\n+        assert!(os::num_cpus() > 0);\n+    }\n+\n     #[test]\n     fn test_setenv() {\n         let n = make_rand_name();"}, {"sha": "fa30ddbcc48b5cb2573ba9144dd9c5fcc0438969", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -11,23 +11,11 @@\n use from_str::FromStr;\n use from_str::from_str;\n use libc::uintptr_t;\n-use libc;\n use option::{Some, None, Option};\n use os;\n use str::Str;\n use sync::atomics;\n \n-/// Get the number of cores available\n-pub fn num_cpus() -> uint {\n-    unsafe {\n-        return rust_get_num_cpus();\n-    }\n-\n-    extern {\n-        fn rust_get_num_cpus() -> libc::uintptr_t;\n-    }\n-}\n-\n /// Dynamically inquire about whether we're running under V.\n /// You should usually not use this unless your test definitely\n /// can't run correctly un-altered. Valgrind is there to help\n@@ -81,7 +69,7 @@ pub fn default_sched_threads() -> uint {\n             if limit_thread_creation_due_to_osx_and_valgrind() {\n                 1\n             } else {\n-                num_cpus()\n+                os::num_cpus()\n             }\n         }\n     }"}, {"sha": "ccc67e3f8b01cb8671c1d7dbfb3aadbf7c134728", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -132,7 +132,8 @@ impl<A:Send> Future<A> {\n         let (tx, rx) = channel();\n \n         spawn(proc() {\n-            tx.send(blk());\n+            // Don't fail if the other end has hung up\n+            let _ = tx.send_opt(blk());\n         });\n \n         Future::from_receiver(rx)\n@@ -144,6 +145,7 @@ mod test {\n     use prelude::*;\n     use sync::Future;\n     use task;\n+    use comm::{channel, Sender};\n \n     #[test]\n     fn test_from_value() {\n@@ -206,4 +208,28 @@ mod test {\n             assert_eq!(actual, expected);\n         });\n     }\n+\n+    #[test]\n+    fn test_dropped_future_doesnt_fail() {\n+        struct Bomb(Sender<bool>);\n+\n+        local_data_key!(LOCAL: Bomb)\n+\n+        impl Drop for Bomb {\n+            fn drop(&mut self) {\n+                let Bomb(ref tx) = *self;\n+                tx.send(task::failing());\n+            }\n+        }\n+\n+        // Spawn a future, but drop it immediately. When we receive the result\n+        // later on, we should never view the task as having failed.\n+        let (tx, rx) = channel();\n+        drop(Future::spawn(proc() {\n+            LOCAL.replace(Some(Bomb(tx)));\n+        }));\n+\n+        // Make sure the future didn't fail the task.\n+        assert!(!rx.recv());\n+    }\n }"}, {"sha": "86dd736ceea48ac9dabee4b7d9d80a6eb16ce356", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -464,7 +464,7 @@ pub enum Expr_ {\n \n     ExprAssign(Gc<Expr>, Gc<Expr>),\n     ExprAssignOp(BinOp, Gc<Expr>, Gc<Expr>),\n-    ExprField(Gc<Expr>, Ident, Vec<P<Ty>>),\n+    ExprField(Gc<Expr>, SpannedIdent, Vec<P<Ty>>),\n     ExprIndex(Gc<Expr>, Gc<Expr>),\n \n     /// Expression that looks like a \"name\". For example,\n@@ -977,7 +977,7 @@ pub enum ViewItem_ {\n     // ident: name used to refer to this crate in the code\n     // optional (InternedString,StrStyle): if present, this is a location\n     // (containing arbitrary characters) from which to fetch the crate sources\n-    // For example, extern crate whatever = \"github.com/mozilla/rust\"\n+    // For example, extern crate whatever = \"github.com/rust-lang/rust\"\n     ViewItemExternCrate(Ident, Option<(InternedString,StrStyle)>, NodeId),\n     ViewItemUse(Gc<ViewPath>),\n }"}, {"sha": "a3112cbb8bed53b670bac840e7cef4c83b9a9eee", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -12,8 +12,8 @@ use std::fmt;\n \n /// CrateIds identify crates and include the crate name and optionally a path\n /// and version. In the full form, they look like relative URLs. Example:\n-/// `github.com/mozilla/rust#std:1.0` would be a package ID with a path of\n-/// `github.com/mozilla/rust` and a crate name of `std` with a version of\n+/// `github.com/rust-lang/rust#std:1.0` would be a package ID with a path of\n+/// `github.com/rust-lang/rust` and a crate name of `std` with a version of\n /// `1.0`. If no crate name is given after the hash, the name is inferred to\n /// be the last component of the path. If no version is given, it is inferred\n /// to be `0.0`."}, {"sha": "8d48401f9c2a45ec077fcc2cdb8d43d86826fa09", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -13,7 +13,7 @@ use ast::{P, Ident, Generics, NodeId, Expr};\n use ast;\n use ast_util;\n use attr;\n-use codemap::{Span, respan, Spanned, DUMMY_SP};\n+use codemap::{Span, respan, Spanned, DUMMY_SP, Pos};\n use ext::base::ExtCtxt;\n use fold::Folder;\n use owned_slice::OwnedSlice;\n@@ -560,7 +560,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_field_access(&self, sp: Span, expr: Gc<ast::Expr>, ident: ast::Ident) -> Gc<ast::Expr> {\n-        self.expr(sp, ast::ExprField(expr, ident, Vec::new()))\n+        let field_name = token::get_ident(ident);\n+        let field_span = Span {\n+            lo: sp.lo - Pos::from_uint(field_name.get().len()),\n+            hi: sp.hi,\n+            expn_info: sp.expn_info,\n+        };\n+\n+        let id = Spanned { node: ident, span: field_span };\n+        self.expr(sp, ast::ExprField(expr, id, Vec::new()))\n     }\n     fn expr_addr_of(&self, sp: Span, e: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         self.expr(sp, ast::ExprAddrOf(ast::MutImmutable, e))"}, {"sha": "6d2b0ceed8bf7d081b227aee820ededf1d4cbfe3", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -876,7 +876,7 @@ pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {\n         }\n         ExprField(el, id, ref tys) => {\n             ExprField(folder.fold_expr(el),\n-                      folder.fold_ident(id),\n+                      respan(id.span, folder.fold_ident(id.node)),\n                       tys.iter().map(|&x| folder.fold_ty(x)).collect())\n         }\n         ExprIndex(el, er) => {"}, {"sha": "bbe0680ef145411a372cabfd8ea2f1bfe0d0b3cb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -1796,7 +1796,7 @@ impl<'a> Parser<'a> {\n         ExprIndex(expr, idx)\n     }\n \n-    pub fn mk_field(&mut self, expr: Gc<Expr>, ident: Ident,\n+    pub fn mk_field(&mut self, expr: Gc<Expr>, ident: ast::SpannedIdent,\n                     tys: Vec<P<Ty>>) -> ast::Expr_ {\n         ExprField(expr, ident, tys)\n     }\n@@ -2090,7 +2090,8 @@ impl<'a> Parser<'a> {\n                             e = self.mk_expr(lo, hi, nd);\n                         }\n                         _ => {\n-                            let field = self.mk_field(e, i, tys);\n+                            let id = spanned(dot, hi, i);\n+                            let field = self.mk_field(e, id, tys);\n                             e = self.mk_expr(lo, hi, field)\n                         }\n                     }"}, {"sha": "badfbe7eb1522d927eeb7978a0a09ee1cf11ad6e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -1487,7 +1487,7 @@ impl<'a> State<'a> {\n             ast::ExprField(ref expr, id, ref tys) => {\n                 try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \".\"));\n-                try!(self.print_ident(id));\n+                try!(self.print_ident(id.node));\n                 if tys.len() > 0u {\n                     try!(word(&mut self.s, \"::<\"));\n                     try!(self.commasep("}, {"sha": "dd928bfa9d4408afce8c4342c8db8afcd70f3311", "filename": "src/test/compile-fail/autoderef-full-lval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -26,13 +26,13 @@ struct fish {\n fn main() {\n     let a: clam = clam{x: box(GC) 1, y: box(GC) 2};\n     let b: clam = clam{x: box(GC) 10, y: box(GC) 20};\n-    let z: int = a.x + b.y; //~ ERROR binary operation `+` cannot be applied to type `@int`\n+    let z: int = a.x + b.y; //~ ERROR binary operation `+` cannot be applied to type `Gc<int>`\n     println!(\"{:?}\", z);\n     assert_eq!(z, 21);\n     let forty: fish = fish{a: box(GC) 40};\n     let two: fish = fish{a: box(GC) 2};\n     let answer: int = forty.a + two.a;\n-    //~^ ERROR binary operation `+` cannot be applied to type `@int`\n+    //~^ ERROR binary operation `+` cannot be applied to type `Gc<int>`\n     println!(\"{:?}\", answer);\n     assert_eq!(answer, 42);\n }"}, {"sha": "e24830907d3bcc06c982b6696c8f9fc5adf9e856", "filename": "src/test/compile-fail/issue-14915.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::gc::{GC,Gc};\n+\n+fn main() {\n+    let x: Box<int> = box 0;\n+    let y: Gc<int> = box (GC) 0;\n+\n+    println!(\"{}\", x + 1); //~ ERROR binary operation `+` cannot be applied to type `Box<int>`\n+    //~^ ERROR cannot determine a type for this bounded type parameter: unconstrained type\n+    println!(\"{}\", y + 1);\n+    //~^ ERROR binary operation `+` cannot be applied to type `Gc<int>`\n+}"}, {"sha": "ea332c1e252338078e6669435cc3618adb97ffa3", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -32,7 +32,7 @@ struct A {\n \n fn main() {\n     let a = A {v: box B{v: None} as Box<Foo+Send>};\n-    //~^ ERROR cannot pack type `~B`, which does not fulfill `Send`\n+    //~^ ERROR cannot pack type `Box<B>`, which does not fulfill `Send`\n     let v = Rc::new(RefCell::new(a));\n     let w = v.clone();\n     let b = &*v;"}, {"sha": "b644d98926cdd56ceed725aa07f52545d985244b", "filename": "src/test/compile-fail/issue-7061.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Fcompile-fail%2Fissue-7061.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Fcompile-fail%2Fissue-7061.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7061.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -16,7 +16,7 @@ struct BarStruct;\n \n impl<'a> BarStruct {\n     fn foo(&'a mut self) -> Gc<BarStruct> { self }\n-    //~^ ERROR: error: mismatched types: expected `@BarStruct` but found `&'a mut BarStruct\n+    //~^ ERROR: error: mismatched types: expected `Gc<BarStruct>` but found `&'a mut BarStruct\n }\n \n fn main() {}"}, {"sha": "3cde24892af3e8ec464c9436e7c5a57c3e71e082", "filename": "src/test/compile-fail/method-missing-call.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Fcompile-fail%2Fmethod-missing-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Fcompile-fail%2Fmethod-missing-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-missing-call.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -28,7 +28,16 @@ impl Point {\n \n fn main() {\n     let point: Point = Point::new();\n-    let px: int =  point.get_x;//~ ERROR attempted to take value of method `get_x` on type `Point`\n-    //~^ NOTE maybe a missing `()` to call it? If not, try an anonymous function.\n+    let px: int =  point\n+                        .get_x;//~ ERROR attempted to take value of method `get_x` on type `Point`\n+                        //~^ NOTE maybe a missing `()` to call it? If not, try an anonymous\n+\n+    // Ensure the span is useful\n+    let ys = &[1,2,3,4,5,6,7];\n+    let a = ys.iter()\n+              .map(|x| x)\n+              .filter(|&&x| x == 1)\n+              .filter_map; //~ ERROR attempted to take value of method `filter_map` on type\n+              //~^ NOTE maybe a missing `()` to call it? If not, try an anonymous function.\n }\n "}, {"sha": "ea2e6feba5757e4e5dd66031c2ed3007a3d5ea07", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -33,7 +33,7 @@ impl<'a> set_f<'a> for c<'a> {\n     }\n \n     fn set_f_bad(&self, b: Gc<b>) {\n-        self.f = b; //~ ERROR mismatched types: expected `@@&'a int` but found `@@&int`\n+        self.f = b; //~ ERROR mismatched types: expected `Gc<Gc<&'a int>>` but found `Gc<Gc<&int>>`\n         //~^ ERROR cannot infer\n     }\n }"}, {"sha": "b08c6625f1705ec67f048971fbac166052699944", "filename": "src/test/run-make/rustdoc-hidden-line/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2FMakefile?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -4,8 +4,8 @@\n ifndef IS_WINDOWS\n \n all:\n-\t$(RUSTDOC) --test foo.rs\n-\t$(RUSTDOC) -w html -o $(TMPDIR)/doc foo.rs\n+\t$(HOST_RPATH_ENV) $(RUSTDOC) --test foo.rs\n+\t$(HOST_RPATH_ENV) $(RUSTDOC) -w html -o $(TMPDIR)/doc foo.rs\n \tcp verify.sh $(TMPDIR)\n \t$(call RUN,verify.sh) $(TMPDIR)\n "}, {"sha": "e49ab64b6958a8ac62818825daa3bd895be045af", "filename": "src/test/run-make/rustdoc-json/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Frun-make%2Frustdoc-json%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Frun-make%2Frustdoc-json%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-json%2FMakefile?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -1,4 +1,4 @@\n -include ../tools.mk\n all:\n-\t$(RUSTDOC) -w json -o $(TMPDIR)/doc.json foo.rs\n-\t$(RUSTDOC) -o $(TMPDIR)/doc $(TMPDIR)/doc.json\n+\t$(HOST_RPATH_ENV) $(RUSTDOC) -w json -o $(TMPDIR)/doc.json foo.rs\n+\t$(HOST_RPATH_ENV) $(RUSTDOC) -o $(TMPDIR)/doc $(TMPDIR)/doc.json"}, {"sha": "de013ab28a5778cb7e56e9e41a7eed4273035719", "filename": "src/test/run-make/rustdoc-smoke/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Frun-make%2Frustdoc-smoke%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Frun-make%2Frustdoc-smoke%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-smoke%2FMakefile?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -1,5 +1,5 @@\n -include ../tools.mk\n all:\n-\t$(RUSTDOC) -w html -o $(TMPDIR)/doc foo.rs\n+\t$(HOST_RPATH_ENV) $(RUSTDOC) -w html -o $(TMPDIR)/doc foo.rs\n \tcp verify.sh $(TMPDIR)\n \t$(call RUN,verify.sh) $(TMPDIR)"}, {"sha": "483a5db8778462678f80633706c42883ad1af4c5", "filename": "src/test/run-make/tools.mk", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Frun-make%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Frun-make%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftools.mk?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -1,15 +1,15 @@\n export LD_LIBRARY_PATH:=$(TMPDIR):$(LD_LIBRARY_PATH)\n export DYLD_LIBRARY_PATH:=$(TMPDIR):$(DYLD_LIBRARY_PATH)\n \n-RUSTC := $(RUSTC) --out-dir $(TMPDIR) -L $(TMPDIR)\n-CC := $(CC) -L $(TMPDIR)\n-\n # These deliberately use `=` and not `:=` so that client makefiles can\n # augment HOST_RPATH_DIR / TARGET_RPATH_DIR.\n HOST_RPATH_ENV = \\\n-    $(LD_LIB_PATH_ENVVAR)=$$$(LD_LIB_PATH_ENVVAR):$(HOST_RPATH_DIR)\n+    $(LD_LIB_PATH_ENVVAR)=$(HOST_RPATH_DIR):$$$(LD_LIB_PATH_ENVVAR)\n TARGET_RPATH_ENV = \\\n-    $(LD_LIB_PATH_ENVVAR)=$$$(LD_LIB_PATH_ENVVAR):$(TARGET_RPATH_DIR)\n+    $(LD_LIB_PATH_ENVVAR)=$(TARGET_RPATH_DIR):$$$(LD_LIB_PATH_ENVVAR)\n+\n+RUSTC := $(HOST_RPATH_ENV) $(RUSTC) --out-dir $(TMPDIR) -L $(TMPDIR)\n+CC := $(CC) -L $(TMPDIR)\n \n # This is the name of the binary we will generate and run; use this\n # e.g. for `$(CC) -o $(RUN_BINFILE)`."}, {"sha": "9796322b264c9263d9a98a8478d5854d768410fa", "filename": "src/test/run-pass/issue-14933.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Frun-pass%2Fissue-14933.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Frun-pass%2Fissue-14933.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14933.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(default_type_params)]\n+\n+pub type BigRat<T = int> = T;\n+\n+fn main() {}"}, {"sha": "ad7ba02970f0510b1cd4bd58a963640bb2a28880", "filename": "src/test/run-pass/logging-separate-lines.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09967665eaa5ca3d259f0f59ef26c8d236bf47a7/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs?ref=09967665eaa5ca3d259f0f59ef26c8d236bf47a7", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-android\n // ignore-win32\n+// exec-env:RUST_LOG=debug\n \n #![feature(phase)]\n \n@@ -29,9 +30,8 @@ fn main() {\n         return\n     }\n \n-    let env = [(\"RUST_LOG\".to_string(), \"debug\".to_string())];\n     let p = Command::new(args[0].as_slice())\n-                    .arg(\"child\").env(env.as_slice())\n+                    .arg(\"child\")\n                     .spawn().unwrap().wait_with_output().unwrap();\n     assert!(p.status.success());\n     let mut lines = str::from_utf8(p.error.as_slice()).unwrap().lines();"}]}