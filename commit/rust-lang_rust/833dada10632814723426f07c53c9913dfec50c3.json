{"sha": "833dada10632814723426f07c53c9913dfec50c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzM2RhZGExMDYzMjgxNDcyMzQyNmYwN2M1M2M5OTEzZGZlYzUwYzM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-13T14:18:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-13T14:18:37Z"}, "message": "Rollup merge of #62585 - pnkfelix:issue-60431-make-struct-tail-normalize-when-possible, r=eddyb\n\nMake struct_tail normalize when possible\n\nAs noted in commit message: this replaces the existing methods to extract the struct tail(s) with new entry points that make the handling of normalization explicit.\n\nMost of the places that call `struct_tail` are during codegen, post type-checking, and therefore they can get away with using `tcx.normalize_erasing_regions` (this is the entry point `struct_tail_erasing_lifetimes`)\n\nFor other cases that may arise, one can use the core method, which is parameterized over the normalization `Ty -> Ty` closure (`struct_tail_with_normalize`).\n\nOr one can use the trivial entry point that does not normalization (`struct_tail_without_normalization`)\n\n----\n\nI spent a little while trying to make a test that exposed the bug via `impl Trait` rather than a projection, but I failed to find something that tripped up the current nightly `rustc`.\n * I have *not* spent any time trying to make tests that trip up the other places where `struct_tail` was previously being called. While I do think the task of making such tests could be worthwhile, I am simply running out of time. (Its also possible that the layout code is always the first point called, and thus it may be pointless to try to come up with such tests.)\n\nI also spent a little time discussing with @eddyb where this code should live. They suggested moving `struct_tail` and its sibling `struct_lockstep_tails` to the `LayoutCx`.  But in the interest of time, I have left that refactoring (which may be questionable at this point) to a follow-up task.\n\n----\n\nFix #60431", "tree": {"sha": "8f9aef6b3d38de444e6a3bdd93ccce8898b8f328", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f9aef6b3d38de444e6a3bdd93ccce8898b8f328"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/833dada10632814723426f07c53c9913dfec50c3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdKeg9CRBK7hj4Ov3rIwAAdHIIAElsB5xqUnvGKDy702WXZNsv\nAHkVq6C72htc2ZwxzmTgSiQy+jeiGnSuyL37mcysdAB4Fi2VBy3kTqA64Ls2khjR\ngpLyZ1HjssPmPQlpY+KO+aK19SOxvU0qEIedZP37qfmyIateO/IRrMfFhGZ9Ixw8\nIUNl+XIbO7C22ipUrV158hcTtyvgP2Gx6DjM9tg6HVqV8r47+Y7ieXa4efAqNrvx\ng2OZjheJ0XB3D9hA+zRgx9TunorVHOJtVTsHmIQ94RW8DHL8JTbRGWLn4hlxEarQ\nYVuQBVL8ERCLvWVk8YDSoS1CZrgEv8CV7gwYcrw5RkxfT4zIwwSh0nhsfDzgyiU=\n=S2uX\n-----END PGP SIGNATURE-----\n", "payload": "tree 8f9aef6b3d38de444e6a3bdd93ccce8898b8f328\nparent 5e1891c47407bef2e2cc107ed997d557e57edaef\nparent 3c8279a2246c8bbb63f7d6aeac144b3a8adbe755\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1563027517 +0200\ncommitter GitHub <noreply@github.com> 1563027517 +0200\n\nRollup merge of #62585 - pnkfelix:issue-60431-make-struct-tail-normalize-when-possible, r=eddyb\n\nMake struct_tail normalize when possible\n\nAs noted in commit message: this replaces the existing methods to extract the struct tail(s) with new entry points that make the handling of normalization explicit.\n\nMost of the places that call `struct_tail` are during codegen, post type-checking, and therefore they can get away with using `tcx.normalize_erasing_regions` (this is the entry point `struct_tail_erasing_lifetimes`)\n\nFor other cases that may arise, one can use the core method, which is parameterized over the normalization `Ty -> Ty` closure (`struct_tail_with_normalize`).\n\nOr one can use the trivial entry point that does not normalization (`struct_tail_without_normalization`)\n\n----\n\nI spent a little while trying to make a test that exposed the bug via `impl Trait` rather than a projection, but I failed to find something that tripped up the current nightly `rustc`.\n * I have *not* spent any time trying to make tests that trip up the other places where `struct_tail` was previously being called. While I do think the task of making such tests could be worthwhile, I am simply running out of time. (Its also possible that the layout code is always the first point called, and thus it may be pointless to try to come up with such tests.)\n\nI also spent a little time discussing with @eddyb where this code should live. They suggested moving `struct_tail` and its sibling `struct_lockstep_tails` to the `LayoutCx`.  But in the interest of time, I have left that refactoring (which may be questionable at this point) to a follow-up task.\n\n----\n\nFix #60431\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/833dada10632814723426f07c53c9913dfec50c3", "html_url": "https://github.com/rust-lang/rust/commit/833dada10632814723426f07c53c9913dfec50c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/833dada10632814723426f07c53c9913dfec50c3/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e1891c47407bef2e2cc107ed997d557e57edaef", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e1891c47407bef2e2cc107ed997d557e57edaef", "html_url": "https://github.com/rust-lang/rust/commit/5e1891c47407bef2e2cc107ed997d557e57edaef"}, {"sha": "3c8279a2246c8bbb63f7d6aeac144b3a8adbe755", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c8279a2246c8bbb63f7d6aeac144b3a8adbe755", "html_url": "https://github.com/rust-lang/rust/commit/3c8279a2246c8bbb63f7d6aeac144b3a8adbe755"}], "stats": {"total": 173, "additions": 151, "deletions": 22}, "files": [{"sha": "4ed52a1e96638a88059d59b2fbd27bdd128f5748", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=833dada10632814723426f07c53c9913dfec50c3", "patch": "@@ -543,7 +543,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     return Ok(tcx.intern_layout(LayoutDetails::scalar(self, data_ptr)));\n                 }\n \n-                let unsized_part = tcx.struct_tail(pointee);\n+                let unsized_part = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 let metadata = match unsized_part.sty {\n                     ty::Foreign(..) => {\n                         return Ok(tcx.intern_layout(LayoutDetails::scalar(self, data_ptr)));\n@@ -1664,7 +1664,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n             ty::Ref(_, pointee, _) |\n             ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let non_zero = !ty.is_unsafe_ptr();\n-                let tail = tcx.struct_tail(pointee);\n+                let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.sty {\n                     ty::Param(_) | ty::Projection(_) => {\n                         debug_assert!(tail.has_param_types() || tail.has_self_ty());\n@@ -2015,7 +2015,7 @@ where\n                     }));\n                 }\n \n-                match tcx.struct_tail(pointee).sty {\n+                match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).sty {\n                     ty::Slice(_) |\n                     ty::Str => tcx.types.usize,\n                     ty::Dynamic(_, _) => {"}, {"sha": "c3ecc04b12e0144e2bc0cc311de656bcb8561e71", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 94, "deletions": 8, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=833dada10632814723426f07c53c9913dfec50c3", "patch": "@@ -257,10 +257,46 @@ impl<'tcx> TyCtxt<'tcx> {\n         false\n     }\n \n-    /// Returns the deeply last field of nested structures, or the same type,\n-    /// if not a structure at all. Corresponds to the only possible unsized\n-    /// field, and its type can be used to determine unsizing strategy.\n-    pub fn struct_tail(self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+    /// Attempts to returns the deeply last field of nested structures, but\n+    /// does not apply any normalization in its search. Returns the same type\n+    /// if input `ty` is not a structure at all.\n+    pub fn struct_tail_without_normalization(self, ty: Ty<'tcx>) -> Ty<'tcx>\n+    {\n+        let tcx = self;\n+        tcx.struct_tail_with_normalize(ty, |ty| ty)\n+    }\n+\n+    /// Returns the deeply last field of nested structures, or the same type if\n+    /// not a structure at all. Corresponds to the only possible unsized field,\n+    /// and its type can be used to determine unsizing strategy.\n+    ///\n+    /// Should only be called if `ty` has no inference variables and does not\n+    /// need its lifetimes preserved (e.g. as part of codegen); otherwise\n+    /// normalization attempt may cause compiler bugs.\n+    pub fn struct_tail_erasing_lifetimes(self,\n+                                         ty: Ty<'tcx>,\n+                                         param_env: ty::ParamEnv<'tcx>)\n+                                         -> Ty<'tcx>\n+    {\n+        let tcx = self;\n+        tcx.struct_tail_with_normalize(ty, |ty| tcx.normalize_erasing_regions(param_env, ty))\n+    }\n+\n+    /// Returns the deeply last field of nested structures, or the same type if\n+    /// not a structure at all. Corresponds to the only possible unsized field,\n+    /// and its type can be used to determine unsizing strategy.\n+    ///\n+    /// This is parameterized over the normalization strategy (i.e. how to\n+    /// handle `<T as Trait>::Assoc` and `impl Trait`); pass the identity\n+    /// function to indicate no normalization should take place.\n+    ///\n+    /// See also `struct_tail_erasing_lifetimes`, which is suitable for use\n+    /// during codegen.\n+    pub fn struct_tail_with_normalize(self,\n+                                      mut ty: Ty<'tcx>,\n+                                      normalize: impl Fn(Ty<'tcx>) -> Ty<'tcx>)\n+                                      -> Ty<'tcx>\n+    {\n         loop {\n             match ty.sty {\n                 ty::Adt(def, substs) => {\n@@ -281,6 +317,15 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }\n                 }\n \n+                ty::Projection(_) | ty::Opaque(..) => {\n+                    let normalized = normalize(ty);\n+                    if ty == normalized {\n+                        return ty;\n+                    } else {\n+                        ty = normalized;\n+                    }\n+                }\n+\n                 _ => {\n                     break;\n                 }\n@@ -294,10 +339,35 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// structure definitions.\n     /// For `(Foo<Foo<T>>, Foo<dyn Trait>)`, the result will be `(Foo<T>, Trait)`,\n     /// whereas struct_tail produces `T`, and `Trait`, respectively.\n-    pub fn struct_lockstep_tails(self,\n-                                 source: Ty<'tcx>,\n-                                 target: Ty<'tcx>)\n-                                 -> (Ty<'tcx>, Ty<'tcx>) {\n+    ///\n+    /// Should only be called if the types have no inference variables and do\n+    /// not need their lifetimes preserved (e.g. as part of codegen); otherwise\n+    /// normalization attempt may cause compiler bugs.\n+    pub fn struct_lockstep_tails_erasing_lifetimes(self,\n+                                                   source: Ty<'tcx>,\n+                                                   target: Ty<'tcx>,\n+                                                   param_env: ty::ParamEnv<'tcx>)\n+                                                   -> (Ty<'tcx>, Ty<'tcx>)\n+    {\n+        let tcx = self;\n+        tcx.struct_lockstep_tails_with_normalize(\n+            source, target, |ty| tcx.normalize_erasing_regions(param_env, ty))\n+    }\n+\n+    /// Same as applying struct_tail on `source` and `target`, but only\n+    /// keeps going as long as the two types are instances of the same\n+    /// structure definitions.\n+    /// For `(Foo<Foo<T>>, Foo<dyn Trait>)`, the result will be `(Foo<T>, Trait)`,\n+    /// whereas struct_tail produces `T`, and `Trait`, respectively.\n+    ///\n+    /// See also `struct_lockstep_tails_erasing_lifetimes`, which is suitable for use\n+    /// during codegen.\n+    pub fn struct_lockstep_tails_with_normalize(self,\n+                                                source: Ty<'tcx>,\n+                                                target: Ty<'tcx>,\n+                                                normalize: impl Fn(Ty<'tcx>) -> Ty<'tcx>)\n+                                                -> (Ty<'tcx>, Ty<'tcx>)\n+    {\n         let (mut a, mut b) = (source, target);\n         loop {\n             match (&a.sty, &b.sty) {\n@@ -319,6 +389,22 @@ impl<'tcx> TyCtxt<'tcx> {\n                         break;\n                     }\n                 },\n+                (ty::Projection(_), _) | (ty::Opaque(..), _) |\n+                (_, ty::Projection(_)) | (_, ty::Opaque(..)) => {\n+                    // If either side is a projection, attempt to\n+                    // progress via normalization. (Should be safe to\n+                    // apply to both sides as normalization is\n+                    // idempotent.)\n+                    let a_norm = normalize(a);\n+                    let b_norm = normalize(b);\n+                    if a == a_norm && b == b_norm {\n+                        break;\n+                    } else {\n+                        a = a_norm;\n+                        b = b_norm;\n+                    }\n+                }\n+\n                 _ => break,\n             }\n         }"}, {"sha": "00471095f2f3517efcba016c7b74307bfe4fdba7", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=833dada10632814723426f07c53c9913dfec50c3", "patch": "@@ -128,7 +128,8 @@ pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n     target: Ty<'tcx>,\n     old_info: Option<Cx::Value>,\n ) -> Cx::Value {\n-    let (source, target) = cx.tcx().struct_lockstep_tails(source, target);\n+    let (source, target) =\n+        cx.tcx().struct_lockstep_tails_erasing_lifetimes(source, target, cx.param_env());\n     match (&source.sty, &target.sty) {\n         (&ty::Array(_, len), &ty::Slice(_)) => {\n             cx.const_usize(len.unwrap_usize(cx.tcx()))"}, {"sha": "13f72e23819a1ac9b62df9b4141225ee7acaaa6c", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=833dada10632814723426f07c53c9913dfec50c3", "patch": "@@ -77,11 +77,12 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n     }\n \n     fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n-        if ty.is_sized(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all()) {\n+        let param_env = ty::ParamEnv::reveal_all();\n+        if ty.is_sized(self.tcx().at(DUMMY_SP), param_env) {\n             return false;\n         }\n \n-        let tail = self.tcx().struct_tail(ty);\n+        let tail = self.tcx().struct_tail_erasing_lifetimes(ty, param_env);\n         match tail.sty {\n             ty::Foreign(..) => false,\n             ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,"}, {"sha": "980697360eb7574e95778f7dca4374f89323f723", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=833dada10632814723426f07c53c9913dfec50c3", "patch": "@@ -270,7 +270,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         dty: Ty<'tcx>,\n     ) -> InterpResult<'tcx> {\n         // A<Struct> -> A<Trait> conversion\n-        let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(sty, dty);\n+        let (src_pointee_ty, dest_pointee_ty) =\n+            self.tcx.struct_lockstep_tails_erasing_lifetimes(sty, dty, self.param_env);\n \n         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n             (&ty::Array(_, length), &ty::Slice(_)) => {"}, {"sha": "bcd36ac547c730525d2e0c5a13d7acee428362a5", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=833dada10632814723426f07c53c9913dfec50c3", "patch": "@@ -146,7 +146,9 @@ for\n             let value = self.ecx.read_immediate(mplace.into())?;\n             // Handle trait object vtables\n             if let Ok(meta) = value.to_meta() {\n-                if let ty::Dynamic(..) = self.ecx.tcx.struct_tail(referenced_ty).sty {\n+                if let ty::Dynamic(..) =\n+                    self.ecx.tcx.struct_tail_erasing_lifetimes(referenced_ty, self.param_env).sty\n+                {\n                     if let Ok(vtable) = meta.unwrap().to_ptr() {\n                         // explitly choose `Immutable` here, since vtables are immutable, even\n                         // if the reference of the fat pointer is mutable"}, {"sha": "b1b8e9751381add0f0a89d9d11613ea8b4549bd4", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=833dada10632814723426f07c53c9913dfec50c3", "patch": "@@ -361,7 +361,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     \"uninitialized data in fat pointer metadata\", self.path);\n                 let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n                 if layout.is_unsized() {\n-                    let tail = self.ecx.tcx.struct_tail(layout.ty);\n+                    let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(layout.ty,\n+                                                                          self.ecx.param_env);\n                     match tail.sty {\n                         ty::Dynamic(..) => {\n                             let vtable = meta.unwrap();"}, {"sha": "6e9390f77508bc4a2499636dccd9c7c2bbf37a45", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=833dada10632814723426f07c53c9913dfec50c3", "patch": "@@ -851,12 +851,13 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     target_ty: Ty<'tcx>,\n ) -> (Ty<'tcx>, Ty<'tcx>) {\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n+        let param_env = ty::ParamEnv::reveal_all();\n         let type_has_metadata = |ty: Ty<'tcx>| -> bool {\n             use syntax_pos::DUMMY_SP;\n-            if ty.is_sized(tcx.at(DUMMY_SP), ty::ParamEnv::reveal_all()) {\n+            if ty.is_sized(tcx.at(DUMMY_SP), param_env) {\n                 return false;\n             }\n-            let tail = tcx.struct_tail(ty);\n+            let tail = tcx.struct_tail_erasing_lifetimes(ty, param_env);\n             match tail.sty {\n                 ty::Foreign(..) => false,\n                 ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n@@ -866,7 +867,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n         if type_has_metadata(inner_source) {\n             (inner_source, inner_target)\n         } else {\n-            tcx.struct_lockstep_tails(inner_source, inner_target)\n+            tcx.struct_lockstep_tails_erasing_lifetimes(inner_source, inner_target, param_env)\n         }\n     };\n "}, {"sha": "77d45cfa63c10ed0c07dc4b486bedfe2377faaab", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=833dada10632814723426f07c53c9913dfec50c3", "patch": "@@ -315,7 +315,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     /// See the test case `test/run-pass/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n     fn rvalue_hint(fcx: &FnCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n-        match fcx.tcx.struct_tail(ty).sty {\n+        match fcx.tcx.struct_tail_without_normalization(ty).sty {\n             ty::Slice(_) | ty::Str | ty::Dynamic(..) => {\n                 ExpectRvalueLikeUnsized(ty)\n             }"}, {"sha": "68e5e7d4fd2454176bf54c1d014ceaa02846b31c", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/833dada10632814723426f07c53c9913dfec50c3/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=833dada10632814723426f07c53c9913dfec50c3", "patch": "@@ -366,7 +366,8 @@ fn check_item_type(\n \n         let mut forbid_unsized = true;\n         if allow_foreign_ty {\n-            if let ty::Foreign(_) = fcx.tcx.struct_tail(item_ty).sty {\n+            let tail = fcx.tcx.struct_tail_erasing_lifetimes(item_ty, fcx.param_env);\n+            if let ty::Foreign(_) = tail.sty {\n                 forbid_unsized = false;\n             }\n         }"}, {"sha": "65845d2c9fece9094789d7c46a3dbfefde8c757a", "filename": "src/test/ui/layout/issue-60431-unsized-tail-behind-projection.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/833dada10632814723426f07c53c9913dfec50c3/src%2Ftest%2Fui%2Flayout%2Fissue-60431-unsized-tail-behind-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/833dada10632814723426f07c53c9913dfec50c3/src%2Ftest%2Fui%2Flayout%2Fissue-60431-unsized-tail-behind-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fissue-60431-unsized-tail-behind-projection.rs?ref=833dada10632814723426f07c53c9913dfec50c3", "patch": "@@ -0,0 +1,35 @@\n+// rust-lang/rust#60431: This is a scenario where to determine the size of\n+// `&Ref<Obstack>`, we need to know the concrete type of the last field in\n+// `Ref<Obstack>` (i.e. its \"struct tail\"), and determining that concrete type\n+// requires normalizing `Obstack::Dyn`.\n+//\n+// The old \"struct tail\" computation did not perform such normalization, and so\n+// the compiler would ICE when trying to figure out if `Ref<Obstack>` is a\n+// dynamically-sized type (DST).\n+\n+// run-pass\n+\n+use std::mem;\n+\n+pub trait Arena {\n+    type Dyn : ?Sized;\n+}\n+\n+pub struct DynRef {\n+    _dummy: [()],\n+}\n+\n+pub struct Ref<A: Arena> {\n+    _value: u8,\n+    _dyn_arena: A::Dyn,\n+}\n+\n+pub struct Obstack;\n+\n+impl Arena for Obstack {\n+    type Dyn = DynRef;\n+}\n+\n+fn main() {\n+    assert_eq!(mem::size_of::<&Ref<Obstack>>(), mem::size_of::<&[()]>());\n+}"}]}