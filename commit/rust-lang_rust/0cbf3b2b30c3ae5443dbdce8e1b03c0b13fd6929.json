{"sha": "0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "node_id": "C_kwDOAAsO6NoAKDBjYmYzYjJiMzBjM2FlNTQ0M2RiZGNlOGUxYjAzYzBiMTNmZDY5Mjk", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-28T18:13:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-28T18:13:02Z"}, "message": "Rollup merge of #96433 - petrochenkov:delim, r=nnethercote\n\nrustc_ast: Harmonize delimiter naming with `proc_macro::Delimiter`\n\nCompiler cannot reuse `proc_macro::Delimiter` directly due to extra impls, but can at least use the same naming.\n\nAfter this PR the only difference between these two enums is that `proc_macro::Delimiter::None` is turned into `token::Delimiter::Invisible`.\nIt's my mistake that the invisible delimiter is called `None` on stable, during the stabilization I audited the naming and wrote the docs, but missed the fact that the `None` naming gives a wrong and confusing impression about what this thing is.\n\ncc https://github.com/rust-lang/rust/pull/96421\nr? ``@nnethercote``", "tree": {"sha": "0d1cdf7f513cdf905818039db967b08fa15cfc89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d1cdf7f513cdf905818039db967b08fa15cfc89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiatkvCRBK7hj4Ov3rIwAAMqUIAKst/p2BM2R6xXFf8XQE9AjL\nIkY6n1lNcksaatmojDfcMeqUOrhDYsKSyA+LSRPopp7gI5ihJ/hpJ+71TzY31UmY\np+GhgJMlfzCjyA93p7LxhPinEqpAgJ2+kDNvXRT6W+kg01pLttapDgQIe/TRvYUJ\nO8AhxomXgCpF7Z6Olm4+LBc52tt6vmlhuh4PECvlY1qKeDJeJErLQLSGWsdeEDYP\n6tv7dkZNEOx8iUlZ+fdJXcVT5tI0y44AOIr32hyVVAnBsRJxiWvwSUgavbcGVT3W\n3ZbUEtfeSlDWBhdE4tZlt3xi2sQclVbKAQYo5RmKqWqhE8T//79SlKgYGzGYCqk=\n=zzXF\n-----END PGP SIGNATURE-----\n", "payload": "tree 0d1cdf7f513cdf905818039db967b08fa15cfc89\nparent cbfbc3be7d1fd5090bdcb1e3c53fa4d894aa99f4\nparent 2733ec1be34b1ae9f22c70c901bb89229adf9def\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1651169582 +0200\ncommitter GitHub <noreply@github.com> 1651169582 +0200\n\nRollup merge of #96433 - petrochenkov:delim, r=nnethercote\n\nrustc_ast: Harmonize delimiter naming with `proc_macro::Delimiter`\n\nCompiler cannot reuse `proc_macro::Delimiter` directly due to extra impls, but can at least use the same naming.\n\nAfter this PR the only difference between these two enums is that `proc_macro::Delimiter::None` is turned into `token::Delimiter::Invisible`.\nIt's my mistake that the invisible delimiter is called `None` on stable, during the stabilization I audited the naming and wrote the docs, but missed the fact that the `None` naming gives a wrong and confusing impression about what this thing is.\n\ncc https://github.com/rust-lang/rust/pull/96421\nr? ``@nnethercote``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "html_url": "https://github.com/rust-lang/rust/commit/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbfbc3be7d1fd5090bdcb1e3c53fa4d894aa99f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbfbc3be7d1fd5090bdcb1e3c53fa4d894aa99f4", "html_url": "https://github.com/rust-lang/rust/commit/cbfbc3be7d1fd5090bdcb1e3c53fa4d894aa99f4"}, {"sha": "2733ec1be34b1ae9f22c70c901bb89229adf9def", "url": "https://api.github.com/repos/rust-lang/rust/commits/2733ec1be34b1ae9f22c70c901bb89229adf9def", "html_url": "https://github.com/rust-lang/rust/commit/2733ec1be34b1ae9f22c70c901bb89229adf9def"}], "stats": {"total": 859, "additions": 433, "deletions": 426}, "files": [{"sha": "a310828b9fbfa03bfbf270215033cad9f34d35dd", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -23,7 +23,7 @@ pub use GenericArgs::*;\n pub use UnsafeSource::*;\n \n use crate::ptr::P;\n-use crate::token::{self, CommentKind, DelimToken, Token};\n+use crate::token::{self, CommentKind, Delimiter, Token};\n use crate::tokenstream::{DelimSpan, LazyTokenStream, TokenStream, TokenTree};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -1542,7 +1542,7 @@ pub enum MacArgs {\n }\n \n impl MacArgs {\n-    pub fn delim(&self) -> Option<DelimToken> {\n+    pub fn delim(&self) -> Option<Delimiter> {\n         match self {\n             MacArgs::Delimited(_, delim, _) => Some(delim.to_token()),\n             MacArgs::Empty | MacArgs::Eq(..) => None,\n@@ -1582,20 +1582,20 @@ pub enum MacDelimiter {\n }\n \n impl MacDelimiter {\n-    pub fn to_token(self) -> DelimToken {\n+    pub fn to_token(self) -> Delimiter {\n         match self {\n-            MacDelimiter::Parenthesis => DelimToken::Paren,\n-            MacDelimiter::Bracket => DelimToken::Bracket,\n-            MacDelimiter::Brace => DelimToken::Brace,\n+            MacDelimiter::Parenthesis => Delimiter::Parenthesis,\n+            MacDelimiter::Bracket => Delimiter::Bracket,\n+            MacDelimiter::Brace => Delimiter::Brace,\n         }\n     }\n \n-    pub fn from_token(delim: DelimToken) -> Option<MacDelimiter> {\n+    pub fn from_token(delim: Delimiter) -> Option<MacDelimiter> {\n         match delim {\n-            token::Paren => Some(MacDelimiter::Parenthesis),\n-            token::Bracket => Some(MacDelimiter::Bracket),\n-            token::Brace => Some(MacDelimiter::Brace),\n-            token::NoDelim => None,\n+            Delimiter::Parenthesis => Some(MacDelimiter::Parenthesis),\n+            Delimiter::Bracket => Some(MacDelimiter::Bracket),\n+            Delimiter::Brace => Some(MacDelimiter::Brace),\n+            Delimiter::Invisible => None,\n         }\n     }\n }"}, {"sha": "b14367aa1c2c2deb32d109eef53e3939b9035e19", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -5,7 +5,7 @@ use crate::ast::{AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n use crate::ast::{Lit, LitKind};\n use crate::ast::{MacArgs, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Path, PathSegment};\n-use crate::token::{self, CommentKind, Token};\n+use crate::token::{self, CommentKind, Delimiter, Token};\n use crate::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n use crate::tokenstream::{DelimSpan, Spacing, TokenTree, TreeAndSpacing};\n use crate::tokenstream::{LazyTokenStream, TokenStream};\n@@ -513,7 +513,7 @@ impl MetaItemKind {\n                 vec![\n                     TokenTree::Delimited(\n                         DelimSpan::from_single(span),\n-                        token::Paren,\n+                        Delimiter::Parenthesis,\n                         TokenStream::new(tokens),\n                     )\n                     .into(),\n@@ -540,7 +540,7 @@ impl MetaItemKind {\n         tokens: &mut impl Iterator<Item = TokenTree>,\n     ) -> Option<MetaItemKind> {\n         match tokens.next() {\n-            Some(TokenTree::Delimited(_, token::NoDelim, inner_tokens)) => {\n+            Some(TokenTree::Delimited(_, Delimiter::Invisible, inner_tokens)) => {\n                 MetaItemKind::name_value_from_tokens(&mut inner_tokens.trees())\n             }\n             Some(TokenTree::Token(token)) => {\n@@ -565,7 +565,7 @@ impl MetaItemKind {\n         tokens: &mut iter::Peekable<impl Iterator<Item = TokenTree>>,\n     ) -> Option<MetaItemKind> {\n         match tokens.peek() {\n-            Some(TokenTree::Delimited(_, token::Paren, inner_tokens)) => {\n+            Some(TokenTree::Delimited(_, Delimiter::Parenthesis, inner_tokens)) => {\n                 let inner_tokens = inner_tokens.clone();\n                 tokens.next();\n                 MetaItemKind::list_from_tokens(inner_tokens)\n@@ -606,7 +606,7 @@ impl NestedMetaItem {\n                 tokens.next();\n                 return Some(NestedMetaItem::Literal(lit));\n             }\n-            Some(TokenTree::Delimited(_, token::NoDelim, inner_tokens)) => {\n+            Some(TokenTree::Delimited(_, Delimiter::Invisible, inner_tokens)) => {\n                 let inner_tokens = inner_tokens.clone();\n                 tokens.next();\n                 return NestedMetaItem::from_tokens(&mut inner_tokens.into_trees().peekable());"}, {"sha": "1589a882f0892c99cbc1f21706797bb3ca493dd0", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,5 +1,4 @@\n pub use BinOpToken::*;\n-pub use DelimToken::*;\n pub use LitKind::*;\n pub use Nonterminal::*;\n pub use TokenKind::*;\n@@ -37,18 +36,26 @@ pub enum BinOpToken {\n     Shr,\n }\n \n-/// A delimiter token.\n-#[derive(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Debug, Copy)]\n-#[derive(HashStable_Generic)]\n-pub enum DelimToken {\n-    /// A round parenthesis (i.e., `(` or `)`).\n-    Paren,\n-    /// A square bracket (i.e., `[` or `]`).\n-    Bracket,\n-    /// A curly brace (i.e., `{` or `}`).\n+/// Describes how a sequence of token trees is delimited.\n+/// Cannot use `proc_macro::Delimiter` directly because this\n+/// structure should implement some additional traits.\n+/// The `None` variant is also renamed to `Invisible` to be\n+/// less confusing and better convey the semantics.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Encodable, Decodable, Hash, HashStable_Generic)]\n+pub enum Delimiter {\n+    /// `( ... )`\n+    Parenthesis,\n+    /// `{ ... }`\n     Brace,\n-    /// An empty delimiter.\n-    NoDelim,\n+    /// `[ ... ]`\n+    Bracket,\n+    /// `\u00d8 ... \u00d8`\n+    /// An invisible delimiter, that may, for example, appear around tokens coming from a\n+    /// \"macro variable\" `$var`. It is important to preserve operator priorities in cases like\n+    /// `$var * 3` where `$var` is `1 + 2`.\n+    /// Invisible delimiters might not survive roundtrip of a token stream through a string.\n+    Invisible,\n }\n \n #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n@@ -212,9 +219,9 @@ pub enum TokenKind {\n     /// Used by proc macros for representing lifetimes, not generated by lexer right now.\n     SingleQuote,\n     /// An opening delimiter (e.g., `{`).\n-    OpenDelim(DelimToken),\n+    OpenDelim(Delimiter),\n     /// A closing delimiter (e.g., `}`).\n-    CloseDelim(DelimToken),\n+    CloseDelim(Delimiter),\n \n     /* Literals */\n     Literal(Lit),\n@@ -387,8 +394,8 @@ impl Token {\n         match self.uninterpolate().kind {\n             Ident(name, is_raw)        =>\n                 ident_can_begin_type(name, self.span, is_raw), // type name or keyword\n-            OpenDelim(Paren)            | // tuple\n-            OpenDelim(Bracket)          | // array\n+            OpenDelim(Delimiter::Parenthesis) | // tuple\n+            OpenDelim(Delimiter::Bracket)     | // array\n             Not                         | // never\n             BinOp(Star)                 | // raw pointer\n             BinOp(And)                  | // reference\n@@ -405,7 +412,7 @@ impl Token {\n     /// Returns `true` if the token can appear at the start of a const param.\n     pub fn can_begin_const_arg(&self) -> bool {\n         match self.kind {\n-            OpenDelim(Brace) => true,\n+            OpenDelim(Delimiter::Brace) => true,\n             Interpolated(ref nt) => matches!(**nt, NtExpr(..) | NtBlock(..) | NtLiteral(..)),\n             _ => self.can_begin_literal_maybe_minus(),\n         }\n@@ -417,7 +424,7 @@ impl Token {\n             || self.is_lifetime()\n             || self.is_keyword(kw::For)\n             || self == &Question\n-            || self == &OpenDelim(Paren)\n+            || self == &OpenDelim(Delimiter::Parenthesis)\n     }\n \n     /// Returns `true` if the token is any literal."}, {"sha": "a8f29f334070e9f4324fdf75e14a1c94818d3d9b", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -13,7 +13,7 @@\n //! and a borrowed `TokenStream` is sufficient to build an owned `TokenStream` without taking\n //! ownership of the original.\n \n-use crate::token::{self, DelimToken, Token, TokenKind};\n+use crate::token::{self, Delimiter, Token, TokenKind};\n use crate::AttrVec;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -42,7 +42,7 @@ pub enum TokenTree {\n     /// A single token.\n     Token(Token),\n     /// A delimited sequence of token trees.\n-    Delimited(DelimSpan, DelimToken, TokenStream),\n+    Delimited(DelimSpan, Delimiter, TokenStream),\n }\n \n #[derive(Copy, Clone)]\n@@ -57,7 +57,7 @@ fn _dummy()\n where\n     Token: Send + Sync,\n     DelimSpan: Send + Sync,\n-    DelimToken: Send + Sync,\n+    Delimiter: Send + Sync,\n     TokenStream: Send + Sync,\n {\n }\n@@ -175,7 +175,7 @@ pub struct AttrAnnotatedTokenStream(pub Lrc<Vec<(AttrAnnotatedTokenTree, Spacing\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub enum AttrAnnotatedTokenTree {\n     Token(Token),\n-    Delimited(DelimSpan, DelimToken, AttrAnnotatedTokenStream),\n+    Delimited(DelimSpan, Delimiter, AttrAnnotatedTokenStream),\n     /// Stores the attributes for an attribute target,\n     /// along with the tokens for that attribute target.\n     /// See `AttributesData` for more information"}, {"sha": "de4f8e04b1689cf6a7e7e2fa10f488657a6f5a12", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -38,7 +38,7 @@\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n \n-use rustc_ast::token::{self, Token};\n+use rustc_ast::token::{Delimiter, Token};\n use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream, TokenTree};\n use rustc_ast::visit;\n use rustc_ast::{self as ast, *};\n@@ -886,7 +886,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     match tokens.into_trees().next() {\n                         Some(TokenTree::Token(token)) => token,\n                         Some(TokenTree::Delimited(_, delim, tokens)) => {\n-                            if delim != token::NoDelim {\n+                            if delim != Delimiter::Invisible {\n                                 sess.diagnostic().delay_span_bug(\n                                     span,\n                                     \"unexpected delimiter in key-value attribute's value\","}, {"sha": "a2ebe3048ceee91a1426eae54ab7199f2a5bbd12", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -6,7 +6,7 @@ use crate::pp::Breaks::{Consistent, Inconsistent};\n use crate::pp::{self, Breaks};\n \n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, BinOpToken, CommentKind, DelimToken, Nonterminal, Token, TokenKind};\n+use rustc_ast::token::{self, BinOpToken, CommentKind, Delimiter, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n@@ -155,10 +155,10 @@ fn tt_prepend_space(tt: &TokenTree, prev: &TokenTree) -> bool {\n     }\n     match tt {\n         TokenTree::Token(token) => !matches!(token.kind, token::Comma | token::Not | token::Dot),\n-        TokenTree::Delimited(_, DelimToken::Paren, _) => {\n+        TokenTree::Delimited(_, Delimiter::Parenthesis, _) => {\n             !matches!(prev, TokenTree::Token(Token { kind: token::Ident(..), .. }))\n         }\n-        TokenTree::Delimited(_, DelimToken::Bracket, _) => {\n+        TokenTree::Delimited(_, Delimiter::Bracket, _) => {\n             !matches!(prev, TokenTree::Token(Token { kind: token::Pound, .. }))\n         }\n         TokenTree::Delimited(..) => true,\n@@ -556,12 +556,12 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         header: Option<MacHeader<'_>>,\n         has_bang: bool,\n         ident: Option<Ident>,\n-        delim: Option<DelimToken>,\n+        delim: Option<Delimiter>,\n         tts: &TokenStream,\n         convert_dollar_crate: bool,\n         span: Span,\n     ) {\n-        if delim == Some(DelimToken::Brace) {\n+        if delim == Some(Delimiter::Brace) {\n             self.cbox(INDENT_UNIT);\n         }\n         match header {\n@@ -577,7 +577,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             self.print_ident(ident);\n         }\n         match delim {\n-            Some(DelimToken::Brace) => {\n+            Some(Delimiter::Brace) => {\n                 if header.is_some() || has_bang || ident.is_some() {\n                     self.nbsp();\n                 }\n@@ -758,13 +758,15 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             token::RArrow => \"->\".into(),\n             token::LArrow => \"<-\".into(),\n             token::FatArrow => \"=>\".into(),\n-            token::OpenDelim(token::Paren) => \"(\".into(),\n-            token::CloseDelim(token::Paren) => \")\".into(),\n-            token::OpenDelim(token::Bracket) => \"[\".into(),\n-            token::CloseDelim(token::Bracket) => \"]\".into(),\n-            token::OpenDelim(token::Brace) => \"{\".into(),\n-            token::CloseDelim(token::Brace) => \"}\".into(),\n-            token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim) => \"\".into(),\n+            token::OpenDelim(Delimiter::Parenthesis) => \"(\".into(),\n+            token::CloseDelim(Delimiter::Parenthesis) => \")\".into(),\n+            token::OpenDelim(Delimiter::Bracket) => \"[\".into(),\n+            token::CloseDelim(Delimiter::Bracket) => \"]\".into(),\n+            token::OpenDelim(Delimiter::Brace) => \"{\".into(),\n+            token::CloseDelim(Delimiter::Brace) => \"}\".into(),\n+            token::OpenDelim(Delimiter::Invisible) | token::CloseDelim(Delimiter::Invisible) => {\n+                \"\".into()\n+            }\n             token::Pound => \"#\".into(),\n             token::Dollar => \"$\".into(),\n             token::Question => \"?\".into(),"}, {"sha": "e9e3307ca95dac89f377ba83f0cb894baf27a025", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n-use rustc_ast::token;\n+use rustc_ast::token::{self, Delimiter};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{Applicability, PResult};\n@@ -395,9 +395,9 @@ fn parse_options<'a>(\n ) -> PResult<'a, ()> {\n     let span_start = p.prev_token.span;\n \n-    p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n+    p.expect(&token::OpenDelim(Delimiter::Parenthesis))?;\n \n-    while !p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n+    while !p.eat(&token::CloseDelim(Delimiter::Parenthesis)) {\n         if !is_global_asm && p.eat_keyword(sym::pure) {\n             try_set_option(p, args, sym::pure, ast::InlineAsmOptions::PURE);\n         } else if !is_global_asm && p.eat_keyword(sym::nomem) {\n@@ -421,7 +421,7 @@ fn parse_options<'a>(\n         }\n \n         // Allow trailing commas\n-        if p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n+        if p.eat(&token::CloseDelim(Delimiter::Parenthesis)) {\n             break;\n         }\n         p.expect(&token::Comma)?;\n@@ -436,9 +436,9 @@ fn parse_options<'a>(\n fn parse_clobber_abi<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> PResult<'a, ()> {\n     let span_start = p.prev_token.span;\n \n-    p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n+    p.expect(&token::OpenDelim(Delimiter::Parenthesis))?;\n \n-    if p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n+    if p.eat(&token::CloseDelim(Delimiter::Parenthesis)) {\n         let err = p.sess.span_diagnostic.struct_span_err(\n             p.token.span,\n             \"at least one abi must be provided as an argument to `clobber_abi`\",\n@@ -454,7 +454,7 @@ fn parse_clobber_abi<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> PResult<'a,\n             }\n             Err(opt_lit) => {\n                 // If the non-string literal is a closing paren then it's the end of the list and is fine\n-                if p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n+                if p.eat(&token::CloseDelim(Delimiter::Parenthesis)) {\n                     break;\n                 }\n                 let span = opt_lit.map_or(p.token.span, |lit| lit.span);\n@@ -466,7 +466,7 @@ fn parse_clobber_abi<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> PResult<'a,\n         };\n \n         // Allow trailing commas\n-        if p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n+        if p.eat(&token::CloseDelim(Delimiter::Parenthesis)) {\n             break;\n         }\n         p.expect(&token::Comma)?;\n@@ -501,7 +501,7 @@ fn parse_reg<'a>(\n     p: &mut Parser<'a>,\n     explicit_reg: &mut bool,\n ) -> PResult<'a, ast::InlineAsmRegOrRegClass> {\n-    p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n+    p.expect(&token::OpenDelim(Delimiter::Parenthesis))?;\n     let result = match p.token.uninterpolate().kind {\n         token::Ident(name, false) => ast::InlineAsmRegOrRegClass::RegClass(name),\n         token::Literal(token::Lit { kind: token::LitKind::Str, symbol, suffix: _ }) => {\n@@ -515,7 +515,7 @@ fn parse_reg<'a>(\n         }\n     };\n     p.bump();\n-    p.expect(&token::CloseDelim(token::DelimToken::Paren))?;\n+    p.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n     Ok(result)\n }\n "}, {"sha": "a9c7ba5d072d217ed3d1d344f6133cf0163bdb3a", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,7 +1,7 @@\n //! Conditional compilation stripping.\n \n use rustc_ast::ptr::P;\n-use rustc_ast::token::{DelimToken, Token, TokenKind};\n+use rustc_ast::token::{Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n use rustc_ast::tokenstream::{DelimSpan, Spacing};\n use rustc_ast::tokenstream::{LazyTokenStream, TokenTree};\n@@ -418,7 +418,7 @@ impl<'a> StripUnconfigured<'a> {\n         // in `#[attr]`, so just use the span of the `#` token.\n         let bracket_group = AttrAnnotatedTokenTree::Delimited(\n             DelimSpan::from_single(pound_span),\n-            DelimToken::Bracket,\n+            Delimiter::Bracket,\n             item.tokens\n                 .as_ref()\n                 .unwrap_or_else(|| panic!(\"Missing tokens for {:?}\", item))"}, {"sha": "5bd89f3f42fa563c01888fee0d3904a16ef233c8", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -8,7 +8,7 @@ use crate::placeholders::{placeholder, PlaceholderExpander};\n use rustc_ast as ast;\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n-use rustc_ast::token;\n+use rustc_ast::token::{self, Delimiter};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{AssocItemKind, AstLike, AstLikeWrapper, AttrStyle, ExprKind, ForeignItemKind};\n@@ -884,7 +884,7 @@ pub fn parse_ast_fragment<'a>(\n         AstFragmentKind::Stmts => {\n             let mut stmts = SmallVec::new();\n             // Won't make progress on a `}`.\n-            while this.token != token::Eof && this.token != token::CloseDelim(token::Brace) {\n+            while this.token != token::Eof && this.token != token::CloseDelim(Delimiter::Brace) {\n                 if let Some(stmt) = this.parse_full_stmt(AttemptLocalParseRecovery::Yes)? {\n                     stmts.push(stmt);\n                 }"}, {"sha": "36295da74adc5598ccf4898c8fe7913a7cbc23f4", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -11,16 +11,16 @@ crate mod quoted;\n crate mod transcribe;\n \n use metavar_expr::MetaVarExpr;\n-use rustc_ast::token::{self, NonterminalKind, Token, TokenKind};\n+use rustc_ast::token::{Delimiter, NonterminalKind, Token, TokenKind};\n use rustc_ast::tokenstream::DelimSpan;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n-/// Contains the sub-token-trees of a \"delimited\" token tree such as `(a b c)`. The delimiters\n-/// might be `NoDelim`, but they are not represented explicitly.\n+/// Contains the sub-token-trees of a \"delimited\" token tree such as `(a b c)`.\n+/// The delimiters are not represented explicitly in the `tts` vector.\n #[derive(PartialEq, Encodable, Decodable, Debug)]\n struct Delimited {\n-    delim: token::DelimToken,\n+    delim: Delimiter,\n     /// FIXME: #67062 has details about why this is sub-optimal.\n     tts: Vec<TokenTree>,\n }"}, {"sha": "35b5e0d0f2f61108b123b1bba46ba9240209ffdf", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -106,7 +106,7 @@\n //! bound.\n use crate::mbe::{KleeneToken, TokenTree};\n \n-use rustc_ast::token::{DelimToken, Token, TokenKind};\n+use rustc_ast::token::{Delimiter, Token, TokenKind};\n use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::MultiSpan;\n@@ -439,7 +439,7 @@ fn check_nested_occurrences(\n             }\n             (NestedMacroState::MacroRulesNotName, &TokenTree::Delimited(_, ref del))\n             | (NestedMacroState::MacroName, &TokenTree::Delimited(_, ref del))\n-                if del.delim == DelimToken::Brace =>\n+                if del.delim == Delimiter::Brace =>\n             {\n                 let macro_rules = state == NestedMacroState::MacroRulesNotName;\n                 state = NestedMacroState::Empty;\n@@ -469,7 +469,7 @@ fn check_nested_occurrences(\n                 check_occurrences(sess, node_id, tt, macros, binders, ops, valid);\n             }\n             (NestedMacroState::MacroName, &TokenTree::Delimited(_, ref del))\n-                if del.delim == DelimToken::Paren =>\n+                if del.delim == Delimiter::Parenthesis =>\n             {\n                 state = NestedMacroState::MacroNameParen;\n                 nested_binders = Binders::default();\n@@ -484,7 +484,7 @@ fn check_nested_occurrences(\n                 );\n             }\n             (NestedMacroState::MacroNameParen, &TokenTree::Delimited(_, ref del))\n-                if del.delim == DelimToken::Brace =>\n+                if del.delim == Delimiter::Brace =>\n             {\n                 state = NestedMacroState::Empty;\n                 check_occurrences("}, {"sha": "050710097c331de9f5b2546fce4c57d5992f3c2b", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -8,7 +8,7 @@ use crate::mbe::macro_parser::{MatchedSeq, MatchedTokenTree, MatcherLoc};\n use crate::mbe::transcribe::transcribe;\n \n use rustc_ast as ast;\n-use rustc_ast::token::{self, NonterminalKind, Token, TokenKind, TokenKind::*};\n+use rustc_ast::token::{self, Delimiter, NonterminalKind, Token, TokenKind, TokenKind::*};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream};\n use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n@@ -1250,8 +1250,8 @@ fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n                 ];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n-                        OpenDelim(token::DelimToken::Brace)\n-                        | OpenDelim(token::DelimToken::Bracket)\n+                        OpenDelim(Delimiter::Brace)\n+                        | OpenDelim(Delimiter::Bracket)\n                         | Comma\n                         | FatArrow\n                         | Colon"}, {"sha": "cdc5e204236fb29062f261094bb5abe94f9d29f1", "filename": "compiler/rustc_expand/src/mbe/metavar_expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::token;\n+use rustc_ast::token::{self, Delimiter};\n use rustc_ast::tokenstream::{Cursor, TokenStream, TokenTree};\n use rustc_ast::{LitIntType, LitKind};\n use rustc_ast_pretty::pprust;\n@@ -35,7 +35,7 @@ impl MetaVarExpr {\n     ) -> PResult<'sess, MetaVarExpr> {\n         let mut tts = input.trees();\n         let ident = parse_ident(&mut tts, sess, outer_span)?;\n-        let Some(TokenTree::Delimited(_, token::Paren, args)) = tts.next() else {\n+        let Some(TokenTree::Delimited(_, Delimiter::Parenthesis, args)) = tts.next() else {\n             let msg = \"meta-variable expression parameter must be wrapped in parentheses\";\n             return Err(sess.span_diagnostic.struct_span_err(ident.span, msg));\n         };"}, {"sha": "d52de24c393b7907f8ef8e42328d99810457557b", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,7 +1,7 @@\n use crate::mbe::macro_parser::count_metavar_decls;\n use crate::mbe::{Delimited, KleeneOp, KleeneToken, MetaVarExpr, SequenceRepetition, TokenTree};\n \n-use rustc_ast::token::{self, Token};\n+use rustc_ast::token::{self, Delimiter, Token};\n use rustc_ast::{tokenstream, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_feature::Features;\n@@ -147,11 +147,11 @@ fn parse_tree(\n     match tree {\n         // `tree` is a `$` token. Look at the next token in `trees`\n         tokenstream::TokenTree::Token(Token { kind: token::Dollar, span }) => {\n-            // FIXME: Handle `None`-delimited groups in a more systematic way\n+            // FIXME: Handle `Invisible`-delimited groups in a more systematic way\n             // during parsing.\n             let mut next = outer_trees.next();\n             let mut trees: Box<dyn Iterator<Item = tokenstream::TokenTree>>;\n-            if let Some(tokenstream::TokenTree::Delimited(_, token::NoDelim, tts)) = next {\n+            if let Some(tokenstream::TokenTree::Delimited(_, Delimiter::Invisible, tts)) = next {\n                 trees = Box::new(tts.into_trees());\n                 next = trees.next();\n             } else {\n@@ -162,15 +162,15 @@ fn parse_tree(\n                 // `tree` is followed by a delimited set of token trees.\n                 Some(tokenstream::TokenTree::Delimited(delim_span, delim, tts)) => {\n                     if parsing_patterns {\n-                        if delim != token::Paren {\n+                        if delim != Delimiter::Parenthesis {\n                             span_dollar_dollar_or_metavar_in_the_lhs_err(\n                                 sess,\n                                 &Token { kind: token::OpenDelim(delim), span: delim_span.entire() },\n                             );\n                         }\n                     } else {\n                         match delim {\n-                            token::Brace => {\n+                            Delimiter::Brace => {\n                                 // The delimiter is `{`.  This indicates the beginning\n                                 // of a meta-variable expression (e.g. `${count(ident)}`).\n                                 // Try to parse the meta-variable expression.\n@@ -191,7 +191,7 @@ fn parse_tree(\n                                     }\n                                 }\n                             }\n-                            token::Paren => {}\n+                            Delimiter::Parenthesis => {}\n                             _ => {\n                                 let tok = pprust::token_kind_to_string(&token::OpenDelim(delim));\n                                 let msg = format!(\"expected `(` or `{{`, found `{}`\", tok);"}, {"sha": "94b6c3153ca30128c3f12df5c6c5b66d30156672", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -2,7 +2,7 @@ use crate::base::ExtCtxt;\n use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, MatchedTokenTree, NamedMatch};\n use crate::mbe::{self, MetaVarExpr};\n use rustc_ast::mut_visit::{self, MutVisitor};\n-use rustc_ast::token::{self, Token, TokenKind};\n+use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndSpacing};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, PResult};\n@@ -27,23 +27,14 @@ impl MutVisitor for Marker {\n \n /// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).\n enum Frame<'a> {\n-    Delimited {\n-        tts: &'a [mbe::TokenTree],\n-        idx: usize,\n-        delim_token: token::DelimToken,\n-        span: DelimSpan,\n-    },\n-    Sequence {\n-        tts: &'a [mbe::TokenTree],\n-        idx: usize,\n-        sep: Option<Token>,\n-    },\n+    Delimited { tts: &'a [mbe::TokenTree], idx: usize, delim: Delimiter, span: DelimSpan },\n+    Sequence { tts: &'a [mbe::TokenTree], idx: usize, sep: Option<Token> },\n }\n \n impl<'a> Frame<'a> {\n     /// Construct a new frame around the delimited set of tokens.\n     fn new(src: &'a mbe::Delimited, span: DelimSpan) -> Frame<'a> {\n-        Frame::Delimited { tts: &src.tts, idx: 0, delim_token: src.delim, span }\n+        Frame::Delimited { tts: &src.tts, idx: 0, delim: src.delim, span }\n     }\n }\n \n@@ -150,14 +141,14 @@ pub(super) fn transcribe<'a>(\n                 // We are done processing a Delimited. If this is the top-level delimited, we are\n                 // done. Otherwise, we unwind the result_stack to append what we have produced to\n                 // any previous results.\n-                Frame::Delimited { delim_token, span, .. } => {\n+                Frame::Delimited { delim, span, .. } => {\n                     if result_stack.is_empty() {\n                         // No results left to compute! We are back at the top-level.\n                         return Ok(TokenStream::new(result));\n                     }\n \n                     // Step back into the parent Delimited.\n-                    let tree = TokenTree::Delimited(span, delim_token, TokenStream::new(result));\n+                    let tree = TokenTree::Delimited(span, delim, TokenStream::new(result));\n                     result = result_stack.pop().unwrap();\n                     result.push(tree.into());\n                 }\n@@ -240,7 +231,7 @@ pub(super) fn transcribe<'a>(\n                         }\n                         MatchedNonterminal(ref nt) => {\n                             // Other variables are emitted into the output stream as groups with\n-                            // `Delimiter::None` to maintain parsing priorities.\n+                            // `Delimiter::Invisible` to maintain parsing priorities.\n                             // `Interpolated` is currently used for such groups in rustc parser.\n                             marker.visit_span(&mut sp);\n                             let token = TokenTree::token(token::Interpolated(nt.clone()), sp);\n@@ -278,7 +269,7 @@ pub(super) fn transcribe<'a>(\n                 mut_visit::visit_delim_span(&mut span, &mut marker);\n                 stack.push(Frame::Delimited {\n                     tts: &delimited.tts,\n-                    delim_token: delimited.delim,\n+                    delim: delimited.delim,\n                     idx: 0,\n                     span,\n                 });"}, {"sha": "5d447d911e7f4e1b7920f3282abdd1a679996df5", "filename": "compiler/rustc_expand/src/parse/tests.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,7 +1,7 @@\n use crate::tests::{matches_codepattern, string_to_stream, with_error_checking_parse};\n \n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, Token};\n+use rustc_ast::token::{self, Delimiter, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use rustc_ast::visit;\n use rustc_ast::{self as ast, PatKind};\n@@ -77,21 +77,23 @@ fn string_to_tts_macro() {\n                         TokenTree::Delimited(_, first_delim, first_tts),\n                         TokenTree::Token(Token { kind: token::FatArrow, .. }),\n                         TokenTree::Delimited(_, second_delim, second_tts),\n-                    ] if macro_delim == &token::Paren => {\n+                    ] if macro_delim == &Delimiter::Parenthesis => {\n                         let tts = &first_tts.trees().collect::<Vec<_>>();\n                         match &tts[..] {\n                             [\n                                 TokenTree::Token(Token { kind: token::Dollar, .. }),\n                                 TokenTree::Token(Token { kind: token::Ident(name, false), .. }),\n-                            ] if first_delim == &token::Paren && name.as_str() == \"a\" => {}\n+                            ] if first_delim == &Delimiter::Parenthesis && name.as_str() == \"a\" => {\n+                            }\n                             _ => panic!(\"value 3: {:?} {:?}\", first_delim, first_tts),\n                         }\n                         let tts = &second_tts.trees().collect::<Vec<_>>();\n                         match &tts[..] {\n                             [\n                                 TokenTree::Token(Token { kind: token::Dollar, .. }),\n                                 TokenTree::Token(Token { kind: token::Ident(name, false), .. }),\n-                            ] if second_delim == &token::Paren && name.as_str() == \"a\" => {}\n+                            ] if second_delim == &Delimiter::Parenthesis\n+                                && name.as_str() == \"a\" => {}\n                             _ => panic!(\"value 4: {:?} {:?}\", second_delim, second_tts),\n                         }\n                     }\n@@ -113,7 +115,7 @@ fn string_to_tts_1() {\n             TokenTree::token(token::Ident(Symbol::intern(\"a\"), false), sp(3, 4)).into(),\n             TokenTree::Delimited(\n                 DelimSpan::from_pair(sp(5, 6), sp(13, 14)),\n-                token::DelimToken::Paren,\n+                Delimiter::Parenthesis,\n                 TokenStream::new(vec![\n                     TokenTree::token(token::Ident(Symbol::intern(\"b\"), false), sp(6, 7)).into(),\n                     TokenTree::token(token::Colon, sp(8, 9)).into(),\n@@ -124,7 +126,7 @@ fn string_to_tts_1() {\n             .into(),\n             TokenTree::Delimited(\n                 DelimSpan::from_pair(sp(15, 16), sp(20, 21)),\n-                token::DelimToken::Brace,\n+                Delimiter::Brace,\n                 TokenStream::new(vec![\n                     TokenTree::token(token::Ident(Symbol::intern(\"b\"), false), sp(17, 18)).into(),\n                     TokenTree::token(token::Semi, sp(18, 19)).into(),"}, {"sha": "b7230cec3e4a99f74d7b0db409a93db61037f443", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -28,24 +28,24 @@ trait ToInternal<T> {\n     fn to_internal(self) -> T;\n }\n \n-impl FromInternal<token::DelimToken> for Delimiter {\n-    fn from_internal(delim: token::DelimToken) -> Delimiter {\n+impl FromInternal<token::Delimiter> for Delimiter {\n+    fn from_internal(delim: token::Delimiter) -> Delimiter {\n         match delim {\n-            token::Paren => Delimiter::Parenthesis,\n-            token::Brace => Delimiter::Brace,\n-            token::Bracket => Delimiter::Bracket,\n-            token::NoDelim => Delimiter::None,\n+            token::Delimiter::Parenthesis => Delimiter::Parenthesis,\n+            token::Delimiter::Brace => Delimiter::Brace,\n+            token::Delimiter::Bracket => Delimiter::Bracket,\n+            token::Delimiter::Invisible => Delimiter::None,\n         }\n     }\n }\n \n-impl ToInternal<token::DelimToken> for Delimiter {\n-    fn to_internal(self) -> token::DelimToken {\n+impl ToInternal<token::Delimiter> for Delimiter {\n+    fn to_internal(self) -> token::Delimiter {\n         match self {\n-            Delimiter::Parenthesis => token::Paren,\n-            Delimiter::Brace => token::Brace,\n-            Delimiter::Bracket => token::Bracket,\n-            Delimiter::None => token::NoDelim,\n+            Delimiter::Parenthesis => token::Delimiter::Parenthesis,\n+            Delimiter::Brace => token::Delimiter::Brace,\n+            Delimiter::Bracket => token::Delimiter::Bracket,\n+            Delimiter::None => token::Delimiter::Invisible,\n         }\n     }\n }\n@@ -61,7 +61,7 @@ impl FromInternal<(TreeAndSpacing, &'_ mut Vec<Self>, &mut Rustc<'_, '_>)>\n         let joint = spacing == Joint;\n         let Token { kind, span } = match tree {\n             tokenstream::TokenTree::Delimited(span, delim, tts) => {\n-                let delimiter = Delimiter::from_internal(delim);\n+                let delimiter = pm::Delimiter::from_internal(delim);\n                 return TokenTree::Group(Group { delimiter, stream: tts, span, flatten: false });\n             }\n             tokenstream::TokenTree::Token(token) => token,\n@@ -164,7 +164,7 @@ impl FromInternal<(TreeAndSpacing, &'_ mut Vec<Self>, &mut Rustc<'_, '_>)>\n                 .map(|kind| tokenstream::TokenTree::token(kind, span))\n                 .collect();\n                 stack.push(TokenTree::Group(Group {\n-                    delimiter: Delimiter::Bracket,\n+                    delimiter: pm::Delimiter::Bracket,\n                     stream,\n                     span: DelimSpan::from_single(span),\n                     flatten: false,\n@@ -181,7 +181,7 @@ impl FromInternal<(TreeAndSpacing, &'_ mut Vec<Self>, &mut Rustc<'_, '_>)>\n             Interpolated(nt) => {\n                 let stream = nt_to_tokenstream(&nt, rustc.sess(), CanSynthesizeMissingTokens::No);\n                 TokenTree::Group(Group {\n-                    delimiter: Delimiter::None,\n+                    delimiter: pm::Delimiter::None,\n                     stream,\n                     span: DelimSpan::from_single(span),\n                     flatten: crate::base::pretty_printing_compatibility_hack(&nt, rustc.sess()),"}, {"sha": "e585c61bf2ee17e351aa5c22c9b16bc7b2ee7af2", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,6 +1,6 @@\n use crate::lexer::unicode_chars::UNICODE_ARRAY;\n use rustc_ast::ast::{self, AttrStyle};\n-use rustc_ast::token::{self, CommentKind, Token, TokenKind};\n+use rustc_ast::token::{self, CommentKind, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::{Spacing, TokenStream};\n use rustc_ast::util::unicode::contains_text_flow_control_chars;\n use rustc_errors::{error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n@@ -24,8 +24,8 @@ use unescape_error_reporting::{emit_unescape_error, escaped_char};\n \n #[derive(Clone, Debug)]\n pub struct UnmatchedBrace {\n-    pub expected_delim: token::DelimToken,\n-    pub found_delim: Option<token::DelimToken>,\n+    pub expected_delim: Delimiter,\n+    pub found_delim: Option<Delimiter>,\n     pub found_span: Span,\n     pub unclosed_span: Option<Span>,\n     pub candidate_span: Option<Span>,\n@@ -284,12 +284,12 @@ impl<'a> StringReader<'a> {\n             rustc_lexer::TokenKind::Semi => token::Semi,\n             rustc_lexer::TokenKind::Comma => token::Comma,\n             rustc_lexer::TokenKind::Dot => token::Dot,\n-            rustc_lexer::TokenKind::OpenParen => token::OpenDelim(token::Paren),\n-            rustc_lexer::TokenKind::CloseParen => token::CloseDelim(token::Paren),\n-            rustc_lexer::TokenKind::OpenBrace => token::OpenDelim(token::Brace),\n-            rustc_lexer::TokenKind::CloseBrace => token::CloseDelim(token::Brace),\n-            rustc_lexer::TokenKind::OpenBracket => token::OpenDelim(token::Bracket),\n-            rustc_lexer::TokenKind::CloseBracket => token::CloseDelim(token::Bracket),\n+            rustc_lexer::TokenKind::OpenParen => token::OpenDelim(Delimiter::Parenthesis),\n+            rustc_lexer::TokenKind::CloseParen => token::CloseDelim(Delimiter::Parenthesis),\n+            rustc_lexer::TokenKind::OpenBrace => token::OpenDelim(Delimiter::Brace),\n+            rustc_lexer::TokenKind::CloseBrace => token::CloseDelim(Delimiter::Brace),\n+            rustc_lexer::TokenKind::OpenBracket => token::OpenDelim(Delimiter::Bracket),\n+            rustc_lexer::TokenKind::CloseBracket => token::CloseDelim(Delimiter::Bracket),\n             rustc_lexer::TokenKind::At => token::At,\n             rustc_lexer::TokenKind::Pound => token::Pound,\n             rustc_lexer::TokenKind::Tilde => token::Tilde,"}, {"sha": "ef84f95ec838010de72bb0b6c34067f62285eae7", "filename": "compiler/rustc_parse/src/lexer/tokentrees.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,6 +1,6 @@\n use super::{StringReader, UnmatchedBrace};\n \n-use rustc_ast::token::{self, DelimToken, Token};\n+use rustc_ast::token::{self, Delimiter, Token};\n use rustc_ast::tokenstream::{\n     DelimSpan,\n     Spacing::{self, *},\n@@ -32,15 +32,15 @@ struct TokenTreesReader<'a> {\n     string_reader: StringReader<'a>,\n     token: Token,\n     /// Stack of open delimiters and their spans. Used for error message.\n-    open_braces: Vec<(token::DelimToken, Span)>,\n+    open_braces: Vec<(Delimiter, Span)>,\n     unmatched_braces: Vec<UnmatchedBrace>,\n     /// The type and spans for all braces\n     ///\n     /// Used only for error recovery when arriving to EOF with mismatched braces.\n-    matching_delim_spans: Vec<(token::DelimToken, Span, Span)>,\n+    matching_delim_spans: Vec<(Delimiter, Span, Span)>,\n     last_unclosed_found_span: Option<Span>,\n     /// Collect empty block spans that might have been auto-inserted by editors.\n-    last_delim_empty_block_spans: FxHashMap<token::DelimToken, Span>,\n+    last_delim_empty_block_spans: FxHashMap<Delimiter, Span>,\n     /// Collect the spans of braces (Open, Close). Used only\n     /// for detecting if blocks are empty and only braces.\n     matching_block_spans: Vec<(Span, Span)>,\n@@ -88,7 +88,7 @@ impl<'a> TokenTreesReader<'a> {\n                 for &(_, sp) in &self.open_braces {\n                     err.span_label(sp, \"unclosed delimiter\");\n                     self.unmatched_braces.push(UnmatchedBrace {\n-                        expected_delim: token::DelimToken::Brace,\n+                        expected_delim: Delimiter::Brace,\n                         found_delim: None,\n                         found_span: self.token.span,\n                         unclosed_span: Some(sp),\n@@ -150,7 +150,7 @@ impl<'a> TokenTreesReader<'a> {\n                         }\n \n                         //only add braces\n-                        if let (DelimToken::Brace, DelimToken::Brace) = (open_brace, delim) {\n+                        if let (Delimiter::Brace, Delimiter::Brace) = (open_brace, delim) {\n                             self.matching_block_spans.push((open_brace_span, close_brace_span));\n                         }\n "}, {"sha": "faa686c3e57a335f5211575bcb5d1d42f129be50", "filename": "compiler/rustc_parse/src/lexer/unicode_chars.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -2,7 +2,7 @@\n // https://www.unicode.org/Public/security/10.0.0/confusables.txt\n \n use super::StringReader;\n-use crate::token;\n+use crate::token::{self, Delimiter};\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_span::{symbol::kw, BytePos, Pos, Span};\n \n@@ -312,12 +312,12 @@ const ASCII_ARRAY: &[(char, &str, Option<token::TokenKind>)] = &[\n     ('!', \"Exclamation Mark\", Some(token::Not)),\n     ('?', \"Question Mark\", Some(token::Question)),\n     ('.', \"Period\", Some(token::Dot)),\n-    ('(', \"Left Parenthesis\", Some(token::OpenDelim(token::Paren))),\n-    (')', \"Right Parenthesis\", Some(token::CloseDelim(token::Paren))),\n-    ('[', \"Left Square Bracket\", Some(token::OpenDelim(token::Bracket))),\n-    (']', \"Right Square Bracket\", Some(token::CloseDelim(token::Bracket))),\n-    ('{', \"Left Curly Brace\", Some(token::OpenDelim(token::Brace))),\n-    ('}', \"Right Curly Brace\", Some(token::CloseDelim(token::Brace))),\n+    ('(', \"Left Parenthesis\", Some(token::OpenDelim(Delimiter::Parenthesis))),\n+    (')', \"Right Parenthesis\", Some(token::CloseDelim(Delimiter::Parenthesis))),\n+    ('[', \"Left Square Bracket\", Some(token::OpenDelim(Delimiter::Bracket))),\n+    (']', \"Right Square Bracket\", Some(token::CloseDelim(Delimiter::Bracket))),\n+    ('{', \"Left Curly Brace\", Some(token::OpenDelim(Delimiter::Brace))),\n+    ('}', \"Right Curly Brace\", Some(token::CloseDelim(Delimiter::Brace))),\n     ('*', \"Asterisk\", Some(token::BinOp(token::Star))),\n     ('/', \"Slash\", Some(token::BinOp(token::Slash))),\n     ('\\\\', \"Backslash\", None),"}, {"sha": "358b01df3b983523d00191c26fe7469ec4970881", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,7 +1,7 @@\n use super::{AttrWrapper, Capturing, FnParseMode, ForceCollect, Parser, PathStyle};\n use rustc_ast as ast;\n use rustc_ast::attr;\n-use rustc_ast::token::{self, Nonterminal};\n+use rustc_ast::token::{self, Delimiter, Nonterminal};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{error_code, Diagnostic, PResult};\n use rustc_span::{sym, BytePos, Span};\n@@ -130,9 +130,9 @@ impl<'a> Parser<'a> {\n                     ast::AttrStyle::Outer\n                 };\n \n-                this.expect(&token::OpenDelim(token::Bracket))?;\n+                this.expect(&token::OpenDelim(Delimiter::Bracket))?;\n                 let item = this.parse_attr_item(false)?;\n-                this.expect(&token::CloseDelim(token::Bracket))?;\n+                this.expect(&token::CloseDelim(Delimiter::Bracket))?;\n                 let attr_sp = lo.to(this.prev_token.span);\n \n                 // Emit error if inner attribute is encountered and forbidden.\n@@ -403,7 +403,7 @@ impl<'a> Parser<'a> {\n     crate fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n         Ok(if self.eat(&token::Eq) {\n             ast::MetaItemKind::NameValue(self.parse_unsuffixed_lit()?)\n-        } else if self.check(&token::OpenDelim(token::Paren)) {\n+        } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             // Matches `meta_seq = ( COMMASEP(meta_item_inner) )`.\n             let (list, _) = self.parse_paren_comma_seq(|p| p.parse_meta_item_inner())?;\n             ast::MetaItemKind::List(list)"}, {"sha": "a12621564ab703e182a22d905127bf1d75b68860", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,5 +1,5 @@\n use super::{Capturing, FlatToken, ForceCollect, Parser, ReplaceRange, TokenCursor, TrailingToken};\n-use rustc_ast::token::{self, DelimToken, Token, TokenKind};\n+use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::{AttrAnnotatedTokenStream, AttributesData, CreateTokenStream};\n use rustc_ast::tokenstream::{AttrAnnotatedTokenTree, DelimSpan, LazyTokenStream, Spacing};\n use rustc_ast::{self as ast};\n@@ -388,11 +388,11 @@ impl<'a> Parser<'a> {\n /// Converts a flattened iterator of tokens (including open and close delimiter tokens)\n /// into a `TokenStream`, creating a `TokenTree::Delimited` for each matching pair\n /// of open and close delims.\n-// FIXME(#67062): Currently, we don't parse `None`-delimited groups correctly,\n-// which can cause us to end up with mismatched `None` delimiters in our\n+// FIXME(#67062): Currently, we don't parse `Invisible`-delimited groups correctly,\n+// which can cause us to end up with mismatched `Invisible` delimiters in our\n // captured tokens. This function contains several hacks to work around this -\n-// essentially, we throw away mismatched `None` delimiters when we encounter them.\n-// Once we properly parse `None` delimiters, they can be captured just like any\n+// essentially, we throw away mismatched `Invisible` delimiters when we encounter them.\n+// Once we properly parse `Invisible` delimiters, they can be captured just like any\n // other tokens, and these hacks can be removed.\n fn make_token_stream(\n     mut iter: impl Iterator<Item = (FlatToken, Spacing)>,\n@@ -401,7 +401,7 @@ fn make_token_stream(\n     #[derive(Debug)]\n     struct FrameData {\n         // This is `None` for the first frame, `Some` for all others.\n-        open_delim_sp: Option<(DelimToken, Span)>,\n+        open_delim_sp: Option<(Delimiter, Span)>,\n         inner: Vec<(AttrAnnotatedTokenTree, Spacing)>,\n     }\n     let mut stack = vec![FrameData { open_delim_sp: None, inner: vec![] }];\n@@ -412,13 +412,13 @@ fn make_token_stream(\n                 stack.push(FrameData { open_delim_sp: Some((delim, span)), inner: vec![] });\n             }\n             FlatToken::Token(Token { kind: TokenKind::CloseDelim(delim), span }) => {\n-                // HACK: If we encounter a mismatched `None` delimiter at the top\n+                // HACK: If we encounter a mismatched `Invisible` delimiter at the top\n                 // level, just ignore it.\n-                if matches!(delim, DelimToken::NoDelim)\n+                if matches!(delim, Delimiter::Invisible)\n                     && (stack.len() == 1\n                         || !matches!(\n                             stack.last_mut().unwrap().open_delim_sp.unwrap().0,\n-                            DelimToken::NoDelim\n+                            Delimiter::Invisible\n                         ))\n                 {\n                     token_and_spacing = iter.next();\n@@ -428,11 +428,11 @@ fn make_token_stream(\n                     .pop()\n                     .unwrap_or_else(|| panic!(\"Token stack was empty for token: {:?}\", token));\n \n-                // HACK: If our current frame has a mismatched opening `None` delimiter,\n+                // HACK: If our current frame has a mismatched opening `Invisible` delimiter,\n                 // merge our current frame with the one above it. That is, transform\n                 // `[ { < first second } third ]` into `[ { first second } third ]`\n-                if !matches!(delim, DelimToken::NoDelim)\n-                    && matches!(frame_data.open_delim_sp.unwrap().0, DelimToken::NoDelim)\n+                if !matches!(delim, Delimiter::Invisible)\n+                    && matches!(frame_data.open_delim_sp.unwrap().0, Delimiter::Invisible)\n                 {\n                     stack.last_mut().unwrap().inner.extend(frame_data.inner);\n                     // Process our closing delimiter again, this time at the previous\n@@ -472,10 +472,10 @@ fn make_token_stream(\n         }\n         token_and_spacing = iter.next();\n     }\n-    // HACK: If we don't have a closing `None` delimiter for our last\n+    // HACK: If we don't have a closing `Invisible` delimiter for our last\n     // frame, merge the frame with the top-level frame. That is,\n     // turn `< first second` into `first second`\n-    if stack.len() == 2 && stack[1].open_delim_sp.unwrap().0 == DelimToken::NoDelim {\n+    if stack.len() == 2 && stack[1].open_delim_sp.unwrap().0 == Delimiter::Invisible {\n         let temp_buf = stack.pop().unwrap();\n         stack.last_mut().unwrap().inner.extend(temp_buf.inner);\n     }"}, {"sha": "beffbdc5de4101c3bbd421f4e6433468df5e4f10", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -8,7 +8,7 @@ use super::{\n use crate::lexer::UnmatchedBrace;\n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, Lit, LitKind, TokenKind};\n+use rustc_ast::token::{self, Delimiter, Lit, LitKind, TokenKind};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{\n     AngleBracketedArg, AngleBracketedArgs, AnonConst, AttrVec, BinOpKind, BindingMode, Block,\n@@ -337,10 +337,10 @@ impl<'a> Parser<'a> {\n             TokenKind::Comma,\n             TokenKind::Semi,\n             TokenKind::ModSep,\n-            TokenKind::OpenDelim(token::DelimToken::Brace),\n-            TokenKind::OpenDelim(token::DelimToken::Paren),\n-            TokenKind::CloseDelim(token::DelimToken::Brace),\n-            TokenKind::CloseDelim(token::DelimToken::Paren),\n+            TokenKind::OpenDelim(Delimiter::Brace),\n+            TokenKind::OpenDelim(Delimiter::Parenthesis),\n+            TokenKind::CloseDelim(Delimiter::Brace),\n+            TokenKind::CloseDelim(Delimiter::Parenthesis),\n         ];\n         match self.token.ident() {\n             Some((ident, false))\n@@ -413,7 +413,7 @@ impl<'a> Parser<'a> {\n             } else if !sm.is_multiline(self.prev_token.span.until(self.token.span)) {\n                 // The current token is in the same line as the prior token, not recoverable.\n             } else if [token::Comma, token::Colon].contains(&self.token.kind)\n-                && self.prev_token.kind == token::CloseDelim(token::Paren)\n+                && self.prev_token.kind == token::CloseDelim(Delimiter::Parenthesis)\n             {\n                 // Likely typo: The current token is on a new line and is expected to be\n                 // `.`, `;`, `?`, or an operator after a close delimiter token.\n@@ -424,7 +424,7 @@ impl<'a> Parser<'a> {\n                 //         ^\n                 // https://github.com/rust-lang/rust/issues/72253\n             } else if self.look_ahead(1, |t| {\n-                t == &token::CloseDelim(token::Brace)\n+                t == &token::CloseDelim(Delimiter::Brace)\n                     || t.can_begin_expr() && t.kind != token::Colon\n             }) && [token::Comma, token::Colon].contains(&self.token.kind)\n             {\n@@ -441,7 +441,7 @@ impl<'a> Parser<'a> {\n                     .emit();\n                 return Ok(true);\n             } else if self.look_ahead(0, |t| {\n-                t == &token::CloseDelim(token::Brace)\n+                t == &token::CloseDelim(Delimiter::Brace)\n                     || (t.can_begin_expr() && t != &token::Semi && t != &token::Pound)\n                     // Avoid triggering with too many trailing `#` in raw string.\n                     || (sm.is_multiline(\n@@ -655,7 +655,7 @@ impl<'a> Parser<'a> {\n                 (Err(snapshot_err), Err(err)) => {\n                     // We don't know what went wrong, emit the normal error.\n                     snapshot_err.cancel();\n-                    self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n+                    self.consume_block(Delimiter::Brace, ConsumeClosingDelim::Yes);\n                     Err(err)\n                 }\n                 (Ok(_), Ok(mut tail)) => {\n@@ -866,7 +866,7 @@ impl<'a> Parser<'a> {\n                         trailing_span = trailing_span.to(self.token.span);\n                         self.bump();\n                     }\n-                    if self.token.kind == token::OpenDelim(token::Paren) {\n+                    if self.token.kind == token::OpenDelim(Delimiter::Parenthesis) {\n                         // Recover from bad turbofish: `foo.collect::Vec<_>()`.\n                         let args = AngleBracketedArgs { args, span }.into();\n                         segment.args = args;\n@@ -1098,7 +1098,7 @@ impl<'a> Parser<'a> {\n                             [(token::Lt, 1), (token::Gt, -1), (token::BinOp(token::Shr), -2)];\n                         self.consume_tts(1, &modifiers);\n \n-                        if !&[token::OpenDelim(token::Paren), token::ModSep]\n+                        if !&[token::OpenDelim(Delimiter::Parenthesis), token::ModSep]\n                             .contains(&self.token.kind)\n                         {\n                             // We don't have `foo< bar >(` or `foo< bar >::`, so we rewind the\n@@ -1132,7 +1132,7 @@ impl<'a> Parser<'a> {\n                                 Err(err)\n                             }\n                         }\n-                    } else if token::OpenDelim(token::Paren) == self.token.kind {\n+                    } else if token::OpenDelim(Delimiter::Parenthesis) == self.token.kind {\n                         // We have high certainty that this was a bad turbofish at this point.\n                         // `foo< bar >(`\n                         suggest(&mut err);\n@@ -1186,8 +1186,10 @@ impl<'a> Parser<'a> {\n         self.bump(); // `(`\n \n         // Consume the fn call arguments.\n-        let modifiers =\n-            [(token::OpenDelim(token::Paren), 1), (token::CloseDelim(token::Paren), -1)];\n+        let modifiers = [\n+            (token::OpenDelim(Delimiter::Parenthesis), 1),\n+            (token::CloseDelim(Delimiter::Parenthesis), -1),\n+        ];\n         self.consume_tts(1, &modifiers);\n \n         if self.token.kind == token::Eof {\n@@ -1579,15 +1581,15 @@ impl<'a> Parser<'a> {\n \n     fn recover_await_macro(&mut self) -> PResult<'a, (Span, P<Expr>, bool)> {\n         self.expect(&token::Not)?;\n-        self.expect(&token::OpenDelim(token::Paren))?;\n+        self.expect(&token::OpenDelim(Delimiter::Parenthesis))?;\n         let expr = self.parse_expr()?;\n-        self.expect(&token::CloseDelim(token::Paren))?;\n+        self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n         Ok((self.prev_token.span, expr, false))\n     }\n \n     fn recover_await_prefix(&mut self, await_sp: Span) -> PResult<'a, (Span, P<Expr>, bool)> {\n         let is_question = self.eat(&token::Question); // Handle `await? <expr>`.\n-        let expr = if self.token == token::OpenDelim(token::Brace) {\n+        let expr = if self.token == token::OpenDelim(Delimiter::Brace) {\n             // Handle `await { <expr> }`.\n             // This needs to be handled separately from the next arm to avoid\n             // interpreting `await { <expr> }?` as `<expr>?.await`.\n@@ -1619,8 +1621,8 @@ impl<'a> Parser<'a> {\n \n     /// If encountering `future.await()`, consumes and emits an error.\n     pub(super) fn recover_from_await_method_call(&mut self) {\n-        if self.token == token::OpenDelim(token::Paren)\n-            && self.look_ahead(1, |t| t == &token::CloseDelim(token::Paren))\n+        if self.token == token::OpenDelim(Delimiter::Parenthesis)\n+            && self.look_ahead(1, |t| t == &token::CloseDelim(Delimiter::Parenthesis))\n         {\n             // future.await()\n             let lo = self.token.span;\n@@ -1641,16 +1643,16 @@ impl<'a> Parser<'a> {\n     pub(super) fn try_macro_suggestion(&mut self) -> PResult<'a, P<Expr>> {\n         let is_try = self.token.is_keyword(kw::Try);\n         let is_questionmark = self.look_ahead(1, |t| t == &token::Not); //check for !\n-        let is_open = self.look_ahead(2, |t| t == &token::OpenDelim(token::Paren)); //check for (\n+        let is_open = self.look_ahead(2, |t| t == &token::OpenDelim(Delimiter::Parenthesis)); //check for (\n \n         if is_try && is_questionmark && is_open {\n             let lo = self.token.span;\n             self.bump(); //remove try\n             self.bump(); //remove !\n             let try_span = lo.to(self.token.span); //we take the try!( span\n             self.bump(); //remove (\n-            let is_empty = self.token == token::CloseDelim(token::Paren); //check if the block is empty\n-            self.consume_block(token::Paren, ConsumeClosingDelim::No); //eat the block\n+            let is_empty = self.token == token::CloseDelim(Delimiter::Parenthesis); //check if the block is empty\n+            self.consume_block(Delimiter::Parenthesis, ConsumeClosingDelim::No); //eat the block\n             let hi = self.token.span;\n             self.bump(); //remove )\n             let mut err = self.struct_span_err(lo.to(hi), \"use of deprecated `try` macro\");\n@@ -1681,7 +1683,7 @@ impl<'a> Parser<'a> {\n         begin_paren: Option<Span>,\n     ) -> P<Pat> {\n         match (&self.token.kind, begin_paren) {\n-            (token::CloseDelim(token::Paren), Some(begin_par_sp)) => {\n+            (token::CloseDelim(Delimiter::Parenthesis), Some(begin_par_sp)) => {\n                 self.bump();\n \n                 self.struct_span_err(\n@@ -1714,8 +1716,8 @@ impl<'a> Parser<'a> {\n             || self.token.is_ident() &&\n             matches!(node, ast::ExprKind::Path(..) | ast::ExprKind::Field(..)) &&\n             !self.token.is_reserved_ident() &&           // v `foo:bar(baz)`\n-            self.look_ahead(1, |t| t == &token::OpenDelim(token::Paren))\n-            || self.look_ahead(1, |t| t == &token::OpenDelim(token::Brace)) // `foo:bar {`\n+            self.look_ahead(1, |t| t == &token::OpenDelim(Delimiter::Parenthesis))\n+            || self.look_ahead(1, |t| t == &token::OpenDelim(Delimiter::Brace)) // `foo:bar {`\n             || self.look_ahead(1, |t| t == &token::Colon) &&     // `foo:bar::<baz`\n             self.look_ahead(2, |t| t == &token::Lt) &&\n             self.look_ahead(3, |t| t.is_ident())\n@@ -1728,7 +1730,7 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn recover_seq_parse_error(\n         &mut self,\n-        delim: token::DelimToken,\n+        delim: Delimiter,\n         lo: Span,\n         result: PResult<'a, P<Expr>>,\n     ) -> P<Expr> {\n@@ -1845,19 +1847,19 @@ impl<'a> Parser<'a> {\n         loop {\n             debug!(\"recover_stmt_ loop {:?}\", self.token);\n             match self.token.kind {\n-                token::OpenDelim(token::DelimToken::Brace) => {\n+                token::OpenDelim(Delimiter::Brace) => {\n                     brace_depth += 1;\n                     self.bump();\n                     if break_on_block == BlockMode::Break && brace_depth == 1 && bracket_depth == 0\n                     {\n                         in_block = true;\n                     }\n                 }\n-                token::OpenDelim(token::DelimToken::Bracket) => {\n+                token::OpenDelim(Delimiter::Bracket) => {\n                     bracket_depth += 1;\n                     self.bump();\n                 }\n-                token::CloseDelim(token::DelimToken::Brace) => {\n+                token::CloseDelim(Delimiter::Brace) => {\n                     if brace_depth == 0 {\n                         debug!(\"recover_stmt_ return - close delim {:?}\", self.token);\n                         break;\n@@ -1869,7 +1871,7 @@ impl<'a> Parser<'a> {\n                         break;\n                     }\n                 }\n-                token::CloseDelim(token::DelimToken::Bracket) => {\n+                token::CloseDelim(Delimiter::Bracket) => {\n                     bracket_depth -= 1;\n                     if bracket_depth < 0 {\n                         bracket_depth = 0;\n@@ -1927,11 +1929,11 @@ impl<'a> Parser<'a> {\n             .emit();\n             self.bump();\n         } else if self.token == token::Pound\n-            && self.look_ahead(1, |t| *t == token::OpenDelim(token::Bracket))\n+            && self.look_ahead(1, |t| *t == token::OpenDelim(Delimiter::Bracket))\n         {\n             let lo = self.token.span;\n             // Skip every token until next possible arg.\n-            while self.token != token::CloseDelim(token::Bracket) {\n+            while self.token != token::CloseDelim(Delimiter::Bracket) {\n                 self.bump();\n             }\n             let sp = lo.to(self.token.span);\n@@ -1952,7 +1954,9 @@ impl<'a> Parser<'a> {\n         // If we find a pattern followed by an identifier, it could be an (incorrect)\n         // C-style parameter declaration.\n         if self.check_ident()\n-            && self.look_ahead(1, |t| *t == token::Comma || *t == token::CloseDelim(token::Paren))\n+            && self.look_ahead(1, |t| {\n+                *t == token::Comma || *t == token::CloseDelim(Delimiter::Parenthesis)\n+            })\n         {\n             // `fn foo(String s) {}`\n             let ident = self.parse_ident().unwrap();\n@@ -1968,7 +1972,7 @@ impl<'a> Parser<'a> {\n         } else if require_name\n             && (self.token == token::Comma\n                 || self.token == token::Lt\n-                || self.token == token::CloseDelim(token::Paren))\n+                || self.token == token::CloseDelim(Delimiter::Parenthesis))\n         {\n             let rfc_note = \"anonymous parameters are removed in the 2018 edition (see RFC 1685)\";\n \n@@ -2086,11 +2090,7 @@ impl<'a> Parser<'a> {\n         Ok(param)\n     }\n \n-    pub(super) fn consume_block(\n-        &mut self,\n-        delim: token::DelimToken,\n-        consume_close: ConsumeClosingDelim,\n-    ) {\n+    pub(super) fn consume_block(&mut self, delim: Delimiter, consume_close: ConsumeClosingDelim) {\n         let mut brace_depth = 0;\n         loop {\n             if self.eat(&token::OpenDelim(delim)) {\n@@ -2109,7 +2109,8 @@ impl<'a> Parser<'a> {\n                     brace_depth -= 1;\n                     continue;\n                 }\n-            } else if self.token == token::Eof || self.eat(&token::CloseDelim(token::NoDelim)) {\n+            } else if self.token == token::Eof || self.eat(&token::CloseDelim(Delimiter::Invisible))\n+            {\n                 return;\n             } else {\n                 self.bump();\n@@ -2555,7 +2556,7 @@ impl<'a> Parser<'a> {\n \n     crate fn maybe_recover_unexpected_block_label(&mut self) -> bool {\n         let Some(label) = self.eat_label().filter(|_| {\n-            self.eat(&token::Colon) && self.token.kind == token::OpenDelim(token::Brace)\n+            self.eat(&token::Colon) && self.token.kind == token::OpenDelim(Delimiter::Brace)\n         }) else {\n             return false;\n         };\n@@ -2652,7 +2653,7 @@ impl<'a> Parser<'a> {\n     /// Parse and throw away a parenthesized comma separated\n     /// sequence of patterns until `)` is reached.\n     fn skip_pat_list(&mut self) -> PResult<'a, ()> {\n-        while !self.check(&token::CloseDelim(token::Paren)) {\n+        while !self.check(&token::CloseDelim(Delimiter::Parenthesis)) {\n             self.parse_pat_no_top_alt(None)?;\n             if !self.eat(&token::Comma) {\n                 return Ok(());"}, {"sha": "bdbc25af7fa1e363325e179806c812afbbbdfa2f", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 46, "deletions": 44, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -7,9 +7,8 @@ use super::{\n };\n use crate::maybe_recover_from_interpolated_ty_qpath;\n \n-use ast::token::DelimToken;\n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, Token, TokenKind};\n+use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::Spacing;\n use rustc_ast::util::classify;\n use rustc_ast::util::literal::LitError;\n@@ -495,7 +494,7 @@ impl<'a> Parser<'a> {\n     fn is_at_start_of_range_notation_rhs(&self) -> bool {\n         if self.token.can_begin_expr() {\n             // Parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`.\n-            if self.token == token::OpenDelim(token::Brace) {\n+            if self.token == token::OpenDelim(Delimiter::Brace) {\n                 return !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n             }\n             true\n@@ -992,8 +991,8 @@ impl<'a> Parser<'a> {\n                 return Ok(e);\n             }\n             e = match self.token.kind {\n-                token::OpenDelim(token::Paren) => self.parse_fn_call_expr(lo, e),\n-                token::OpenDelim(token::Bracket) => self.parse_index_expr(lo, e)?,\n+                token::OpenDelim(Delimiter::Parenthesis) => self.parse_fn_call_expr(lo, e),\n+                token::OpenDelim(Delimiter::Bracket) => self.parse_index_expr(lo, e)?,\n                 _ => return Ok(e),\n             }\n         }\n@@ -1156,7 +1155,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a function call expression, `expr(...)`.\n     fn parse_fn_call_expr(&mut self, lo: Span, fun: P<Expr>) -> P<Expr> {\n-        let snapshot = if self.token.kind == token::OpenDelim(token::Paren)\n+        let snapshot = if self.token.kind == token::OpenDelim(Delimiter::Parenthesis)\n             && self.look_ahead_type_ascription_as_field()\n         {\n             Some((self.create_snapshot_for_diagnostic(), fun.kind.clone()))\n@@ -1173,7 +1172,7 @@ impl<'a> Parser<'a> {\n         {\n             return expr;\n         }\n-        self.recover_seq_parse_error(token::Paren, lo, seq)\n+        self.recover_seq_parse_error(Delimiter::Parenthesis, lo, seq)\n     }\n \n     /// If we encounter a parser state that looks like the user has written a `struct` literal with\n@@ -1190,8 +1189,10 @@ impl<'a> Parser<'a> {\n             (Err(err), Some((mut snapshot, ExprKind::Path(None, path)))) => {\n                 let name = pprust::path_to_string(&path);\n                 snapshot.bump(); // `(`\n-                match snapshot.parse_struct_fields(path, false, token::Paren) {\n-                    Ok((fields, ..)) if snapshot.eat(&token::CloseDelim(token::Paren)) => {\n+                match snapshot.parse_struct_fields(path, false, Delimiter::Parenthesis) {\n+                    Ok((fields, ..))\n+                        if snapshot.eat(&token::CloseDelim(Delimiter::Parenthesis)) =>\n+                    {\n                         // We are certain we have `Enum::Foo(a: 3, b: 4)`, suggest\n                         // `Enum::Foo { a: 3, b: 4 }` or `Enum::Foo(3, 4)`.\n                         self.restore_snapshot(snapshot);\n@@ -1241,7 +1242,7 @@ impl<'a> Parser<'a> {\n     fn parse_index_expr(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n         self.bump(); // `[`\n         let index = self.parse_expr()?;\n-        self.expect(&token::CloseDelim(token::Bracket))?;\n+        self.expect(&token::CloseDelim(Delimiter::Bracket))?;\n         Ok(self.mk_expr(lo.to(self.prev_token.span), self.mk_index(base, index), AttrVec::new()))\n     }\n \n@@ -1253,10 +1254,10 @@ impl<'a> Parser<'a> {\n \n         let fn_span_lo = self.token.span;\n         let mut segment = self.parse_path_segment(PathStyle::Expr, None)?;\n-        self.check_trailing_angle_brackets(&segment, &[&token::OpenDelim(token::Paren)]);\n+        self.check_trailing_angle_brackets(&segment, &[&token::OpenDelim(Delimiter::Parenthesis)]);\n         self.check_turbofish_missing_angle_brackets(&mut segment);\n \n-        if self.check(&token::OpenDelim(token::Paren)) {\n+        if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             // Method call `expr.f()`\n             let mut args = self.parse_paren_expr_seq()?;\n             args.insert(0, self_arg);\n@@ -1302,9 +1303,9 @@ impl<'a> Parser<'a> {\n             // could be removed without changing functionality, but it's faster\n             // to have it here, especially for programs with large constants.\n             self.parse_lit_expr(attrs)\n-        } else if self.check(&token::OpenDelim(token::Paren)) {\n+        } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             self.parse_tuple_parens_expr(attrs)\n-        } else if self.check(&token::OpenDelim(token::Brace)) {\n+        } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n             self.parse_block_expr(None, lo, BlockCheckMode::Default, attrs)\n         } else if self.check(&token::BinOp(token::Or)) || self.check(&token::OrOr) {\n             self.parse_closure_expr(attrs).map_err(|mut err| {\n@@ -1315,8 +1316,8 @@ impl<'a> Parser<'a> {\n                 }\n                 err\n             })\n-        } else if self.check(&token::OpenDelim(token::Bracket)) {\n-            self.parse_array_or_repeat_expr(attrs, token::Bracket)\n+        } else if self.check(&token::OpenDelim(Delimiter::Bracket)) {\n+            self.parse_array_or_repeat_expr(attrs, Delimiter::Bracket)\n         } else if self.check_path() {\n             self.parse_path_start_expr(attrs)\n         } else if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n@@ -1422,14 +1423,16 @@ impl<'a> Parser<'a> {\n \n     fn parse_tuple_parens_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n-        self.expect(&token::OpenDelim(token::Paren))?;\n+        self.expect(&token::OpenDelim(Delimiter::Parenthesis))?;\n         let (es, trailing_comma) = match self.parse_seq_to_end(\n-            &token::CloseDelim(token::Paren),\n+            &token::CloseDelim(Delimiter::Parenthesis),\n             SeqSep::trailing_allowed(token::Comma),\n             |p| p.parse_expr_catch_underscore(),\n         ) {\n             Ok(x) => x,\n-            Err(err) => return Ok(self.recover_seq_parse_error(token::Paren, lo, Err(err))),\n+            Err(err) => {\n+                return Ok(self.recover_seq_parse_error(Delimiter::Parenthesis, lo, Err(err)));\n+            }\n         };\n         let kind = if es.len() == 1 && !trailing_comma {\n             // `(e)` is parenthesized `e`.\n@@ -1445,7 +1448,7 @@ impl<'a> Parser<'a> {\n     fn parse_array_or_repeat_expr(\n         &mut self,\n         attrs: AttrVec,\n-        close_delim: token::DelimToken,\n+        close_delim: Delimiter,\n     ) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         self.bump(); // `[` or other open delim\n@@ -1500,7 +1503,7 @@ impl<'a> Parser<'a> {\n                 prior_type_ascription: self.last_type_ascription,\n             };\n             (self.prev_token.span, ExprKind::MacCall(mac))\n-        } else if self.check(&token::OpenDelim(token::Brace)) {\n+        } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n             if let Some(expr) = self.maybe_parse_struct_expr(qself.as_ref(), &path, &attrs) {\n                 if qself.is_some() {\n                     self.sess.gated_spans.gate(sym::more_qualified_paths, path.span);\n@@ -1533,7 +1536,7 @@ impl<'a> Parser<'a> {\n             self.parse_for_expr(label, lo, attrs)\n         } else if self.eat_keyword(kw::Loop) {\n             self.parse_loop_expr(label, lo, attrs)\n-        } else if self.check(&token::OpenDelim(token::Brace)) || self.token.is_whole_block() {\n+        } else if self.check(&token::OpenDelim(Delimiter::Brace)) || self.token.is_whole_block() {\n             self.parse_block_expr(label, lo, BlockCheckMode::Default, attrs)\n         } else if !ate_colon && (self.check(&TokenKind::Comma) || self.check(&TokenKind::Gt)) {\n             // We're probably inside of a `Path<'a>` that needs a turbofish\n@@ -1631,7 +1634,7 @@ impl<'a> Parser<'a> {\n             )\n             .emit();\n             Some(lexpr)\n-        } else if self.token != token::OpenDelim(token::Brace)\n+        } else if self.token != token::OpenDelim(Delimiter::Brace)\n             || !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n         {\n             let expr = self.parse_expr_opt()?;\n@@ -1940,7 +1943,7 @@ impl<'a> Parser<'a> {\n         attrs: AttrVec,\n     ) -> Option<P<Expr>> {\n         let mut snapshot = self.create_snapshot_for_diagnostic();\n-        match snapshot.parse_array_or_repeat_expr(attrs, token::Brace) {\n+        match snapshot.parse_array_or_repeat_expr(attrs, Delimiter::Brace) {\n             Ok(arr) => {\n                 let hi = snapshot.prev_token.span;\n                 self.struct_span_err(arr.span, \"this is a block expression, not an array\")\n@@ -2044,7 +2047,7 @@ impl<'a> Parser<'a> {\n         }\n \n         if self.token.kind == TokenKind::Semi\n-            && matches!(self.token_cursor.frame.delim_sp, Some((DelimToken::Paren, _)))\n+            && matches!(self.token_cursor.frame.delim_sp, Some((Delimiter::Parenthesis, _)))\n         {\n             // It is likely that the closure body is a block but where the\n             // braces have been removed. We will recover and eat the next\n@@ -2158,7 +2161,7 @@ impl<'a> Parser<'a> {\n             }\n         } else {\n             let attrs = self.parse_outer_attributes()?.take_for_recovery(); // For recovery.\n-            let not_block = self.token != token::OpenDelim(token::Brace);\n+            let not_block = self.token != token::OpenDelim(Delimiter::Brace);\n             let block = self.parse_block().map_err(|err| {\n                 if not_block {\n                     self.error_missing_if_then_block(lo, Some(err), missing_then_block_binop_span())\n@@ -2283,7 +2286,7 @@ impl<'a> Parser<'a> {\n         // This is used below for recovery in case of `for ( $stuff ) $block`\n         // in which case we will suggest `for $stuff $block`.\n         let begin_paren = match self.token.kind {\n-            token::OpenDelim(token::Paren) => Some(self.token.span),\n+            token::OpenDelim(Delimiter::Parenthesis) => Some(self.token.span),\n             _ => None,\n         };\n \n@@ -2372,7 +2375,7 @@ impl<'a> Parser<'a> {\n         let match_span = self.prev_token.span;\n         let lo = self.prev_token.span;\n         let scrutinee = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n-        if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n+        if let Err(mut e) = self.expect(&token::OpenDelim(Delimiter::Brace)) {\n             if self.token == token::Semi {\n                 e.span_suggestion_short(\n                     match_span,\n@@ -2391,15 +2394,15 @@ impl<'a> Parser<'a> {\n         attrs.extend(self.parse_inner_attributes()?);\n \n         let mut arms: Vec<Arm> = Vec::new();\n-        while self.token != token::CloseDelim(token::Brace) {\n+        while self.token != token::CloseDelim(Delimiter::Brace) {\n             match self.parse_arm() {\n                 Ok(arm) => arms.push(arm),\n                 Err(mut e) => {\n                     // Recover by skipping to the end of the block.\n                     e.emit();\n                     self.recover_stmt();\n                     let span = lo.to(self.token.span);\n-                    if self.token == token::CloseDelim(token::Brace) {\n+                    if self.token == token::CloseDelim(Delimiter::Brace) {\n                         self.bump();\n                     }\n                     return Ok(self.mk_expr(span, ExprKind::Match(scrutinee, arms), attrs));\n@@ -2463,7 +2466,7 @@ impl<'a> Parser<'a> {\n         // We might have either a `,` -> `;` typo, or a block without braces. We need\n         // a more subtle parsing strategy.\n         loop {\n-            if self.token.kind == token::CloseDelim(token::Brace) {\n+            if self.token.kind == token::CloseDelim(Delimiter::Brace) {\n                 // We have reached the closing brace of the `match` expression.\n                 return Some(err(self, stmts));\n             }\n@@ -2571,7 +2574,7 @@ impl<'a> Parser<'a> {\n             })?;\n \n             let require_comma = classify::expr_requires_semi_to_be_stmt(&expr)\n-                && this.token != token::CloseDelim(token::Brace);\n+                && this.token != token::CloseDelim(Delimiter::Brace);\n \n             let hi = this.prev_token.span;\n \n@@ -2592,8 +2595,8 @@ impl<'a> Parser<'a> {\n                         TrailingToken::None,\n                     ));\n                 }\n-                this.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Brace)]).map_err(\n-                    |mut err| {\n+                this.expect_one_of(&[token::Comma], &[token::CloseDelim(Delimiter::Brace)])\n+                    .map_err(|mut err| {\n                         match (sm.span_to_lines(expr.span), sm.span_to_lines(arm_start_span)) {\n                             (Ok(ref expr_lines), Ok(ref arm_start_lines))\n                                 if arm_start_lines.lines[0].end_col\n@@ -2627,8 +2630,7 @@ impl<'a> Parser<'a> {\n                             }\n                         }\n                         err\n-                    },\n-                )?;\n+                    })?;\n             } else {\n                 this.eat(&token::Comma);\n             }\n@@ -2670,13 +2672,13 @@ impl<'a> Parser<'a> {\n     fn is_do_catch_block(&self) -> bool {\n         self.token.is_keyword(kw::Do)\n             && self.is_keyword_ahead(1, &[kw::Catch])\n-            && self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))\n+            && self.look_ahead(2, |t| *t == token::OpenDelim(Delimiter::Brace))\n             && !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n \n     fn is_try_block(&self) -> bool {\n         self.token.is_keyword(kw::Try)\n-            && self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace))\n+            && self.look_ahead(1, |t| *t == token::OpenDelim(Delimiter::Brace))\n             && self.token.uninterpolated_span().rust_2018()\n     }\n \n@@ -2696,10 +2698,10 @@ impl<'a> Parser<'a> {\n             && ((\n                 // `async move {`\n                 self.is_keyword_ahead(1, &[kw::Move])\n-                    && self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))\n+                    && self.look_ahead(2, |t| *t == token::OpenDelim(Delimiter::Brace))\n             ) || (\n                 // `async {`\n-                self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace))\n+                self.look_ahead(1, |t| *t == token::OpenDelim(Delimiter::Brace))\n             ))\n     }\n \n@@ -2726,7 +2728,7 @@ impl<'a> Parser<'a> {\n     ) -> Option<PResult<'a, P<Expr>>> {\n         let struct_allowed = !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n         if struct_allowed || self.is_certainly_not_a_block() {\n-            if let Err(err) = self.expect(&token::OpenDelim(token::Brace)) {\n+            if let Err(err) = self.expect(&token::OpenDelim(Delimiter::Brace)) {\n                 return Some(Err(err));\n             }\n             let expr = self.parse_struct_expr(qself.cloned(), path.clone(), attrs.clone(), true);\n@@ -2753,7 +2755,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         pth: ast::Path,\n         recover: bool,\n-        close_delim: token::DelimToken,\n+        close_delim: Delimiter,\n     ) -> PResult<'a, (Vec<ExprField>, ast::StructRest, bool)> {\n         let mut fields = Vec::new();\n         let mut base = ast::StructRest::None;\n@@ -2853,9 +2855,9 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, P<Expr>> {\n         let lo = pth.span;\n         let (fields, base, recover_async) =\n-            self.parse_struct_fields(pth.clone(), recover, token::Brace)?;\n+            self.parse_struct_fields(pth.clone(), recover, Delimiter::Brace)?;\n         let span = lo.to(self.token.span);\n-        self.expect(&token::CloseDelim(token::Brace))?;\n+        self.expect(&token::CloseDelim(Delimiter::Brace))?;\n         let expr = if recover_async {\n             ExprKind::Err\n         } else {"}, {"sha": "746861933d2f0493a5963e92d4c157880faedf6f", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -4,7 +4,7 @@ use super::{AttrWrapper, FollowedByType, ForceCollect, Parser, PathStyle, Traili\n \n use rustc_ast::ast::*;\n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, TokenKind};\n+use rustc_ast::token::{self, Delimiter, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use rustc_ast::{self as ast, AttrVec, Attribute, DUMMY_NODE_ID};\n use rustc_ast::{Async, Const, Defaultness, IsAuto, Mutability, Unsafe, UseTree, UseTreeKind};\n@@ -39,9 +39,9 @@ impl<'a> Parser<'a> {\n         let mod_kind = if self.eat(&token::Semi) {\n             ModKind::Unloaded\n         } else {\n-            self.expect(&token::OpenDelim(token::Brace))?;\n+            self.expect(&token::OpenDelim(Delimiter::Brace))?;\n             let (mut inner_attrs, items, inner_span) =\n-                self.parse_mod(&token::CloseDelim(token::Brace))?;\n+                self.parse_mod(&token::CloseDelim(Delimiter::Brace))?;\n             attrs.append(&mut inner_attrs);\n             ModKind::Loaded(items, Inline::Yes, inner_span)\n         };\n@@ -324,7 +324,7 @@ impl<'a> Parser<'a> {\n         let sp = self.prev_token.span.between(self.token.span);\n         let full_sp = self.prev_token.span.to(self.token.span);\n         let ident_sp = self.token.span;\n-        if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n+        if self.look_ahead(1, |t| *t == token::OpenDelim(Delimiter::Brace)) {\n             // possible public struct definition where `struct` was forgotten\n             let ident = self.parse_ident().unwrap();\n             let msg = format!(\"add `struct` here to parse `{ident}` as a public struct\");\n@@ -336,16 +336,16 @@ impl<'a> Parser<'a> {\n                 Applicability::MaybeIncorrect, // speculative\n             );\n             Err(err)\n-        } else if self.look_ahead(1, |t| *t == token::OpenDelim(token::Paren)) {\n+        } else if self.look_ahead(1, |t| *t == token::OpenDelim(Delimiter::Parenthesis)) {\n             let ident = self.parse_ident().unwrap();\n             self.bump(); // `(`\n             let kw_name = self.recover_first_param();\n-            self.consume_block(token::Paren, ConsumeClosingDelim::Yes);\n+            self.consume_block(Delimiter::Parenthesis, ConsumeClosingDelim::Yes);\n             let (kw, kw_name, ambiguous) = if self.check(&token::RArrow) {\n-                self.eat_to_tokens(&[&token::OpenDelim(token::Brace)]);\n+                self.eat_to_tokens(&[&token::OpenDelim(Delimiter::Brace)]);\n                 self.bump(); // `{`\n                 (\"fn\", kw_name, false)\n-            } else if self.check(&token::OpenDelim(token::Brace)) {\n+            } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n                 self.bump(); // `{`\n                 (\"fn\", kw_name, false)\n             } else if self.check(&token::Colon) {\n@@ -358,7 +358,7 @@ impl<'a> Parser<'a> {\n             let msg = format!(\"missing `{kw}` for {kw_name} definition\");\n             let mut err = self.struct_span_err(sp, &msg);\n             if !ambiguous {\n-                self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n+                self.consume_block(Delimiter::Brace, ConsumeClosingDelim::Yes);\n                 let suggestion =\n                     format!(\"add `{kw}` here to parse `{ident}` as a public {kw_name}\");\n                 err.span_suggestion_short(\n@@ -386,9 +386,9 @@ impl<'a> Parser<'a> {\n             let ident = self.parse_ident().unwrap();\n             self.eat_to_tokens(&[&token::Gt]);\n             self.bump(); // `>`\n-            let (kw, kw_name, ambiguous) = if self.eat(&token::OpenDelim(token::Paren)) {\n+            let (kw, kw_name, ambiguous) = if self.eat(&token::OpenDelim(Delimiter::Parenthesis)) {\n                 (\"fn\", self.recover_first_param(), false)\n-            } else if self.check(&token::OpenDelim(token::Brace)) {\n+            } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n                 (\"struct\", \"struct\", false)\n             } else {\n                 (\"fn` or `struct\", \"function or struct\", true)\n@@ -630,19 +630,19 @@ impl<'a> Parser<'a> {\n         mut parse_item: impl FnMut(&mut Parser<'a>) -> PResult<'a, Option<Option<T>>>,\n     ) -> PResult<'a, Vec<T>> {\n         let open_brace_span = self.token.span;\n-        self.expect(&token::OpenDelim(token::Brace))?;\n+        self.expect(&token::OpenDelim(Delimiter::Brace))?;\n         attrs.append(&mut self.parse_inner_attributes()?);\n \n         let mut items = Vec::new();\n-        while !self.eat(&token::CloseDelim(token::Brace)) {\n+        while !self.eat(&token::CloseDelim(Delimiter::Brace)) {\n             if self.recover_doc_comment_before_brace() {\n                 continue;\n             }\n             match parse_item(self) {\n                 Ok(None) => {\n                     // We have to bail or we'll potentially never make progress.\n                     let non_item_span = self.token.span;\n-                    self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n+                    self.consume_block(Delimiter::Brace, ConsumeClosingDelim::Yes);\n                     self.struct_span_err(non_item_span, \"non-item in item list\")\n                         .span_label(open_brace_span, \"item list starts here\")\n                         .span_label(non_item_span, \"non-item starts here\")\n@@ -652,7 +652,7 @@ impl<'a> Parser<'a> {\n                 }\n                 Ok(Some(item)) => items.extend(item),\n                 Err(mut err) => {\n-                    self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n+                    self.consume_block(Delimiter::Brace, ConsumeClosingDelim::Yes);\n                     err.span_label(open_brace_span, \"while parsing this item list starting here\")\n                         .span_label(self.prev_token.span, \"the item list ends here\")\n                         .emit();\n@@ -666,7 +666,7 @@ impl<'a> Parser<'a> {\n     /// Recover on a doc comment before `}`.\n     fn recover_doc_comment_before_brace(&mut self) -> bool {\n         if let token::DocComment(..) = self.token.kind {\n-            if self.look_ahead(1, |tok| tok == &token::CloseDelim(token::Brace)) {\n+            if self.look_ahead(1, |tok| tok == &token::CloseDelim(Delimiter::Brace)) {\n                 struct_span_err!(\n                     self.diagnostic(),\n                     self.token.span,\n@@ -866,7 +866,7 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n \n         let mut prefix = ast::Path { segments: Vec::new(), span: lo.shrink_to_lo(), tokens: None };\n-        let kind = if self.check(&token::OpenDelim(token::Brace))\n+        let kind = if self.check(&token::OpenDelim(Delimiter::Brace))\n             || self.check(&token::BinOp(token::Star))\n             || self.is_import_coupler()\n         {\n@@ -908,7 +908,7 @@ impl<'a> Parser<'a> {\n     /// USE_TREE_LIST = \u00d8 | (USE_TREE `,`)* USE_TREE [`,`]\n     /// ```\n     fn parse_use_tree_list(&mut self) -> PResult<'a, Vec<(UseTree, ast::NodeId)>> {\n-        self.parse_delim_comma_seq(token::Brace, |p| Ok((p.parse_use_tree()?, DUMMY_NODE_ID)))\n+        self.parse_delim_comma_seq(Delimiter::Brace, |p| Ok((p.parse_use_tree()?, DUMMY_NODE_ID)))\n             .map(|(r, _)| r)\n     }\n \n@@ -1077,7 +1077,7 @@ impl<'a> Parser<'a> {\n             && self.is_keyword_ahead(1, &[kw::Extern])\n             && self.look_ahead(\n                 2 + self.look_ahead(2, |t| t.can_begin_literal_maybe_minus() as usize),\n-                |t| t.kind == token::OpenDelim(token::Brace),\n+                |t| t.kind == token::OpenDelim(Delimiter::Brace),\n             )\n     }\n \n@@ -1204,8 +1204,9 @@ impl<'a> Parser<'a> {\n         let mut generics = self.parse_generics()?;\n         generics.where_clause = self.parse_where_clause()?;\n \n-        let (variants, _) =\n-            self.parse_delim_comma_seq(token::Brace, |p| p.parse_enum_variant()).map_err(|e| {\n+        let (variants, _) = self\n+            .parse_delim_comma_seq(Delimiter::Brace, |p| p.parse_enum_variant())\n+            .map_err(|e| {\n                 self.recover_stmt();\n                 e\n             })?;\n@@ -1228,11 +1229,11 @@ impl<'a> Parser<'a> {\n                 }\n                 let ident = this.parse_field_ident(\"enum\", vlo)?;\n \n-                let struct_def = if this.check(&token::OpenDelim(token::Brace)) {\n+                let struct_def = if this.check(&token::OpenDelim(Delimiter::Brace)) {\n                     // Parse a struct variant.\n                     let (fields, recovered) = this.parse_record_struct_body(\"struct\", false)?;\n                     VariantData::Struct(fields, recovered)\n-                } else if this.check(&token::OpenDelim(token::Paren)) {\n+                } else if this.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n                     VariantData::Tuple(this.parse_tuple_struct_body()?, DUMMY_NODE_ID)\n                 } else {\n                     VariantData::Unit(DUMMY_NODE_ID)\n@@ -1292,12 +1293,12 @@ impl<'a> Parser<'a> {\n         } else if self.eat(&token::Semi) {\n             VariantData::Unit(DUMMY_NODE_ID)\n         // Record-style struct definition\n-        } else if self.token == token::OpenDelim(token::Brace) {\n+        } else if self.token == token::OpenDelim(Delimiter::Brace) {\n             let (fields, recovered) =\n                 self.parse_record_struct_body(\"struct\", generics.where_clause.has_where_token)?;\n             VariantData::Struct(fields, recovered)\n         // Tuple-style struct definition with optional where-clause.\n-        } else if self.token == token::OpenDelim(token::Paren) {\n+        } else if self.token == token::OpenDelim(Delimiter::Parenthesis) {\n             let body = VariantData::Tuple(self.parse_tuple_struct_body()?, DUMMY_NODE_ID);\n             generics.where_clause = self.parse_where_clause()?;\n             self.expect_semi()?;\n@@ -1326,7 +1327,7 @@ impl<'a> Parser<'a> {\n             let (fields, recovered) =\n                 self.parse_record_struct_body(\"union\", generics.where_clause.has_where_token)?;\n             VariantData::Struct(fields, recovered)\n-        } else if self.token == token::OpenDelim(token::Brace) {\n+        } else if self.token == token::OpenDelim(Delimiter::Brace) {\n             let (fields, recovered) =\n                 self.parse_record_struct_body(\"union\", generics.where_clause.has_where_token)?;\n             VariantData::Struct(fields, recovered)\n@@ -1348,10 +1349,10 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, (Vec<FieldDef>, /* recovered */ bool)> {\n         let mut fields = Vec::new();\n         let mut recovered = false;\n-        if self.eat(&token::OpenDelim(token::Brace)) {\n-            while self.token != token::CloseDelim(token::Brace) {\n+        if self.eat(&token::OpenDelim(Delimiter::Brace)) {\n+            while self.token != token::CloseDelim(Delimiter::Brace) {\n                 let field = self.parse_field_def(adt_ty).map_err(|e| {\n-                    self.consume_block(token::Brace, ConsumeClosingDelim::No);\n+                    self.consume_block(Delimiter::Brace, ConsumeClosingDelim::No);\n                     recovered = true;\n                     e\n                 });\n@@ -1363,7 +1364,7 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n             }\n-            self.eat(&token::CloseDelim(token::Brace));\n+            self.eat(&token::CloseDelim(Delimiter::Brace));\n         } else {\n             let token_str = super::token_descr(&self.token);\n             let msg = &format!(\n@@ -1439,7 +1440,7 @@ impl<'a> Parser<'a> {\n             token::Comma => {\n                 self.bump();\n             }\n-            token::CloseDelim(token::Brace) => {}\n+            token::CloseDelim(Delimiter::Brace) => {}\n             token::DocComment(..) => {\n                 let previous_span = self.prev_token.span;\n                 let mut err = self.span_err(self.token.span, Error::UselessDocComment);\n@@ -1450,7 +1451,7 @@ impl<'a> Parser<'a> {\n                 if !seen_comma && comma_after_doc_seen {\n                     seen_comma = true;\n                 }\n-                if comma_after_doc_seen || self.token == token::CloseDelim(token::Brace) {\n+                if comma_after_doc_seen || self.token == token::CloseDelim(Delimiter::Brace) {\n                     err.emit();\n                 } else {\n                     if !seen_comma {\n@@ -1478,7 +1479,7 @@ impl<'a> Parser<'a> {\n                     if let Some(last_segment) = segments.last() {\n                         recovered = self.check_trailing_angle_brackets(\n                             last_segment,\n-                            &[&token::Comma, &token::CloseDelim(token::Brace)],\n+                            &[&token::Comma, &token::CloseDelim(Delimiter::Brace)],\n                         );\n                         if recovered {\n                             // Handle a case like `Vec<u8>>,` where we can continue parsing fields\n@@ -1636,12 +1637,12 @@ impl<'a> Parser<'a> {\n     /// ```\n     fn parse_item_decl_macro(&mut self, lo: Span) -> PResult<'a, ItemInfo> {\n         let ident = self.parse_ident()?;\n-        let body = if self.check(&token::OpenDelim(token::Brace)) {\n+        let body = if self.check(&token::OpenDelim(Delimiter::Brace)) {\n             self.parse_mac_args()? // `MacBody`\n-        } else if self.check(&token::OpenDelim(token::Paren)) {\n+        } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             let params = self.parse_token_tree(); // `MacParams`\n             let pspan = params.span();\n-            if !self.check(&token::OpenDelim(token::Brace)) {\n+            if !self.check(&token::OpenDelim(Delimiter::Brace)) {\n                 return self.unexpected();\n             }\n             let body = self.parse_token_tree(); // `MacBody`\n@@ -1924,7 +1925,7 @@ impl<'a> Parser<'a> {\n             self.expect_semi()?;\n             *sig_hi = self.prev_token.span;\n             (Vec::new(), None)\n-        } else if self.check(&token::OpenDelim(token::Brace)) || self.token.is_whole_block() {\n+        } else if self.check(&token::OpenDelim(Delimiter::Brace)) || self.token.is_whole_block() {\n             self.parse_inner_attrs_and_block().map(|(attrs, body)| (attrs, Some(body)))?\n         } else if self.token.kind == token::Eq {\n             // Recover `fn foo() = $expr;`.\n@@ -1943,12 +1944,12 @@ impl<'a> Parser<'a> {\n             (Vec::new(), Some(self.mk_block_err(span)))\n         } else {\n             let expected = if req_body {\n-                &[token::OpenDelim(token::Brace)][..]\n+                &[token::OpenDelim(Delimiter::Brace)][..]\n             } else {\n-                &[token::Semi, token::OpenDelim(token::Brace)]\n+                &[token::Semi, token::OpenDelim(Delimiter::Brace)]\n             };\n             if let Err(mut err) = self.expected_one_of_not_found(&[], &expected) {\n-                if self.token.kind == token::CloseDelim(token::Brace) {\n+                if self.token.kind == token::CloseDelim(Delimiter::Brace) {\n                     // The enclosing `mod`, `trait` or `impl` is being closed, so keep the `fn` in\n                     // the AST for typechecking.\n                     err.span_label(ident.span, \"while parsing this `fn`\");\n@@ -2164,7 +2165,7 @@ impl<'a> Parser<'a> {\n                 e.emit();\n                 let lo = p.prev_token.span;\n                 // Skip every token until next possible arg or end.\n-                p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n+                p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(Delimiter::Parenthesis)]);\n                 // Create a placeholder argument for proper arg count (issue #34264).\n                 Ok(dummy_arg(Ident::new(kw::Empty, lo.to(p.prev_token.span))))\n             });\n@@ -2220,7 +2221,7 @@ impl<'a> Parser<'a> {\n                 let mut ty = this.parse_ty_for_param();\n                 if ty.is_ok()\n                     && this.token != token::Comma\n-                    && this.token != token::CloseDelim(token::Paren)\n+                    && this.token != token::CloseDelim(Delimiter::Parenthesis)\n                 {\n                     // This wasn't actually a type, but a pattern looking like a type,\n                     // so we are going to rollback and re-parse for recovery."}, {"sha": "96cca68257e7f1e4afe4d4c06a70e6ff46781cab", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -19,7 +19,7 @@ pub use pat::{CommaRecoveryMode, RecoverColon, RecoverComma};\n pub use path::PathStyle;\n \n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, DelimToken, Nonterminal, Token, TokenKind};\n+use rustc_ast::token::{self, Delimiter, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::AttributesData;\n use rustc_ast::tokenstream::{self, DelimSpan, Spacing};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n@@ -244,12 +244,12 @@ struct TokenCursor {\n \n #[derive(Clone)]\n struct TokenCursorFrame {\n-    delim_sp: Option<(DelimToken, DelimSpan)>,\n+    delim_sp: Option<(Delimiter, DelimSpan)>,\n     tree_cursor: tokenstream::Cursor,\n }\n \n impl TokenCursorFrame {\n-    fn new(delim_sp: Option<(DelimToken, DelimSpan)>, tts: TokenStream) -> Self {\n+    fn new(delim_sp: Option<(Delimiter, DelimSpan)>, tts: TokenStream) -> Self {\n         TokenCursorFrame { delim_sp, tree_cursor: tts.into_trees() }\n     }\n }\n@@ -263,8 +263,8 @@ impl TokenCursor {\n     #[inline(always)]\n     fn inlined_next(&mut self, desugar_doc_comments: bool) -> (Token, Spacing) {\n         loop {\n-            // FIXME: we currently don't return `NoDelim` open/close delims. To fix #67062 we will\n-            // need to, whereupon the `delim != DelimToken::NoDelim` conditions below can be\n+            // FIXME: we currently don't return `Delimiter` open/close delims. To fix #67062 we will\n+            // need to, whereupon the `delim != Delimiter::Invisible` conditions below can be\n             // removed.\n             if let Some((tree, spacing)) = self.frame.tree_cursor.next_with_spacing_ref() {\n                 match tree {\n@@ -278,14 +278,14 @@ impl TokenCursor {\n                         // Set `open_delim` to true here because we deal with it immediately.\n                         let frame = TokenCursorFrame::new(Some((delim, sp)), tts.clone());\n                         self.stack.push(mem::replace(&mut self.frame, frame));\n-                        if delim != DelimToken::NoDelim {\n+                        if delim != Delimiter::Invisible {\n                             return (Token::new(token::OpenDelim(delim), sp.open), Spacing::Alone);\n                         }\n                         // No open delimeter to return; continue on to the next iteration.\n                     }\n                 };\n             } else if let Some(frame) = self.stack.pop() {\n-                if let Some((delim, span)) = self.frame.delim_sp && delim != DelimToken::NoDelim {\n+                if let Some((delim, span)) = self.frame.delim_sp && delim != Delimiter::Invisible {\n                     self.frame = frame;\n                     return (Token::new(token::CloseDelim(delim), span.close), Spacing::Alone);\n                 }\n@@ -314,7 +314,7 @@ impl TokenCursor {\n         let delim_span = DelimSpan::from_single(span);\n         let body = TokenTree::Delimited(\n             delim_span,\n-            token::Bracket,\n+            Delimiter::Bracket,\n             [\n                 TokenTree::token(token::Ident(sym::doc, false), span),\n                 TokenTree::token(token::Eq, span),\n@@ -626,7 +626,7 @@ impl<'a> Parser<'a> {\n         self.is_keyword_ahead(dist, &[kw::Const])\n             && self.look_ahead(dist + 1, |t| match t.kind {\n                 token::Interpolated(ref nt) => matches!(**nt, token::NtBlock(..)),\n-                token::OpenDelim(DelimToken::Brace) => true,\n+                token::OpenDelim(Delimiter::Brace) => true,\n                 _ => false,\n             })\n     }\n@@ -954,7 +954,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_delim_comma_seq<T>(\n         &mut self,\n-        delim: DelimToken,\n+        delim: Delimiter,\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     ) -> PResult<'a, (Vec<T>, bool)> {\n         self.parse_unspanned_seq(\n@@ -969,7 +969,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     ) -> PResult<'a, (Vec<T>, bool)> {\n-        self.parse_delim_comma_seq(token::Paren, f)\n+        self.parse_delim_comma_seq(Delimiter::Parenthesis, f)\n     }\n \n     /// Advance the parser by one token using provided token as the next one.\n@@ -1005,7 +1005,7 @@ impl<'a> Parser<'a> {\n         }\n         debug_assert!(!matches!(\n             next.0.kind,\n-            token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim)\n+            token::OpenDelim(Delimiter::Invisible) | token::CloseDelim(Delimiter::Invisible)\n         ));\n         self.inlined_bump_with(next)\n     }\n@@ -1018,10 +1018,10 @@ impl<'a> Parser<'a> {\n         }\n \n         let frame = &self.token_cursor.frame;\n-        if let Some((delim, span)) = frame.delim_sp && delim != DelimToken::NoDelim {\n+        if let Some((delim, span)) = frame.delim_sp && delim != Delimiter::Invisible {\n             let all_normal = (0..dist).all(|i| {\n                 let token = frame.tree_cursor.look_ahead(i);\n-                !matches!(token, Some(TokenTree::Delimited(_, DelimToken::NoDelim, _)))\n+                !matches!(token, Some(TokenTree::Delimited(_, Delimiter::Invisible, _)))\n             });\n             if all_normal {\n                 return match frame.tree_cursor.look_ahead(dist - 1) {\n@@ -1043,7 +1043,7 @@ impl<'a> Parser<'a> {\n             token = cursor.next(/* desugar_doc_comments */ false).0;\n             if matches!(\n                 token.kind,\n-                token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim)\n+                token::OpenDelim(Delimiter::Invisible) | token::CloseDelim(Delimiter::Invisible)\n             ) {\n                 continue;\n             }\n@@ -1079,7 +1079,7 @@ impl<'a> Parser<'a> {\n     /// Parses constness: `const` or nothing.\n     fn parse_constness(&mut self) -> Const {\n         // Avoid const blocks to be parsed as const items\n-        if self.look_ahead(1, |t| t != &token::OpenDelim(DelimToken::Brace))\n+        if self.look_ahead(1, |t| t != &token::OpenDelim(Delimiter::Brace))\n             && self.eat_keyword(kw::Const)\n         {\n             Const::Yes(self.prev_token.uninterpolated_span())\n@@ -1142,9 +1142,9 @@ impl<'a> Parser<'a> {\n \n     fn parse_mac_args_common(&mut self, delimited_only: bool) -> PResult<'a, MacArgs> {\n         Ok(\n-            if self.check(&token::OpenDelim(DelimToken::Paren))\n-                || self.check(&token::OpenDelim(DelimToken::Bracket))\n-                || self.check(&token::OpenDelim(DelimToken::Brace))\n+            if self.check(&token::OpenDelim(Delimiter::Parenthesis))\n+                || self.check(&token::OpenDelim(Delimiter::Bracket))\n+                || self.check(&token::OpenDelim(Delimiter::Brace))\n             {\n                 match self.parse_token_tree() {\n                     TokenTree::Delimited(dspan, delim, tokens) =>\n@@ -1288,7 +1288,7 @@ impl<'a> Parser<'a> {\n         }\n         let lo = self.prev_token.span;\n \n-        if self.check(&token::OpenDelim(token::Paren)) {\n+        if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             // We don't `self.bump()` the `(` yet because this might be a struct definition where\n             // `()` or a tuple might be allowed. For example, `struct Struct(pub (), pub (usize));`.\n             // Because of this, we only `bump` the `(` if we're assured it is appropriate to do so\n@@ -1299,7 +1299,7 @@ impl<'a> Parser<'a> {\n                 // Parse `pub(crate)`.\n                 self.bump(); // `(`\n                 self.bump(); // `crate`\n-                self.expect(&token::CloseDelim(token::Paren))?; // `)`\n+                self.expect(&token::CloseDelim(Delimiter::Parenthesis))?; // `)`\n                 let vis = VisibilityKind::Crate(CrateSugar::PubCrate);\n                 return Ok(Visibility {\n                     span: lo.to(self.prev_token.span),\n@@ -1311,20 +1311,20 @@ impl<'a> Parser<'a> {\n                 self.bump(); // `(`\n                 self.bump(); // `in`\n                 let path = self.parse_path(PathStyle::Mod)?; // `path`\n-                self.expect(&token::CloseDelim(token::Paren))?; // `)`\n+                self.expect(&token::CloseDelim(Delimiter::Parenthesis))?; // `)`\n                 let vis = VisibilityKind::Restricted { path: P(path), id: ast::DUMMY_NODE_ID };\n                 return Ok(Visibility {\n                     span: lo.to(self.prev_token.span),\n                     kind: vis,\n                     tokens: None,\n                 });\n-            } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren))\n+            } else if self.look_ahead(2, |t| t == &token::CloseDelim(Delimiter::Parenthesis))\n                 && self.is_keyword_ahead(1, &[kw::Super, kw::SelfLower])\n             {\n                 // Parse `pub(self)` or `pub(super)`.\n                 self.bump(); // `(`\n                 let path = self.parse_path(PathStyle::Mod)?; // `super`/`self`\n-                self.expect(&token::CloseDelim(token::Paren))?; // `)`\n+                self.expect(&token::CloseDelim(Delimiter::Parenthesis))?; // `)`\n                 let vis = VisibilityKind::Restricted { path: P(path), id: ast::DUMMY_NODE_ID };\n                 return Ok(Visibility {\n                     span: lo.to(self.prev_token.span),\n@@ -1346,7 +1346,7 @@ impl<'a> Parser<'a> {\n     fn recover_incorrect_vis_restriction(&mut self) -> PResult<'a, ()> {\n         self.bump(); // `(`\n         let path = self.parse_path(PathStyle::Mod)?;\n-        self.expect(&token::CloseDelim(token::Paren))?; // `)`\n+        self.expect(&token::CloseDelim(Delimiter::Parenthesis))?; // `)`\n \n         let msg = \"incorrect visibility restriction\";\n         let suggestion = r##\"some possible visibility restrictions are:\n@@ -1413,7 +1413,7 @@ impl<'a> Parser<'a> {\n     fn is_import_coupler(&mut self) -> bool {\n         self.check(&token::ModSep)\n             && self.look_ahead(1, |t| {\n-                *t == token::OpenDelim(token::Brace) || *t == token::BinOp(token::Star)\n+                *t == token::OpenDelim(Delimiter::Brace) || *t == token::BinOp(token::Star)\n             })\n     }\n "}, {"sha": "6974f318f9498542de1683663afdcdb147e3c11d", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,5 +1,5 @@\n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, NonterminalKind, Token};\n+use rustc_ast::token::{self, Delimiter, NonterminalKind, Token};\n use rustc_ast::AstLike;\n use rustc_ast_pretty::pprust;\n use rustc_errors::PResult;\n@@ -43,7 +43,7 @@ impl<'a> Parser<'a> {\n                 _ => token.can_begin_type(),\n             },\n             NonterminalKind::Block => match token.kind {\n-                token::OpenDelim(token::Brace) => true,\n+                token::OpenDelim(Delimiter::Brace) => true,\n                 token::Interpolated(ref nt) => !matches!(\n                     **nt,\n                     token::NtItem(_)\n@@ -67,8 +67,8 @@ impl<'a> Parser<'a> {\n             NonterminalKind::PatParam { .. } | NonterminalKind::PatWithOr { .. } => {\n                 match token.kind {\n                 token::Ident(..) |                  // box, ref, mut, and other identifiers (can stricten)\n-                token::OpenDelim(token::Paren) |    // tuple pattern\n-                token::OpenDelim(token::Bracket) |  // slice pattern\n+                token::OpenDelim(Delimiter::Parenthesis) |    // tuple pattern\n+                token::OpenDelim(Delimiter::Bracket) |  // slice pattern\n                 token::BinOp(token::And) |          // reference\n                 token::BinOp(token::Minus) |        // negative literal\n                 token::AndAnd |                     // double reference"}, {"sha": "c7b929bf367dc1a6cf69d0708bdf27914410fb7b", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -2,7 +2,7 @@ use super::{ForceCollect, Parser, PathStyle, TrailingToken};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n use rustc_ast::ptr::P;\n-use rustc_ast::token;\n+use rustc_ast::token::{self, Delimiter};\n use rustc_ast::{\n     self as ast, AttrVec, Attribute, BindingMode, Expr, ExprKind, MacCall, Mutability, Pat,\n     PatField, PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n@@ -260,9 +260,9 @@ impl<'a> Parser<'a> {\n                 | token::Semi // e.g. `let a |;`.\n                 | token::Colon // e.g. `let a | :`.\n                 | token::Comma // e.g. `let (a |,)`.\n-                | token::CloseDelim(token::Bracket) // e.g. `let [a | ]`.\n-                | token::CloseDelim(token::Paren) // e.g. `let (a | )`.\n-                | token::CloseDelim(token::Brace) // e.g. `let A { f: a | }`.\n+                | token::CloseDelim(Delimiter::Bracket) // e.g. `let [a | ]`.\n+                | token::CloseDelim(Delimiter::Parenthesis) // e.g. `let (a | )`.\n+                | token::CloseDelim(Delimiter::Brace) // e.g. `let A { f: a | }`.\n             )\n         });\n         match (is_end_ahead, &self.token.kind) {\n@@ -323,11 +323,11 @@ impl<'a> Parser<'a> {\n \n         let pat = if self.check(&token::BinOp(token::And)) || self.token.kind == token::AndAnd {\n             self.parse_pat_deref(expected)?\n-        } else if self.check(&token::OpenDelim(token::Paren)) {\n+        } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             self.parse_pat_tuple_or_parens()?\n-        } else if self.check(&token::OpenDelim(token::Bracket)) {\n+        } else if self.check(&token::OpenDelim(Delimiter::Bracket)) {\n             // Parse `[pat, pat,...]` as a slice pattern.\n-            let (pats, _) = self.parse_delim_comma_seq(token::Bracket, |p| {\n+            let (pats, _) = self.parse_delim_comma_seq(Delimiter::Bracket, |p| {\n                 p.parse_pat_allow_top_alt(\n                     None,\n                     RecoverComma::No,\n@@ -389,9 +389,9 @@ impl<'a> Parser<'a> {\n             } else if let Some(form) = self.parse_range_end() {\n                 let begin = self.mk_expr(span, ExprKind::Path(qself, path), AttrVec::new());\n                 self.parse_pat_range_begin_with(begin, form)?\n-            } else if self.check(&token::OpenDelim(token::Brace)) {\n+            } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n                 self.parse_pat_struct(qself, path)?\n-            } else if self.check(&token::OpenDelim(token::Paren)) {\n+            } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n                 self.parse_pat_tuple_struct(qself, path)?\n             } else {\n                 PatKind::Path(qself, path)\n@@ -845,8 +845,8 @@ impl<'a> Parser<'a> {\n         // Avoid `in`. Due to recovery in the list parser this messes with `for ( $pat in $expr )`.\n         && !self.token.is_keyword(kw::In)\n         // Try to do something more complex?\n-        && self.look_ahead(1, |t| !matches!(t.kind, token::OpenDelim(token::Paren) // A tuple struct pattern.\n-            | token::OpenDelim(token::Brace) // A struct pattern.\n+        && self.look_ahead(1, |t| !matches!(t.kind, token::OpenDelim(Delimiter::Parenthesis) // A tuple struct pattern.\n+            | token::OpenDelim(Delimiter::Brace) // A struct pattern.\n             | token::DotDotDot | token::DotDotEq | token::DotDot // A range pattern.\n             | token::ModSep // A tuple / struct variant pattern.\n             | token::Not)) // A macro expanding to a pattern.\n@@ -868,7 +868,7 @@ impl<'a> Parser<'a> {\n         // This shortly leads to a parse error. Note that if there is no explicit\n         // binding mode then we do not end up here, because the lookahead\n         // will direct us over to `parse_enum_variant()`.\n-        if self.token == token::OpenDelim(token::Paren) {\n+        if self.token == token::OpenDelim(Delimiter::Parenthesis) {\n             return Err(self\n                 .struct_span_err(self.prev_token.span, \"expected identifier, found enum pattern\"));\n         }\n@@ -917,7 +917,7 @@ impl<'a> Parser<'a> {\n         let mut delayed_err: Option<DiagnosticBuilder<'a, ErrorGuaranteed>> = None;\n         let mut etc_span = None;\n \n-        while self.token != token::CloseDelim(token::Brace) {\n+        while self.token != token::CloseDelim(Delimiter::Brace) {\n             let attrs = match self.parse_outer_attributes() {\n                 Ok(attrs) => attrs,\n                 Err(err) => {\n@@ -946,7 +946,7 @@ impl<'a> Parser<'a> {\n                 self.recover_one_fewer_dotdot();\n                 self.bump(); // `..` || `...`\n \n-                if self.token == token::CloseDelim(token::Brace) {\n+                if self.token == token::CloseDelim(Delimiter::Brace) {\n                     etc_span = Some(etc_sp);\n                     break;\n                 }\n@@ -970,7 +970,7 @@ impl<'a> Parser<'a> {\n                 }\n \n                 etc_span = Some(etc_sp.until(self.token.span));\n-                if self.token == token::CloseDelim(token::Brace) {\n+                if self.token == token::CloseDelim(Delimiter::Brace) {\n                     // If the struct looks otherwise well formed, recover and continue.\n                     if let Some(sp) = comma_sp {\n                         err.span_suggestion_short("}, {"sha": "5c6fb376cd41a0d51051b4c8a6b27917e5029ce1", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -2,7 +2,7 @@ use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{Parser, Restrictions, TokenType};\n use crate::maybe_whole;\n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, Token};\n+use rustc_ast::token::{self, Delimiter, Token};\n use rustc_ast::{\n     self as ast, AngleBracketedArg, AngleBracketedArgs, AnonConst, AssocConstraint,\n     AssocConstraintKind, BlockCheckMode, GenericArg, GenericArgs, Generics, ParenthesizedArgs,\n@@ -236,14 +236,14 @@ impl<'a> Parser<'a> {\n                 token.kind,\n                 token::Lt\n                     | token::BinOp(token::Shl)\n-                    | token::OpenDelim(token::Paren)\n+                    | token::OpenDelim(Delimiter::Parenthesis)\n                     | token::LArrow\n             )\n         };\n         let check_args_start = |this: &mut Self| {\n             this.expected_tokens.extend_from_slice(&[\n                 TokenType::Token(token::Lt),\n-                TokenType::Token(token::OpenDelim(token::Paren)),\n+                TokenType::Token(token::OpenDelim(Delimiter::Parenthesis)),\n             ]);\n             is_args_start(&this.token)\n         };\n@@ -639,7 +639,7 @@ impl<'a> Parser<'a> {\n     /// the caller.\n     pub(super) fn parse_const_arg(&mut self) -> PResult<'a, AnonConst> {\n         // Parse const argument.\n-        let value = if let token::OpenDelim(token::Brace) = self.token.kind {\n+        let value = if let token::OpenDelim(Delimiter::Brace) = self.token.kind {\n             self.parse_block_expr(\n                 None,\n                 self.token.span,\n@@ -667,7 +667,8 @@ impl<'a> Parser<'a> {\n             GenericArg::Const(self.parse_const_arg()?)\n         } else if self.check_type() {\n             // Parse type argument.\n-            let is_const_fn = self.look_ahead(1, |t| t.kind == token::OpenDelim(token::Paren));\n+            let is_const_fn =\n+                self.look_ahead(1, |t| t.kind == token::OpenDelim(Delimiter::Parenthesis));\n             let mut snapshot = self.create_snapshot_for_diagnostic();\n             match self.parse_ty() {\n                 Ok(ty) => GenericArg::Type(ty),"}, {"sha": "ac693597662e6e55c27ca68c7fbabcfa5cd958bf", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -11,7 +11,7 @@ use crate::maybe_whole;\n \n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, TokenKind};\n+use rustc_ast::token::{self, Delimiter, TokenKind};\n use rustc_ast::util::classify;\n use rustc_ast::{\n     AstLike, AttrStyle, AttrVec, Attribute, LocalKind, MacCall, MacCallStmt, MacStmtStyle,\n@@ -92,7 +92,7 @@ impl<'a> Parser<'a> {\n             // Do not attempt to parse an expression if we're done here.\n             self.error_outer_attrs(&attrs.take_for_recovery());\n             self.mk_stmt(lo, StmtKind::Empty)\n-        } else if self.token != token::CloseDelim(token::Brace) {\n+        } else if self.token != token::CloseDelim(Delimiter::Brace) {\n             // Remainder are line-expr stmts.\n             let e = if force_collect == ForceCollect::Yes {\n                 self.collect_tokens_no_attrs(|this| {\n@@ -131,7 +131,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n \n-            let expr = if this.eat(&token::OpenDelim(token::Brace)) {\n+            let expr = if this.eat(&token::OpenDelim(Delimiter::Brace)) {\n                 this.parse_struct_expr(None, path, AttrVec::new(), true)?\n             } else {\n                 let hi = this.prev_token.span;\n@@ -165,7 +165,7 @@ impl<'a> Parser<'a> {\n         let hi = self.prev_token.span;\n \n         let style = match delim {\n-            Some(token::Brace) => MacStmtStyle::Braces,\n+            Some(Delimiter::Brace) => MacStmtStyle::Braces,\n             Some(_) => MacStmtStyle::NoBraces,\n             None => unreachable!(),\n         };\n@@ -434,7 +434,7 @@ impl<'a> Parser<'a> {\n             // If the next token is an open brace (e.g., `if a b {`), the place-\n             // inside-a-block suggestion would be more likely wrong than right.\n             Ok(Some(_))\n-                if self.look_ahead(1, |t| t == &token::OpenDelim(token::Brace))\n+                if self.look_ahead(1, |t| t == &token::OpenDelim(Delimiter::Brace))\n                     || do_not_suggest_help => {}\n             // Do not suggest `if foo println!(\"\") {;}` (as would be seen in test for #46836).\n             Ok(Some(Stmt { kind: StmtKind::Empty, .. })) => {}\n@@ -488,7 +488,7 @@ impl<'a> Parser<'a> {\n         maybe_whole!(self, NtBlock, |x| (Vec::new(), x));\n \n         self.maybe_recover_unexpected_block_label();\n-        if !self.eat(&token::OpenDelim(token::Brace)) {\n+        if !self.eat(&token::OpenDelim(Delimiter::Brace)) {\n             return self.error_block_no_opening_brace();\n         }\n \n@@ -509,7 +509,7 @@ impl<'a> Parser<'a> {\n         recover: AttemptLocalParseRecovery,\n     ) -> PResult<'a, P<Block>> {\n         let mut stmts = vec![];\n-        while !self.eat(&token::CloseDelim(token::Brace)) {\n+        while !self.eat(&token::CloseDelim(Delimiter::Brace)) {\n             if self.token == token::Eof {\n                 break;\n             }\n@@ -553,7 +553,7 @@ impl<'a> Parser<'a> {\n             {\n                 // Just check for errors and recover; do not eat semicolon yet.\n                 if let Err(mut e) =\n-                    self.expect_one_of(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n+                    self.expect_one_of(&[], &[token::Semi, token::CloseDelim(Delimiter::Brace)])\n                 {\n                     if let TokenKind::DocComment(..) = self.token.kind {\n                         if let Ok(snippet) = self.span_to_snippet(self.token.span) {"}, {"sha": "9e771a8af1a4e0a3368b4c4b5a7409fa05fafa00", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -3,7 +3,7 @@ use super::{Parser, PathStyle, TokenType};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n \n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, Token, TokenKind};\n+use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n use rustc_ast::{\n     self as ast, BareFnTy, FnRetTy, GenericBound, GenericBounds, GenericParam, Generics, Lifetime,\n     MacCall, MutTy, Mutability, PolyTraitRef, TraitBoundModifier, TraitObjectSyntax, Ty, TyKind,\n@@ -249,14 +249,14 @@ impl<'a> Parser<'a> {\n \n         let lo = self.token.span;\n         let mut impl_dyn_multi = false;\n-        let kind = if self.check(&token::OpenDelim(token::Paren)) {\n+        let kind = if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             self.parse_ty_tuple_or_parens(lo, allow_plus)?\n         } else if self.eat(&token::Not) {\n             // Never type `!`\n             TyKind::Never\n         } else if self.eat(&token::BinOp(token::Star)) {\n             self.parse_ty_ptr()?\n-        } else if self.eat(&token::OpenDelim(token::Bracket)) {\n+        } else if self.eat(&token::OpenDelim(Delimiter::Bracket)) {\n             self.parse_array_or_slice_ty()?\n         } else if self.check(&token::BinOp(token::And)) || self.check(&token::AndAnd) {\n             // Reference\n@@ -409,7 +409,7 @@ impl<'a> Parser<'a> {\n         let elt_ty = match self.parse_ty() {\n             Ok(ty) => ty,\n             Err(mut err)\n-                if self.look_ahead(1, |t| t.kind == token::CloseDelim(token::Bracket))\n+                if self.look_ahead(1, |t| t.kind == token::CloseDelim(Delimiter::Bracket))\n                     | self.look_ahead(1, |t| t.kind == token::Semi) =>\n             {\n                 // Recover from `[LIT; EXPR]` and `[LIT]`\n@@ -422,14 +422,14 @@ impl<'a> Parser<'a> {\n \n         let ty = if self.eat(&token::Semi) {\n             let mut length = self.parse_anon_const_expr()?;\n-            if let Err(e) = self.expect(&token::CloseDelim(token::Bracket)) {\n+            if let Err(e) = self.expect(&token::CloseDelim(Delimiter::Bracket)) {\n                 // Try to recover from `X<Y, ...>` when `X::<Y, ...>` works\n                 self.check_mistyped_turbofish_with_multiple_type_params(e, &mut length.value)?;\n-                self.expect(&token::CloseDelim(token::Bracket))?;\n+                self.expect(&token::CloseDelim(Delimiter::Bracket))?;\n             }\n             TyKind::Array(elt_ty, length)\n         } else {\n-            self.expect(&token::CloseDelim(token::Bracket))?;\n+            self.expect(&token::CloseDelim(Delimiter::Bracket))?;\n             TyKind::Slice(elt_ty)\n         };\n \n@@ -492,9 +492,9 @@ impl<'a> Parser<'a> {\n     // Parses the `typeof(EXPR)`.\n     // To avoid ambiguity, the type is surrounded by parentheses.\n     fn parse_typeof_ty(&mut self) -> PResult<'a, TyKind> {\n-        self.expect(&token::OpenDelim(token::Paren))?;\n+        self.expect(&token::OpenDelim(Delimiter::Parenthesis))?;\n         let expr = self.parse_anon_const_expr()?;\n-        self.expect(&token::CloseDelim(token::Paren))?;\n+        self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n         Ok(TyKind::Typeof(expr))\n     }\n \n@@ -672,7 +672,7 @@ impl<'a> Parser<'a> {\n         || self.check(&token::Question)\n         || self.check(&token::Tilde)\n         || self.check_keyword(kw::For)\n-        || self.check(&token::OpenDelim(token::Paren))\n+        || self.check(&token::OpenDelim(Delimiter::Parenthesis))\n     }\n \n     fn error_negative_bounds(\n@@ -713,7 +713,7 @@ impl<'a> Parser<'a> {\n     fn parse_generic_bound(&mut self) -> PResult<'a, Result<GenericBound, Span>> {\n         let anchor_lo = self.prev_token.span;\n         let lo = self.token.span;\n-        let has_parens = self.eat(&token::OpenDelim(token::Paren));\n+        let has_parens = self.eat(&token::OpenDelim(Delimiter::Parenthesis));\n         let inner_lo = self.token.span;\n         let is_negative = self.eat(&token::Not);\n \n@@ -766,7 +766,7 @@ impl<'a> Parser<'a> {\n     /// Recover on `('lifetime)` with `(` already eaten.\n     fn recover_paren_lifetime(&mut self, lo: Span, inner_lo: Span) -> PResult<'a, ()> {\n         let inner_span = inner_lo.to(self.prev_token.span);\n-        self.expect(&token::CloseDelim(token::Paren))?;\n+        self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n         let mut err = self.struct_span_err(\n             lo.to(self.prev_token.span),\n             \"parenthesized lifetime bounds are not supported\",\n@@ -829,7 +829,7 @@ impl<'a> Parser<'a> {\n                 // suggestion is given.\n                 let bounds = vec![];\n                 self.parse_remaining_bounds(bounds, true)?;\n-                self.expect(&token::CloseDelim(token::Paren))?;\n+                self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n                 let sp = vec![lo, self.prev_token.span];\n                 let sugg: Vec<_> = sp.iter().map(|sp| (*sp, String::new())).collect();\n                 self.struct_span_err(sp, \"incorrect braces around trait bounds\")\n@@ -840,7 +840,7 @@ impl<'a> Parser<'a> {\n                     )\n                     .emit();\n             } else {\n-                self.expect(&token::CloseDelim(token::Paren))?;\n+                self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n             }\n         }\n "}, {"sha": "db755ccd1d5155fc0ce1ed4999a48fcde6caa54f", "filename": "compiler/rustc_session/src/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_session%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/compiler%2Frustc_session%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Futils.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,6 +1,6 @@\n use crate::parse::ParseSess;\n use crate::session::Session;\n-use rustc_ast::token::{self, DelimToken, Nonterminal, Token};\n+use rustc_ast::token::{self, Delimiter, Nonterminal, Token};\n use rustc_ast::tokenstream::CanSynthesizeMissingTokens;\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use rustc_data_structures::profiling::VerboseTimingGuard;\n@@ -137,7 +137,7 @@ impl<'a> FlattenNonterminals<'a> {\n                 let tts = (self.nt_to_tokenstream)(&nt, self.parse_sess, self.synthesize_tokens);\n                 TokenTree::Delimited(\n                     DelimSpan::from_single(token.span),\n-                    DelimToken::NoDelim,\n+                    Delimiter::Invisible,\n                     self.process_token_stream(tts),\n                 )\n                 .into()"}, {"sha": "f1c5eaad868e99d495224fd2cee4111f4e9c17b6", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -704,10 +704,10 @@ pub enum Delimiter {\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     Bracket,\n     /// `\u00d8 ... \u00d8`\n-    /// An implicit delimiter, that may, for example, appear around tokens coming from a\n+    /// An invisible delimiter, that may, for example, appear around tokens coming from a\n     /// \"macro variable\" `$var`. It is important to preserve operator priorities in cases like\n     /// `$var * 3` where `$var` is `1 + 2`.\n-    /// Implicit delimiters might not survive roundtrip of a token stream through a string.\n+    /// Invisible delimiters might not survive roundtrip of a token stream through a string.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     None,\n }"}, {"sha": "a9c0fe6f0797147f96b7c76f7230d474fbfe7466", "filename": "src/librustdoc/clean/render_macro_matchers.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::token::{self, BinOpToken, DelimToken};\n+use rustc_ast::token::{self, BinOpToken, Delimiter};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast_pretty::pprust::state::State as Printer;\n use rustc_ast_pretty::pprust::PrintState;\n@@ -104,11 +104,11 @@ fn print_tt(printer: &mut Printer<'_>, tt: &TokenTree) {\n             let open_delim = printer.token_kind_to_string(&token::OpenDelim(*delim));\n             printer.word(open_delim);\n             if !tts.is_empty() {\n-                if *delim == DelimToken::Brace {\n+                if *delim == Delimiter::Brace {\n                     printer.space();\n                 }\n                 print_tts(printer, tts);\n-                if *delim == DelimToken::Brace {\n+                if *delim == Delimiter::Brace {\n                     printer.space();\n                 }\n             }\n@@ -162,9 +162,9 @@ fn print_tts(printer: &mut Printer<'_>, tts: &TokenStream) {\n                 (_, _) => (true, Other),\n             },\n             TokenTree::Delimited(_, delim, _) => match (state, delim) {\n-                (Dollar, DelimToken::Paren) => (false, DollarParen),\n-                (Pound | PoundBang, DelimToken::Bracket) => (false, Other),\n-                (Ident, DelimToken::Paren | DelimToken::Bracket) => (false, Other),\n+                (Dollar, Delimiter::Parenthesis) => (false, DollarParen),\n+                (Pound | PoundBang, Delimiter::Bracket) => (false, Other),\n+                (Ident, Delimiter::Parenthesis | Delimiter::Bracket) => (false, Other),\n                 (_, _) => (true, Other),\n             },\n         };"}, {"sha": "ec30199028142730015818db08cb0f56b298fd02", "filename": "src/test/ui/proc-macro/nodelim-groups.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Ftest%2Fui%2Fproc-macro%2Fnodelim-groups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Ftest%2Fui%2Fproc-macro%2Fnodelim-groups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnodelim-groups.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -3,7 +3,7 @@\n // compile-flags: -Z span-debug\n // edition:2018\n //\n-// Tests the pretty-printing behavior of inserting `NoDelim` groups\n+// Tests the pretty-printing behavior of inserting `Invisible`-delimited groups\n \n #![no_std] // Don't load unnecessary hygiene information from std\n extern crate std;"}, {"sha": "741f3350801db8c742f29697ec1224e3ff6bf713", "filename": "src/tools/rustfmt/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -2,7 +2,7 @@ use std::borrow::Cow;\n use std::cmp::min;\n \n use itertools::Itertools;\n-use rustc_ast::token::{DelimToken, LitKind};\n+use rustc_ast::token::{Delimiter, LitKind};\n use rustc_ast::{ast, ptr};\n use rustc_span::{BytePos, Span};\n \n@@ -412,7 +412,7 @@ pub(crate) fn rewrite_array<'a, T: 'a + IntoOverflowableItem<'a>>(\n     context: &'a RewriteContext<'_>,\n     shape: Shape,\n     force_separator_tactic: Option<SeparatorTactic>,\n-    delim_token: Option<DelimToken>,\n+    delim_token: Option<Delimiter>,\n ) -> Option<String> {\n     overflow::rewrite_with_square_brackets(\n         context,"}, {"sha": "26c429eb94ff3b1d0bb2677c9a1dbf7c8cd10b28", "filename": "src/tools/rustfmt/src/macros.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -12,7 +12,7 @@\n use std::collections::HashMap;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n-use rustc_ast::token::{BinOpToken, DelimToken, Token, TokenKind};\n+use rustc_ast::token::{BinOpToken, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::{Cursor, Spacing, TokenStream, TokenTree};\n use rustc_ast::{ast, ptr};\n use rustc_ast_pretty::pprust;\n@@ -203,7 +203,7 @@ fn rewrite_macro_inner(\n     let is_forced_bracket = FORCED_BRACKET_MACROS.contains(&&macro_name[..]);\n \n     let style = if is_forced_bracket && !is_nested_macro {\n-        DelimToken::Bracket\n+        Delimiter::Bracket\n     } else {\n         original_style\n     };\n@@ -212,15 +212,15 @@ fn rewrite_macro_inner(\n     let has_comment = contains_comment(context.snippet(mac.span()));\n     if ts.is_empty() && !has_comment {\n         return match style {\n-            DelimToken::Paren if position == MacroPosition::Item => {\n+            Delimiter::Parenthesis if position == MacroPosition::Item => {\n                 Some(format!(\"{}();\", macro_name))\n             }\n-            DelimToken::Bracket if position == MacroPosition::Item => {\n+            Delimiter::Bracket if position == MacroPosition::Item => {\n                 Some(format!(\"{}[];\", macro_name))\n             }\n-            DelimToken::Paren => Some(format!(\"{}()\", macro_name)),\n-            DelimToken::Bracket => Some(format!(\"{}[]\", macro_name)),\n-            DelimToken::Brace => Some(format!(\"{} {{}}\", macro_name)),\n+            Delimiter::Parenthesis => Some(format!(\"{}()\", macro_name)),\n+            Delimiter::Bracket => Some(format!(\"{}[]\", macro_name)),\n+            Delimiter::Brace => Some(format!(\"{} {{}}\", macro_name)),\n             _ => unreachable!(),\n         };\n     }\n@@ -260,7 +260,7 @@ fn rewrite_macro_inner(\n     }\n \n     match style {\n-        DelimToken::Paren => {\n+        Delimiter::Parenthesis => {\n             // Handle special case: `vec!(expr; expr)`\n             if vec_with_semi {\n                 handle_vec_semi(context, shape, arg_vec, macro_name, style)\n@@ -286,7 +286,7 @@ fn rewrite_macro_inner(\n                 })\n             }\n         }\n-        DelimToken::Bracket => {\n+        Delimiter::Bracket => {\n             // Handle special case: `vec![expr; expr]`\n             if vec_with_semi {\n                 handle_vec_semi(context, shape, arg_vec, macro_name, style)\n@@ -323,7 +323,7 @@ fn rewrite_macro_inner(\n                 Some(format!(\"{}{}\", rewrite, comma))\n             }\n         }\n-        DelimToken::Brace => {\n+        Delimiter::Brace => {\n             // For macro invocations with braces, always put a space between\n             // the `macro_name!` and `{ /* macro_body */ }` but skip modifying\n             // anything in between the braces (for now).\n@@ -342,11 +342,11 @@ fn handle_vec_semi(\n     shape: Shape,\n     arg_vec: Vec<MacroArg>,\n     macro_name: String,\n-    delim_token: DelimToken,\n+    delim_token: Delimiter,\n ) -> Option<String> {\n     let (left, right) = match delim_token {\n-        DelimToken::Paren => (\"(\", \")\"),\n-        DelimToken::Bracket => (\"[\", \"]\"),\n+        Delimiter::Parenthesis => (\"(\", \")\"),\n+        Delimiter::Bracket => (\"[\", \"]\"),\n         _ => unreachable!(),\n     };\n \n@@ -528,7 +528,7 @@ enum MacroArgKind {\n     /// e.g., `$($foo: expr),*`\n     Repeat(\n         /// `()`, `[]` or `{}`.\n-        DelimToken,\n+        Delimiter,\n         /// Inner arguments inside delimiters.\n         Vec<ParsedMacroArg>,\n         /// Something after the closing delimiter and the repeat token, if available.\n@@ -537,7 +537,7 @@ enum MacroArgKind {\n         Token,\n     ),\n     /// e.g., `[derive(Debug)]`\n-    Delimited(DelimToken, Vec<ParsedMacroArg>),\n+    Delimited(Delimiter, Vec<ParsedMacroArg>),\n     /// A possible separator. e.g., `,` or `;`.\n     Separator(String, String),\n     /// Other random stuff that does not fit to other kinds.\n@@ -547,22 +547,22 @@ enum MacroArgKind {\n \n fn delim_token_to_str(\n     context: &RewriteContext<'_>,\n-    delim_token: DelimToken,\n+    delim_token: Delimiter,\n     shape: Shape,\n     use_multiple_lines: bool,\n     inner_is_empty: bool,\n ) -> (String, String) {\n     let (lhs, rhs) = match delim_token {\n-        DelimToken::Paren => (\"(\", \")\"),\n-        DelimToken::Bracket => (\"[\", \"]\"),\n-        DelimToken::Brace => {\n+        Delimiter::Parenthesis => (\"(\", \")\"),\n+        Delimiter::Bracket => (\"[\", \"]\"),\n+        Delimiter::Brace => {\n             if inner_is_empty || use_multiple_lines {\n                 (\"{\", \"}\")\n             } else {\n                 (\"{ \", \" }\")\n             }\n         }\n-        DelimToken::NoDelim => unreachable!(),\n+        Delimiter::Invisible => unreachable!(),\n     };\n     if use_multiple_lines {\n         let indent_str = shape.indent.to_string_with_newline(context.config);\n@@ -583,8 +583,8 @@ impl MacroArgKind {\n     fn starts_with_brace(&self) -> bool {\n         matches!(\n             *self,\n-            MacroArgKind::Repeat(DelimToken::Brace, _, _, _)\n-                | MacroArgKind::Delimited(DelimToken::Brace, _)\n+            MacroArgKind::Repeat(Delimiter::Brace, _, _, _)\n+                | MacroArgKind::Delimited(Delimiter::Brace, _)\n         )\n     }\n \n@@ -753,7 +753,7 @@ impl MacroArgParser {\n         }\n     }\n \n-    fn add_delimited(&mut self, inner: Vec<ParsedMacroArg>, delim: DelimToken) {\n+    fn add_delimited(&mut self, inner: Vec<ParsedMacroArg>, delim: Delimiter) {\n         self.result.push(ParsedMacroArg {\n             kind: MacroArgKind::Delimited(delim, inner),\n         });\n@@ -763,7 +763,7 @@ impl MacroArgParser {\n     fn add_repeat(\n         &mut self,\n         inner: Vec<ParsedMacroArg>,\n-        delim: DelimToken,\n+        delim: Delimiter,\n         iter: &mut Cursor,\n     ) -> Option<()> {\n         let mut buffer = String::new();\n@@ -1083,18 +1083,18 @@ pub(crate) fn convert_try_mac(\n     }\n }\n \n-pub(crate) fn macro_style(mac: &ast::MacCall, context: &RewriteContext<'_>) -> DelimToken {\n+pub(crate) fn macro_style(mac: &ast::MacCall, context: &RewriteContext<'_>) -> Delimiter {\n     let snippet = context.snippet(mac.span());\n     let paren_pos = snippet.find_uncommented(\"(\").unwrap_or(usize::max_value());\n     let bracket_pos = snippet.find_uncommented(\"[\").unwrap_or(usize::max_value());\n     let brace_pos = snippet.find_uncommented(\"{\").unwrap_or(usize::max_value());\n \n     if paren_pos < bracket_pos && paren_pos < brace_pos {\n-        DelimToken::Paren\n+        Delimiter::Parenthesis\n     } else if bracket_pos < brace_pos {\n-        DelimToken::Bracket\n+        Delimiter::Bracket\n     } else {\n-        DelimToken::Brace\n+        Delimiter::Brace\n     }\n }\n \n@@ -1174,7 +1174,7 @@ struct Macro {\n // rather than clone them, if we can make the borrowing work out.\n struct MacroBranch {\n     span: Span,\n-    args_paren_kind: DelimToken,\n+    args_paren_kind: Delimiter,\n     args: TokenStream,\n     body: Span,\n     whole_body: Span,\n@@ -1188,7 +1188,7 @@ impl MacroBranch {\n         multi_branch_style: bool,\n     ) -> Option<String> {\n         // Only attempt to format function-like macros.\n-        if self.args_paren_kind != DelimToken::Paren {\n+        if self.args_paren_kind != Delimiter::Parenthesis {\n             // FIXME(#1539): implement for non-sugared macros.\n             return None;\n         }\n@@ -1350,18 +1350,18 @@ fn rewrite_macro_with_items(\n     items: &[MacroArg],\n     macro_name: &str,\n     shape: Shape,\n-    style: DelimToken,\n+    style: Delimiter,\n     position: MacroPosition,\n     span: Span,\n ) -> Option<String> {\n     let (opener, closer) = match style {\n-        DelimToken::Paren => (\"(\", \")\"),\n-        DelimToken::Bracket => (\"[\", \"]\"),\n-        DelimToken::Brace => (\" {\", \"}\"),\n+        Delimiter::Parenthesis => (\"(\", \")\"),\n+        Delimiter::Bracket => (\"[\", \"]\"),\n+        Delimiter::Brace => (\" {\", \"}\"),\n         _ => return None,\n     };\n     let trailing_semicolon = match style {\n-        DelimToken::Paren | DelimToken::Bracket if position == MacroPosition::Item => \";\",\n+        Delimiter::Parenthesis | Delimiter::Bracket if position == MacroPosition::Item => \";\",\n         _ => \"\",\n     };\n "}, {"sha": "f115e7d0261826b9bfd30b91a8fd776ce6fab1be", "filename": "src/tools/rustfmt/src/overflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Ftools%2Frustfmt%2Fsrc%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Ftools%2Frustfmt%2Fsrc%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Foverflow.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -3,7 +3,7 @@\n use std::cmp::min;\n \n use itertools::Itertools;\n-use rustc_ast::token::DelimToken;\n+use rustc_ast::token::Delimiter;\n use rustc_ast::{ast, ptr};\n use rustc_span::Span;\n \n@@ -297,11 +297,11 @@ pub(crate) fn rewrite_with_square_brackets<'a, T: 'a + IntoOverflowableItem<'a>>\n     shape: Shape,\n     span: Span,\n     force_separator_tactic: Option<SeparatorTactic>,\n-    delim_token: Option<DelimToken>,\n+    delim_token: Option<Delimiter>,\n ) -> Option<String> {\n     let (lhs, rhs) = match delim_token {\n-        Some(DelimToken::Paren) => (\"(\", \")\"),\n-        Some(DelimToken::Brace) => (\"{\", \"}\"),\n+        Some(Delimiter::Parenthesis) => (\"(\", \")\"),\n+        Some(Delimiter::Brace) => (\"{\", \"}\"),\n         _ => (\"[\", \"]\"),\n     };\n     Context::new("}, {"sha": "09b3e32df312d5b026be722102e2e20e526ad1a8", "filename": "src/tools/rustfmt/src/parse/macros/cfg_if.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,7 +1,7 @@\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n use rustc_ast::ast;\n-use rustc_ast::token::{DelimToken, TokenKind};\n+use rustc_ast::token::{Delimiter, TokenKind};\n use rustc_parse::parser::ForceCollect;\n use rustc_span::symbol::kw;\n \n@@ -47,11 +47,11 @@ fn parse_cfg_if_inner<'a>(\n                 .map_err(|_| \"Failed to parse attributes\")?;\n         }\n \n-        if !parser.eat(&TokenKind::OpenDelim(DelimToken::Brace)) {\n+        if !parser.eat(&TokenKind::OpenDelim(Delimiter::Brace)) {\n             return Err(\"Expected an opening brace\");\n         }\n \n-        while parser.token != TokenKind::CloseDelim(DelimToken::Brace)\n+        while parser.token != TokenKind::CloseDelim(Delimiter::Brace)\n             && parser.token.kind != TokenKind::Eof\n         {\n             let item = match parser.parse_item(ForceCollect::No) {\n@@ -70,7 +70,7 @@ fn parse_cfg_if_inner<'a>(\n             }\n         }\n \n-        if !parser.eat(&TokenKind::CloseDelim(DelimToken::Brace)) {\n+        if !parser.eat(&TokenKind::CloseDelim(Delimiter::Brace)) {\n             return Err(\"Expected a closing brace\");\n         }\n "}, {"sha": "d4dbf21f8cab7fffa14ca8abd08530c78f50bd88", "filename": "src/tools/rustfmt/src/parse/macros/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fmod.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::token::{DelimToken, TokenKind};\n+use rustc_ast::token::{Delimiter, TokenKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::{ast, ptr};\n use rustc_parse::parser::{ForceCollect, Parser};\n@@ -81,7 +81,7 @@ fn check_keyword<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n             && parser.look_ahead(1, |t| {\n                 t.kind == TokenKind::Eof\n                     || t.kind == TokenKind::Comma\n-                    || t.kind == TokenKind::CloseDelim(DelimToken::NoDelim)\n+                    || t.kind == TokenKind::CloseDelim(Delimiter::Invisible)\n             })\n         {\n             parser.bump();\n@@ -97,15 +97,15 @@ fn check_keyword<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n pub(crate) fn parse_macro_args(\n     context: &RewriteContext<'_>,\n     tokens: TokenStream,\n-    style: DelimToken,\n+    style: Delimiter,\n     forced_bracket: bool,\n ) -> Option<ParsedMacroArgs> {\n     let mut parser = build_parser(context, tokens);\n     let mut args = Vec::new();\n     let mut vec_with_semi = false;\n     let mut trailing_comma = false;\n \n-    if DelimToken::Brace != style {\n+    if Delimiter::Brace != style {\n         loop {\n             if let Some(arg) = check_keyword(&mut parser) {\n                 args.push(arg);"}, {"sha": "f04fb2e0446c2f06e870a702d19e59ff8215560d", "filename": "src/tools/rustfmt/src/visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs?ref=0cbf3b2b30c3ae5443dbdce8e1b03c0b13fd6929", "patch": "@@ -1,7 +1,7 @@\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n \n-use rustc_ast::{ast, token::DelimToken, visit, AstLike};\n+use rustc_ast::{ast, token::Delimiter, visit, AstLike};\n use rustc_data_structures::sync::Lrc;\n use rustc_span::{symbol, BytePos, Pos, Span};\n \n@@ -689,7 +689,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         // with whitespace between the delimiters and trailing semi (i.e. `foo!(abc)     ;`)\n         // are formatted correctly.\n         let (span, rewrite) = match macro_style(mac, &self.get_context()) {\n-            DelimToken::Bracket | DelimToken::Paren if MacroPosition::Item == pos => {\n+            Delimiter::Bracket | Delimiter::Parenthesis if MacroPosition::Item == pos => {\n                 let search_span = mk_sp(mac.span().hi(), self.snippet_provider.end_pos());\n                 let hi = self.snippet_provider.span_before(search_span, \";\");\n                 let target_span = mk_sp(mac.span().lo(), hi + BytePos(1));"}]}