{"sha": "417eefedfa4554d1417994a67186dd6a0a720aa8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxN2VlZmVkZmE0NTU0ZDE0MTc5OTRhNjcxODZkZDZhMGE3MjBhYTg=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-01-09T11:20:51Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-01-26T18:32:03Z"}, "message": "BTreeMap: stop tree from being owned by non-root node", "tree": {"sha": "822ca07f588582598e31598bfe6d0bea1258d389", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/822ca07f588582598e31598bfe6d0bea1258d389"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/417eefedfa4554d1417994a67186dd6a0a720aa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/417eefedfa4554d1417994a67186dd6a0a720aa8", "html_url": "https://github.com/rust-lang/rust/commit/417eefedfa4554d1417994a67186dd6a0a720aa8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/417eefedfa4554d1417994a67186dd6a0a720aa8/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7907345e58b4f4d2c95e5ea9b8e0b3bff8946523", "url": "https://api.github.com/repos/rust-lang/rust/commits/7907345e58b4f4d2c95e5ea9b8e0b3bff8946523", "html_url": "https://github.com/rust-lang/rust/commit/7907345e58b4f4d2c95e5ea9b8e0b3bff8946523"}], "stats": {"total": 105, "additions": 73, "deletions": 32}, "files": [{"sha": "79dc694e6be82a41516e31d1802af7a674bba03e", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/417eefedfa4554d1417994a67186dd6a0a720aa8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/417eefedfa4554d1417994a67186dd6a0a720aa8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=417eefedfa4554d1417994a67186dd6a0a720aa8", "patch": "@@ -300,8 +300,8 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n /// [`into_iter`]: IntoIterator::into_iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    front: Option<Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>>,\n-    back: Option<Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>>,\n+    front: Option<Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge>>,\n     length: usize,\n }\n \n@@ -1364,7 +1364,7 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     fn into_iter(self) -> IntoIter<K, V> {\n         let mut me = ManuallyDrop::new(self);\n         if let Some(root) = me.root.take() {\n-            let (f, b) = root.full_range();\n+            let (f, b) = root.into_dying().full_range();\n \n             IntoIter { front: Some(f), back: Some(b), length: me.length }\n         } else {"}, {"sha": "2773b427fb13345b42e7d07a4c1faf3fdae090a0", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/417eefedfa4554d1417994a67186dd6a0a720aa8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/417eefedfa4554d1417994a67186dd6a0a720aa8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=417eefedfa4554d1417994a67186dd6a0a720aa8", "patch": "@@ -12,7 +12,7 @@ use super::unwrap_unchecked;\n ///\n /// The result is meaningful only if the tree is ordered by key, like the tree\n /// in a `BTreeMap` is.\n-fn range_search<BorrowType, K, V, Q, R>(\n+fn range_search<BorrowType: marker::BorrowType, K, V, Q, R>(\n     root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     range: R,\n@@ -105,7 +105,7 @@ where\n }\n \n /// Equivalent to `range_search(k, v, ..)` but without the `Ord` bound.\n-fn full_range<BorrowType, K, V>(\n+fn full_range<BorrowType: marker::BorrowType, K, V>(\n     root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n ) -> (\n@@ -202,15 +202,15 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::ValMut<'a>, K, V, marker::LeafOrInternal>\n     }\n }\n \n-impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n+impl<K, V> NodeRef<marker::Dying, K, V, marker::LeafOrInternal> {\n     /// Splits a unique reference into a pair of leaf edges delimiting the full range of the tree.\n     /// The results are non-unique references allowing massively destructive mutation, so must be\n     /// used with the utmost care.\n     pub fn full_range(\n         self,\n     ) -> (\n-        Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n-        Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n+        Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge>,\n+        Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge>,\n     ) {\n         // We duplicate the root NodeRef here -- we will never access it in a way\n         // that overlaps references obtained from the root.\n@@ -219,7 +219,9 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     }\n }\n \n-impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+impl<BorrowType: marker::BorrowType, K, V>\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>\n+{\n     /// Given a leaf edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n     /// on the right side, which is either in the same leaf node or in an ancestor node.\n     /// If the leaf edge is the last one in the tree, returns [`Result::Err`] with the root node.\n@@ -263,7 +265,9 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::E\n     }\n }\n \n-impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge> {\n+impl<BorrowType: marker::BorrowType, K, V>\n+    Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>\n+{\n     /// Given an internal edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n     /// on the right side, which is either in the same internal node or in an ancestor node.\n     /// If the internal edge is the last one in the tree, returns [`Result::Err`] with the root node.\n@@ -297,8 +301,8 @@ macro_rules! def_next_kv_uncheched_dealloc {\n         /// - The node carrying the next KV returned must not have been deallocated by a\n         ///   previous call on any handle obtained for this tree.\n         unsafe fn $name <K, V>(\n-            leaf_edge: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n-        ) -> Handle<NodeRef<marker::Owned, K, V, marker::LeafOrInternal>, marker::KV> {\n+            leaf_edge: Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge>,\n+        ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n             let mut edge = leaf_edge.forget_node_type();\n             loop {\n                 edge = match edge.$adjacent_kv() {\n@@ -378,7 +382,7 @@ impl<'a, K, V> Handle<NodeRef<marker::ValMut<'a>, K, V, marker::Leaf>, marker::E\n     }\n }\n \n-impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n+impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     /// Moves the leaf edge handle to the next leaf edge and returns the key and value\n     /// in between, deallocating any node left behind while leaving the corresponding\n     /// edge in its parent node dangling.\n@@ -422,7 +426,7 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     }\n }\n \n-impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n     /// Returns the leftmost leaf edge in or underneath a node - in other words, the edge\n     /// you need first when navigating forward (or last when navigating backward).\n     #[inline]\n@@ -503,7 +507,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n     }\n }\n \n-impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {\n+impl<BorrowType: marker::BorrowType, K, V>\n+    Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV>\n+{\n     /// Returns the leaf edge closest to a KV for forward navigation.\n     pub fn next_leaf_edge(self) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n         match self.force() {"}, {"sha": "67c4f09306d1960ff13c09752b41261420c74896", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 49, "deletions": 14, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/417eefedfa4554d1417994a67186dd6a0a720aa8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/417eefedfa4554d1417994a67186dd6a0a720aa8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=417eefedfa4554d1417994a67186dd6a0a720aa8", "patch": "@@ -93,8 +93,8 @@ struct InternalNode<K, V> {\n     data: LeafNode<K, V>,\n \n     /// The pointers to the children of this node. `len + 1` of these are considered\n-    /// initialized and valid. Although during the process of `into_iter` or `drop`,\n-    /// some pointers are dangling while others still need to be traversed.\n+    /// initialized and valid, except that near the end, while the tree is held\n+    /// through borrow type `Dying`, some of these pointers are dangling.\n     edges: [MaybeUninit<BoxedNode<K, V>>; 2 * B],\n }\n \n@@ -119,7 +119,7 @@ impl<K, V> InternalNode<K, V> {\n /// is not a separate type and has no destructor.\n type BoxedNode<K, V> = NonNull<LeafNode<K, V>>;\n \n-/// An owned tree.\n+/// The root node of an owned tree.\n ///\n /// Note that this does not have a destructor, and must be cleaned up manually.\n pub type Root<K, V> = NodeRef<marker::Owned, K, V, marker::LeafOrInternal>;\n@@ -157,18 +157,23 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n }\n \n impl<K, V, Type> NodeRef<marker::Owned, K, V, Type> {\n-    /// Mutably borrows the owned node. Unlike `reborrow_mut`, this is safe,\n-    /// because the return value cannot be used to destroy the node itself,\n-    /// and there cannot be other references to the tree (except during the\n-    /// process of `into_iter` or `drop`, but that is horrific already).\n+    /// Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe\n+    /// because the return value cannot be used to destroy the root, and there\n+    /// cannot be other references to the tree.\n     pub fn borrow_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n-    /// Slightly mutably borrows the owned node.\n+    /// Slightly mutably borrows the owned root node.\n     pub fn borrow_valmut(&mut self) -> NodeRef<marker::ValMut<'_>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n+\n+    /// Irreversibly transistions to a reference that offers traversal,\n+    /// destructive methods and little else.\n+    pub fn into_dying(self) -> NodeRef<marker::Dying, K, V, Type> {\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n@@ -196,8 +201,13 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n \n         let top = self.node;\n \n-        let internal_node = NodeRef { height: self.height, node: top, _marker: PhantomData };\n-        *self = internal_node.first_edge().descend();\n+        // SAFETY: we asserted to be internal.\n+        let internal_self = unsafe { self.borrow_mut().cast_to_internal_unchecked() };\n+        // SAFETY: we borrowed `self` exclusively and its borrow type is exclusive.\n+        let internal_node = unsafe { &mut *NodeRef::as_internal_ptr(&internal_self) };\n+        // SAFETY: the first edge is always initialized.\n+        self.node = unsafe { internal_node.edges[0].assume_init_read() };\n+        self.height -= 1;\n         self.clear_parent_link();\n \n         unsafe {\n@@ -224,6 +234,9 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n ///      although insert methods allow a mutable pointer to a value to coexist.\n ///    - When this is `Owned`, the `NodeRef` acts roughly like `Box<Node>`,\n ///      but does not have a destructor, and must be cleaned up manually.\n+///    - When this is `Dying`, the `NodeRef` still acts roughly like `Box<Node>`,\n+///      but has methods to destroy the tree bit by bit, and ordinary methods,\n+///      while not marked as unsafe to call, can invoke UB if called incorrectly.\n ///   Since any `NodeRef` allows navigating through the tree, `BorrowType`\n ///   effectively applies to the entire tree, not just to the node itself.\n /// - `K` and `V`: These are the types of keys and values stored in the nodes.\n@@ -280,6 +293,7 @@ unsafe impl<'a, K: Sync + 'a, V: Sync + 'a, Type> Send for NodeRef<marker::Immut\n unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::Mut<'a>, K, V, Type> {}\n unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::ValMut<'a>, K, V, Type> {}\n unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Owned, K, V, Type> {}\n+unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Dying, K, V, Type> {}\n \n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n     /// Unpack a node reference that was packed as `NodeRef::parent`.\n@@ -343,7 +357,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n }\n \n-impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n+impl<BorrowType: marker::BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Finds the parent of the current node. Returns `Ok(handle)` if the current\n     /// node actually has a parent, where `handle` points to the edge of the parent\n     /// that points to the current node. Returns `Err(self)` if the current node has\n@@ -356,6 +370,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     pub fn ascend(\n         self,\n     ) -> Result<Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>, Self> {\n+        assert!(BorrowType::PERMITS_TRAVERSAL);\n         // We need to use raw pointers to nodes because, if BorrowType is marker::ValMut,\n         // there might be outstanding mutable references to values that we must not invalidate.\n         let leaf_ptr: *const _ = Self::as_leaf_ptr(&self);\n@@ -410,13 +425,13 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     }\n }\n \n-impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n+impl<K, V> NodeRef<marker::Dying, K, V, marker::LeafOrInternal> {\n     /// Similar to `ascend`, gets a reference to a node's parent node, but also\n     /// deallocates the current node in the process. This is unsafe because the\n     /// current node will still be accessible despite being deallocated.\n     pub unsafe fn deallocate_and_ascend(\n         self,\n-    ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n+    ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::Internal>, marker::Edge>> {\n         let height = self.height;\n         let node = self.node;\n         let ret = self.ascend().ok();\n@@ -951,14 +966,17 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     }\n }\n \n-impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge> {\n+impl<BorrowType: marker::BorrowType, K, V>\n+    Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>\n+{\n     /// Finds the node pointed to by this edge.\n     ///\n     /// The method name assumes you picture trees with the root node on top.\n     ///\n     /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n     /// both, upon success, do nothing.\n     pub fn descend(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+        assert!(BorrowType::PERMITS_TRAVERSAL);\n         // We need to use raw pointers to nodes because, if BorrowType is\n         // marker::ValMut, there might be outstanding mutable references to\n         // values that we must not invalidate. There's no worry accessing the\n@@ -1596,10 +1614,27 @@ pub mod marker {\n     pub enum LeafOrInternal {}\n \n     pub enum Owned {}\n+    pub enum Dying {}\n     pub struct Immut<'a>(PhantomData<&'a ()>);\n     pub struct Mut<'a>(PhantomData<&'a mut ()>);\n     pub struct ValMut<'a>(PhantomData<&'a mut ()>);\n \n+    pub trait BorrowType {\n+        // Whether node references of this borrow type allow traversing\n+        // to other nodes in the tree.\n+        const PERMITS_TRAVERSAL: bool = true;\n+    }\n+    impl BorrowType for Owned {\n+        // Traversal isn't needede, it happens using the result of `borrow_mut`.\n+        // By disabling traversal, and only creating new references to roots,\n+        // we know that every reference of the `Owned` type is to a root node.\n+        const PERMITS_TRAVERSAL: bool = false;\n+    }\n+    impl BorrowType for Dying {}\n+    impl<'a> BorrowType for Immut<'a> {}\n+    impl<'a> BorrowType for Mut<'a> {}\n+    impl<'a> BorrowType for ValMut<'a> {}\n+\n     pub enum KV {}\n     pub enum Edge {}\n }"}, {"sha": "acb7210ca7c8b411edf61035726168e4371886e0", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/417eefedfa4554d1417994a67186dd6a0a720aa8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/417eefedfa4554d1417994a67186dd6a0a720aa8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=417eefedfa4554d1417994a67186dd6a0a720aa8", "patch": "@@ -95,8 +95,8 @@ fn test_partial_cmp_eq() {\n     assert_eq!(top_edge_1.partial_cmp(&top_edge_2), None);\n \n     root1.pop_internal_level();\n-    unsafe { root1.deallocate_and_ascend() };\n-    unsafe { root2.deallocate_and_ascend() };\n+    unsafe { root1.into_dying().deallocate_and_ascend() };\n+    unsafe { root2.into_dying().deallocate_and_ascend() };\n }\n \n #[test]"}, {"sha": "f87444b7cd3e5de65bfe50704914a56688773583", "filename": "library/alloc/src/collections/btree/search.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/417eefedfa4554d1417994a67186dd6a0a720aa8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/417eefedfa4554d1417994a67186dd6a0a720aa8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs?ref=417eefedfa4554d1417994a67186dd6a0a720aa8", "patch": "@@ -15,7 +15,7 @@ pub enum IndexResult {\n     Edge(usize),\n }\n \n-impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n     /// Looks up a given key in a (sub)tree headed by the node, recursively.\n     /// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n     /// returns a `GoDown` with the handle of the leaf edge where the key belongs."}]}