{"sha": "219ddde26b151baf2046cf6d593ffc0dcd858f9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxOWRkZGUyNmIxNTFiYWYyMDQ2Y2Y2ZDU5M2ZmYzBkY2Q4NThmOWI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-28T08:10:10Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-05T06:33:09Z"}, "message": "resolve: extract `try_resolve_as_non_binding`.", "tree": {"sha": "baecccbe3af53e3e558629e4f44661ab03695e1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/baecccbe3af53e3e558629e4f44661ab03695e1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/219ddde26b151baf2046cf6d593ffc0dcd858f9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/219ddde26b151baf2046cf6d593ffc0dcd858f9b", "html_url": "https://github.com/rust-lang/rust/commit/219ddde26b151baf2046cf6d593ffc0dcd858f9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/219ddde26b151baf2046cf6d593ffc0dcd858f9b/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d537d4020f96588986a62d6f61d4779fd208f1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d537d4020f96588986a62d6f61d4779fd208f1a", "html_url": "https://github.com/rust-lang/rust/commit/6d537d4020f96588986a62d6f61d4779fd208f1a"}], "stats": {"total": 126, "additions": 69, "deletions": 57}, "files": [{"sha": "20a12a4ae938ea4c3525f5add6717a0c4e3aab06", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 68, "deletions": 57, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/219ddde26b151baf2046cf6d593ffc0dcd858f9b/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219ddde26b151baf2046cf6d593ffc0dcd858f9b/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=219ddde26b151baf2046cf6d593ffc0dcd858f9b", "patch": "@@ -9,7 +9,7 @@ use GenericParameters::*;\n use RibKind::*;\n \n use crate::{path_names_to_string, BindingError, CrateLint, LexicalScopeBinding};\n-use crate::{Module, ModuleOrUniformRoot, NameBinding, NameBindingKind, ParentScope, PathResult};\n+use crate::{Module, ModuleOrUniformRoot, NameBindingKind, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n use log::debug;\n@@ -1327,78 +1327,37 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         &mut self.ribs[ns].last_mut().unwrap().bindings\n     }\n \n-    fn resolve_pattern(&mut self,\n-                       pat: &Pat,\n-                       pat_src: PatternSource,\n-                       // Maps idents to the node ID for the\n-                       // outermost pattern that binds them.\n-                       bindings: &mut FxHashMap<Ident, NodeId>) {\n+    fn resolve_pattern(\n+        &mut self,\n+        pat: &Pat,\n+        pat_src: PatternSource,\n+        // Maps idents to the node ID for the outermost pattern that binds them.\n+        bindings: &mut FxHashMap<Ident, NodeId>,\n+    ) {\n         // Visit all direct subpatterns of this pattern.\n         let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n             debug!(\"resolve_pattern pat={:?} node={:?}\", pat, pat.node);\n             match pat.node {\n-                PatKind::Ident(bmode, ident, ref opt_pat) => {\n-                    // First try to resolve the identifier as some existing\n-                    // entity, then fall back to a fresh binding.\n-                    let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS,\n-                                                                      None, pat.span)\n-                                      .and_then(LexicalScopeBinding::item);\n-                    let res = binding.map(NameBinding::res).and_then(|res| {\n-                        let is_syntactic_ambiguity = opt_pat.is_none() &&\n-                            bmode == BindingMode::ByValue(Mutability::Immutable);\n-                        match res {\n-                            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n-                            Res::Def(DefKind::Const, _) if is_syntactic_ambiguity => {\n-                                // Disambiguate in favor of a unit struct/variant\n-                                // or constant pattern.\n-                                self.r.record_use(ident, ValueNS, binding.unwrap(), false);\n-                                Some(res)\n-                            }\n-                            Res::Def(DefKind::Ctor(..), _)\n-                            | Res::Def(DefKind::Const, _)\n-                            | Res::Def(DefKind::Static, _) => {\n-                                // This is unambiguously a fresh binding, either syntactically\n-                                // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n-                                // to something unusable as a pattern (e.g., constructor function),\n-                                // but we still conservatively report an error, see\n-                                // issues/33118#issuecomment-233962221 for one reason why.\n-                                self.r.report_error(\n-                                    ident.span,\n-                                    ResolutionError::BindingShadowsSomethingUnacceptable(\n-                                        pat_src.descr(), ident.name, binding.unwrap())\n-                                );\n-                                None\n-                            }\n-                            Res::Def(DefKind::Fn, _) | Res::Err => {\n-                                // These entities are explicitly allowed\n-                                // to be shadowed by fresh bindings.\n-                                None\n-                            }\n-                            res => {\n-                                span_bug!(ident.span, \"unexpected resolution for an \\\n-                                                       identifier in pattern: {:?}\", res);\n-                            }\n-                        }\n-                    }).unwrap_or_else(|| {\n-                        self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n-                    });\n-\n+                PatKind::Ident(bmode, ident, ref sub) => {\n+                    // First try to resolve the identifier as some existing entity,\n+                    // then fall back to a fresh binding.\n+                    let has_sub = sub.is_some();\n+                    let res = self.try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n+                        .unwrap_or_else(|| {\n+                            self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n+                        });\n                     self.r.record_partial_res(pat.id, PartialRes::new(res));\n                 }\n-\n                 PatKind::TupleStruct(ref path, ..) => {\n                     self.smart_resolve_path(pat.id, None, path, PathSource::TupleStruct);\n                 }\n-\n                 PatKind::Path(ref qself, ref path) => {\n                     self.smart_resolve_path(pat.id, qself.as_ref(), path, PathSource::Pat);\n                 }\n-\n                 PatKind::Struct(ref path, ..) => {\n                     self.smart_resolve_path(pat.id, None, path, PathSource::Struct);\n                 }\n-\n                 _ => {}\n             }\n             true\n@@ -1407,6 +1366,58 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         visit::walk_pat(self, pat);\n     }\n \n+    fn try_resolve_as_non_binding(\n+        &mut self,\n+        pat_src: PatternSource,\n+        pat: &Pat,\n+        bm: BindingMode,\n+        ident: Ident,\n+        has_sub: bool,\n+    ) -> Option<Res> {\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, pat.span)?.item()?;\n+        let res = binding.res();\n+\n+        // An immutable (no `mut`) by-value (no `ref`) binding pattern without\n+        // a sub pattern (no `@ $pat`) is syntactically ambiguous as it could\n+        // also be interpreted as a path to e.g. a constant, variant, etc.\n+        let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Immutable);\n+\n+        match res {\n+            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n+            Res::Def(DefKind::Const, _) if is_syntactic_ambiguity => {\n+                // Disambiguate in favor of a unit struct/variant or constant pattern.\n+                self.r.record_use(ident, ValueNS, binding, false);\n+                Some(res)\n+            }\n+            Res::Def(DefKind::Ctor(..), _)\n+            | Res::Def(DefKind::Const, _)\n+            | Res::Def(DefKind::Static, _) => {\n+                // This is unambiguously a fresh binding, either syntactically\n+                // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n+                // to something unusable as a pattern (e.g., constructor function),\n+                // but we still conservatively report an error, see\n+                // issues/33118#issuecomment-233962221 for one reason why.\n+                self.r.report_error(\n+                    ident.span,\n+                    ResolutionError::BindingShadowsSomethingUnacceptable(\n+                        pat_src.descr(),\n+                        ident.name,\n+                        binding,\n+                    ),\n+                );\n+                None\n+            }\n+            Res::Def(DefKind::Fn, _) | Res::Err => {\n+                // These entities are explicitly allowed to be shadowed by fresh bindings.\n+                None\n+            }\n+            res => {\n+                span_bug!(ident.span, \"unexpected resolution for an \\\n+                                        identifier in pattern: {:?}\", res);\n+            }\n+        }\n+    }\n+\n     // High-level and context dependent path resolution routine.\n     // Resolves the path and records the resolution into definition map.\n     // If resolution fails tries several techniques to find likely"}, {"sha": "9b92bb7698aaa506e5e6a805b4bd4a83c445904d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/219ddde26b151baf2046cf6d593ffc0dcd858f9b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219ddde26b151baf2046cf6d593ffc0dcd858f9b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=219ddde26b151baf2046cf6d593ffc0dcd858f9b", "patch": "@@ -9,6 +9,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(inner_deref)]\n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]\n #![feature(mem_take)]"}]}