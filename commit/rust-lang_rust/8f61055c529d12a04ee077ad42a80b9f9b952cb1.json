{"sha": "8f61055c529d12a04ee077ad42a80b9f9b952cb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNjEwNTVjNTI5ZDEyYTA0ZWUwNzdhZDQyYTgwYjlmOWI5NTJjYjE=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-05-16T23:31:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-16T23:31:49Z"}, "message": "Rollup merge of #41937 - nikomatsakis:issue-41936-variance-coerce-unsized-cycle, r=eddyb\n\nuse equality in the coerce-unsized check\n\nThis seems both to be a safe, conservative choice, and it sidesteps the cycle in #41849. Note that, before I converted variance into proper queries, we were using a hybrid of subtyping and equality, due to the presence of a flag that forced invariance if variance had not yet been computed. (Also, Coerce Unsized is unstable.)\n\nFixes #41936.\n\nr? @eddyb", "tree": {"sha": "7e4b054718986f98818cc55f2cd425ce9c0599d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e4b054718986f98818cc55f2cd425ce9c0599d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f61055c529d12a04ee077ad42a80b9f9b952cb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f61055c529d12a04ee077ad42a80b9f9b952cb1", "html_url": "https://github.com/rust-lang/rust/commit/8f61055c529d12a04ee077ad42a80b9f9b952cb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f61055c529d12a04ee077ad42a80b9f9b952cb1/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f68728fb372ff6b0b543f87ac6776f9d12a4b05", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f68728fb372ff6b0b543f87ac6776f9d12a4b05", "html_url": "https://github.com/rust-lang/rust/commit/0f68728fb372ff6b0b543f87ac6776f9d12a4b05"}, {"sha": "6db4beb3e833eb7d8daad30e2a9ecc27d54a0318", "url": "https://api.github.com/repos/rust-lang/rust/commits/6db4beb3e833eb7d8daad30e2a9ecc27d54a0318", "html_url": "https://github.com/rust-lang/rust/commit/6db4beb3e833eb7d8daad30e2a9ecc27d54a0318"}], "stats": {"total": 108, "additions": 106, "deletions": 2}, "files": [{"sha": "aabb6aff55140c4138efecfa741db1245b2e0e4b", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8f61055c529d12a04ee077ad42a80b9f9b952cb1/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f61055c529d12a04ee077ad42a80b9f9b952cb1/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=8f61055c529d12a04ee077ad42a80b9f9b952cb1", "patch": "@@ -39,10 +39,12 @@ use super::sub::Sub;\n use super::InferCtxt;\n use super::{MiscVariable, TypeTrace};\n \n+use hir::def_id::DefId;\n use ty::{IntType, UintType};\n use ty::{self, Ty, TyCtxt};\n use ty::error::TypeError;\n use ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use ty::subst::Substs;\n use traits::{Obligation, PredicateObligations};\n \n use syntax::ast;\n@@ -336,6 +338,23 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n         Ok(ty::Binder(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n \n+    fn relate_item_substs(&mut self,\n+                          item_def_id: DefId,\n+                          a_subst: &'tcx Substs<'tcx>,\n+                          b_subst: &'tcx Substs<'tcx>)\n+                          -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n+    {\n+        if self.ambient_variance == ty::Variance::Invariant {\n+            // Avoid fetching the variance if we are in an invariant\n+            // context; no need, and it can induce dependency cycles\n+            // (e.g. #41849).\n+            relate::relate_substs(self, None, a_subst, b_subst)\n+        } else {\n+            let opt_variances = self.tcx().variances_of(item_def_id);\n+            relate::relate_substs(self, Some(&opt_variances), a_subst, b_subst)\n+        }\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n                                              variance: ty::Variance,\n                                              a: &T,"}, {"sha": "556bd618c78cbb22e49b90b503f1daad2577d4a6", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8f61055c529d12a04ee077ad42a80b9f9b952cb1/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f61055c529d12a04ee077ad42a80b9f9b952cb1/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=8f61055c529d12a04ee077ad42a80b9f9b952cb1", "patch": "@@ -249,6 +249,45 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     return err_info;\n                 }\n \n+                // Here we are considering a case of converting\n+                // `S<P0...Pn>` to S<Q0...Qn>`. As an example, let's imagine a struct `Foo<T, U>`,\n+                // which acts like a pointer to `U`, but carries along some extra data of type `T`:\n+                //\n+                //     struct Foo<T, U> {\n+                //         extra: T,\n+                //         ptr: *mut U,\n+                //     }\n+                //\n+                // We might have an impl that allows (e.g.) `Foo<T, [i32; 3]>` to be unsized\n+                // to `Foo<T, [i32]>`. That impl would look like:\n+                //\n+                //   impl<T, U: Unsize<V>, V> CoerceUnsized<Foo<T, V>> for Foo<T, U> {}\n+                //\n+                // Here `U = [i32; 3]` and `V = [i32]`. At runtime,\n+                // when this coercion occurs, we would be changing the\n+                // field `ptr` from a thin pointer of type `*mut [i32;\n+                // 3]` to a fat pointer of type `*mut [i32]` (with\n+                // extra data `3`).  **The purpose of this check is to\n+                // make sure that we know how to do this conversion.**\n+                //\n+                // To check if this impl is legal, we would walk down\n+                // the fields of `Foo` and consider their types with\n+                // both substitutes. We are looking to find that\n+                // exactly one (non-phantom) field has changed its\n+                // type, which we will expect to be the pointer that\n+                // is becoming fat (we could probably generalize this\n+                // to mutiple thin pointers of the same type becoming\n+                // fat, but we don't). In this case:\n+                //\n+                // - `extra` has type `T` before and type `T` after\n+                // - `ptr` has type `*mut U` before and type `*mut V` after\n+                //\n+                // Since just one field changed, we would then check\n+                // that `*mut U: CoerceUnsized<*mut V>` is implemented\n+                // (in other words, that we know how to do this\n+                // conversion). This will work out because `U:\n+                // Unsize<V>`, and we have a builtin rule that `*mut\n+                // U` can be coerced to `*mut V` if `U: Unsize<V>`.\n                 let fields = &def_a.struct_variant().fields;\n                 let diff_fields = fields.iter()\n                     .enumerate()\n@@ -260,8 +299,16 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             return None;\n                         }\n \n-                        // Ignore fields that aren't significantly changed\n-                        if let Ok(ok) = infcx.sub_types(false, &cause, b, a) {\n+                        // Ignore fields that aren't changed; it may\n+                        // be that we could get away with subtyping or\n+                        // something more accepting, but we use\n+                        // equality because we want to be able to\n+                        // perform this check without computing\n+                        // variance where possible. (This is because\n+                        // we may have to evaluate constraint\n+                        // expressions in the course of execution.)\n+                        // See e.g. #41936.\n+                        if let Ok(ok) = infcx.eq_types(false, &cause, b, a) {\n                             if ok.obligations.is_empty() {\n                                 return None;\n                             }"}, {"sha": "bfbead87891784e123ba6ae6ad5dd5ff3f797e5d", "filename": "src/test/run-pass/issue-41936-variance-coerce-unsized-cycle.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8f61055c529d12a04ee077ad42a80b9f9b952cb1/src%2Ftest%2Frun-pass%2Fissue-41936-variance-coerce-unsized-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f61055c529d12a04ee077ad42a80b9f9b952cb1/src%2Ftest%2Frun-pass%2Fissue-41936-variance-coerce-unsized-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41936-variance-coerce-unsized-cycle.rs?ref=8f61055c529d12a04ee077ad42a80b9f9b952cb1", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #41936. The coerce-unsized trait check in\n+// coherence was using subtyping, which triggered variance\n+// computation, which failed because it required type info for fields\n+// that had not (yet) been computed.\n+\n+#![feature(unsize)]\n+#![feature(coerce_unsized)]\n+\n+use std::{marker,ops};\n+\n+// Change the array to a non-array, and error disappears\n+// Adding a new field to the end keeps the error\n+struct LogDataBuf([u8;8]);\n+\n+struct Aref<T: ?Sized>\n+{\n+    // Inner structure triggers the error, removing the inner removes the message.\n+    ptr: Box<ArefInner<T>>,\n+}\n+impl<T: ?Sized + marker::Unsize<U>, U: ?Sized> ops::CoerceUnsized<Aref<U>> for Aref<T> {}\n+\n+struct ArefInner<T: ?Sized>\n+{\n+    // Even with this field commented out, the error is raised.\n+    data: T,\n+}\n+\n+fn main(){}"}]}