{"sha": "382a963c17122470918e1491a733b81fb545330d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MmE5NjNjMTcxMjI0NzA5MThlMTQ5MWE3MzNiODFmYjU0NTMzMGQ=", "commit": {"author": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2020-05-06T08:48:52Z"}, "committer": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2020-05-06T08:48:52Z"}, "message": "filter upvars that cause trait obligation", "tree": {"sha": "51a0b1bfd88efe81632c4b33150d5a7ef787d8b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51a0b1bfd88efe81632c4b33150d5a7ef787d8b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/382a963c17122470918e1491a733b81fb545330d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/382a963c17122470918e1491a733b81fb545330d", "html_url": "https://github.com/rust-lang/rust/commit/382a963c17122470918e1491a733b81fb545330d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/382a963c17122470918e1491a733b81fb545330d/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4bdcfd3cfbfa025c5363149a14f2b36a584b54a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4bdcfd3cfbfa025c5363149a14f2b36a584b54a", "html_url": "https://github.com/rust-lang/rust/commit/d4bdcfd3cfbfa025c5363149a14f2b36a584b54a"}], "stats": {"total": 254, "additions": 134, "deletions": 120}, "files": [{"sha": "d2d9c303ea19dd1fd08b29a72931abb9b7c2ac21", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 134, "deletions": 120, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/382a963c17122470918e1491a733b81fb545330d/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382a963c17122470918e1491a733b81fb545330d/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=382a963c17122470918e1491a733b81fb545330d", "patch": "@@ -125,19 +125,15 @@ pub trait InferCtxtExt<'tcx> {\n     fn note_obligation_cause_for_async_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        target_span: Span,\n-        scope_span: &Option<Span>,\n-        yield_span: Option<Span>,\n-        expr: Option<hir::HirId>,\n-        snippet: String,\n+        interior: Option<(Span, Option<Span>, Option<Span>, Option<hir::HirId>, Option<Span>)>,\n+        upvar: Option<(Ty<'tcx>, Span)>,\n         inner_generator_body: Option<&hir::Body<'_>>,\n         outer_generator: Option<DefId>,\n         trait_ref: ty::TraitRef<'_>,\n         target_ty: Ty<'tcx>,\n         tables: &ty::TypeckTables<'_>,\n         obligation: &PredicateObligation<'tcx>,\n         next_code: Option<&ObligationCauseCode<'tcx>>,\n-        from_awaited_ty: Option<Span>,\n     );\n \n     fn note_obligation_cause_code<T>(\n@@ -1136,7 +1132,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 obligation.cause.span={:?}\",\n             obligation.predicate, obligation.cause.span\n         );\n-        let source_map = self.tcx.sess.source_map();\n         let hir = self.tcx.hir();\n \n         // Attempt to detect an async-await error by looking at the obligation causes, looking\n@@ -1173,6 +1168,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n         let mut generator = None;\n         let mut outer_generator = None;\n+        let mut generator_substs = None;\n         let mut next_code = Some(&obligation.cause.code);\n         while let Some(code) = next_code {\n             debug!(\"maybe_note_obligation_cause_for_async_await: code={:?}\", code);\n@@ -1188,8 +1184,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     );\n \n                     match ty.kind {\n-                        ty::Generator(did, ..) => {\n+                        ty::Generator(did, substs, ..) => {\n                             generator = generator.or(Some(did));\n+                            generator_substs = generator_substs.or(Some(substs));\n                             outer_generator = Some(did);\n                         }\n                         ty::GeneratorWitness(..) => {}\n@@ -1212,12 +1209,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 target_ty={:?}\",\n             generator, trait_ref, target_ty\n         );\n-        let (generator_did, trait_ref, target_ty) = match (generator, trait_ref, target_ty) {\n-            (Some(generator_did), Some(trait_ref), Some(target_ty)) => {\n-                (generator_did, trait_ref, target_ty)\n-            }\n-            _ => return false,\n-        };\n+        let (generator_did, _generator_substs, trait_ref, target_ty) =\n+            match (generator, generator_substs, trait_ref, target_ty) {\n+                (Some(generator_did), Some(generator_substs), Some(trait_ref), Some(target_ty)) => {\n+                    (generator_did, generator_substs, trait_ref, target_ty)\n+                }\n+                _ => return false,\n+            };\n \n         let span = self.tcx.def_span(generator_did);\n \n@@ -1285,7 +1283,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             );\n             eq\n         };\n-        let target_span = tables\n+        let interior = tables\n             .generator_interior_types\n             .iter()\n             .find(|ty::GeneratorInteriorTypeCause { ty, .. }| ty_matches(ty))\n@@ -1306,39 +1304,36 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .map(|expr| expr.span);\n                 let ty::GeneratorInteriorTypeCause { span, scope_span, yield_span, expr, .. } =\n                     cause;\n-                (\n-                    span,\n-                    source_map.span_to_snippet(*span),\n-                    scope_span,\n-                    yield_span,\n-                    expr,\n-                    from_awaited_ty,\n-                )\n+                (*span, *scope_span, *yield_span, *expr, from_awaited_ty)\n             });\n \n+        let upvar = if let Some(upvars) = self.tcx.upvars(generator_did) {\n+            upvars.iter().find_map(|(upvar_id, upvar)| {\n+                let upvar_ty = tables.node_type(*upvar_id);\n+                let upvar_ty = self.resolve_vars_if_possible(&upvar_ty);\n+                if ty_matches(&upvar_ty) { Some((upvar_ty, upvar.span)) } else { None }\n+            })\n+        } else {\n+            None\n+        };\n+\n         debug!(\n-            \"maybe_note_obligation_cause_for_async_await: target_ty={:?} \\\n-                generator_interior_types={:?} target_span={:?}\",\n-            target_ty, tables.generator_interior_types, target_span\n+            \"maybe_note_obligation_cause_for_async_await: interior={:?} \\\n+                generator_interior_types={:?} upvar: {:?}\",\n+            interior, tables.generator_interior_types, upvar\n         );\n-        if let Some((target_span, Ok(snippet), scope_span, yield_span, expr, from_awaited_ty)) =\n-            target_span\n-        {\n+        if interior.is_some() || upvar.is_some() {\n             self.note_obligation_cause_for_async_await(\n                 err,\n-                *target_span,\n-                scope_span,\n-                *yield_span,\n-                *expr,\n-                snippet,\n+                interior,\n+                upvar,\n                 generator_body,\n                 outer_generator,\n                 trait_ref,\n                 target_ty,\n                 tables,\n                 obligation,\n                 next_code,\n-                from_awaited_ty,\n             );\n             true\n         } else {\n@@ -1351,19 +1346,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn note_obligation_cause_for_async_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        target_span: Span,\n-        scope_span: &Option<Span>,\n-        yield_span: Option<Span>,\n-        expr: Option<hir::HirId>,\n-        snippet: String,\n+        interior: Option<(Span, Option<Span>, Option<Span>, Option<hir::HirId>, Option<Span>)>,\n+        upvar: Option<(Ty<'tcx>, Span)>,\n         inner_generator_body: Option<&hir::Body<'_>>,\n         outer_generator: Option<DefId>,\n         trait_ref: ty::TraitRef<'_>,\n         target_ty: Ty<'tcx>,\n         tables: &ty::TypeckTables<'_>,\n         obligation: &PredicateObligation<'tcx>,\n         next_code: Option<&ObligationCauseCode<'tcx>>,\n-        from_awaited_ty: Option<Span>,\n     ) {\n         let source_map = self.tcx.sess.source_map();\n \n@@ -1424,99 +1415,122 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             format!(\"does not implement `{}`\", trait_ref.print_only_trait_path())\n         };\n \n-        if let Some(await_span) = from_awaited_ty {\n-            // The type causing this obligation is one being awaited at await_span.\n-            let mut span = MultiSpan::from_span(await_span);\n-\n-            span.push_span_label(\n-                await_span,\n-                format!(\"await occurs here on type `{}`, which {}\", target_ty, trait_explanation),\n-            );\n+        if let Some((target_span, scope_span, yield_span, expr, from_awaited_ty)) = interior {\n+            if let Some(await_span) = from_awaited_ty {\n+                // The type causing this obligation is one being awaited at await_span.\n+                let mut span = MultiSpan::from_span(await_span);\n \n-            err.span_note(\n-                span,\n-                &format!(\n-                    \"future {not_trait} as it awaits another future which {not_trait}\",\n-                    not_trait = trait_explanation\n-                ),\n-            );\n-        } else {\n-            // Look at the last interior type to get a span for the `.await`.\n-            debug!(\n-                \"note_obligation_cause_for_async_await generator_interior_types: {:#?}\",\n-                tables.generator_interior_types\n-            );\n-\n-            if let Some(yield_span) = yield_span {\n-                let mut span = MultiSpan::from_span(yield_span);\n                 span.push_span_label(\n-                    yield_span,\n-                    format!(\"{} occurs here, with `{}` maybe used later\", await_or_yield, snippet),\n-                );\n-\n-                span.push_span_label(\n-                    target_span,\n-                    format!(\"has type `{}` which {}\", target_ty, trait_explanation),\n+                    await_span,\n+                    format!(\n+                        \"await occurs here on type `{}`, which {}\",\n+                        target_ty, trait_explanation\n+                    ),\n                 );\n \n-                // If available, use the scope span to annotate the drop location.\n-                if let Some(scope_span) = scope_span {\n-                    span.push_span_label(\n-                        source_map.end_point(*scope_span),\n-                        format!(\"`{}` is later dropped here\", snippet),\n-                    );\n-                }\n-\n                 err.span_note(\n                     span,\n                     &format!(\n-                        \"{} {} as this value is used across {}\",\n-                        future_or_generator, trait_explanation, an_await_or_yield\n+                        \"future {not_trait} as it awaits another future which {not_trait}\",\n+                        not_trait = trait_explanation\n                     ),\n                 );\n-            }\n-        }\n+            } else {\n+                // Look at the last interior type to get a span for the `.await`.\n+                debug!(\n+                    \"note_obligation_cause_for_async_await generator_interior_types: {:#?}\",\n+                    tables.generator_interior_types\n+                );\n \n-        if let Some(expr_id) = expr {\n-            let expr = hir.expect_expr(expr_id);\n-            debug!(\"target_ty evaluated from {:?}\", expr);\n-\n-            let parent = hir.get_parent_node(expr_id);\n-            if let Some(hir::Node::Expr(e)) = hir.find(parent) {\n-                let parent_span = hir.span(parent);\n-                let parent_did = parent.owner.to_def_id();\n-                // ```rust\n-                // impl T {\n-                //     fn foo(&self) -> i32 {}\n-                // }\n-                // T.foo();\n-                // ^^^^^^^ a temporary `&T` created inside this method call due to `&self`\n-                // ```\n-                //\n-                let is_region_borrow =\n-                    tables.expr_adjustments(expr).iter().any(|adj| adj.is_region_borrow());\n-\n-                // ```rust\n-                // struct Foo(*const u8);\n-                // bar(Foo(std::ptr::null())).await;\n-                //     ^^^^^^^^^^^^^^^^^^^^^ raw-ptr `*T` created inside this struct ctor.\n-                // ```\n-                debug!(\"parent_def_kind: {:?}\", self.tcx.def_kind(parent_did));\n-                let is_raw_borrow_inside_fn_like_call = match self.tcx.def_kind(parent_did) {\n-                    DefKind::Fn | DefKind::Ctor(..) => target_ty.is_unsafe_ptr(),\n-                    _ => false,\n-                };\n+                if let Some(yield_span) = yield_span {\n+                    let mut span = MultiSpan::from_span(yield_span);\n+                    if let Ok(snippet) = source_map.span_to_snippet(target_span) {\n+                        span.push_span_label(\n+                            yield_span,\n+                            format!(\n+                                \"{} occurs here, with `{}` maybe used later\",\n+                                await_or_yield, snippet\n+                            ),\n+                        );\n+                        // If available, use the scope span to annotate the drop location.\n+                        if let Some(scope_span) = scope_span {\n+                            span.push_span_label(\n+                                source_map.end_point(scope_span),\n+                                format!(\"`{}` is later dropped here\", snippet),\n+                            );\n+                        }\n+                    }\n+                    span.push_span_label(\n+                        target_span,\n+                        format!(\"has type `{}` which {}\", target_ty, trait_explanation),\n+                    );\n \n-                if (tables.is_method_call(e) && is_region_borrow)\n-                    || is_raw_borrow_inside_fn_like_call\n-                {\n-                    err.span_help(\n-                        parent_span,\n-                        \"consider moving this into a `let` \\\n-                        binding to create a shorter lived borrow\",\n+                    err.span_note(\n+                        span,\n+                        &format!(\n+                            \"{} {} as this value is used across {}\",\n+                            future_or_generator, trait_explanation, an_await_or_yield\n+                        ),\n                     );\n                 }\n             }\n+            if let Some((_, upvar_span)) = upvar {\n+                let mut span = MultiSpan::from_span(upvar_span);\n+                span.push_span_label(\n+                    upvar_span,\n+                    format!(\"has type `{}` which {}\", target_ty, trait_explanation),\n+                );\n+            }\n+            if let Some(expr_id) = expr {\n+                let expr = hir.expect_expr(expr_id);\n+                debug!(\"target_ty evaluated from {:?}\", expr);\n+\n+                let parent = hir.get_parent_node(expr_id);\n+                if let Some(hir::Node::Expr(e)) = hir.find(parent) {\n+                    let parent_span = hir.span(parent);\n+                    let parent_did = parent.owner.to_def_id();\n+                    // ```rust\n+                    // impl T {\n+                    //     fn foo(&self) -> i32 {}\n+                    // }\n+                    // T.foo();\n+                    // ^^^^^^^ a temporary `&T` created inside this method call due to `&self`\n+                    // ```\n+                    //\n+                    let is_region_borrow =\n+                        tables.expr_adjustments(expr).iter().any(|adj| adj.is_region_borrow());\n+\n+                    // ```rust\n+                    // struct Foo(*const u8);\n+                    // bar(Foo(std::ptr::null())).await;\n+                    //     ^^^^^^^^^^^^^^^^^^^^^ raw-ptr `*T` created inside this struct ctor.\n+                    // ```\n+                    debug!(\"parent_def_kind: {:?}\", self.tcx.def_kind(parent_did));\n+                    let is_raw_borrow_inside_fn_like_call = match self.tcx.def_kind(parent_did) {\n+                        DefKind::Fn | DefKind::Ctor(..) => target_ty.is_unsafe_ptr(),\n+                        _ => false,\n+                    };\n+\n+                    if (tables.is_method_call(e) && is_region_borrow)\n+                        || is_raw_borrow_inside_fn_like_call\n+                    {\n+                        err.span_help(\n+                            parent_span,\n+                            \"consider moving this into a `let` \\\n+                        binding to create a shorter lived borrow\",\n+                        );\n+                    }\n+                }\n+            }\n+        } else {\n+            if let Some((_, upvar_span)) = upvar {\n+                let mut span = MultiSpan::from_span(upvar_span);\n+                span.push_span_label(\n+                    upvar_span,\n+                    format!(\"has type `{}` which {}\", target_ty, trait_explanation),\n+                );\n+                err.span_note(span, &format!(\"captured outer value {}\", trait_explanation));\n+            }\n         }\n \n         // Add a note for the item obligation that remains - normally a note pointing to the"}]}