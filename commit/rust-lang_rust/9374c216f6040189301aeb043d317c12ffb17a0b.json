{"sha": "9374c216f6040189301aeb043d317c12ffb17a0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNzRjMjE2ZjYwNDAxODkzMDFhZWIwNDNkMzE3YzEyZmZiMTdhMGI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-03-23T02:26:51Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-03-24T21:06:13Z"}, "message": "Minor refactoring in coercion.rs", "tree": {"sha": "443d83ee955ff7a9ebf840c59a9306eeaf5ab900", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/443d83ee955ff7a9ebf840c59a9306eeaf5ab900"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9374c216f6040189301aeb043d317c12ffb17a0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9374c216f6040189301aeb043d317c12ffb17a0b", "html_url": "https://github.com/rust-lang/rust/commit/9374c216f6040189301aeb043d317c12ffb17a0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9374c216f6040189301aeb043d317c12ffb17a0b/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95602a759d9190cad92279aa5929d30166f2255c", "url": "https://api.github.com/repos/rust-lang/rust/commits/95602a759d9190cad92279aa5929d30166f2255c", "html_url": "https://github.com/rust-lang/rust/commit/95602a759d9190cad92279aa5929d30166f2255c"}], "stats": {"total": 310, "additions": 163, "deletions": 147}, "files": [{"sha": "8ad11e19b347b93503fb1f2f6aa46ae8904095ba", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 163, "deletions": 147, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/9374c216f6040189301aeb043d317c12ffb17a0b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9374c216f6040189301aeb043d317c12ffb17a0b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=9374c216f6040189301aeb043d317c12ffb17a0b", "patch": "@@ -258,70 +258,64 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         match (&a.sty, &b.sty) {\n             (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_rptr(_, mt_b)) => {\n-                self.unpack_actual_value(t_a, |a| {\n-                    match self.unsize_ty(t_a, a, mt_b.ty) {\n-                        Some((ty, kind)) => {\n-                            if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n-                                return Err(ty::terr_mutability);\n-                            }\n-\n-                            let coercion = Coercion(self.trace.clone());\n-                            let r_borrow = self.fcx.infcx().next_region_var(coercion);\n-                            let ty = ty::mk_rptr(self.tcx(),\n-                                                 self.tcx().mk_region(r_borrow),\n-                                                 ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                            try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n-                            debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoPtr(AutoUnsize({:?})))\", kind);\n-                            Ok(Some(AdjustDerefRef(AutoDerefRef {\n-                                autoderefs: 1,\n-                                autoref: Some(ty::AutoPtr(r_borrow, mt_b.mutbl,\n-                                                          Some(box AutoUnsize(kind))))\n-                            })))\n+                match self.unsize_ty(t_a, mt_b.ty) {\n+                    Some((ty, kind)) => {\n+                        if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n+                            return Err(ty::terr_mutability);\n                         }\n-                        _ => Err(ty::terr_mismatch)\n+\n+                        let coercion = Coercion(self.trace.clone());\n+                        let r_borrow = self.fcx.infcx().next_region_var(coercion);\n+                        let ty = ty::mk_rptr(self.tcx(),\n+                                             self.tcx().mk_region(r_borrow),\n+                                             ty::mt{ty: ty, mutbl: mt_b.mutbl});\n+                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        debug!(\"Success, coerced with AutoDerefRef(1, \\\n+                                AutoPtr(AutoUnsize({:?})))\", kind);\n+                        Ok(Some(AdjustDerefRef(AutoDerefRef {\n+                            autoderefs: 1,\n+                            autoref: Some(ty::AutoPtr(r_borrow, mt_b.mutbl,\n+                                                      Some(box AutoUnsize(kind))))\n+                        })))\n                     }\n-                })\n+                    _ => Err(ty::terr_mismatch)\n+                }\n             }\n             (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_ptr(mt_b)) => {\n-                self.unpack_actual_value(t_a, |a| {\n-                    match self.unsize_ty(t_a, a, mt_b.ty) {\n-                        Some((ty, kind)) => {\n-                            if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n-                                return Err(ty::terr_mutability);\n-                            }\n-\n-                            let ty = ty::mk_ptr(self.tcx(),\n-                                                 ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                            try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n-                            debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoPtr(AutoUnsize({:?})))\", kind);\n-                            Ok(Some(AdjustDerefRef(AutoDerefRef {\n-                                autoderefs: 1,\n-                                autoref: Some(ty::AutoUnsafe(mt_b.mutbl,\n-                                                             Some(box AutoUnsize(kind))))\n-                            })))\n+                match self.unsize_ty(t_a, mt_b.ty) {\n+                    Some((ty, kind)) => {\n+                        if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n+                            return Err(ty::terr_mutability);\n                         }\n-                        _ => Err(ty::terr_mismatch)\n+\n+                        let ty = ty::mk_ptr(self.tcx(),\n+                                             ty::mt{ty: ty, mutbl: mt_b.mutbl});\n+                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        debug!(\"Success, coerced with AutoDerefRef(1, \\\n+                                AutoPtr(AutoUnsize({:?})))\", kind);\n+                        Ok(Some(AdjustDerefRef(AutoDerefRef {\n+                            autoderefs: 1,\n+                            autoref: Some(ty::AutoUnsafe(mt_b.mutbl,\n+                                                         Some(box AutoUnsize(kind))))\n+                        })))\n                     }\n-                })\n+                    _ => Err(ty::terr_mismatch)\n+                }\n             }\n             (&ty::ty_uniq(t_a), &ty::ty_uniq(t_b)) => {\n-                self.unpack_actual_value(t_a, |a| {\n-                    match self.unsize_ty(t_a, a, t_b) {\n-                        Some((ty, kind)) => {\n-                            let ty = ty::mk_uniq(self.tcx(), ty);\n-                            try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n-                            debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoUnsizeUniq({:?}))\", kind);\n-                            Ok(Some(AdjustDerefRef(AutoDerefRef {\n-                                autoderefs: 1,\n-                                autoref: Some(ty::AutoUnsizeUniq(kind))\n-                            })))\n-                        }\n-                        _ => Err(ty::terr_mismatch)\n+                match self.unsize_ty(t_a, t_b) {\n+                    Some((ty, kind)) => {\n+                        let ty = ty::mk_uniq(self.tcx(), ty);\n+                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        debug!(\"Success, coerced with AutoDerefRef(1, \\\n+                                AutoUnsizeUniq({:?}))\", kind);\n+                        Ok(Some(AdjustDerefRef(AutoDerefRef {\n+                            autoderefs: 1,\n+                            autoref: Some(ty::AutoUnsizeUniq(kind))\n+                        })))\n                     }\n-                })\n+                    _ => Err(ty::terr_mismatch)\n+                }\n             }\n             _ => Err(ty::terr_mismatch)\n         }\n@@ -332,112 +326,134 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // E.g., `[T, ..n]` -> `([T], UnsizeLength(n))`\n     fn unsize_ty(&self,\n                  ty_a: Ty<'tcx>,\n-                 a: Ty<'tcx>, // TODO unwrap ty_a here, not in the caller\n                  ty_b: Ty<'tcx>)\n                  -> Option<(Ty<'tcx>, ty::UnsizeKind<'tcx>)>\n     {\n         let tcx = self.tcx();\n \n-        self.unpack_actual_value(ty_b, |b| {\n-            debug!(\"unsize_ty(a={}, b={})\", a.repr(self.tcx()), b.repr(self.tcx()));\n-            match (&a.sty, &b.sty) {\n-                (&ty::ty_vec(t_a, Some(len)), &ty::ty_vec(_, None)) => {\n-                    let ty = ty::mk_vec(tcx, t_a, None);\n-                    Some((ty, ty::UnsizeLength(len)))\n-                }\n-                (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n-                    // Upcasts permit two things:\n-                    //\n-                    // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n-                    // 2. Tightening the region bound, e.g. `Foo+'a` to `Foo+'b` if `'a : 'b`\n-                    //\n-                    // Note that neither of these changes requires any\n-                    // change at runtime.  Eventually this will be\n-                    // generalized.\n-                    //\n-                    // We always upcast when we can because of reason\n-                    // #2 (region bounds).\n-                    if data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds) {\n-                        // construct a type `a1` which is a version of\n-                        // `a` using the upcast bounds from `b`\n-                        let bounds_a1 = ty::ExistentialBounds {\n-                            // From type b\n-                            region_bound: data_b.bounds.region_bound,\n-                            builtin_bounds: data_b.bounds.builtin_bounds,\n-\n-                            // From type a\n-                            projection_bounds: data_a.bounds.projection_bounds.clone(),\n-                        };\n-                        let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n-\n-                        // relate `a1` to `b`\n-                        let result = self.fcx.infcx().try(|_| {\n-                            // it's ok to upcast from Foo+'a to Foo+'b so long as 'a : 'b\n-                            try!(self.outlives(data_a.bounds.region_bound,\n-                                               data_b.bounds.region_bound));\n-                            self.subtype(ty_a1, ty_b)\n-                        });\n-\n-                        // if that was successful, we have a coercion\n-                        match result {\n-                            Ok(_) => Some((ty_b, ty::UnsizeUpcast(ty_b))),\n-                            Err(_) => None,\n-                        }\n-                    } else {\n-                        None\n+        self.unpack_actual_value(ty_a, |a| {\n+            self.unpack_actual_value(ty_b, |b| {\n+                debug!(\"unsize_ty(a={}, b={})\", a.repr(self.tcx()), b.repr(self.tcx()));\n+                match (&a.sty, &b.sty) {\n+                    (&ty::ty_vec(t_a, Some(len)), &ty::ty_vec(_, None)) => {\n+                        let ty = ty::mk_vec(tcx, t_a, None);\n+                        Some((ty, ty::UnsizeLength(len)))\n                     }\n-                }\n-                (_, &ty::ty_trait(ref data)) => {\n-                    Some((ty_b, ty::UnsizeVtable(ty::TyTrait { principal: data.principal.clone(),\n-                                                               bounds: data.bounds.clone() },\n-                                                 ty_a)))\n-                }\n-                (&ty::ty_struct(did_a, substs_a), &ty::ty_struct(did_b, substs_b))\n-                  if did_a == did_b => {\n-                    debug!(\"unsizing a struct\");\n-                    // Try unsizing each type param in turn to see if we end up with ty_b.\n-                    let ty_substs_a = substs_a.types.get_slice(subst::TypeSpace);\n-                    let ty_substs_b = substs_b.types.get_slice(subst::TypeSpace);\n-                    assert!(ty_substs_a.len() == ty_substs_b.len());\n-\n-                    let mut result = None;\n-                    let tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n-                    for (i, (tp_a, tp_b)) in tps {\n-                        if self.fcx.infcx().try(|_| self.subtype(*tp_a, *tp_b)).is_ok() {\n-                            continue;\n+                    (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n+                        // Upcasts permit two things:\n+                        //\n+                        // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n+                        // 2. Tightening the region bound, e.g. `Foo+'a` to `Foo+'b` if `'a : 'b`\n+                        //\n+                        // Note that neither of these changes requires any\n+                        // change at runtime.  Eventually this will be\n+                        // generalized.\n+                        //\n+                        // We always upcast when we can because of reason\n+                        // #2 (region bounds).\n+                        if data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds) {\n+                            // construct a type `a1` which is a version of\n+                            // `a` using the upcast bounds from `b`\n+                            let bounds_a1 = ty::ExistentialBounds {\n+                                // From type b\n+                                region_bound: data_b.bounds.region_bound,\n+                                builtin_bounds: data_b.bounds.builtin_bounds,\n+\n+                                // From type a\n+                                projection_bounds: data_a.bounds.projection_bounds.clone(),\n+                            };\n+                            let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n+\n+                            // relate `a1` to `b`\n+                            let result = self.fcx.infcx().try(|_| {\n+                                // it's ok to upcast from Foo+'a to Foo+'b so long as 'a : 'b\n+                                try!(self.outlives(data_a.bounds.region_bound,\n+                                                   data_b.bounds.region_bound));\n+                                self.subtype(ty_a1, ty_b)\n+                            });\n+\n+                            // if that was successful, we have a coercion\n+                            match result {\n+                                Ok(_) => Some((ty_b, ty::UnsizeUpcast(ty_b))),\n+                                Err(_) => None,\n+                            }\n+                        } else {\n+                            None\n                         }\n-                        match\n-                            self.unpack_actual_value(\n-                                *tp_a,\n-                                |tp| self.unsize_ty(*tp_a, tp, *tp_b))\n+                    }\n+                    (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n+                        // For now, we only support upcasts from\n+                        // `Foo+Send` to `Foo` (really, any time there are\n+                        // fewer builtin bounds then before). These are\n+                        // convenient because they don't require any sort\n+                        // of change to the vtable at runtime.\n+                        if data_a.bounds.builtin_bounds != data_b.bounds.builtin_bounds &&\n+                            data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds)\n                         {\n-                            Some((new_tp, k)) => {\n-                                // Check that the whole types match.\n-                                let mut new_substs = substs_a.clone();\n-                                new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n-                                let ty = ty::mk_struct(tcx, did_a, tcx.mk_substs(new_substs));\n-                                if self.fcx.infcx().try(|_| self.subtype(ty, ty_b)).is_err() {\n-                                    debug!(\"Unsized type parameter '{}', but still \\\n-                                            could not match types {} and {}\",\n-                                           ppaux::ty_to_string(tcx, *tp_a),\n-                                           ppaux::ty_to_string(tcx, ty),\n-                                           ppaux::ty_to_string(tcx, ty_b));\n-                                    // We can only unsize a single type parameter, so\n-                                    // if we unsize one and it doesn't give us the\n-                                    // type we want, then we won't succeed later.\n+                            let bounds_a1 = ty::ExistentialBounds {\n+                                region_bound: data_a.bounds.region_bound,\n+                                builtin_bounds: data_b.bounds.builtin_bounds,\n+                                projection_bounds: data_a.bounds.projection_bounds.clone(),\n+                            };\n+                            let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n+                            match self.fcx.infcx().try(|_| self.subtype(ty_a1, ty_b)) {\n+                                Ok(_) => Some((ty_b, ty::UnsizeUpcast(ty_b))),\n+                                Err(_) => None,\n+                            }\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    (_, &ty::ty_trait(ref data)) => {\n+                        Some((ty_b, ty::UnsizeVtable(ty::TyTrait {\n+                                                         principal: data.principal.clone(),\n+                                                         bounds: data.bounds.clone()\n+                                                     },\n+                                                     ty_a)))\n+                    }\n+                    (&ty::ty_struct(did_a, substs_a), &ty::ty_struct(did_b, substs_b))\n+                      if did_a == did_b => {\n+                        debug!(\"unsizing a struct\");\n+                        // Try unsizing each type param in turn to see if we end up with ty_b.\n+                        let ty_substs_a = substs_a.types.get_slice(subst::TypeSpace);\n+                        let ty_substs_b = substs_b.types.get_slice(subst::TypeSpace);\n+                        assert!(ty_substs_a.len() == ty_substs_b.len());\n+\n+                        let mut result = None;\n+                        let tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n+                        for (i, (tp_a, tp_b)) in tps {\n+                            if self.fcx.infcx().try(|_| self.subtype(*tp_a, *tp_b)).is_ok() {\n+                                continue;\n+                            }\n+                            match self.unsize_ty(*tp_a, *tp_b) {\n+                                Some((new_tp, k)) => {\n+                                    // Check that the whole types match.\n+                                    let mut new_substs = substs_a.clone();\n+                                    new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n+                                    let ty = ty::mk_struct(tcx, did_a, tcx.mk_substs(new_substs));\n+                                    if self.fcx.infcx().try(|_| self.subtype(ty, ty_b)).is_err() {\n+                                        debug!(\"Unsized type parameter '{}', but still \\\n+                                                could not match types {} and {}\",\n+                                               ppaux::ty_to_string(tcx, *tp_a),\n+                                               ppaux::ty_to_string(tcx, ty),\n+                                               ppaux::ty_to_string(tcx, ty_b));\n+                                        // We can only unsize a single type parameter, so\n+                                        // if we unsize one and it doesn't give us the\n+                                        // type we want, then we won't succeed later.\n+                                        break;\n+                                    }\n+\n+                                    result = Some((ty, ty::UnsizeStruct(box k, i)));\n                                     break;\n                                 }\n-\n-                                result = Some((ty, ty::UnsizeStruct(box k, i)));\n-                                break;\n+                                None => {}\n                             }\n-                            None => {}\n                         }\n+                        result\n                     }\n-                    result\n+                    _ => None\n                 }\n-                _ => None\n-            }\n+            })\n         })\n     }\n "}]}