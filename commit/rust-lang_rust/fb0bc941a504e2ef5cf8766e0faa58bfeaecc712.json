{"sha": "fb0bc941a504e2ef5cf8766e0faa58bfeaecc712", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMGJjOTQxYTUwNGUyZWY1Y2Y4NzY2ZTBmYWE1OGJmZWFlY2M3MTI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-09T12:33:03Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-09T12:33:03Z"}, "message": "Cleanup diagnostics tests", "tree": {"sha": "bb92790ad91df84287877c6179ef8739901d0542", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb92790ad91df84287877c6179ef8739901d0542"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb0bc941a504e2ef5cf8766e0faa58bfeaecc712", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb0bc941a504e2ef5cf8766e0faa58bfeaecc712", "html_url": "https://github.com/rust-lang/rust/commit/fb0bc941a504e2ef5cf8766e0faa58bfeaecc712", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb0bc941a504e2ef5cf8766e0faa58bfeaecc712/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea68a1d0c96cfaa3ec152f3f2f3b938a436df1dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea68a1d0c96cfaa3ec152f3f2f3b938a436df1dd", "html_url": "https://github.com/rust-lang/rust/commit/ea68a1d0c96cfaa3ec152f3f2f3b938a436df1dd"}], "stats": {"total": 368, "additions": 131, "deletions": 237}, "files": [{"sha": "00f6bb18649da15a1193725427613f6adcecbbae", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 123, "deletions": 225, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/fb0bc941a504e2ef5cf8766e0faa58bfeaecc712/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb0bc941a504e2ef5cf8766e0faa58bfeaecc712/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=fb0bc941a504e2ef5cf8766e0faa58bfeaecc712", "patch": "@@ -281,43 +281,11 @@ fn check_struct_shorthand_initialization(\n \n #[cfg(test)]\n mod tests {\n-    use insta::assert_debug_snapshot;\n-    use ra_syntax::SourceFile;\n     use stdx::trim_indent;\n     use test_utils::assert_eq_text;\n \n-    use crate::mock_analysis::{analysis_and_position, single_file};\n-\n-    use super::*;\n-\n-    type DiagnosticChecker = fn(&mut Vec<Diagnostic>, FileId, &SyntaxNode) -> Option<()>;\n-\n-    fn check_not_applicable(code: &str, func: DiagnosticChecker) {\n-        let parse = SourceFile::parse(code);\n-        let mut diagnostics = Vec::new();\n-        for node in parse.tree().syntax().descendants() {\n-            func(&mut diagnostics, FileId(0), &node);\n-        }\n-        assert!(diagnostics.is_empty());\n-    }\n-\n-    fn check_apply(before: &str, after: &str, func: DiagnosticChecker) {\n-        let parse = SourceFile::parse(before);\n-        let mut diagnostics = Vec::new();\n-        for node in parse.tree().syntax().descendants() {\n-            func(&mut diagnostics, FileId(0), &node);\n-        }\n-        let diagnostic =\n-            diagnostics.pop().unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));\n-        let mut fix = diagnostic.fix.unwrap();\n-        let edit = fix.source_change.source_file_edits.pop().unwrap().edit;\n-        let actual = {\n-            let mut actual = before.to_string();\n-            edit.apply(&mut actual);\n-            actual\n-        };\n-        assert_eq_text!(after, &actual);\n-    }\n+    use crate::mock_analysis::{analysis_and_position, single_file, MockAnalysis};\n+    use expect::{expect, Expect};\n \n     /// Takes a multi-file input fixture with annotated cursor positions,\n     /// and checks that:\n@@ -350,16 +318,21 @@ mod tests {\n \n     /// Takes a multi-file input fixture with annotated cursor position and checks that no diagnostics\n     /// apply to the file containing the cursor.\n-    fn check_no_diagnostic_for_target_file(ra_fixture: &str) {\n-        let (analysis, file_position) = analysis_and_position(ra_fixture);\n-        let diagnostics = analysis.diagnostics(file_position.file_id).unwrap();\n-        assert_eq!(diagnostics.len(), 0);\n-    }\n-\n-    fn check_no_diagnostic(ra_fixture: &str) {\n+    fn check_no_diagnostics(ra_fixture: &str) {\n+        let mock = MockAnalysis::with_files(ra_fixture);\n+        let files = mock.files().map(|(it, _)| it).collect::<Vec<_>>();\n+        let analysis = mock.analysis();\n+        let diagnostics = files\n+            .into_iter()\n+            .flat_map(|file_id| analysis.diagnostics(file_id).unwrap())\n+            .collect::<Vec<_>>();\n+        assert_eq!(diagnostics.len(), 0, \"unexpected diagnostics:\\n{:#?}\", diagnostics);\n+    }\n+\n+    fn check_expect(ra_fixture: &str, expect: Expect) {\n         let (analysis, file_id) = single_file(ra_fixture);\n         let diagnostics = analysis.diagnostics(file_id).unwrap();\n-        assert_eq!(diagnostics.len(), 0, \"expected no diagnostic, found one\");\n+        expect.assert_debug_eq(&diagnostics)\n     }\n \n     #[test]\n@@ -397,7 +370,7 @@ fn div(x: i32, y: i32) -> Result<i32, ()> {\n     fn test_wrap_return_type_handles_generic_functions() {\n         check_fix(\n             r#\"\n-            //- /main.rs\n+//- /main.rs\n use core::result::Result::{self, Ok, Err};\n \n fn div<T>(x: T) -> Result<T, i32> {\n@@ -461,44 +434,37 @@ fn div(x: i32, y: i32) -> MyResult<i32> {\n \n     #[test]\n     fn test_wrap_return_type_not_applicable_when_expr_type_does_not_match_ok_type() {\n-        check_no_diagnostic_for_target_file(\n-            r\"\n-            //- /main.rs\n-            use core::result::Result::{self, Ok, Err};\n+        check_no_diagnostics(\n+            r#\"\n+//- /main.rs\n+use core::result::Result::{self, Ok, Err};\n \n-            fn foo() -> Result<(), i32> {\n-                0<|>\n-            }\n+fn foo() -> Result<(), i32> { 0 }\n \n-            //- /core/lib.rs\n-            pub mod result {\n-                pub enum Result<T, E> { Ok(T), Err(E) }\n-            }\n-        \",\n+//- /core/lib.rs\n+pub mod result {\n+    pub enum Result<T, E> { Ok(T), Err(E) }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn test_wrap_return_type_not_applicable_when_return_type_is_not_result() {\n-        check_no_diagnostic_for_target_file(\n-            r\"\n-            //- /main.rs\n-            use core::result::Result::{self, Ok, Err};\n+        check_no_diagnostics(\n+            r#\"\n+//- /main.rs\n+use core::result::Result::{self, Ok, Err};\n \n-            enum SomeOtherEnum {\n-                Ok(i32),\n-                Err(String),\n-            }\n+enum SomeOtherEnum { Ok(i32), Err(String) }\n \n-            fn foo() -> SomeOtherEnum {\n-                0<|>\n-            }\n+fn foo() -> SomeOtherEnum { 0 }\n \n-            //- /core/lib.rs\n-            pub mod result {\n-                pub enum Result<T, E> { Ok(T), Err(E) }\n-            }\n-        \",\n+//- /core/lib.rs\n+pub mod result {\n+    pub enum Result<T, E> { Ok(T), Err(E) }\n+}\n+\"#,\n         );\n     }\n \n@@ -592,7 +558,7 @@ fn test_fn() {\n \n     #[test]\n     fn test_fill_struct_fields_no_diagnostic() {\n-        check_no_diagnostic(\n+        check_no_diagnostics(\n             r\"\n             struct TestStruct { one: i32, two: i64 }\n \n@@ -606,7 +572,7 @@ fn test_fn() {\n \n     #[test]\n     fn test_fill_struct_fields_no_diagnostic_on_spread() {\n-        check_no_diagnostic(\n+        check_no_diagnostics(\n             r\"\n             struct TestStruct { one: i32, two: i64 }\n \n@@ -620,202 +586,134 @@ fn test_fn() {\n \n     #[test]\n     fn test_unresolved_module_diagnostic() {\n-        let (analysis, file_id) = single_file(\"mod foo;\");\n-        let diagnostics = analysis.diagnostics(file_id).unwrap();\n-        assert_debug_snapshot!(diagnostics, @r###\"\n-        [\n-            Diagnostic {\n-                message: \"unresolved module\",\n-                range: 0..8,\n-                severity: Error,\n-                fix: Some(\n-                    Fix {\n-                        label: \"Create module\",\n-                        source_change: SourceChange {\n-                            source_file_edits: [],\n-                            file_system_edits: [\n-                                CreateFile {\n-                                    anchor: FileId(\n-                                        1,\n-                                    ),\n-                                    dst: \"foo.rs\",\n+        check_expect(\n+            r#\"mod foo;\"#,\n+            expect![[r#\"\n+                [\n+                    Diagnostic {\n+                        message: \"unresolved module\",\n+                        range: 0..8,\n+                        severity: Error,\n+                        fix: Some(\n+                            Fix {\n+                                label: \"Create module\",\n+                                source_change: SourceChange {\n+                                    source_file_edits: [],\n+                                    file_system_edits: [\n+                                        CreateFile {\n+                                            anchor: FileId(\n+                                                1,\n+                                            ),\n+                                            dst: \"foo.rs\",\n+                                        },\n+                                    ],\n+                                    is_snippet: false,\n                                 },\n-                            ],\n-                            is_snippet: false,\n-                        },\n+                            },\n+                        ),\n                     },\n-                ),\n-            },\n-        ]\n-        \"###);\n+                ]\n+            \"#]],\n+        );\n     }\n \n     #[test]\n     fn range_mapping_out_of_macros() {\n-        let (analysis, file_id) = single_file(\n-            r\"\n-            fn some() {}\n-            fn items() {}\n-            fn here() {}\n+        // FIXME: this is very wrong, but somewhat tricky to fix.\n+        check_fix(\n+            r#\"\n+fn some() {}\n+fn items() {}\n+fn here() {}\n \n-            macro_rules! id {\n-                ($($tt:tt)*) => { $($tt)*};\n-            }\n+macro_rules! id { ($($tt:tt)*) => { $($tt)*}; }\n \n-            fn main() {\n-                let _x = id![Foo { a: 42 }];\n-            }\n+fn main() {\n+    let _x = id![Foo { a: <|>42 }];\n+}\n \n-            pub struct Foo {\n-                pub a: i32,\n-                pub b: i32,\n-            }\n-        \",\n+pub struct Foo { pub a: i32, pub b: i32 }\n+\"#,\n+            r#\"\n+fn {a:42, b: ()} {}\n+fn items() {}\n+fn here() {}\n+\n+macro_rules! id { ($($tt:tt)*) => { $($tt)*}; }\n+\n+fn main() {\n+    let _x = id![Foo { a: 42 }];\n+}\n+\n+pub struct Foo { pub a: i32, pub b: i32 }\n+\"#,\n         );\n-        let diagnostics = analysis.diagnostics(file_id).unwrap();\n-        assert_debug_snapshot!(diagnostics, @r###\"\n-        [\n-            Diagnostic {\n-                message: \"Missing structure fields:\\n- b\\n\",\n-                range: 127..136,\n-                severity: Error,\n-                fix: Some(\n-                    Fix {\n-                        label: \"Fill struct fields\",\n-                        source_change: SourceChange {\n-                            source_file_edits: [\n-                                SourceFileEdit {\n-                                    file_id: FileId(\n-                                        1,\n-                                    ),\n-                                    edit: TextEdit {\n-                                        indels: [\n-                                            Indel {\n-                                                insert: \"{a:42, b: ()}\",\n-                                                delete: 3..9,\n-                                            },\n-                                        ],\n-                                    },\n-                                },\n-                            ],\n-                            file_system_edits: [],\n-                            is_snippet: false,\n-                        },\n-                    },\n-                ),\n-            },\n-        ]\n-        \"###);\n     }\n \n     #[test]\n     fn test_check_unnecessary_braces_in_use_statement() {\n-        check_not_applicable(\n-            \"\n-            use a;\n-            use a::{c, d::e};\n-        \",\n-            check_unnecessary_braces_in_use_statement,\n-        );\n-        check_apply(\"use {b};\", \"use b;\", check_unnecessary_braces_in_use_statement);\n-        check_apply(\"use a::{c};\", \"use a::c;\", check_unnecessary_braces_in_use_statement);\n-        check_apply(\"use a::{self};\", \"use a;\", check_unnecessary_braces_in_use_statement);\n-        check_apply(\n-            \"use a::{c, d::{e}};\",\n-            \"use a::{c, d::e};\",\n-            check_unnecessary_braces_in_use_statement,\n+        check_no_diagnostics(\n+            r#\"\n+use a;\n+use a::{c, d::e};\n+\"#,\n         );\n+        check_fix(r#\"use {<|>b};\"#, r#\"use b;\"#);\n+        check_fix(r#\"use {b<|>};\"#, r#\"use b;\"#);\n+        check_fix(r#\"use a::{c<|>};\"#, r#\"use a::c;\"#);\n+        check_fix(r#\"use a::{self<|>};\"#, r#\"use a;\"#);\n+        check_fix(r#\"use a::{c, d::{e<|>}};\"#, r#\"use a::{c, d::e};\"#);\n     }\n \n     #[test]\n     fn test_check_struct_shorthand_initialization() {\n-        check_not_applicable(\n+        check_no_diagnostics(\n             r#\"\n-            struct A {\n-                a: &'static str\n-            }\n-\n-            fn main() {\n-                A {\n-                    a: \"hello\"\n-                }\n-            }\n-        \"#,\n-            check_struct_shorthand_initialization,\n+struct A { a: &'static str }\n+fn main() { A { a: \"hello\" } }\n+\"#,\n         );\n-        check_not_applicable(\n+        check_no_diagnostics(\n             r#\"\n-            struct A(usize);\n-\n-            fn main() {\n-                A {\n-                    0: 0\n-                }\n-            }\n-        \"#,\n-            check_struct_shorthand_initialization,\n+struct A(usize);\n+fn main() { A { 0: 0 } }\n+\"#,\n         );\n \n-        check_apply(\n+        check_fix(\n             r#\"\n-struct A {\n-    a: &'static str\n-}\n-\n+struct A { a: &'static str }\n fn main() {\n     let a = \"haha\";\n-    A {\n-        a: a\n-    }\n+    A { a<|>: a }\n }\n-        \"#,\n+\"#,\n             r#\"\n-struct A {\n-    a: &'static str\n-}\n-\n+struct A { a: &'static str }\n fn main() {\n     let a = \"haha\";\n-    A {\n-        a\n-    }\n+    A { a }\n }\n-        \"#,\n-            check_struct_shorthand_initialization,\n+\"#,\n         );\n \n-        check_apply(\n+        check_fix(\n             r#\"\n-struct A {\n-    a: &'static str,\n-    b: &'static str\n-}\n-\n+struct A { a: &'static str, b: &'static str }\n fn main() {\n     let a = \"haha\";\n     let b = \"bb\";\n-    A {\n-        a: a,\n-        b\n-    }\n+    A { a<|>: a, b }\n }\n-        \"#,\n+\"#,\n             r#\"\n-struct A {\n-    a: &'static str,\n-    b: &'static str\n-}\n-\n+struct A { a: &'static str, b: &'static str }\n fn main() {\n     let a = \"haha\";\n     let b = \"bb\";\n-    A {\n-        a,\n-        b\n-    }\n+    A { a, b }\n }\n-        \"#,\n-            check_struct_shorthand_initialization,\n+\"#,\n         );\n     }\n "}, {"sha": "b28054688783dc49e4befbdcc1d722f583d7e58e", "filename": "crates/ra_ide/src/mock_analysis.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb0bc941a504e2ef5cf8766e0faa58bfeaecc712/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb0bc941a504e2ef5cf8766e0faa58bfeaecc712/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs?ref=fb0bc941a504e2ef5cf8766e0faa58bfeaecc712", "patch": "@@ -71,27 +71,23 @@ impl MockAnalysis {\n     }\n \n     pub fn id_of(&self, path: &str) -> FileId {\n-        let (idx, _) = self\n-            .files\n-            .iter()\n-            .enumerate()\n-            .find(|(_, data)| path == data.path)\n-            .expect(\"no file in this mock\");\n-        FileId(idx as u32 + 1)\n+        let (file_id, _) =\n+            self.files().find(|(_, data)| path == data.path).expect(\"no file in this mock\");\n+        file_id\n     }\n     pub fn annotations(&self) -> Vec<(FileRange, String)> {\n-        self.files\n-            .iter()\n-            .enumerate()\n-            .flat_map(|(idx, fixture)| {\n-                let file_id = FileId(idx as u32 + 1);\n+        self.files()\n+            .flat_map(|(file_id, fixture)| {\n                 let annotations = extract_annotations(&fixture.text);\n                 annotations\n                     .into_iter()\n                     .map(move |(range, data)| (FileRange { file_id, range }, data))\n             })\n             .collect()\n     }\n+    pub fn files(&self) -> impl Iterator<Item = (FileId, &Fixture)> + '_ {\n+        self.files.iter().enumerate().map(|(idx, fixture)| (FileId(idx as u32 + 1), fixture))\n+    }\n     pub fn annotation(&self) -> (FileRange, String) {\n         let mut all = self.annotations();\n         assert_eq!(all.len(), 1);"}]}