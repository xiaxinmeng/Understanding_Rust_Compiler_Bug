{"sha": "3001ae7f94672064ca5db1a9f425644e98c3ecc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMDFhZTdmOTQ2NzIwNjRjYTVkYjFhOWY0MjU2NDRlOThjM2VjYzY=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-02-20T01:17:15Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-03-05T22:13:11Z"}, "message": "Implement wfcheck for const parameters\n\nCo-Authored-By: Gabriel Smith <yodaldevoid@users.noreply.github.com>", "tree": {"sha": "fc66df76c44896995249e01354f0577789740d75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc66df76c44896995249e01354f0577789740d75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3001ae7f94672064ca5db1a9f425644e98c3ecc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3001ae7f94672064ca5db1a9f425644e98c3ecc6", "html_url": "https://github.com/rust-lang/rust/commit/3001ae7f94672064ca5db1a9f425644e98c3ecc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3001ae7f94672064ca5db1a9f425644e98c3ecc6/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8361eb6fa42a0cf609d7bbec493702ee2193d7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8361eb6fa42a0cf609d7bbec493702ee2193d7b", "html_url": "https://github.com/rust-lang/rust/commit/a8361eb6fa42a0cf609d7bbec493702ee2193d7b"}], "stats": {"total": 59, "additions": 50, "deletions": 9}, "files": [{"sha": "16cf25f0d4916e183e05384571dcba7063adc075", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 50, "deletions": 9, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3001ae7f94672064ca5db1a9f425644e98c3ecc6/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3001ae7f94672064ca5db1a9f425644e98c3ecc6/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=3001ae7f94672064ca5db1a9f425644e98c3ecc6", "patch": "@@ -6,6 +6,7 @@ use rustc::traits::{self, ObligationCauseCode};\n use rustc::ty::{self, Lift, Ty, TyCtxt, TyKind, GenericParamDefKind, TypeFoldable, ToPredicate};\n use rustc::ty::subst::{Subst, InternalSubsts};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n+use rustc::mir::interpret::ConstValue;\n use rustc::middle::lang_items;\n use rustc::infer::opaque_types::may_define_existential_type;\n \n@@ -436,7 +437,7 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n     // struct Foo<T = Vec<[u32]>> { .. }\n     // Here the default `Vec<[u32]>` is not WF because `[u32]: Sized` does not hold.\n     for param in &generics.params {\n-        if let GenericParamDefKind::Type {..} = param.kind {\n+        if let GenericParamDefKind::Type { .. } = param.kind {\n             if is_our_default(&param) {\n                 let ty = fcx.tcx.type_of(param.def_id);\n                 // ignore dependent defaults -- that is, where the default of one type\n@@ -464,7 +465,7 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n                 // All regions are identity.\n                 fcx.tcx.mk_param_from_def(param)\n             }\n-            GenericParamDefKind::Type {..} => {\n+            GenericParamDefKind::Type { .. } => {\n                 // If the param has a default,\n                 if is_our_default(param) {\n                     let default_ty = fcx.tcx.type_of(param.def_id);\n@@ -477,6 +478,10 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n                 // Mark unwanted params as err.\n                 fcx.tcx.types.err.into()\n             }\n+            GenericParamDefKind::Const => {\n+                // FIXME(const_generics:defaults)\n+                fcx.tcx.types.err.into()\n+            }\n         }\n     });\n     // Now we build the substituted predicates.\n@@ -497,6 +502,16 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n             fn visit_region(&mut self, _: ty::Region<'tcx>) -> bool {\n                 true\n             }\n+\n+            fn visit_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> bool {\n+                if let ty::LazyConst::Evaluated(ty::Const {\n+                    val: ConstValue::Param(param),\n+                    ..\n+                }) = c {\n+                    self.params.insert(param.index);\n+                }\n+                c.super_visit_with(self)\n+            }\n         }\n         let mut param_count = CountParams::default();\n         let has_region = pred.visit_with(&mut param_count);\n@@ -617,11 +632,10 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                         for (subst, param) in substs.iter().zip(&generics.params) {\n                             match subst.unpack() {\n                                 ty::subst::UnpackedKind::Type(ty) => match ty.sty {\n-                                    ty::Param(..) => {},\n+                                    ty::Param(..) => {}\n                                     // prevent `fn foo() -> Foo<u32>` from being defining\n                                     _ => {\n-                                        tcx\n-                                            .sess\n+                                        tcx.sess\n                                             .struct_span_err(\n                                                 span,\n                                                 \"non-defining existential type use \\\n@@ -636,8 +650,9 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                                                 ),\n                                             )\n                                             .emit();\n-                                    },\n-                                }, // match ty\n+                                    }\n+                                }\n+\n                                 ty::subst::UnpackedKind::Lifetime(region) => {\n                                     let param_span = tcx.def_span(param.def_id);\n                                     if let ty::ReStatic = region {\n@@ -658,7 +673,31 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                                     } else {\n                                         seen.entry(region).or_default().push(param_span);\n                                     }\n-                                },\n+                                }\n+\n+                                ty::subst::UnpackedKind::Const(ct) => match ct {\n+                                    ty::LazyConst::Evaluated(ty::Const {\n+                                        val: ConstValue::Param(_),\n+                                        ..\n+                                    }) => {}\n+                                    _ => {\n+                                        tcx.sess\n+                                            .struct_span_err(\n+                                                span,\n+                                                \"non-defining existential type use \\\n+                                                in defining scope\",\n+                                            )\n+                                            .span_note(\n+                                                tcx.def_span(param.def_id),\n+                                                &format!(\n+                                                    \"used non-generic const {} for \\\n+                                                    generic parameter\",\n+                                                    ty,\n+                                                ),\n+                                            )\n+                                            .emit();\n+                                    }\n+                                }\n                             } // match subst\n                         } // for (subst, param)\n                         for (_, spans) in seen {\n@@ -942,7 +981,9 @@ fn reject_shadowing_parameters(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) {\n     let parent = tcx.generics_of(generics.parent.unwrap());\n     let impl_params: FxHashMap<_, _> = parent.params.iter().flat_map(|param| match param.kind {\n         GenericParamDefKind::Lifetime => None,\n-        GenericParamDefKind::Type {..} => Some((param.name, param.def_id)),\n+        GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n+            Some((param.name, param.def_id))\n+        }\n     }).collect();\n \n     for method_param in &generics.params {"}]}