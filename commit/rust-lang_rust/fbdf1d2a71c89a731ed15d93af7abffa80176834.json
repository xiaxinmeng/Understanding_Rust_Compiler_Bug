{"sha": "fbdf1d2a71c89a731ed15d93af7abffa80176834", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZGYxZDJhNzFjODlhNzMxZWQxNWQ5M2FmN2FiZmZhODAxNzY4MzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-29T15:14:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-29T15:14:47Z"}, "message": "Auto merge of #64000 - Centril:rollup-70s9ar3, r=Centril\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #62734 (Hide trait default methods)\n - #63953 (bootstrap: allow specifying mirror for bootstrap compiler download.)\n - #63956 (rustc: Handle modules in \"fat\" LTO more robustly)\n - #63979 (std: Remove the `wasm_syscall` feature)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "6dd4c795f90382ab99ea7bea3a96604865b7ebe4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dd4c795f90382ab99ea7bea3a96604865b7ebe4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbdf1d2a71c89a731ed15d93af7abffa80176834", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbdf1d2a71c89a731ed15d93af7abffa80176834", "html_url": "https://github.com/rust-lang/rust/commit/fbdf1d2a71c89a731ed15d93af7abffa80176834", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbdf1d2a71c89a731ed15d93af7abffa80176834/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7445622bcb515c822a2fc6e8c57c90478c1a56bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7445622bcb515c822a2fc6e8c57c90478c1a56bb", "html_url": "https://github.com/rust-lang/rust/commit/7445622bcb515c822a2fc6e8c57c90478c1a56bb"}, {"sha": "d920aa0e022c9809adb58eaa8f540712b5e68b63", "url": "https://api.github.com/repos/rust-lang/rust/commits/d920aa0e022c9809adb58eaa8f540712b5e68b63", "html_url": "https://github.com/rust-lang/rust/commit/d920aa0e022c9809adb58eaa8f540712b5e68b63"}], "stats": {"total": 567, "additions": 116, "deletions": 451}, "files": [{"sha": "30e2ee1b9babf4609e77ef6c663842e4fa68c2bd", "filename": "config.toml.example", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -382,11 +382,6 @@\n # This is the name of the directory in which codegen backends will get installed\n #codegen-backends-dir = \"codegen-backends\"\n \n-# Flag indicating whether `libstd` calls an imported function to handle basic IO\n-# when targeting WebAssembly. Enable this to debug tests for the `wasm32-unknown-unknown`\n-# target, as without this option the test output will not be captured.\n-#wasm-syscall = false\n-\n # Indicates whether LLD will be compiled and made available in the sysroot for\n # rustc to execute.\n #lld = false"}, {"sha": "4162fe1df5086841b6c0953e041b4c8fd3deccef", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -320,7 +320,7 @@ class RustBuild(object):\n     def __init__(self):\n         self.cargo_channel = ''\n         self.date = ''\n-        self._download_url = 'https://static.rust-lang.org'\n+        self._download_url = ''\n         self.rustc_channel = ''\n         self.build = ''\n         self.build_dir = os.path.join(os.getcwd(), \"build\")\n@@ -733,9 +733,19 @@ def update_submodules(self):\n             self.update_submodule(module[0], module[1], recorded_submodules)\n         print(\"Submodules updated in %.2f seconds\" % (time() - start_time))\n \n+    def set_normal_environment(self):\n+        \"\"\"Set download URL for normal environment\"\"\"\n+        if 'RUSTUP_DIST_SERVER' in os.environ:\n+            self._download_url = os.environ['RUSTUP_DIST_SERVER']\n+        else:\n+            self._download_url = 'https://static.rust-lang.org'\n+\n     def set_dev_environment(self):\n         \"\"\"Set download URL for development environment\"\"\"\n-        self._download_url = 'https://dev-static.rust-lang.org'\n+        if 'RUSTUP_DEV_DIST_SERVER' in os.environ:\n+            self._download_url = os.environ['RUSTUP_DEV_DIST_SERVER']\n+        else:\n+            self._download_url = 'https://dev-static.rust-lang.org'\n \n     def check_vendored_status(self):\n         \"\"\"Check that vendoring is configured properly\"\"\"\n@@ -828,6 +838,8 @@ def bootstrap(help_triggered):\n \n     if 'dev' in data:\n         build.set_dev_environment()\n+    else:\n+        build.set_normal_environment()\n \n     build.update_submodules()\n "}, {"sha": "43d9264eaca92ee6584485ed37a2e1e71a503762", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -122,7 +122,6 @@ pub struct Config {\n \n     // libstd features\n     pub backtrace: bool, // support for RUST_BACKTRACE\n-    pub wasm_syscall: bool,\n \n     // misc\n     pub low_priority: bool,\n@@ -318,7 +317,6 @@ struct Rust {\n     save_toolstates: Option<String>,\n     codegen_backends: Option<Vec<String>>,\n     codegen_backends_dir: Option<String>,\n-    wasm_syscall: Option<bool>,\n     lld: Option<bool>,\n     lldb: Option<bool>,\n     llvm_tools: Option<bool>,\n@@ -558,7 +556,6 @@ impl Config {\n             if let Some(true) = rust.incremental {\n                 config.incremental = true;\n             }\n-            set(&mut config.wasm_syscall, rust.wasm_syscall);\n             set(&mut config.lld_enabled, rust.lld);\n             set(&mut config.lldb_enabled, rust.lldb);\n             set(&mut config.llvm_tools_enabled, rust.llvm_tools);"}, {"sha": "5d7581c8211be84c1e05b0ae27663f69aa992202", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -495,9 +495,6 @@ impl Build {\n         if self.config.profiler {\n             features.push_str(\" profiler\");\n         }\n-        if self.config.wasm_syscall {\n-            features.push_str(\" wasm_syscall\");\n-        }\n         features\n     }\n "}, {"sha": "97b28ed9e96c81468f2dd877f775d3cbeff051af", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -1811,16 +1811,6 @@ impl Step for Crate {\n                     .expect(\"nodejs not configured\"),\n             );\n         } else if target.starts_with(\"wasm32\") {\n-            // Warn about running tests without the `wasm_syscall` feature enabled.\n-            // The javascript shim implements the syscall interface so that test\n-            // output can be correctly reported.\n-            if !builder.config.wasm_syscall {\n-                builder.info(\n-                    \"Libstd was built without `wasm_syscall` feature enabled: \\\n-                     test output may not be visible.\"\n-                );\n-            }\n-\n             // On the wasm32-unknown-unknown target we're using LTO which is\n             // incompatible with `-C prefer-dynamic`, so disable that here\n             cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");"}, {"sha": "262a53eabe3c7bf3030eafc9c8c79a8d3000522c", "filename": "src/etc/wasm32-shim.js", "status": "modified", "additions": 1, "deletions": 107, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Fetc%2Fwasm32-shim.js", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Fetc%2Fwasm32-shim.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fwasm32-shim.js?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -15,113 +15,7 @@ const buffer = fs.readFileSync(process.argv[2]);\n Error.stackTraceLimit = 20;\n \n let m = new WebAssembly.Module(buffer);\n-\n-let memory = null;\n-\n-function viewstruct(data, fields) {\n-  return new Uint32Array(memory.buffer).subarray(data/4, data/4 + fields);\n-}\n-\n-function copystr(a, b) {\n-  let view = new Uint8Array(memory.buffer).subarray(a, a + b);\n-  return String.fromCharCode.apply(null, view);\n-}\n-\n-function syscall_write([fd, ptr, len]) {\n-  let s = copystr(ptr, len);\n-  switch (fd) {\n-    case 1: process.stdout.write(s); break;\n-    case 2: process.stderr.write(s); break;\n-  }\n-}\n-\n-function syscall_exit([code]) {\n-  process.exit(code);\n-}\n-\n-function syscall_args(params) {\n-  let [ptr, len] = params;\n-\n-  // Calculate total required buffer size\n-  let totalLen = -1;\n-  for (let i = 2; i < process.argv.length; ++i) {\n-    totalLen += Buffer.byteLength(process.argv[i]) + 1;\n-  }\n-  if (totalLen < 0) { totalLen = 0; }\n-  params[2] = totalLen;\n-\n-  // If buffer is large enough, copy data\n-  if (len >= totalLen) {\n-    let view = new Uint8Array(memory.buffer);\n-    for (let i = 2; i < process.argv.length; ++i) {\n-      let value = process.argv[i];\n-      Buffer.from(value).copy(view, ptr);\n-      ptr += Buffer.byteLength(process.argv[i]) + 1;\n-    }\n-  }\n-}\n-\n-function syscall_getenv(params) {\n-  let [keyPtr, keyLen, valuePtr, valueLen] = params;\n-\n-  let key = copystr(keyPtr, keyLen);\n-  let value = process.env[key];\n-\n-  if (value == null) {\n-    params[4] = 0xFFFFFFFF;\n-  } else {\n-    let view = new Uint8Array(memory.buffer);\n-    let totalLen = Buffer.byteLength(value);\n-    params[4] = totalLen;\n-    if (valueLen >= totalLen) {\n-      Buffer.from(value).copy(view, valuePtr);\n-    }\n-  }\n-}\n-\n-function syscall_time(params) {\n-  let t = Date.now();\n-  let secs = Math.floor(t / 1000);\n-  let millis = t % 1000;\n-  params[1] = Math.floor(secs / 0x100000000);\n-  params[2] = secs % 0x100000000;\n-  params[3] = Math.floor(millis * 1000000);\n-}\n-\n-let imports = {};\n-imports.env = {\n-  // These are generated by LLVM itself for various intrinsic calls. Hopefully\n-  // one day this is not necessary and something will automatically do this.\n-  fmod: function(x, y) { return x % y; },\n-  exp2: function(x) { return Math.pow(2, x); },\n-  exp2f: function(x) { return Math.pow(2, x); },\n-  ldexp: function(x, y) { return x * Math.pow(2, y); },\n-  ldexpf: function(x, y) { return x * Math.pow(2, y); },\n-  sin: Math.sin,\n-  sinf: Math.sin,\n-  cos: Math.cos,\n-  cosf: Math.cos,\n-  log: Math.log,\n-  log2: Math.log2,\n-  log10: Math.log10,\n-  log10f: Math.log10,\n-\n-  rust_wasm_syscall: function(index, data) {\n-    switch (index) {\n-      case 1: syscall_write(viewstruct(data, 3)); return true;\n-      case 2: syscall_exit(viewstruct(data, 1)); return true;\n-      case 3: syscall_args(viewstruct(data, 3)); return true;\n-      case 4: syscall_getenv(viewstruct(data, 5)); return true;\n-      case 6: syscall_time(viewstruct(data, 4)); return true;\n-      default:\n-        console.log(\"Unsupported syscall: \" + index);\n-        return false;\n-    }\n-  }\n-};\n-\n-let instance = new WebAssembly.Instance(m, imports);\n-memory = instance.exports.memory;\n+let instance = new WebAssembly.Instance(m, {});\n try {\n   instance.exports.main();\n } catch (e) {"}, {"sha": "a43fbb68dbaed76d7d5d3d858c8c591fee5f50f7", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -183,14 +183,40 @@ pub(crate) fn prepare_thin(\n \n fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n            diag_handler: &Handler,\n-           mut modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n+           modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n            cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n            mut serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n            symbol_white_list: &[*const libc::c_char])\n     -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n {\n     info!(\"going for a fat lto\");\n \n+    // Sort out all our lists of incoming modules into two lists.\n+    //\n+    // * `serialized_modules` (also and argument to this function) contains all\n+    //   modules that are serialized in-memory.\n+    // * `in_memory` contains modules which are already parsed and in-memory,\n+    //   such as from multi-CGU builds.\n+    //\n+    // All of `cached_modules` (cached from previous incremental builds) can\n+    // immediately go onto the `serialized_modules` modules list and then we can\n+    // split the `modules` array into these two lists.\n+    let mut in_memory = Vec::new();\n+    serialized_modules.extend(cached_modules.into_iter().map(|(buffer, wp)| {\n+        info!(\"pushing cached module {:?}\", wp.cgu_name);\n+        (buffer, CString::new(wp.cgu_name).unwrap())\n+    }));\n+    for module in modules {\n+        match module {\n+            FatLTOInput::InMemory(m) => in_memory.push(m),\n+            FatLTOInput::Serialized { name, buffer } => {\n+                info!(\"pushing serialized module {:?}\", name);\n+                let buffer = SerializedModule::Local(buffer);\n+                serialized_modules.push((buffer, CString::new(name).unwrap()));\n+            }\n+        }\n+    }\n+\n     // Find the \"costliest\" module and merge everything into that codegen unit.\n     // All the other modules will be serialized and reparsed into the new\n     // context, so this hopefully avoids serializing and parsing the largest\n@@ -200,14 +226,8 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     // file copy operations in the backend work correctly. The only other kind\n     // of module here should be an allocator one, and if your crate is smaller\n     // than the allocator module then the size doesn't really matter anyway.\n-    let costliest_module = modules.iter()\n+    let costliest_module = in_memory.iter()\n         .enumerate()\n-        .filter_map(|(i, module)| {\n-            match module {\n-                FatLTOInput::InMemory(m) => Some((i, m)),\n-                FatLTOInput::Serialized { .. } => None,\n-            }\n-        })\n         .filter(|&(_, module)| module.kind == ModuleKind::Regular)\n         .map(|(i, module)| {\n             let cost = unsafe {\n@@ -223,26 +243,14 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     // re-executing the LTO passes. If that's the case deserialize the first\n     // module and create a linker with it.\n     let module: ModuleCodegen<ModuleLlvm> = match costliest_module {\n-        Some((_cost, i)) => {\n-            match modules.remove(i) {\n-                FatLTOInput::InMemory(m) => m,\n-                FatLTOInput::Serialized { .. } => unreachable!(),\n-            }\n-        }\n+        Some((_cost, i)) => in_memory.remove(i),\n         None => {\n-            let pos = modules.iter().position(|m| {\n-                match m {\n-                    FatLTOInput::InMemory(_) => false,\n-                    FatLTOInput::Serialized { .. } => true,\n-                }\n-            }).expect(\"must have at least one serialized module\");\n-            let (name, buffer) = match modules.remove(pos) {\n-                FatLTOInput::Serialized { name, buffer } => (name, buffer),\n-                FatLTOInput::InMemory(_) => unreachable!(),\n-            };\n+            assert!(serialized_modules.len() > 0, \"must have at least one serialized module\");\n+            let (buffer, name) = serialized_modules.remove(0);\n+            info!(\"no in-memory regular modules to choose from, parsing {:?}\", name);\n             ModuleCodegen {\n-                module_llvm: ModuleLlvm::parse(cgcx, &name, &buffer, diag_handler)?,\n-                name,\n+                module_llvm: ModuleLlvm::parse(cgcx, &name, buffer.data(), diag_handler)?,\n+                name: name.into_string().unwrap(),\n                 kind: ModuleKind::Regular,\n             }\n         }\n@@ -265,25 +273,13 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         // and we want to move everything to the same LLVM context. Currently the\n         // way we know of to do that is to serialize them to a string and them parse\n         // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n-        let mut new_modules = modules.into_iter().map(|module| {\n-            match module {\n-                FatLTOInput::InMemory(module) => {\n-                    let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n-                    let llmod_id = CString::new(&module.name[..]).unwrap();\n-                    (SerializedModule::Local(buffer), llmod_id)\n-                }\n-                FatLTOInput::Serialized { name, buffer } => {\n-                    let llmod_id = CString::new(name).unwrap();\n-                    (SerializedModule::Local(buffer), llmod_id)\n-                }\n-            }\n-        }).collect::<Vec<_>>();\n+        for module in in_memory {\n+            let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n+            let llmod_id = CString::new(&module.name[..]).unwrap();\n+            serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n+        }\n         // Sort the modules to ensure we produce deterministic results.\n-        new_modules.sort_by(|module1, module2| module1.1.partial_cmp(&module2.1).unwrap());\n-        serialized_modules.extend(new_modules);\n-        serialized_modules.extend(cached_modules.into_iter().map(|(buffer, wp)| {\n-            (buffer, CString::new(wp.cgu_name).unwrap())\n-        }));\n+        serialized_modules.sort_by(|module1, module2| module1.1.cmp(&module2.1));\n \n         // For all serialized bitcode files we parse them and link them in as we did\n         // above, this is all mostly handled in C++. Like above, though, we don't\n@@ -850,7 +846,7 @@ fn module_name_to_str(c_str: &CStr) -> &str {\n         bug!(\"Encountered non-utf8 LLVM module name `{}`: {}\", c_str.to_string_lossy(), e))\n }\n \n-fn parse_module<'a>(\n+pub fn parse_module<'a>(\n     cx: &'a llvm::Context,\n     name: &CStr,\n     data: &[u8],"}, {"sha": "2fd78885bd01e8106b8ffb22d2cd468075dcad8d", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -54,6 +54,7 @@ use syntax_pos::symbol::InternedString;\n pub use llvm_util::target_features;\n use std::any::Any;\n use std::sync::{mpsc, Arc};\n+use std::ffi::CStr;\n \n use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n@@ -386,13 +387,13 @@ impl ModuleLlvm {\n \n     fn parse(\n         cgcx: &CodegenContext<LlvmCodegenBackend>,\n-        name: &str,\n-        buffer: &back::lto::ModuleBuffer,\n+        name: &CStr,\n+        buffer: &[u8],\n         handler: &Handler,\n     ) -> Result<Self, FatalError> {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n-            let llmod_raw = buffer.parse(name, llcx, handler)?;\n+            let llmod_raw = back::lto::parse_module(llcx, name, buffer, handler)?;\n             let tm = match (cgcx.tm_factory.0)() {\n                 Ok(m) => m,\n                 Err(e) => {"}, {"sha": "d5c47a15948fb4c30538e429c9e89ee2acc17860", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -2405,13 +2405,14 @@ fn document(w: &mut fmt::Formatter<'_>, cx: &Context, item: &clean::Item) -> fmt\n }\n \n /// Render md_text as markdown.\n-fn render_markdown(w: &mut fmt::Formatter<'_>,\n-                   cx: &Context,\n-                   md_text: &str,\n-                   links: Vec<(String, String)>,\n-                   prefix: &str,\n-                   is_hidden: bool)\n-                   -> fmt::Result {\n+fn render_markdown(\n+    w: &mut fmt::Formatter<'_>,\n+    cx: &Context,\n+    md_text: &str,\n+    links: Vec<(String, String)>,\n+    prefix: &str,\n+    is_hidden: bool,\n+) -> fmt::Result {\n     let mut ids = cx.id_map.borrow_mut();\n     write!(w, \"<div class='docblock{}'>{}{}</div>\",\n            if is_hidden { \" hidden\" } else { \"\" },\n@@ -2425,7 +2426,8 @@ fn document_short(\n     cx: &Context,\n     item: &clean::Item,\n     link: AssocItemLink<'_>,\n-    prefix: &str, is_hidden: bool\n+    prefix: &str,\n+    is_hidden: bool,\n ) -> fmt::Result {\n     if let Some(s) = item.doc_value() {\n         let markdown = if s.contains('\\n') {\n@@ -4084,9 +4086,10 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n             RenderMode::ForDeref { mut_: deref_mut_ } => should_render_item(&item, deref_mut_),\n         };\n \n-        let (is_hidden, extra_class) = if trait_.is_none() ||\n-                                          item.doc_value().is_some() ||\n-                                          item.inner.is_associated() {\n+        let (is_hidden, extra_class) = if (trait_.is_none() ||\n+                                           item.doc_value().is_some() ||\n+                                           item.inner.is_associated()) &&\n+                                          !is_default_item {\n             (false, \"\")\n         } else {\n             (true, \" hidden\")"}, {"sha": "637c6ef8e8e0bb893daf117e7d5621687c7e1195", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -3,7 +3,7 @@\n \n // Local js definitions:\n /* global addClass, getCurrentValue, hasClass */\n-/* global isHidden onEach, removeClass, updateLocalStorage */\n+/* global isHidden, onEach, removeClass, updateLocalStorage */\n \n if (!String.prototype.startsWith) {\n     String.prototype.startsWith = function(searchString, position) {"}, {"sha": "157faa0af9bca1858689201ecb05e977afc8a17b", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -70,11 +70,6 @@ llvm-libunwind = [\"unwind/llvm-libunwind\"]\n # Make panics and failed asserts immediately abort without formatting any message\n panic_immediate_abort = [\"core/panic_immediate_abort\"]\n \n-# An off-by-default feature which enables a linux-syscall-like ABI for libstd to\n-# interoperate with the host environment. Currently not well documented and\n-# requires rebuilding the standard library to use it.\n-wasm_syscall = []\n-\n # Enable std_detect default features for stdarch/crates/std_detect:\n # https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/Cargo.toml\n std_detect_file_io = []"}, {"sha": "8279e5280e9249b2c53f69b1843ba5803b1882bd", "filename": "src/libstd/sys/wasm/args.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -1,7 +1,6 @@\n use crate::ffi::OsString;\n use crate::marker::PhantomData;\n use crate::vec;\n-use crate::sys::ArgsSysCall;\n \n pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n     // On wasm these should always be null, so there's nothing for us to do here\n@@ -11,9 +10,8 @@ pub unsafe fn cleanup() {\n }\n \n pub fn args() -> Args {\n-    let v = ArgsSysCall::perform();\n     Args {\n-        iter: v.into_iter(),\n+        iter: Vec::new().into_iter(),\n         _dont_send_or_sync_me: PhantomData,\n     }\n }"}, {"sha": "de0bb38dc319e7c9d0c0067700c39af650ef0888", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 1, "deletions": 221, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -15,11 +15,6 @@\n //! guaranteed to be a runtime error!\n \n use crate::os::raw::c_char;\n-use crate::ptr;\n-use crate::sys::os_str::Buf;\n-use crate::sys_common::{AsInner, FromInner};\n-use crate::ffi::{OsString, OsStr};\n-use crate::time::Duration;\n \n pub mod alloc;\n pub mod args;\n@@ -89,7 +84,7 @@ pub unsafe fn strlen(mut s: *const c_char) -> usize {\n }\n \n pub unsafe fn abort_internal() -> ! {\n-    ExitSysCall::perform(1)\n+    crate::arch::wasm32::unreachable()\n }\n \n // We don't have randomness yet, but I totally used a random number generator to\n@@ -100,218 +95,3 @@ pub unsafe fn abort_internal() -> ! {\n pub fn hashmap_random_keys() -> (u64, u64) {\n     (1, 2)\n }\n-\n-// Implement a minimal set of system calls to enable basic IO\n-pub enum SysCallIndex {\n-    Read = 0,\n-    Write = 1,\n-    Exit = 2,\n-    Args = 3,\n-    GetEnv = 4,\n-    SetEnv = 5,\n-    Time = 6,\n-}\n-\n-#[repr(C)]\n-pub struct ReadSysCall {\n-    fd: usize,\n-    ptr: *mut u8,\n-    len: usize,\n-    result: usize,\n-}\n-\n-impl ReadSysCall {\n-    pub fn perform(fd: usize, buffer: &mut [u8]) -> usize {\n-        let mut call_record = ReadSysCall {\n-            fd,\n-            len: buffer.len(),\n-            ptr: buffer.as_mut_ptr(),\n-            result: 0\n-        };\n-        if unsafe { syscall(SysCallIndex::Read, &mut call_record) } {\n-            call_record.result\n-        } else {\n-            0\n-        }\n-    }\n-}\n-\n-#[repr(C)]\n-pub struct WriteSysCall {\n-    fd: usize,\n-    ptr: *const u8,\n-    len: usize,\n-}\n-\n-impl WriteSysCall {\n-    pub fn perform(fd: usize, buffer: &[u8]) {\n-        let mut call_record = WriteSysCall {\n-            fd,\n-            len: buffer.len(),\n-            ptr: buffer.as_ptr()\n-        };\n-        unsafe { syscall(SysCallIndex::Write, &mut call_record); }\n-    }\n-}\n-\n-#[repr(C)]\n-pub struct ExitSysCall {\n-    code: usize,\n-}\n-\n-impl ExitSysCall {\n-    pub fn perform(code: usize) -> ! {\n-        let mut call_record = ExitSysCall {\n-            code\n-        };\n-        unsafe {\n-            syscall(SysCallIndex::Exit, &mut call_record);\n-            crate::intrinsics::abort();\n-        }\n-    }\n-}\n-\n-fn receive_buffer<E, F: FnMut(&mut [u8]) -> Result<usize, E>>(estimate: usize, mut f: F)\n-    -> Result<Vec<u8>, E>\n-{\n-    let mut buffer = vec![0; estimate];\n-    loop {\n-        let result = f(&mut buffer)?;\n-        if result <= buffer.len() {\n-            buffer.truncate(result);\n-            break;\n-        }\n-        buffer.resize(result, 0);\n-    }\n-    Ok(buffer)\n-}\n-\n-#[repr(C)]\n-pub struct ArgsSysCall {\n-    ptr: *mut u8,\n-    len: usize,\n-    result: usize\n-}\n-\n-impl ArgsSysCall {\n-    pub fn perform() -> Vec<OsString> {\n-        receive_buffer(1024, |buffer| -> Result<usize, !> {\n-            let mut call_record = ArgsSysCall {\n-                len: buffer.len(),\n-                ptr: buffer.as_mut_ptr(),\n-                result: 0\n-            };\n-            if unsafe { syscall(SysCallIndex::Args, &mut call_record) } {\n-                Ok(call_record.result)\n-            } else {\n-                Ok(0)\n-            }\n-        })\n-            .unwrap()\n-            .split(|b| *b == 0)\n-            .map(|s| FromInner::from_inner(Buf { inner: s.to_owned() }))\n-            .collect()\n-    }\n-}\n-\n-#[repr(C)]\n-pub struct GetEnvSysCall {\n-    key_ptr: *const u8,\n-    key_len: usize,\n-    value_ptr: *mut u8,\n-    value_len: usize,\n-    result: usize\n-}\n-\n-impl GetEnvSysCall {\n-    pub fn perform(key: &OsStr) -> Option<OsString> {\n-        let key_buf = &AsInner::as_inner(key).inner;\n-        receive_buffer(64, |buffer| {\n-            let mut call_record = GetEnvSysCall {\n-                key_len: key_buf.len(),\n-                key_ptr: key_buf.as_ptr(),\n-                value_len: buffer.len(),\n-                value_ptr: buffer.as_mut_ptr(),\n-                result: !0usize\n-            };\n-            if unsafe { syscall(SysCallIndex::GetEnv, &mut call_record) } {\n-                if call_record.result == !0usize {\n-                    Err(())\n-                } else {\n-                    Ok(call_record.result)\n-                }\n-            } else {\n-                Err(())\n-            }\n-        }).ok().map(|s| {\n-            FromInner::from_inner(Buf { inner: s })\n-        })\n-    }\n-}\n-\n-#[repr(C)]\n-pub struct SetEnvSysCall {\n-    key_ptr: *const u8,\n-    key_len: usize,\n-    value_ptr: *const u8,\n-    value_len: usize\n-}\n-\n-impl SetEnvSysCall {\n-    pub fn perform(key: &OsStr, value: Option<&OsStr>) {\n-        let key_buf = &AsInner::as_inner(key).inner;\n-        let value_buf = value.map(|v| &AsInner::as_inner(v).inner);\n-        let mut call_record = SetEnvSysCall {\n-            key_len: key_buf.len(),\n-            key_ptr: key_buf.as_ptr(),\n-            value_len: value_buf.map(|v| v.len()).unwrap_or(!0usize),\n-            value_ptr: value_buf.map(|v| v.as_ptr()).unwrap_or(ptr::null())\n-        };\n-        unsafe { syscall(SysCallIndex::SetEnv, &mut call_record); }\n-    }\n-}\n-\n-pub enum TimeClock {\n-    Monotonic = 0,\n-    System = 1,\n-}\n-\n-#[repr(C)]\n-pub struct TimeSysCall {\n-    clock: usize,\n-    secs_hi: usize,\n-    secs_lo: usize,\n-    nanos: usize\n-}\n-\n-impl TimeSysCall {\n-    pub fn perform(clock: TimeClock) -> Duration {\n-        let mut call_record = TimeSysCall {\n-            clock: clock as usize,\n-            secs_hi: 0,\n-            secs_lo: 0,\n-            nanos: 0\n-        };\n-        if unsafe { syscall(SysCallIndex::Time, &mut call_record) } {\n-            Duration::new(\n-                ((call_record.secs_hi as u64) << 32) | (call_record.secs_lo as u64),\n-                call_record.nanos as u32\n-            )\n-        } else {\n-            panic!(\"Time system call is not implemented by WebAssembly host\");\n-        }\n-    }\n-}\n-\n-unsafe fn syscall<T>(index: SysCallIndex, data: &mut T) -> bool {\n-    #[cfg(feature = \"wasm_syscall\")]\n-    extern {\n-        #[no_mangle]\n-        fn rust_wasm_syscall(index: usize, data: *mut Void) -> usize;\n-    }\n-\n-    #[cfg(not(feature = \"wasm_syscall\"))]\n-    unsafe fn rust_wasm_syscall(_index: usize, _data: *mut Void) -> usize { 0 }\n-\n-    rust_wasm_syscall(index as usize, data as *mut T as *mut Void) != 0\n-}"}, {"sha": "890049e8bfae50f0fb7cc815730f4a72d7403efc", "filename": "src/libstd/sys/wasm/os.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -4,7 +4,7 @@ use crate::fmt;\n use crate::io;\n use crate::path::{self, PathBuf};\n use crate::str;\n-use crate::sys::{unsupported, Void, ExitSysCall, GetEnvSysCall, SetEnvSysCall};\n+use crate::sys::{unsupported, Void};\n \n pub fn errno() -> i32 {\n     0\n@@ -73,16 +73,16 @@ pub fn env() -> Env {\n     panic!(\"not supported on web assembly\")\n }\n \n-pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n-    Ok(GetEnvSysCall::perform(k))\n+pub fn getenv(_: &OsStr) -> io::Result<Option<OsString>> {\n+    Ok(None)\n }\n \n-pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n-    Ok(SetEnvSysCall::perform(k, Some(v)))\n+pub fn setenv(_: &OsStr, _: &OsStr) -> io::Result<()> {\n+    Err(io::Error::new(io::ErrorKind::Other, \"cannot set env vars on wasm32-unknown-unknown\"))\n }\n \n-pub fn unsetenv(k: &OsStr) -> io::Result<()> {\n-    Ok(SetEnvSysCall::perform(k, None))\n+pub fn unsetenv(_: &OsStr) -> io::Result<()> {\n+    Err(io::Error::new(io::ErrorKind::Other, \"cannot unset env vars on wasm32-unknown-unknown\"))\n }\n \n pub fn temp_dir() -> PathBuf {\n@@ -94,7 +94,9 @@ pub fn home_dir() -> Option<PathBuf> {\n }\n \n pub fn exit(_code: i32) -> ! {\n-    ExitSysCall::perform(_code as isize as usize)\n+    unsafe {\n+        crate::arch::wasm32::unreachable();\n+    }\n }\n \n pub fn getpid() -> u32 {"}, {"sha": "5a4e4505e93bddce1805a1f163e2df0c66bc7cfd", "filename": "src/libstd/sys/wasm/stdio.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -1,5 +1,4 @@\n use crate::io;\n-use crate::sys::{ReadSysCall, WriteSysCall};\n \n pub struct Stdin;\n pub struct Stdout;\n@@ -12,8 +11,8 @@ impl Stdin {\n }\n \n impl io::Read for Stdin {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        Ok(ReadSysCall::perform(0, buf))\n+    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {\n+        Ok(0)\n     }\n }\n \n@@ -25,7 +24,6 @@ impl Stdout {\n \n impl io::Write for Stdout {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        WriteSysCall::perform(1, buf);\n         Ok(buf.len())\n     }\n \n@@ -42,7 +40,6 @@ impl Stderr {\n \n impl io::Write for Stderr {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        WriteSysCall::perform(2, buf);\n         Ok(buf.len())\n     }\n \n@@ -57,10 +54,6 @@ pub fn is_ebadf(_err: &io::Error) -> bool {\n     true\n }\n \n-pub fn panic_output() -> Option<impl io::Write> {\n-    if cfg!(feature = \"wasm_syscall\") {\n-        Stderr::new().ok()\n-    } else {\n-        None\n-    }\n+pub fn panic_output() -> Option<Vec<u8>> {\n+    None\n }"}, {"sha": "dd9ad3760b050799dbd200bbcacdfbb03429db83", "filename": "src/libstd/sys/wasm/time.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -1,5 +1,4 @@\n use crate::time::Duration;\n-use crate::sys::{TimeSysCall, TimeClock};\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n pub struct Instant(Duration);\n@@ -11,7 +10,7 @@ pub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));\n \n impl Instant {\n     pub fn now() -> Instant {\n-        Instant(TimeSysCall::perform(TimeClock::Monotonic))\n+        panic!(\"time not implemented on wasm32-unknown-unknown\")\n     }\n \n     pub const fn zero() -> Instant {\n@@ -37,7 +36,7 @@ impl Instant {\n \n impl SystemTime {\n     pub fn now() -> SystemTime {\n-        SystemTime(TimeSysCall::perform(TimeClock::System))\n+        panic!(\"time not implemented on wasm32-unknown-unknown\")\n     }\n \n     pub fn sub_time(&self, other: &SystemTime)"}, {"sha": "345d10bc4b9ea59d3c4216b4055b564d9b8a1265", "filename": "src/test/run-make-fulldeps/lto-empty/Makefile", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2FMakefile?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -0,0 +1,12 @@\n+-include ../tools.mk\n+\n+all: cdylib-fat cdylib-thin\n+\n+cdylib-fat:\n+\t$(RUSTC) lib.rs -C lto=fat -C opt-level=3 -C incremental=$(TMPDIR)/inc-fat\n+\t$(RUSTC) lib.rs -C lto=fat -C opt-level=3 -C incremental=$(TMPDIR)/inc-fat\n+\n+cdylib-thin:\n+\t$(RUSTC) lib.rs -C lto=thin -C opt-level=3 -C incremental=$(TMPDIR)/inc-thin\n+\t$(RUSTC) lib.rs -C lto=thin -C opt-level=3 -C incremental=$(TMPDIR)/inc-thin\n+"}, {"sha": "e3663c79078f4f0823ebbb7baf5fc65a1512c15a", "filename": "src/test/run-make-fulldeps/lto-empty/lib.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2Flib.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -0,0 +1 @@\n+#![crate_type = \"cdylib\"]"}, {"sha": "bb6af7995a0ad15445befc2c4d13c552421c239d", "filename": "src/test/rustdoc/assoc-consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-consts.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -95,5 +95,5 @@ impl Qux for Bar {\n     /// Docs for QUX_DEFAULT1 in impl.\n     const QUX_DEFAULT1: i16 = 7;\n     // @has - '//*[@id=\"associatedconstant.QUX_DEFAULT2\"]' 'const QUX_DEFAULT2: u32'\n-    // @has - '//*[@class=\"docblock\"]' \"Docs for QUX_DEFAULT2 in trait.\"\n+    // @has - '//*[@class=\"docblock hidden\"]' \"Docs for QUX_DEFAULT2 in trait.\"\n }"}, {"sha": "7eb3e43cb114e0b0779d55d904efe9b64ad3206d", "filename": "src/test/rustdoc/inline_cross/assoc-items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc-items.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -16,15 +16,15 @@ extern crate assoc_items;\n // @has - '//*[@id=\"associatedconstant.ConstNoDefault\"]' 'const ConstNoDefault: i16'\n // @has - '//*[@class=\"docblock\"]' 'dox for ConstNoDefault'\n // @has - '//*[@id=\"associatedconstant.ConstWithDefault\"]' 'const ConstWithDefault: u16'\n-// @has - '//*[@class=\"docblock\"]' 'docs for ConstWithDefault'\n+// @has - '//*[@class=\"docblock hidden\"]' 'docs for ConstWithDefault'\n // @has - '//*[@id=\"associatedtype.TypeNoDefault\"]' 'type TypeNoDefault = i32'\n // @has - '//*[@class=\"docblock\"]' 'dox for TypeNoDefault'\n // @has - '//*[@id=\"associatedtype.TypeWithDefault\"]' 'type TypeWithDefault = u32'\n-// @has - '//*[@class=\"docblock\"]' 'docs for TypeWithDefault'\n+// @has - '//*[@class=\"docblock hidden\"]' 'docs for TypeWithDefault'\n // @has - '//*[@id=\"method.method_no_default\"]' 'fn method_no_default()'\n // @has - '//*[@class=\"docblock\"]' 'dox for method_no_default'\n // @has - '//*[@id=\"method.method_with_default\"]' 'fn method_with_default()'\n-// @has - '//*[@class=\"docblock\"]' 'docs for method_with_default'\n+// @has - '//*[@class=\"docblock hidden\"]' 'docs for method_with_default'\n pub use assoc_items::MyStruct;\n \n // @has foo/trait.MyTrait.html"}, {"sha": "4591bb526ae77424d4e229049f3bb5b20255ce7b", "filename": "src/test/rustdoc/inline_cross/impl-inline-without-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl-inline-without-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl-inline-without-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl-inline-without-trait.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -8,5 +8,5 @@ extern crate impl_inline_without_trait;\n \n // @has 'foo/struct.MyStruct.html'\n // @has - '//*[@id=\"method.my_trait_method\"]' 'fn my_trait_method()'\n-// @has - '//*[@class=\"docblock\"]' 'docs for my_trait_method'\n+// @has - '//*[@class=\"docblock hidden\"]' 'docs for my_trait_method'\n pub use impl_inline_without_trait::MyStruct;"}, {"sha": "11ddab5f7ff26a3f65131ff0bd2ca690a575369f", "filename": "src/test/rustdoc/manual_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Ftest%2Frustdoc%2Fmanual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Ftest%2Frustdoc%2Fmanual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmanual_impl.rs?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -24,10 +24,10 @@ pub trait T {\n // @has  - '//*[@class=\"docblock\"]' 'Docs associated with the S1 trait implementation.'\n // @has  - '//*[@class=\"docblock\"]' 'Docs associated with the S1 trait a_method implementation.'\n // @!has - '//*[@class=\"docblock\"]' 'Docs associated with the trait a_method definition.'\n-// @has - '//*[@class=\"docblock\"]' 'Docs associated with the trait b_method definition.'\n-// @has - '//*[@class=\"docblock\"]' 'Docs associated with the trait c_method definition.'\n+// @has - '//*[@class=\"docblock hidden\"]' 'Docs associated with the trait b_method definition.'\n+// @has - '//*[@class=\"docblock hidden\"]' 'Docs associated with the trait c_method definition.'\n // @!has - '//*[@class=\"docblock\"]' 'There is another line'\n-// @has - '//*[@class=\"docblock\"]' 'Read more'\n+// @has - '//*[@class=\"docblock hidden\"]' 'Read more'\n pub struct S1(usize);\n \n /// Docs associated with the S1 trait implementation.\n@@ -44,7 +44,7 @@ impl T for S1 {\n // @has  - '//*[@class=\"docblock\"]' 'Docs associated with the S2 trait c_method implementation.'\n // @!has - '//*[@class=\"docblock\"]' 'Docs associated with the trait a_method definition.'\n // @!has - '//*[@class=\"docblock\"]' 'Docs associated with the trait c_method definition.'\n-// @has - '//*[@class=\"docblock\"]' 'Docs associated with the trait b_method definition.'\n+// @has - '//*[@class=\"docblock hidden\"]' 'Docs associated with the trait b_method definition.'\n pub struct S2(usize);\n \n /// Docs associated with the S2 trait implementation."}, {"sha": "b7a930b61cc96aed4b73d9adc82ce62250d63d61", "filename": "src/test/ui/lto-duplicate-symbols.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbdf1d2a71c89a731ed15d93af7abffa80176834/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr?ref=fbdf1d2a71c89a731ed15d93af7abffa80176834", "patch": "@@ -1,6 +1,6 @@\n warning: Linking globals named 'foo': symbol multiply defined!\n \n-error: failed to load bc of \"lto_duplicate_symbols1.3a1fbbbh-cgu.0\": \n+error: failed to load bc of \"lto_duplicate_symbols2.3a1fbbbh-cgu.0\": \n \n error: aborting due to previous error\n "}]}