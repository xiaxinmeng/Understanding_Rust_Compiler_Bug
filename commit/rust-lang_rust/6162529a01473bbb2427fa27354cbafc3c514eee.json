{"sha": "6162529a01473bbb2427fa27354cbafc3c514eee", "node_id": "C_kwDOAAsO6NoAKDYxNjI1MjlhMDE0NzNiYmIyNDI3ZmEyNzM1NGNiYWZjM2M1MTRlZWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-20T07:21:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-20T07:21:01Z"}, "message": "Auto merge of #89100 - petrochenkov:localbind, r=cjgillot\n\nresolve: Use `NameBinding` for local variables and generic parameters\n\n`NameBinding` is a structure used for representing any name introduction (an item, or import, or even a built-in).\nExcept that local variables and generic parameters weren't represented as `NameBinding`s, for this reason they requires separate paths in name resolution code in several places.\n\nThis PR introduces `NameBinding`s for local variables as well and simplifies all the code working with them leaving only the `NameBinding` paths.", "tree": {"sha": "ada1156ba17179deaca7ba04d89a4410a2aeeb72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ada1156ba17179deaca7ba04d89a4410a2aeeb72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6162529a01473bbb2427fa27354cbafc3c514eee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6162529a01473bbb2427fa27354cbafc3c514eee", "html_url": "https://github.com/rust-lang/rust/commit/6162529a01473bbb2427fa27354cbafc3c514eee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6162529a01473bbb2427fa27354cbafc3c514eee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42983a28ab3c70728da7a9b932b667c978dd898d", "url": "https://api.github.com/repos/rust-lang/rust/commits/42983a28ab3c70728da7a9b932b667c978dd898d", "html_url": "https://github.com/rust-lang/rust/commit/42983a28ab3c70728da7a9b932b667c978dd898d"}, {"sha": "c1e8fc8c97831ac1d167e54c3d7b84305c697b87", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1e8fc8c97831ac1d167e54c3d7b84305c697b87", "html_url": "https://github.com/rust-lang/rust/commit/c1e8fc8c97831ac1d167e54c3d7b84305c697b87"}], "stats": {"total": 358, "additions": 145, "deletions": 213}, "files": [{"sha": "fbb1a868bdefd683103bb3b08196781f2d54606b", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 87, "deletions": 74, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/6162529a01473bbb2427fa27354cbafc3c514eee/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6162529a01473bbb2427fa27354cbafc3c514eee/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=6162529a01473bbb2427fa27354cbafc3c514eee", "patch": "@@ -7,7 +7,7 @@\n \n use RibKind::*;\n \n-use crate::{path_names_to_string, BindingError, CrateLint, LexicalScopeBinding};\n+use crate::{path_names_to_string, BindingError, CrateLint, NameBinding, ToNameBinding};\n use crate::{Module, ModuleOrUniformRoot, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n@@ -21,27 +21,22 @@ use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::{PrimTy, TraitCandidate};\n-use rustc_middle::{bug, span_bug};\n+use rustc_middle::{bug, span_bug, ty};\n use rustc_session::lint;\n+use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n+use tracing::debug;\n \n-use rustc_span::source_map::{respan, Spanned};\n use std::collections::{hash_map::Entry, BTreeSet};\n use std::mem::{replace, take};\n-use tracing::debug;\n \n mod diagnostics;\n crate mod lifetimes;\n \n type Res = def::Res<NodeId>;\n \n-type IdentMap<T> = FxHashMap<Ident, T>;\n-\n-/// Map from the name in a pattern to its binding mode.\n-type BindingMap = IdentMap<BindingInfo>;\n-\n #[derive(Copy, Clone, Debug)]\n struct BindingInfo {\n     span: Span,\n@@ -172,8 +167,8 @@ impl RibKind<'_> {\n /// The resolution keeps a separate stack of ribs as it traverses the AST for each namespace. When\n /// resolving, the name is looked up from inside out.\n #[derive(Debug)]\n-crate struct Rib<'a, R = Res> {\n-    pub bindings: IdentMap<R>,\n+crate struct Rib<'a, R = &'a NameBinding<'a>> {\n+    pub bindings: FxHashMap<Ident, R>,\n     pub kind: RibKind<'a>,\n }\n \n@@ -567,12 +562,12 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                 GenericParamKind::Type { .. } => {\n                     forward_ty_ban_rib\n                         .bindings\n-                        .insert(Ident::with_dummy_span(param.ident.name), Res::Err);\n+                        .insert(Ident::with_dummy_span(param.ident.name), self.r.dummy_binding);\n                 }\n                 GenericParamKind::Const { .. } => {\n                     forward_const_ban_rib\n                         .bindings\n-                        .insert(Ident::with_dummy_span(param.ident.name), Res::Err);\n+                        .insert(Ident::with_dummy_span(param.ident.name), self.r.dummy_binding);\n                 }\n                 GenericParamKind::Lifetime => {}\n             }\n@@ -589,7 +584,9 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         // such as in the case of `trait Add<Rhs = Self>`.)\n         if self.diagnostic_metadata.current_self_item.is_some() {\n             // (`Some` if + only if we are in ADT's generics.)\n-            forward_ty_ban_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), Res::Err);\n+            forward_ty_ban_rib\n+                .bindings\n+                .insert(Ident::with_dummy_span(kw::SelfUpper), self.r.dummy_binding);\n         }\n \n         for param in &generics.params {\n@@ -737,15 +734,17 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         ns: Namespace,\n         record_used_id: Option<NodeId>,\n         path_span: Span,\n-    ) -> Option<LexicalScopeBinding<'a>> {\n-        self.r.resolve_ident_in_lexical_scope(\n-            ident,\n-            ns,\n-            &self.parent_scope,\n-            record_used_id,\n-            path_span,\n-            &self.ribs[ns],\n-        )\n+    ) -> Option<&'a NameBinding<'a>> {\n+        self.r\n+            .resolve_ident_in_lexical_scope(\n+                ident,\n+                ns,\n+                &self.parent_scope,\n+                record_used_id,\n+                path_span,\n+                &self.ribs[ns],\n+            )\n+            .ok()\n     }\n \n     fn resolve_path(\n@@ -903,6 +902,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn future_proof_import(&mut self, use_tree: &UseTree) {\n+        if !self.should_report_errs() {\n+            return;\n+        }\n+\n         let segments = &use_tree.prefix.segments;\n         if !segments.is_empty() {\n             let ident = segments[0].ident;\n@@ -914,31 +917,42 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 UseTreeKind::Simple(..) if segments.len() == 1 => &[TypeNS, ValueNS][..],\n                 _ => &[TypeNS],\n             };\n+\n+            let from_ribs = |binding: &NameBinding<'_>| {\n+                matches!(\n+                    binding.res(),\n+                    Res::Local(..)\n+                        | Res::SelfTy(..)\n+                        | Res::Def(DefKind::TyParam | DefKind::ConstParam, ..)\n+                )\n+            };\n             let report_error = |this: &Self, ns| {\n                 let what = if ns == TypeNS { \"type parameters\" } else { \"local variables\" };\n-                if this.should_report_errs() {\n-                    this.r\n-                        .session\n-                        .span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n-                }\n+                let msg = format!(\"imports cannot refer to {what}\");\n+                this.r.session.span_err(ident.span, &msg);\n             };\n \n             for &ns in nss {\n-                match self.resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span) {\n-                    Some(LexicalScopeBinding::Res(..)) => {\n+                if let Some(binding) =\n+                    self.resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span)\n+                {\n+                    if from_ribs(binding) {\n                         report_error(self, ns);\n-                    }\n-                    Some(LexicalScopeBinding::Item(binding)) => {\n+                    } else {\n                         let orig_unusable_binding =\n                             replace(&mut self.r.unusable_binding, Some(binding));\n-                        if let Some(LexicalScopeBinding::Res(..)) = self\n-                            .resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span)\n-                        {\n-                            report_error(self, ns);\n+                        if let Some(binding) = self.resolve_ident_in_lexical_scope(\n+                            ident,\n+                            ns,\n+                            None,\n+                            use_tree.prefix.span,\n+                        ) {\n+                            if from_ribs(binding) {\n+                                report_error(self, ns);\n+                            }\n                         }\n                         self.r.unusable_binding = orig_unusable_binding;\n                     }\n-                    None => {}\n                 }\n             }\n         } else if let UseTreeKind::Nested(use_trees) = &use_tree.kind {\n@@ -1135,8 +1149,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 _ => unreachable!(),\n             };\n             let res = Res::Def(def_kind, self.r.local_def_id(param.id).to_def_id());\n+            let binding =\n+                (res, ty::Visibility::Invisible, param.ident.span, self.parent_scope.expansion)\n+                    .to_name_binding(self.r.arenas);\n+\n             self.r.record_partial_res(param.id, PartialRes::new(res));\n-            rib.bindings.insert(ident, res);\n+            rib.bindings.insert(ident, binding);\n         }\n \n         self.ribs[ValueNS].push(function_value_rib);\n@@ -1256,10 +1274,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn with_self_rib_ns(&mut self, ns: Namespace, self_res: Res, f: impl FnOnce(&mut Self)) {\n+        let binding = (self_res, ty::Visibility::Invisible, DUMMY_SP, self.parent_scope.expansion)\n+            .to_name_binding(self.r.arenas);\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // Plain insert (no renaming, since types are not currently hygienic)\n-        self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), self_res);\n+        self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), binding);\n         self.ribs[ns].push(self_type_rib);\n         f(self);\n         self.ribs[ns].pop();\n@@ -1470,7 +1490,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     /// this is done hygienically. This could arise for a macro\n     /// that expands into an or-pattern where one 'x' was from the\n     /// user and one 'x' came from the macro.\n-    fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n+    fn binding_mode_map(&mut self, pat: &Pat) -> FxHashMap<Ident, BindingInfo> {\n         let mut binding_map = FxHashMap::default();\n \n         pat.walk(&mut |pat| {\n@@ -1503,7 +1523,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n     /// Checks that all of the arms in an or-pattern have exactly the\n     /// same set of bindings, with the same binding modes for each.\n-    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) -> Vec<BindingMap> {\n+    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) -> Vec<FxHashMap<Ident, BindingInfo>> {\n         let mut missing_vars = FxHashMap::default();\n         let mut inconsistent_vars = FxHashMap::default();\n \n@@ -1645,7 +1665,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         .try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n                         .unwrap_or_else(|| self.fresh_binding(ident, pat.id, pat_src, bindings));\n                     self.r.record_partial_res(pat.id, PartialRes::new(res));\n-                    self.r.record_pat_span(pat.id, pat.span);\n                 }\n                 PatKind::TupleStruct(ref qself, ref path, ref sub_patterns) => {\n                     self.smart_resolve_path(\n@@ -1735,18 +1754,24 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         if already_bound_or {\n             // `Variant1(a) | Variant2(a)`, ok\n             // Reuse definition from the first `a`.\n-            self.innermost_rib_bindings(ValueNS)[&ident]\n+            self.innermost_rib_bindings(ValueNS)[&ident].res()\n         } else {\n             let res = Res::Local(pat_id);\n             if ident_valid {\n                 // A completely fresh binding add to the set if it's valid.\n-                self.innermost_rib_bindings(ValueNS).insert(ident, res);\n+                let binding =\n+                    (res, ty::Visibility::Invisible, ident.span, self.parent_scope.expansion)\n+                        .to_name_binding(self.r.arenas);\n+                self.innermost_rib_bindings(ValueNS).insert(ident, binding);\n             }\n             res\n         }\n     }\n \n-    fn innermost_rib_bindings(&mut self, ns: Namespace) -> &mut IdentMap<Res> {\n+    fn innermost_rib_bindings(\n+        &mut self,\n+        ns: Namespace,\n+    ) -> &mut FxHashMap<Ident, &'a NameBinding<'a>> {\n         &mut self.ribs[ns].last_mut().unwrap().bindings\n     }\n \n@@ -1763,32 +1788,25 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // also be interpreted as a path to e.g. a constant, variant, etc.\n         let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Not);\n \n-        let ls_binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, pat.span)?;\n-        let (res, binding) = match ls_binding {\n-            LexicalScopeBinding::Item(binding)\n-                if is_syntactic_ambiguity && binding.is_ambiguity() =>\n-            {\n-                // For ambiguous bindings we don't know all their definitions and cannot check\n-                // whether they can be shadowed by fresh bindings or not, so force an error.\n-                // issues/33118#issuecomment-233962221 (see below) still applies here,\n-                // but we have to ignore it for backward compatibility.\n-                self.r.record_use(ident, binding, false);\n-                return None;\n-            }\n-            LexicalScopeBinding::Item(binding) => (binding.res(), Some(binding)),\n-            LexicalScopeBinding::Res(res) => (res, None),\n-        };\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, pat.span)?;\n+        if is_syntactic_ambiguity && binding.is_ambiguity() {\n+            // For ambiguous bindings we don't know all their definitions and cannot check\n+            // whether they can be shadowed by fresh bindings or not, so force an error.\n+            // issues/33118#issuecomment-233962221 (see below) still applies here,\n+            // but we have to ignore it for backward compatibility.\n+            self.r.record_use(ident, binding, false);\n+            return None;\n+        }\n \n+        let res = binding.res();\n         match res {\n             Res::SelfCtor(_) // See #70549.\n             | Res::Def(\n                 DefKind::Ctor(_, CtorKind::Const) | DefKind::Const | DefKind::ConstParam,\n                 _,\n             ) if is_syntactic_ambiguity => {\n                 // Disambiguate in favor of a unit struct/variant or constant pattern.\n-                if let Some(binding) = binding {\n-                    self.r.record_use(ident, binding, false);\n-                }\n+                self.r.record_use(ident, binding, false);\n                 Some(res)\n             }\n             Res::Def(DefKind::Ctor(..) | DefKind::Const | DefKind::Static, _) => {\n@@ -1797,7 +1815,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // to something unusable as a pattern (e.g., constructor function),\n                 // but we still conservatively report an error, see\n                 // issues/33118#issuecomment-233962221 for one reason why.\n-                let binding = binding.expect(\"no binding for a ctor or static\");\n                 self.report_error(\n                     ident.span,\n                     ResolutionError::BindingShadowsSomethingUnacceptable {\n@@ -2037,19 +2054,15 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn self_type_is_available(&mut self, span: Span) -> bool {\n-        let binding = self.resolve_ident_in_lexical_scope(\n-            Ident::with_dummy_span(kw::SelfUpper),\n-            TypeNS,\n-            None,\n-            span,\n-        );\n-        if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n+        let ident = Ident::with_dummy_span(kw::SelfUpper);\n+        self.resolve_ident_in_lexical_scope(ident, TypeNS, None, span)\n+            .map_or(false, |binding| binding.res() != Res::Err)\n     }\n \n     fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n         let ident = Ident::new(kw::SelfLower, self_span);\n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span);\n-        if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n+        self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span)\n+            .map_or(false, |binding| binding.res() != Res::Err)\n     }\n \n     /// A wrapper around [`Resolver::report_error`]."}, {"sha": "506f154975383357bf2be7aaaf4a736f9dfd6de7", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6162529a01473bbb2427fa27354cbafc3c514eee/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6162529a01473bbb2427fa27354cbafc3c514eee/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=6162529a01473bbb2427fa27354cbafc3c514eee", "patch": "@@ -1294,7 +1294,8 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             // Walk backwards up the ribs in scope and collect candidates.\n             for rib in self.ribs[ns].iter().rev() {\n                 // Locals and type parameters\n-                for (ident, &res) in &rib.bindings {\n+                for (ident, binding) in &rib.bindings {\n+                    let res = binding.res();\n                     if filter_fn(res) {\n                         names.push(TypoSuggestion::typo_from_res(ident.name, res));\n                     }"}, {"sha": "042c6a9246040febb7c0de81d14e62da4bce77f6", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 56, "deletions": 138, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/6162529a01473bbb2427fa27354cbafc3c514eee/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6162529a01473bbb2427fa27354cbafc3c514eee/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=6162529a01473bbb2427fa27354cbafc3c514eee", "patch": "@@ -373,26 +373,6 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n     }\n }\n \n-/// An intermediate resolution result.\n-///\n-/// This refers to the thing referred by a name. The difference between `Res` and `Item` is that\n-/// items are visible in their whole block, while `Res`es only from the place they are defined\n-/// forward.\n-#[derive(Debug)]\n-enum LexicalScopeBinding<'a> {\n-    Item(&'a NameBinding<'a>),\n-    Res(Res),\n-}\n-\n-impl<'a> LexicalScopeBinding<'a> {\n-    fn res(self) -> Res {\n-        match self {\n-            LexicalScopeBinding::Item(binding) => binding.res(),\n-            LexicalScopeBinding::Res(res) => res,\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug)]\n enum ModuleOrUniformRoot<'a> {\n     /// Regular module.\n@@ -918,10 +898,6 @@ pub struct Resolver<'a> {\n     /// \"self-confirming\" import resolutions during import validation.\n     unusable_binding: Option<&'a NameBinding<'a>>,\n \n-    // Spans for local variables found during pattern resolution.\n-    // Used for suggestions during error reporting.\n-    pat_span_map: NodeMap<Span>,\n-\n     /// Resolutions for nodes that have a single resolution.\n     partial_res_map: NodeMap<PartialRes>,\n     /// Resolutions for import nodes, which have multiple resolutions in different namespaces.\n@@ -1332,7 +1308,6 @@ impl<'a> Resolver<'a> {\n             last_import_segment: false,\n             unusable_binding: None,\n \n-            pat_span_map: Default::default(),\n             partial_res_map: Default::default(),\n             import_res_map: Default::default(),\n             label_res_map: Default::default(),\n@@ -1358,13 +1333,8 @@ impl<'a> Resolver<'a> {\n             macro_expanded_macro_export_errors: BTreeSet::new(),\n \n             arenas,\n-            dummy_binding: arenas.alloc_name_binding(NameBinding {\n-                kind: NameBindingKind::Res(Res::Err, false),\n-                ambiguity: None,\n-                expansion: LocalExpnId::ROOT,\n-                span: DUMMY_SP,\n-                vis: ty::Visibility::Public,\n-            }),\n+            dummy_binding: (Res::Err, ty::Visibility::Public, DUMMY_SP, LocalExpnId::ROOT)\n+                .to_name_binding(arenas),\n \n             crate_loader: CrateLoader::new(session, metadata_loader, crate_name),\n             macro_names: FxHashSet::default(),\n@@ -1921,11 +1891,11 @@ impl<'a> Resolver<'a> {\n         record_used_id: Option<NodeId>,\n         path_span: Span,\n         ribs: &[Rib<'a>],\n-    ) -> Option<LexicalScopeBinding<'a>> {\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         assert!(ns == TypeNS || ns == ValueNS);\n         let orig_ident = ident;\n         if ident.name == kw::Empty {\n-            return Some(LexicalScopeBinding::Res(Res::Err));\n+            return Ok(self.dummy_binding);\n         }\n         let (general_span, normalized_span) = if ident.name == kw::SelfUpper {\n             // FIXME(jseyfried) improve `Self` hygiene\n@@ -1948,18 +1918,30 @@ impl<'a> Resolver<'a> {\n             // Use the rib kind to determine whether we are resolving parameters\n             // (macro 2.0 hygiene) or local variables (`macro_rules` hygiene).\n             let rib_ident = if ribs[i].kind.contains_params() { normalized_ident } else { ident };\n-            if let Some((original_rib_ident_def, res)) = ribs[i].bindings.get_key_value(&rib_ident)\n+            if let Some((&original_rib_ident_def, &binding)) =\n+                ribs[i].bindings.get_key_value(&rib_ident)\n             {\n                 // The ident resolves to a type parameter or local variable.\n-                return Some(LexicalScopeBinding::Res(self.validate_res_from_ribs(\n+                let res = self.validate_res_from_ribs(\n                     i,\n                     rib_ident,\n-                    *res,\n+                    binding.res(),\n                     record_used,\n                     path_span,\n-                    *original_rib_ident_def,\n+                    original_rib_ident_def,\n                     ribs,\n-                )));\n+                );\n+\n+                // We have to create a new binding in case of validation errors,\n+                // or in case of const generic hack changing the resolution.\n+                return Ok(if res != binding.res() {\n+                    self.arenas.alloc_name_binding(NameBinding {\n+                        kind: NameBindingKind::Res(res, false),\n+                        ..binding.clone()\n+                    })\n+                } else {\n+                    binding\n+                });\n             }\n \n             module = match ribs[i].kind {\n@@ -1978,17 +1960,17 @@ impl<'a> Resolver<'a> {\n                 _ => break,\n             }\n \n-            let item = self.resolve_ident_in_module_unadjusted(\n+            let binding = self.resolve_ident_in_module_unadjusted(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n                 parent_scope,\n                 record_used,\n                 path_span,\n             );\n-            if let Ok(binding) = item {\n+            if binding.is_ok() {\n                 // The ident resolves to an item.\n-                return Some(LexicalScopeBinding::Item(binding));\n+                return binding;\n             }\n         }\n         self.early_resolve_ident_in_lexical_scope(\n@@ -1999,8 +1981,6 @@ impl<'a> Resolver<'a> {\n             record_used,\n             path_span,\n         )\n-        .ok()\n-        .map(LexicalScopeBinding::Item)\n     }\n \n     fn hygienic_lexical_parent(\n@@ -2225,16 +2205,6 @@ impl<'a> Resolver<'a> {\n \n         for (i, &Segment { ident, id, has_generic_args: _ }) in path.iter().enumerate() {\n             debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n-            let record_segment_res = |this: &mut Self, res| {\n-                if record_used {\n-                    if let Some(id) = id {\n-                        if !this.partial_res_map.contains_key(&id) {\n-                            assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n-                            this.record_partial_res(id, PartialRes::new(res));\n-                        }\n-                    }\n-                }\n-            };\n \n             let is_last = i == path.len() - 1;\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n@@ -2313,12 +2283,8 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n \n-            enum FindBindingResult<'a> {\n-                Binding(Result<&'a NameBinding<'a>, Determinacy>),\n-                PathResult(PathResult<'a>),\n-            }\n             let find_binding_in_ns = |this: &mut Self, ns| {\n-                let binding = if let Some(module) = module {\n+                if let Some(module) = module {\n                     this.resolve_ident_in_module(\n                         module,\n                         ident,\n@@ -2343,44 +2309,34 @@ impl<'a> Resolver<'a> {\n                     } else {\n                         None\n                     };\n-                    match this.resolve_ident_in_lexical_scope(\n+                    this.resolve_ident_in_lexical_scope(\n                         ident,\n                         ns,\n                         parent_scope,\n                         record_used_id,\n                         path_span,\n                         &ribs.unwrap()[ns],\n-                    ) {\n-                        // we found a locally-imported or available item/module\n-                        Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n-                        // we found a local variable or type param\n-                        Some(LexicalScopeBinding::Res(res))\n-                            if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) =>\n-                        {\n-                            record_segment_res(this, res);\n-                            return FindBindingResult::PathResult(PathResult::NonModule(\n-                                PartialRes::with_unresolved_segments(res, path.len() - 1),\n-                            ));\n-                        }\n-                        _ => Err(Determinacy::determined(record_used)),\n-                    }\n-                };\n-                FindBindingResult::Binding(binding)\n-            };\n-            let binding = match find_binding_in_ns(self, ns) {\n-                FindBindingResult::PathResult(x) => return x,\n-                FindBindingResult::Binding(binding) => binding,\n+                    )\n+                }\n             };\n-            match binding {\n+\n+            match find_binding_in_ns(self, ns) {\n                 Ok(binding) => {\n                     if i == 1 {\n                         second_binding = Some(binding);\n                     }\n                     let res = binding.res();\n+                    if record_used {\n+                        if let Some(id) = id {\n+                            if !self.partial_res_map.contains_key(&id) {\n+                                assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n+                                self.record_partial_res(id, PartialRes::new(res));\n+                            }\n+                        }\n+                    }\n                     let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(res);\n                     if let Some(next_module) = binding.module() {\n                         module = Some(ModuleOrUniformRoot::Module(next_module));\n-                        record_segment_res(self, res);\n                     } else if res == Res::ToolMod && i + 1 != path.len() {\n                         if binding.is_import() {\n                             self.session\n@@ -2470,56 +2426,25 @@ impl<'a> Resolver<'a> {\n                             .map_or(false, |c| c.is_ascii_uppercase())\n                         {\n                             // Check whether the name refers to an item in the value namespace.\n-                            let suggestion = if ribs.is_some() {\n-                                let match_span = match self.resolve_ident_in_lexical_scope(\n-                                    ident,\n-                                    ValueNS,\n-                                    parent_scope,\n-                                    None,\n-                                    path_span,\n-                                    &ribs.unwrap()[ValueNS],\n-                                ) {\n-                                    // Name matches a local variable. For example:\n-                                    // ```\n-                                    // fn f() {\n-                                    //     let Foo: &str = \"\";\n-                                    //     println!(\"{}\", Foo::Bar); // Name refers to local\n-                                    //                               // variable `Foo`.\n-                                    // }\n-                                    // ```\n-                                    Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n-                                        Some(*self.pat_span_map.get(&id).unwrap())\n-                                    }\n-\n-                                    // Name matches item from a local name binding\n-                                    // created by `use` declaration. For example:\n-                                    // ```\n-                                    // pub Foo: &str = \"\";\n-                                    //\n-                                    // mod submod {\n-                                    //     use super::Foo;\n-                                    //     println!(\"{}\", Foo::Bar); // Name refers to local\n-                                    //                               // binding `Foo`.\n-                                    // }\n-                                    // ```\n-                                    Some(LexicalScopeBinding::Item(name_binding)) => {\n-                                        Some(name_binding.span)\n-                                    }\n-                                    _ => None,\n-                                };\n-\n-                                if let Some(span) = match_span {\n-                                    Some((\n-                                        vec![(span, String::from(\"\"))],\n+                            let suggestion = ribs\n+                                .and_then(|ribs| {\n+                                    self.resolve_ident_in_lexical_scope(\n+                                        ident,\n+                                        ValueNS,\n+                                        parent_scope,\n+                                        None,\n+                                        path_span,\n+                                        &ribs[ValueNS],\n+                                    )\n+                                    .ok()\n+                                })\n+                                .map(|binding| {\n+                                    (\n+                                        vec![(binding.span, String::from(\"\"))],\n                                         format!(\"`{}` is defined here, but is not a type\", ident),\n                                         Applicability::MaybeIncorrect,\n-                                    ))\n-                                } else {\n-                                    None\n-                                }\n-                            } else {\n-                                None\n-                            };\n+                                    )\n+                                });\n \n                             (format!(\"use of undeclared type `{}`\", ident), suggestion)\n                         } else {\n@@ -2557,9 +2482,7 @@ impl<'a> Resolver<'a> {\n                         let mut msg = format!(\"could not find `{}` in {}\", ident, parent);\n                         if ns == TypeNS || ns == ValueNS {\n                             let ns_to_try = if ns == TypeNS { ValueNS } else { TypeNS };\n-                            if let FindBindingResult::Binding(Ok(binding)) =\n-                                find_binding_in_ns(self, ns_to_try)\n-                            {\n+                            if let Ok(binding) = find_binding_in_ns(self, ns_to_try) {\n                                 let mut found = |what| {\n                                     msg = format!(\n                                         \"expected {}, found {} `{}` in {}\",\n@@ -2901,11 +2824,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn record_pat_span(&mut self, node: NodeId, span: Span) {\n-        debug!(\"(recording pat) recording {:?} for {:?}\", node, span);\n-        self.pat_span_map.insert(node, span);\n-    }\n-\n     fn is_accessible_from(&self, vis: ty::Visibility, module: Module<'a>) -> bool {\n         vis.is_accessible_from(module.nearest_parent_mod(), self)\n     }"}]}