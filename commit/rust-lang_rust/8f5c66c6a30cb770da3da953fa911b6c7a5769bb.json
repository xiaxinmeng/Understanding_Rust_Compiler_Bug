{"sha": "8f5c66c6a30cb770da3da953fa911b6c7a5769bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNWM2NmM2YTMwY2I3NzBkYTNkYTk1M2ZhOTExYjZjN2E1NzY5YmI=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-04-23T20:25:50Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-04-24T22:05:10Z"}, "message": "Introduce BTreeMap benches of iter itself", "tree": {"sha": "952ccb9a8c1326ee1d916210a2066184141ec25f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/952ccb9a8c1326ee1d916210a2066184141ec25f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f5c66c6a30cb770da3da953fa911b6c7a5769bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5c66c6a30cb770da3da953fa911b6c7a5769bb", "html_url": "https://github.com/rust-lang/rust/commit/8f5c66c6a30cb770da3da953fa911b6c7a5769bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f5c66c6a30cb770da3da953fa911b6c7a5769bb/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3360cc3a0ea33c84d0b0b1163107b1c1acbf2a69", "url": "https://api.github.com/repos/rust-lang/rust/commits/3360cc3a0ea33c84d0b0b1163107b1c1acbf2a69", "html_url": "https://github.com/rust-lang/rust/commit/3360cc3a0ea33c84d0b0b1163107b1c1acbf2a69"}], "stats": {"total": 118, "additions": 72, "deletions": 46}, "files": [{"sha": "38d19c59ad186edfbad8b6d8f972320d9df57f22", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 72, "deletions": 46, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/8f5c66c6a30cb770da3da953fa911b6c7a5769bb/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5c66c6a30cb770da3da953fa911b6c7a5769bb/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=8f5c66c6a30cb770da3da953fa911b6c7a5769bb", "patch": "@@ -1,6 +1,6 @@\n use std::collections::BTreeMap;\n use std::iter::Iterator;\n-use std::ops::Bound::{Excluded, Unbounded};\n+use std::ops::RangeBounds;\n use std::vec::Vec;\n \n use rand::{seq::SliceRandom, thread_rng, Rng};\n@@ -117,7 +117,7 @@ map_find_rand_bench! {find_rand_10_000, 10_000, BTreeMap}\n map_find_seq_bench! {find_seq_100,    100,    BTreeMap}\n map_find_seq_bench! {find_seq_10_000, 10_000, BTreeMap}\n \n-fn bench_iter(b: &mut Bencher, size: i32) {\n+fn bench_iteration(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();\n     let mut rng = thread_rng();\n \n@@ -133,21 +133,21 @@ fn bench_iter(b: &mut Bencher, size: i32) {\n }\n \n #[bench]\n-pub fn iter_20(b: &mut Bencher) {\n-    bench_iter(b, 20);\n+pub fn iteration_20(b: &mut Bencher) {\n+    bench_iteration(b, 20);\n }\n \n #[bench]\n-pub fn iter_1000(b: &mut Bencher) {\n-    bench_iter(b, 1000);\n+pub fn iteration_1000(b: &mut Bencher) {\n+    bench_iteration(b, 1000);\n }\n \n #[bench]\n-pub fn iter_100000(b: &mut Bencher) {\n-    bench_iter(b, 100000);\n+pub fn iteration_100000(b: &mut Bencher) {\n+    bench_iteration(b, 100000);\n }\n \n-fn bench_iter_mut(b: &mut Bencher, size: i32) {\n+fn bench_iteration_mut(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();\n     let mut rng = thread_rng();\n \n@@ -163,18 +163,18 @@ fn bench_iter_mut(b: &mut Bencher, size: i32) {\n }\n \n #[bench]\n-pub fn iter_mut_20(b: &mut Bencher) {\n-    bench_iter_mut(b, 20);\n+pub fn iteration_mut_20(b: &mut Bencher) {\n+    bench_iteration_mut(b, 20);\n }\n \n #[bench]\n-pub fn iter_mut_1000(b: &mut Bencher) {\n-    bench_iter_mut(b, 1000);\n+pub fn iteration_mut_1000(b: &mut Bencher) {\n+    bench_iteration_mut(b, 1000);\n }\n \n #[bench]\n-pub fn iter_mut_100000(b: &mut Bencher) {\n-    bench_iter_mut(b, 100000);\n+pub fn iteration_mut_100000(b: &mut Bencher) {\n+    bench_iteration_mut(b, 100000);\n }\n \n fn bench_first_and_last(b: &mut Bencher, size: i32) {\n@@ -202,57 +202,83 @@ pub fn first_and_last_10k(b: &mut Bencher) {\n     bench_first_and_last(b, 10_000);\n }\n \n-#[bench]\n-pub fn range_excluded_excluded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+const BENCH_RANGE_SIZE: i32 = 145;\n+const BENCH_RANGE_COUNT: i32 = BENCH_RANGE_SIZE * (BENCH_RANGE_SIZE - 1) / 2;\n+\n+fn bench_range<F, R>(b: &mut Bencher, f: F)\n+where\n+    F: Fn(i32, i32) -> R,\n+    R: RangeBounds<i32>,\n+{\n+    let map: BTreeMap<_, _> = (0..BENCH_RANGE_SIZE).map(|i| (i, i)).collect();\n     b.iter(|| {\n-        for first in 0..size {\n-            for last in first + 1..size {\n-                black_box(map.range((Excluded(first), Excluded(last))));\n+        let mut c = 0;\n+        for i in 0..BENCH_RANGE_SIZE {\n+            for j in i + 1..BENCH_RANGE_SIZE {\n+                black_box(map.range(f(i, j)));\n+                c += 1;\n             }\n         }\n+        debug_assert_eq!(c, BENCH_RANGE_COUNT);\n     });\n }\n \n #[bench]\n-pub fn range_excluded_unbounded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| {\n-        for first in 0..size {\n-            black_box(map.range((Excluded(first), Unbounded)));\n-        }\n-    });\n+pub fn range_included_excluded(b: &mut Bencher) {\n+    bench_range(b, |i, j| i..j);\n }\n \n #[bench]\n pub fn range_included_included(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| {\n-        for first in 0..size {\n-            for last in first..size {\n-                black_box(map.range(first..=last));\n-            }\n-        }\n-    });\n+    bench_range(b, |i, j| i..=j);\n }\n \n #[bench]\n pub fn range_included_unbounded(b: &mut Bencher) {\n-    let size = 144;\n+    bench_range(b, |i, _| i..);\n+}\n+\n+#[bench]\n+pub fn range_unbounded_unbounded(b: &mut Bencher) {\n+    bench_range(b, |_, _| ..);\n+}\n+\n+fn bench_iter(b: &mut Bencher, repeats: i32, size: i32) {\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n     b.iter(|| {\n-        for first in 0..size {\n-            black_box(map.range(first..));\n+        for _ in 0..repeats {\n+            black_box(map.iter());\n         }\n     });\n }\n \n+/// Contrast range_unbounded_unbounded with `iter()`.\n #[bench]\n-pub fn range_unbounded_unbounded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| map.range(..));\n+pub fn range_unbounded_vs_iter(b: &mut Bencher) {\n+    bench_iter(b, BENCH_RANGE_COUNT, BENCH_RANGE_SIZE);\n+}\n+\n+#[bench]\n+pub fn iter_0(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 0);\n+}\n+\n+#[bench]\n+pub fn iter_1(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 1);\n+}\n+\n+#[bench]\n+pub fn iter_100(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 100);\n+}\n+\n+#[bench]\n+pub fn iter_10k(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 10_000);\n+}\n+\n+#[bench]\n+pub fn iter_1m(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 1_000_000);\n }"}]}