{"sha": "87102587149ce00d008c3463bf6283f5145b2f23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MTAyNTg3MTQ5Y2UwMGQwMDhjMzQ2M2JmNjI4M2Y1MTQ1YjJmMjM=", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2021-06-11T13:38:48Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2021-06-14T11:30:58Z"}, "message": "Improve maybe_uninit_extra docs\n\nFor reasoning, see https://github.com/rust-lang/rust/issues/63567#issuecomment-858640987", "tree": {"sha": "5c50a88b8e214a2ad3ef9cca854b7b2c537d6887", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c50a88b8e214a2ad3ef9cca854b7b2c537d6887"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87102587149ce00d008c3463bf6283f5145b2f23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87102587149ce00d008c3463bf6283f5145b2f23", "html_url": "https://github.com/rust-lang/rust/commit/87102587149ce00d008c3463bf6283f5145b2f23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87102587149ce00d008c3463bf6283f5145b2f23/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66ba81059e15b3466c71fe5b5bf2418702dd1fd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/66ba81059e15b3466c71fe5b5bf2418702dd1fd1", "html_url": "https://github.com/rust-lang/rust/commit/66ba81059e15b3466c71fe5b5bf2418702dd1fd1"}], "stats": {"total": 80, "additions": 67, "deletions": 13}, "files": [{"sha": "1f06bd0012c60ef090e62ae04d269098581f2bc1", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/87102587149ce00d008c3463bf6283f5145b2f23/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87102587149ce00d008c3463bf6283f5145b2f23/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=87102587149ce00d008c3463bf6283f5145b2f23", "patch": "@@ -402,10 +402,60 @@ impl<T> MaybeUninit<T> {\n         u\n     }\n \n-    /// Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n-    /// without dropping it, so be careful not to use this twice unless you want to\n-    /// skip running the destructor. For your convenience, this also returns a mutable\n-    /// reference to the (now safely initialized) contents of `self`.\n+    /// Sets the value of the `MaybeUninit<T>`.\n+    ///\n+    /// This overwrites any previous value without dropping it, so be careful\n+    /// not to use this twice unless you want to skip running the destructor.\n+    /// For your convenience, this also returns a mutable reference to the\n+    /// (now safely initialized) contents of `self`.\n+    ///\n+    /// As the content is stored inside a `MaybeUninit`, the destructor is not\n+    /// ran for the inner data if the MaybeUninit leaves scope without a call to\n+    /// [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n+    /// the mutable reference returned by this function needs to keep this in\n+    /// mind. The safety model of Rust regards leaks as safe, but they are\n+    /// usually still undesirable. This being said, the mutable reference\n+    /// behaves like any other mutable reference would, so assigning a new value\n+    /// to it will drop the old content.\n+    ///\n+    /// [`assume_init`]: Self::assume_init\n+    /// [`assume_init_drop`]: Self::assume_init_drop\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_extra)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u8>>::uninit();\n+    ///\n+    /// {\n+    ///     let hello = x.write((&b\"Hello, world!\").to_vec());\n+    ///     // Setting hello does not leak prior allocations, but drops them\n+    ///     *hello = (&b\"Hello\").to_vec();\n+    ///     hello[0] = 'h' as u8;\n+    /// }\n+    /// // x is initialized now:\n+    /// let s = unsafe { x.assume_init() };\n+    /// assert_eq!(b\"hello\", s.as_slice());\n+    /// ```\n+    ///\n+    /// This usage of the method causes a leak:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_extra)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<String>::uninit();\n+    ///\n+    /// x.write(\"Hello\".to_string());\n+    /// // This leaks the contained string:\n+    /// x.write(\"hello\".to_string());\n+    /// // x is initialized now:\n+    /// let s = unsafe { x.assume_init() };\n+    /// ```\n     #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[rustc_const_unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n@@ -564,9 +614,11 @@ impl<T> MaybeUninit<T> {\n     /// behavior. The [type-level documentation][inv] contains more information about\n     /// this initialization invariant.\n     ///\n-    /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n-    /// multiple copies of the data (by calling `assume_init_read` multiple times, or first\n-    /// calling `assume_init_read` and then [`assume_init`]), it is your responsibility\n+    /// Moreover, similar to the [`ptr::read`] function, this function creates a\n+    /// bitwise copy of the contents, regardless whether the contained type\n+    /// implements the [`Copy`] trait or not. When using multiple copies of the\n+    /// data (by calling `assume_init_read` multiple times, or first calling\n+    /// `assume_init_read` and then [`assume_init`]), it is your responsibility\n     /// to ensure that that data may indeed be duplicated.\n     ///\n     /// [inv]: #initialization-invariant\n@@ -622,7 +674,8 @@ impl<T> MaybeUninit<T> {\n \n     /// Drops the contained value in place.\n     ///\n-    /// If you have ownership of the `MaybeUninit`, you can use [`assume_init`] instead.\n+    /// If you have ownership of the `MaybeUninit`, you can also use\n+    /// [`assume_init`] as an alternative.\n     ///\n     /// # Safety\n     ///\n@@ -632,11 +685,12 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// On top of that, all additional invariants of the type `T` must be\n     /// satisfied, as the `Drop` implementation of `T` (or its members) may\n-    /// rely on this. For example, a `1`-initialized [`Vec<T>`] is considered\n-    /// initialized (under the current implementation; this does not constitute\n-    /// a stable guarantee) because the only requirement the compiler knows\n-    /// about it is that the data pointer must be non-null. Dropping such a\n-    /// `Vec<T>` however will cause undefined behaviour.\n+    /// rely on this. For example, setting a [`Vec<T>`] to an invalid but\n+    /// non-null address makes it initialized (under the current implementation;\n+    /// this does not constitute a stable guarantee), because the only\n+    /// requirement the compiler knows about it is that the data pointer must be\n+    /// non-null. Dropping such a `Vec<T>` however will cause undefined\n+    /// behaviour.\n     ///\n     /// [`assume_init`]: MaybeUninit::assume_init\n     /// [`Vec<T>`]: ../../std/vec/struct.Vec.html"}]}