{"sha": "c763eceae349c1d827d9cfbf5df21ca40b21c861", "node_id": "C_kwDOAAsO6NoAKGM3NjNlY2VhZTM0OWMxZDgyN2Q5Y2ZiZjVkZjIxY2E0MGIyMWM4NjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-24T06:16:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-24T06:16:24Z"}, "message": "Auto merge of #109552 - matthiaskrgr:rollup-03xwois, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #109406 (Remove outdated comments)\n - #109433 (Return equal for two identical projections)\n - #109495 (Implement non-const `Destruct` trait in new solver)\n - #109519 (Link against libc++ on AIX)\n - #109550 (Make helper functions private in fn_ctxt/adjust_fulfillment_errors)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "df8f56ba15d8be04f1ed1a37e30b8848b8b39b8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df8f56ba15d8be04f1ed1a37e30b8848b8b39b8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c763eceae349c1d827d9cfbf5df21ca40b21c861", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c763eceae349c1d827d9cfbf5df21ca40b21c861", "html_url": "https://github.com/rust-lang/rust/commit/c763eceae349c1d827d9cfbf5df21ca40b21c861", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c763eceae349c1d827d9cfbf5df21ca40b21c861/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c0f5008ce74563873cbd8574018dbe4906a5361", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c0f5008ce74563873cbd8574018dbe4906a5361", "html_url": "https://github.com/rust-lang/rust/commit/4c0f5008ce74563873cbd8574018dbe4906a5361"}, {"sha": "2cfcca629fe53f81ab312eeabb6d0efc5151a9bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cfcca629fe53f81ab312eeabb6d0efc5151a9bd", "html_url": "https://github.com/rust-lang/rust/commit/2cfcca629fe53f81ab312eeabb6d0efc5151a9bd"}], "stats": {"total": 169, "additions": 121, "deletions": 48}, "files": [{"sha": "7534e432f1198aa411cd581da42afe9813a64eba", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c763eceae349c1d827d9cfbf5df21ca40b21c861/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c763eceae349c1d827d9cfbf5df21ca40b21c861/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=c763eceae349c1d827d9cfbf5df21ca40b21c861", "patch": "@@ -310,7 +310,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .filter(|field| {\n                 let field_ty = field.ty(self.tcx, identity_substs);\n-                Self::find_param_in_ty(field_ty.into(), param_to_point_at)\n+                find_param_in_ty(field_ty.into(), param_to_point_at)\n             })\n             .collect();\n \n@@ -356,7 +356,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .inputs()\n             .iter()\n             .enumerate()\n-            .filter(|(_, ty)| Self::find_param_in_ty((**ty).into(), param_to_point_at))\n+            .filter(|(_, ty)| find_param_in_ty((**ty).into(), param_to_point_at))\n             .collect();\n         // If there's one field that references the given generic, great!\n         if let [(idx, _)] = args_referencing_param.as_slice()\n@@ -579,8 +579,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Find out which of `in_ty_elements` refer to `param`.\n             // FIXME: It may be better to take the first if there are multiple,\n             // just so that the error points to a smaller expression.\n-            let Some((drill_expr, drill_ty)) = Self::is_iterator_singleton(expr_elements.iter().zip( in_ty_elements.iter()).filter(|(_expr_elem, in_ty_elem)| {\n-                Self::find_param_in_ty((*in_ty_elem).into(), param)\n+            let Some((drill_expr, drill_ty)) = is_iterator_singleton(expr_elements.iter().zip( in_ty_elements.iter()).filter(|(_expr_elem, in_ty_elem)| {\n+                find_param_in_ty((*in_ty_elem).into(), param)\n             })) else {\n                 // The param is not mentioned, or it is mentioned in multiple indexes.\n                 return Err(expr);\n@@ -628,10 +628,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // We need to know which of the generic parameters mentions our target param.\n             // We expect that at least one of them does, since it is expected to be mentioned.\n             let Some((drill_generic_index, generic_argument_type)) =\n-                Self::is_iterator_singleton(\n+                is_iterator_singleton(\n                     in_ty_adt_generic_args.iter().enumerate().filter(\n                         |(_index, in_ty_generic)| {\n-                            Self::find_param_in_ty(*in_ty_generic, param)\n+                            find_param_in_ty(*in_ty_generic, param)\n                         },\n                     ),\n                 ) else {\n@@ -751,10 +751,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // We need to know which of the generic parameters mentions our target param.\n             // We expect that at least one of them does, since it is expected to be mentioned.\n             let Some((drill_generic_index, generic_argument_type)) =\n-                Self::is_iterator_singleton(\n+                is_iterator_singleton(\n                     in_ty_adt_generic_args.iter().enumerate().filter(\n                         |(_index, in_ty_generic)| {\n-                            Self::find_param_in_ty(*in_ty_generic, param)\n+                            find_param_in_ty(*in_ty_generic, param)\n                         },\n                     ),\n                 ) else {\n@@ -793,14 +793,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             //     outer contextual information.\n \n             // (1) Find the (unique) field index which mentions the type in our constraint:\n-            let Some((field_index, field_type)) = Self::is_iterator_singleton(\n+            let Some((field_index, field_type)) = is_iterator_singleton(\n                 in_ty_adt\n                     .variant_with_id(variant_def_id)\n                     .fields\n                     .iter()\n                     .map(|field| field.ty(self.tcx, *in_ty_adt_generic_args))\n                     .enumerate()\n-                    .filter(|(_index, field_type)| Self::find_param_in_ty((*field_type).into(), param))\n+                    .filter(|(_index, field_type)| find_param_in_ty((*field_type).into(), param))\n             ) else {\n                 return Err(expr);\n             };\n@@ -833,20 +833,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         Err(expr)\n     }\n+}\n \n-    // FIXME: This can be made into a private, non-impl function later.\n-    /// Traverses the given ty (either a `ty::Ty` or a `ty::GenericArg`) and searches for references\n-    /// to the given `param_to_point_at`. Returns `true` if it finds any use of the param.\n-    pub fn find_param_in_ty(\n-        ty: ty::GenericArg<'tcx>,\n-        param_to_point_at: ty::GenericArg<'tcx>,\n-    ) -> bool {\n-        let mut walk = ty.walk();\n-        while let Some(arg) = walk.next() {\n-            if arg == param_to_point_at {\n-                return true;\n-            }\n-            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+/// Traverses the given ty (either a `ty::Ty` or a `ty::GenericArg`) and searches for references\n+/// to the given `param_to_point_at`. Returns `true` if it finds any use of the param.\n+fn find_param_in_ty<'tcx>(\n+    ty: ty::GenericArg<'tcx>,\n+    param_to_point_at: ty::GenericArg<'tcx>,\n+) -> bool {\n+    let mut walk = ty.walk();\n+    while let Some(arg) = walk.next() {\n+        if arg == param_to_point_at {\n+            return true;\n+        }\n+        if let ty::GenericArgKind::Type(ty) = arg.unpack()\n                 && let ty::Alias(ty::Projection, ..) = ty.kind()\n             {\n                 // This logic may seem a bit strange, but typically when\n@@ -857,16 +857,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // in some UI tests.\n                 walk.skip_current_subtree();\n             }\n-        }\n-        false\n     }\n+    false\n+}\n \n-    // FIXME: This can be made into a private, non-impl function later.\n-    /// Returns `Some(iterator.next())` if it has exactly one item, and `None` otherwise.\n-    pub fn is_iterator_singleton<T>(mut iterator: impl Iterator<Item = T>) -> Option<T> {\n-        match (iterator.next(), iterator.next()) {\n-            (_, Some(_)) => None,\n-            (first, _) => first,\n-        }\n+/// Returns `Some(iterator.next())` if it has exactly one item, and `None` otherwise.\n+fn is_iterator_singleton<T>(mut iterator: impl Iterator<Item = T>) -> Option<T> {\n+    match (iterator.next(), iterator.next()) {\n+        (_, Some(_)) => None,\n+        (first, _) => first,\n     }\n }"}, {"sha": "eadc30a799b2a08dd80b6ea95292c0db3fd89536", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c763eceae349c1d827d9cfbf5df21ca40b21c861/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c763eceae349c1d827d9cfbf5df21ca40b21c861/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=c763eceae349c1d827d9cfbf5df21ca40b21c861", "patch": "@@ -712,10 +712,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                unreachable!(\n-                    \"we captured two identical projections: capture1 = {:?}, capture2 = {:?}\",\n-                    capture1, capture2\n+                self.tcx.sess.delay_span_bug(\n+                    closure_span,\n+                    &format!(\n+                        \"two identical projections: ({:?}, {:?})\",\n+                        capture1.place.projections, capture2.place.projections\n+                    ),\n                 );\n+                std::cmp::Ordering::Equal\n             });\n         }\n "}, {"sha": "f8e9ec535e4568769b39c5fe0679f44c70e063bd", "filename": "compiler/rustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c763eceae349c1d827d9cfbf5df21ca40b21c861/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c763eceae349c1d827d9cfbf5df21ca40b21c861/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=c763eceae349c1d827d9cfbf5df21ca40b21c861", "patch": "@@ -333,6 +333,7 @@ fn main() {\n     } else if target.contains(\"darwin\")\n         || target.contains(\"freebsd\")\n         || target.contains(\"windows-gnullvm\")\n+        || target.contains(\"aix\")\n     {\n         \"c++\"\n     } else if target.contains(\"netbsd\") && llvm_static_stdcpp.is_some() {"}, {"sha": "995fec78c40763165388c7a0da5804eae05678e6", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c763eceae349c1d827d9cfbf5df21ca40b21c861/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c763eceae349c1d827d9cfbf5df21ca40b21c861/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=c763eceae349c1d827d9cfbf5df21ca40b21c861", "patch": "@@ -212,6 +212,11 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_destruct_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n@@ -340,6 +345,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             G::consider_builtin_unsize_candidate(self, goal)\n         } else if lang_items.discriminant_kind_trait() == Some(trait_def_id) {\n             G::consider_builtin_discriminant_kind_candidate(self, goal)\n+        } else if lang_items.destruct_trait() == Some(trait_def_id) {\n+            G::consider_builtin_destruct_candidate(self, goal)\n         } else {\n             Err(NoSolution)\n         };"}, {"sha": "525b3105538d0311e3dcc01705f204db15115d08", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c763eceae349c1d827d9cfbf5df21ca40b21c861/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c763eceae349c1d827d9cfbf5df21ca40b21c861/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=c763eceae349c1d827d9cfbf5df21ca40b21c861", "patch": "@@ -487,6 +487,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n+\n+    fn consider_builtin_destruct_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`Destruct` does not have an associated type: {:?}\", goal);\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code."}, {"sha": "ade45d199f05245bae67ce22f46e47ea3b988455", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c763eceae349c1d827d9cfbf5df21ca40b21c861/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c763eceae349c1d827d9cfbf5df21ca40b21c861/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=c763eceae349c1d827d9cfbf5df21ca40b21c861", "patch": "@@ -534,6 +534,20 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         // `DiscriminantKind` is automatically implemented for every type.\n         ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n+\n+    fn consider_builtin_destruct_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        if !goal.param_env.is_const() {\n+            // `Destruct` is automatically implemented for every type in\n+            // non-const environments.\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        } else {\n+            // FIXME(-Ztrait-solver=next): Implement this when we get const working in the new solver\n+            Err(NoSolution)\n+        }\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "c7d0144de30cb5bb61153e0e51b065e35841ac79", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c763eceae349c1d827d9cfbf5df21ca40b21c861/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c763eceae349c1d827d9cfbf5df21ca40b21c861/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=c763eceae349c1d827d9cfbf5df21ca40b21c861", "patch": "@@ -13,7 +13,6 @@ pub mod set;\n mod set_val;\n mod split;\n \n-#[doc(hidden)]\n trait Recover<Q: ?Sized> {\n     type Key;\n "}, {"sha": "4de30d40825e7a6688f870c63d3b6516d4380ab5", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c763eceae349c1d827d9cfbf5df21ca40b21c861/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c763eceae349c1d827d9cfbf5df21ca40b21c861/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=c763eceae349c1d827d9cfbf5df21ca40b21c861", "patch": "@@ -1,6 +1,3 @@\n-// This is pretty much entirely stolen from TreeSet, since BTreeMap has an identical interface\n-// to TreeMap\n-\n use crate::vec::Vec;\n use core::borrow::Borrow;\n use core::cmp::Ordering::{self, Equal, Greater, Less};\n@@ -18,8 +15,6 @@ use super::Recover;\n \n use crate::alloc::{Allocator, Global};\n \n-// FIXME(conventions): implement bounded iterators\n-\n /// An ordered set based on a B-Tree.\n ///\n /// See [`BTreeMap`]'s documentation for a detailed discussion of this collection's performance"}, {"sha": "837a18bff6087ccf47fa2f9ad82678e6f350b242", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c763eceae349c1d827d9cfbf5df21ca40b21c861/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c763eceae349c1d827d9cfbf5df21ca40b21c861/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=c763eceae349c1d827d9cfbf5df21ca40b21c861", "patch": "@@ -12,13 +12,6 @@ use crate::ops::{BitAnd, BitOr, BitXor, Sub};\n \n use super::map::{map_try_reserve_error, RandomState};\n \n-// Future Optimization (FIXME!)\n-// ============================\n-//\n-// Iteration over zero sized values is a noop. There is no need\n-// for `bucket.val` in the case of HashSet. I suppose we would need HKT\n-// to get rid of it properly.\n-\n /// A [hash set] implemented as a `HashMap` where the value is `()`.\n ///\n /// As with the [`HashMap`] type, a `HashSet` requires that the elements"}, {"sha": "cae1ced9958a754d0d2aa5b5913554491784bcfb", "filename": "tests/ui/closures/issue-109188.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c763eceae349c1d827d9cfbf5df21ca40b21c861/tests%2Fui%2Fclosures%2Fissue-109188.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c763eceae349c1d827d9cfbf5df21ca40b21c861/tests%2Fui%2Fclosures%2Fissue-109188.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2Fissue-109188.rs?ref=c763eceae349c1d827d9cfbf5df21ca40b21c861", "patch": "@@ -0,0 +1,22 @@\n+enum Either {\n+    One(X),\n+    Two(X),\n+}\n+\n+struct X(Y);\n+\n+struct Y;\n+\n+fn consume_fnmut(f: &dyn FnMut()) {\n+    f();\n+}\n+\n+fn move_into_fnmut() {\n+    let x = move_into_fnmut();\n+    consume_fnmut(&|| {\n+        let Either::One(_t) = x; //~ ERROR mismatched types\n+        let Either::Two(_t) = x; //~ ERROR mismatched types\n+    });\n+}\n+\n+fn main() { }"}, {"sha": "d52b516294f99d6e53f6be122037352915f7846a", "filename": "tests/ui/closures/issue-109188.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c763eceae349c1d827d9cfbf5df21ca40b21c861/tests%2Fui%2Fclosures%2Fissue-109188.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c763eceae349c1d827d9cfbf5df21ca40b21c861/tests%2Fui%2Fclosures%2Fissue-109188.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2Fissue-109188.stderr?ref=c763eceae349c1d827d9cfbf5df21ca40b21c861", "patch": "@@ -0,0 +1,19 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-109188.rs:17:13\n+   |\n+LL |         let Either::One(_t) = x;\n+   |             ^^^^^^^^^^^^^^^   - this expression has type `()`\n+   |             |\n+   |             expected `()`, found `Either`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-109188.rs:18:13\n+   |\n+LL |         let Either::Two(_t) = x;\n+   |             ^^^^^^^^^^^^^^^   - this expression has type `()`\n+   |             |\n+   |             expected `()`, found `Either`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "4b013983a4a84fa3f951395058478ba3878024ff", "filename": "tests/ui/traits/new-solver/canonical-int-var-eq-in-response.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c763eceae349c1d827d9cfbf5df21ca40b21c861/tests%2Fui%2Ftraits%2Fnew-solver%2Fcanonical-int-var-eq-in-response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c763eceae349c1d827d9cfbf5df21ca40b21c861/tests%2Fui%2Ftraits%2Fnew-solver%2Fcanonical-int-var-eq-in-response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fcanonical-int-var-eq-in-response.rs?ref=c763eceae349c1d827d9cfbf5df21ca40b21c861", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Ztrait-solver=next\n // check-pass\n \n trait Mirror {"}, {"sha": "30d7777b78aa004bd0893cdbe5134733c4a1b2ce", "filename": "tests/ui/traits/new-solver/destruct.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c763eceae349c1d827d9cfbf5df21ca40b21c861/tests%2Fui%2Ftraits%2Fnew-solver%2Fdestruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c763eceae349c1d827d9cfbf5df21ca40b21c861/tests%2Fui%2Ftraits%2Fnew-solver%2Fdestruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fdestruct.rs?ref=c763eceae349c1d827d9cfbf5df21ca40b21c861", "patch": "@@ -0,0 +1,13 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+#![feature(const_trait_impl)]\n+\n+fn foo(_: impl std::marker::Destruct) {}\n+\n+struct MyAdt;\n+\n+fn main() {\n+    foo(1);\n+    foo(MyAdt);\n+}"}]}