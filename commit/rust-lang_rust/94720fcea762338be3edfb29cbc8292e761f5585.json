{"sha": "94720fcea762338be3edfb29cbc8292e761f5585", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NzIwZmNlYTc2MjMzOGJlM2VkZmIyOWNiYzgyOTJlNzYxZjU1ODU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-30T00:41:38Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-30T00:44:29Z"}, "message": "std: More camel casing", "tree": {"sha": "12eb76366746670e40f6fcb8785d9e52086c800b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12eb76366746670e40f6fcb8785d9e52086c800b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94720fcea762338be3edfb29cbc8292e761f5585", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94720fcea762338be3edfb29cbc8292e761f5585", "html_url": "https://github.com/rust-lang/rust/commit/94720fcea762338be3edfb29cbc8292e761f5585", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94720fcea762338be3edfb29cbc8292e761f5585/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8b34b2af820574830024daac3a57db079ab3bac", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8b34b2af820574830024daac3a57db079ab3bac", "html_url": "https://github.com/rust-lang/rust/commit/d8b34b2af820574830024daac3a57db079ab3bac"}], "stats": {"total": 109, "additions": 59, "deletions": 50}, "files": [{"sha": "67b4048240232bd965d25b2599f7e2b75f37fe3f", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94720fcea762338be3edfb29cbc8292e761f5585/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94720fcea762338be3edfb29cbc8292e761f5585/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=94720fcea762338be3edfb29cbc8292e761f5585", "patch": "@@ -2,7 +2,7 @@\n \n import vec;\n import uint;\n-import iotask = uv::iotask::iotask;\n+import iotask = uv::iotask::IoTask;\n import interact = uv::iotask::interact;\n \n import sockaddr_in = uv::ll::sockaddr_in;"}, {"sha": "c7a5f90a857a042c7cc24ab3fca3df8e062da772", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94720fcea762338be3edfb29cbc8292e761f5585/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94720fcea762338be3edfb29cbc8292e761f5585/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=94720fcea762338be3edfb29cbc8292e761f5585", "patch": "@@ -2,7 +2,7 @@\n \n import ip = net_ip;\n import uv::iotask;\n-import uv::iotask::iotask;\n+import uv::iotask::IoTask;\n import future_spawn = future::spawn;\n // FIXME #1935\n // should be able to, but can't atm, replace w/ result::{result, extensions};\n@@ -119,7 +119,7 @@ enum tcp_connect_err_data {\n  * `net::tcp::tcp_connect_err_data` instance will be returned\n  */\n fn connect(-input_ip: ip::ip_addr, port: uint,\n-           iotask: iotask)\n+           iotask: IoTask)\n     -> result::Result<tcp_socket, tcp_connect_err_data> unsafe {\n     let result_po = core::comm::Port::<conn_attempt>();\n     let closed_signal_po = core::comm::Port::<()>();\n@@ -560,7 +560,7 @@ fn accept(new_conn: tcp_new_connection)\n  * of listen exiting because of an error\n  */\n fn listen(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n-          iotask: iotask,\n+          iotask: IoTask,\n           on_establish_cb: fn~(comm::Chan<Option<tcp_err_data>>),\n           +new_connect_cb: fn~(tcp_new_connection,\n                                comm::Chan<Option<tcp_err_data>>))\n@@ -577,7 +577,7 @@ fn listen(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n }\n \n fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n-          iotask: iotask,\n+          iotask: IoTask,\n           on_establish_cb: fn~(comm::Chan<Option<tcp_err_data>>),\n           -on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n     -> result::Result<(), tcp_listen_err_data> unsafe {\n@@ -1003,7 +1003,7 @@ type tcp_listen_fc_data = {\n     stream_closed_ch: comm::Chan<()>,\n     kill_ch: comm::Chan<Option<tcp_err_data>>,\n     on_connect_cb: fn~(*uv::ll::uv_tcp_t),\n-    iotask: iotask,\n+    iotask: IoTask,\n     mut active: bool\n };\n \n@@ -1202,7 +1202,7 @@ type tcp_socket_data = {\n     stream_handle_ptr: *uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n     write_req: uv::ll::uv_write_t,\n-    iotask: iotask\n+    iotask: IoTask\n };\n \n type tcp_buffered_socket_data = {\n@@ -1479,7 +1479,7 @@ mod test {\n     fn run_tcp_test_server(server_ip: ~str, server_port: uint, resp: ~str,\n                           server_ch: comm::Chan<~str>,\n                           cont_ch: comm::Chan<()>,\n-                          iotask: iotask) -> ~str {\n+                          iotask: IoTask) -> ~str {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n             // on_establish_cb -- called when listener is set up\n@@ -1562,7 +1562,7 @@ mod test {\n     }\n \n     fn run_tcp_test_server_fail(server_ip: ~str, server_port: uint,\n-                          iotask: iotask) -> tcp_listen_err_data {\n+                          iotask: IoTask) -> tcp_listen_err_data {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n             // on_establish_cb -- called when listener is set up\n@@ -1585,7 +1585,7 @@ mod test {\n \n     fn run_tcp_test_client(server_ip: ~str, server_port: uint, resp: ~str,\n                           client_ch: comm::Chan<~str>,\n-                          iotask: iotask) -> result::Result<~str,\n+                          iotask: IoTask) -> result::Result<~str,\n                                                     tcp_connect_err_data> {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n "}, {"sha": "765aff74197d6765aa52297a8750a6b652d991ff", "filename": "src/libstd/std.rc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94720fcea762338be3edfb29cbc8292e761f5585/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/94720fcea762338be3edfb29cbc8292e761f5585/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=94720fcea762338be3edfb29cbc8292e761f5585", "patch": "@@ -36,16 +36,22 @@ mod net_tcp;\n mod net_url;\n \n // libuv modules\n+#[warn(non_camel_case_types)]\n mod uv;\n mod uv_ll;\n+#[warn(non_camel_case_types)]\n mod uv_iotask;\n+#[warn(non_camel_case_types)]\n mod uv_global_loop;\n \n \n // Utility modules\n \n+#[warn(non_camel_case_types)]\n mod c_vec;\n+#[warn(non_camel_case_types)]\n mod timer;\n+#[warn(non_camel_case_types)]\n mod cell;\n \n // Concurrency\n@@ -54,6 +60,7 @@ mod cell;\n mod sync;\n #[warn(non_camel_case_types)]\n mod arc;\n+#[warn(non_camel_case_types)]\n mod comm;\n \n // Collections"}, {"sha": "ff0130b77839cae91e1578cc8e75aef0d58759ba", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94720fcea762338be3edfb29cbc8292e761f5585/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94720fcea762338be3edfb29cbc8292e761f5585/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=94720fcea762338be3edfb29cbc8292e761f5585", "patch": "@@ -5,7 +5,7 @@\n \n import uv = uv;\n import uv::iotask;\n-import iotask::iotask;\n+import iotask::IoTask;\n import comm = core::comm;\n \n export delayed_send, sleep, recv_timeout;\n@@ -26,7 +26,7 @@ export delayed_send, sleep, recv_timeout;\n  * * ch - a channel of type T to send a `val` on\n  * * val - a value of type T to send over the provided `ch`\n  */\n-fn delayed_send<T: copy send>(iotask: iotask,\n+fn delayed_send<T: copy send>(iotask: IoTask,\n                               msecs: uint, ch: comm::Chan<T>, +val: T) {\n         unsafe {\n             let timer_done_po = core::comm::Port::<()>();\n@@ -75,7 +75,7 @@ fn delayed_send<T: copy send>(iotask: iotask,\n  * * `iotask` - a `uv::iotask` that the tcp request will run on\n  * * msecs - an amount of time, in milliseconds, for the current task to block\n  */\n-fn sleep(iotask: iotask, msecs: uint) {\n+fn sleep(iotask: IoTask, msecs: uint) {\n     let exit_po = core::comm::Port::<()>();\n     let exit_ch = core::comm::Chan(exit_po);\n     delayed_send(iotask, msecs, exit_ch, ());\n@@ -102,7 +102,7 @@ fn sleep(iotask: iotask, msecs: uint) {\n  * on the provided port in the allotted timeout period, then the result will\n  * be a `some(T)`. If not, then `none` will be returned.\n  */\n-fn recv_timeout<T: copy send>(iotask: iotask,\n+fn recv_timeout<T: copy send>(iotask: IoTask,\n                               msecs: uint,\n                               wait_po: comm::Port<T>) -> Option<T> {\n     let timeout_po = comm::Port::<()>();"}, {"sha": "4fec4dda4398639367febe2bc5dc779465c988df", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/94720fcea762338be3edfb29cbc8292e761f5585/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94720fcea762338be3edfb29cbc8292e761f5585/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=94720fcea762338be3edfb29cbc8292e761f5585", "patch": "@@ -5,7 +5,7 @@ export get;\n import ll = uv_ll;\n import iotask = uv_iotask;\n import get_gl = get;\n-import iotask::{iotask, spawn_iotask};\n+import iotask::{IoTask, spawn_iotask};\n import priv::{chan_from_global_ptr, weaken_task};\n import comm = core::comm;\n import comm::{Port, Chan, select2, listen};\n@@ -28,23 +28,23 @@ extern mod rustrt {\n  * * A `hl::high_level_loop` that encapsulates communication with the global\n  * loop.\n  */\n-fn get() -> iotask {\n+fn get() -> IoTask {\n     return get_monitor_task_gl();\n }\n \n #[doc(hidden)]\n-fn get_monitor_task_gl() -> iotask unsafe {\n+fn get_monitor_task_gl() -> IoTask unsafe {\n \n     let monitor_loop_chan_ptr = rustrt::rust_uv_get_kernel_global_chan_ptr();\n \n     debug!(\"ENTERING global_loop::get() loop chan: %?\",\n            monitor_loop_chan_ptr);\n \n     debug!(\"before priv::chan_from_global_ptr\");\n-    type monchan = Chan<iotask>;\n+    type MonChan = Chan<IoTask>;\n \n     let monitor_ch =\n-        do chan_from_global_ptr::<monchan>(monitor_loop_chan_ptr,\n+        do chan_from_global_ptr::<MonChan>(monitor_loop_chan_ptr,\n                                            || {\n                                                 task::task().sched_mode\n                                                 (task::SingleThreaded)\n@@ -85,7 +85,7 @@ fn get_monitor_task_gl() -> iotask unsafe {\n     }\n }\n \n-fn spawn_loop() -> iotask {\n+fn spawn_loop() -> IoTask {\n     let builder = do task::task().add_wrapper |task_body| {\n         fn~(move task_body) {\n             // The I/O loop task also needs to be weak so it doesn't keep\n@@ -131,7 +131,7 @@ mod test {\n         log(debug, ~\"exiting simple timer cb\");\n     }\n \n-    fn impl_uv_hl_simple_timer(iotask: iotask) unsafe {\n+    fn impl_uv_hl_simple_timer(iotask: IoTask) unsafe {\n         let exit_po = core::comm::Port::<bool>();\n         let exit_ch = core::comm::Chan(exit_po);\n         let exit_ch_ptr = ptr::addr_of(exit_ch);"}, {"sha": "42cc2e1cb609bdbda5160ae4fea3c9ba0d695367", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/94720fcea762338be3edfb29cbc8292e761f5585/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94720fcea762338be3edfb29cbc8292e761f5585/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=94720fcea762338be3edfb29cbc8292e761f5585", "patch": "@@ -5,7 +5,7 @@\n  * `interact` function you can execute code in a uv callback.\n  */\n \n-export iotask;\n+export IoTask;\n export spawn_iotask;\n export interact;\n export exit;\n@@ -18,14 +18,14 @@ import task::TaskBuilder;\n import ll = uv_ll;\n \n /// Used to abstract-away direct interaction with a libuv loop.\n-enum iotask {\n-    iotask_({\n+enum IoTask {\n+    IoTask_({\n         async_handle: *ll::uv_async_t,\n-        op_chan: Chan<iotask_msg>\n+        op_chan: Chan<IoTaskMsg>\n     })\n }\n \n-fn spawn_iotask(-task: task::TaskBuilder) -> iotask {\n+fn spawn_iotask(-task: task::TaskBuilder) -> IoTask {\n \n     do listen |iotask_ch| {\n \n@@ -62,9 +62,9 @@ fn spawn_iotask(-task: task::TaskBuilder) -> iotask {\n  * module. It is not safe to send the `loop_ptr` param to this callback out\n  * via ports/chans.\n  */\n-unsafe fn interact(iotask: iotask,\n+unsafe fn interact(iotask: IoTask,\n                    -cb: fn~(*c_void)) {\n-    send_msg(iotask, interaction(cb));\n+    send_msg(iotask, Interaction(cb));\n }\n \n /**\n@@ -74,20 +74,20 @@ unsafe fn interact(iotask: iotask,\n  * async handle and do a sanity check to make sure that all other handles are\n  * closed, causing a failure otherwise.\n  */\n-fn exit(iotask: iotask) unsafe {\n-    send_msg(iotask, teardown_loop);\n+fn exit(iotask: IoTask) unsafe {\n+    send_msg(iotask, TeardownLoop);\n }\n \n \n // INTERNAL API\n \n-enum iotask_msg {\n-    interaction (fn~(*libc::c_void)),\n-    teardown_loop\n+enum IoTaskMsg {\n+    Interaction (fn~(*libc::c_void)),\n+    TeardownLoop\n }\n \n /// Run the loop and begin handling messages\n-fn run_loop(iotask_ch: Chan<iotask>) unsafe {\n+fn run_loop(iotask_ch: Chan<IoTask>) unsafe {\n \n     let loop_ptr = ll::loop_new();\n \n@@ -100,15 +100,15 @@ fn run_loop(iotask_ch: Chan<iotask>) unsafe {\n     ll::async_init(loop_ptr, async_handle, wake_up_cb);\n \n     // initialize our loop data and store it in the loop\n-    let data: iotask_loop_data = {\n+    let data: IoTaskLoopData = {\n         async_handle: async_handle,\n         msg_po: Port()\n     };\n     ll::set_data_for_uv_handle(async_handle, addr_of(data));\n \n     // Send out a handle through which folks can talk to us\n     // while we dwell in the I/O loop\n-    let iotask = iotask_({\n+    let iotask = IoTask_({\n         async_handle: async_handle,\n         op_chan: data.msg_po.chan()\n     });\n@@ -122,13 +122,13 @@ fn run_loop(iotask_ch: Chan<iotask>) unsafe {\n }\n \n // data that lives for the lifetime of the high-evel oo\n-type iotask_loop_data = {\n+type IoTaskLoopData = {\n     async_handle: *ll::uv_async_t,\n-    msg_po: Port<iotask_msg>\n+    msg_po: Port<IoTaskMsg>\n };\n \n-fn send_msg(iotask: iotask,\n-            -msg: iotask_msg) unsafe {\n+fn send_msg(iotask: IoTask,\n+            -msg: IoTaskMsg) unsafe {\n     iotask.op_chan.send(msg);\n     ll::async_send(iotask.async_handle);\n }\n@@ -141,18 +141,18 @@ extern fn wake_up_cb(async_handle: *ll::uv_async_t,\n                      async_handle, status));\n \n     let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n-    let data = ll::get_data_for_uv_handle(async_handle) as *iotask_loop_data;\n+    let data = ll::get_data_for_uv_handle(async_handle) as *IoTaskLoopData;\n     let msg_po = (*data).msg_po;\n \n     while msg_po.peek() {\n         match msg_po.recv() {\n-          interaction(cb) => cb(loop_ptr),\n-          teardown_loop => begin_teardown(data)\n+          Interaction(cb) => cb(loop_ptr),\n+          TeardownLoop => begin_teardown(data)\n         }\n     }\n }\n \n-fn begin_teardown(data: *iotask_loop_data) unsafe {\n+fn begin_teardown(data: *IoTaskLoopData) unsafe {\n     log(debug, ~\"iotask begin_teardown() called, close async_handle\");\n     let async_handle = (*data).async_handle;\n     ll::close(async_handle as *c_void, tear_down_close_cb);\n@@ -171,19 +171,19 @@ mod test {\n     extern fn async_close_cb(handle: *ll::uv_async_t) unsafe {\n         log(debug, fmt!(\"async_close_cb handle %?\", handle));\n         let exit_ch = (*(ll::get_data_for_uv_handle(handle)\n-                        as *ah_data)).exit_ch;\n+                        as *AhData)).exit_ch;\n         core::comm::send(exit_ch, ());\n     }\n     extern fn async_handle_cb(handle: *ll::uv_async_t, status: libc::c_int)\n         unsafe {\n         log(debug, fmt!(\"async_handle_cb handle %? status %?\",handle,status));\n         ll::close(handle, async_close_cb);\n     }\n-    type ah_data = {\n-        iotask: iotask,\n+    type AhData = {\n+        iotask: IoTask,\n         exit_ch: comm::Chan<()>\n     };\n-    fn impl_uv_iotask_async(iotask: iotask) unsafe {\n+    fn impl_uv_iotask_async(iotask: IoTask) unsafe {\n         let async_handle = ll::async_t();\n         let ah_ptr = ptr::addr_of(async_handle);\n         let exit_po = core::comm::Port::<()>();\n@@ -203,8 +203,8 @@ mod test {\n \n     // this fn documents the bear minimum neccesary to roll your own\n     // high_level_loop\n-    unsafe fn spawn_test_loop(exit_ch: comm::Chan<()>) -> iotask {\n-        let iotask_port = comm::Port::<iotask>();\n+    unsafe fn spawn_test_loop(exit_ch: comm::Chan<()>) -> IoTask {\n+        let iotask_port = comm::Port::<IoTask>();\n         let iotask_ch = comm::Chan(iotask_port);\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             run_loop(iotask_ch);"}, {"sha": "589c36f4344563259615c4271e3ccde15dea456a", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94720fcea762338be3edfb29cbc8292e761f5585/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94720fcea762338be3edfb29cbc8292e761f5585/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=94720fcea762338be3edfb29cbc8292e761f5585", "patch": "@@ -20,6 +20,8 @@\n  * with per-platform, generated source files from rust-bindgen.\n  */\n \n+#[allow(non_camel_case_types)] // C types\n+\n import libc::size_t;\n import comm = core::comm;\n import ptr::to_unsafe_ptr;"}]}