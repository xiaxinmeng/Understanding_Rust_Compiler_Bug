{"sha": "adddfccf2b63f7969d80d459788e973b56168ec4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZGRmY2NmMmI2M2Y3OTY5ZDgwZDQ1OTc4OGU5NzNiNTYxNjhlYzQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-15T08:04:00Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:05Z"}, "message": "rustc_metadata: move all encoding/decoding helpers to methods.", "tree": {"sha": "5118045775e30a588f2bf803acdb0352c078e648", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5118045775e30a588f2bf803acdb0352c078e648"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adddfccf2b63f7969d80d459788e973b56168ec4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adddfccf2b63f7969d80d459788e973b56168ec4", "html_url": "https://github.com/rust-lang/rust/commit/adddfccf2b63f7969d80d459788e973b56168ec4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adddfccf2b63f7969d80d459788e973b56168ec4/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6890354f3b43c98ff0e329fe7cf952eb1176ce61", "url": "https://api.github.com/repos/rust-lang/rust/commits/6890354f3b43c98ff0e329fe7cf952eb1176ce61", "html_url": "https://github.com/rust-lang/rust/commit/6890354f3b43c98ff0e329fe7cf952eb1176ce61"}], "stats": {"total": 2132, "additions": 1002, "deletions": 1130}, "files": [{"sha": "6324995f328b9c1e830b6b255e24813674844d03", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=adddfccf2b63f7969d80d459788e973b56168ec4", "patch": "@@ -188,7 +188,6 @@ pub trait CrateStore<'tcx> {\n     fn is_compiler_builtins(&self, cnum: CrateNum) -> bool;\n     fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy;\n     fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>;\n-    fn crate_attrs(&self, cnum: CrateNum) -> Vec<ast::Attribute>;\n     /// The name of the crate as it is referred to in source code of the current\n     /// crate.\n     fn crate_name(&self, cnum: CrateNum) -> InternedString;\n@@ -365,8 +364,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         bug!(\"panic_strategy\")\n     }\n     fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n-    fn crate_attrs(&self, cnum: CrateNum) -> Vec<ast::Attribute>\n-        { bug!(\"crate_attrs\") }\n     fn crate_name(&self, cnum: CrateNum) -> InternedString { bug!(\"crate_name\") }\n     fn original_crate_name(&self, cnum: CrateNum) -> InternedString {\n         bug!(\"original_crate_name\")"}, {"sha": "f48c31fc2f9ddd5e07d7c46576ba35949f79248c", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=adddfccf2b63f7969d80d459788e973b56168ec4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types)]\n-\n use rustc::hir::map as ast_map;\n \n use rustc::hir::intravisit::{Visitor, IdRangeComputingVisitor, IdRange};\n@@ -64,9 +62,7 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n                                      orig_did: DefId)\n                                      -> &'tcx InlinedItem {\n     debug!(\"> Decoding inlined fn: {:?}\", tcx.item_path_str(orig_did));\n-    let dcx = &mut ast_doc.decoder();\n-    dcx.tcx = Some(tcx);\n-    dcx.cdata = Some(cdata);\n+    let dcx = &mut DecodeContext::new(ast_doc, Some(cdata)).typed(tcx);\n     dcx.from_id_range = IdRange::decode(dcx).unwrap();\n     let cnt = dcx.from_id_range.max.as_usize() - dcx.from_id_range.min.as_usize();\n     dcx.to_id_range.min = tcx.sess.reserve_node_ids(cnt);"}, {"sha": "77a583f7379c1fd0139af6f486c7b72c8321f3c2", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=adddfccf2b63f7969d80d459788e973b56168ec4", "patch": "@@ -14,7 +14,6 @@\n \n use common::CrateInfo;\n use cstore::{self, CStore, CrateSource, MetadataBlob};\n-use decoder;\n use loader::{self, CratePaths};\n \n use rustc::hir::def_id::{CrateNum, DefIndex};\n@@ -28,6 +27,7 @@ use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n use rustc::hir::map as hir_map;\n \n use std::cell::{RefCell, Cell};\n+use std::ops::Deref;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::fs;\n@@ -143,11 +143,13 @@ enum PMDSource {\n     Owned(loader::Library),\n }\n \n-impl PMDSource {\n-    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n+impl Deref for PMDSource {\n+    type Target = MetadataBlob;\n+\n+    fn deref(&self) -> &MetadataBlob {\n         match *self {\n-            PMDSource::Registered(ref cmd) => cmd.data(),\n-            PMDSource::Owned(ref lib) => lib.metadata.as_slice(),\n+            PMDSource::Registered(ref cmd) => &cmd.data,\n+            PMDSource::Owned(ref lib) => &lib.metadata\n         }\n     }\n }\n@@ -295,7 +297,7 @@ impl<'a> CrateReader<'a> {\n                       -> (CrateNum, Rc<cstore::CrateMetadata>,\n                           cstore::CrateSource) {\n         info!(\"register crate `extern crate {} as {}`\", name, ident);\n-        let crate_info = decoder::get_crate_info(lib.metadata.as_slice());\n+        let crate_info = lib.metadata.get_crate_info();\n         self.verify_no_symbol_conflicts(span, &crate_info);\n \n         // Claim this crate number and cache it\n@@ -317,7 +319,7 @@ impl<'a> CrateReader<'a> {\n \n         let loader::Library { dylib, rlib, metadata } = lib;\n \n-        let cnum_map = self.resolve_crate_deps(root, metadata.as_slice(), cnum, span);\n+        let cnum_map = self.resolve_crate_deps(root, &metadata, cnum, span);\n \n         if crate_info.macro_derive_registrar.is_some() {\n             self.sess.span_err(span, \"crates of the `rustc-macro` crate type \\\n@@ -328,8 +330,8 @@ impl<'a> CrateReader<'a> {\n             name: name.to_string(),\n             extern_crate: Cell::new(None),\n             info: crate_info,\n-            index: decoder::load_index(metadata.as_slice()),\n-            key_map: decoder::load_key_map(metadata.as_slice()),\n+            index: metadata.load_index(),\n+            key_map: metadata.load_key_map(),\n             data: metadata,\n             cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,\n@@ -414,7 +416,7 @@ impl<'a> CrateReader<'a> {\n         // Note that we only do this for target triple crates, though, as we\n         // don't want to match a host crate against an equivalent target one\n         // already loaded.\n-        let crate_info = decoder::get_crate_info(library.metadata.as_slice());\n+        let crate_info = library.metadata.get_crate_info();\n         if loader.triple == self.sess.opts.target_triple {\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n@@ -465,14 +467,14 @@ impl<'a> CrateReader<'a> {\n     // Go through the crate metadata and load any crates that it references\n     fn resolve_crate_deps(&mut self,\n                           root: &Option<CratePaths>,\n-                          cdata: &[u8],\n+                          metadata: &MetadataBlob,\n                           krate: CrateNum,\n                           span: Span)\n                           -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n         // The map from crate numbers in the crate we're resolving to local crate\n         // numbers\n-        let map: FnvHashMap<_, _> = decoder::get_crate_deps(cdata).iter().map(|dep| {\n+        let map: FnvHashMap<_, _> = metadata.get_crate_deps().iter().map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, ..) = self.resolve_crate(root,\n                                                         &dep.name,\n@@ -566,16 +568,15 @@ impl<'a> CrateReader<'a> {\n         let ci = self.extract_crate_info(item).unwrap();\n         let ekrate = self.read_extension_crate(item.span, &ci);\n \n-        let crate_info = decoder::get_crate_info(ekrate.metadata.as_slice());\n+        let crate_info = ekrate.metadata.get_crate_info();\n         let source_name = format!(\"<{} macros>\", item.ident);\n         let mut ret = Macros {\n             macro_rules: Vec::new(),\n             custom_derive_registrar: None,\n             svh: crate_info.hash,\n             dylib: None,\n         };\n-        decoder::each_exported_macro(ekrate.metadata.as_slice(),\n-                                     |name, attrs, span, body| {\n+        ekrate.metadata.each_exported_macro(|name, attrs, span, body| {\n             // NB: Don't use parse::parse_tts_from_source_str because it parses with\n             // quote_depth > 0.\n             let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n@@ -670,7 +671,7 @@ impl<'a> CrateReader<'a> {\n             span_fatal!(self.sess, span, E0456, \"{}\", &message[..]);\n         }\n \n-        let crate_info = decoder::get_crate_info(ekrate.metadata.as_slice());\n+        let crate_info = ekrate.metadata.get_crate_info();\n         match (ekrate.dylib.as_ref(), crate_info.plugin_registrar_fn) {\n             (Some(dylib), Some(reg)) => {\n                 Some((dylib.to_path_buf(), crate_info.hash, reg))\n@@ -1111,7 +1112,7 @@ pub fn read_local_crates(sess: & Session,\n pub fn import_codemap(local_codemap: &codemap::CodeMap,\n                       metadata: &MetadataBlob)\n                       -> Vec<cstore::ImportedFileMap> {\n-    let external_codemap = decoder::get_imported_filemaps(metadata.as_slice());\n+    let external_codemap = metadata.get_imported_filemaps();\n \n     let imported_filemaps = external_codemap.into_iter().map(|filemap_to_import| {\n         // Try to find an existing FileMap that can be reused for the filemap to"}, {"sha": "8136fc7e845f3962dda1ed3b9304e9ede58f67ae", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 54, "deletions": 94, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=adddfccf2b63f7969d80d459788e973b56168ec4", "patch": "@@ -10,7 +10,6 @@\n \n use cstore;\n use common;\n-use decoder;\n use encoder;\n use loader;\n \n@@ -40,101 +39,87 @@ use rustc::hir;\n impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn stability(&self, def: DefId) -> Option<attr::Stability> {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_stability(&cdata, def.index)\n+        self.get_crate_data(def.krate).get_stability(def.index)\n     }\n \n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_deprecation(&cdata, def.index)\n+        self.get_crate_data(def.krate).get_deprecation(def.index)\n     }\n \n     fn visibility(&self, def: DefId) -> ty::Visibility {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_visibility(&cdata, def.index)\n+        self.get_crate_data(def.krate).get_visibility(def.index)\n     }\n \n     fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind\n     {\n         assert!(!def_id.is_local());\n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        let cdata = self.get_crate_data(def_id.krate);\n-        decoder::closure_kind(&cdata, def_id.index)\n+        self.get_crate_data(def_id.krate).closure_kind(def_id.index)\n     }\n \n     fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx> {\n         assert!(!def_id.is_local());\n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        let cdata = self.get_crate_data(def_id.krate);\n-        decoder::closure_ty(&cdata, def_id.index, tcx)\n+        self.get_crate_data(def_id.krate).closure_ty(def_id.index, tcx)\n     }\n \n     fn item_variances(&self, def: DefId) -> Vec<ty::Variance> {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_item_variances(&cdata, def.index)\n+        self.get_crate_data(def.krate).get_item_variances(def.index)\n     }\n \n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_type(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_type(def.index, tcx)\n     }\n \n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_predicates(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_predicates(def.index, tcx)\n     }\n \n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_super_predicates(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_super_predicates(def.index, tcx)\n     }\n \n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                          -> &'tcx ty::Generics<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_generics(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_generics(def.index, tcx)\n     }\n \n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        let cdata = self.get_crate_data(def_id.krate);\n-        decoder::get_item_attrs(&cdata, def_id.index)\n+        self.get_crate_data(def_id.krate).get_item_attrs(def_id.index)\n     }\n \n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_trait_def(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_trait_def(def.index, tcx)\n     }\n \n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_adt_def(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_adt_def(def.index, tcx)\n     }\n \n     fn fn_arg_names(&self, did: DefId) -> Vec<String>\n     {\n         self.dep_graph.read(DepNode::MetaData(did));\n-        let cdata = self.get_crate_data(did.krate);\n-        decoder::get_fn_arg_names(&cdata, did.index)\n+        self.get_crate_data(did.krate).get_fn_arg_names(did.index)\n     }\n \n     fn opt_item_name(&self, def: DefId) -> Option<ast::Name> {\n@@ -143,17 +128,16 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         if def.index == CRATE_DEF_INDEX {\n             Some(token::intern(&cdata.name()))\n         } else {\n-            decoder::maybe_get_item_name(&cdata, def.index)\n+            cdata.maybe_get_item_name(def.index)\n         }\n     }\n \n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         let mut result = vec![];\n-        let cdata = self.get_crate_data(def_id.krate);\n-        decoder::each_inherent_implementation_for_type(&cdata, def_id.index,\n-                                                       |iid| result.push(iid));\n+        self.get_crate_data(def_id.krate)\n+            .each_inherent_implementation_for_type(def_id.index, |iid| result.push(iid));\n         result\n     }\n \n@@ -164,7 +148,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         }\n         let mut result = vec![];\n         self.iter_crate_data(|_, cdata| {\n-            decoder::each_implementation_for_trait(cdata, filter, &mut |iid| {\n+            cdata.each_implementation_for_trait(filter, &mut |iid| {\n                 result.push(iid)\n             })\n         });\n@@ -174,85 +158,74 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId> {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         let mut result = vec![];\n-        let crate_data = self.get_crate_data(def_id.krate);\n         let get_crate_data = &mut |cnum| self.get_crate_data(cnum);\n-        decoder::each_child_of_item(&crate_data, def_id.index, get_crate_data,\n-                                    &mut |def, _, _| result.push(def.def_id()));\n+        self.get_crate_data(def_id.krate)\n+            .each_child_of_item(def_id.index, get_crate_data,\n+                                &mut |def, _, _| result.push(def.def_id()));\n         result\n     }\n \n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_impl_polarity(&cdata, def.index)\n+        self.get_crate_data(def.krate).get_impl_polarity(def.index)\n     }\n \n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_impl_trait(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_impl_trait(def.index, tcx)\n     }\n \n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_custom_coerce_unsized_kind(&cdata, def.index)\n+        self.get_crate_data(def.krate).get_custom_coerce_unsized_kind(def.index)\n     }\n \n     fn impl_parent(&self, impl_def: DefId) -> Option<DefId> {\n         self.dep_graph.read(DepNode::MetaData(impl_def));\n-        let cdata = self.get_crate_data(impl_def.krate);\n-        decoder::get_parent_impl(&*cdata, impl_def.index)\n+        self.get_crate_data(impl_def.krate).get_parent_impl(impl_def.index)\n     }\n \n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId> {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        let cdata = self.get_crate_data(def_id.krate);\n-        decoder::get_trait_of_item(&cdata, def_id.index)\n+        self.get_crate_data(def_id.krate).get_trait_of_item(def_id.index)\n     }\n \n     fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<ty::ImplOrTraitItem<'tcx>>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_impl_or_trait_item(&cdata, def.index, tcx)\n+        self.get_crate_data(def.krate).get_impl_or_trait_item(def.index, tcx)\n     }\n \n     fn is_const_fn(&self, did: DefId) -> bool\n     {\n         self.dep_graph.read(DepNode::MetaData(did));\n-        let cdata = self.get_crate_data(did.krate);\n-        decoder::is_const_fn(&cdata, did.index)\n+        self.get_crate_data(did.krate).is_const_fn(did.index)\n     }\n \n     fn is_defaulted_trait(&self, trait_def_id: DefId) -> bool\n     {\n         self.dep_graph.read(DepNode::MetaData(trait_def_id));\n-        let cdata = self.get_crate_data(trait_def_id.krate);\n-        decoder::is_defaulted_trait(&cdata, trait_def_id.index)\n+        self.get_crate_data(trait_def_id.krate).is_defaulted_trait(trait_def_id.index)\n     }\n \n     fn is_default_impl(&self, impl_did: DefId) -> bool {\n         self.dep_graph.read(DepNode::MetaData(impl_did));\n-        let cdata = self.get_crate_data(impl_did.krate);\n-        decoder::is_default_impl(&cdata, impl_did.index)\n+        self.get_crate_data(impl_did.krate).is_default_impl(impl_did.index)\n     }\n \n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool {\n         self.dep_graph.read(DepNode::MetaData(did));\n-        let cdata = self.get_crate_data(did.krate);\n-        decoder::is_extern_item(&cdata, did.index, tcx)\n+        self.get_crate_data(did.krate).is_extern_item(did.index, tcx)\n     }\n \n     fn is_foreign_item(&self, did: DefId) -> bool {\n-        let cdata = self.get_crate_data(did.krate);\n-        decoder::is_foreign_item(&cdata, did.index)\n+        self.get_crate_data(did.krate).is_foreign_item(did.index)\n     }\n \n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool\n@@ -263,21 +236,18 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n                                 -> Vec<(CrateNum, LinkagePreference)>\n     {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_dylib_dependency_formats(&cdata)\n+        self.get_crate_data(cnum).get_dylib_dependency_formats()\n     }\n \n     fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n     {\n-        let crate_data = self.get_crate_data(cnum);\n-        decoder::get_lang_items(&crate_data)\n+        self.get_crate_data(cnum).get_lang_items()\n     }\n \n     fn missing_lang_items(&self, cnum: CrateNum)\n                           -> Vec<lang_items::LangItem>\n     {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_missing_lang_items(&cdata)\n+        self.get_crate_data(cnum).get_missing_lang_items()\n     }\n \n     fn is_staged_api(&self, cnum: CrateNum) -> bool\n@@ -308,11 +278,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).panic_strategy()\n     }\n \n-    fn crate_attrs(&self, cnum: CrateNum) -> Vec<ast::Attribute>\n-    {\n-        decoder::get_item_attrs(&self.get_crate_data(cnum), CRATE_DEF_INDEX)\n-    }\n-\n     fn crate_name(&self, cnum: CrateNum) -> token::InternedString\n     {\n         token::intern_and_get_ident(&self.get_crate_data(cnum).name[..])\n@@ -348,18 +313,16 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>\n     {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_native_libraries(&cdata)\n+        self.get_crate_data(cnum).get_native_libraries()\n     }\n \n     fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>\n     {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_reachable_ids(&cdata)\n+        self.get_crate_data(cnum).get_reachable_ids()\n     }\n \n     fn is_no_builtins(&self, cnum: CrateNum) -> bool {\n-        attr::contains_name(&self.crate_attrs(cnum), \"no_builtins\")\n+        self.get_crate_data(cnum).is_no_builtins()\n     }\n \n     fn def_index_for_def_key(&self,\n@@ -380,43 +343,43 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         // canonical name for an item.\n         //\n         // self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::def_key(&cdata, def.index)\n+        self.get_crate_data(def.krate).def_key(def.index)\n     }\n \n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n         // See `Note` above in `def_key()` for why this read is\n         // commented out:\n         //\n         // self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::def_path(&cdata, def.index)\n+        self.get_crate_data(def.krate).def_path(def.index)\n     }\n \n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n     {\n         self.dep_graph.read(DepNode::MetaData(struct_def_id));\n-        let cdata = self.get_crate_data(struct_def_id.krate);\n-        decoder::get_struct_ctor_def_id(&cdata, struct_def_id.index)\n+        self.get_crate_data(struct_def_id.krate).get_struct_ctor_def_id(struct_def_id.index)\n     }\n \n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_struct_field_names(&cdata, def.index)\n+        self.get_crate_data(def.krate).get_struct_field_names(def.index)\n     }\n \n     fn item_children(&self, def_id: DefId) -> Vec<ChildItem>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         let mut result = vec![];\n-        let crate_data = self.get_crate_data(def_id.krate);\n         let get_crate_data = &mut |cnum| self.get_crate_data(cnum);\n-        decoder::each_child_of_item(&crate_data, def_id.index, get_crate_data,\n-                                    &mut |def, name, vis| {\n-            result.push(ChildItem { def: def, name: name, vis: vis });\n-        });\n+        self.get_crate_data(def_id.krate)\n+            .each_child_of_item(def_id.index, get_crate_data,\n+                                &mut |def, name, vis| {\n+                result.push(ChildItem {\n+                    def: def,\n+                    name: name,\n+                    vis: vis\n+                });\n+            });\n         result\n     }\n \n@@ -445,8 +408,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n         debug!(\"maybe_get_item_ast({}): inlining item\", tcx.item_path_str(def_id));\n \n-        let cdata = self.get_crate_data(def_id.krate);\n-        let inlined = decoder::maybe_get_item_ast(&cdata, tcx, def_id.index);\n+        let inlined = self.get_crate_data(def_id.krate).maybe_get_item_ast(tcx, def_id.index);\n \n         let cache_inlined_item = |original_def_id, inlined_item_id, inlined_root_node_id| {\n             let cache_entry = cstore::CachedInlinedItem {\n@@ -534,14 +496,12 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<Mir<'tcx>> {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::maybe_get_item_mir(&cdata, tcx, def.index)\n+        self.get_crate_data(def.krate).maybe_get_item_mir(tcx, def.index)\n     }\n \n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::is_item_mir_available(&cdata, def.index)\n+        self.get_crate_data(def.krate).is_item_mir_available(def.index)\n     }\n \n     fn crates(&self) -> Vec<CrateNum>"}, {"sha": "4151f98b3daeeef83ce6265a91f801111de98972", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=adddfccf2b63f7969d80d459788e973b56168ec4", "patch": "@@ -8,16 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types)]\n-\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n pub use self::MetadataBlob::*;\n \n use common;\n use creader;\n-use decoder;\n use index;\n use loader;\n \n@@ -297,7 +294,6 @@ impl CStore {\n }\n \n impl CrateMetadata {\n-    pub fn data<'a>(&'a self) -> &'a [u8] { self.data.as_slice() }\n     pub fn name(&self) -> &str { &self.info.name }\n     pub fn hash(&self) -> Svh { self.info.hash }\n     pub fn disambiguator(&self) -> &str { &self.info.disambiguator }\n@@ -317,37 +313,41 @@ impl CrateMetadata {\n     }\n \n     pub fn is_staged_api(&self) -> bool {\n-        let attrs = decoder::get_item_attrs(self, CRATE_DEF_INDEX);\n-        attrs.iter().any(|attr| {\n+        self.get_item_attrs(CRATE_DEF_INDEX).iter().any(|attr| {\n             attr.name() == \"stable\" || attr.name() == \"unstable\"\n         })\n     }\n \n     pub fn is_allocator(&self) -> bool {\n-        let attrs = decoder::get_item_attrs(self, CRATE_DEF_INDEX);\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"allocator\")\n     }\n \n     pub fn needs_allocator(&self) -> bool {\n-        let attrs = decoder::get_item_attrs(self, CRATE_DEF_INDEX);\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"needs_allocator\")\n     }\n \n     pub fn is_panic_runtime(&self) -> bool {\n-        let attrs = decoder::get_item_attrs(self, CRATE_DEF_INDEX);\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"panic_runtime\")\n     }\n \n     pub fn needs_panic_runtime(&self) -> bool {\n-        let attrs = decoder::get_item_attrs(self, CRATE_DEF_INDEX);\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"needs_panic_runtime\")\n     }\n \n     pub fn is_compiler_builtins(&self) -> bool {\n-        let attrs = decoder::get_crate_attributes(self.data());\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n         attr::contains_name(&attrs, \"compiler_builtins\")\n     }\n \n+    pub fn is_no_builtins(&self) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+        attr::contains_name(&attrs, \"no_builtins\")\n+    }\n+\n     pub fn panic_strategy(&self) -> PanicStrategy {\n         self.info.panic_strategy.clone()\n     }"}, {"sha": "05bd9e97234e542902029e4bb1ecfd3111ecbd12", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 657, "deletions": 728, "changes": 1385, "blob_url": "https://github.com/rust-lang/rust/blob/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=adddfccf2b63f7969d80d459788e973b56168ec4", "patch": "@@ -10,14 +10,11 @@\n \n // Decoding metadata from a single crate's metadata\n \n-#![allow(non_camel_case_types)]\n-\n use astencode::decode_inlined_item;\n-use cstore::{self, CrateMetadata};\n+use cstore::{CrateMetadata, MetadataBlob, NativeLibraryKind};\n use common::*;\n use index;\n \n-use rustc::hir::def_id::CRATE_DEF_INDEX;\n use rustc::hir::svh::Svh;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::{DefKey, DefPathData};\n@@ -43,7 +40,6 @@ use std::rc::Rc;\n use std::str;\n use std::u32;\n \n-use rbml::reader;\n use rbml;\n use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n@@ -53,44 +49,48 @@ use syntax_pos::{self, Span, BytePos};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n     pub opaque: opaque::Decoder<'a>,\n-    pub tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n-    pub cdata: Option<&'a cstore::CrateMetadata>,\n+    tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n+    cdata: Option<&'a CrateMetadata>,\n     pub from_id_range: IdRange,\n     pub to_id_range: IdRange,\n     // Cache the last used filemap for translating spans as an optimization.\n     last_filemap_index: usize,\n }\n \n-impl<'doc> rbml::Doc<'doc> {\n-    pub fn decoder<'tcx>(self) -> DecodeContext<'doc, 'tcx> {\n+impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n+    pub fn new(doc: rbml::Doc<'a>, cdata: Option<&'a CrateMetadata>)\n+               -> DecodeContext<'a, 'tcx> {\n         let id_range = IdRange {\n             min: NodeId::from_u32(u32::MIN),\n             max: NodeId::from_u32(u32::MAX)\n         };\n         DecodeContext {\n-            opaque: opaque::Decoder::new(self.data, self.start),\n-            cdata: None,\n+            opaque: opaque::Decoder::new(doc.data, doc.start),\n+            cdata: cdata,\n             tcx: None,\n             from_id_range: id_range,\n             to_id_range: id_range,\n             last_filemap_index: 0\n         }\n     }\n-}\n \n-impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n     }\n \n-    pub fn cdata(&self) -> &'a cstore::CrateMetadata {\n+    pub fn cdata(&self) -> &'a CrateMetadata {\n         self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n     }\n \n     pub fn decode<T: Decodable>(&mut self) -> T {\n         T::decode(self).unwrap()\n     }\n \n+    pub fn typed(mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        self.tcx = Some(tcx);\n+        self\n+    }\n+\n     /// Iterate over the indices of a sequence.\n     /// This will work solely because of `serialize::opaque`'s\n     /// simple encoding of `n: usize` followed by `n` elements.\n@@ -295,124 +295,84 @@ impl<'a, 'tcx> SpecializedDecoder<ty::AdtDef<'tcx>> for DecodeContext<'a, 'tcx>\n     }\n }\n \n-pub type Cmd<'a> = &'a CrateMetadata;\n+#[derive(Clone)]\n+pub struct CrateDep {\n+    pub cnum: CrateNum,\n+    pub name: String,\n+    pub hash: Svh,\n+    pub explicitly_linked: bool,\n+}\n \n-impl CrateMetadata {\n-    fn get_item(&self, item_id: DefIndex) -> Option<rbml::Doc> {\n-        self.index.lookup_item(self.data(), item_id).map(|pos| {\n-            rbml::Doc::at(self.data(), pos as usize)\n-        })\n+impl<'a, 'tcx> MetadataBlob {\n+    fn root(&self) -> rbml::Doc {\n+        rbml::Doc::new(self.as_slice())\n     }\n \n-    fn lookup_item(&self, item_id: DefIndex) -> rbml::Doc {\n-        match self.get_item(item_id) {\n-            None => bug!(\"lookup_item: id not found: {:?} in crate {:?} with number {}\",\n-                         item_id,\n-                         self.name,\n-                         self.cnum),\n-            Some(d) => d\n-        }\n+    fn child_at(&'a self, pos: usize, tag: usize) -> DecodeContext<'a, 'tcx> {\n+        DecodeContext::new(rbml::Doc::at(self.as_slice(), pos).child(tag), None)\n     }\n \n-    fn local_def_id(&self, index: DefIndex) -> DefId {\n-        DefId {\n-            krate: self.cnum,\n-            index: index\n-        }\n+    fn get(&'a self, tag: usize) -> DecodeContext<'a, 'tcx> {\n+        DecodeContext::new(self.root().child(tag), None)\n     }\n-}\n-\n-pub fn load_index(data: &[u8]) -> index::Index {\n-    index::Index::from_rbml(rbml::Doc::new(data).get(root_tag::index))\n-}\n-\n-pub fn crate_rustc_version(data: &[u8]) -> Option<String> {\n-    let doc = rbml::Doc::new(data);\n-    reader::maybe_get_doc(doc, root_tag::rustc_version).map(|s| {\n-        str::from_utf8(&s.data[s.start..s.end]).unwrap().to_string()\n-    })\n-}\n-\n-// Go through each item in the metadata and create a map from that\n-// item's def-key to the item's DefIndex.\n-pub fn load_key_map(data: &[u8]) -> FnvHashMap<DefKey, DefIndex> {\n-    load_index(data).iter_enumerated(data).map(|(index, pos)| {\n-        // load def-key from item\n-        let key = item_def_key(rbml::Doc::at(data, pos as usize));\n-        (key, index)\n-    }).collect()\n-}\n-\n-fn item_family(item: rbml::Doc) -> Family {\n-    item.get(item_tag::family).decoder().decode()\n-}\n \n-fn item_visibility(item: rbml::Doc) -> ty::Visibility {\n-    item.get(item_tag::visibility).decoder().decode()\n-}\n-\n-fn entry_data(doc: rbml::Doc, cdata: Cmd) -> EntryData {\n-    let mut dcx = doc.get(item_tag::data).decoder();\n-    dcx.cdata = Some(cdata);\n+    pub fn load_index(&self) -> index::Index {\n+        index::Index::from_rbml(self.root().child(root_tag::index))\n+    }\n \n-    dcx.decode()\n-}\n+    pub fn crate_rustc_version(&self) -> Option<String> {\n+        self.root().maybe_child(root_tag::rustc_version).map(|s| {\n+            str::from_utf8(&s.data[s.start..s.end]).unwrap().to_string()\n+        })\n+    }\n \n-fn entry_typed_data<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n-                              -> EntryTypedData<'tcx> {\n-    let mut dcx = doc.get(item_tag::typed_data).decoder();\n-    dcx.cdata = Some(cdata);\n-    dcx.tcx = Some(tcx);\n+    // Go through each item in the metadata and create a map from that\n+    // item's def-key to the item's DefIndex.\n+    pub fn load_key_map(&self) -> FnvHashMap<DefKey, DefIndex> {\n+        self.load_index().iter_enumerated(self.as_slice()).map(|(index, pos)| {\n+            (self.child_at(pos as usize, item_tag::def_key).decode(), index)\n+        }).collect()\n+    }\n \n-    dcx.decode()\n-}\n+    pub fn get_crate_deps(&self) -> Vec<CrateDep> {\n+        let dcx = self.get(root_tag::crate_deps);\n \n-fn item_parent_item(cdata: Cmd, d: rbml::Doc) -> Option<DefId> {\n-    item_def_key(d).parent.map(|index| cdata.local_def_id(index))\n-}\n+        dcx.seq().enumerate().map(|(crate_num, (name, hash, explicitly_linked))| {\n+            CrateDep {\n+                cnum: CrateNum::new(crate_num + 1),\n+                name: name,\n+                hash: hash,\n+                explicitly_linked: explicitly_linked,\n+            }\n+        }).collect()\n+    }\n \n-fn doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n-    maybe_doc_type(doc, tcx, cdata).expect(\"missing item_tag::ty\")\n-}\n+    pub fn get_crate_info(&self) -> CrateInfo {\n+        self.get(root_tag::crate_info).decode()\n+    }\n \n-fn maybe_doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n-                            -> Option<Ty<'tcx>> {\n-    reader::maybe_get_doc(doc, item_tag::ty).map(|tp| {\n-        let mut dcx = tp.decoder();\n-        dcx.tcx = Some(tcx);\n-        dcx.cdata = Some(cdata);\n-        dcx.decode()\n-    })\n-}\n+    pub fn list_crate_metadata(&self, out: &mut io::Write) -> io::Result<()> {\n+        write!(out, \"=External Dependencies=\\n\")?;\n+        for dep in &self.get_crate_deps() {\n+            write!(out, \"{} {}-{}\\n\", dep.cnum, dep.name, dep.hash)?;\n+        }\n+        write!(out, \"\\n\")?;\n+        Ok(())\n+    }\n \n-fn item_name(item: rbml::Doc) -> ast::Name {\n-    maybe_item_name(item).expect(\"no item in item_name\")\n-}\n+    pub fn get_imported_filemaps(&self) -> Vec<syntax_pos::FileMap> {\n+        self.get(root_tag::codemap).decode()\n+    }\n \n-fn maybe_item_name(item: rbml::Doc) -> Option<ast::Name> {\n-    let name = match item_def_key(item).disambiguated_data.data {\n-        DefPathData::TypeNs(name) |\n-        DefPathData::ValueNs(name) |\n-        DefPathData::Module(name) |\n-        DefPathData::MacroDef(name) |\n-        DefPathData::TypeParam(name) |\n-        DefPathData::LifetimeDef(name) |\n-        DefPathData::EnumVariant(name) |\n-        DefPathData::Field(name) |\n-        DefPathData::Binding(name) => Some(name),\n-\n-        DefPathData::InlinedRoot(_) => bug!(\"unexpected DefPathData\"),\n-\n-        DefPathData::CrateRoot |\n-        DefPathData::Misc |\n-        DefPathData::Impl |\n-        DefPathData::ClosureExpr |\n-        DefPathData::StructCtor |\n-        DefPathData::Initializer |\n-        DefPathData::ImplTrait => None\n-    };\n-\n-    name.map(|s| token::intern(&s))\n+    pub fn each_exported_macro<F>(&self, mut f: F) where\n+        F: FnMut(ast::Name, Vec<ast::Attribute>, Span, String) -> bool,\n+    {\n+        for (name, attrs, span, body) in self.get(root_tag::macro_defs).seq() {\n+            if !f(name, attrs, span, body) {\n+                break;\n+            }\n+        }\n+    }\n }\n \n impl Family {\n@@ -444,729 +404,698 @@ impl Family {\n     }\n }\n \n-pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n-                               item_id: DefIndex,\n-                               tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::TraitDef<'tcx>\n-{\n-    let item_doc = cdata.lookup_item(item_id);\n-    let generics = doc_generics(item_doc, tcx, cdata);\n-\n-    let data = match entry_data(item_doc, cdata) {\n-        EntryData::Trait(data) => data,\n-        _ => bug!()\n-    };\n-    let typed_data = match entry_typed_data(item_doc, tcx, cdata) {\n-        EntryTypedData::Trait(data) => data,\n-        _ => bug!()\n-    };\n-\n-    ty::TraitDef::new(data.unsafety, data.paren_sugar, generics, typed_data.trait_ref,\n-                      def_path(cdata, item_id).unwrap().deterministic_hash(tcx)))\n-}\n-\n-fn get_variant<'tcx>(cdata: Cmd,\n-                     item: rbml::Doc,\n-                     index: DefIndex)\n-                     -> (ty::VariantDefData<'tcx, 'tcx>, Option<DefIndex>) {\n-    let data = match entry_data(item, cdata) {\n-        EntryData::Variant(data) => data,\n-        _ => bug!()\n-    };\n-\n-    let mut dcx = item.get(item_tag::children).decoder();\n-    dcx.cdata = Some(cdata);\n-\n-    let fields = dcx.seq().map(|index| {\n-        let f = cdata.lookup_item(index);\n-        ty::FieldDefData::new(cdata.local_def_id(index),\n-                              item_name(f),\n-                              item_visibility(f))\n-    }).collect();\n-\n-    (ty::VariantDefData {\n-        did: cdata.local_def_id(data.struct_ctor.unwrap_or(index)),\n-        name: item_name(item),\n-        fields: fields,\n-        disr_val: ConstInt::Infer(data.disr),\n-        kind: data.kind,\n-    }, data.struct_ctor)\n-}\n+impl<'a, 'tcx> CrateMetadata {\n+    fn maybe_get(&'a self, item: rbml::Doc<'a>, tag: usize)\n+                 -> Option<DecodeContext<'a, 'tcx>> {\n+        item.maybe_child(tag).map(|child| {\n+            DecodeContext::new(child, Some(self))\n+        })\n+    }\n \n-pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n-                             item_id: DefIndex,\n-                             tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                             -> ty::AdtDefMaster<'tcx>\n-{\n-    let doc = cdata.lookup_item(item_id);\n-    let did = cdata.local_def_id(item_id);\n-    let mut ctor_index = None;\n-    let family = item_family(doc);\n-    let variants = if family == Family::Enum {\n-        let mut dcx = doc.get(item_tag::children).decoder();\n-        dcx.cdata = Some(cdata);\n-\n-        dcx.seq().map(|index| {\n-            let (variant, struct_ctor) = get_variant(cdata, cdata.lookup_item(index), index);\n-            assert_eq!(struct_ctor, None);\n-            variant\n-        }).collect()\n-    } else{\n-        let (variant, struct_ctor) = get_variant(cdata, doc, item_id);\n-        ctor_index = struct_ctor;\n-        vec![variant]\n-    };\n-    let kind = match family {\n-        Family::Enum => ty::AdtKind::Enum,\n-        Family::Struct => ty::AdtKind::Struct,\n-        Family::Union => ty::AdtKind::Union,\n-        _ => bug!(\"get_adt_def called on a non-ADT {:?} - {:?}\",\n-                  family, did)\n-    };\n-\n-    let adt = tcx.intern_adt_def(did, kind, variants);\n-    if let Some(ctor_index) = ctor_index {\n-        // Make adt definition available through constructor id as well.\n-        tcx.insert_adt_def(cdata.local_def_id(ctor_index), adt);\n-    }\n-\n-    // this needs to be done *after* the variant is interned,\n-    // to support recursive structures\n-    for variant in &adt.variants {\n-        for field in &variant.fields {\n-            debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n-            let ty = get_type(cdata, field.did.index, tcx);\n-            field.fulfill_ty(ty);\n-            debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n-                   variant.name, field.name, ty);\n+    fn get(&'a self, item: rbml::Doc<'a>, tag: usize) -> DecodeContext<'a, 'tcx> {\n+        match self.maybe_get(item, tag) {\n+            Some(dcx) => dcx,\n+            None => bug!(\"failed to find child with tag {}\", tag)\n         }\n     }\n \n-    adt\n-}\n+    fn item_family(&self, item: rbml::Doc) -> Family {\n+        self.get(item, item_tag::family).decode()\n+    }\n \n-pub fn get_predicates<'a, 'tcx>(cdata: Cmd,\n-                                item_id: DefIndex,\n-                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                -> ty::GenericPredicates<'tcx>\n-{\n-    let item_doc = cdata.lookup_item(item_id);\n-    doc_predicates(item_doc, tcx, cdata, item_tag::predicates)\n-}\n+    fn item_visibility(&self, item: rbml::Doc) -> ty::Visibility {\n+        self.get(item, item_tag::visibility).decode()\n+    }\n \n-pub fn get_super_predicates<'a, 'tcx>(cdata: Cmd,\n-                                      item_id: DefIndex,\n-                                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                      -> ty::GenericPredicates<'tcx>\n-{\n-    let item_doc = cdata.lookup_item(item_id);\n-    doc_predicates(item_doc, tcx, cdata, item_tag::super_predicates)\n-}\n+    fn item_def_key(&self, item: rbml::Doc) -> hir_map::DefKey {\n+        self.get(item, item_tag::def_key).decode()\n+    }\n \n-pub fn get_generics<'a, 'tcx>(cdata: Cmd,\n-                              item_id: DefIndex,\n-                              tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                              -> &'tcx ty::Generics<'tcx>\n-{\n-    let item_doc = cdata.lookup_item(item_id);\n-    doc_generics(item_doc, tcx, cdata)\n-}\n+    fn item_name(&self, item: rbml::Doc) -> ast::Name {\n+        self.maybe_item_name(item).expect(\"no item in item_name\")\n+    }\n \n-pub fn get_type<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                          -> Ty<'tcx>\n-{\n-    let item_doc = cdata.lookup_item(id);\n-    doc_type(item_doc, tcx, cdata)\n-}\n+    fn maybe_item_name(&self, item: rbml::Doc) -> Option<ast::Name> {\n+        let name = match self.item_def_key(item).disambiguated_data.data {\n+            DefPathData::TypeNs(name) |\n+            DefPathData::ValueNs(name) |\n+            DefPathData::Module(name) |\n+            DefPathData::MacroDef(name) |\n+            DefPathData::TypeParam(name) |\n+            DefPathData::LifetimeDef(name) |\n+            DefPathData::EnumVariant(name) |\n+            DefPathData::Field(name) |\n+            DefPathData::Binding(name) => Some(name),\n+\n+            DefPathData::InlinedRoot(_) => bug!(\"unexpected DefPathData\"),\n+\n+            DefPathData::CrateRoot |\n+            DefPathData::Misc |\n+            DefPathData::Impl |\n+            DefPathData::ClosureExpr |\n+            DefPathData::StructCtor |\n+            DefPathData::Initializer |\n+            DefPathData::ImplTrait => None\n+        };\n \n-pub fn get_stability(cdata: Cmd, id: DefIndex) -> Option<attr::Stability> {\n-    let item = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item, item_tag::stability).map(|doc| {\n-        doc.decoder().decode()\n-    })\n-}\n+        name.map(|s| token::intern(&s))\n+    }\n \n-pub fn get_deprecation(cdata: Cmd, id: DefIndex) -> Option<attr::Deprecation> {\n-    let item = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item, item_tag::deprecation).map(|doc| {\n-        doc.decoder().decode()\n-    })\n-}\n+    fn maybe_entry(&self, item_id: DefIndex) -> Option<rbml::Doc> {\n+        self.index.lookup_item(self.data.as_slice(), item_id).map(|pos| {\n+            rbml::Doc::at(self.data.as_slice(), pos as usize)\n+        })\n+    }\n \n-pub fn get_visibility(cdata: Cmd, id: DefIndex) -> ty::Visibility {\n-    item_visibility(cdata.lookup_item(id))\n-}\n+    fn entry(&self, item_id: DefIndex) -> rbml::Doc {\n+        match self.maybe_entry(item_id) {\n+            None => bug!(\"entry: id not found: {:?} in crate {:?} with number {}\",\n+                         item_id,\n+                         self.name,\n+                         self.cnum),\n+            Some(d) => d\n+        }\n+    }\n \n-fn get_impl_data(cdata: Cmd, id: DefIndex) -> ImplData {\n-    match entry_data(cdata.lookup_item(id), cdata) {\n-        EntryData::Impl(data) => data,\n-        _ => bug!()\n+    fn local_def_id(&self, index: DefIndex) -> DefId {\n+        DefId {\n+            krate: self.cnum,\n+            index: index\n+        }\n     }\n-}\n \n-pub fn get_parent_impl(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n-    get_impl_data(cdata, id).parent_impl\n-}\n+    fn entry_data(&self, doc: rbml::Doc) -> EntryData {\n+        self.get(doc, item_tag::data).decode()\n+    }\n \n-pub fn get_impl_polarity(cdata: Cmd, id: DefIndex) -> hir::ImplPolarity {\n-    get_impl_data(cdata, id).polarity\n-}\n+    fn entry_typed_data(&self, doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                        -> EntryTypedData<'tcx> {\n+        self.get(doc, item_tag::typed_data).typed(tcx).decode()\n+    }\n \n-pub fn get_custom_coerce_unsized_kind(\n-    cdata: Cmd,\n-    id: DefIndex)\n-    -> Option<ty::adjustment::CustomCoerceUnsized>\n-{\n-    get_impl_data(cdata, id).coerce_unsized_kind\n-}\n+    fn item_parent_item(&self, d: rbml::Doc) -> Option<DefId> {\n+        self.item_def_key(d).parent.map(|index| self.local_def_id(index))\n+    }\n \n-pub fn get_impl_trait<'a, 'tcx>(cdata: Cmd,\n-                                id: DefIndex,\n-                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                -> Option<ty::TraitRef<'tcx>>\n-{\n-    match entry_typed_data(cdata.lookup_item(id), tcx, cdata) {\n-        EntryTypedData::Impl(data) => data.trait_ref,\n-        _ => bug!()\n+    fn doc_type(&self, doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+        self.maybe_doc_type(doc, tcx).expect(\"missing item_tag::ty\")\n     }\n-}\n \n-/// Iterates over the language items in the given crate.\n-pub fn get_lang_items(cdata: Cmd) -> Vec<(DefIndex, usize)> {\n-    rbml::Doc::new(cdata.data()).get(root_tag::lang_items).decoder().decode()\n-}\n+    fn maybe_doc_type(&self, doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Ty<'tcx>> {\n+        self.maybe_get(doc, item_tag::ty).map(|dcx| dcx.typed(tcx).decode())\n+    }\n \n+    pub fn get_trait_def(&self,\n+                         item_id: DefIndex,\n+                         tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::TraitDef<'tcx> {\n+        let item_doc = self.entry(item_id);\n+        let generics = self.doc_generics(item_doc, tcx);\n \n-/// Iterates over each child of the given item.\n-pub fn each_child_of_item<F, G>(cdata: Cmd, id: DefIndex,\n-                                mut get_crate_data: &mut G,\n-                                mut callback: &mut F)\n-    where F: FnMut(Def, ast::Name, ty::Visibility),\n-          G: FnMut(CrateNum) -> Rc<CrateMetadata>,\n-{\n-    // Find the item.\n-    let item_doc = match cdata.get_item(id) {\n-        None => return,\n-        Some(item_doc) => item_doc,\n-    };\n-\n-    let mut dcx = match reader::maybe_get_doc(item_doc, item_tag::children) {\n-        Some(doc) => doc.decoder(),\n-        None => return\n-    };\n-    dcx.cdata = Some(cdata);\n-\n-    // Iterate over all children.\n-    for child_index in dcx.seq::<DefIndex>() {\n-        // Get the item.\n-        if let Some(child) = cdata.get_item(child_index) {\n-            // Hand off the item to the callback.\n-            let family = item_family(child);\n-            if let Family::ForeignMod = family {\n-                each_child_of_item(cdata, child_index, get_crate_data, callback);\n-            } else if let Some(def) = family.to_def(cdata.local_def_id(child_index)) {\n-                callback(def, item_name(child), item_visibility(child));\n-            }\n-        }\n+        let data = match self.entry_data(item_doc) {\n+            EntryData::Trait(data) => data,\n+            _ => bug!()\n+        };\n+        let typed_data = match self.entry_typed_data(item_doc, tcx) {\n+            EntryTypedData::Trait(data) => data,\n+            _ => bug!()\n+        };\n+\n+        ty::TraitDef::new(data.unsafety, data.paren_sugar, generics, typed_data.trait_ref,\n+                          self.def_path(item_id).unwrap().deterministic_hash(tcx)))\n     }\n \n-    let reexports = match entry_data(item_doc, cdata) {\n-        EntryData::Mod(data) => data.reexports,\n-        _ => return\n-    };\n-    for exp in reexports {\n-        // This reexport may be in yet another crate.\n-        let crate_data = if exp.def_id.krate == cdata.cnum {\n-            None\n-        } else {\n-            Some(get_crate_data(exp.def_id.krate))\n+    fn get_variant(&self, item: rbml::Doc, index: DefIndex)\n+                  -> (ty::VariantDefData<'tcx, 'tcx>, Option<DefIndex>) {\n+        let data = match self.entry_data(item) {\n+            EntryData::Variant(data) => data,\n+            _ => bug!()\n         };\n-        let crate_data = match crate_data {\n-            Some(ref cdata) => &**cdata,\n-            None => cdata\n+\n+        let fields = self.get(item, item_tag::children).seq().map(|index| {\n+            let f = self.entry(index);\n+            ty::FieldDefData::new(self.local_def_id(index),\n+                                  self.item_name(f),\n+                                  self.item_visibility(f))\n+        }).collect();\n+\n+        (ty::VariantDefData {\n+            did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n+            name: self.item_name(item),\n+            fields: fields,\n+            disr_val: ConstInt::Infer(data.disr),\n+            kind: data.kind,\n+        }, data.struct_ctor)\n+    }\n+\n+    pub fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                       -> ty::AdtDefMaster<'tcx> {\n+        let doc = self.entry(item_id);\n+        let did = self.local_def_id(item_id);\n+        let mut ctor_index = None;\n+        let family = self.item_family(doc);\n+        let variants = if family == Family::Enum {\n+            self.get(doc, item_tag::children).seq().map(|index| {\n+                let (variant, struct_ctor) = self.get_variant(self.entry(index), index);\n+                assert_eq!(struct_ctor, None);\n+                variant\n+            }).collect()\n+        } else{\n+            let (variant, struct_ctor) = self.get_variant(doc, item_id);\n+            ctor_index = struct_ctor;\n+            vec![variant]\n+        };\n+        let kind = match family {\n+            Family::Enum => ty::AdtKind::Enum,\n+            Family::Struct => ty::AdtKind::Struct,\n+            Family::Union => ty::AdtKind::Union,\n+            _ => bug!(\"get_adt_def called on a non-ADT {:?} - {:?}\",\n+                      family, did)\n         };\n \n-        // Get the item.\n-        if let Some(child) = crate_data.get_item(exp.def_id.index) {\n-            // Hand off the item to the callback.\n-            if let Some(def) = item_family(child).to_def(exp.def_id) {\n-                // These items have a public visibility because they're part of\n-                // a public re-export.\n-                callback(def, exp.name, ty::Visibility::Public);\n+        let adt = tcx.intern_adt_def(did, kind, variants);\n+        if let Some(ctor_index) = ctor_index {\n+            // Make adt definition available through constructor id as well.\n+            tcx.insert_adt_def(self.local_def_id(ctor_index), adt);\n+        }\n+\n+        // this needs to be done *after* the variant is interned,\n+        // to support recursive structures\n+        for variant in &adt.variants {\n+            for field in &variant.fields {\n+                debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n+                let ty = self.get_type(field.did.index, tcx);\n+                field.fulfill_ty(ty);\n+                debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n+                       variant.name, field.name, ty);\n             }\n         }\n+\n+        adt\n     }\n-}\n \n-pub fn maybe_get_item_name(cdata: Cmd, id: DefIndex) -> Option<ast::Name> {\n-    maybe_item_name(cdata.lookup_item(id))\n-}\n+    pub fn get_predicates(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                          -> ty::GenericPredicates<'tcx> {\n+        self.doc_predicates(self.entry(item_id), tcx, item_tag::predicates)\n+    }\n \n-pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n-                                    -> Option<&'tcx InlinedItem> {\n-    debug!(\"Looking up item: {:?}\", id);\n-    let item_doc = cdata.lookup_item(id);\n-    let item_did = cdata.local_def_id(id);\n-    let parent_def_id = cdata.local_def_id(def_key(cdata, id).parent.unwrap());\n-    let mut parent_def_path = def_path(cdata, id).unwrap();\n-    parent_def_path.data.pop();\n-    reader::maybe_get_doc(item_doc, item_tag::ast).map(|ast_doc| {\n-        decode_inlined_item(cdata, tcx, parent_def_path, parent_def_id, ast_doc, item_did)\n-    })\n-}\n+    pub fn get_super_predicates(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                -> ty::GenericPredicates<'tcx> {\n+        self.doc_predicates(self.entry(item_id), tcx, item_tag::super_predicates)\n+    }\n \n-pub fn is_item_mir_available<'tcx>(cdata: Cmd, id: DefIndex) -> bool {\n-    if let Some(item_doc) = cdata.get_item(id) {\n-        return reader::maybe_get_doc(item_doc, item_tag::mir as usize).is_some();\n+    pub fn get_generics(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                        -> &'tcx ty::Generics<'tcx> {\n+        self.doc_generics(self.entry(item_id), tcx)\n     }\n \n-    false\n-}\n+    pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+        self.doc_type(self.entry(id), tcx)\n+    }\n \n-pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n-                                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    id: DefIndex)\n-                                    -> Option<Mir<'tcx>> {\n-    let item_doc = cdata.lookup_item(id);\n-\n-    reader::maybe_get_doc(item_doc, item_tag::mir).map(|mir_doc| {\n-        let mut dcx = mir_doc.decoder();\n-        dcx.tcx = Some(tcx);\n-        dcx.cdata = Some(cdata);\n-        dcx.decode()\n-    })\n-}\n+    pub fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n+        self.maybe_get(self.entry(id), item_tag::stability).map(|mut dcx| {\n+            dcx.decode()\n+        })\n+    }\n \n-pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                        -> Option<ty::ImplOrTraitItem<'tcx>> {\n-    let item_doc = cdata.lookup_item(id);\n-    let family = item_family(item_doc);\n+    pub fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n+        self.maybe_get(self.entry(id), item_tag::deprecation).map(|mut dcx| {\n+            dcx.decode()\n+        })\n+    }\n \n-    match family {\n-        Family::AssociatedConst |\n-        Family::Method |\n-        Family::AssociatedType => {}\n+    pub fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n+        self.item_visibility(self.entry(id))\n+    }\n \n-        _ => return None\n+    fn get_impl_data(&self, id: DefIndex) -> ImplData {\n+        match self.entry_data(self.entry(id)) {\n+            EntryData::Impl(data) => data,\n+            _ => bug!()\n+        }\n     }\n \n-    let def_id = cdata.local_def_id(id);\n+    pub fn get_parent_impl(&self, id: DefIndex) -> Option<DefId> {\n+        self.get_impl_data(id).parent_impl\n+    }\n \n-    let container_id = item_parent_item(cdata, item_doc).unwrap();\n-    let container = match item_family(cdata.lookup_item(container_id.index)) {\n-        Family::Trait => TraitContainer(container_id),\n-        _ => ImplContainer(container_id),\n-    };\n+    pub fn get_impl_polarity(&self, id: DefIndex) -> hir::ImplPolarity {\n+        self.get_impl_data(id).polarity\n+    }\n \n-    let name = item_name(item_doc);\n-    let vis = item_visibility(item_doc);\n+    pub fn get_custom_coerce_unsized_kind(&self, id: DefIndex)\n+                                          -> Option<ty::adjustment::CustomCoerceUnsized> {\n+        self.get_impl_data(id).coerce_unsized_kind\n+    }\n \n-    let (defaultness, has_body) = match entry_data(item_doc, cdata) {\n-        EntryData::TraitAssociated(data) => {\n-            (hir::Defaultness::Default, data.has_default)\n+    pub fn get_impl_trait(&self,\n+                          id: DefIndex,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                          -> Option<ty::TraitRef<'tcx>> {\n+        match self.entry_typed_data(self.entry(id), tcx) {\n+            EntryTypedData::Impl(data) => data.trait_ref,\n+            _ => bug!()\n         }\n-        EntryData::ImplAssociated(data) => {\n-            (data.defaultness, true)\n-        }\n-        _ => bug!()\n-    };\n+    }\n \n-    Some(match family {\n-        Family::AssociatedConst => {\n-            let ty = doc_type(item_doc, tcx, cdata);\n-            ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n-                name: name,\n-                ty: ty,\n-                vis: vis,\n-                defaultness: defaultness,\n-                def_id: def_id,\n-                container: container,\n-                has_value: has_body,\n-            }))\n+    /// Iterates over the language items in the given crate.\n+    pub fn get_lang_items(&self) -> Vec<(DefIndex, usize)> {\n+        self.get(self.data.root(), root_tag::lang_items).decode()\n+    }\n+\n+    /// Iterates over each child of the given item.\n+    pub fn each_child_of_item<F, G>(&self, id: DefIndex,\n+                                    mut get_crate_data: &mut G,\n+                                    mut callback: &mut F)\n+        where F: FnMut(Def, ast::Name, ty::Visibility),\n+              G: FnMut(CrateNum) -> Rc<CrateMetadata>,\n+    {\n+        // Find the item.\n+        let item_doc = match self.maybe_entry(id) {\n+            None => return,\n+            Some(item_doc) => item_doc,\n+        };\n+\n+        let dcx = match self.maybe_get(item_doc, item_tag::children) {\n+            Some(dcx) => dcx,\n+            None => return\n+        };\n+\n+        // Iterate over all children.\n+        for child_index in dcx.seq::<DefIndex>() {\n+            // Get the item.\n+            if let Some(child) = self.maybe_entry(child_index) {\n+                // Hand off the item to the callback.\n+                let family = self.item_family(child);\n+                if let Family::ForeignMod = family {\n+                    self.each_child_of_item(child_index, get_crate_data, callback);\n+                } else if let Some(def) = family.to_def(self.local_def_id(child_index)) {\n+                    callback(def, self.item_name(child), self.item_visibility(child));\n+                }\n+            }\n         }\n-        Family::Method => {\n-            let generics = doc_generics(item_doc, tcx, cdata);\n-            let predicates = doc_predicates(item_doc, tcx, cdata, item_tag::predicates);\n-            let ity = tcx.lookup_item_type(def_id).ty;\n-            let fty = match ity.sty {\n-                ty::TyFnDef(.., fty) => fty,\n-                _ => bug!(\n-                    \"the type {:?} of the method {:?} is not a function?\",\n-                    ity, name)\n-            };\n \n-            let explicit_self = match entry_typed_data(item_doc, tcx, cdata) {\n-                EntryTypedData::Method(data) => data.explicit_self,\n-                _ => bug!()\n+        let reexports = match self.entry_data(item_doc) {\n+            EntryData::Mod(data) => data.reexports,\n+            _ => return\n+        };\n+        for exp in reexports {\n+            // This reexport may be in yet another crate.\n+            let crate_data = if exp.def_id.krate == self.cnum {\n+                None\n+            } else {\n+                Some(get_crate_data(exp.def_id.krate))\n             };\n-            ty::MethodTraitItem(Rc::new(ty::Method {\n-                name: name,\n-                generics: generics,\n-                predicates: predicates,\n-                fty: fty,\n-                explicit_self: explicit_self,\n-                vis: vis,\n-                defaultness: defaultness,\n-                has_body: has_body,\n-                def_id: def_id,\n-                container: container,\n-            }))\n-        }\n-        Family::AssociatedType => {\n-            let ty = maybe_doc_type(item_doc, tcx, cdata);\n-            ty::TypeTraitItem(Rc::new(ty::AssociatedType {\n-                name: name,\n-                ty: ty,\n-                vis: vis,\n-                defaultness: defaultness,\n-                def_id: def_id,\n-                container: container,\n-            }))\n+            let crate_data = match crate_data {\n+                Some(ref cdata) => &**cdata,\n+                None => self\n+            };\n+\n+            // Get the item.\n+            if let Some(child) = crate_data.maybe_entry(exp.def_id.index) {\n+                // Hand off the item to the callback.\n+                if let Some(def) = self.item_family(child).to_def(exp.def_id) {\n+                    // These items have a public visibility because they're part of\n+                    // a public re-export.\n+                    callback(def, exp.name, ty::Visibility::Public);\n+                }\n+            }\n         }\n-        _ => bug!()\n-    })\n-}\n+    }\n \n-pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> Vec<ty::Variance> {\n-    let item_doc = cdata.lookup_item(id);\n-    item_doc.get(item_tag::variances).decoder().decode()\n-}\n+    pub fn maybe_get_item_name(&self, id: DefIndex) -> Option<ast::Name> {\n+        self.maybe_item_name(self.entry(id))\n+    }\n \n-pub fn get_struct_ctor_def_id(cdata: Cmd, node_id: DefIndex) -> Option<DefId>\n-{\n-    let data = match entry_data(cdata.lookup_item(node_id), cdata) {\n-        EntryData::Variant(data) => data,\n-        _ => bug!()\n-    };\n+    pub fn maybe_get_item_ast(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n+                              -> Option<&'tcx InlinedItem> {\n+        debug!(\"Looking up item: {:?}\", id);\n+        let item_doc = self.entry(id);\n+        let item_did = self.local_def_id(id);\n+        let parent_def_id = self.local_def_id(self.def_key(id).parent.unwrap());\n+        let mut parent_def_path = self.def_path(id).unwrap();\n+        parent_def_path.data.pop();\n+        item_doc.maybe_child(item_tag::ast).map(|ast_doc| {\n+            decode_inlined_item(self, tcx, parent_def_path, parent_def_id, ast_doc, item_did)\n+        })\n+    }\n \n-    data.struct_ctor.map(|index| cdata.local_def_id(index))\n-}\n+    pub fn is_item_mir_available(&self, id: DefIndex) -> bool {\n+        if let Some(item_doc) = self.maybe_entry(id) {\n+            return item_doc.maybe_child(item_tag::mir).is_some();\n+        }\n \n-pub fn get_item_attrs(cdata: Cmd,\n-                      node_id: DefIndex)\n-                      -> Vec<ast::Attribute> {\n-    // The attributes for a tuple struct are attached to the definition, not the ctor;\n-    // we assume that someone passing in a tuple struct ctor is actually wanting to\n-    // look at the definition\n-    let mut item = cdata.lookup_item(node_id);\n-    let def_key = item_def_key(item);\n-    if def_key.disambiguated_data.data == DefPathData::StructCtor {\n-        item = cdata.lookup_item(def_key.parent.unwrap());\n-    }\n-    get_attributes(item)\n-}\n+        false\n+    }\n \n-pub fn get_struct_field_names(cdata: Cmd, id: DefIndex) -> Vec<ast::Name> {\n-    let mut dcx = cdata.lookup_item(id).get(item_tag::children).decoder();\n-    dcx.cdata = Some(cdata);\n+    pub fn maybe_get_item_mir(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n+                              -> Option<Mir<'tcx>> {\n+        self.maybe_get(self.entry(id), item_tag::mir).map(|dcx| {\n+            dcx.typed(tcx).decode()\n+        })\n+    }\n \n-    dcx.seq().map(|index| item_name(cdata.lookup_item(index))).collect()\n-}\n+    pub fn get_impl_or_trait_item(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                  -> Option<ty::ImplOrTraitItem<'tcx>> {\n+        let item_doc = self.entry(id);\n+        let family = self.item_family(item_doc);\n \n-fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n-    reader::maybe_get_doc(md, item_tag::attributes).map_or(vec![], |attrs_doc| {\n-        let mut attrs = attrs_doc.decoder().decode::<Vec<ast::Attribute>>();\n+        match family {\n+            Family::AssociatedConst |\n+            Family::Method |\n+            Family::AssociatedType => {}\n \n-        // Need new unique IDs: old thread-local IDs won't map to new threads.\n-        for attr in attrs.iter_mut() {\n-            attr.node.id = attr::mk_attr_id();\n+            _ => return None\n         }\n \n-        attrs\n-    })\n-}\n+        let def_id = self.local_def_id(id);\n \n-#[derive(Clone)]\n-pub struct CrateDep {\n-    pub cnum: CrateNum,\n-    pub name: String,\n-    pub hash: Svh,\n-    pub explicitly_linked: bool,\n-}\n+        let container_id = self.item_parent_item(item_doc).unwrap();\n+        let container = match self.item_family(self.entry(container_id.index)) {\n+            Family::Trait => TraitContainer(container_id),\n+            _ => ImplContainer(container_id),\n+        };\n \n-pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n-    let dcx = rbml::Doc::new(data).get(root_tag::crate_deps).decoder();\n+        let name = self.item_name(item_doc);\n+        let vis = self.item_visibility(item_doc);\n \n-    dcx.seq().enumerate().map(|(crate_num, (name, hash, explicitly_linked))| {\n-        CrateDep {\n-            cnum: CrateNum::new(crate_num + 1),\n-            name: name,\n-            hash: hash,\n-            explicitly_linked: explicitly_linked,\n-        }\n-    }).collect()\n-}\n+        let (defaultness, has_body) = match self.entry_data(item_doc) {\n+            EntryData::TraitAssociated(data) => {\n+                (hir::Defaultness::Default, data.has_default)\n+            }\n+            EntryData::ImplAssociated(data) => {\n+                (data.defaultness, true)\n+            }\n+            _ => bug!()\n+        };\n \n-fn list_crate_deps(data: &[u8], out: &mut io::Write) -> io::Result<()> {\n-    write!(out, \"=External Dependencies=\\n\")?;\n-    for dep in &get_crate_deps(data) {\n-        write!(out, \"{} {}-{}\\n\", dep.cnum, dep.name, dep.hash)?;\n+        Some(match family {\n+            Family::AssociatedConst => {\n+                ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n+                    name: name,\n+                    ty: self.doc_type(item_doc, tcx),\n+                    vis: vis,\n+                    defaultness: defaultness,\n+                    def_id: def_id,\n+                    container: container,\n+                    has_value: has_body,\n+                }))\n+            }\n+            Family::Method => {\n+                let generics = self.doc_generics(item_doc, tcx);\n+                let predicates = self.doc_predicates(item_doc, tcx, item_tag::predicates);\n+                let ity = tcx.lookup_item_type(def_id).ty;\n+                let fty = match ity.sty {\n+                    ty::TyFnDef(.., fty) => fty,\n+                    _ => bug!(\n+                        \"the type {:?} of the method {:?} is not a function?\",\n+                        ity, name)\n+                };\n+\n+                let explicit_self = match self.entry_typed_data(item_doc, tcx) {\n+                    EntryTypedData::Method(data) => data.explicit_self,\n+                    _ => bug!()\n+                };\n+                ty::MethodTraitItem(Rc::new(ty::Method {\n+                    name: name,\n+                    generics: generics,\n+                    predicates: predicates,\n+                    fty: fty,\n+                    explicit_self: explicit_self,\n+                    vis: vis,\n+                    defaultness: defaultness,\n+                    has_body: has_body,\n+                    def_id: def_id,\n+                    container: container,\n+                }))\n+            }\n+            Family::AssociatedType => {\n+                ty::TypeTraitItem(Rc::new(ty::AssociatedType {\n+                    name: name,\n+                    ty: self.maybe_doc_type(item_doc, tcx),\n+                    vis: vis,\n+                    defaultness: defaultness,\n+                    def_id: def_id,\n+                    container: container,\n+                }))\n+            }\n+            _ => bug!()\n+        })\n     }\n-    write!(out, \"\\n\")?;\n-    Ok(())\n-}\n \n-pub fn get_crate_info(data: &[u8]) -> CrateInfo {\n-    rbml::Doc::new(data).get(root_tag::crate_info).decoder().decode()\n-}\n+    pub fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n+        let item_doc = self.entry(id);\n+        self.get(item_doc, item_tag::variances).decode()\n+    }\n \n-pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Write) -> io::Result<()> {\n-    list_crate_deps(bytes, out)\n-}\n+    pub fn get_struct_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n+        let data = match self.entry_data(self.entry(node_id)) {\n+            EntryData::Variant(data) => data,\n+            _ => bug!()\n+        };\n \n-// Translate a DefId from the current compilation environment to a DefId\n-// for an external crate.\n-fn reverse_translate_def_id(cdata: Cmd, did: DefId) -> Option<DefId> {\n-    for (local, &global) in cdata.cnum_map.borrow().iter_enumerated() {\n-        if global == did.krate {\n-            return Some(DefId { krate: local, index: did.index });\n+        data.struct_ctor.map(|index| self.local_def_id(index))\n+    }\n+\n+    pub fn get_item_attrs(&self, node_id: DefIndex) -> Vec<ast::Attribute> {\n+        // The attributes for a tuple struct are attached to the definition, not the ctor;\n+        // we assume that someone passing in a tuple struct ctor is actually wanting to\n+        // look at the definition\n+        let mut item = self.entry(node_id);\n+        let def_key = self.item_def_key(item);\n+        if def_key.disambiguated_data.data == DefPathData::StructCtor {\n+            item = self.entry(def_key.parent.unwrap());\n         }\n+        self.get_attributes(item)\n     }\n \n-    None\n-}\n+    pub fn get_struct_field_names(&self, id: DefIndex) -> Vec<ast::Name> {\n+        self.get(self.entry(id), item_tag::children).seq().map(|index| {\n+            self.item_name(self.entry(index))\n+        }).collect()\n+    }\n+\n+    fn get_attributes(&self, md: rbml::Doc) -> Vec<ast::Attribute> {\n+        self.maybe_get(md, item_tag::attributes).map_or(vec![], |mut dcx| {\n+            let mut attrs = dcx.decode::<Vec<ast::Attribute>>();\n \n-pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n-                                                id: DefIndex,\n-                                                mut callback: F)\n-    where F: FnMut(DefId),\n-{\n-    let item_doc = cdata.lookup_item(id);\n-    let mut dcx = item_doc.get(item_tag::inherent_impls).decoder();\n-    dcx.cdata = Some(cdata);\n+            // Need new unique IDs: old thread-local IDs won't map to new threads.\n+            for attr in attrs.iter_mut() {\n+                attr.node.id = attr::mk_attr_id();\n+            }\n \n-    for impl_def_id in dcx.seq() {\n-        callback(impl_def_id);\n+            attrs\n+        })\n     }\n-}\n \n-pub fn each_implementation_for_trait<F>(cdata: Cmd,\n-                                        filter: Option<DefId>,\n-                                        mut callback: F) where\n-    F: FnMut(DefId),\n-{\n-    // Do a reverse lookup beforehand to avoid touching the crate_num\n-    // hash map in the loop below.\n-    let filter = match filter.map(|def_id| reverse_translate_def_id(cdata, def_id)) {\n-        Some(Some(def_id)) => Some(def_id),\n-        Some(None) => return,\n-        None => None\n-    };\n-\n-    // FIXME(eddyb) Make this O(1) instead of O(n).\n-    for trait_doc in rbml::Doc::new(cdata.data()).get(root_tag::impls).children() {\n-        let mut dcx = trait_doc.decoder();\n-        dcx.cdata = Some(cdata);\n-\n-        let (krate, index) = dcx.decode();\n-        if let Some(local_did) = filter {\n-            if (local_did.krate.as_u32(), local_did.index) != (krate, index) {\n-                continue;\n+    // Translate a DefId from the current compilation environment to a DefId\n+    // for an external crate.\n+    fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {\n+        for (local, &global) in self.cnum_map.borrow().iter_enumerated() {\n+            if global == did.krate {\n+                return Some(DefId { krate: local, index: did.index });\n             }\n         }\n \n-        for impl_def_id in dcx.seq() {\n+        None\n+    }\n+\n+    pub fn each_inherent_implementation_for_type<F>(&self, id: DefIndex, mut callback: F)\n+        where F: FnMut(DefId),\n+    {\n+        for impl_def_id in self.get(self.entry(id), item_tag::inherent_impls).seq() {\n             callback(impl_def_id);\n         }\n     }\n-}\n \n-pub fn get_trait_of_item(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n-    let item_doc = cdata.lookup_item(id);\n-    let parent_item_id = match item_parent_item(cdata, item_doc) {\n-        None => return None,\n-        Some(item_id) => item_id,\n-    };\n-    match item_family(cdata.lookup_item(parent_item_id.index)) {\n-        Family::Trait => Some(parent_item_id),\n-        _ => None\n-    }\n-}\n+    pub fn each_implementation_for_trait<F>(&self,\n+                                            filter: Option<DefId>,\n+                                            mut callback: F) where\n+        F: FnMut(DefId),\n+    {\n+        // Do a reverse lookup beforehand to avoid touching the crate_num\n+        // hash map in the loop below.\n+        let filter = match filter.map(|def_id| self.reverse_translate_def_id(def_id)) {\n+            Some(Some(def_id)) => Some(def_id),\n+            Some(None) => return,\n+            None => None\n+        };\n \n+        // FIXME(eddyb) Make this O(1) instead of O(n).\n+        for trait_doc in self.data.root().children_of(root_tag::impls) {\n+            let mut dcx = DecodeContext::new(trait_doc, Some(self));\n \n-pub fn get_native_libraries(cdata: Cmd)\n-                            -> Vec<(cstore::NativeLibraryKind, String)> {\n-    rbml::Doc::new(cdata.data()).get(root_tag::native_libraries).decoder().decode()\n-}\n+            let (krate, index) = dcx.decode();\n+            if let Some(local_did) = filter {\n+                if (local_did.krate.as_u32(), local_did.index) != (krate, index) {\n+                    continue;\n+                }\n+            }\n \n-pub fn each_exported_macro<F>(data: &[u8], mut f: F) where\n-    F: FnMut(ast::Name, Vec<ast::Attribute>, Span, String) -> bool,\n-{\n-    let dcx = rbml::Doc::new(data).get(root_tag::macro_defs).decoder();\n-    for (name, attrs, span, body) in dcx.seq() {\n-        if !f(name, attrs, span, body) {\n-            break;\n+            for impl_def_id in dcx.seq() {\n+                callback(impl_def_id);\n+            }\n         }\n     }\n-}\n \n-pub fn get_dylib_dependency_formats(cdata: Cmd)\n-    -> Vec<(CrateNum, LinkagePreference)>\n-{\n-    let dcx = rbml::Doc::new(cdata.data()).get(root_tag::dylib_dependency_formats).decoder();\n-\n-    dcx.seq::<Option<_>>().enumerate().flat_map(|(i, link)| {\n-        let cnum = CrateNum::new(i + 1);\n-        link.map(|link| (cdata.cnum_map.borrow()[cnum], link))\n-    }).collect()\n-}\n+    pub fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n+        let item_doc = self.entry(id);\n+        let parent_item_id = match self.item_parent_item(item_doc) {\n+            None => return None,\n+            Some(item_id) => item_id,\n+        };\n+        match self.item_family(self.entry(parent_item_id.index)) {\n+            Family::Trait => Some(parent_item_id),\n+            _ => None\n+        }\n+    }\n \n-pub fn get_missing_lang_items(cdata: Cmd) -> Vec<lang_items::LangItem> {\n-    rbml::Doc::new(cdata.data()).get(root_tag::lang_items_missing).decoder().decode()\n-}\n \n-pub fn get_fn_arg_names(cdata: Cmd, id: DefIndex) -> Vec<String> {\n-    let method_doc = cdata.lookup_item(id);\n-    match reader::maybe_get_doc(method_doc, item_tag::fn_arg_names) {\n-        Some(args_doc) => args_doc.decoder().decode(),\n-        None => vec![],\n+    pub fn get_native_libraries(&self) -> Vec<(NativeLibraryKind, String)> {\n+        self.get(self.data.root(), root_tag::native_libraries).decode()\n     }\n-}\n \n-pub fn get_reachable_ids(cdata: Cmd) -> Vec<DefId> {\n-    let dcx = rbml::Doc::new(cdata.data()).get(root_tag::reachable_ids).decoder();\n+    pub fn get_dylib_dependency_formats(&self) -> Vec<(CrateNum, LinkagePreference)> {\n+        let dcx = self.get(self.data.root(), root_tag::dylib_dependency_formats);\n \n-    dcx.seq().map(|index| cdata.local_def_id(index)).collect()\n-}\n+        dcx.seq::<Option<_>>().enumerate().flat_map(|(i, link)| {\n+            let cnum = CrateNum::new(i + 1);\n+            link.map(|link| (self.cnum_map.borrow()[cnum], link))\n+        }).collect()\n+    }\n \n-pub fn is_const_fn(cdata: Cmd, id: DefIndex) -> bool {\n-    let constness = match entry_data(cdata.lookup_item(id), cdata) {\n-        EntryData::ImplAssociated(data) => data.constness,\n-        EntryData::Fn(data) => data.constness,\n-        _ => hir::Constness::NotConst\n-    };\n-    constness == hir::Constness::Const\n-}\n+    pub fn get_missing_lang_items(&self) -> Vec<lang_items::LangItem> {\n+        self.get(self.data.root(), root_tag::lang_items_missing).decode()\n+    }\n \n-pub fn is_extern_item<'a, 'tcx>(cdata: Cmd,\n-                                id: DefIndex,\n-                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                -> bool {\n-    let item_doc = match cdata.get_item(id) {\n-        Some(doc) => doc,\n-        None => return false,\n-    };\n-    let applicable = match item_family(item_doc) {\n-        Family::ImmStatic |\n-        Family::MutStatic |\n-        Family::ForeignImmStatic |\n-        Family::ForeignMutStatic => true,\n-\n-        Family::Fn | Family::ForeignFn => {\n-            get_generics(cdata, id, tcx).types.is_empty()\n-        }\n+    pub fn get_fn_arg_names(&self, id: DefIndex) -> Vec<String> {\n+        self.maybe_get(self.entry(id), item_tag::fn_arg_names)\n+            .map_or(vec![], |mut dcx| dcx.decode())\n+    }\n \n-        _ => false,\n-    };\n+    pub fn get_reachable_ids(&self) -> Vec<DefId> {\n+        let dcx = self.get(self.data.root(), root_tag::reachable_ids);\n \n-    if applicable {\n-        attr::contains_extern_indicator(tcx.sess.diagnostic(),\n-                                        &get_attributes(item_doc))\n-    } else {\n-        false\n+        dcx.seq().map(|index| self.local_def_id(index)).collect()\n     }\n-}\n \n-pub fn is_foreign_item(cdata: Cmd, id: DefIndex) -> bool {\n-    match item_family(cdata.lookup_item(id)) {\n-        Family::ForeignImmStatic |\n-        Family::ForeignMutStatic |\n-        Family::ForeignFn => true,\n-        _ => false\n+    pub fn is_const_fn(&self, id: DefIndex) -> bool {\n+        let constness = match self.entry_data(self.entry(id)) {\n+            EntryData::ImplAssociated(data) => data.constness,\n+            EntryData::Fn(data) => data.constness,\n+            _ => hir::Constness::NotConst\n+        };\n+        constness == hir::Constness::Const\n     }\n-}\n-\n-fn doc_generics<'a, 'tcx>(base_doc: rbml::Doc,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          cdata: Cmd)\n-                          -> &'tcx ty::Generics<'tcx>\n-{\n-    let mut dcx = base_doc.get(item_tag::generics).decoder();\n-    dcx.tcx = Some(tcx);\n-    dcx.cdata = Some(cdata);\n-    tcx.alloc_generics(dcx.decode())\n-}\n \n-fn doc_predicates<'a, 'tcx>(base_doc: rbml::Doc,\n-                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            cdata: Cmd,\n-                            tag: usize)\n-                            -> ty::GenericPredicates<'tcx>\n-{\n-    let mut dcx = base_doc.get(tag).decoder();\n-    dcx.cdata = Some(cdata);\n-    dcx.tcx = Some(tcx);\n-\n-    ty::GenericPredicates {\n-        parent: dcx.decode(),\n-        predicates: (0..dcx.decode::<usize>()).map(|_| {\n-            // Handle shorthands first, if we have an usize > 0x80.\n-            if dcx.opaque.data[dcx.opaque.position()] & 0x80 != 0 {\n-                let pos = dcx.decode::<usize>();\n-                assert!(pos >= SHORTHAND_OFFSET);\n-                let pos = pos - SHORTHAND_OFFSET;\n-\n-                let mut dcx = rbml::Doc {\n-                    data: cdata.data(),\n-                    start: pos,\n-                    end: cdata.data().len(),\n-                }.decoder();\n-                dcx.tcx = Some(tcx);\n-                dcx.cdata = Some(cdata);\n-                dcx.decode()\n-            } else {\n-                dcx.decode()\n+    pub fn is_extern_item(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+        let item_doc = match self.maybe_entry(id) {\n+            Some(doc) => doc,\n+            None => return false,\n+        };\n+        let applicable = match self.item_family(item_doc) {\n+            Family::ImmStatic |\n+            Family::MutStatic |\n+            Family::ForeignImmStatic |\n+            Family::ForeignMutStatic => true,\n+\n+            Family::Fn | Family::ForeignFn => {\n+                self.get_generics(id, tcx).types.is_empty()\n             }\n-        }).collect()\n+\n+            _ => false,\n+        };\n+\n+        if applicable {\n+            attr::contains_extern_indicator(tcx.sess.diagnostic(),\n+                                            &self.get_attributes(item_doc))\n+        } else {\n+            false\n+        }\n     }\n-}\n \n-pub fn is_defaulted_trait(cdata: Cmd, trait_id: DefIndex) -> bool {\n-    match entry_data(cdata.lookup_item(trait_id), cdata) {\n-        EntryData::Trait(data) => data.has_default_impl,\n-        _ => bug!()\n+    pub fn is_foreign_item(&self, id: DefIndex) -> bool {\n+        match self.item_family(self.entry(id)) {\n+            Family::ForeignImmStatic |\n+            Family::ForeignMutStatic |\n+            Family::ForeignFn => true,\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn is_default_impl(cdata: Cmd, impl_id: DefIndex) -> bool {\n-    item_family(cdata.lookup_item(impl_id)) == Family::DefaultImpl\n-}\n+    fn doc_generics(&self, base_doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                    -> &'tcx ty::Generics<'tcx> {\n+        let generics = self.get(base_doc, item_tag::generics).typed(tcx).decode();\n+        tcx.alloc_generics(generics)\n+    }\n \n-pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<syntax_pos::FileMap> {\n-    rbml::Doc::new(metadata).get(root_tag::codemap).decoder().decode()\n-}\n+    fn doc_predicates(&self, base_doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, tag: usize)\n+                      -> ty::GenericPredicates<'tcx> {\n+        let mut dcx = self.get(base_doc, tag).typed(tcx);\n+\n+        ty::GenericPredicates {\n+            parent: dcx.decode(),\n+            predicates: (0..dcx.decode::<usize>()).map(|_| {\n+                // Handle shorthands first, if we have an usize > 0x80.\n+                if dcx.opaque.data[dcx.opaque.position()] & 0x80 != 0 {\n+                    let pos = dcx.decode::<usize>();\n+                    assert!(pos >= SHORTHAND_OFFSET);\n+                    let pos = pos - SHORTHAND_OFFSET;\n+\n+                    let data = self.data.as_slice();\n+                    let doc = rbml::Doc {\n+                        data: data,\n+                        start: pos,\n+                        end: data.len(),\n+                    };\n+                    DecodeContext::new(doc, Some(self)).typed(tcx).decode()\n+                } else {\n+                    dcx.decode()\n+                }\n+            }).collect()\n+        }\n+    }\n \n-pub fn closure_kind(cdata: Cmd, closure_id: DefIndex) -> ty::ClosureKind {\n-    match entry_data(cdata.lookup_item(closure_id), cdata) {\n-        EntryData::Closure(data) => data.kind,\n-        _ => bug!()\n+    pub fn is_defaulted_trait(&self, trait_id: DefIndex) -> bool {\n+        match self.entry_data(self.entry(trait_id)) {\n+            EntryData::Trait(data) => data.has_default_impl,\n+            _ => bug!()\n+        }\n     }\n-}\n \n-pub fn closure_ty<'a, 'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                            -> ty::ClosureTy<'tcx> {\n-    match entry_typed_data(cdata.lookup_item(closure_id), tcx, cdata) {\n-        EntryTypedData::Closure(data) => data.ty,\n-        _ => bug!()\n+    pub fn is_default_impl(&self, impl_id: DefIndex) -> bool {\n+        self.item_family(self.entry(impl_id)) == Family::DefaultImpl\n     }\n-}\n \n-pub fn def_key(cdata: Cmd, id: DefIndex) -> hir_map::DefKey {\n-    debug!(\"def_key: id={:?}\", id);\n-    item_def_key(cdata.lookup_item(id))\n-}\n+    pub fn closure_kind(&self, closure_id: DefIndex) -> ty::ClosureKind {\n+        match self.entry_data(self.entry(closure_id)) {\n+            EntryData::Closure(data) => data.kind,\n+            _ => bug!()\n+        }\n+    }\n \n-fn item_def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n-    item_doc.get(item_tag::def_key).decoder().decode()\n-}\n+    pub fn closure_ty(&self, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                      -> ty::ClosureTy<'tcx> {\n+        match self.entry_typed_data(self.entry(closure_id), tcx) {\n+            EntryTypedData::Closure(data) => data.ty,\n+            _ => bug!()\n+        }\n+    }\n \n-// Returns the path leading to the thing with this `id`. Note that\n-// some def-ids don't wind up in the metadata, so `def_path` sometimes\n-// returns `None`\n-pub fn def_path(cdata: Cmd, id: DefIndex) -> Option<hir_map::DefPath> {\n-    debug!(\"def_path(id={:?})\", id);\n-    if cdata.get_item(id).is_some() {\n-        Some(hir_map::DefPath::make(cdata.cnum, id, |parent| def_key(cdata, parent)))\n-    } else {\n-        None\n+    pub fn def_key(&self, id: DefIndex) -> hir_map::DefKey {\n+        debug!(\"def_key: id={:?}\", id);\n+        self.item_def_key(self.entry(id))\n+    }\n+\n+    // Returns the path leading to the thing with this `id`. Note that\n+    // some def-ids don't wind up in the metadata, so `def_path` sometimes\n+    // returns `None`\n+    pub fn def_path(&self, id: DefIndex) -> Option<hir_map::DefPath> {\n+        debug!(\"def_path(id={:?})\", id);\n+        if self.maybe_entry(id).is_some() {\n+            Some(hir_map::DefPath::make(self.cnum, id, |parent| self.def_key(parent)))\n+        } else {\n+            None\n+        }\n     }\n }"}, {"sha": "e345129b327e99e0258553046c8dc6d70413d584", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 219, "deletions": 224, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=adddfccf2b63f7969d80d459788e973b56168ec4", "patch": "@@ -11,7 +11,6 @@\n // Metadata encoding\n \n #![allow(unused_must_use)] // everything is just a MemWriter, can't fail\n-#![allow(non_camel_case_types)]\n \n use astencode::encode_inlined_item;\n use common::*;\n@@ -226,9 +225,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             struct_ctor: struct_ctor\n         })\n     }\n-}\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     /// Encode data for the given variant of the given ADT. The\n     /// index of the variant is untracked: this is ok because we\n     /// will have to lookup the adt-def by its id, and that gives us\n@@ -249,8 +246,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.encode_visibility(enum_vis);\n \n         let attrs = tcx.get_attrs(vid);\n-        encode_attributes(self, &attrs);\n-        encode_stability(self, vid);\n+        self.encode_attributes(&attrs);\n+        self.encode_stability(vid);\n \n         let data = self.encode_variant(variant, None);\n \n@@ -264,9 +261,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         self.encode_bounds_and_type_for_item(vid);\n     }\n-}\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_mod(&mut self,\n                            FromId(id, (md, attrs, vis)):\n                            FromId<(&hir::Mod, &[ast::Attribute], &hir::Visibility)>) {\n@@ -276,8 +271,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.encode_def_key(def_id);\n         self.encode_family(Family::Mod);\n         self.encode_visibility(vis);\n-        encode_stability(self, def_id);\n-        encode_attributes(self, attrs);\n+        self.encode_stability(def_id);\n+        self.encode_attributes(attrs);\n         debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n         // Encode info about all the module children.\n@@ -371,16 +366,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let variant_id = tcx.map.as_local_node_id(variant.did).unwrap();\n         let variant_data = tcx.map.expect_variant_data(variant_id);\n-        encode_attributes(self, &variant_data.fields()[field_index].attrs);\n-        encode_stability(self, field.did);\n+        self.encode_attributes(&variant_data.fields()[field_index].attrs);\n+        self.encode_stability(field.did);\n     }\n \n     fn encode_struct_ctor(&mut self, ctor_def_id: DefId) {\n         self.encode_def_key(ctor_def_id);\n         self.encode_family(Family::Struct);\n         self.encode_bounds_and_type_for_item(ctor_def_id);\n \n-        encode_stability(self, ctor_def_id);\n+        self.encode_stability(ctor_def_id);\n     }\n \n     fn encode_generics(&mut self,\n@@ -445,8 +440,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.encode_family(family);\n         self.encode_visibility(trait_item.vis());\n \n-        encode_stability(self, def_id);\n-        encode_attributes(self, &ast_item.attrs);\n+        self.encode_stability(def_id);\n+        self.encode_attributes(&ast_item.attrs);\n         if let hir::MethodTraitItem(ref sig, _) = ast_item.node {\n             self.encode_fn_arg_names(&sig.decl);\n         };\n@@ -499,8 +494,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.encode_def_key(def_id);\n         self.encode_family(family);\n         self.encode_visibility(impl_item.vis());\n-        encode_attributes(self, &ast_item.attrs);\n-        encode_stability(self, def_id);\n+        self.encode_attributes(&ast_item.attrs);\n+        self.encode_stability(def_id);\n \n         let constness = if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n             if sig.constness == hir::Constness::Const {\n@@ -555,33 +550,30 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             self.end_tag();\n         }\n     }\n-}\n \n-// Encodes the inherent implementations of a structure, enumeration, or trait.\n-fn encode_inherent_implementations(ecx: &mut EncodeContext,\n-                                   def_id: DefId) {\n-    ecx.start_tag(item_tag::inherent_impls);\n-    match ecx.tcx.inherent_impls.borrow().get(&def_id) {\n-        None => <[DefId]>::encode(&[], ecx).unwrap(),\n-        Some(implementations) => implementations.encode(ecx).unwrap()\n+    // Encodes the inherent implementations of a structure, enumeration, or trait.\n+    fn encode_inherent_implementations(&mut self, def_id: DefId) {\n+        self.start_tag(item_tag::inherent_impls);\n+        match self.tcx.inherent_impls.borrow().get(&def_id) {\n+            None => <[DefId]>::encode(&[], self).unwrap(),\n+            Some(implementations) => implementations.encode(self).unwrap()\n+        }\n+        self.end_tag();\n     }\n-    ecx.end_tag();\n-}\n \n-fn encode_stability(ecx: &mut EncodeContext, def_id: DefId) {\n-    ecx.tcx.lookup_stability(def_id).map(|stab| {\n-        ecx.start_tag(item_tag::stability);\n-        stab.encode(ecx).unwrap();\n-        ecx.end_tag();\n-    });\n-    ecx.tcx.lookup_deprecation(def_id).map(|depr| {\n-        ecx.start_tag(item_tag::deprecation);\n-        depr.encode(ecx).unwrap();\n-        ecx.end_tag();\n-    });\n-}\n+    fn encode_stability(&mut self, def_id: DefId) {\n+        self.tcx.lookup_stability(def_id).map(|stab| {\n+            self.start_tag(item_tag::stability);\n+            stab.encode(self).unwrap();\n+            self.end_tag();\n+        });\n+        self.tcx.lookup_deprecation(def_id).map(|depr| {\n+            self.start_tag(item_tag::deprecation);\n+            depr.encode(self).unwrap();\n+            self.end_tag();\n+        });\n+    }\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_item(&mut self,\n                             (def_id, item): (DefId, &hir::Item)) {\n         let tcx = self.tcx;\n@@ -652,7 +644,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 self.end_tag();\n \n                 // Encode inherent implementations for self enumeration.\n-                encode_inherent_implementations(self, def_id);\n+                self.encode_inherent_implementations(def_id);\n \n                 (Family::Enum, EntryData::Other, EntryTypedData::Other)\n             }\n@@ -675,7 +667,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let data = self.encode_variant(variant, struct_ctor);\n \n                 // Encode inherent implementations for self structure.\n-                encode_inherent_implementations(self, def_id);\n+                self.encode_inherent_implementations(def_id);\n \n                 (Family::Struct, data, EntryTypedData::Other)\n             }\n@@ -691,7 +683,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let data = self.encode_variant(def.struct_variant(), None);\n \n                 // Encode inherent implementations for self union.\n-                encode_inherent_implementations(self, def_id);\n+                self.encode_inherent_implementations(def_id);\n \n                 (Family::Union, data, EntryTypedData::Other)\n             }\n@@ -752,7 +744,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 self.end_tag();\n \n                 // Encode inherent implementations for self trait.\n-                encode_inherent_implementations(self, def_id);\n+                self.encode_inherent_implementations(def_id);\n \n                 (Family::Trait,\n                  EntryData::Trait(TraitData {\n@@ -772,8 +764,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.encode_family(family);\n         self.encode_def_key(def_id);\n         self.encode_visibility(&item.vis);\n-        encode_attributes(self, &item.attrs);\n-        encode_stability(self, def_id);\n+        self.encode_attributes(&item.attrs);\n+        self.encode_stability(def_id);\n \n         self.start_tag(item_tag::data);\n         data.encode(self).unwrap();\n@@ -883,8 +875,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         EntryTypedData::Other.encode(self).unwrap();\n         self.end_tag();\n \n-        encode_attributes(self, &nitem.attrs);\n-        encode_stability(self, def_id);\n+        self.encode_attributes(&nitem.attrs);\n+        self.encode_stability(def_id);\n     }\n }\n \n@@ -970,152 +962,153 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         assert!(self.mir_map.map.contains_key(&def_id));\n         self.encode_mir(def_id);\n     }\n-}\n \n-fn encode_info_for_items(ecx: &mut EncodeContext) -> IndexData {\n-    let krate = ecx.tcx.map.krate();\n-\n-    // FIXME(eddyb) Avoid wrapping the items in a doc.\n-    ecx.start_tag(0).unwrap();\n-\n-    let items = {\n-        let mut index = IndexBuilder::new(ecx);\n-        index.record(DefId::local(CRATE_DEF_INDEX),\n-                     EncodeContext::encode_info_for_mod,\n-                     FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n-        let mut visitor = EncodeVisitor {\n-            index: index,\n+    fn encode_info_for_items(&mut self) -> IndexData {\n+        let krate = self.tcx.map.krate();\n+\n+        // FIXME(eddyb) Avoid wrapping the items in a doc.\n+        self.start_tag(0).unwrap();\n+\n+        let items = {\n+            let mut index = IndexBuilder::new(self);\n+            index.record(DefId::local(CRATE_DEF_INDEX),\n+                        EncodeContext::encode_info_for_mod,\n+                        FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n+            let mut visitor = EncodeVisitor {\n+                index: index,\n+            };\n+            krate.visit_all_items(&mut visitor);\n+            visitor.index.into_items()\n         };\n-        krate.visit_all_items(&mut visitor);\n-        visitor.index.into_items()\n-    };\n \n-    ecx.end_tag();\n+        self.end_tag();\n \n-    items\n-}\n+        items\n+    }\n \n-fn encode_item_index(ecx: &mut EncodeContext, index: IndexData) {\n-    ecx.start_tag(root_tag::index);\n-    index.write_index(&mut ecx.opaque.cursor);\n-    ecx.end_tag();\n-}\n+    fn encode_item_index(&mut self, index: IndexData) {\n+        self.start_tag(root_tag::index);\n+        index.write_index(&mut self.opaque.cursor);\n+        self.end_tag();\n+    }\n \n-fn encode_attributes(ecx: &mut EncodeContext, attrs: &[ast::Attribute]) {\n-    ecx.start_tag(item_tag::attributes);\n-    attrs.encode(ecx).unwrap();\n-    ecx.end_tag();\n-}\n+    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) {\n+        self.start_tag(item_tag::attributes);\n+        attrs.encode(self).unwrap();\n+        self.end_tag();\n+    }\n \n-fn encode_crate_deps(ecx: &mut EncodeContext, cstore: &cstore::CStore) {\n-    fn get_ordered_deps(cstore: &cstore::CStore)\n-                        -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n-        // Pull the cnums and name,vers,hash out of cstore\n-        let mut deps = Vec::new();\n-        cstore.iter_crate_data(|cnum, val| {\n-            deps.push((cnum, val.clone()));\n-        });\n+    fn encode_crate_deps(&mut self) {\n+        fn get_ordered_deps(cstore: &cstore::CStore)\n+                            -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n+            // Pull the cnums and name,vers,hash out of cstore\n+            let mut deps = Vec::new();\n+            cstore.iter_crate_data(|cnum, val| {\n+                deps.push((cnum, val.clone()));\n+            });\n \n-        // Sort by cnum\n-        deps.sort_by(|kv1, kv2| kv1.0.cmp(&kv2.0));\n+            // Sort by cnum\n+            deps.sort_by(|kv1, kv2| kv1.0.cmp(&kv2.0));\n \n-        // Sanity-check the crate numbers\n-        let mut expected_cnum = 1;\n-        for &(n, _) in &deps {\n-            assert_eq!(n, CrateNum::new(expected_cnum));\n-            expected_cnum += 1;\n+            // Sanity-check the crate numbers\n+            let mut expected_cnum = 1;\n+            for &(n, _) in &deps {\n+                assert_eq!(n, CrateNum::new(expected_cnum));\n+                expected_cnum += 1;\n+            }\n+\n+            deps\n         }\n \n-        deps\n+        // We're just going to write a list of crate 'name-hash-version's, with\n+        // the assumption that they are numbered 1 to n.\n+        // FIXME (#2166): This is not nearly enough to support correct versioning\n+        // but is enough to get transitive crate dependencies working.\n+        self.start_tag(root_tag::crate_deps);\n+        let deps = get_ordered_deps(self.cstore);\n+        self.seq(&deps, |_, &(_, ref dep)| {\n+            (dep.name(), dep.hash(), dep.explicitly_linked.get())\n+        });\n+        self.end_tag();\n     }\n \n-    // We're just going to write a list of crate 'name-hash-version's, with\n-    // the assumption that they are numbered 1 to n.\n-    // FIXME (#2166): This is not nearly enough to support correct versioning\n-    // but is enough to get transitive crate dependencies working.\n-    ecx.start_tag(root_tag::crate_deps);\n-    ecx.seq(&get_ordered_deps(cstore), |_, &(_, ref dep)| {\n-        (dep.name(), dep.hash(), dep.explicitly_linked.get())\n-    });\n-    ecx.end_tag();\n-}\n-\n-fn encode_lang_items(ecx: &mut EncodeContext) {\n-    let tcx = ecx.tcx;\n-    let lang_items = || {\n-        tcx.lang_items.items().iter().enumerate().filter_map(|(i, &opt_def_id)| {\n-            if let Some(def_id) = opt_def_id {\n-                if def_id.is_local() {\n-                    return Some((def_id.index, i));\n+    fn encode_lang_items(&mut self) {\n+        let tcx = self.tcx;\n+        let lang_items = || {\n+            tcx.lang_items.items().iter().enumerate().filter_map(|(i, &opt_def_id)| {\n+                if let Some(def_id) = opt_def_id {\n+                    if def_id.is_local() {\n+                        return Some((def_id.index, i));\n+                    }\n                 }\n-            }\n-            None\n-        })\n-    };\n+                None\n+            })\n+        };\n \n-    let count = lang_items().count();\n-    let mut lang_items = lang_items();\n+        let count = lang_items().count();\n+        let mut lang_items = lang_items();\n \n-    ecx.start_tag(root_tag::lang_items);\n-    ecx.seq(0..count, |_, _| lang_items.next().unwrap());\n-    ecx.end_tag();\n+        self.start_tag(root_tag::lang_items);\n+        self.seq(0..count, |_, _| lang_items.next().unwrap());\n+        self.end_tag();\n \n-    ecx.start_tag(root_tag::lang_items_missing);\n-    tcx.lang_items.missing.encode(ecx).unwrap();\n-    ecx.end_tag();\n-}\n+        self.start_tag(root_tag::lang_items_missing);\n+        tcx.lang_items.missing.encode(self).unwrap();\n+        self.end_tag();\n+    }\n \n-fn encode_native_libraries(ecx: &mut EncodeContext) {\n-    let used_libraries = ecx.tcx.sess.cstore.used_libraries();\n-    let libs = || {\n-        used_libraries.iter().filter_map(|&(ref lib, kind)| {\n-            match kind {\n-                cstore::NativeStatic => None, // these libraries are not propagated\n-                cstore::NativeFramework | cstore::NativeUnknown => {\n-                    Some((kind, lib))\n+    fn encode_native_libraries(&mut self) {\n+        let used_libraries = self.tcx.sess.cstore.used_libraries();\n+        let libs = || {\n+            used_libraries.iter().filter_map(|&(ref lib, kind)| {\n+                match kind {\n+                    cstore::NativeStatic => None, // these libraries are not propagated\n+                    cstore::NativeFramework | cstore::NativeUnknown => {\n+                        Some((kind, lib))\n+                    }\n                 }\n-            }\n-        })\n-    };\n+            })\n+        };\n \n-    let count = libs().count();\n-    let mut libs = libs();\n+        let count = libs().count();\n+        let mut libs = libs();\n \n-    ecx.start_tag(root_tag::native_libraries);\n-    ecx.seq(0..count, |_, _| libs.next().unwrap());\n-    ecx.end_tag();\n-}\n+        self.start_tag(root_tag::native_libraries);\n+        self.seq(0..count, |_, _| libs.next().unwrap());\n+        self.end_tag();\n+    }\n \n-fn encode_codemap(ecx: &mut EncodeContext) {\n-    let codemap = ecx.tcx.sess.codemap();\n-    let all_filemaps = codemap.files.borrow();\n-    let filemaps = || {\n-        // No need to export empty filemaps, as they can't contain spans\n-        // that need translation.\n-        // Also no need to re-export imported filemaps, as any downstream\n-        // crate will import them from their original source.\n-        all_filemaps.iter().filter(|filemap| {\n-            !filemap.lines.borrow().is_empty() && !filemap.is_imported()\n-        })\n-    };\n+    fn encode_codemap(&mut self) {\n+        let codemap = self.tcx.sess.codemap();\n+        let all_filemaps = codemap.files.borrow();\n+        let filemaps = || {\n+            // No need to export empty filemaps, as they can't contain spans\n+            // that need translation.\n+            // Also no need to re-export imported filemaps, as any downstream\n+            // crate will import them from their original source.\n+            all_filemaps.iter().filter(|filemap| {\n+                !filemap.lines.borrow().is_empty() && !filemap.is_imported()\n+            })\n+        };\n \n-    let count = filemaps().count();\n-    let mut filemaps = filemaps();\n+        let count = filemaps().count();\n+        let mut filemaps = filemaps();\n \n-    ecx.start_tag(root_tag::codemap);\n-    ecx.seq(0..count, |_, _| filemaps.next().unwrap());\n-    ecx.end_tag();\n-}\n+        self.start_tag(root_tag::codemap);\n+        self.seq(0..count, |_, _| filemaps.next().unwrap());\n+        self.end_tag();\n+    }\n \n-/// Serialize the text of the exported macros\n-fn encode_macro_defs(ecx: &mut EncodeContext) {\n-    let tcx = ecx.tcx;\n-    ecx.start_tag(root_tag::macro_defs);\n-    ecx.seq(&tcx.map.krate().exported_macros, |_, def| {\n-        let body = ::syntax::print::pprust::tts_to_string(&def.body);\n-        (def.name, &def.attrs, def.span, body)\n-    });\n-    ecx.end_tag();\n+    /// Serialize the text of the exported macros\n+    fn encode_macro_defs(&mut self) {\n+        let tcx = self.tcx;\n+        self.start_tag(root_tag::macro_defs);\n+        self.seq(&tcx.map.krate().exported_macros, |_, def| {\n+            let body = ::syntax::print::pprust::tts_to_string(&def.body);\n+            (def.name, &def.attrs, def.span, body)\n+        });\n+        self.end_tag();\n+    }\n }\n \n struct ImplVisitor<'a, 'tcx:'a> {\n@@ -1136,59 +1129,61 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n     }\n }\n \n-/// Encodes an index, mapping each trait to its (local) implementations.\n-fn encode_impls(ecx: &mut EncodeContext) {\n-    let mut visitor = ImplVisitor {\n-        tcx: ecx.tcx,\n-        impls: FnvHashMap()\n-    };\n-    ecx.tcx.map.krate().visit_all_items(&mut visitor);\n-\n-    ecx.start_tag(root_tag::impls);\n-    for (trait_def_id, trait_impls) in visitor.impls {\n-        // FIXME(eddyb) Avoid wrapping the entries in docs.\n-        ecx.start_tag(0);\n-        (trait_def_id.krate.as_u32(), trait_def_id.index).encode(ecx).unwrap();\n-        trait_impls.encode(ecx).unwrap();\n-        ecx.end_tag();\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+    /// Encodes an index, mapping each trait to its (local) implementations.\n+    fn encode_impls(&mut self) {\n+        let mut visitor = ImplVisitor {\n+            tcx: self.tcx,\n+            impls: FnvHashMap()\n+        };\n+        self.tcx.map.krate().visit_all_items(&mut visitor);\n+\n+        self.start_tag(root_tag::impls);\n+        for (trait_def_id, trait_impls) in visitor.impls {\n+            // FIXME(eddyb) Avoid wrapping the entries in docs.\n+            self.start_tag(0);\n+            (trait_def_id.krate.as_u32(), trait_def_id.index).encode(self).unwrap();\n+            trait_impls.encode(self).unwrap();\n+            self.end_tag();\n+        }\n+        self.end_tag();\n     }\n-    ecx.end_tag();\n-}\n \n-// Encodes all reachable symbols in this crate into the metadata.\n-//\n-// This pass is seeded off the reachability list calculated in the\n-// middle::reachable module but filters out items that either don't have a\n-// symbol associated with them (they weren't translated) or if they're an FFI\n-// definition (as that's not defined in this crate).\n-fn encode_reachable(ecx: &mut EncodeContext) {\n-    ecx.start_tag(root_tag::reachable_ids);\n+    // Encodes all reachable symbols in this crate into the metadata.\n+    //\n+    // This pass is seeded off the reachability list calculated in the\n+    // middle::reachable module but filters out items that either don't have a\n+    // symbol associated with them (they weren't translated) or if they're an FFI\n+    // definition (as that's not defined in this crate).\n+    fn encode_reachable(&mut self) {\n+        self.start_tag(root_tag::reachable_ids);\n \n-    let reachable = ecx.reachable;\n-    ecx.seq(reachable, |ecx, &id| ecx.tcx.map.local_def_id(id).index);\n+        let reachable = self.reachable;\n+        self.seq(reachable, |ecx, &id| ecx.tcx.map.local_def_id(id).index);\n \n-    ecx.end_tag();\n-}\n+        self.end_tag();\n+    }\n \n-fn encode_dylib_dependency_formats(ecx: &mut EncodeContext) {\n-    ecx.start_tag(root_tag::dylib_dependency_formats);\n-    match ecx.tcx.sess.dependency_formats.borrow().get(&config::CrateTypeDylib) {\n-        Some(arr) => {\n-            ecx.seq(arr, |_, slot| {\n-                match *slot {\n-                    Linkage::NotLinked |\n-                    Linkage::IncludedFromDylib => None,\n-\n-                    Linkage::Dynamic => Some(LinkagePreference::RequireDynamic),\n-                    Linkage::Static => Some(LinkagePreference::RequireStatic),\n-                }\n-            });\n-        }\n-        None => {\n-            <[Option<LinkagePreference>]>::encode(&[], ecx).unwrap();\n+    fn encode_dylib_dependency_formats(&mut self) {\n+        self.start_tag(root_tag::dylib_dependency_formats);\n+        match self.tcx.sess.dependency_formats.borrow().get(&config::CrateTypeDylib) {\n+            Some(arr) => {\n+                self.seq(arr, |_, slot| {\n+                    match *slot {\n+                        Linkage::NotLinked |\n+                        Linkage::IncludedFromDylib => None,\n+\n+                        Linkage::Dynamic => Some(LinkagePreference::RequireDynamic),\n+                        Linkage::Static => Some(LinkagePreference::RequireStatic),\n+                    }\n+                });\n+            }\n+            None => {\n+                <[Option<LinkagePreference>]>::encode(&[], self).unwrap();\n+            }\n         }\n+        self.end_tag();\n     }\n-    ecx.end_tag();\n }\n \n pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1281,47 +1276,47 @@ fn encode_metadata_inner(ecx: &mut EncodeContext) {\n     ecx.end_tag();\n \n     let mut i = ecx.position();\n-    encode_crate_deps(ecx, ecx.cstore);\n-    encode_dylib_dependency_formats(ecx);\n+    ecx.encode_crate_deps();\n+    ecx.encode_dylib_dependency_formats();\n     let dep_bytes = ecx.position() - i;\n \n     // Encode the language items.\n     i = ecx.position();\n-    encode_lang_items(ecx);\n+    ecx.encode_lang_items();\n     let lang_item_bytes = ecx.position() - i;\n \n     // Encode the native libraries used\n     i = ecx.position();\n-    encode_native_libraries(ecx);\n+    ecx.encode_native_libraries();\n     let native_lib_bytes = ecx.position() - i;\n \n     // Encode codemap\n     i = ecx.position();\n-    encode_codemap(ecx);\n+    ecx.encode_codemap();\n     let codemap_bytes = ecx.position() - i;\n \n     // Encode macro definitions\n     i = ecx.position();\n-    encode_macro_defs(ecx);\n+    ecx.encode_macro_defs();\n     let macro_defs_bytes = ecx.position() - i;\n \n     // Encode the def IDs of impls, for coherence checking.\n     i = ecx.position();\n-    encode_impls(ecx);\n+    ecx.encode_impls();\n     let impl_bytes = ecx.position() - i;\n \n     // Encode reachability info.\n     i = ecx.position();\n-    encode_reachable(ecx);\n+    ecx.encode_reachable();\n     let reachable_bytes = ecx.position() - i;\n \n     // Encode and index the items.\n     i = ecx.position();\n-    let items = encode_info_for_items(ecx);\n+    let items = ecx.encode_info_for_items();\n     let item_bytes = ecx.position() - i;\n \n     i = ecx.position();\n-    encode_item_index(ecx, items);\n+    ecx.encode_item_index(items);\n     let index_bytes = ecx.position() - i;\n \n     let total_bytes = ecx.position();"}, {"sha": "883004b8486f1fde30464759386e24653d2c3017", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=adddfccf2b63f7969d80d459788e973b56168ec4", "patch": "@@ -214,7 +214,6 @@\n \n use cstore::{MetadataBlob, MetadataVec, MetadataArchive};\n use common::{metadata_encoding_version, rustc_version};\n-use decoder;\n \n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n@@ -511,7 +510,7 @@ impl<'a> Context<'a> {\n                     if let Some((ref p, _)) = lib.rlib {\n                         err.note(&format!(\"path: {}\", p.display()));\n                     }\n-                    let crate_info = decoder::get_crate_info(lib.metadata.as_slice());\n+                    let crate_info = lib.metadata.get_crate_info();\n                     note_crate_name(&mut err, &crate_info.name);\n                 }\n                 err.emit();\n@@ -550,7 +549,7 @@ impl<'a> Context<'a> {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             let (hash, metadata) = match get_metadata_section(self.target, flavor, &lib) {\n                 Ok(blob) => {\n-                    if let Some(h) = self.crate_matches(blob.as_slice(), &lib) {\n+                    if let Some(h) = self.crate_matches(&blob, &lib) {\n                         (h, blob)\n                     } else {\n                         info!(\"metadata mismatch\");\n@@ -597,8 +596,8 @@ impl<'a> Context<'a> {\n         }\n     }\n \n-    fn crate_matches(&mut self, crate_data: &[u8], libpath: &Path) -> Option<Svh> {\n-        let crate_rustc_version = decoder::crate_rustc_version(crate_data);\n+    fn crate_matches(&mut self, metadata: &MetadataBlob, libpath: &Path) -> Option<Svh> {\n+        let crate_rustc_version = metadata.crate_rustc_version();\n         if crate_rustc_version != Some(rustc_version()) {\n             let message = crate_rustc_version.unwrap_or(format!(\"an unknown compiler\"));\n             info!(\"Rejecting via version: expected {} got {}\", rustc_version(), message);\n@@ -609,7 +608,7 @@ impl<'a> Context<'a> {\n             return None;\n         }\n \n-        let crate_info = decoder::get_crate_info(crate_data);\n+        let crate_info = metadata.get_crate_info();\n         if self.should_match_name {\n             if self.crate_name != crate_info.name {\n                 info!(\"Rejecting via crate name\"); return None;\n@@ -895,7 +894,7 @@ pub fn list_file_metadata(target: &Target, path: &Path,\n     let filename = path.file_name().unwrap().to_str().unwrap();\n     let flavor = if filename.ends_with(\".rlib\") { CrateFlavor::Rlib } else { CrateFlavor::Dylib };\n     match get_metadata_section(target, flavor, path) {\n-        Ok(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n+        Ok(metadata) => metadata.list_crate_metadata(out),\n         Err(msg) => {\n             write!(out, \"{}\\n\", msg)\n         }"}, {"sha": "c4cfc32d63306140ca3d918e7eef2f4f511fa101", "filename": "src/librustc_metadata/rbml/reader.rs", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frbml%2Freader.rs?ref=adddfccf2b63f7969d80d459788e973b56168ec4", "patch": "@@ -52,6 +52,15 @@ use test::Bencher;\n use std::fmt;\n use std::str;\n \n+macro_rules! try_or {\n+    ($e:expr, $r:expr) => (\n+        match $e {\n+            Ok(x) => x,\n+            Err(_) => return $r\n+        }\n+    )\n+}\n+\n #[derive(Clone, Copy)]\n pub struct Doc<'a> {\n     pub data: &'a [u8],\n@@ -79,17 +88,34 @@ impl<'doc> Doc<'doc> {\n         }\n     }\n \n-    pub fn get(&self, tag: usize) -> Doc<'doc> {\n-        match maybe_get_doc(*self, tag) {\n+    pub fn maybe_child(&self, tag: usize) -> Option<Doc<'doc>> {\n+        let mut pos = self.start;\n+        while pos < self.end {\n+            let elt_tag = try_or!(tag_at(self.data, pos), None);\n+            let elt_size = try_or!(tag_len_at(self.data, elt_tag.next), None);\n+            pos = elt_size.next + elt_size.val;\n+            if elt_tag.val == tag {\n+                return Some(Doc {\n+                    data: self.data,\n+                    start: elt_size.next,\n+                    end: pos,\n+                });\n+            }\n+        }\n+        None\n+    }\n+\n+    pub fn child(&self, tag: usize) -> Doc<'doc> {\n+        match self.maybe_child(tag) {\n             Some(d) => d,\n             None => {\n-                bug!(\"failed to find block with tag {:?}\", tag);\n+                bug!(\"failed to find child with tag {:?}\", tag);\n             }\n         }\n     }\n \n-    pub fn children(self) -> DocsIterator<'doc> {\n-        DocsIterator { d: self }\n+    pub fn children_of(&self, tag: usize) -> DocsIterator<'doc> {\n+        DocsIterator { d: self.child(tag) }\n     }\n }\n \n@@ -106,24 +132,10 @@ impl fmt::Display for Error {\n     }\n }\n \n-// rbml reading\n-\n-macro_rules! try_or {\n-    ($e:expr, $r:expr) => (\n-        match $e {\n-            Ok(e) => e,\n-            Err(e) => {\n-                debug!(\"ignored error: {:?}\", e);\n-                return $r\n-            }\n-        }\n-    )\n-}\n-\n #[derive(Copy, Clone)]\n-pub struct Res {\n-    pub val: usize,\n-    pub next: usize,\n+struct Res {\n+    val: usize,\n+    next: usize,\n }\n \n fn tag_at(data: &[u8], start: usize) -> Result<Res, Error> {\n@@ -235,23 +247,6 @@ fn tag_len_at(data: &[u8], next: usize) -> Result<Res, Error> {\n     vuint_at(data, next)\n }\n \n-pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: usize) -> Option<Doc<'a>> {\n-    let mut pos = d.start;\n-    while pos < d.end {\n-        let elt_tag = try_or!(tag_at(d.data, pos), None);\n-        let elt_size = try_or!(tag_len_at(d.data, elt_tag.next), None);\n-        pos = elt_size.next + elt_size.val;\n-        if elt_tag.val == tg {\n-            return Some(Doc {\n-                data: d.data,\n-                start: elt_size.next,\n-                end: pos,\n-            });\n-        }\n-    }\n-    None\n-}\n-\n pub struct DocsIterator<'a> {\n     d: Doc<'a>,\n }"}, {"sha": "0acf211a27c53897aa2e1c0985fec8e5210ee386", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adddfccf2b63f7969d80d459788e973b56168ec4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=adddfccf2b63f7969d80d459788e973b56168ec4", "patch": "@@ -237,8 +237,8 @@ pub struct ExternalCrate {\n impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext) -> ExternalCrate {\n         let mut primitives = Vec::new();\n+        let root = DefId { krate: self.0, index: CRATE_DEF_INDEX };\n         cx.tcx_opt().map(|tcx| {\n-            let root = DefId { krate: self.0, index: CRATE_DEF_INDEX };\n             for item in tcx.sess.cstore.item_children(root) {\n                 let did = match item.def {\n                     Def::Mod(did) => did,\n@@ -250,7 +250,7 @@ impl Clean<ExternalCrate> for CrateNum {\n         });\n         ExternalCrate {\n             name: (&cx.sess().cstore.crate_name(self.0)[..]).to_owned(),\n-            attrs: cx.sess().cstore.crate_attrs(self.0).clean(cx),\n+            attrs: cx.sess().cstore.item_attrs(root).clean(cx),\n             primitives: primitives,\n         }\n     }"}]}