{"sha": "b6087492ed7b78096adbdba1e086cc987f46b32d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MDg3NDkyZWQ3Yjc4MDk2YWRiZGJhMWUwODZjYzk4N2Y0NmIzMmQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-06-27T09:14:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-06-27T09:23:06Z"}, "message": "rustc: Retry SIGILL linker invocations\n\nWe've seen quite a few issues with spurious illegal instructions getting\nexecuted on OSX on CI recently. For whatever reason `cc` itself is\nexecuting an illegal instruction and we're not really getting any other\ninformation about what's happening. Since we're already retrying the\nlinker when it segfaults, let's just continue to retry everything and\nautomatically reinvoke the linker when it fails with an illegal instruction.", "tree": {"sha": "98c5622d6dff04dbf041dd05fb98a1f07d18c5df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98c5622d6dff04dbf041dd05fb98a1f07d18c5df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6087492ed7b78096adbdba1e086cc987f46b32d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6087492ed7b78096adbdba1e086cc987f46b32d", "html_url": "https://github.com/rust-lang/rust/commit/b6087492ed7b78096adbdba1e086cc987f46b32d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6087492ed7b78096adbdba1e086cc987f46b32d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "html_url": "https://github.com/rust-lang/rust/commit/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf"}], "stats": {"total": 71, "additions": 47, "deletions": 24}, "files": [{"sha": "618e8b8699fcc9713cd1ad550353ed71160f5341", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b6087492ed7b78096adbdba1e086cc987f46b32d/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6087492ed7b78096adbdba1e086cc987f46b32d/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=b6087492ed7b78096adbdba1e086cc987f46b32d", "patch": "@@ -29,7 +29,7 @@ use std::fmt;\n use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n-use std::process::{Output, Stdio};\n+use std::process::{Output, Stdio, ExitStatus};\n use std::str;\n use std::env;\n \n@@ -510,21 +510,6 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n     sess.abort_if_errors();\n \n     // Invoke the system linker\n-    //\n-    // Note that there's a terribly awful hack that really shouldn't be present\n-    // in any compiler. Here an environment variable is supported to\n-    // automatically retry the linker invocation if the linker looks like it\n-    // segfaulted.\n-    //\n-    // Gee that seems odd, normally segfaults are things we want to know about!\n-    // Unfortunately though in rust-lang/rust#38878 we're experiencing the\n-    // linker segfaulting on Travis quite a bit which is causing quite a bit of\n-    // pain to land PRs when they spuriously fail due to a segfault.\n-    //\n-    // The issue #38878 has some more debugging information on it as well, but\n-    // this unfortunately looks like it's just a race condition in macOS's linker\n-    // with some thread pool working in the background. It seems that no one\n-    // currently knows a fix for this so in the meantime we're left with this...\n     info!(\"{:?}\", &cmd);\n     let retry_on_segfault = env::var(\"RUSTC_RETRY_LINKER_ON_SEGFAULT\").is_ok();\n     let mut prog;\n@@ -567,21 +552,59 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n             info!(\"{:?}\", &cmd);\n             continue;\n         }\n+\n+        // Here's a terribly awful hack that really shouldn't be present in any\n+        // compiler. Here an environment variable is supported to automatically\n+        // retry the linker invocation if the linker looks like it segfaulted.\n+        //\n+        // Gee that seems odd, normally segfaults are things we want to know\n+        // about!  Unfortunately though in rust-lang/rust#38878 we're\n+        // experiencing the linker segfaulting on Travis quite a bit which is\n+        // causing quite a bit of pain to land PRs when they spuriously fail\n+        // due to a segfault.\n+        //\n+        // The issue #38878 has some more debugging information on it as well,\n+        // but this unfortunately looks like it's just a race condition in\n+        // macOS's linker with some thread pool working in the background. It\n+        // seems that no one currently knows a fix for this so in the meantime\n+        // we're left with this...\n         if !retry_on_segfault || i > 3 {\n             break\n         }\n         let msg_segv = \"clang: error: unable to execute command: Segmentation fault: 11\";\n         let msg_bus  = \"clang: error: unable to execute command: Bus error: 10\";\n-        if !(out.contains(msg_segv) || out.contains(msg_bus)) {\n-            break\n+        if out.contains(msg_segv) || out.contains(msg_bus) {\n+            warn!(\n+                \"looks like the linker segfaulted when we tried to call it, \\\n+                 automatically retrying again. cmd = {:?}, out = {}.\",\n+                cmd,\n+                out,\n+            );\n+            continue;\n         }\n \n-        warn!(\n-            \"looks like the linker segfaulted when we tried to call it, \\\n-             automatically retrying again. cmd = {:?}, out = {}.\",\n-            cmd,\n-            out,\n-        );\n+        if is_illegal_instruction(&output.status) {\n+            warn!(\n+                \"looks like the linker hit an illegal instruction when we \\\n+                 tried to call it, automatically retrying again. cmd = {:?}, ]\\\n+                 out = {}, status = {}.\",\n+                cmd,\n+                out,\n+                output.status,\n+            );\n+            continue;\n+        }\n+\n+        #[cfg(unix)]\n+        fn is_illegal_instruction(status: &ExitStatus) -> bool {\n+            use std::os::unix::prelude::*;\n+            status.signal() == Some(libc::SIGILL)\n+        }\n+\n+        #[cfg(windows)]\n+        fn is_illegal_instruction(_status: &ExitStatus) -> bool {\n+            false\n+        }\n     }\n \n     match prog {"}]}