{"sha": "dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMWIwZmI0MzZkYTZkN2UzOTFlMTRiM2E5OGNkNWY5NmIyNzI2YmI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-21T12:53:55Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-21T12:53:55Z"}, "message": "Compiles again", "tree": {"sha": "8f88e4b1a315a965632afd895e575620ddf4069b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f88e4b1a315a965632afd895e575620ddf4069b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb", "html_url": "https://github.com/rust-lang/rust/commit/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6a18cead8885b229f5c7bc5d11cf6ed42d4dc6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6a18cead8885b229f5c7bc5d11cf6ed42d4dc6c", "html_url": "https://github.com/rust-lang/rust/commit/c6a18cead8885b229f5c7bc5d11cf6ed42d4dc6c"}], "stats": {"total": 1135, "additions": 212, "deletions": 923}, "files": [{"sha": "fd692ef8b64a5ac3b70b18f7102ffaef26cf7567", "filename": "src/error.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb", "patch": "@@ -2,7 +2,7 @@ use std::error::Error;\n use std::fmt;\n use rustc::mir;\n use rustc::ty::{FnSig, Ty, layout};\n-use memory::{Pointer, Function};\n+use memory::Pointer;\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n@@ -52,9 +52,6 @@ pub enum EvalError<'tcx> {\n     DeallocatedStaticMemory,\n     Layout(layout::LayoutError<'tcx>),\n     Unreachable,\n-    ExpectedConcreteFunction(Function<'tcx>),\n-    ExpectedDropGlue(Function<'tcx>),\n-    ManuallyCalledDropGlue,\n     Panic,\n }\n \n@@ -128,12 +125,6 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"attempted to get length of a null terminated string, but no null found before end of allocation\",\n             EvalError::Unreachable =>\n                 \"entered unreachable code\",\n-            EvalError::ExpectedConcreteFunction(_) =>\n-                \"tried to use glue function as function\",\n-            EvalError::ExpectedDropGlue(_) =>\n-                \"tried to use non-drop-glue function as drop glue\",\n-            EvalError::ManuallyCalledDropGlue =>\n-                \"tried to manually invoke drop glue\",\n             EvalError::Panic =>\n                 \"the evaluated program panicked\",\n         }"}, {"sha": "9b2e5e1ceaba67d55e24f33e36e2da3b0f5f4eb0", "filename": "src/eval_context.rs", "status": "modified", "additions": 106, "deletions": 62, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb", "patch": "@@ -8,7 +8,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir;\n use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Layout, Size};\n-use rustc::ty::subst::{self, Subst, Substs};\n+use rustc::ty::subst::{Subst, Substs, Kind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Binder};\n use rustc_data_structures::indexed_vec::Idx;\n use syntax::codemap::{self, DUMMY_SP};\n@@ -52,11 +52,8 @@ pub struct Frame<'tcx> {\n     /// The MIR for the function called on this frame.\n     pub mir: MirRef<'tcx>,\n \n-    /// The def_id of the current function.\n-    pub def_id: DefId,\n-\n-    /// type substitutions for the current function invocation.\n-    pub substs: &'tcx Substs<'tcx>,\n+    /// The def_id and substs of the current function\n+    pub instance: ty::Instance<'tcx>,\n \n     /// The span of the call site.\n     pub span: codemap::Span,\n@@ -78,12 +75,6 @@ pub struct Frame<'tcx> {\n     /// Before being initialized, all locals are `Value::ByVal(PrimVal::Undef)`.\n     pub locals: Vec<Value>,\n \n-    /// Temporary allocations introduced to save stackframes\n-    /// This is pure interpreter magic and has nothing to do with how rustc does it\n-    /// An example is calling an FnMut closure that has been converted to a FnOnce closure\n-    /// The value's destructor will be called and the memory freed when the stackframe finishes\n-    pub interpreter_temporaries: Vec<(Pointer, Ty<'tcx>)>,\n-\n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -208,12 +199,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ty.is_sized(self.tcx, &self.tcx.empty_parameter_environment(), DUMMY_SP)\n     }\n \n-    pub fn load_mir(&self, def_id: DefId) -> EvalResult<'tcx, MirRef<'tcx>> {\n-        trace!(\"load mir {:?}\", def_id);\n-        if def_id.is_local() || self.tcx.sess.cstore.is_item_mir_available(def_id) {\n-            Ok(self.tcx.item_mir(def_id))\n-        } else {\n-            Err(EvalError::NoMirFor(self.tcx.item_path_str(def_id)))\n+    pub fn load_mir(&self, instance: ty::InstanceDef<'tcx>) -> EvalResult<'tcx, MirRef<'tcx>> {\n+        trace!(\"load mir {:?}\", instance);\n+        match instance {\n+            ty::InstanceDef::Item(def_id) => self.tcx.maybe_item_mir(def_id).ok_or_else(|| EvalError::NoMirFor(self.tcx.item_path_str(def_id))),\n+            _ => Ok(self.tcx.instance_mir(instance)),\n         }\n     }\n \n@@ -272,13 +262,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub fn push_stack_frame(\n         &mut self,\n-        def_id: DefId,\n+        instance: ty::Instance<'tcx>,\n         span: codemap::Span,\n         mir: MirRef<'tcx>,\n-        substs: &'tcx Substs<'tcx>,\n         return_lvalue: Lvalue<'tcx>,\n         return_to_block: StackPopCleanup,\n-        temporaries: Vec<(Pointer, Ty<'tcx>)>,\n     ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n \n@@ -293,10 +281,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             return_to_block,\n             return_lvalue,\n             locals,\n-            interpreter_temporaries: temporaries,\n             span,\n-            def_id,\n-            substs,\n+            instance,\n             stmt: 0,\n         });\n \n@@ -352,13 +338,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n             }\n         }\n-        // drop and deallocate all temporary allocations\n-        for (ptr, ty) in frame.interpreter_temporaries {\n-            trace!(\"dropping temporary allocation\");\n-            let mut drops = Vec::new();\n-            self.drop(Lvalue::from_ptr(ptr), ty, &mut drops)?;\n-            self.eval_drop_impls(drops, frame.span)?;\n-        }\n+\n         Ok(())\n     }\n \n@@ -665,8 +645,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     ReifyFnPointer => match self.operand_ty(operand).sty {\n-                        ty::TyFnDef(def_id, substs, sig) => {\n-                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs, sig);\n+                        ty::TyFnDef(def_id, substs, _) => {\n+                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs);\n                             self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"reify fn pointer on {:?}\", other),\n@@ -682,8 +662,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     ClosureFnPointer => match self.operand_ty(operand).sty {\n                         ty::TyClosure(def_id, substs) => {\n-                            let fn_ty = self.tcx.closure_type(def_id);\n-                            let fn_ptr = self.memory.create_fn_ptr_from_noncapture_closure(def_id, substs, fn_ty);\n+                            let instance = resolve_closure(self.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n+                            let fn_ptr = self.memory.create_fn_alloc(instance);\n                             self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"reify fn pointer on {:?}\", other),\n@@ -845,16 +825,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             // function items are zero sized\n                             Value::ByRef(self.memory.allocate(0, 0)?)\n                         } else {\n-                            let (def_id, substs) = self.resolve_associated_const(def_id, substs);\n-                            let cid = GlobalId { def_id, substs, promoted: None };\n+                            let instance = self.resolve_associated_const(def_id, substs);\n+                            let cid = GlobalId { instance, promoted: None };\n                             self.globals.get(&cid).expect(\"static/const not cached\").value\n                         }\n                     }\n \n                     Literal::Promoted { index } => {\n                         let cid = GlobalId {\n-                            def_id: self.frame().def_id,\n-                            substs: self.substs(),\n+                            instance: self.frame().instance,\n                             promoted: Some(index),\n                         };\n                         self.globals.get(&cid).expect(\"promoted not cached\").value\n@@ -891,8 +870,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     },\n                     val => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n-                        let ty = self.monomorphize(ty, self.stack[frame].substs);\n-                        let substs = self.stack[frame].substs;\n+                        let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n+                        let substs = self.stack[frame].instance.substs;\n                         let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n                         self.stack[frame].locals[local.index() - 1] = Value::ByRef(ptr);\n                         self.write_value_to_ptr(val, ptr, ty)?;\n@@ -911,7 +890,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match global_val.value {\n                     Value::ByRef(ptr) => Lvalue::from_ptr(ptr),\n                     _ => {\n-                        let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.substs)?;\n+                        let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.instance.substs)?;\n                         self.memory.mark_static(ptr.alloc_id);\n                         self.write_value_to_ptr(global_val.value, ptr, global_val.ty)?;\n                         // see comment on `initialized` field\n@@ -1289,7 +1268,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub(super) fn substs(&self) -> &'tcx Substs<'tcx> {\n-        self.frame().substs\n+        self.frame().instance.substs\n     }\n \n     fn unsize_into_ptr(\n@@ -1320,7 +1299,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             (_, &ty::TyDynamic(ref data, _)) => {\n                 let trait_ref = data.principal().unwrap().with_self_ty(self.tcx, src_pointee_ty);\n                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n-                let vtable = self.get_vtable(trait_ref)?;\n+                let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n                 let ptr = src.read_ptr(&self.memory)?;\n                 let ptr = PrimVal::Ptr(ptr);\n                 let extra = PrimVal::Ptr(vtable);\n@@ -1519,7 +1498,8 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     limits: ResourceLimits,\n ) {\n     let mut ecx = EvalContext::new(tcx, limits);\n-    let mir = ecx.load_mir(def_id).expect(\"main function's MIR not found\");\n+    let instance = ty::Instance::mono(tcx, def_id);\n+    let mir = ecx.load_mir(instance.def).expect(\"main function's MIR not found\");\n \n     if !mir.return_ty.is_nil() || mir.arg_count != 0 {\n         let msg = \"miri does not support main functions without `fn()` type signatures\";\n@@ -1528,13 +1508,11 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     }\n \n     ecx.push_stack_frame(\n-        def_id,\n+        instance,\n         DUMMY_SP,\n         mir,\n-        tcx.intern_substs(&[]),\n         Lvalue::from_ptr(Pointer::zst_ptr()),\n         StackPopCleanup::None,\n-        Vec::new(),\n     ).expect(\"could not allocate first stack frame\");\n \n     loop {\n@@ -1564,23 +1542,12 @@ fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {\n         block.terminator().source_info.span\n     };\n     let mut err = tcx.sess.struct_span_err(span, &e.to_string());\n-    for &Frame { def_id, substs, span, .. } in ecx.stack().iter().rev() {\n-        if tcx.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr {\n+    for &Frame { instance, span, .. } in ecx.stack().iter().rev() {\n+        if tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n             err.span_note(span, \"inside call to closure\");\n             continue;\n         }\n-        // FIXME(solson): Find a way to do this without this Display impl hack.\n-        use rustc::util::ppaux;\n-        use std::fmt;\n-        struct Instance<'tcx>(DefId, &'tcx subst::Substs<'tcx>);\n-        impl<'tcx> ::std::panic::UnwindSafe for Instance<'tcx> {}\n-        impl<'tcx> ::std::panic::RefUnwindSafe for Instance<'tcx> {}\n-        impl<'tcx> fmt::Display for Instance<'tcx> {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                ppaux::parameterized(f, self.1, self.0, &[])\n-            }\n-        }\n-        err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));\n+        err.span_note(span, &format!(\"inside call to {}\", instance));\n     }\n     err.emit();\n }\n@@ -1657,3 +1624,80 @@ impl<'b, 'tcx: 'b> IntoValTyPair<'tcx> for &'b mir::Operand<'tcx> {\n         Ok((value, value_ty))\n     }\n }\n+\n+\n+/// FIXME: expose trans::monomorphize::resolve_closure\n+pub fn resolve_closure<'a, 'tcx> (\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    substs: ty::ClosureSubsts<'tcx>,\n+    requested_kind: ty::ClosureKind,\n+) -> ty::Instance<'tcx> {\n+    let actual_kind = tcx.closure_kind(def_id);\n+    match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n+        Ok(true) => fn_once_adapter_instance(tcx, def_id, substs),\n+        _ => ty::Instance::new(def_id, substs.substs)\n+    }\n+}\n+\n+fn fn_once_adapter_instance<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    closure_did: DefId,\n+    substs: ty::ClosureSubsts<'tcx>,\n+) -> ty::Instance<'tcx> {\n+    debug!(\"fn_once_adapter_shim({:?}, {:?})\",\n+           closure_did,\n+           substs);\n+    let fn_once = tcx.lang_items.fn_once_trait().unwrap();\n+    let call_once = tcx.associated_items(fn_once)\n+        .find(|it| it.kind == ty::AssociatedKind::Method)\n+        .unwrap().def_id;\n+    let def = ty::InstanceDef::ClosureOnceShim { call_once };\n+\n+    let self_ty = tcx.mk_closure_from_closure_substs(\n+        closure_did, substs);\n+\n+    let sig = tcx.closure_type(closure_did).subst(tcx, substs.substs);\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n+    assert_eq!(sig.inputs().len(), 1);\n+    let substs = tcx.mk_substs([\n+        Kind::from(self_ty),\n+        Kind::from(sig.inputs()[0]),\n+    ].iter().cloned());\n+\n+    debug!(\"fn_once_adapter_shim: self_ty={:?} sig={:?}\", self_ty, sig);\n+    ty::Instance { def, substs }\n+}\n+\n+fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n+                              trait_closure_kind: ty::ClosureKind)\n+                              -> Result<bool, ()>\n+{\n+    match (actual_closure_kind, trait_closure_kind) {\n+        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+        (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n+            // No adapter needed.\n+           Ok(false)\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // basically the same thing, so we can just return llfn.\n+            Ok(false)\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n+            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+            // this by doing something like:\n+            //\n+            //     fn call_once(self, ...) { call_mut(&self, ...) }\n+            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+            //\n+            // These are both the same at trans time.\n+            Ok(true)\n+        }\n+        _ => Err(()),\n+    }\n+}"}, {"sha": "62855c0450579a16afe3b30bbbc0ce11751edb4b", "filename": "src/lvalue.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb", "patch": "@@ -1,7 +1,5 @@\n-use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::ty::layout::{Size, Align};\n-use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -42,15 +40,9 @@ pub enum LvalueExtra {\n /// Uniquely identifies a specific constant or static.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n pub struct GlobalId<'tcx> {\n-    /// For a constant or static, the `DefId` of the item itself.\n-    /// For a promoted global, the `DefId` of the function they belong to.\n-    pub(super) def_id: DefId,\n-\n-    /// For statics and constants this is `Substs::empty()`, so only promoteds and associated\n-    /// constants actually have something useful here. We could special case statics and constants,\n-    /// but that would only require more branching when working with constants, and not bring any\n-    /// real benefits.\n-    pub(super) substs: &'tcx Substs<'tcx>,\n+    /// For a constant or static, the `Instance` of the item itself.\n+    /// For a promoted global, the `Instance` of the function they belong to.\n+    pub(super) instance: ty::Instance<'tcx>,\n \n     /// The index for promoted globals within their function's `Mir`.\n     pub(super) promoted: Option<mir::Promoted>,\n@@ -138,8 +130,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Local(local) => Lvalue::Local { frame: self.stack.len() - 1, local, field: None },\n \n             Static(ref static_) => {\n-                let substs = self.tcx.intern_substs(&[]);\n-                Lvalue::Global(GlobalId { def_id: static_.def_id, substs, promoted: None })\n+                let instance = ty::Instance::mono(self.tcx, static_.def_id);\n+                Lvalue::Global(GlobalId { instance, promoted: None })\n             }\n \n             Projection(ref proj) => return self.eval_lvalue_projection(proj),"}, {"sha": "058f8b478cac415840b3ee78959f1091898aab98", "filename": "src/memory.rs", "status": "modified", "additions": 13, "deletions": 111, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb", "patch": "@@ -3,7 +3,7 @@ use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque, BTreeSet\n use std::{fmt, iter, ptr, mem, io};\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, PolyFnSig, ClosureSubsts};\n+use rustc::ty;\n use rustc::ty::subst::Substs;\n use rustc::ty::layout::{self, TargetDataLayout};\n \n@@ -102,44 +102,6 @@ impl Pointer {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]\n-/// Identifies a specific monomorphized function\n-pub struct FunctionDefinition<'tcx> {\n-    pub def_id: DefId,\n-    pub substs: &'tcx Substs<'tcx>,\n-    pub sig: PolyFnSig<'tcx>,\n-}\n-\n-/// Either a concrete function, or a glue function\n-#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]\n-pub enum Function<'tcx> {\n-    /// A function or method created by compiling code\n-    Concrete(FunctionDefinition<'tcx>),\n-    /// Glue required to call a regular function through a Fn(Mut|Once) trait object\n-    FnDefAsTraitObject(FunctionDefinition<'tcx>),\n-    /// A drop glue function only needs to know the real type, and then miri can extract\n-    /// that type from a vtable's drop pointer.\n-    /// Instead of storing some drop function, we act as if there are no trait objects, by\n-    /// mapping trait objects to their real types before acting on them.\n-    DropGlue(ty::Ty<'tcx>),\n-    /// Glue required to treat the ptr part of a fat pointer\n-    /// as a function pointer\n-    FnPtrAsTraitObject(PolyFnSig<'tcx>),\n-    /// Glue for Closures\n-    Closure(FunctionDefinition<'tcx>),\n-    /// Glue for noncapturing closures casted to function pointers\n-    NonCaptureClosureAsFnPtr(FunctionDefinition<'tcx>),\n-}\n-\n-impl<'tcx> Function<'tcx> {\n-    pub fn expect_drop_glue_real_ty(self) -> EvalResult<'tcx, ty::Ty<'tcx>> {\n-        match self {\n-            Function::DropGlue(real_ty) => Ok(real_ty),\n-            other => Err(EvalError::ExpectedDropGlue(other)),\n-        }\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n@@ -165,10 +127,10 @@ pub struct Memory<'a, 'tcx> {\n \n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n-    functions: HashMap<AllocId, Function<'tcx>>,\n+    functions: HashMap<AllocId, ty::Instance<'tcx>>,\n \n     /// Inverse map of `functions` so we don't allocate a new pointer every time we need one\n-    function_alloc_cache: HashMap<Function<'tcx>, AllocId>,\n+    function_alloc_cache: HashMap<ty::Instance<'tcx>, AllocId>,\n \n     /// Target machine data layout to emulate.\n     pub layout: &'a TargetDataLayout,\n@@ -214,55 +176,20 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.alloc_map.iter()\n     }\n \n-    pub fn create_closure_ptr(&mut self, def_id: DefId, substs: ClosureSubsts<'tcx>, sig: PolyFnSig<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::Closure(FunctionDefinition {\n-            def_id,\n-            substs: substs.substs,\n-            sig,\n-        }))\n-    }\n-\n-    pub fn create_fn_ptr_from_noncapture_closure(&mut self, def_id: DefId, substs: ClosureSubsts<'tcx>, sig: PolyFnSig<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::NonCaptureClosureAsFnPtr(FunctionDefinition {\n-            def_id,\n-            substs: substs.substs,\n-            sig,\n-        }))\n-    }\n-\n-    pub fn create_fn_as_trait_glue(&mut self, def_id: DefId, substs: &'tcx Substs, sig: PolyFnSig<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::FnDefAsTraitObject(FunctionDefinition {\n-            def_id,\n-            substs,\n-            sig,\n-        }))\n-    }\n-\n-    pub fn create_fn_ptr_as_trait_glue(&mut self, sig: PolyFnSig<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::FnPtrAsTraitObject(sig))\n-    }\n-\n-    pub fn create_drop_glue(&mut self, ty: ty::Ty<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::DropGlue(ty))\n-    }\n-\n-    pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs, sig: PolyFnSig<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::Concrete(FunctionDefinition {\n-            def_id,\n-            substs,\n-            sig,\n-        }))\n+    pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Pointer {\n+        let instance = ty::Instance::new(def_id, substs);\n+        self.create_fn_alloc(instance)\n     }\n \n-    fn create_fn_alloc(&mut self, def: Function<'tcx>) -> Pointer {\n-        if let Some(&alloc_id) = self.function_alloc_cache.get(&def) {\n+    pub fn create_fn_alloc(&mut self, instance: ty::Instance<'tcx>) -> Pointer {\n+        if let Some(&alloc_id) = self.function_alloc_cache.get(&instance) {\n             return Pointer::new(alloc_id, 0);\n         }\n         let id = self.next_id;\n         debug!(\"creating fn ptr: {}\", id);\n         self.next_id.0 += 1;\n-        self.functions.insert(id, def);\n-        self.function_alloc_cache.insert(def, id);\n+        self.functions.insert(id, instance);\n+        self.function_alloc_cache.insert(instance, id);\n         Pointer::new(id, 0)\n     }\n \n@@ -469,7 +396,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn get_fn(&self, id: AllocId) -> EvalResult<'tcx, Function<'tcx>> {\n+    pub fn get_fn(&self, id: AllocId) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         debug!(\"reading fn ptr: {}\", id);\n         match self.functions.get(&id) {\n             Some(&fndef) => Ok(fndef),\n@@ -501,28 +428,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n             let alloc = match (self.alloc_map.get(&id), self.functions.get(&id)) {\n                 (Some(a), None) => a,\n-                (None, Some(&Function::Concrete(fn_def))) => {\n-                    trace!(\"{} {}\", msg, dump_fn_def(fn_def));\n-                    continue;\n-                },\n-                (None, Some(&Function::DropGlue(real_ty))) => {\n-                    trace!(\"{} drop glue for {}\", msg, real_ty);\n-                    continue;\n-                },\n-                (None, Some(&Function::FnDefAsTraitObject(fn_def))) => {\n-                    trace!(\"{} fn as Fn glue for {}\", msg, dump_fn_def(fn_def));\n-                    continue;\n-                },\n-                (None, Some(&Function::FnPtrAsTraitObject(fn_def))) => {\n-                    trace!(\"{} fn ptr as Fn glue (signature: {:?})\", msg, fn_def);\n-                    continue;\n-                },\n-                (None, Some(&Function::Closure(fn_def))) => {\n-                    trace!(\"{} closure glue for {}\", msg, dump_fn_def(fn_def));\n-                    continue;\n-                },\n-                (None, Some(&Function::NonCaptureClosureAsFnPtr(fn_def))) => {\n-                    trace!(\"{} non-capture closure as fn ptr glue for {}\", msg, dump_fn_def(fn_def));\n+                (None, Some(instance)) => {\n+                    trace!(\"{} {}\", msg, instance);\n                     continue;\n                 },\n                 (None, None) => {\n@@ -594,11 +501,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n }\n \n-fn dump_fn_def<'tcx>(fn_def: FunctionDefinition<'tcx>) -> String {\n-    let name = ty::tls::with(|tcx| tcx.item_path_str(fn_def.def_id));\n-    format!(\"function pointer: {}: {}\", name, fn_def.sig.skip_binder())\n-}\n-\n /// Byte accessors\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     fn get_bytes_unchecked(&self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {"}, {"sha": "8a0cbc4a8f1c9d08bbd60602d8a558368060497f", "filename": "src/step.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb", "patch": "@@ -45,8 +45,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             let mut new = Ok(0);\n             ConstantExtractor {\n                 span: stmt.source_info.span,\n-                substs: self.substs(),\n-                def_id: self.frame().def_id,\n+                instance: self.frame().instance,\n                 ecx: self,\n                 mir: Ref::clone(&mir),\n                 new_constants: &mut new,\n@@ -63,8 +62,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let mut new = Ok(0);\n         ConstantExtractor {\n             span: terminator.source_info.span,\n-            substs: self.substs(),\n-            def_id: self.frame().def_id,\n+            instance: self.frame().instance,\n             ecx: self,\n             mir: Ref::clone(&mir),\n             new_constants: &mut new,\n@@ -145,8 +143,7 @@ struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b> {\n     span: Span,\n     ecx: &'a mut EvalContext<'b, 'tcx>,\n     mir: MirRef<'tcx>,\n-    def_id: DefId,\n-    substs: &'tcx subst::Substs<'tcx>,\n+    instance: ty::Instance<'tcx>,\n     new_constants: &'a mut EvalResult<'tcx, u64>,\n }\n \n@@ -158,26 +155,24 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         span: Span,\n         shared: bool,\n     ) {\n-        let (def_id, substs) = self.ecx.resolve_associated_const(def_id, substs);\n-        let cid = GlobalId { def_id, substs, promoted: None };\n+        let instance = self.ecx.resolve_associated_const(def_id, substs);\n+        let cid = GlobalId { instance, promoted: None };\n         if self.ecx.globals.contains_key(&cid) {\n             return;\n         }\n         self.try(|this| {\n-            let mir = this.ecx.load_mir(def_id)?;\n+            let mir = this.ecx.load_mir(instance.def)?;\n             this.ecx.globals.insert(cid, Global::uninitialized(mir.return_ty));\n             let mutable = !shared || mir.return_ty.type_contents(this.ecx.tcx).interior_unsafe();\n             let cleanup = StackPopCleanup::MarkStatic(mutable);\n             let name = ty::tls::with(|tcx| tcx.item_path_str(def_id));\n             trace!(\"pushing stack frame for global: {}\", name);\n             this.ecx.push_stack_frame(\n-                def_id,\n+                instance,\n                 span,\n                 mir,\n-                substs,\n                 Lvalue::Global(cid),\n                 cleanup,\n-                Vec::new(),\n             )\n         });\n     }\n@@ -210,8 +205,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n             },\n             mir::Literal::Promoted { index } => {\n                 let cid = GlobalId {\n-                    def_id: self.def_id,\n-                    substs: self.substs,\n+                    instance: self.instance,\n                     promoted: Some(index),\n                 };\n                 if self.ecx.globals.contains_key(&cid) {\n@@ -220,16 +214,14 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                 let mir = Ref::clone(&self.mir);\n                 let mir = Ref::map(mir, |mir| &mir.promoted[index]);\n                 self.try(|this| {\n-                    let ty = this.ecx.monomorphize(mir.return_ty, this.substs);\n+                    let ty = this.ecx.monomorphize(mir.return_ty, this.instance.substs);\n                     this.ecx.globals.insert(cid, Global::uninitialized(ty));\n                     trace!(\"pushing stack frame for {:?}\", index);\n-                    this.ecx.push_stack_frame(this.def_id,\n+                    this.ecx.push_stack_frame(this.instance,\n                                               constant.span,\n                                               mir,\n-                                              this.substs,\n                                               Lvalue::Global(cid),\n-                                              StackPopCleanup::MarkStatic(false),\n-                                              Vec::new())\n+                                              StackPopCleanup::MarkStatic(false))\n                 });\n             }\n         }"}, {"sha": "efa415679328c46461ed4b090c6bdb049383c126", "filename": "src/terminator/drop.rs", "status": "removed", "additions": 0, "deletions": 224, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/c6a18cead8885b229f5c7bc5d11cf6ed42d4dc6c/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a18cead8885b229f5c7bc5d11cf6ed42d4dc6c/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=c6a18cead8885b229f5c7bc5d11cf6ed42d4dc6c", "patch": "@@ -1,224 +0,0 @@\n-use rustc::hir::def_id::DefId;\n-use rustc::traits;\n-use rustc::ty::layout::Layout;\n-use rustc::ty::subst::{Substs, Kind};\n-use rustc::ty::{self, Ty};\n-use rustc::mir;\n-use syntax::codemap::Span;\n-\n-use error::{EvalError, EvalResult};\n-use eval_context::{EvalContext, monomorphize_field_ty, StackPopCleanup};\n-use lvalue::{Lvalue, LvalueExtra};\n-use memory::Pointer;\n-use value::PrimVal;\n-use value::Value;\n-\n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    /// Creates stack frames for all drop impls. See `drop` for the actual content.\n-    pub fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>, span: Span) -> EvalResult<'tcx> {\n-        // add them to the stack in reverse order, because the impl that needs to run the last\n-        // is the one that needs to be at the bottom of the stack\n-        for (drop_def_id, self_arg, substs) in drops.into_iter().rev() {\n-            let mir = self.load_mir(drop_def_id)?;\n-            trace!(\"substs for drop glue: {:?}\", substs);\n-            self.push_stack_frame(\n-                drop_def_id,\n-                span,\n-                mir,\n-                substs,\n-                Lvalue::from_ptr(Pointer::zst_ptr()),\n-                StackPopCleanup::None,\n-                Vec::new(),\n-            )?;\n-            let mut arg_locals = self.frame().mir.args_iter();\n-            let first = arg_locals.next().expect(\"drop impl has self arg\");\n-            assert!(arg_locals.next().is_none(), \"drop impl should have only one arg\");\n-            let dest = self.eval_lvalue(&mir::Lvalue::Local(first))?;\n-            let ty = self.frame().mir.local_decls[first].ty;\n-            self.write_value(self_arg, dest, ty)?;\n-        }\n-        Ok(())\n-    }\n-\n-    /// push DefIds of drop impls and their argument on the given vector\n-    pub fn drop(\n-        &mut self,\n-        lval: Lvalue<'tcx>,\n-        ty: Ty<'tcx>,\n-        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n-    ) -> EvalResult<'tcx> {\n-        if !self.type_needs_drop(ty) {\n-            debug!(\"no need to drop {:?}\", ty);\n-            return Ok(());\n-        }\n-        trace!(\"need to drop {:?} at {:?}\", ty, lval);\n-\n-        match ty.sty {\n-            // special case `Box` to deallocate the inner allocation\n-            ty::TyAdt(ref def, _) if def.is_box() => {\n-                let contents_ty = ty.boxed_ty();\n-                let val = self.read_lvalue(lval);\n-                // we are going through the read_value path, because that already does all the\n-                // checks for the trait object types. We'd only be repeating ourselves here.\n-                let val = self.follow_by_ref_value(val, ty)?;\n-                trace!(\"box dealloc on {:?}\", val);\n-                match val {\n-                    Value::ByRef(_) => bug!(\"follow_by_ref_value can't result in ByRef\"),\n-                    Value::ByVal(ptr) => {\n-                        assert!(self.type_is_sized(contents_ty));\n-                        let contents_ptr = ptr.to_ptr()?;\n-                        self.drop(Lvalue::from_ptr(contents_ptr), contents_ty, drop)?;\n-                    },\n-                    Value::ByValPair(prim_ptr, extra) => {\n-                        let ptr = prim_ptr.to_ptr()?;\n-                        let extra = match self.tcx.struct_tail(contents_ty).sty {\n-                            ty::TyDynamic(..) => LvalueExtra::Vtable(extra.to_ptr()?),\n-                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.to_u64()?),\n-                            _ => bug!(\"invalid fat pointer type: {}\", ty),\n-                        };\n-                        self.drop(Lvalue::Ptr { ptr, extra }, contents_ty, drop)?;\n-                    },\n-                }\n-                // We cannot use Box's destructor, because it is a no-op and only exists to reduce\n-                // the number of hacks required in the compiler around the Box type.\n-                let box_free_fn = self.tcx.lang_items.box_free_fn().expect(\"no box_free lang item\");\n-                let substs = self.tcx.intern_substs(&[Kind::from(contents_ty)]);\n-                // this is somewhat hacky, but hey, there's no representation difference between\n-                // pointers, `Box`es and references, so\n-                // #[lang = \"box_free\"] unsafe fn box_free<T>(ptr: *mut T)\n-                // is the same as\n-                // fn drop(&mut self) if Self is Box<T>\n-                drop.push((box_free_fn, val, substs));\n-            }\n-\n-            ty::TyAdt(adt_def, substs) => {\n-                // FIXME: some structs are represented as ByValPair\n-                let mut lval = self.force_allocation(lval)?;\n-                let (adt_ptr, extra) = lval.to_ptr_and_extra();\n-\n-                // run drop impl before the fields' drop impls\n-                if let Some(destructor) = adt_def.destructor(self.tcx) {\n-                    let trait_ref = ty::Binder(ty::TraitRef {\n-                        def_id: self.tcx.lang_items.drop_trait().unwrap(),\n-                        substs: self.tcx.mk_substs_trait(ty, &[]),\n-                    });\n-                    let vtable = match self.fulfill_obligation(trait_ref) {\n-                        traits::VtableImpl(data) => data,\n-                        _ => bug!(\"dtor for {:?} is not an impl???\", ty)\n-                    };\n-                    let val = match extra {\n-                        LvalueExtra::None => Value::ByVal(PrimVal::Ptr(adt_ptr)),\n-                        LvalueExtra::DowncastVariant(_) => bug!(\"downcast variant in drop\"),\n-                        LvalueExtra::Length(n) => Value::ByValPair(PrimVal::Ptr(adt_ptr), PrimVal::from_u128(n as u128)),\n-                        LvalueExtra::Vtable(vtable) => Value::ByValPair(PrimVal::Ptr(adt_ptr), PrimVal::Ptr(vtable)),\n-                    };\n-                    drop.push((destructor.did, val, vtable.substs));\n-                }\n-\n-                let layout = self.type_layout(ty)?;\n-                let fields = match *layout {\n-                    Layout::Univariant { .. } => &adt_def.struct_variant().fields,\n-                    Layout::General { .. } => {\n-                        let discr_val = self.read_discriminant_value(adt_ptr, ty)? as u128;\n-                        let ptr = self.force_allocation(lval)?.to_ptr();\n-                        match adt_def.discriminants(self.tcx).position(|v| discr_val == v.to_u128_unchecked()) {\n-                            Some(i) => {\n-                                lval = Lvalue::Ptr {\n-                                    ptr,\n-                                    extra: LvalueExtra::DowncastVariant(i),\n-                                };\n-                                &adt_def.variants[i].fields\n-                            },\n-                            None => return Err(EvalError::InvalidDiscriminant),\n-                        }\n-                    },\n-                    Layout::StructWrappedNullablePointer { .. } |\n-                    Layout::RawNullablePointer { .. } => {\n-                        let discr = self.read_discriminant_value(adt_ptr, ty)?;\n-                        assert_eq!(discr as usize as u128, discr);\n-                        &adt_def.variants[discr as usize].fields\n-                    },\n-                    Layout::CEnum { .. } => return Ok(()),\n-                    _ => bug!(\"{:?} is not an adt layout\", layout),\n-                };\n-                let tcx = self.tcx;\n-                self.drop_fields(\n-                    fields.iter().map(|field| monomorphize_field_ty(tcx, field, substs)),\n-                    lval,\n-                    ty,\n-                    drop,\n-                )?;\n-            }\n-\n-            ty::TyTuple(fields, _) =>\n-                self.drop_fields(fields.into_iter().cloned(), lval, ty, drop)?,\n-\n-            ty::TyDynamic(..) => {\n-                let (ptr, vtable) = match lval {\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => (ptr, vtable),\n-                    _ => bug!(\"expected an lvalue with a vtable\"),\n-                };\n-                if let Some(real_ty) = self.read_drop_type_from_vtable(vtable)? {\n-                    self.drop(Lvalue::from_ptr(ptr), real_ty, drop)?;\n-                }\n-            }\n-\n-            ty::TySlice(elem_ty) => {\n-                let (ptr, len) = match lval {\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => (ptr, len),\n-                    _ => bug!(\"expected an lvalue with a length\"),\n-                };\n-                let size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n-                // FIXME: this creates a lot of stack frames if the element type has\n-                // a drop impl\n-                for i in 0..len {\n-                    self.drop(Lvalue::from_ptr(ptr.offset(i * size)), elem_ty, drop)?;\n-                }\n-            }\n-\n-            ty::TyArray(elem_ty, len) => {\n-                let lval = self.force_allocation(lval)?;\n-                let (ptr, extra) = match lval {\n-                    Lvalue::Ptr { ptr, extra } => (ptr, extra),\n-                    _ => bug!(\"expected an lvalue with optional extra data\"),\n-                };\n-                let size = self.type_size(elem_ty)?.expect(\"array element cannot be unsized\");\n-                // FIXME: this creates a lot of stack frames if the element type has\n-                // a drop impl\n-                for i in 0..(len as u64) {\n-                    self.drop(Lvalue::Ptr { ptr: ptr.offset(i * size), extra }, elem_ty, drop)?;\n-                }\n-            }\n-\n-            ty::TyClosure(def_id, substs) => {\n-                let fields = substs.upvar_tys(def_id, self.tcx);\n-                self.drop_fields(fields, lval, ty, drop)?;\n-            }\n-\n-            _ => bug!(),\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn drop_fields<I>(\n-        &mut self,\n-        fields: I,\n-        lval: Lvalue<'tcx>,\n-        ty: Ty<'tcx>,\n-        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n-    ) -> EvalResult<'tcx>\n-        where I: Iterator<Item=Ty<'tcx>>,\n-    {\n-        trace!(\"drop_fields: {:?} of type {}\", lval, ty);\n-        for (i, field_ty) in fields.enumerate() {\n-            let field_lval = self.lvalue_field(lval, i, ty, field_ty)?;\n-            self.drop(field_lval, field_ty, drop)?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment())\n-    }\n-}"}, {"sha": "a84b87f49a7367c521f893fa528ef0f6e2be4aa7", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 24, "deletions": 55, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb", "patch": "@@ -1,4 +1,3 @@\n-use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::ty::layout::{Layout, Size, Align};\n use rustc::ty::subst::Substs;\n@@ -13,8 +12,7 @@ use value::{PrimVal, PrimValKind, Value};\n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn call_intrinsic(\n         &mut self,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n+        instance: ty::Instance<'tcx>,\n         args: &[mir::Operand<'tcx>],\n         dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n@@ -31,7 +29,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let f32 = self.tcx.types.f32;\n         let f64 = self.tcx.types.f64;\n \n-        let intrinsic_name = &self.tcx.item_name(def_id).as_str()[..];\n+        let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n         match intrinsic_name {\n             \"add_with_overflow\" =>\n                 self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_ty)?,\n@@ -60,7 +58,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_load_relaxed\" |\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 self.write_value(Value::ByRef(ptr), dest, ty)?;\n             }\n@@ -69,7 +67,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_store_relaxed\" |\n             \"atomic_store_rel\" |\n             \"volatile_store\" => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let dest = arg_vals[0].read_ptr(&self.memory)?;\n                 self.write_value_to_ptr(arg_vals[1], dest, ty)?;\n             }\n@@ -79,7 +77,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n@@ -93,7 +91,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let expect_old = self.value_to_primval(arg_vals[1], ty)?;\n                 let change = self.value_to_primval(arg_vals[2], ty)?;\n@@ -115,7 +113,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_and\" | \"atomic_and_acq\" | \"atomic_and_rel\" | \"atomic_and_acqrel\" | \"atomic_and_relaxed\" |\n             \"atomic_xadd\" | \"atomic_xadd_acq\" | \"atomic_xadd_rel\" | \"atomic_xadd_acqrel\" | \"atomic_xadd_relaxed\" |\n             \"atomic_xsub\" | \"atomic_xsub_acq\" | \"atomic_xsub_rel\" | \"atomic_xsub_acqrel\" | \"atomic_xsub_relaxed\" => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n@@ -144,7 +142,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"copy\" |\n             \"copy_nonoverlapping\" => {\n                 // FIXME: check whether overlapping occurs\n-                let elem_ty = substs.type_at(0);\n+                let elem_ty = instance.substs.type_at(0);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"cannot copy unsized value\");\n                 let elem_align = self.type_align(elem_ty)?;\n                 let src = arg_vals[0].read_ptr(&self.memory)?;\n@@ -157,49 +155,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"cttz\" |\n             \"ctlz\" |\n             \"bswap\" => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let num = self.value_to_primval(arg_vals[0], ty)?;\n                 let kind = self.ty_to_primval_kind(ty)?;\n                 let num = numeric_intrinsic(intrinsic_name, num, kind)?;\n                 self.write_primval(dest, num, ty)?;\n             }\n \n             \"discriminant_value\" => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let adt_ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n                 self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n             }\n \n-            \"drop_in_place\" => {\n-                let ty = substs.type_at(0);\n-                trace!(\"drop in place on {}\", ty);\n-                let ptr_ty = self.tcx.mk_mut_ptr(ty);\n-                let lvalue = match self.follow_by_ref_value(arg_vals[0], ptr_ty)? {\n-                    Value::ByRef(_) => bug!(\"follow_by_ref_value returned ByRef\"),\n-                    Value::ByVal(value) => Lvalue::from_ptr(value.to_ptr()?),\n-                    Value::ByValPair(ptr, extra) => Lvalue::Ptr {\n-                        ptr: ptr.to_ptr()?,\n-                        extra: match self.tcx.struct_tail(ty).sty {\n-                            ty::TyDynamic(..) => LvalueExtra::Vtable(extra.to_ptr()?),\n-                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.to_u64()?),\n-                            _ => bug!(\"invalid fat pointer type: {}\", ptr_ty),\n-                        },\n-                    },\n-                };\n-                let mut drops = Vec::new();\n-                self.drop(lvalue, ty, &mut drops)?;\n-                let span = {\n-                    let frame = self.frame();\n-                    frame.mir[frame.block].terminator().source_info.span\n-                };\n-                // need to change the block before pushing the drop impl stack frames\n-                // we could do this for all intrinsics before evaluating the intrinsics, but if\n-                // the evaluation fails, we should not have moved forward\n-                self.goto_block(target);\n-                return self.eval_drop_impls(drops, span);\n-            }\n-\n             \"sinf32\" | \"fabsf32\" | \"cosf32\" |\n             \"sqrtf32\" | \"expf32\" | \"exp2f32\" |\n             \"logf32\" | \"log10f32\" | \"log2f32\" |\n@@ -247,7 +216,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let kind = self.ty_to_primval_kind(ty)?;\n                 let a = self.value_to_primval(arg_vals[0], ty)?;\n                 let b = self.value_to_primval(arg_vals[1], ty)?;\n@@ -279,7 +248,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         Value::ByVal(PrimVal::Undef) => match this.ty_to_primval_kind(dest_ty) {\n                             Ok(_) => Value::ByVal(PrimVal::Bytes(0)),\n                             Err(_) => {\n-                                let ptr = this.alloc_ptr_with_substs(dest_ty, substs)?;\n+                                let ptr = this.alloc_ptr_with_substs(dest_ty, instance.substs)?;\n                                 this.memory.write_repeat(ptr, 0, size)?;\n                                 Value::ByRef(ptr)\n                             }\n@@ -299,35 +268,35 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"min_align_of\" => {\n-                let elem_ty = substs.type_at(0);\n+                let elem_ty = instance.substs.type_at(0);\n                 let elem_align = self.type_align(elem_ty)?;\n                 let align_val = PrimVal::from_u128(elem_align as u128);\n                 self.write_primval(dest, align_val, dest_ty)?;\n             }\n \n             \"pref_align_of\" => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let layout = self.type_layout(ty)?;\n                 let align = layout.align(&self.tcx.data_layout).pref();\n                 let align_val = PrimVal::from_u128(align as u128);\n                 self.write_primval(dest, align_val, dest_ty)?;\n             }\n \n             \"move_val_init\" => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 self.write_value_to_ptr(arg_vals[1], ptr, ty)?;\n             }\n \n             \"needs_drop\" => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let env = self.tcx.empty_parameter_environment();\n                 let needs_drop = self.tcx.type_needs_drop_given_env(ty, &env);\n                 self.write_primval(dest, PrimVal::from_bool(needs_drop), dest_ty)?;\n             }\n \n             \"offset\" => {\n-                let pointee_ty = substs.type_at(0);\n+                let pointee_ty = instance.substs.type_at(0);\n                 // FIXME: assuming here that type size is < i64::max_value()\n                 let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n@@ -388,7 +357,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"size_of\" => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 // FIXME: change the `box_free` lang item to take `T: ?Sized` and have it use the\n                 // `size_of_val` intrinsic, then change this back to\n                 // .expect(\"size_of intrinsic called on unsized value\")\n@@ -398,32 +367,32 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"size_of_val\" => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let (size, _) = self.size_and_align_of_dst(ty, arg_vals[0])?;\n                 self.write_primval(dest, PrimVal::from_u128(size as u128), dest_ty)?;\n             }\n \n             \"min_align_of_val\" |\n             \"align_of_val\" => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let (_, align) = self.size_and_align_of_dst(ty, arg_vals[0])?;\n                 self.write_primval(dest, PrimVal::from_u128(align as u128), dest_ty)?;\n             }\n \n             \"type_name\" => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let ty_name = ty.to_string();\n                 let s = self.str_to_value(&ty_name)?;\n                 self.write_value(s, dest, dest_ty)?;\n             }\n             \"type_id\" => {\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let n = self.tcx.type_id_hash(ty);\n                 self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n             }\n \n             \"transmute\" => {\n-                let dest_ty = substs.type_at(1);\n+                let dest_ty = instance.substs.type_at(1);\n                 self.write_value(arg_vals[0], dest, dest_ty)?;\n             }\n \n@@ -449,7 +418,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"write_bytes\" => {\n                 let u8 = self.tcx.types.u8;\n-                let ty = substs.type_at(0);\n+                let ty = instance.substs.type_at(0);\n                 let ty_align = self.type_align(ty)?;\n                 let val_byte = self.value_to_primval(arg_vals[1], u8)?.to_u128()? as u8;\n                 let size = self.type_size(ty)?.expect(\"write_bytes() type must be sized\");"}, {"sha": "8e0623dcba1760a8726100283eb1d2560cf9b357", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 26, "deletions": 193, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb", "patch": "@@ -1,22 +1,18 @@\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::ty::layout::Layout;\n-use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n-use rustc_const_math::ConstInt;\n use syntax::codemap::Span;\n use syntax::attr;\n use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n use lvalue::Lvalue;\n-use memory::{Pointer, FunctionDefinition, Function};\n+use memory::Pointer;\n use value::PrimVal;\n use value::Value;\n \n mod intrinsic;\n-mod drop;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn goto_block(&mut self, target: mir::BasicBlock) {\n@@ -64,46 +60,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let func_ty = self.operand_ty(func);\n                 let fn_def = match func_ty.sty {\n-                    ty::TyFnPtr(bare_sig) => {\n-                        let bare_sig = self.erase_lifetimes(&bare_sig);\n+                    ty::TyFnPtr(_) => {\n                         let fn_ptr = self.eval_operand_to_primval(func)?.to_ptr()?;\n-                        let fn_def = self.memory.get_fn(fn_ptr.alloc_id)?;\n-                        match fn_def {\n-                            Function::Concrete(fn_def) => {\n-                                // transmuting function pointers in miri is fine as long as the number of\n-                                // arguments and the abi don't change.\n-                                let sig = self.erase_lifetimes(&fn_def.sig);\n-                                if sig.abi != bare_sig.abi ||\n-                                    sig.variadic != bare_sig.variadic ||\n-                                    sig.inputs_and_output != bare_sig.inputs_and_output {\n-                                    return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n-                                }\n-                            },\n-                            Function::NonCaptureClosureAsFnPtr(fn_def) => {\n-                                let sig = self.erase_lifetimes(&fn_def.sig);\n-                                assert_eq!(sig.abi, Abi::RustCall);\n-                                if sig.variadic != bare_sig.variadic ||\n-                                    sig.inputs().len() != 1 {\n-                                    return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n-                                }\n-                                if let ty::TyTuple(fields, _) = sig.inputs()[0].sty {\n-                                    if **fields != *bare_sig.inputs() {\n-                                        return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n-                                    }\n-                                } else {\n-                                    return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n-                                }\n-                            },\n-                            other => return Err(EvalError::ExpectedConcreteFunction(other)),\n-                        }\n                         self.memory.get_fn(fn_ptr.alloc_id)?\n                     },\n-                    ty::TyFnDef(def_id, substs, fn_ty) => Function::Concrete(FunctionDefinition {\n-                        def_id,\n-                        substs,\n-                        sig: fn_ty,\n-                    }),\n-\n+                    ty::TyFnDef(def_id, substs, _) => ty::Instance::new(def_id, substs),\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func_ty);\n                         return Err(EvalError::Unimplemented(msg));\n@@ -112,19 +73,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.eval_fn_call(fn_def, destination, args, terminator.source_info.span)?;\n             }\n \n-            Drop { ref location, target, .. } => {\n-                let lval = self.eval_lvalue(location)?;\n-\n-                let ty = self.lvalue_ty(location);\n-\n-                // we can't generate the drop stack frames on the fly,\n-                // because that would change our call stack\n-                // and very much confuse the further processing of the drop glue\n-                let mut drops = Vec::new();\n-                self.drop(lval, ty, &mut drops)?;\n-                self.goto_block(target);\n-                self.eval_drop_impls(drops, terminator.source_info.span)?;\n-            }\n+            Drop { .. } => unreachable!(),\n \n             Assert { ref cond, expected, ref msg, target, .. } => {\n                 let cond_val = self.eval_operand_to_primval(cond)?.to_bool()?;\n@@ -158,155 +107,70 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn eval_fn_call(\n         &mut self,\n-        fn_def: Function<'tcx>,\n+        instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n     ) -> EvalResult<'tcx> {\n-        use syntax::abi::Abi;\n-        match fn_def {\n-            // Intrinsics can only be addressed directly\n-            Function::Concrete(FunctionDefinition { def_id, substs, sig }) if sig.abi() == Abi::RustIntrinsic => {\n+        let sig = match instance.def.def_ty(self.tcx).sty {\n+            ty::TyFnPtr(bare_sig) => bare_sig,\n+            ty::TyFnDef(_, _, fn_ty) => fn_ty,\n+            ref other => bug!(\"expected function or pointer, got {:?}\", other),\n+        };\n+        match sig.abi() {\n+            Abi::RustIntrinsic => {\n                 let sig = self.erase_lifetimes(&sig);\n                 let ty = sig.output();\n                 let layout = self.type_layout(ty)?;\n                 let (ret, target) = match destination {\n                     Some(dest) if is_inhabited(self.tcx, ty) => dest,\n                     _ => return Err(EvalError::Unreachable),\n                 };\n-                self.call_intrinsic(def_id, substs, arg_operands, ret, ty, layout, target)?;\n+                self.call_intrinsic(instance, arg_operands, ret, ty, layout, target)?;\n                 self.dump_local(ret);\n                 Ok(())\n             },\n-            // C functions can only be addressed directly\n-            Function::Concrete(FunctionDefinition { def_id, sig, ..}) if sig.abi() == Abi::C => {\n+            Abi::C => {\n                 let sig = self.erase_lifetimes(&sig);\n                 let ty = sig.output();\n                 let (ret, target) = destination.unwrap();\n-                self.call_c_abi(def_id, arg_operands, ret, ty)?;\n+                match instance.def {\n+                    ty::InstanceDef::Item(_) => {},\n+                    _ => bug!(\"C abi function must be InstanceDef::Item\"),\n+                }\n+                self.call_c_abi(instance.def_id(), arg_operands, ret, ty)?;\n                 self.dump_local(ret);\n                 self.goto_block(target);\n                 Ok(())\n             },\n-            Function::DropGlue(_) => Err(EvalError::ManuallyCalledDropGlue),\n-            Function::Concrete(FunctionDefinition { def_id, sig, substs }) if sig.abi() == Abi::Rust || sig.abi() == Abi::RustCall => {\n+            Abi::Rust | Abi::RustCall => {\n                 let mut args = Vec::new();\n                 for arg in arg_operands {\n                     let arg_val = self.eval_operand(arg)?;\n                     let arg_ty = self.operand_ty(arg);\n                     args.push((arg_val, arg_ty));\n                 }\n-\n-                // Only trait methods can have a Self parameter.\n-                let (resolved_def_id, resolved_substs, temporaries) =\n-                    if let Some(trait_id) = self.tcx.trait_of_item(def_id) {\n-                        self.trait_method(trait_id, def_id, substs, &mut args)?\n-                    } else {\n-                        (def_id, substs, Vec::new())\n-                    };\n-\n-                // FIXME(eddyb) Detect ADT constructors more efficiently.\n-                if let Some(adt_def) = sig.output().skip_binder().ty_adt_def() {\n-                    let dids = adt_def.variants.iter().map(|v| v.did);\n-                    let discrs = adt_def.discriminants(self.tcx).map(ConstInt::to_u128_unchecked);\n-                    if let Some((_, disr_val)) = dids.zip(discrs).find(|&(did, _)| resolved_def_id == did) {\n-                        let (lvalue, target) = destination.expect(\"tuple struct constructors can't diverge\");\n-                        let dest_ty = self.tcx.item_type(adt_def.did);\n-                        let dest_layout = self.type_layout(dest_ty)?;\n-                        trace!(\"layout({:?}) = {:#?}\", dest_ty, dest_layout);\n-                        match *dest_layout {\n-                            Layout::Univariant { .. } => {\n-                                assert_eq!(disr_val, 0);\n-                                self.assign_fields(lvalue, dest_ty, args)?;\n-                            },\n-                            Layout::General { discr, ref variants, .. } => {\n-                                let discr_size = discr.size().bytes();\n-                                self.assign_discr_and_fields(\n-                                    lvalue,\n-                                    dest_ty,\n-                                    variants[disr_val as usize].offsets[0].bytes(),\n-                                    args,\n-                                    disr_val,\n-                                    disr_val as usize,\n-                                    discr_size,\n-                                )?;\n-                            },\n-                            Layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n-                                if nndiscr as u128 == disr_val {\n-                                    self.assign_fields(lvalue, dest_ty, args)?;\n-                                } else {\n-                                    for (_, ty) in args {\n-                                        assert_eq!(self.type_size(ty)?, Some(0));\n-                                    }\n-                                    let (offset, ty) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n-\n-                                    // FIXME(solson)\n-                                    let dest = self.force_allocation(lvalue)?.to_ptr();\n-\n-                                    let dest = dest.offset(offset.bytes());\n-                                    let dest_size = self.type_size(ty)?\n-                                        .expect(\"bad StructWrappedNullablePointer discrfield\");\n-                                    self.memory.write_int(dest, 0, dest_size)?;\n-                                }\n-                            },\n-                            Layout::RawNullablePointer { .. } => {\n-                                assert_eq!(args.len(), 1);\n-                                let (val, ty) = args.pop().unwrap();\n-                                self.write_value(val, lvalue, ty)?;\n-                            },\n-                            _ => bug!(\"bad layout for tuple struct constructor: {:?}\", dest_layout),\n-                        }\n-                        self.goto_block(target);\n-                        return Ok(());\n-                    }\n-                }\n                 self.eval_fn_call_inner(\n-                    resolved_def_id,\n-                    resolved_substs,\n+                    instance,\n                     destination,\n                     args,\n-                    temporaries,\n                     span,\n                 )\n             },\n-            Function::NonCaptureClosureAsFnPtr(FunctionDefinition { def_id, substs, sig }) if sig.abi() == Abi::RustCall => {\n-                let sig = self.erase_lifetimes(&sig);\n-                let mut args = Vec::new();\n-                for arg in arg_operands {\n-                    let arg_val = self.eval_operand(arg)?;\n-                    let arg_ty = self.operand_ty(arg);\n-                    args.push((arg_val, arg_ty));\n-                }\n-                args.insert(0, (\n-                    Value::ByVal(PrimVal::Undef),\n-                    sig.inputs()[0],\n-                ));\n-                self.eval_fn_call_inner(\n-                    def_id,\n-                    substs,\n-                    destination,\n-                    args,\n-                    Vec::new(),\n-                    span,\n-                )\n-            }\n-            Function::Concrete(fn_def) => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", fn_def.sig.abi()))),\n-            other => Err(EvalError::Unimplemented(format!(\"can't call function kind {:#?}\", other))),\n+            other => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", other))),\n         }\n     }\n \n     fn eval_fn_call_inner(\n         &mut self,\n-        resolved_def_id: DefId,\n-        resolved_substs: &'tcx Substs,\n+        instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n         args: Vec<(Value, Ty<'tcx>)>,\n-        temporaries: Vec<(Pointer, Ty<'tcx>)>,\n         span: Span,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"eval_fn_call_inner: {:#?}, {:#?}, {:#?}\", args, temporaries, destination);\n+        trace!(\"eval_fn_call_inner: {:#?}, {:#?}\", args, destination);\n \n-        let mir = match self.load_mir(resolved_def_id) {\n+        let mir = match self.load_mir(instance.def) {\n             Ok(mir) => mir,\n             Err(EvalError::NoMirFor(path)) => {\n                 match &path[..] {\n@@ -344,13 +208,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         };\n \n         self.push_stack_frame(\n-            resolved_def_id,\n+            instance,\n             span,\n             mir,\n-            resolved_substs,\n             return_lvalue,\n             return_to_block,\n-            temporaries,\n         )?;\n \n         let arg_locals = self.frame().mir.args_iter();\n@@ -530,33 +392,4 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // current frame.\n         Ok(())\n     }\n-\n-    pub(crate) fn unpack_fn_args(&self, args: &mut Vec<(Value, Ty<'tcx>)>) -> EvalResult<'tcx> {\n-        if let Some((last, last_ty)) = args.pop() {\n-            let last_layout = self.type_layout(last_ty)?;\n-            match (&last_ty.sty, last_layout) {\n-                (&ty::TyTuple(fields, _),\n-                 &Layout::Univariant { ref variant, .. }) => {\n-                    let offsets = variant.offsets.iter().map(|s| s.bytes());\n-                    match last {\n-                        Value::ByRef(last_ptr) => {\n-                            for (offset, ty) in offsets.zip(fields) {\n-                                let arg = Value::ByRef(last_ptr.offset(offset));\n-                                args.push((arg, ty));\n-                            }\n-                        },\n-                        // propagate undefs\n-                        undef @ Value::ByVal(PrimVal::Undef) => {\n-                            for field_ty in fields {\n-                                args.push((undef, field_ty));\n-                            }\n-                        },\n-                        _ => bug!(\"rust-call ABI tuple argument was {:?}, but {:?} were expected\", last, fields),\n-                    }\n-                }\n-                ty => bug!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n-            }\n-        }\n-        Ok(())\n-    }\n }"}, {"sha": "74cb6966c067badda12aeff3448e81496482f68a", "filename": "src/traits.rs", "status": "modified", "additions": 26, "deletions": 236, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=dc1b0fb436da6d7e391e14b3a98cd5f96b2726bb", "patch": "@@ -8,171 +8,11 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use syntax::codemap::DUMMY_SP;\n-use syntax::{ast, abi};\n+use syntax::ast;\n \n-use error::{EvalError, EvalResult};\n-use memory::Function;\n-use value::PrimVal;\n-use value::Value;\n+use error::EvalResult;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    /// Trait method, which has to be resolved to an impl method.\n-    pub(crate) fn trait_method(\n-        &mut self,\n-        trait_id: DefId,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n-        args: &mut Vec<(Value, Ty<'tcx>)>,\n-    ) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>, Vec<(Pointer, Ty<'tcx>)>)> {\n-        let trait_ref = ty::TraitRef::from_method(self.tcx, trait_id, substs);\n-        let trait_ref = self.tcx.normalize_associated_type(&ty::Binder(trait_ref));\n-\n-        match self.fulfill_obligation(trait_ref) {\n-            traits::VtableImpl(vtable_impl) => {\n-                let impl_did = vtable_impl.impl_def_id;\n-                let mname = self.tcx.item_name(def_id);\n-                // Create a concatenated set of substitutions which includes those from the impl\n-                // and those from the method:\n-                let (did, substs) = find_method(self.tcx, substs, impl_did, vtable_impl.substs, mname);\n-\n-                Ok((did, substs, Vec::new()))\n-            }\n-\n-            traits::VtableClosure(vtable_closure) => {\n-                let trait_closure_kind = self.tcx\n-                    .lang_items\n-                    .fn_trait_kind(trait_id)\n-                    .expect(\"The substitutions should have no type parameters remaining after passing through fulfill_obligation\");\n-                let closure_kind = self.tcx.closure_kind(vtable_closure.closure_def_id);\n-                trace!(\"closures {:?}, {:?}\", closure_kind, trait_closure_kind);\n-                self.unpack_fn_args(args)?;\n-                let mut temporaries = Vec::new();\n-                match (closure_kind, trait_closure_kind) {\n-                    (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n-                    (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n-                    (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) |\n-                    (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {} // No adapter needed.\n-\n-                    (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n-                    (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n-                        // The closure fn is a `fn(&self, ...)` or `fn(&mut self, ...)`.\n-                        // We want a `fn(self, ...)`.\n-                        // We can produce this by doing something like:\n-                        //\n-                        //     fn call_once(self, ...) { call_mut(&self, ...) }\n-                        //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n-                        //\n-                        // These are both the same at trans time.\n-\n-                        // Interpreter magic: insert an intermediate pointer, so we can skip the\n-                        // intermediate function call.\n-                        let ptr = match args[0].0 {\n-                            Value::ByRef(ptr) => ptr,\n-                            Value::ByVal(primval) => {\n-                                let ptr = self.alloc_ptr(args[0].1)?;\n-                                let size = self.type_size(args[0].1)?.expect(\"closures are sized\");\n-                                self.memory.write_primval(ptr, primval, size)?;\n-                                ptr\n-                            },\n-                            Value::ByValPair(a, b) => {\n-                                let ptr = self.alloc_ptr(args[0].1)?;\n-                                self.write_pair_to_ptr(a, b, ptr, args[0].1)?;\n-                                ptr\n-                            },\n-                        };\n-                        temporaries.push((ptr, args[0].1));\n-                        args[0].0 = Value::ByVal(PrimVal::Ptr(ptr));\n-                        args[0].1 = self.tcx.mk_mut_ptr(args[0].1);\n-                    }\n-\n-                    _ => bug!(\"cannot convert {:?} to {:?}\", closure_kind, trait_closure_kind),\n-                }\n-                Ok((vtable_closure.closure_def_id, vtable_closure.substs.substs, temporaries))\n-            }\n-\n-            traits::VtableFnPointer(vtable_fn_ptr) => {\n-                if let ty::TyFnDef(did, substs, _) = vtable_fn_ptr.fn_ty.sty {\n-                    args.remove(0);\n-                    self.unpack_fn_args(args)?;\n-                    Ok((did, substs, Vec::new()))\n-                } else {\n-                    bug!(\"VtableFnPointer did not contain a concrete function: {:?}\", vtable_fn_ptr)\n-                }\n-            }\n-\n-            traits::VtableObject(ref data) => {\n-                let idx = self.tcx.get_vtable_index_of_object_method(data, def_id) as u64;\n-                if args.is_empty() {\n-                    return Err(EvalError::VtableForArgumentlessMethod);\n-                }\n-                let (self_ptr, vtable) = args[0].0.expect_ptr_vtable_pair(&self.memory)?;\n-                let idx = idx + 3;\n-                let offset = idx * self.memory.pointer_size();\n-                let fn_ptr = self.memory.read_ptr(vtable.offset(offset))?;\n-                trace!(\"args: {:#?}\", args);\n-                match self.memory.get_fn(fn_ptr.alloc_id)? {\n-                    Function::FnDefAsTraitObject(fn_def) => {\n-                        trace!(\"sig: {:#?}\", fn_def.sig);\n-                        assert!(fn_def.sig.abi() != abi::Abi::RustCall);\n-                        assert_eq!(args.len(), 2);\n-                        // a function item turned into a closure trait object\n-                        // the first arg is just there to give use the vtable\n-                        args.remove(0);\n-                        self.unpack_fn_args(args)?;\n-                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n-                    },\n-                    Function::DropGlue(_) => Err(EvalError::ManuallyCalledDropGlue),\n-                    Function::Concrete(fn_def) => {\n-                        let sig = self.erase_lifetimes(&fn_def.sig);\n-                        trace!(\"sig: {:#?}\", sig);\n-                        args[0] = (\n-                            Value::ByVal(PrimVal::Ptr(self_ptr)),\n-                            sig.inputs()[0],\n-                        );\n-                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n-                    },\n-                    Function::NonCaptureClosureAsFnPtr(fn_def) => {\n-                        let sig = self.erase_lifetimes(&fn_def.sig);\n-                        args.insert(0, (\n-                            Value::ByVal(PrimVal::Undef),\n-                            sig.inputs()[0],\n-                        ));\n-                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n-                    }\n-                    Function::Closure(fn_def) => {\n-                        self.unpack_fn_args(args)?;\n-                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n-                    }\n-                    Function::FnPtrAsTraitObject(sig) => {\n-                        let sig = self.erase_lifetimes(&sig);\n-                        trace!(\"sig: {:#?}\", sig);\n-                        // the first argument was the fat ptr\n-                        args.remove(0);\n-                        self.unpack_fn_args(args)?;\n-                        let fn_ptr = self.memory.read_ptr(self_ptr)?;\n-                        let fn_def = match self.memory.get_fn(fn_ptr.alloc_id)? {\n-                            Function::Concrete(fn_def) => {\n-                                let fn_def_sig = self.erase_lifetimes(&fn_def.sig);\n-                                assert_eq!(sig, fn_def_sig);\n-                                fn_def\n-                            },\n-                            Function::NonCaptureClosureAsFnPtr(fn_def) => {\n-                                let fn_def_sig = self.erase_lifetimes(&fn_def.sig);\n-                                args.insert(0, (\n-                                    Value::ByVal(PrimVal::Undef),\n-                                    fn_def_sig.inputs()[0],\n-                                ));\n-                                fn_def\n-                            },\n-                            other => bug!(\"FnPtrAsTraitObject for {:?}\", other),\n-                        };\n-                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n-                    }\n-                }\n-            },\n-            vtable => bug!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n-        }\n-    }\n \n     pub(crate) fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n         // Do the initial selection for the obligation. This yields the shallow result we are\n@@ -202,7 +42,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     /// The `trait_ref` encodes the erased self type. Hence if we are\n     /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n     /// `trait_ref` would map `T:Trait`.\n-    pub fn get_vtable(&mut self, trait_ref: ty::PolyTraitRef<'tcx>) -> EvalResult<'tcx, Pointer> {\n+    pub fn get_vtable(&mut self, ty: Ty<'tcx>, trait_ref: ty::PolyTraitRef<'tcx>) -> EvalResult<'tcx, Pointer> {\n         let tcx = self.tcx;\n \n         debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n@@ -219,13 +59,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     self.get_vtable_methods(id, substs)\n                         .into_iter()\n                         .map(|opt_mth| opt_mth.map(|mth| {\n-                            let fn_ty = self.tcx.item_type(mth.method.def_id);\n-                            let fn_ty = match fn_ty.sty {\n-                                ty::TyFnDef(_, _, fn_ty) => fn_ty,\n-                                _ => bug!(\"bad function type: {}\", fn_ty),\n-                            };\n-                            let fn_ty = self.tcx.erase_regions(&fn_ty);\n-                            self.memory.create_fn_ptr(mth.method.def_id, mth.substs, fn_ty)\n+                            self.memory.create_fn_ptr(mth.method.def_id, mth.substs)\n                         }))\n                         .collect::<Vec<_>>()\n                         .into_iter()\n@@ -238,18 +72,22 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         ..\n                     }\n                 ) => {\n-                    let closure_type = self.tcx.closure_type(closure_def_id);\n-                    vec![Some(self.memory.create_closure_ptr(closure_def_id, substs, closure_type))].into_iter()\n+                    let instance = ::eval_context::resolve_closure(self.tcx, closure_def_id, substs, ty::ClosureKind::FnOnce);\n+                    vec![Some(self.memory.create_fn_alloc(instance))].into_iter()\n                 }\n \n                 // turn a function definition into a Fn trait object\n                 traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, .. }) => {\n                     match fn_ty.sty {\n-                        ty::TyFnDef(did, substs, bare_fn_ty) => {\n-                            vec![Some(self.memory.create_fn_as_trait_glue(did, substs, bare_fn_ty))].into_iter()\n+                        ty::TyFnDef(did, substs, _) => {\n+                            let instance = ty::Instance {\n+                                def: ty::InstanceDef::FnPtrShim(did, fn_ty),\n+                                substs,\n+                            };\n+                            vec![Some(self.memory.create_fn_alloc(instance))].into_iter()\n                         },\n-                        ty::TyFnPtr(bare_fn_ty) => {\n-                            vec![Some(self.memory.create_fn_ptr_as_trait_glue(bare_fn_ty))].into_iter()\n+                        ty::TyFnPtr(_) => {\n+                            unimplemented!();\n                         },\n                         _ => bug!(\"bad VtableFnPointer fn_ty: {:#?}\", fn_ty.sty),\n                     }\n@@ -279,19 +117,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         // in case there is no drop function to be called, this still needs to be initialized\n         self.memory.write_usize(vtable, 0)?;\n+        let drop_in_place = self.tcx.lang_items.drop_in_place_fn().expect(\"drop_in_place lang item not available\");\n         if let ty::TyAdt(adt_def, substs) = trait_ref.self_ty().sty {\n-            if let Some(destructor) = adt_def.destructor(self.tcx) {\n-                let fn_ty = match self.tcx.item_type(destructor.did).sty {\n-                    ty::TyFnDef(_, _, fn_ty) => self.tcx.erase_regions(&fn_ty),\n-                    _ => bug!(\"drop method is not a TyFnDef\"),\n-                };\n-                let fn_ty = self.erase_lifetimes(&fn_ty);\n-                // The real type is taken from the self argument in `fn drop(&mut self)`\n-                let real_ty = match fn_ty.inputs()[0].sty {\n-                    ty::TyRef(_, mt) => self.monomorphize(mt.ty, substs),\n-                    _ => bug!(\"first argument of Drop::drop must be &mut T\"),\n+            if adt_def.has_dtor(self.tcx) {\n+                let env = self.tcx.empty_parameter_environment();\n+                let def = if self.tcx.type_needs_drop_given_env(ty, &env) {\n+                    ty::InstanceDef::DropGlue(drop_in_place, Some(ty))\n+                } else {\n+                    ty::InstanceDef::DropGlue(drop_in_place, None)\n                 };\n-                let fn_ptr = self.memory.create_drop_glue(real_ty);\n+                let instance = ty::Instance { substs, def };\n+                let fn_ptr = self.memory.create_fn_alloc(instance);\n                 self.memory.write_ptr(vtable, fn_ptr)?;\n             }\n         }\n@@ -310,20 +146,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(vtable)\n     }\n \n-    pub fn read_drop_type_from_vtable(&self, vtable: Pointer) -> EvalResult<'tcx, Option<Ty<'tcx>>> {\n-        let drop_fn = self.memory.read_ptr(vtable)?;\n-\n-        // just a sanity check\n-        assert_eq!(drop_fn.offset, 0);\n-\n-        // some values don't need to call a drop impl, so the value is null\n-        if drop_fn == Pointer::from_int(0) {\n-            Ok(None)\n-        } else {\n-            self.memory.get_fn(drop_fn.alloc_id)?.expect_drop_glue_real_ty().map(Some)\n-        }\n-    }\n-\n     pub fn read_size_and_align_from_vtable(&self, vtable: Pointer) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n         let size = self.memory.read_usize(vtable.offset(pointer_size))?;\n@@ -423,7 +245,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &self,\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n-    ) -> (DefId, &'tcx Substs<'tcx>) {\n+    ) -> ty::Instance<'tcx> {\n         if let Some(trait_id) = self.tcx.trait_of_item(def_id) {\n             let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, substs));\n             let vtable = self.fulfill_obligation(trait_ref);\n@@ -432,11 +254,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let assoc_const_opt = self.tcx.associated_items(vtable_impl.impl_def_id)\n                     .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n                 if let Some(assoc_const) = assoc_const_opt {\n-                    return (assoc_const.def_id, vtable_impl.substs);\n+                    return ty::Instance::new(assoc_const.def_id, vtable_impl.substs);\n                 }\n             }\n         }\n-        (def_id, substs)\n+        ty::Instance::new(def_id, substs)\n     }\n }\n \n@@ -483,35 +305,3 @@ pub(super) fn get_impl_method<'a, 'tcx>(\n         }\n     }\n }\n-\n-/// Locates the applicable definition of a method, given its name.\n-pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             substs: &'tcx Substs<'tcx>,\n-                             impl_def_id: DefId,\n-                             impl_substs: &'tcx Substs<'tcx>,\n-                             name: ast::Name)\n-                             -> (DefId, &'tcx Substs<'tcx>)\n-{\n-    assert!(!substs.needs_infer());\n-\n-    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-\n-    match trait_def.ancestors(impl_def_id).defs(tcx, name, ty::AssociatedKind::Method).next() {\n-        Some(node_item) => {\n-            let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-                let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n-                let substs = traits::translate_substs(&infcx, impl_def_id, substs, node_item.node);\n-                tcx.lift(&substs).unwrap_or_else(|| {\n-                    bug!(\"find_method: translate_substs \\\n-                          returned {:?} which contains inference types/regions\",\n-                         substs);\n-                })\n-            });\n-            (node_item.item.def_id, substs)\n-        }\n-        None => {\n-            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n-        }\n-    }\n-}"}]}