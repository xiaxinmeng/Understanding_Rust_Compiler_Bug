{"sha": "8fd40db4bc6148b146da5160202671a57d9db82e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZDQwZGI0YmM2MTQ4YjE0NmRhNTE2MDIwMjY3MWE1N2Q5ZGI4MmU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-21T15:22:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-21T15:22:39Z"}, "message": "Merge pull request #708 from RalfJung/alloc-tests\n\ntest System/Global allocator API: alloc_zeroed, realloc", "tree": {"sha": "102924206dd5b15f48ab03cc3843ed790eff258d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/102924206dd5b15f48ab03cc3843ed790eff258d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fd40db4bc6148b146da5160202671a57d9db82e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcvIq/CRBK7hj4Ov3rIwAAdHIIADO7+x0uhr5gz4kaZ88FREYC\nIJ5t9tiWgYQMTi4hapEX9cPqIb70xKMZhMteNFdiMbE5Xde9BYQvuFit2hX/LeRN\nqJBHF2nLW4gMtzPDgRNUFDHYhZwNXf0zLOT2ZZRiYfBicErG6gkCsCcY7+deNGQq\nSG1XIwrtbZRHXCZselbYeBiZYDB2S9H3JMOi3S/pICaV+FWtFWnN7hLBZsCZ/ELb\nGfoxQ7Qu78DCW1cgFDjdSgqkWSIJVnK7H/fgz7zl1DYfAbWUOJK9YBt1YHj+zWHA\ngBSz6gs71upt/1a9Z1gAuvlOUH7rHDNwnpl8tsjizA5b5IY/fZ+gqe8v1d8zsVA=\n=ZxyZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 102924206dd5b15f48ab03cc3843ed790eff258d\nparent 788616d0f010fd7307ffe3b19d19415bae7782ed\nparent e4970fe6ffa3052d6b1a880c934d4465bf656df9\nauthor Ralf Jung <post@ralfj.de> 1555860159 +0200\ncommitter GitHub <noreply@github.com> 1555860159 +0200\n\nMerge pull request #708 from RalfJung/alloc-tests\n\ntest System/Global allocator API: alloc_zeroed, realloc"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fd40db4bc6148b146da5160202671a57d9db82e", "html_url": "https://github.com/rust-lang/rust/commit/8fd40db4bc6148b146da5160202671a57d9db82e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fd40db4bc6148b146da5160202671a57d9db82e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "788616d0f010fd7307ffe3b19d19415bae7782ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/788616d0f010fd7307ffe3b19d19415bae7782ed", "html_url": "https://github.com/rust-lang/rust/commit/788616d0f010fd7307ffe3b19d19415bae7782ed"}, {"sha": "e4970fe6ffa3052d6b1a880c934d4465bf656df9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4970fe6ffa3052d6b1a880c934d4465bf656df9", "html_url": "https://github.com/rust-lang/rust/commit/e4970fe6ffa3052d6b1a880c934d4465bf656df9"}], "stats": {"total": 219, "additions": 150, "deletions": 69}, "files": [{"sha": "9789a76c6393eabbd4959f748abe4d8d3bb09718", "filename": "src/fn_call.rs", "status": "modified", "additions": 117, "deletions": 61, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/8fd40db4bc6148b146da5160202671a57d9db82e/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd40db4bc6148b146da5160202671a57d9db82e/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=8fd40db4bc6148b146da5160202671a57d9db82e", "patch": "@@ -50,6 +50,86 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         Ok(Some(this.load_mir(instance.def)?))\n     }\n \n+    fn malloc(\n+        &mut self,\n+        size: u64,\n+        zero_init: bool,\n+    ) -> Scalar<Tag> {\n+        let this = self.eval_context_mut();\n+        let tcx = &{this.tcx.tcx};\n+        if size == 0 {\n+            Scalar::from_int(0, this.pointer_size())\n+        } else {\n+            let align = this.tcx.data_layout.pointer_align.abi;\n+            let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into());\n+            if zero_init {\n+                // We just allocated this, the access cannot fail\n+                this.memory_mut()\n+                    .get_mut(ptr.alloc_id).unwrap()\n+                    .write_repeat(tcx, ptr, 0, Size::from_bytes(size)).unwrap();\n+            }\n+            Scalar::Ptr(ptr)\n+        }\n+    }\n+\n+    fn free(\n+        &mut self,\n+        ptr: Scalar<Tag>,\n+    ) -> EvalResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        if !ptr.is_null_ptr(this) {\n+            this.memory_mut().deallocate(\n+                ptr.to_ptr()?,\n+                None,\n+                MiriMemoryKind::C.into(),\n+            )?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn realloc(\n+        &mut self,\n+        old_ptr: Scalar<Tag>,\n+        new_size: u64,\n+    ) -> EvalResult<'tcx, Scalar<Tag>> {\n+        let this = self.eval_context_mut();\n+        let align = this.tcx.data_layout.pointer_align.abi;\n+        if old_ptr.is_null_ptr(this) {\n+            if new_size == 0 {\n+                Ok(Scalar::from_int(0, this.pointer_size()))\n+            } else {\n+                let new_ptr = this.memory_mut().allocate(\n+                    Size::from_bytes(new_size),\n+                    align,\n+                    MiriMemoryKind::C.into()\n+                );\n+                Ok(Scalar::Ptr(new_ptr))\n+            }\n+        } else {\n+            let old_ptr = old_ptr.to_ptr()?;\n+            let memory = this.memory_mut();\n+            let old_size = Size::from_bytes(memory.get(old_ptr.alloc_id)?.bytes.len() as u64);\n+            if new_size == 0 {\n+                memory.deallocate(\n+                    old_ptr,\n+                    Some((old_size, align)),\n+                    MiriMemoryKind::C.into(),\n+                )?;\n+                Ok(Scalar::from_int(0, this.pointer_size()))\n+            } else {\n+                let new_ptr = memory.reallocate(\n+                    old_ptr,\n+                    old_size,\n+                    align,\n+                    Size::from_bytes(new_size),\n+                    align,\n+                    MiriMemoryKind::C.into(),\n+                )?;\n+                Ok(Scalar::Ptr(new_ptr))\n+            }\n+        }\n+    }\n+\n     /// Emulates calling a foreign item, failing if the item is not supported.\n     /// This function will handle `goto_block` if needed.\n     fn emulate_foreign_item(\n@@ -87,28 +167,15 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         match link_name {\n             \"malloc\" => {\n                 let size = this.read_scalar(args[0])?.to_usize(this)?;\n-                if size == 0 {\n-                    this.write_null(dest)?;\n-                } else {\n-                    let align = this.tcx.data_layout.pointer_align.abi;\n-                    let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into());\n-                    this.write_scalar(Scalar::Ptr(ptr), dest)?;\n-                }\n+                let res = this.malloc(size, /*zero_init:*/ false);\n+                this.write_scalar(res, dest)?;\n             }\n             \"calloc\" => {\n                 let items = this.read_scalar(args[0])?.to_usize(this)?;\n                 let len = this.read_scalar(args[1])?.to_usize(this)?;\n-                let bytes = items.checked_mul(len).ok_or_else(|| InterpError::Overflow(mir::BinOp::Mul))?;\n-\n-                if bytes == 0 {\n-                    this.write_null(dest)?;\n-                } else {\n-                    let size = Size::from_bytes(bytes);\n-                    let align = this.tcx.data_layout.pointer_align.abi;\n-                    let ptr = this.memory_mut().allocate(size, align, MiriMemoryKind::C.into());\n-                    this.memory_mut().get_mut(ptr.alloc_id)?.write_repeat(tcx, ptr, 0, size)?;\n-                    this.write_scalar(Scalar::Ptr(ptr), dest)?;\n-                }\n+                let size = items.checked_mul(len).ok_or_else(|| InterpError::Overflow(mir::BinOp::Mul))?;\n+                let res = this.malloc(size, /*zero_init:*/ true);\n+                this.write_scalar(res, dest)?;\n             }\n             \"posix_memalign\" => {\n                 let ret = this.deref_operand(args[0])?;\n@@ -136,55 +203,15 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n                 }\n                 this.write_null(dest)?;\n             }\n-\n             \"free\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                if !ptr.is_null_ptr(this) {\n-                    this.memory_mut().deallocate(\n-                        ptr.to_ptr()?,\n-                        None,\n-                        MiriMemoryKind::C.into(),\n-                    )?;\n-                }\n+                this.free(ptr)?;\n             }\n             \"realloc\" => {\n                 let old_ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let new_size = this.read_scalar(args[1])?.to_usize(this)?;\n-                let align = this.tcx.data_layout.pointer_align.abi;\n-                if old_ptr.is_null_ptr(this) {\n-                    if new_size == 0 {\n-                        this.write_null(dest)?;\n-                    } else {\n-                        let new_ptr = this.memory_mut().allocate(\n-                            Size::from_bytes(new_size),\n-                            align,\n-                            MiriMemoryKind::C.into()\n-                        );\n-                        this.write_scalar(Scalar::Ptr(new_ptr), dest)?;\n-                    }\n-                } else {\n-                    let old_ptr = old_ptr.to_ptr()?;\n-                    let memory = this.memory_mut();\n-                    let old_size = Size::from_bytes(memory.get(old_ptr.alloc_id)?.bytes.len() as u64);\n-                    if new_size == 0 {\n-                        memory.deallocate(\n-                            old_ptr,\n-                            Some((old_size, align)),\n-                            MiriMemoryKind::C.into(),\n-                        )?;\n-                        this.write_null(dest)?;\n-                    } else {\n-                        let new_ptr = memory.reallocate(\n-                            old_ptr,\n-                            old_size,\n-                            align,\n-                            Size::from_bytes(new_size),\n-                            align,\n-                            MiriMemoryKind::C.into(),\n-                        )?;\n-                        this.write_scalar(Scalar::Ptr(new_ptr), dest)?;\n-                    }\n-                }\n+                let res = this.realloc(old_ptr, new_size)?;\n+                this.write_scalar(res, dest)?;\n             }\n \n             \"__rust_alloc\" => {\n@@ -687,6 +714,35 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n             },\n \n             // Windows API stubs.\n+            // HANDLE = isize\n+            // DWORD = ULONG = u32\n+            \"GetProcessHeap\" => {\n+                // Just fake a HANDLE\n+                this.write_scalar(Scalar::from_int(1, this.pointer_size()), dest)?;\n+            }\n+            \"HeapAlloc\" => {\n+                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let flags = this.read_scalar(args[1])?.to_u32()?;\n+                let size = this.read_scalar(args[2])?.to_usize(this)?;\n+                let zero_init = (flags & 0x00000008) != 0; // HEAP_ZERO_MEMORY\n+                let res = this.malloc(size, zero_init);\n+                this.write_scalar(res, dest)?;\n+            }\n+            \"HeapFree\" => {\n+                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let _flags = this.read_scalar(args[1])?.to_u32()?;\n+                let ptr = this.read_scalar(args[2])?.not_undef()?;\n+                this.free(ptr)?;\n+            }\n+            \"HeapReAlloc\" => {\n+                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let _flags = this.read_scalar(args[1])?.to_u32()?;\n+                let ptr = this.read_scalar(args[2])?.not_undef()?;\n+                let size = this.read_scalar(args[3])?.to_usize(this)?;\n+                let res = this.realloc(ptr, size)?;\n+                this.write_scalar(res, dest)?;\n+            }\n+\n             \"SetLastError\" => {\n                 let err = this.read_scalar(args[0])?.to_u32()?;\n                 this.machine.last_error = err;"}, {"sha": "91e15f249d452dc4539431464549ebc974766afb", "filename": "tests/run-pass/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd40db4bc6148b146da5160202671a57d9db82e/tests%2Frun-pass%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd40db4bc6148b146da5160202671a57d9db82e/tests%2Frun-pass%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fenv.rs?ref=8fd40db4bc6148b146da5160202671a57d9db82e", "patch": "@@ -1,4 +1,4 @@\n-//ignore-windows: env var emulation not implemented on Windows\n+//ignore-windows: TODO env var emulation stubbed out on Windows\n \n use std::env;\n "}, {"sha": "25a816bcf2454df0d074259e3aaafcffe7ba43e6", "filename": "tests/run-pass/hashmap.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8fd40db4bc6148b146da5160202671a57d9db82e/tests%2Frun-pass%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd40db4bc6148b146da5160202671a57d9db82e/tests%2Frun-pass%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fhashmap.rs?ref=8fd40db4bc6148b146da5160202671a57d9db82e", "patch": "@@ -27,13 +27,12 @@ fn test_map<S: BuildHasher>(mut map: HashMap<i32, i32, S>) {\n }\n \n fn main() {\n-    if cfg!(not(target_os = \"macos\")) {\n-        let map: HashMap<i32, i32> = HashMap::default();\n-        test_map(map);\n-    } else {\n-        // TODO: Implement random number generation on OS X.\n+    if cfg!(target_os = \"macos\") { // TODO: Implement random number generation on OS X.\n         // Until then, use a deterministic map.\n         let map : HashMap<i32, i32, BuildHasherDefault<collections::hash_map::DefaultHasher>> = HashMap::default();\n         test_map(map);\n+    } else {\n+        let map: HashMap<i32, i32> = HashMap::default();\n+        test_map(map);\n     }\n }"}, {"sha": "b201f24e25634b37c2fc2d2b73c047c32928f617", "filename": "tests/run-pass/heap_allocator.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8fd40db4bc6148b146da5160202671a57d9db82e/tests%2Frun-pass%2Fheap_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd40db4bc6148b146da5160202671a57d9db82e/tests%2Frun-pass%2Fheap_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fheap_allocator.rs?ref=8fd40db4bc6148b146da5160202671a57d9db82e", "patch": "@@ -1,9 +1,32 @@\n-//ignore-windows: inspects allocation base address on Windows\n-\n #![feature(allocator_api)]\n \n use std::ptr::NonNull;\n use std::alloc::{Global, Alloc, Layout, System};\n+use std::slice;\n+\n+fn check_alloc<T: Alloc>(mut allocator: T) { unsafe {\n+    let layout = Layout::from_size_align(20, 4).unwrap();\n+    let a = allocator.alloc(layout).unwrap();\n+    allocator.dealloc(a, layout);\n+\n+    let p1 = allocator.alloc_zeroed(layout).unwrap();\n+\n+    let p2 = allocator.realloc(p1, Layout::from_size_align(20, 4).unwrap(), 40).unwrap();\n+    let slice = slice::from_raw_parts(p2.as_ptr(), 20);\n+    assert_eq!(&slice, &[0_u8; 20]);\n+\n+    // old size == new size\n+    let p3 = allocator.realloc(p2, Layout::from_size_align(40, 4).unwrap(), 40).unwrap();\n+    let slice = slice::from_raw_parts(p3.as_ptr(), 20);\n+    assert_eq!(&slice, &[0_u8; 20]);\n+\n+    // old size > new size\n+    let p4 = allocator.realloc(p3, Layout::from_size_align(40, 4).unwrap(), 10).unwrap();\n+    let slice = slice::from_raw_parts(p4.as_ptr(), 10);\n+    assert_eq!(&slice, &[0_u8; 10]);\n+\n+    allocator.dealloc(p4, Layout::from_size_align(10, 4).unwrap());\n+} }\n \n fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n     let size = 8;\n@@ -50,6 +73,9 @@ fn box_to_global() {\n }\n \n fn main() {\n+    check_alloc(System);\n+    check_alloc(Global);\n+    #[cfg(not(target_os = \"windows\"))] // TODO: Inspects allocation base address on Windows; needs intptrcast model\n     check_overalign_requests(System);\n     check_overalign_requests(Global);\n     global_to_box();"}]}