{"sha": "dd08c30703d052205a68ae34331eea464178cd99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMDhjMzA3MDNkMDUyMjA1YTY4YWUzNDMzMWVlYTQ2NDE3OGNkOTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-12T18:12:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-12T18:12:21Z"}, "message": "Auto merge of #44133 - vorner:allocator-kind-autodetect, r=alexcrichton\n\nAutodetect the type of allocator crate used\n\nAnnotate the allocator crates (allocator_system, allocator_jemalloc) by the type of allocator they are. If one is requested as an exe allocator, detect its type by the flags.\n\nThis has the effect that using this (de jure wrong) configuration in the target spec works instead of producing a really unhelpful and arcane linker error:\n\n\"exe-allocation-crate\": \"alloc_system\"\n\nFixes #43524.\n\nThere are two yet unsolved FIXME's, I'll be glad for some advice on what to do with them.", "tree": {"sha": "19df045809158d1b422468393327e0c79e3fd145", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19df045809158d1b422468393327e0c79e3fd145"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd08c30703d052205a68ae34331eea464178cd99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd08c30703d052205a68ae34331eea464178cd99", "html_url": "https://github.com/rust-lang/rust/commit/dd08c30703d052205a68ae34331eea464178cd99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd08c30703d052205a68ae34331eea464178cd99/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7b7dce02da1b10f6da79b2f2e93a73314faf497", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7b7dce02da1b10f6da79b2f2e93a73314faf497", "html_url": "https://github.com/rust-lang/rust/commit/a7b7dce02da1b10f6da79b2f2e93a73314faf497"}, {"sha": "94297c67465c3bd124063de717f7574491f5cc7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/94297c67465c3bd124063de717f7574491f5cc7d", "html_url": "https://github.com/rust-lang/rust/commit/94297c67465c3bd124063de717f7574491f5cc7d"}], "stats": {"total": 105, "additions": 69, "deletions": 36}, "files": [{"sha": "d153f19c4622f021d78dee45d2453b22b10dc9a5", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd08c30703d052205a68ae34331eea464178cd99/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd08c30703d052205a68ae34331eea464178cd99/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=dd08c30703d052205a68ae34331eea464178cd99", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![no_std]\n+#![allow(unused_attributes)]\n #![unstable(feature = \"alloc_jemalloc\",\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\",\n@@ -19,8 +20,10 @@\n #![feature(libc)]\n #![feature(linkage)]\n #![feature(staged_api)]\n+#![feature(rustc_attrs)]\n #![cfg_attr(dummy_jemalloc, allow(dead_code, unused_extern_crates))]\n #![cfg_attr(not(dummy_jemalloc), feature(allocator_api))]\n+#![rustc_alloc_kind = \"exe\"]\n \n extern crate alloc;\n extern crate alloc_system;"}, {"sha": "2eb659699eb9b4839c3615c41c99d47686c6cb22", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd08c30703d052205a68ae34331eea464178cd99/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd08c30703d052205a68ae34331eea464178cd99/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=dd08c30703d052205a68ae34331eea464178cd99", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![no_std]\n+#![allow(unused_attributes)]\n #![deny(warnings)]\n #![unstable(feature = \"alloc_system\",\n             reason = \"this library is unlikely to be stabilized in its current \\\n@@ -19,7 +20,9 @@\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(staged_api)]\n+#![feature(rustc_attrs)]\n #![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]\n+#![rustc_alloc_kind = \"lib\"]\n \n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values. In practice, the alignment is a"}, {"sha": "dc6c260ec7174abdeab0d398c3f9586794609d19", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 63, "deletions": 36, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/dd08c30703d052205a68ae34331eea464178cd99/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd08c30703d052205a68ae34331eea464178cd99/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=dd08c30703d052205a68ae34331eea464178cd99", "patch": "@@ -15,7 +15,7 @@ use locator::{self, CratePaths};\n use native_libs::relevant_lib;\n use schema::CrateRoot;\n \n-use rustc::hir::def_id::{CrateNum, DefIndex};\n+use rustc::hir::def_id::{CrateNum, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::svh::Svh;\n use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::DepKind;\n@@ -944,53 +944,80 @@ impl<'a> CrateLoader<'a> {\n         // (need_lib_alloc and prefer_dynamic) then we select `None`, and if the\n         // exe allocation crate doesn't exist for this target then we also\n         // select `None`.\n-        let exe_allocation_crate =\n+        let exe_allocation_crate_data =\n             if need_lib_alloc && !self.sess.opts.cg.prefer_dynamic {\n                 None\n             } else {\n-                self.sess.target.target.options.exe_allocation_crate.as_ref()\n+                self.sess\n+                    .target\n+                    .target\n+                    .options\n+                    .exe_allocation_crate\n+                    .as_ref()\n+                    .map(|name| {\n+                        // We've determined that we're injecting an \"exe allocator\" which means\n+                        // that we're going to load up a whole new crate. An example of this is\n+                        // that we're producing a normal binary on Linux which means we need to\n+                        // load the `alloc_jemalloc` crate to link as an allocator.\n+                        let name = Symbol::intern(name);\n+                        let (cnum, data) = self.resolve_crate(&None,\n+                                                              name,\n+                                                              name,\n+                                                              None,\n+                                                              DUMMY_SP,\n+                                                              PathKind::Crate,\n+                                                              DepKind::Implicit);\n+                        self.sess.injected_allocator.set(Some(cnum));\n+                        data\n+                    })\n             };\n \n-        match exe_allocation_crate {\n-            // We've determined that we're injecting an \"exe allocator\" which\n-            // means that we're going to load up a whole new crate. An example\n-            // of this is that we're producing a normal binary on Linux which\n-            // means we need to load the `alloc_jemalloc` crate to link as an\n-            // allocator.\n-            Some(krate) => {\n-                self.sess.allocator_kind.set(Some(AllocatorKind::DefaultExe));\n-                let name = Symbol::intern(krate);\n-                let dep_kind = DepKind::Implicit;\n-                let (cnum, _data) =\n-                    self.resolve_crate(&None,\n-                                       name,\n-                                       name,\n-                                       None,\n-                                       DUMMY_SP,\n-                                       PathKind::Crate, dep_kind);\n-                self.sess.injected_allocator.set(Some(cnum));\n+        let allocation_crate_data = exe_allocation_crate_data.or_else(|| {\n+            if attr::contains_name(&krate.attrs, \"default_lib_allocator\") {\n+                // Prefer self as the allocator if there's a collision\n+                return None;\n             }\n-\n             // We're not actually going to inject an allocator, we're going to\n             // require that something in our crate graph is the default lib\n             // allocator. This is typically libstd, so this'll rarely be an\n             // error.\n-            None => {\n-                self.sess.allocator_kind.set(Some(AllocatorKind::DefaultLib));\n-                let mut found_lib_allocator =\n-                    attr::contains_name(&krate.attrs, \"default_lib_allocator\");\n-                self.cstore.iter_crate_data(|_, data| {\n-                    if !found_lib_allocator {\n-                        if data.has_default_lib_allocator() {\n-                            found_lib_allocator = true;\n-                        }\n+            let mut allocator = None;\n+            self.cstore.iter_crate_data(|_, data| {\n+                if allocator.is_none() && data.has_default_lib_allocator() {\n+                    allocator = Some(data.clone());\n+                }\n+            });\n+            allocator\n+        });\n+\n+        match allocation_crate_data {\n+            Some(data) => {\n+                // We have an allocator. We detect separately what kind it is, to allow for some\n+                // flexibility in misconfiguration.\n+                let attrs = data.get_item_attrs(CRATE_DEF_INDEX);\n+                let kind_interned = attr::first_attr_value_str_by_name(&attrs, \"rustc_alloc_kind\")\n+                    .map(Symbol::as_str);\n+                let kind_str = kind_interned\n+                    .as_ref()\n+                    .map(|s| s as &str);\n+                let alloc_kind = match kind_str {\n+                    None |\n+                    Some(\"lib\") => AllocatorKind::DefaultLib,\n+                    Some(\"exe\") => AllocatorKind::DefaultExe,\n+                    Some(other) => {\n+                        self.sess.err(&format!(\"Allocator kind {} not known\", other));\n+                        return;\n                     }\n-                });\n-                if found_lib_allocator {\n-                    return\n+                };\n+                self.sess.allocator_kind.set(Some(alloc_kind));\n+            },\n+            None => {\n+                if !attr::contains_name(&krate.attrs, \"default_lib_allocator\") {\n+                    self.sess.err(\"no #[default_lib_allocator] found but one is \\\n+                                   required; is libstd not linked?\");\n+                    return;\n                 }\n-                self.sess.err(\"no #[default_lib_allocator] found but one is \\\n-                               required; is libstd not linked?\");\n+                self.sess.allocator_kind.set(Some(AllocatorKind::DefaultLib));\n             }\n         }\n "}]}