{"sha": "1bdee96c5e6de445f09df34447a42553294f21ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiZGVlOTZjNWU2ZGU0NDVmMDlkZjM0NDQ3YTQyNTUzMjk0ZjIxZWQ=", "commit": {"author": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-10-03T17:19:50Z"}, "committer": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-10-17T16:48:20Z"}, "message": "Move subslice pattern tests to alloc/tests/slice.rs", "tree": {"sha": "2dd1834c63ea5644aab2897f9040c7454381aa23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dd1834c63ea5644aab2897f9040c7454381aa23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bdee96c5e6de445f09df34447a42553294f21ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bdee96c5e6de445f09df34447a42553294f21ed", "html_url": "https://github.com/rust-lang/rust/commit/1bdee96c5e6de445f09df34447a42553294f21ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bdee96c5e6de445f09df34447a42553294f21ed/comments", "author": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "committer": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42271a537a7a833c7ed448297b48be3bbc98de8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/42271a537a7a833c7ed448297b48be3bbc98de8c", "html_url": "https://github.com/rust-lang/rust/commit/42271a537a7a833c7ed448297b48be3bbc98de8c"}], "stats": {"total": 246, "additions": 120, "deletions": 126}, "files": [{"sha": "a4f0fb415fb3cc79b8045c98471371fd28c2e6da", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/1bdee96c5e6de445f09df34447a42553294f21ed/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bdee96c5e6de445f09df34447a42553294f21ed/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=1bdee96c5e6de445f09df34447a42553294f21ed", "patch": "@@ -1,5 +1,6 @@\n use std::cell::Cell;\n use std::cmp::Ordering::{self, Equal, Greater, Less};\n+use std::convert::identity;\n use std::mem;\n use std::panic;\n use std::rc::Rc;\n@@ -1778,3 +1779,122 @@ fn repeat_generic_slice() {\n     assert_eq!([1, 2, 3, 4].repeat(1), vec![1, 2, 3, 4]);\n     assert_eq!([1, 2, 3, 4].repeat(3), vec![1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n }\n+\n+#[test]\n+#[allow(unreachable_patterns)]\n+fn subslice_patterns() {\n+    // This test comprehensively checks the passing static and dynamic semantics\n+    // of subslice patterns `..`, `x @ ..`, `ref x @ ..`, and `ref mut @ ..`\n+    // in slice patterns `[$($pat), $(,)?]` .\n+\n+    #[derive(PartialEq, Debug, Clone)]\n+    struct N(u8);\n+\n+    macro_rules! n {\n+        ($($e:expr),* $(,)?) => {\n+            [$(N($e)),*]\n+        }\n+    }\n+\n+    macro_rules! c {\n+        ($inp:expr, $typ:ty, $out:expr $(,)?) => {\n+            assert_eq!($out, identity::<$typ>($inp));\n+        };\n+    }\n+\n+    macro_rules! m {\n+        ($e:expr, $p:pat => $b:expr) => {\n+            match $e {\n+                $p => $b,\n+                _ => panic!(),\n+            }\n+        };\n+    }\n+\n+    // == Slices ==\n+\n+    // Matching slices using `ref` patterns:\n+    let mut v = vec![N(0), N(1), N(2), N(3), N(4)];\n+    let mut vc = (0..=4).collect::<Vec<u8>>();\n+\n+    let [..] = v[..]; // Always matches.\n+    m!(v[..], [N(0), ref sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n+    m!(v[..], [N(0), ref sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n+    m!(v[..], [ref sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n+    m!(v[..], [ref sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n+    m!(v[..], [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n+    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching slices using `ref mut` patterns:\n+    let [..] = v[..]; // Always matches.\n+    m!(v[..], [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n+    m!(v[..], [N(0), ref mut sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n+    m!(v[..], [ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n+    m!(v[..], [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(v[..], [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching slices using default binding modes (&):\n+    let [..] = &v[..]; // Always matches.\n+    m!(&v[..], [N(0), sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n+    m!(&v[..], [N(0), sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n+    m!(&v[..], [sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n+    m!(&v[..], [sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n+    m!(&v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n+    m!(&vc[..], [x, .., y] => c!((x, y), (&u8, &u8), (&0, &4)));\n+\n+    // Matching slices using default binding modes (&mut):\n+    let [..] = &mut v[..]; // Always matches.\n+    m!(&mut v[..], [N(0), sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n+    m!(&mut v[..], [N(0), sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n+    m!(&mut v[..], [sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n+    m!(&mut v[..], [sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(&mut v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(&mut vc[..], [x, .., y] => c!((x, y), (&mut u8, &mut u8), (&mut 0, &mut 4)));\n+\n+    // == Arrays ==\n+    let mut v = n![0, 1, 2, 3, 4];\n+    let vc = [0, 1, 2, 3, 4];\n+\n+    // Matching arrays by value:\n+    m!(v.clone(), [N(0), sub @ .., N(4)] => c!(sub, [N; 3], n![1, 2, 3]));\n+    m!(v.clone(), [N(0), sub @ ..] => c!(sub, [N; 4], n![1, 2, 3, 4]));\n+    m!(v.clone(), [sub @ .., N(4)] => c!(sub, [N; 4], n![0, 1, 2, 3]));\n+    m!(v.clone(), [sub @ .., _, _, _, _, _] => c!(sub, [N; 0], n![] as [N; 0]));\n+    m!(v.clone(), [_, _, _, _, _, sub @ ..] => c!(sub, [N; 0], n![] as [N; 0]));\n+    m!(v.clone(), [x, .., y] => c!((x, y), (N, N), (N(0), N(4))));\n+    m!(v.clone(), [..] => ());\n+\n+    // Matching arrays by ref patterns:\n+    m!(v, [N(0), ref sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n+    m!(v, [N(0), ref sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n+    m!(v, [ref sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n+    m!(v, [ref sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(v, [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(vc, [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching arrays by ref mut patterns:\n+    m!(v, [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n+    m!(v, [N(0), ref mut sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n+    m!(v, [ref mut sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n+    m!(v, [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n+    m!(v, [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n+\n+    // Matching arrays by default binding modes (&):\n+    m!(&v, [N(0), sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n+    m!(&v, [N(0), sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n+    m!(&v, [sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n+    m!(&v, [sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(&v, [_, _, _, _, _, sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(&v, [..] => ());\n+    m!(&v, [x, .., y] => c!((x, y), (&N, &N), (&N(0), &N(4))));\n+\n+    // Matching arrays by default binding modes (&mut):\n+    m!(&mut v, [N(0), sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n+    m!(&mut v, [N(0), sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n+    m!(&mut v, [sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n+    m!(&mut v, [sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n+    m!(&mut v, [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n+    m!(&mut v, [..] => ());\n+    m!(&mut v, [x, .., y] => c!((x, y), (&mut N, &mut N), (&mut N(0), &mut N(4))));\n+}"}, {"sha": "e05790911f52d9b3e0ca2eb9fcb233ba7607edbf", "filename": "src/test/ui/array-slice-vec/subslice-patterns-pass.rs", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/42271a537a7a833c7ed448297b48be3bbc98de8c/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42271a537a7a833c7ed448297b48be3bbc98de8c/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs?ref=42271a537a7a833c7ed448297b48be3bbc98de8c", "patch": "@@ -1,126 +0,0 @@\n-// This test comprehensively checks the passing static and dynamic semantics\n-// of subslice patterns `..`, `x @ ..`, `ref x @ ..`, and `ref mut @ ..`\n-// in slice patterns `[$($pat), $(,)?]` .\n-\n-// run-pass\n-\n-#![allow(unreachable_patterns)]\n-\n-use std::convert::identity;\n-\n-#[derive(PartialEq, Debug, Clone)]\n-struct N(u8);\n-\n-macro_rules! n {\n-    ($($e:expr),* $(,)?) => {\n-        [$(N($e)),*]\n-    }\n-}\n-\n-macro_rules! c {\n-    ($inp:expr, $typ:ty, $out:expr $(,)?) => {\n-        assert_eq!($out, identity::<$typ>($inp));\n-    }\n-}\n-\n-macro_rules! m {\n-    ($e:expr, $p:pat => $b:expr) => {\n-        match $e {\n-            $p => $b,\n-            _ => panic!(),\n-        }\n-    }\n-}\n-\n-fn main() {\n-    slices();\n-    arrays();\n-}\n-\n-fn slices() {\n-    // Matching slices using `ref` patterns:\n-    let mut v = vec![N(0), N(1), N(2), N(3), N(4)];\n-    let mut vc = (0..=4).collect::<Vec<u8>>();\n-\n-    let [..] = v[..]; // Always matches.\n-    m!(v[..], [N(0), ref sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n-    m!(v[..], [N(0), ref sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n-    m!(v[..], [ref sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n-    m!(v[..], [ref sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n-    m!(v[..], [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n-    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n-\n-    // Matching slices using `ref mut` patterns:\n-    let [..] = v[..]; // Always matches.\n-    m!(v[..], [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n-    m!(v[..], [N(0), ref mut sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n-    m!(v[..], [ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n-    m!(v[..], [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n-    m!(v[..], [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n-    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n-\n-    // Matching slices using default binding modes (&):\n-    let [..] = &v[..]; // Always matches.\n-    m!(&v[..], [N(0), sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n-    m!(&v[..], [N(0), sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n-    m!(&v[..], [sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n-    m!(&v[..], [sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n-    m!(&v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n-    m!(&vc[..], [x, .., y] => c!((x, y), (&u8, &u8), (&0, &4)));\n-\n-    // Matching slices using default binding modes (&mut):\n-    let [..] = &mut v[..]; // Always matches.\n-    m!(&mut v[..], [N(0), sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n-    m!(&mut v[..], [N(0), sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n-    m!(&mut v[..], [sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n-    m!(&mut v[..], [sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n-    m!(&mut v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n-    m!(&mut vc[..], [x, .., y] => c!((x, y), (&mut u8, &mut u8), (&mut 0, &mut 4)));\n-}\n-\n-fn arrays() {\n-    let mut v = n![0, 1, 2, 3, 4];\n-    let vc = [0, 1, 2, 3, 4];\n-\n-    // Matching arrays by value:\n-    m!(v.clone(), [N(0), sub @ .., N(4)] => c!(sub, [N; 3], n![1, 2, 3]));\n-    m!(v.clone(), [N(0), sub @ ..] => c!(sub, [N; 4], n![1, 2, 3, 4]));\n-    m!(v.clone(), [sub @ .., N(4)] => c!(sub, [N; 4], n![0, 1, 2, 3]));\n-    m!(v.clone(), [sub @ .., _, _, _, _, _] => c!(sub, [N; 0], n![] as [N; 0]));\n-    m!(v.clone(), [_, _, _, _, _, sub @ ..] => c!(sub, [N; 0], n![] as [N; 0]));\n-    m!(v.clone(), [x, .., y] => c!((x, y), (N, N), (N(0), N(4))));\n-    m!(v.clone(), [..] => ());\n-\n-    // Matching arrays by ref patterns:\n-    m!(v, [N(0), ref sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n-    m!(v, [N(0), ref sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n-    m!(v, [ref sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n-    m!(v, [ref sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n-    m!(v, [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n-    m!(vc, [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n-\n-    // Matching arrays by ref mut patterns:\n-    m!(v, [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n-    m!(v, [N(0), ref mut sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n-    m!(v, [ref mut sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n-    m!(v, [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n-    m!(v, [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n-\n-    // Matching arrays by default binding modes (&):\n-    m!(&v, [N(0), sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n-    m!(&v, [N(0), sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n-    m!(&v, [sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n-    m!(&v, [sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n-    m!(&v, [_, _, _, _, _, sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n-    m!(&v, [..] => ());\n-    m!(&v, [x, .., y] => c!((x, y), (&N, &N), (&N(0), &N(4))));\n-\n-    // Matching arrays by default binding modes (&mut):\n-    m!(&mut v, [N(0), sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n-    m!(&mut v, [N(0), sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n-    m!(&mut v, [sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n-    m!(&mut v, [sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n-    m!(&mut v, [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n-    m!(&mut v, [..] => ());\n-    m!(&mut v, [x, .., y] => c!((x, y), (&mut N, &mut N), (&mut N(0), &mut N(4))));\n-}"}]}