{"sha": "5d823d46ad5350e095a531d847464f42c5f29261", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkODIzZDQ2YWQ1MzUwZTA5NWE1MzFkODQ3NDY0ZjQyYzVmMjkyNjE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-08T00:24:02Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-08T00:24:16Z"}, "message": "Migrate std::map to use core::hash::Hash trait. Disable many hokey hashes.", "tree": {"sha": "5d9dc2ab6e1cf05678634e20712392362bc3e46d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d9dc2ab6e1cf05678634e20712392362bc3e46d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d823d46ad5350e095a531d847464f42c5f29261", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d823d46ad5350e095a531d847464f42c5f29261", "html_url": "https://github.com/rust-lang/rust/commit/5d823d46ad5350e095a531d847464f42c5f29261", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d823d46ad5350e095a531d847464f42c5f29261/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5093dff7b28a47309e3cafd2530663313ef56f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5093dff7b28a47309e3cafd2530663313ef56f0", "html_url": "https://github.com/rust-lang/rust/commit/f5093dff7b28a47309e3cafd2530663313ef56f0"}], "stats": {"total": 1133, "additions": 736, "deletions": 397}, "files": [{"sha": "ef792ef690e1fdc4aab9628b22d844b5680e9da1", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -64,7 +64,7 @@ impl <A: IterBytes> A: Hash {\n     pure fn hash_keyed(k0: u64, k1: u64) -> u64 {\n         unchecked {\n             let s = &State(k0, k1);\n-            for self.iter_le_bytes |bytes| {\n+            for self.iter_bytes(true) |bytes| {\n                 s.input(bytes);\n             }\n             s.result_u64()\n@@ -79,8 +79,8 @@ pure fn hash_keyed_2<A: IterBytes,\n                                    k0: u64, k1: u64) -> u64 {\n     unchecked {\n         let s = &State(k0, k1);\n-        for a.iter_le_bytes |bytes| { s.input(bytes); }\n-        for b.iter_le_bytes |bytes| { s.input(bytes); }\n+        for a.iter_bytes(true) |bytes| { s.input(bytes); }\n+        for b.iter_bytes(true) |bytes| { s.input(bytes); }\n         s.result_u64()\n     }\n }\n@@ -91,9 +91,9 @@ pure fn hash_keyed_3<A: IterBytes,\n                                    k0: u64, k1: u64) -> u64 {\n     unchecked {\n         let s = &State(k0, k1);\n-        for a.iter_le_bytes |bytes| { s.input(bytes); }\n-        for b.iter_le_bytes |bytes| { s.input(bytes); }\n-        for c.iter_le_bytes |bytes| { s.input(bytes); }\n+        for a.iter_bytes(true) |bytes| { s.input(bytes); }\n+        for b.iter_bytes(true) |bytes| { s.input(bytes); }\n+        for c.iter_bytes(true) |bytes| { s.input(bytes); }\n         s.result_u64()\n     }\n }\n@@ -105,10 +105,10 @@ pure fn hash_keyed_4<A: IterBytes,\n                                    k0: u64, k1: u64) -> u64 {\n     unchecked {\n         let s = &State(k0, k1);\n-        for a.iter_le_bytes |bytes| { s.input(bytes); }\n-        for b.iter_le_bytes |bytes| { s.input(bytes); }\n-        for c.iter_le_bytes |bytes| { s.input(bytes); }\n-        for d.iter_le_bytes |bytes| { s.input(bytes); }\n+        for a.iter_bytes(true) |bytes| { s.input(bytes); }\n+        for b.iter_bytes(true) |bytes| { s.input(bytes); }\n+        for c.iter_bytes(true) |bytes| { s.input(bytes); }\n+        for d.iter_bytes(true) |bytes| { s.input(bytes); }\n         s.result_u64()\n     }\n }\n@@ -121,11 +121,11 @@ pure fn hash_keyed_5<A: IterBytes,\n                                    k0: u64, k1: u64) -> u64 {\n     unchecked {\n         let s = &State(k0, k1);\n-        for a.iter_le_bytes |bytes| { s.input(bytes); }\n-        for b.iter_le_bytes |bytes| { s.input(bytes); }\n-        for c.iter_le_bytes |bytes| { s.input(bytes); }\n-        for d.iter_le_bytes |bytes| { s.input(bytes); }\n-        for e.iter_le_bytes |bytes| { s.input(bytes); }\n+        for a.iter_bytes(true) |bytes| { s.input(bytes); }\n+        for b.iter_bytes(true) |bytes| { s.input(bytes); }\n+        for c.iter_bytes(true) |bytes| { s.input(bytes); }\n+        for d.iter_bytes(true) |bytes| { s.input(bytes); }\n+        for e.iter_bytes(true) |bytes| { s.input(bytes); }\n         s.result_u64()\n     }\n }"}, {"sha": "f619085bd4b5c8575fe8ddffd9e89c447ad4d673", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 203, "deletions": 177, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -7,221 +7,273 @@ use io::Writer;\n type Cb = fn(buf: &[const u8]) -> bool;\n \n trait IterBytes {\n-    fn iter_le_bytes(f: Cb);\n-    fn iter_be_bytes(f: Cb);\n+    fn iter_bytes(lsb0: bool, f: Cb);\n }\n \n impl u8: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) {\n+    fn iter_bytes(_lsb0: bool, f: Cb) {\n         f([\n-            self,\n-        ]);\n-    }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) {\n-        f([\n-            self as u8\n+            self\n         ]);\n     }\n }\n \n impl u16: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) {\n-        f([\n-            self as u8,\n-            (self >> 8) as u8\n-        ]);\n-    }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) {\n-        f([\n-            (self >> 8) as u8,\n-            self as u8\n-        ]);\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        if lsb0 {\n+            f([\n+                self as u8,\n+                (self >> 8) as u8\n+            ]);\n+        } else {\n+            f([\n+                (self >> 8) as u8,\n+                self as u8\n+            ]);\n+        }\n     }\n }\n \n impl u32: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) {\n-        f([\n-            self as u8,\n-            (self >> 8) as u8,\n-            (self >> 16) as u8,\n-            (self >> 24) as u8,\n-        ]);\n-    }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) {\n-        f([\n-            (self >> 24) as u8,\n-            (self >> 16) as u8,\n-            (self >> 8) as u8,\n-            self as u8\n-        ]);\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        if lsb0 {\n+            f([\n+                self as u8,\n+                (self >> 8) as u8,\n+                (self >> 16) as u8,\n+                (self >> 24) as u8,\n+            ]);\n+        } else {\n+            f([\n+                (self >> 24) as u8,\n+                (self >> 16) as u8,\n+                (self >> 8) as u8,\n+                self as u8\n+            ]);\n+        }\n     }\n }\n \n impl u64: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) {\n-        f([\n-            self as u8,\n-            (self >> 8) as u8,\n-            (self >> 16) as u8,\n-            (self >> 24) as u8,\n-            (self >> 32) as u8,\n-            (self >> 40) as u8,\n-            (self >> 48) as u8,\n-            (self >> 56) as u8\n-        ]);\n-    }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) {\n-        f([\n-            (self >> 56) as u8,\n-            (self >> 48) as u8,\n-            (self >> 40) as u8,\n-            (self >> 32) as u8,\n-            (self >> 24) as u8,\n-            (self >> 16) as u8,\n-            (self >> 8) as u8,\n-            self as u8\n-        ]);\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        if lsb0 {\n+            f([\n+                self as u8,\n+                (self >> 8) as u8,\n+                (self >> 16) as u8,\n+                (self >> 24) as u8,\n+                (self >> 32) as u8,\n+                (self >> 40) as u8,\n+                (self >> 48) as u8,\n+                (self >> 56) as u8\n+            ]);\n+        } else {\n+            f([\n+                (self >> 56) as u8,\n+                (self >> 48) as u8,\n+                (self >> 40) as u8,\n+                (self >> 32) as u8,\n+                (self >> 24) as u8,\n+                (self >> 16) as u8,\n+                (self >> 8) as u8,\n+                self as u8\n+            ]);\n+        }\n     }\n }\n \n impl i8: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) { (self as u8).iter_le_bytes(f) }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) { (self as u8).iter_be_bytes(f) }\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        (self as u8).iter_bytes(lsb0, f)\n+    }\n }\n \n impl i16: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) { (self as u16).iter_le_bytes(f) }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) { (self as u16).iter_be_bytes(f) }\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        (self as u16).iter_bytes(lsb0, f)\n+    }\n }\n \n impl i32: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) { (self as u32).iter_le_bytes(f) }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) { (self as u32).iter_be_bytes(f) }\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        (self as u32).iter_bytes(lsb0, f)\n+    }\n }\n \n impl i64: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) { (self as u64).iter_le_bytes(f) }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) { (self as u64).iter_be_bytes(f) }\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        (self as u64).iter_bytes(lsb0, f)\n+    }\n }\n \n #[cfg(target_word_size = \"32\")]\n impl uint: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) { (self as u32).iter_le_bytes(f) }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) { (self as u32).iter_be_bytes(f) }\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        (self as u32).iter_bytes(lsb0, f)\n+    }\n }\n \n #[cfg(target_word_size = \"64\")]\n impl uint: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) { (self as u64).iter_le_bytes(f) }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) { (self as u64).iter_be_bytes(f) }\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        (self as u64).iter_bytes(lsb0, f)\n+    }\n }\n \n impl int: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) { (self as uint).iter_le_bytes(f) }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) { (self as uint).iter_be_bytes(f) }\n-}\n-\n-impl ~[const u8]: IterBytes {\n-    #[inline(always)]\n-    fn iter_le_bytes(f: Cb) { f(self); }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) { f(self); }\n-}\n-\n-impl @[const u8]: IterBytes {\n-    #[inline(always)]\n-    fn iter_le_bytes(f: Cb) { f(self); }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) { f(self); }\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        (self as uint).iter_bytes(lsb0, f)\n+    }\n }\n \n impl<A: IterBytes> &[const A]: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) {\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n         for self.each |elt| {\n-            do elt.iter_le_bytes |bytes| {\n+            do elt.iter_bytes(lsb0) |bytes| {\n                 f(bytes)\n             }\n         }\n     }\n+}\n+\n+// Move this to vec, probably.\n+fn borrow<A>(a: &x/[const A]) -> &x/[const A] {\n+    a\n+}\n+\n+impl<A: IterBytes> ~[const A]: IterBytes {\n     #[inline(always)]\n-    fn iter_be_bytes(f: Cb) {\n-        for self.each |elt| {\n-            do elt.iter_be_bytes |bytes| {\n-                f(bytes)\n-            }\n-        }\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        borrow(self).iter_bytes(lsb0, f)\n     }\n }\n \n-fn iter_le_bytes_2<A: IterBytes, B: IterBytes>(a: &A, b: &B, f: Cb) {\n+\n+impl<A: IterBytes> @[const A]: IterBytes {\n+    #[inline(always)]\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        borrow(self).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+fn iter_bytes_2<A: IterBytes, B: IterBytes>(a: &A, b: &B,\n+                                            lsb0: bool, z: Cb) {\n+    let mut flag = true;\n+    a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+}\n+\n+fn iter_bytes_3<A: IterBytes,\n+                B: IterBytes,\n+                C: IterBytes>(a: &A, b: &B, c: &C,\n+                              lsb0: bool, z: Cb) {\n+    let mut flag = true;\n+    a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+}\n+\n+fn iter_bytes_4<A: IterBytes,\n+                B: IterBytes,\n+                C: IterBytes,\n+                D: IterBytes>(a: &A, b: &B, c: &C,\n+                              d: &D,\n+                              lsb0: bool, z: Cb) {\n     let mut flag = true;\n-    a.iter_le_bytes(|bytes| {flag = f(bytes); flag});\n+    a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n-    b.iter_le_bytes(|bytes| {flag = f(bytes); flag});\n+    b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-fn iter_be_bytes_2<A: IterBytes, B: IterBytes>(a: &A, b: &B, f: Cb) {\n+fn iter_bytes_5<A: IterBytes,\n+                B: IterBytes,\n+                C: IterBytes,\n+                D: IterBytes,\n+                E: IterBytes>(a: &A, b: &B, c: &C,\n+                              d: &D, e: &E,\n+                              lsb0: bool, z: Cb) {\n     let mut flag = true;\n-    a.iter_be_bytes(|bytes| {flag = f(bytes); flag});\n+    a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n-    b.iter_be_bytes(|bytes| {flag = f(bytes); flag});\n+    d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    e.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-fn iter_le_bytes_3<A: IterBytes,\n-                   B: IterBytes,\n-                   C: IterBytes>(a: &A, b: &B, c: &C, f: Cb) {\n+fn iter_bytes_6<A: IterBytes,\n+                B: IterBytes,\n+                C: IterBytes,\n+                D: IterBytes,\n+                E: IterBytes,\n+                F: IterBytes>(a: &A, b: &B, c: &C,\n+                              d: &D, e: &E, f: &F,\n+                              lsb0: bool, z: Cb) {\n     let mut flag = true;\n-    a.iter_le_bytes(|bytes| {flag = f(bytes); flag});\n+    a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n-    b.iter_le_bytes(|bytes| { flag = f(bytes); flag});\n+    d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n-    c.iter_le_bytes(|bytes| {flag = f(bytes); flag});\n+    e.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    f.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-fn iter_be_bytes_3<A: IterBytes,\n-                   B: IterBytes,\n-                   C: IterBytes>(a: &A, b: &B, c: &C, f: Cb) {\n+fn iter_bytes_7<A: IterBytes,\n+                B: IterBytes,\n+                C: IterBytes,\n+                D: IterBytes,\n+                E: IterBytes,\n+                F: IterBytes,\n+                G: IterBytes>(a: &A, b: &B, c: &C,\n+                              d: &D, e: &E, f: &F,\n+                              g: &G,\n+                              lsb0: bool, z: Cb) {\n     let mut flag = true;\n-                       a.iter_be_bytes(|bytes| {flag = f(bytes); flag});\n+    a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n-                       b.iter_be_bytes(|bytes| {flag = f(bytes); flag});\n+    e.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n-                       c.iter_be_bytes(|bytes| {flag = f(bytes); flag});\n+    f.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+    if !flag { return; }\n+    g.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n impl &str: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) {\n-        do str::byte_slice(self) |bytes| {\n-            f(bytes);\n-        }\n-    }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) {\n+    fn iter_bytes(_lsb0: bool, f: Cb) {\n         do str::byte_slice(self) |bytes| {\n             f(bytes);\n         }\n@@ -230,13 +282,7 @@ impl &str: IterBytes {\n \n impl ~str: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) {\n-        do str::byte_slice(self) |bytes| {\n-            f(bytes);\n-        }\n-    }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) {\n+    fn iter_bytes(_lsb0: bool, f: Cb) {\n         do str::byte_slice(self) |bytes| {\n             f(bytes);\n         }\n@@ -245,84 +291,64 @@ impl ~str: IterBytes {\n \n impl @str: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) {\n+    fn iter_bytes(_lsb0: bool, f: Cb) {\n         do str::byte_slice(self) |bytes| {\n             f(bytes);\n         }\n     }\n+}\n+\n+impl<A: IterBytes> Option<A>: IterBytes {\n     #[inline(always)]\n-    fn iter_be_bytes(f: Cb) {\n-        do str::byte_slice(self) |bytes| {\n-            f(bytes);\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        match self {\n+          Some(a) => iter_bytes_2(&0u8, &a, lsb0, f),\n+          None => 1u8.iter_bytes(lsb0, f)\n         }\n     }\n }\n+\n impl<A: IterBytes> &A: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) {\n-        (*self).iter_le_bytes(f);\n-    }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) {\n-        (*self).iter_be_bytes(f);\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        (*self).iter_bytes(lsb0, f);\n     }\n }\n \n impl<A: IterBytes> @A: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) {\n-        (*self).iter_le_bytes(f);\n-    }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) {\n-        (*self).iter_be_bytes(f);\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        (*self).iter_bytes(lsb0, f);\n     }\n }\n \n impl<A: IterBytes> ~A: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) {\n-        (*self).iter_le_bytes(f);\n-    }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) {\n-        (*self).iter_be_bytes(f);\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        (*self).iter_bytes(lsb0, f);\n     }\n }\n \n // NB: raw-pointer IterBytes does _not_ dereference\n // to the target; it just gives you the pointer-bytes.\n impl<A> *A: IterBytes {\n     #[inline(always)]\n-    fn iter_le_bytes(f: Cb) {\n-        (self as uint).iter_le_bytes(f);\n-    }\n-    #[inline(always)]\n-    fn iter_be_bytes(f: Cb) {\n-        (self as uint).iter_be_bytes(f);\n+    fn iter_bytes(lsb0: bool, f: Cb) {\n+        (self as uint).iter_bytes(lsb0, f);\n     }\n }\n \n \n trait ToBytes {\n-    fn to_le_bytes() -> ~[u8];\n-    fn to_be_bytes() -> ~[u8];\n+    fn to_bytes(lsb0: bool) -> ~[u8];\n }\n \n impl<A: IterBytes> A: ToBytes {\n-    fn to_le_bytes() -> ~[u8] {\n+    fn to_bytes(lsb0: bool) -> ~[u8] {\n         let buf = io::mem_buffer();\n-        for self.iter_le_bytes |bytes| {\n+        for self.iter_bytes(lsb0) |bytes| {\n             buf.write(bytes)\n         }\n         io::mem_buffer_buf(buf)\n     }\n-    fn to_be_bytes() -> ~[u8] {\n-        let buf = io::mem_buffer();\n-        for self.iter_be_bytes |bytes| {\n-            buf.write(bytes)\n-        }\n-        io::mem_buffer_buf(buf)\n-    }\n-\n }"}, {"sha": "603cff987210d3ebc5a84d0d5ddc69bbe00d0d45", "filename": "src/libstd/map.rs", "status": "modified", "additions": 45, "deletions": 75, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -19,21 +19,12 @@ export hash_from_vec, hash_from_strs, hash_from_bytes;\n export hash_from_ints, hash_from_uints;\n export vec_from_set;\n \n-/**\n- * A function that returns a hash of a value\n- *\n- * The hash should concentrate entropy in the lower bits.\n- */\n-type hashfn<K> = fn~(key: &K) -> uint;\n-\n-type eqfn<K> = fn~(key1: &K, key2: &K) -> bool;\n-\n /// A convenience type to treat a hashmap as a set\n-type set<K> = hashmap<K, ()>;\n+type set<K:Eq IterBytes Hash> = hashmap<K, ()>;\n \n-type hashmap<K, V> = chained::t<K, V>;\n+type hashmap<K:Eq IterBytes Hash, V> = chained::t<K, V>;\n \n-trait map<K: copy, V: copy> {\n+trait map<K:Eq IterBytes Hash copy, V: copy> {\n     /// Return the number of elements in the map\n     pure fn size() -> uint;\n \n@@ -119,22 +110,20 @@ mod chained {\n         mut next: Option<@entry<K, V>>\n     }\n \n-    struct hashmap_<K, V> {\n+    struct hashmap_<K:Eq IterBytes Hash, V> {\n         mut count: uint,\n-        mut chains: ~[mut Option<@entry<K,V>>],\n-        hasher: hashfn<K>,\n-        eqer: eqfn<K>\n+        mut chains: ~[mut Option<@entry<K,V>>]\n     }\n \n-    type t<K, V> = @hashmap_<K, V>;\n+    type t<K:Eq IterBytes Hash, V> = @hashmap_<K, V>;\n \n     enum search_result<K, V> {\n         not_found,\n         found_first(uint, @entry<K,V>),\n         found_after(@entry<K,V>, @entry<K,V>)\n     }\n \n-    priv impl<K, V: copy> t<K, V> {\n+    priv impl<K:Eq IterBytes Hash, V: copy> t<K, V> {\n         pure fn search_rem(k: &K, h: uint, idx: uint,\n                            e_root: @entry<K,V>) -> search_result<K,V> {\n             let mut e0 = e_root;\n@@ -149,7 +138,7 @@ mod chained {\n                   Some(e1) => {\n                     comp += 1u;\n                     unchecked {\n-                        if e1.hash == h && self.eqer(&e1.key, k) {\n+                        if e1.hash == h && e1.key == *k {\n                             debug!(\"search_tbl: present, comp %u, \\\n                                     hash %u, idx %u\",\n                                    comp, h, idx);\n@@ -173,7 +162,7 @@ mod chained {\n               }\n               Some(e) => {\n                 unchecked {\n-                    if e.hash == h && self.eqer(&e.key, k) {\n+                    if e.hash == h && e.key == *k {\n                         debug!(\"search_tbl: present, comp %u, hash %u, \\\n                                 idx %u\", 1u, h, idx);\n                         return found_first(idx, e);\n@@ -218,23 +207,23 @@ mod chained {\n         }\n     }\n \n-    impl<K: copy, V: copy> t<K, V>: map<K, V> {\n+    impl<K:Eq IterBytes Hash copy, V: copy> t<K, V>: map<K, V> {\n         pure fn size() -> uint { self.count }\n \n         fn contains_key(+k: K) -> bool {\n             self.contains_key_ref(&k)\n         }\n \n         fn contains_key_ref(k: &K) -> bool {\n-            let hash = self.hasher(k);\n+            let hash = k.hash_keyed(0,0) as uint;\n             match self.search_tbl(k, hash) {\n               not_found => false,\n               found_first(*) | found_after(*) => true\n             }\n         }\n \n         fn insert(+k: K, +v: V) -> bool {\n-            let hash = self.hasher(&k);\n+            let hash = k.hash_keyed(0,0) as uint;\n             match self.search_tbl(&k, hash) {\n               not_found => {\n                 self.count += 1u;\n@@ -277,7 +266,7 @@ mod chained {\n \n         pure fn find(+k: K) -> Option<V> {\n             unchecked {\n-                match self.search_tbl(&k, self.hasher(&k)) {\n+                match self.search_tbl(&k, k.hash_keyed(0,0) as uint) {\n                   not_found => None,\n                   found_first(_, entry) => Some(entry.value),\n                   found_after(_, entry) => Some(entry.value)\n@@ -294,7 +283,7 @@ mod chained {\n         }\n \n         fn remove(+k: K) -> bool {\n-            match self.search_tbl(&k, self.hasher(&k)) {\n+            match self.search_tbl(&k, k.hash_keyed(0,0) as uint) {\n               not_found => false,\n               found_first(idx, entry) => {\n                 self.count -= 1u;\n@@ -341,7 +330,7 @@ mod chained {\n         }\n     }\n \n-    impl<K: copy ToStr, V: ToStr copy> t<K, V>: ToStr {\n+    impl<K:Eq IterBytes Hash copy ToStr, V: ToStr copy> t<K, V>: ToStr {\n         fn to_writer(wr: io::Writer) {\n             if self.count == 0u {\n                 wr.write_str(~\"{}\");\n@@ -367,7 +356,7 @@ mod chained {\n         }\n     }\n \n-    impl<K: copy, V: copy> t<K, V>: ops::Index<K, V> {\n+    impl<K:Eq IterBytes Hash copy, V: copy> t<K, V>: ops::Index<K, V> {\n         pure fn index(&&k: K) -> V {\n             unchecked {\n                 self.get(k)\n@@ -379,11 +368,9 @@ mod chained {\n         vec::to_mut(vec::from_elem(nchains, None))\n     }\n \n-    fn mk<K, V: copy>(+hasher: hashfn<K>, +eqer: eqfn<K>) -> t<K,V> {\n+    fn mk<K:Eq IterBytes Hash, V: copy>() -> t<K,V> {\n         let slf: t<K, V> = @hashmap_ {count: 0u,\n-                                      chains: chains(initial_capacity),\n-                                      hasher: hasher,\n-                                      eqer: eqer};\n+                                      chains: chains(initial_capacity)};\n         slf\n     }\n }\n@@ -392,56 +379,49 @@ mod chained {\n Function: hashmap\n \n Construct a hashmap.\n-\n-Parameters:\n-\n-hasher - The hash function for key type K\n-eqer - The equality function for key type K\n */\n-fn hashmap<K: const, V: copy>(+hasher: hashfn<K>, +eqer: eqfn<K>)\n+fn hashmap<K:Eq IterBytes Hash const, V: copy>()\n         -> hashmap<K, V> {\n-    chained::mk(hasher, eqer)\n+    chained::mk()\n }\n \n /// Construct a hashmap for string-slice keys\n fn str_slice_hash<V: copy>() -> hashmap<&str, V> {\n-    return hashmap(|s| hash::hash_str(*s) as uint,\n-                   |a,b| str::eq_slice(*a, *b));\n+    return hashmap();\n }\n \n /// Construct a hashmap for string keys\n fn str_hash<V: copy>() -> hashmap<~str, V> {\n-    return hashmap(str::hash, str::eq);\n+    return hashmap();\n }\n \n /// Construct a hashmap for boxed string keys\n fn box_str_hash<V: copy>() -> hashmap<@~str, V> {\n-    hashmap(|x: &@~str| str::hash(&**x),\n-            |x: &@~str, y: &@~str| str::eq(&**x, &**y))\n+    hashmap()\n }\n \n /// Construct a hashmap for byte string keys\n fn bytes_hash<V: copy>() -> hashmap<~[u8], V> {\n-    return hashmap(vec::u8::hash, vec::u8::eq);\n+    return hashmap();\n }\n \n /// Construct a hashmap for int keys\n fn int_hash<V: copy>() -> hashmap<int, V> {\n-   return hashmap(|x| { int::hash(*x) }, |x, y| { int::eq(*x, *y)});\n+    return hashmap();\n }\n \n /// Construct a hashmap for uint keys\n fn uint_hash<V: copy>() -> hashmap<uint, V> {\n-   return hashmap(|x| { uint::hash(*x) }, |x, y| { uint::eq(*x, *y) } );\n+    return hashmap();\n }\n \n /// Convenience function for adding keys to a hashmap with nil type keys\n-fn set_add<K: const copy>(set: set<K>, +key: K) -> bool {\n+fn set_add<K:Eq IterBytes Hash const copy>(set: set<K>, +key: K) -> bool {\n     set.insert(key, ())\n }\n \n /// Convert a set into a vector.\n-fn vec_from_set<T: copy>(s: set<T>) -> ~[T] {\n+fn vec_from_set<T:Eq IterBytes Hash copy>(s: set<T>) -> ~[T] {\n     let mut v = ~[];\n     vec::reserve(v, s.size());\n     do s.each_key() |k| {\n@@ -452,9 +432,9 @@ fn vec_from_set<T: copy>(s: set<T>) -> ~[T] {\n }\n \n /// Construct a hashmap from a vector\n-fn hash_from_vec<K: const copy, V: copy>(+hasher: hashfn<K>, +eqer: eqfn<K>,\n-                                         items: &[(K, V)]) -> hashmap<K, V> {\n-    let map = hashmap(hasher, eqer);\n+fn hash_from_vec<K: Eq IterBytes Hash const copy, V: copy>(\n+    items: &[(K, V)]) -> hashmap<K, V> {\n+    let map = hashmap();\n     do vec::iter(items) |item| {\n         let (key, value) = item;\n         map.insert(key, value);\n@@ -464,22 +444,22 @@ fn hash_from_vec<K: const copy, V: copy>(+hasher: hashfn<K>, +eqer: eqfn<K>,\n \n /// Construct a hashmap from a vector with string keys\n fn hash_from_strs<V: copy>(items: &[(~str, V)]) -> hashmap<~str, V> {\n-    hash_from_vec(str::hash, str::eq, items)\n+    hash_from_vec(items)\n }\n \n /// Construct a hashmap from a vector with byte keys\n fn hash_from_bytes<V: copy>(items: &[(~[u8], V)]) -> hashmap<~[u8], V> {\n-    hash_from_vec(vec::u8::hash, vec::u8::eq, items)\n+    hash_from_vec(items)\n }\n \n /// Construct a hashmap from a vector with int keys\n fn hash_from_ints<V: copy>(items: &[(int, V)]) -> hashmap<int, V> {\n-    hash_from_vec(|x| { int::hash(*x) }, |x, y| { int::eq(*x, *y) }, items)\n+    hash_from_vec(items)\n }\n \n /// Construct a hashmap from a vector with uint keys\n fn hash_from_uints<V: copy>(items: &[(uint, V)]) -> hashmap<uint, V> {\n-    hash_from_vec(|x| { uint::hash(*x) }, |x, y| { uint::eq(*x, *y) } , items)\n+    hash_from_vec(items)\n }\n \n // XXX Transitional\n@@ -594,13 +574,9 @@ mod tests {\n         debug!(\"*** starting test_simple\");\n         pure fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n         pure fn uint_id(x: &uint) -> uint { *x }\n-        let hasher_uint: map::hashfn<uint> = uint_id;\n-        let eqer_uint: map::eqfn<uint> = eq_uint;\n-        let hasher_str: map::hashfn<~str> = str::hash;\n-        let eqer_str: map::eqfn<~str> = str::eq;\n         debug!(\"uint -> uint\");\n         let hm_uu: map::hashmap<uint, uint> =\n-            map::hashmap::<uint, uint>(copy hasher_uint, copy eqer_uint);\n+            map::hashmap::<uint, uint>();\n         assert (hm_uu.insert(10u, 12u));\n         assert (hm_uu.insert(11u, 13u));\n         assert (hm_uu.insert(12u, 14u));\n@@ -616,7 +592,7 @@ mod tests {\n         let twelve: ~str = ~\"twelve\";\n         debug!(\"str -> uint\");\n         let hm_su: map::hashmap<~str, uint> =\n-            map::hashmap::<~str, uint>(copy hasher_str, copy eqer_str);\n+            map::hashmap::<~str, uint>();\n         assert (hm_su.insert(~\"ten\", 12u));\n         assert (hm_su.insert(eleven, 13u));\n         assert (hm_su.insert(~\"twelve\", 14u));\n@@ -630,7 +606,7 @@ mod tests {\n         assert (hm_su.get(~\"twelve\") == 12u);\n         debug!(\"uint -> str\");\n         let hm_us: map::hashmap<uint, ~str> =\n-            map::hashmap::<uint, ~str>(copy hasher_uint, copy eqer_uint);\n+            map::hashmap::<uint, ~str>();\n         assert (hm_us.insert(10u, ~\"twelve\"));\n         assert (hm_us.insert(11u, ~\"thirteen\"));\n         assert (hm_us.insert(12u, ~\"fourteen\"));\n@@ -643,7 +619,7 @@ mod tests {\n         assert hm_us.get(12u) == ~\"twelve\";\n         debug!(\"str -> str\");\n         let hm_ss: map::hashmap<~str, ~str> =\n-            map::hashmap::<~str, ~str>(copy hasher_str, copy eqer_str);\n+            map::hashmap::<~str, ~str>();\n         assert (hm_ss.insert(ten, ~\"twelve\"));\n         assert (hm_ss.insert(eleven, ~\"thirteen\"));\n         assert (hm_ss.insert(twelve, ~\"fourteen\"));\n@@ -668,10 +644,8 @@ mod tests {\n         pure fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n         pure fn uint_id(x: &uint) -> uint { *x }\n         debug!(\"uint -> uint\");\n-        let hasher_uint: map::hashfn<uint> = uint_id;\n-        let eqer_uint: map::eqfn<uint> = eq_uint;\n         let hm_uu: map::hashmap<uint, uint> =\n-            map::hashmap::<uint, uint>(hasher_uint, eqer_uint);\n+            map::hashmap::<uint, uint>();\n         let mut i: uint = 0u;\n         while i < num_to_insert {\n             assert (hm_uu.insert(i, i * i));\n@@ -695,10 +669,8 @@ mod tests {\n             i += 1u;\n         }\n         debug!(\"str -> str\");\n-        let hasher_str: map::hashfn<~str> = str::hash;\n-        let eqer_str: map::eqfn<~str> = str::eq;\n         let hm_ss: map::hashmap<~str, ~str> =\n-            map::hashmap::<~str, ~str>(hasher_str, eqer_str);\n+            map::hashmap::<~str, ~str>();\n         i = 0u;\n         while i < num_to_insert {\n             assert hm_ss.insert(uint::to_str(i, 2u), uint::to_str(i * i, 2u));\n@@ -745,10 +717,8 @@ mod tests {\n         assert (hash(&0u) == hash(&1u));\n         assert (hash(&2u) == hash(&3u));\n         assert (hash(&0u) != hash(&2u));\n-        let hasher: map::hashfn<uint> = hash;\n-        let eqer: map::eqfn<uint> = eq;\n         let hm: map::hashmap<uint, uint> =\n-            map::hashmap::<uint, uint>(hasher, eqer);\n+            map::hashmap::<uint, uint>();\n         let mut i: uint = 0u;\n         while i < num_to_insert {\n             assert (hm.insert(i, i * i));\n@@ -808,7 +778,7 @@ mod tests {\n     #[test]\n     fn test_contains_key() {\n         let key = ~\"k\";\n-        let map = map::hashmap::<~str, ~str>(str::hash, str::eq);\n+        let map = map::hashmap::<~str, ~str>();\n         assert (!map.contains_key(key));\n         map.insert(key, ~\"val\");\n         assert (map.contains_key(key));\n@@ -817,7 +787,7 @@ mod tests {\n     #[test]\n     fn test_find() {\n         let key = ~\"k\";\n-        let map = map::hashmap::<~str, ~str>(str::hash, str::eq);\n+        let map = map::hashmap::<~str, ~str>();\n         assert (option::is_none(map.find(key)));\n         map.insert(key, ~\"val\");\n         assert (option::get(map.find(key)) == ~\"val\");\n@@ -826,7 +796,7 @@ mod tests {\n     #[test]\n     fn test_clear() {\n         let key = ~\"k\";\n-        let map = map::hashmap::<~str, ~str>(str::hash, str::eq);\n+        let map = map::hashmap::<~str, ~str>();\n         map.insert(key, ~\"val\");\n         assert (map.size() == 1);\n         assert (map.contains_key(key));"}, {"sha": "e2cfdd119b6233746aadbd98a3a3bc32d876909b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -310,6 +310,22 @@ enum binding_mode {\n     bind_by_implicit_ref\n }\n \n+impl binding_mode : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        match self {\n+          bind_by_value => 0u8.iter_bytes(lsb0, f),\n+\n+          bind_by_move => 1u8.iter_bytes(lsb0, f),\n+\n+          bind_by_ref(ref m) =>\n+          to_bytes::iter_bytes_2(&2u8, m, lsb0, f),\n+\n+          bind_by_implicit_ref =>\n+          3u8.iter_bytes(lsb0, f),\n+        }\n+    }\n+}\n+\n impl binding_mode : cmp::Eq {\n     pure fn eq(&&other: binding_mode) -> bool {\n         match self {\n@@ -368,6 +384,12 @@ enum pat_ {\n #[auto_serialize]\n enum mutability { m_mutbl, m_imm, m_const, }\n \n+impl mutability : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl mutability: cmp::Eq {\n     pure fn eq(&&other: mutability) -> bool {\n         (self as uint) == (other as uint)\n@@ -443,6 +465,18 @@ enum inferable<T> {\n     infer(node_id)\n }\n \n+impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        match self {\n+          expl(ref t) =>\n+          to_bytes::iter_bytes_2(&0u8, t, lsb0, f),\n+\n+          infer(ref n) =>\n+          to_bytes::iter_bytes_2(&1u8, n, lsb0, f),\n+        }\n+    }\n+}\n+\n impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n     pure fn eq(&&other: inferable<T>) -> bool {\n         match self {\n@@ -467,6 +501,13 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n #[auto_serialize]\n enum rmode { by_ref, by_val, by_mutbl_ref, by_move, by_copy }\n \n+impl rmode : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+\n impl rmode : cmp::Eq {\n     pure fn eq(&&other: rmode) -> bool {\n         (self as uint) == (other as uint)\n@@ -822,6 +863,12 @@ enum trait_method {\n #[auto_serialize]\n enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n+impl int_ty : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl int_ty: cmp::Eq {\n     pure fn eq(&&other: int_ty) -> bool {\n         match (self, other) {\n@@ -845,6 +892,12 @@ impl int_ty: cmp::Eq {\n #[auto_serialize]\n enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n+impl uint_ty : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl uint_ty: cmp::Eq {\n     pure fn eq(&&other: uint_ty) -> bool {\n         match (self, other) {\n@@ -866,6 +919,11 @@ impl uint_ty: cmp::Eq {\n #[auto_serialize]\n enum float_ty { ty_f, ty_f32, ty_f64, }\n \n+impl float_ty : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n impl float_ty: cmp::Eq {\n     pure fn eq(&&other: float_ty) -> bool {\n         match (self, other) {\n@@ -954,6 +1012,24 @@ enum ty_ {\n     ty_infer,\n }\n \n+// Equality and byte-iter (hashing) can be quite approximate for AST types.\n+// since we only care about this for normalizing them to \"real\" types.\n+impl ty : cmp::Eq {\n+    pure fn eq(&&other: ty) -> bool {\n+        ptr::addr_of(self) == ptr::addr_of(other)\n+    }\n+    pure fn ne(&&other: ty) -> bool {\n+        ptr::addr_of(self) != ptr::addr_of(other)\n+    }\n+}\n+\n+impl ty : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n+    }\n+}\n+\n+\n #[auto_serialize]\n type arg = {mode: mode, ty: @ty, ident: ident, id: node_id};\n \n@@ -971,6 +1047,12 @@ enum purity {\n     extern_fn, // declared with \"extern fn\"\n }\n \n+impl purity : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl purity : cmp::Eq {\n     pure fn eq(&&other: purity) -> bool {\n         (self as uint) == (other as uint)\n@@ -985,6 +1067,12 @@ enum ret_style {\n     return_val, // everything else\n }\n \n+impl ret_style : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl ret_style : cmp::Eq {\n     pure fn eq(&&other: ret_style) -> bool {\n         match (self, other) {\n@@ -1276,6 +1364,12 @@ enum item_ {\n #[auto_serialize]\n enum class_mutability { class_mutable, class_immutable }\n \n+impl class_mutability : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl class_mutability : cmp::Eq {\n     pure fn eq(&&other: class_mutability) -> bool {\n         match (self, other) {"}, {"sha": "97dcb922c4382b808d1f5ca09f4d528917092fa8", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -251,28 +251,16 @@ pure fn is_call_expr(e: @expr) -> bool {\n     match e.node { expr_call(_, _, _) => true, _ => false }\n }\n \n-pure fn eq_ty(a: &@ty, b: &@ty) -> bool { box::ptr_eq(*a, *b) }\n-\n-pure fn hash_ty(t: &@ty) -> uint {\n-    let res = (t.span.lo << 16u) + t.span.hi;\n-    return res;\n-}\n-\n-pure fn def_eq(a: &ast::def_id, b: &ast::def_id) -> bool {\n-    a.crate == b.crate && a.node == b.node\n-}\n-\n-pure fn hash_def(d: &ast::def_id) -> uint {\n-    let mut h = 5381u;\n-    h = (h << 5u) + h ^ (d.crate as uint);\n-    h = (h << 5u) + h ^ (d.node as uint);\n-    return h;\n+// This makes def_id hashable\n+impl def_id : core::to_bytes::IterBytes {\n+    #[inline(always)]\n+    fn iter_bytes(lsb0: bool, f: core::to_bytes::Cb) {\n+        core::to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f);\n+    }\n }\n \n fn new_def_hash<V: copy>() -> std::map::hashmap<ast::def_id, V> {\n-    let hasher: std::map::hashfn<ast::def_id> = hash_def;\n-    let eqer: std::map::eqfn<ast::def_id> = def_eq;\n-    return std::map::hashmap::<ast::def_id, V>(hasher, eqer);\n+    return std::map::hashmap::<ast::def_id, V>();\n }\n \n fn block_from_expr(e: @expr) -> blk {"}, {"sha": "cc1b049ab93ea9dcb0ae5d4a5754a326186eeb1d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -345,8 +345,7 @@ fn mk_ident_interner() -> ident_interner {\n                      @~\"dtor\", @~\"main\", @~\"<opaque>\", @~\"blk\", @~\"static\",\n                      @~\"intrinsic\", @~\"__foreign_mod__\"];\n \n-    let rv = interner::mk_prefill::<@~str>(|x| str::hash(*x),\n-                                           |x,y| str::eq(*x, *y), init_vec);\n+    let rv = interner::mk_prefill::<@~str>(init_vec);\n \n     /* having multiple interners will just confuse the serializer */\n     unsafe{ assert task::local_data_get(interner_key!()).is_none() };\n@@ -357,7 +356,7 @@ fn mk_ident_interner() -> ident_interner {\n /* for when we don't care about the contents; doesn't interact with TLD or\n    serialization */\n fn mk_fake_ident_interner() -> ident_interner {\n-    interner::mk::<@~str>(|x| str::hash(*x), |x,y| str::eq(*x, *y))\n+    interner::mk::<@~str>()\n }\n \n /**"}, {"sha": "59cdb6b98a7c96940e9ab21b4365f37c25ff5ef7", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -2,40 +2,39 @@\n // allows bidirectional lookup; i.e. given a value, one can easily find the\n // type, and vice versa.\n use std::map;\n-use std::map::{hashmap, hashfn, eqfn};\n+use std::map::hashmap;\n use dvec::DVec;\n+use cmp::Eq;\n+use hash::Hash;\n+use to_bytes::IterBytes;\n \n type hash_interner<T: const> =\n     {map: hashmap<T, uint>,\n-     vect: DVec<T>,\n-     hasher: hashfn<T>,\n-     eqer: eqfn<T>};\n+     vect: DVec<T>};\n \n-fn mk<T: const copy>(+hasher: hashfn<T>, +eqer: eqfn<T>) -> interner<T> {\n-    let m = map::hashmap::<T, uint>(copy hasher, copy eqer);\n+fn mk<T:Eq IterBytes Hash const copy>() -> interner<T> {\n+    let m = map::hashmap::<T, uint>();\n     let hi: hash_interner<T> =\n-        {map: m, vect: DVec(), hasher: hasher, eqer: eqer};\n+        {map: m, vect: DVec()};\n     return hi as interner::<T>;\n }\n \n-fn mk_prefill<T: const copy>(hasher: hashfn<T>, eqer: eqfn<T>,\n-                             init: ~[T]) -> interner<T> {\n-\n-    let rv = mk(copy hasher, copy eqer);\n+fn mk_prefill<T:Eq IterBytes Hash const copy>(init: ~[T]) -> interner<T> {\n+    let rv = mk();\n     for init.each() |v| { rv.intern(v); }\n     return rv;\n }\n \n \n /* when traits can extend traits, we should extend index<uint,T> to get [] */\n-trait interner<T: const copy> {\n+trait interner<T:Eq IterBytes Hash const copy> {\n     fn intern(T) -> uint;\n     fn gensym(T) -> uint;\n     pure fn get(uint) -> T;\n     fn len() -> uint;\n }\n \n-impl <T: const copy> hash_interner<T>: interner<T> {\n+impl <T:Eq IterBytes Hash const copy> hash_interner<T>: interner<T> {\n     fn intern(val: T) -> uint {\n         match self.map.find(val) {\n           Some(idx) => return idx,"}, {"sha": "4e529239401bdb3a8c6e228054cf2c124084fea9", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -1057,7 +1057,7 @@ fn name_has_type(tn: type_names, s: ~str) -> Option<TypeRef> {\n fn mk_type_names() -> type_names {\n     pure fn hash(t: &TypeRef) -> uint { *t as uint }\n     pure fn eq(a: &TypeRef, b: &TypeRef) -> bool { *a == *b }\n-    @{type_names: std::map::hashmap(hash, eq),\n+    @{type_names: std::map::hashmap(),\n       named_types: std::map::str_hash()}\n }\n "}, {"sha": "70f1258124565753ba2344276dc63b4c45080b8e", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -404,8 +404,24 @@ fn save_and_restore<T:copy,U>(&save_and_restore_t: T, f: fn() -> U) -> U {\n }\n \n /// Creates and returns a new root_map\n+\n+impl root_map_key : cmp::Eq {\n+    pure fn eq(&&other: root_map_key) -> bool {\n+        self.id == other.id && self.derefs == other.derefs\n+    }\n+    pure fn ne(&&other: root_map_key) -> bool {\n+        ! (self == other)\n+    }\n+}\n+\n+impl root_map_key : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n+    }\n+}\n+\n fn root_map() -> root_map {\n-    return hashmap(root_map_key_hash, root_map_key_eq);\n+    return hashmap();\n \n     pure fn root_map_key_eq(k1: &root_map_key, k2: &root_map_key) -> bool {\n         k1.id == k2.id && k1.derefs == k2.derefs"}, {"sha": "c34881abdfa23e0e6ebca8dce4bbc8fd0126a37d", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -309,7 +309,7 @@ fn Atom(n: uint) -> Atom {\n \n /// Creates a hash table of atoms.\n fn atom_hashmap<V:copy>() -> hashmap<Atom,V> {\n-  hashmap::<Atom,V>(|x| { uint::hash(*x) }, |x, y| { uint::eq(*x, *y) })\n+  hashmap::<Atom,V>()\n }\n \n /// One local scope."}, {"sha": "420893f29d4a40f02fe49780f3c2124df5e0ab30", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -2658,10 +2658,10 @@ fn trans_crate(sess: session::session,\n           tydescs: ty::new_ty_hash(),\n           mut finished_tydescs: false,\n           external: ast_util::new_def_hash(),\n-          monomorphized: map::hashmap(hash_mono_id, sys::shape_eq),\n+          monomorphized: map::hashmap(),\n           monomorphizing: ast_util::new_def_hash(),\n           type_use_cache: ast_util::new_def_hash(),\n-          vtables: map::hashmap(hash_mono_id, sys::shape_eq),\n+          vtables: map::hashmap(),\n           const_cstr_cache: map::str_hash(),\n           const_globals: int_hash::<ValueRef>(),\n           module_data: str_hash::<ValueRef>(),"}, {"sha": "75007312e113237ab4858f0855e82fa61640c133", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -1125,24 +1125,24 @@ impl mono_id_: cmp::Eq {\n     pure fn ne(&&other: mono_id_) -> bool { !self.eq(other) }\n }\n \n-pure fn hash_mono_id(mi: &mono_id) -> uint {\n-    let mut h = syntax::ast_util::hash_def(&mi.def);\n-    for vec::each(mi.params) |param| {\n-        h = h * match param {\n-          mono_precise(ty, vts) => {\n-            let mut h = ty::type_id(ty);\n-            do option::iter(vts) |vts| {\n-                for vec::each(vts) |vt| {\n-                    h += hash_mono_id(&vt);\n-                }\n-            }\n-            h\n-          }\n-          mono_any => 1u,\n-          mono_repr(sz, align) => sz * (align + 2u)\n+impl mono_param_id : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        match self {\n+          mono_precise(t, mids) =>\n+          to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), &mids, lsb0, f),\n+\n+          mono_any => 1u8.iter_bytes(lsb0, f),\n+\n+          mono_repr(a,b) =>\n+          to_bytes::iter_bytes_3(&2u8, &a, &b, lsb0, f)\n         }\n     }\n-    h\n+}\n+\n+impl mono_id_ : core::to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);\n+    }\n }\n \n fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {"}, {"sha": "6fee6f22fe01a7c4b3953cba0c1ad6e4c6b3b426", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -22,8 +22,34 @@ use option::is_some;\n \n use ty_ctxt = middle::ty::ctxt;\n \n-type nominal_id = @{did: ast::def_id, parent_id: Option<ast::def_id>,\n+type nominal_id_ = {did: ast::def_id, parent_id: Option<ast::def_id>,\n                     tps: ~[ty::t]};\n+type nominal_id = @nominal_id_;\n+\n+impl nominal_id_ : core::cmp::Eq {\n+    pure fn eq(&&other: nominal_id_) -> bool {\n+        if self.did != other.did ||\n+            self.parent_id != other.parent_id {\n+            false\n+        } else {\n+            do vec::all2(self.tps, other.tps) |m_tp, n_tp| {\n+                ty::type_id(m_tp) == ty::type_id(n_tp)\n+            }\n+        }\n+    }\n+    pure fn ne(&&other: nominal_id_) -> bool {\n+        ! (self == other)\n+    }\n+}\n+\n+impl nominal_id_ : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.did, &self.parent_id, lsb0, f);\n+        for self.tps.each |t| {\n+            ty::type_id(t).iter_bytes(lsb0, f);\n+        }\n+    }\n+}\n \n fn mk_nominal_id(tcx: ty::ctxt, did: ast::def_id,\n                  parent_id: Option<ast::def_id>,\n@@ -32,31 +58,8 @@ fn mk_nominal_id(tcx: ty::ctxt, did: ast::def_id,\n     @{did: did, parent_id: parent_id, tps: tps_norm}\n }\n \n-pure fn hash_nominal_id(ri: &nominal_id) -> uint {\n-    let mut h = 5381u;\n-    h *= 33u;\n-    h += ri.did.crate as uint;\n-    h *= 33u;\n-    h += ri.did.node as uint;\n-    for vec::each(ri.tps) |t| {\n-        h *= 33u;\n-        h += ty::type_id(t);\n-    }\n-    return h;\n-}\n-\n-pure fn eq_nominal_id(mi: &nominal_id, ni: &nominal_id) -> bool {\n-    if mi.did != ni.did {\n-        false\n-    } else {\n-        do vec::all2(mi.tps, ni.tps) |m_tp, n_tp| {\n-            ty::type_id(m_tp) == ty::type_id(n_tp)\n-        }\n-    }\n-}\n-\n fn new_nominal_id_hash<T: copy>() -> hashmap<nominal_id, T> {\n-    return hashmap(hash_nominal_id, eq_nominal_id);\n+    return hashmap();\n }\n \n type enum_data = {did: ast::def_id, substs: ty::substs};\n@@ -193,7 +196,7 @@ fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n          pad: 0u16,\n          tag_id_to_index: new_nominal_id_hash(),\n          tag_order: DVec(),\n-         resources: interner::mk(hash_nominal_id, eq_nominal_id),\n+         resources: interner::mk(),\n          llshapetablesty: llshapetablesty,\n          llshapetables: llshapetables};\n }"}, {"sha": "b8679a3818a30f2acf7adfca46f55fc6c42cfa2d", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 263, "deletions": 19, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -226,7 +226,25 @@ type field_ty = {\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-type creader_cache = hashmap<{cnum: int, pos: uint, len: uint}, t>;\n+type creader_cache_key = {cnum: int, pos: uint, len: uint};\n+type creader_cache = hashmap<creader_cache_key, t>;\n+\n+impl creader_cache_key : cmp::Eq {\n+    pure fn eq(&&other: creader_cache_key) -> bool {\n+        self.cnum == other.cnum &&\n+            self.pos == other.pos &&\n+            self.len == other.len\n+    }\n+    pure fn ne(&&other: creader_cache_key) -> bool {\n+        !(self == other)\n+    }\n+}\n+\n+impl creader_cache_key : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f);\n+    }\n+}\n \n type intern_key = {struct: sty, o_def_id: Option<ast::def_id>};\n \n@@ -237,6 +255,12 @@ impl intern_key: cmp::Eq {\n     pure fn ne(&&other: intern_key) -> bool { !self.eq(other) }\n }\n \n+impl intern_key : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.struct, &self.o_def_id, lsb0, f);\n+    }\n+}\n+\n enum ast_ty_to_ty_cache_entry {\n     atttce_unresolved,  /* not resolved yet */\n     atttce_resolved(t)  /* resolved to a type, irrespective of region */\n@@ -366,6 +390,12 @@ enum closure_kind {\n     ck_uniq,\n }\n \n+impl closure_kind : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl closure_kind : cmp::Eq {\n     pure fn eq(&&other: closure_kind) -> bool {\n         (self as uint) == (other as uint)\n@@ -378,6 +408,18 @@ enum fn_proto {\n     proto_vstore(vstore)\n }\n \n+impl fn_proto : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        match self {\n+          proto_bare =>\n+          0u8.iter_bytes(lsb0, f),\n+\n+          proto_vstore(ref v) =>\n+          to_bytes::iter_bytes_2(&1u8, v, lsb0, f)\n+        }\n+    }\n+}\n+\n impl fn_proto : cmp::Eq {\n     pure fn eq(&&other: fn_proto) -> bool {\n         match self {\n@@ -444,6 +486,13 @@ impl param_ty: cmp::Eq {\n     pure fn ne(&&other: param_ty) -> bool { !self.eq(other) }\n }\n \n+impl param_ty : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.idx, &self.def_id, lsb0, f)\n+    }\n+}\n+\n+\n /// Representation of regions:\n enum region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n@@ -606,6 +655,28 @@ enum InferTy {\n     IntVar(IntVid)\n }\n \n+impl InferTy : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        match self {\n+          TyVar(ref tv) => to_bytes::iter_bytes_2(&0u8, tv, lsb0, f),\n+          IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f)\n+        }\n+    }\n+}\n+\n+impl param_bound : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        match self {\n+          bound_copy => 0u8.iter_bytes(lsb0, f),\n+          bound_owned => 1u8.iter_bytes(lsb0, f),\n+          bound_send => 2u8.iter_bytes(lsb0, f),\n+          bound_const => 3u8.iter_bytes(lsb0, f),\n+          bound_trait(ref t) =>\n+          to_bytes::iter_bytes_2(&4u8, t, lsb0, f)\n+        }\n+    }\n+}\n+\n trait vid {\n     pure fn to_uint() -> uint;\n     pure fn to_str() -> ~str;\n@@ -657,6 +728,30 @@ impl purity: purity_to_str {\n     }\n }\n \n+impl RegionVid : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (*self).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+impl TyVid : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (*self).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+impl IntVid : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (*self).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+impl FnVid : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (*self).iter_bytes(lsb0, f)\n+    }\n+}\n+\n fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n     let mut kind = kind_noncopyable();\n     for vec::each(*bounds) |bound| {\n@@ -701,18 +796,11 @@ type node_type_table = @smallintmap::SmallIntMap<t>;\n \n fn mk_rcache() -> creader_cache {\n     type val = {cnum: int, pos: uint, len: uint};\n-    pure fn hash_cache_entry(k: &val) -> uint {\n-        (k.cnum as uint) + k.pos + k.len\n-    }\n-    pure fn eq_cache_entries(a: &val, b: &val) -> bool {\n-        a.cnum == b.cnum && a.pos == b.pos && a.len == b.len\n-    }\n-    return map::hashmap(hash_cache_entry, eq_cache_entries);\n+    return map::hashmap();\n }\n \n fn new_ty_hash<V: copy>() -> map::hashmap<t, V> {\n-    map::hashmap(|t: &t| type_id(*t),\n-                 |a: &t, b: &t| type_id(*a) == type_id(*b))\n+    map::hashmap()\n }\n \n fn mk_ctxt(s: session::session,\n@@ -721,11 +809,7 @@ fn mk_ctxt(s: session::session,\n            freevars: freevars::freevar_map,\n            region_map: middle::region::region_map,\n            region_paramd_items: middle::region::region_paramd_items) -> ctxt {\n-    pure fn hash_intern_key(k: &intern_key) -> uint {\n-        hash_type_structure(&k.struct) +\n-            option::map_default(k.o_def_id, 0u, |d| ast_util::hash_def(&d))\n-    }\n-    let interner = map::hashmap(hash_intern_key, sys::shape_eq);\n+    let interner = map::hashmap();\n     let vecs_implicitly_copyable =\n         get_lint_level(s.lint_settings.default_settings,\n                        lint::vecs_implicitly_copyable) == allow;\n@@ -750,8 +834,7 @@ fn mk_ctxt(s: session::session,\n       needs_drop_cache: new_ty_hash(),\n       needs_unwind_cleanup_cache: new_ty_hash(),\n       kind_cache: new_ty_hash(),\n-      ast_ty_to_ty_cache: map::hashmap(\n-          ast_util::hash_ty, ast_util::eq_ty),\n+      ast_ty_to_ty_cache: map::hashmap(),\n       enum_var_cache: new_def_hash(),\n       trait_method_cache: new_def_hash(),\n       ty_param_bounds: map::int_hash(),\n@@ -2314,6 +2397,167 @@ fn index_sty(cx: ctxt, sty: &sty) -> Option<mt> {\n     }\n }\n \n+impl bound_region : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        match self {\n+          ty::br_self => 0u8.iter_bytes(lsb0, f),\n+\n+          ty::br_anon(ref idx) =>\n+          to_bytes::iter_bytes_2(&1u8, idx, lsb0, f),\n+\n+          ty::br_named(ref ident) =>\n+          to_bytes::iter_bytes_2(&2u8, ident, lsb0, f),\n+\n+          ty::br_cap_avoid(ref id, ref br) =>\n+          to_bytes::iter_bytes_3(&3u8, id, br, lsb0, f)\n+        }\n+    }\n+}\n+\n+impl region : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        match self {\n+          re_bound(ref br) =>\n+          to_bytes::iter_bytes_2(&0u8, br, lsb0, f),\n+\n+          re_free(ref id, ref br) =>\n+          to_bytes::iter_bytes_3(&1u8, id, br, lsb0, f),\n+\n+          re_scope(ref id) =>\n+          to_bytes::iter_bytes_2(&2u8, id, lsb0, f),\n+\n+          re_var(ref id) =>\n+          to_bytes::iter_bytes_2(&3u8, id, lsb0, f),\n+\n+          re_static => 4u8.iter_bytes(lsb0, f)\n+        }\n+    }\n+}\n+\n+impl vstore : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        match self {\n+          vstore_fixed(ref u) =>\n+          to_bytes::iter_bytes_2(&0u8, u, lsb0, f),\n+\n+          vstore_uniq => 1u8.iter_bytes(lsb0, f),\n+          vstore_box => 2u8.iter_bytes(lsb0, f),\n+\n+          vstore_slice(ref r) =>\n+          to_bytes::iter_bytes_2(&3u8, r, lsb0, f),\n+        }\n+    }\n+}\n+\n+impl substs : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+          to_bytes::iter_bytes_3(&self.self_r,\n+                                 &self.self_ty,\n+                                 &self.tps, lsb0, f)\n+    }\n+}\n+\n+impl mt : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+          to_bytes::iter_bytes_2(&self.ty,\n+                                 &self.mutbl, lsb0, f)\n+    }\n+}\n+\n+impl field : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+          to_bytes::iter_bytes_2(&self.ident,\n+                                 &self.mt, lsb0, f)\n+    }\n+}\n+\n+impl arg : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+          to_bytes::iter_bytes_2(&self.mode,\n+                                 &self.ty, lsb0, f)\n+    }\n+}\n+\n+impl sty : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        match self {\n+          ty_nil => 0u8.iter_bytes(lsb0, f),\n+          ty_bool => 1u8.iter_bytes(lsb0, f),\n+\n+          ty_int(ref t) =>\n+          to_bytes::iter_bytes_2(&2u8, t, lsb0, f),\n+\n+          ty_uint(ref t) =>\n+          to_bytes::iter_bytes_2(&3u8, t, lsb0, f),\n+\n+          ty_float(ref t) =>\n+          to_bytes::iter_bytes_2(&4u8, t, lsb0, f),\n+\n+          ty_estr(ref v) =>\n+          to_bytes::iter_bytes_2(&5u8, v, lsb0, f),\n+\n+          ty_enum(ref did, ref substs) =>\n+          to_bytes::iter_bytes_3(&6u8, did, substs, lsb0, f),\n+\n+          ty_box(ref mt) =>\n+          to_bytes::iter_bytes_2(&7u8, mt, lsb0, f),\n+\n+          ty_evec(ref mt, ref v) =>\n+          to_bytes::iter_bytes_3(&8u8, mt, v, lsb0, f),\n+\n+          ty_unboxed_vec(ref mt) =>\n+          to_bytes::iter_bytes_2(&9u8, mt, lsb0, f),\n+\n+          ty_tup(ref ts) =>\n+          to_bytes::iter_bytes_2(&10u8, ts, lsb0, f),\n+\n+          ty_rec(ref fs) =>\n+          to_bytes::iter_bytes_2(&11u8, fs, lsb0, f),\n+\n+          ty_fn(ref ft) =>\n+          to_bytes::iter_bytes_7(&12u8,\n+                                 &ft.meta.purity,\n+                                 &ft.meta.proto,\n+                                 &ft.meta.bounds,\n+                                 &ft.sig.inputs,\n+                                 &ft.sig.output,\n+                                 &ft.meta.ret_style,\n+                                 lsb0, f),\n+\n+          ty_self => 13u8.iter_bytes(lsb0, f),\n+\n+          ty_infer(ref v) =>\n+          to_bytes::iter_bytes_2(&14u8, v, lsb0, f),\n+\n+          ty_param(ref p) =>\n+          to_bytes::iter_bytes_2(&15u8, p, lsb0, f),\n+\n+          ty_type => 16u8.iter_bytes(lsb0, f),\n+          ty_bot => 17u8.iter_bytes(lsb0, f),\n+\n+          ty_ptr(ref mt) =>\n+          to_bytes::iter_bytes_2(&18u8, mt, lsb0, f),\n+\n+          ty_uniq(ref mt) =>\n+          to_bytes::iter_bytes_2(&19u8, mt, lsb0, f),\n+\n+          ty_trait(ref did, ref substs, ref v) =>\n+          to_bytes::iter_bytes_4(&20u8, did, substs, v, lsb0, f),\n+\n+          ty_opaque_closure_ptr(ref ck) =>\n+          to_bytes::iter_bytes_2(&21u8, ck, lsb0, f),\n+\n+          ty_opaque_box => 22u8.iter_bytes(lsb0, f),\n+\n+          ty_class(ref did, ref substs) =>\n+          to_bytes::iter_bytes_3(&23u8, did, substs, lsb0, f),\n+\n+          ty_rptr(ref r, ref mt) =>\n+          to_bytes::iter_bytes_3(&24u8, r, mt, lsb0, f),\n+        }\n+    }\n+}\n+\n pure fn hash_bound_region(br: &bound_region) -> uint {\n     match *br { // no idea if this is any good\n       ty::br_self => 0u,\n@@ -2325,7 +2569,7 @@ pure fn hash_bound_region(br: &bound_region) -> uint {\n }\n \n fn br_hashmap<V:copy>() -> hashmap<bound_region, V> {\n-    map::hashmap(hash_bound_region, sys::shape_eq)\n+    map::hashmap()\n }\n \n pure fn hash_region(r: &region) -> uint {\n@@ -3328,7 +3572,7 @@ fn enum_variant_with_id(cx: ctxt, enum_id: ast::def_id,\n     let mut i = 0u;\n     while i < vec::len::<variant_info>(*variants) {\n         let variant = variants[i];\n-        if ast_util::def_eq(&variant.id, &variant_id) { return variant; }\n+        if variant.id == variant_id { return variant; }\n         i += 1u;\n     }\n     cx.sess.bug(~\"enum_variant_with_id(): no variant exists with that ID\");"}, {"sha": "3c51c22bf05546d87f5b8d385eaa188cae760aff", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -349,6 +349,21 @@ impl Constraint: cmp::Eq {\n     pure fn ne(&&other: Constraint) -> bool { !self.eq(other) }\n }\n \n+impl Constraint : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        match self {\n+          ConstrainVarSubVar(ref v0, ref v1) =>\n+          to_bytes::iter_bytes_3(&0u8, v0, v1, lsb0, f),\n+\n+          ConstrainRegSubVar(ref ra, ref va) =>\n+          to_bytes::iter_bytes_3(&1u8, ra, va, lsb0, f),\n+\n+          ConstrainVarSubReg(ref va, ref ra) =>\n+          to_bytes::iter_bytes_3(&2u8, va, ra, lsb0, f)\n+        }\n+    }\n+}\n+\n struct TwoRegions {\n     a: region,\n     b: region,\n@@ -361,6 +376,12 @@ impl TwoRegions: cmp::Eq {\n     pure fn ne(&&other: TwoRegions) -> bool { !self.eq(other) }\n }\n \n+impl TwoRegions : to_bytes::IterBytes {\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.a, &self.b, lsb0, f)\n+    }\n+}\n+\n enum UndoLogEntry {\n     Snapshot,\n     AddVar(RegionVid),\n@@ -394,7 +415,7 @@ fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n         tcx: tcx,\n         var_spans: DVec(),\n         values: empty_cell(),\n-        constraints: hashmap(hash_constraint, sys::shape_eq),\n+        constraints: hashmap(),\n         lubs: CombineMap(),\n         glbs: CombineMap(),\n         undo_log: DVec()\n@@ -405,16 +426,7 @@ fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n // `b`!  Not obvious that this is the most efficient way to go about\n // it.\n fn CombineMap() -> CombineMap {\n-    return hashmap(hash_two_regions, eq_two_regions);\n-\n-    pure fn hash_two_regions(rc: &TwoRegions) -> uint {\n-        hash_region(&rc.a) ^ hash_region(&rc.b)\n-    }\n-\n-    pure fn eq_two_regions(rc1: &TwoRegions, rc2: &TwoRegions) -> bool {\n-        (rc1.a == rc2.a && rc1.b == rc2.b) ||\n-            (rc1.a == rc2.b && rc1.b == rc2.a)\n-    }\n+    return hashmap();\n }\n \n pure fn hash_constraint(rc: &Constraint) -> uint {\n@@ -795,11 +807,7 @@ struct SpannedRegion {\n type TwoRegionsMap = hashmap<TwoRegions, ()>;\n \n fn TwoRegionsMap() -> TwoRegionsMap {\n-    return hashmap(hash_two_regions, sys::shape_eq);\n-\n-    pure fn hash_two_regions(rc: &TwoRegions) -> uint {\n-        hash_region(&rc.a) ^ (hash_region(&rc.b) << 2)\n-    }\n+    return hashmap();\n }\n \n impl RegionVarBindings {"}, {"sha": "49ea43439d19bb93b94aa1caa58c93b33b304762", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -5,8 +5,7 @@ use std::map;\n \n fn main() {\n     let buggy_map :hashmap<uint, &uint> =\n-      hashmap::<uint, &uint>(|x| { uint::hash(*x) },\n-                             |x, y| { uint::eq(*x, *y) });\n+      hashmap::<uint, &uint>();\n     buggy_map.insert(42, ~1); //~ ERROR illegal borrow\n     \n     // but it is ok if we use a temporary"}, {"sha": "28c6e7222e28de4d803d383a81cb41de217d4608", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -1,7 +1,6 @@\n mod argparse {\n     use std;\n \n-    import std::map;\n     import either::{Either, Left, Right};\n \n     struct Flag {"}, {"sha": "5af2191c151b1898c4d3fba51f8184b534861e70", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5d823d46ad5350e095a531d847464f42c5f29261/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d823d46ad5350e095a531d847464f42c5f29261/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=5d823d46ad5350e095a531d847464f42c5f29261", "patch": "@@ -6,19 +6,13 @@ use std::map::hashmap;\n \n fn main() {\n     let count = @mut 0u;\n-    pure fn hash(s: &~[@~str]) -> uint {\n-        if vec::len(*s) > 0u && *s[0] == ~\"boom\" { fail; }\n-        return 10u;\n-    }\n-    pure fn eq(s: &~[@~str], t: &~[@~str]) -> bool {\n-        return *s == *t;\n-    }\n-\n-    let map = map::hashmap(hash, eq);\n+    let map = map::hashmap();\n     let mut arr = ~[];\n     for uint::range(0u, 10u) |i| {\n         arr += ~[@~\"key stuff\"];\n         map.insert(arr, arr + ~[@~\"value stuff\"]);\n+        if arr.len() == 5 {\n+            fail;\n+        }\n     }\n-    map.insert(~[@~\"boom\"], ~[]);\n }"}]}