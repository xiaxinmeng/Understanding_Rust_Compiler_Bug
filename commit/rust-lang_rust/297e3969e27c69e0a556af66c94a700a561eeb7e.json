{"sha": "297e3969e27c69e0a556af66c94a700a561eeb7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5N2UzOTY5ZTI3YzY5ZTBhNTU2YWY2NmM5NGE3MDBhNTYxZWViN2U=", "commit": {"author": {"name": "ubsan", "email": "npmazzuca@gmail.com", "date": "2016-07-06T03:12:37Z"}, "committer": {"name": "ubsan", "email": "npmazzuca@gmail.com", "date": "2016-07-06T03:12:37Z"}, "message": "Merge upstream/master: Fix a weird bug", "tree": {"sha": "dfd9d03b30f851658af54e82e387b5a4a43fa202", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfd9d03b30f851658af54e82e387b5a4a43fa202"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/297e3969e27c69e0a556af66c94a700a561eeb7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/297e3969e27c69e0a556af66c94a700a561eeb7e", "html_url": "https://github.com/rust-lang/rust/commit/297e3969e27c69e0a556af66c94a700a561eeb7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/297e3969e27c69e0a556af66c94a700a561eeb7e/comments", "author": {"login": "ubsan", "id": 60298436, "node_id": "MDQ6VXNlcjYwMjk4NDM2", "avatar_url": "https://avatars.githubusercontent.com/u/60298436?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubsan", "html_url": "https://github.com/ubsan", "followers_url": "https://api.github.com/users/ubsan/followers", "following_url": "https://api.github.com/users/ubsan/following{/other_user}", "gists_url": "https://api.github.com/users/ubsan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubsan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubsan/subscriptions", "organizations_url": "https://api.github.com/users/ubsan/orgs", "repos_url": "https://api.github.com/users/ubsan/repos", "events_url": "https://api.github.com/users/ubsan/events{/privacy}", "received_events_url": "https://api.github.com/users/ubsan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubsan", "id": 60298436, "node_id": "MDQ6VXNlcjYwMjk4NDM2", "avatar_url": "https://avatars.githubusercontent.com/u/60298436?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubsan", "html_url": "https://github.com/ubsan", "followers_url": "https://api.github.com/users/ubsan/followers", "following_url": "https://api.github.com/users/ubsan/following{/other_user}", "gists_url": "https://api.github.com/users/ubsan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubsan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubsan/subscriptions", "organizations_url": "https://api.github.com/users/ubsan/orgs", "repos_url": "https://api.github.com/users/ubsan/repos", "events_url": "https://api.github.com/users/ubsan/events{/privacy}", "received_events_url": "https://api.github.com/users/ubsan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "451af791dadf5a38da2fe63d578c083b95d6c10a", "url": "https://api.github.com/repos/rust-lang/rust/commits/451af791dadf5a38da2fe63d578c083b95d6c10a", "html_url": "https://github.com/rust-lang/rust/commit/451af791dadf5a38da2fe63d578c083b95d6c10a"}, {"sha": "731d37561971d80f5d7ccaba8c2affcf39965917", "url": "https://api.github.com/repos/rust-lang/rust/commits/731d37561971d80f5d7ccaba8c2affcf39965917", "html_url": "https://github.com/rust-lang/rust/commit/731d37561971d80f5d7ccaba8c2affcf39965917"}], "stats": {"total": 5711, "additions": 3610, "deletions": 2101}, "files": [{"sha": "49236d6b671ef74cb8f4bb8f90d35171d243dc88", "filename": "README.md", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1,7 +1,7 @@\n # The Rust Programming Language\n \n-This is the main source code repository for [Rust]. It contains the compiler, standard library,\n-and documentation.\n+This is the main source code repository for [Rust]. It contains the compiler,\n+standard library, and documentation.\n \n [Rust]: https://www.rust-lang.org\n \n@@ -64,37 +64,37 @@ build.\n \n #### MinGW\n \n-[MSYS2](http://msys2.github.io/) can be used to easily build Rust on Windows:\n+[MSYS2][msys2] can be used to easily build Rust on Windows:\n \n-1. Grab the latest MSYS2 installer and go through the installer.\n+msys2: https://msys2.github.io/\n \n-2. From the MSYS2 terminal, install the `mingw64` toolchain and other required\n-   tools.\n+1. Grab the latest [MSYS2 installer][msys2] and go through the installer.\n \n-   ```sh\n-   # Update package mirrors (may be needed if you have a fresh install of MSYS2)\n-   $ pacman -Sy pacman-mirrors\n-   ```\n+2. Run `mingw32_shell.bat` or `mingw64_shell.bat` from wherever you installed\n+   MSYS2 (i.e. `C:\\msys64`), depending on whether you want 32-bit or 64-bit\n+   Rust. (As of the latest version of MSYS2 you have to run `msys2_shell.cmd\n+   -mingw32` or `msys2_shell.cmd -mingw64` from the command line instead)\n \n-   Download [MinGW from\n-   here](http://mingw-w64.org/doku.php/download/mingw-builds), and choose the\n-   `version=4.9.x,threads=win32,exceptions=dwarf/seh` flavor when installing. Also, make sure to install to a path without spaces in it. After installing,\n-   add its `bin` directory to your `PATH`. This is due to [#28260](https://github.com/rust-lang/rust/issues/28260), in the future,\n-   installing from pacman should be just fine.\n+3. From this terminal, install the required tools:\n \n    ```sh\n-   # Make git available in MSYS2 (if not already available on path)\n-   $ pacman -S git\n+   # Update package mirrors (may be needed if you have a fresh install of MSYS2)\n+   $ pacman -Sy pacman-mirrors\n \n-   $ pacman -S base-devel\n+   # Install build tools needed for Rust. If you're building a 32-bit compiler,\n+   # then replace \"x86_64\" below with \"i686\". If you've already got git, python,\n+   # or CMake installed and in PATH you can remove them from this list. Note\n+   # that it is important that the `python2` and `cmake` packages **not** used.\n+   # The build has historically been known to fail with these packages.\n+   $ pacman -S git \\\n+               make \\\n+               diffutils \\\n+               mingw-w64-x86_64-python2 \\\n+               mingw-w64-x86_64-cmake \\\n+               mingw-w64-x86_64-gcc\n    ```\n \n-3. Run `mingw32_shell.bat` or `mingw64_shell.bat` from wherever you installed\n-   MSYS2 (i.e. `C:\\msys`), depending on whether you want 32-bit or 64-bit Rust.\n-   (As of the latest version of MSYS2 you have to run `msys2_shell.cmd -mingw32`\n-   or `msys2_shell.cmd -mingw64` from the command line instead)\n-\n-4. Navigate to Rust's source code, configure and build it:\n+4. Navigate to Rust's source code (or clone it), then configure and build it:\n \n    ```sh\n    $ ./configure\n@@ -114,12 +114,25 @@ $ ./configure\n $ make && make install\n ```\n \n+#### MSVC with rustbuild\n+\n+For those who don't want the hassle of MSYS or MinGW, you can invoke rustbuild\n+directly. All you need are Python 2, CMake, and Git in your PATH (make sure you\n+do __not__ use the ones from MSYS!). You'll also need Visual Studio 2013 or\n+newer with the C++ tools. Then all you need to do is invoke the appropriate\n+vcvars bat file and kick off rustbuild.\n+\n+```bat\n+CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.bat\"\n+python .\\src\\bootstrap\\bootstrap.py\n+```\n+\n ## Building Documentation\n \n If you\u2019d like to build the documentation, it\u2019s almost the same:\n \n ```sh\n-./configure\n+$ ./configure\n $ make docs\n ```\n \n@@ -154,8 +167,8 @@ Snapshot binaries are currently built and tested on several platforms:\n You may find that other platforms work, but these are our officially\n supported build environments that are most likely to work.\n \n-Rust currently needs between 600MiB and 1.5GiB to build, depending on platform. If it hits\n-swap, it will take a very long time to build.\n+Rust currently needs between 600MiB and 1.5GiB to build, depending on platform.\n+If it hits swap, it will take a very long time to build.\n \n There is more advice about hacking on Rust in [CONTRIBUTING.md].\n \n@@ -192,4 +205,5 @@ Rust is primarily distributed under the terms of both the MIT license\n and the Apache License (Version 2.0), with portions covered by various\n BSD-like licenses.\n \n-See [LICENSE-APACHE](LICENSE-APACHE), [LICENSE-MIT](LICENSE-MIT), and [COPYRIGHT](COPYRIGHT) for details.\n+See [LICENSE-APACHE](LICENSE-APACHE), [LICENSE-MIT](LICENSE-MIT), and\n+[COPYRIGHT](COPYRIGHT) for details."}, {"sha": "ffe8d64ff2da4c71b64338b88b460a5946f63b05", "filename": "RELEASES.md", "status": "modified", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1,3 +1,315 @@\n+Version 1.10.0 (2016-07-07)\n+===========================\n+\n+Language\n+--------\n+\n+* [Allow `concat_idents!` in type positions as well as in expression\n+  positions]\n+  (https://github.com/rust-lang/rust/pull/33735).\n+* [`Copy` types are required to have a trivial implementation of `Clone`]\n+  (https://github.com/rust-lang/rust/pull/33420).\n+  [RFC 1521](https://github.com/rust-lang/rfcs/blob/master/text/1521-copy-clone-semantics.md).\n+* [Single-variant enums support the `#[repr(..)]` attribute]\n+  (https://github.com/rust-lang/rust/pull/33355).\n+* [Fix `#[derive(RustcEncodable)]` in the presence of other `encode` methods]\n+  (https://github.com/rust-lang/rust/pull/32908).\n+* [`panic!` can be converted to a runtime abort with the\n+  `-C panic=abort` flag]\n+  (https://github.com/rust-lang/rust/pull/32900).\n+  [RFC 1513](https://github.com/rust-lang/rfcs/blob/master/text/1513-less-unwinding.md).\n+* [Add a new crate type, 'cdylib']\n+  (https://github.com/rust-lang/rust/pull/33553).\n+  cdylibs are dynamic libraries suitable for loading by non-Rust hosts.\n+  [RFC 1510](https://github.com/rust-lang/rfcs/blob/master/text/1510-rdylib.md).\n+  Note that Cargo does not yet directly support cdylibs.\n+\n+Stabilized APIs\n+---------------\n+\n+* `os::windows::fs::OpenOptionsExt::access_mode`\n+* `os::windows::fs::OpenOptionsExt::share_mode`\n+* `os::windows::fs::OpenOptionsExt::custom_flags`\n+* `os::windows::fs::OpenOptionsExt::attributes`\n+* `os::windows::fs::OpenOptionsExt::security_qos_flags`\n+* `os::unix::fs::OpenOptionsExt::custom_flags`\n+* [`sync::Weak::new`]\n+  (http://doc.rust-lang.org/alloc/arc/struct.Weak.html#method.new)\n+* `Default for sync::Weak`\n+* [`panic::set_hook`]\n+  (http://doc.rust-lang.org/std/panic/fn.set_hook.html)\n+* [`panic::take_hook`]\n+  (http://doc.rust-lang.org/std/panic/fn.take_hook.html)\n+* [`panic::PanicInfo`]\n+  (http://doc.rust-lang.org/std/panic/struct.PanicInfo.html)\n+* [`panic::PanicInfo::payload`]\n+  (http://doc.rust-lang.org/std/panic/struct.PanicInfo.html#method.payload)\n+* [`panic::PanicInfo::location`]\n+  (http://doc.rust-lang.org/std/panic/struct.PanicInfo.html#method.location)\n+* [`panic::Location`]\n+  (http://doc.rust-lang.org/std/panic/struct.Location.html)\n+* [`panic::Location::file`]\n+  (http://doc.rust-lang.org/std/panic/struct.Location.html#method.file)\n+* [`panic::Location::line`]\n+  (http://doc.rust-lang.org/std/panic/struct.Location.html#method.line)\n+* [`ffi::CStr::from_bytes_with_nul`]\n+  (http://doc.rust-lang.org/std/ffi/struct.CStr.html#method.from_bytes_with_nul)\n+* [`ffi::CStr::from_bytes_with_nul_unchecked`]\n+  (http://doc.rust-lang.org/std/ffi/struct.CStr.html#method.from_bytes_with_nul_unchecked)\n+* [`ffi::FromBytesWithNulError`]\n+  (http://doc.rust-lang.org/std/ffi/struct.FromBytesWithNulError.html)\n+* [`fs::Metadata::modified`]\n+  (http://doc.rust-lang.org/std/fs/struct.Metadata.html#method.modified)\n+* [`fs::Metadata::accessed`]\n+  (http://doc.rust-lang.org/std/fs/struct.Metadata.html#method.accessed)\n+* [`fs::Metadata::created`]\n+  (http://doc.rust-lang.org/std/fs/struct.Metadata.html#method.created)\n+* `sync::atomic::Atomic{Usize,Isize,Bool,Ptr}::compare_exchange`\n+* `sync::atomic::Atomic{Usize,Isize,Bool,Ptr}::compare_exchange_weak`\n+* `collections::{btree,hash}_map::{Occupied,Vacant,}Entry::key`\n+* `os::unix::net::{UnixStream, UnixListener, UnixDatagram, SocketAddr}`\n+* [`SocketAddr::is_unnamed`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.SocketAddr.html#method.is_unnamed)\n+* [`SocketAddr::as_pathname`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.SocketAddr.html#method.as_pathname)\n+* [`UnixStream::connect`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#method.connect)\n+* [`UnixStream::pair`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#method.pair)\n+* [`UnixStream::try_clone`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#method.try_clone)\n+* [`UnixStream::local_addr`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#method.local_addr)\n+* [`UnixStream::peer_addr`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#method.peer_addr)\n+* [`UnixStream::set_read_timeout`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#method.read_timeout)\n+* [`UnixStream::set_write_timeout`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#method.write_timeout)\n+* [`UnixStream::read_timeout`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#method.read_timeout)\n+* [`UnixStream::write_timeout`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#method.write_timeout)\n+* [`UnixStream::set_nonblocking`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#method.set_nonblocking)\n+* [`UnixStream::take_error`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#method.take_error)\n+* [`UnixStream::shutdown`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#method.shutdown)\n+* Read/Write/RawFd impls for `UnixStream`\n+* [`UnixListener::bind`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixListener.html#method.bind)\n+* [`UnixListener::accept`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixListener.html#method.accept)\n+* [`UnixListener::try_clone`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixListener.html#method.try_clone)\n+* [`UnixListener::local_addr`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixListener.html#method.local_addr)\n+* [`UnixListener::set_nonblocking`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixListener.html#method.set_nonblocking)\n+* [`UnixListener::take_error`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixListener.html#method.take_error)\n+* [`UnixListener::incoming`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixListener.html#method.incoming)\n+* RawFd impls for `UnixListener`\n+* [`UnixDatagram::bind`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.bind)\n+* [`UnixDatagram::unbound`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.unbound)\n+* [`UnixDatagram::pair`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.pair)\n+* [`UnixDatagram::connect`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.connect)\n+* [`UnixDatagram::try_clone`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.try_clone)\n+* [`UnixDatagram::local_addr`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.local_addr)\n+* [`UnixDatagram::peer_addr`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.peer_addr)\n+* [`UnixDatagram::recv_from`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.recv_from)\n+* [`UnixDatagram::recv`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.recv)\n+* [`UnixDatagram::send_to`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.send_to)\n+* [`UnixDatagram::send`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.send)\n+* [`UnixDatagram::set_read_timeout`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.set_read_timeout)\n+* [`UnixDatagram::set_write_timeout`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.set_write_timeout)\n+* [`UnixDatagram::read_timeout`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.read_timeout)\n+* [`UnixDatagram::write_timeout`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.write_timeout)\n+* [`UnixDatagram::set_nonblocking`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.set_nonblocking)\n+* [`UnixDatagram::take_error`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.take_error)\n+* [`UnixDatagram::shutdown`]\n+  (http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.shutdown)\n+* RawFd impls for `UnixDatagram`\n+* `{BTree,Hash}Map::values_mut`\n+* [`<[_]>::binary_search_by_key`]\n+  (http://doc.rust-lang.org/beta/std/primitive.slice.html#method.binary_search_by_key)\n+\n+Libraries\n+---------\n+\n+* [The `abs_sub` method of floats is deprecated]\n+  (https://github.com/rust-lang/rust/pull/33664).\n+  The semantics of this minor method are subtle and probably not what\n+  most people want.\n+* [Add implementation of Ord for Cell<T> and RefCell<T> where T: Ord]\n+  (https://github.com/rust-lang/rust/pull/33306).\n+* [On Linux, if `HashMap`s can't be initialized with `getrandom` they\n+  will fall back to `/dev/urandom` temporarily to avoid blocking\n+  during early boot]\n+  (https://github.com/rust-lang/rust/pull/33086).\n+* [Implemented negation for wrapping numerals]\n+  (https://github.com/rust-lang/rust/pull/33067).\n+* [Implement `Clone` for `binary_heap::IntoIter`]\n+  (https://github.com/rust-lang/rust/pull/33050).\n+* [Implement `Display` and `Hash` for `std::num::Wrapping`]\n+  (https://github.com/rust-lang/rust/pull/33023).\n+* [Add `Default` implementation for `&CStr`, `CString`, `Path`]\n+  (https://github.com/rust-lang/rust/pull/32990).\n+* [Implement `From<Vec<T>>` and `Into<Vec<T>>` for `VecDeque<T>`]\n+  (https://github.com/rust-lang/rust/pull/32866).\n+* [Implement `Default` for `UnsafeCell`, `fmt::Error`, `Condvar`,\n+  `Mutex`, `RwLock`]\n+  (https://github.com/rust-lang/rust/pull/32785).\n+\n+Cargo\n+-----\n+* [Cargo.toml supports the `profile.*.panic` option]\n+  (https://github.com/rust-lang/cargo/pull/2687).\n+  This controls the runtime behavior of the `panic!` macro\n+  and can be either \"unwind\" (the default), or \"abort\".\n+  [RFC 1513](https://github.com/rust-lang/rfcs/blob/master/text/1513-less-unwinding.md).\n+* [Don't throw away errors with `-p` arguments]\n+  (https://github.com/rust-lang/cargo/pull/2723).\n+* [Report status to stderr instead of stdout]\n+  (https://github.com/rust-lang/cargo/pull/2693).\n+* [Build scripts are passed a `CARGO_MANIFEST_LINKS` environment\n+  variable that corresponds to the `links` field of the manifest]\n+  (https://github.com/rust-lang/cargo/pull/2710).\n+* [Ban keywords from crate names]\n+  (https://github.com/rust-lang/cargo/pull/2707).\n+* [Canonicalize `CARGO_HOME` on Windows]\n+  (https://github.com/rust-lang/cargo/pull/2604).\n+* [Retry network requests]\n+  (https://github.com/rust-lang/cargo/pull/2396).\n+  By default they are retried twice, which can be customized with the\n+  `net.retry` value in `.cargo/config`.\n+* [Don't print extra error info for failing subcommands]\n+  (https://github.com/rust-lang/cargo/pull/2674).\n+* [Add `--force` flag to `cargo install`]\n+  (https://github.com/rust-lang/cargo/pull/2405).\n+* [Don't use `flock` on NFS mounts]\n+  (https://github.com/rust-lang/cargo/pull/2623).\n+* [Prefer building `cargo install` artifacts in temporary directories]\n+  (https://github.com/rust-lang/cargo/pull/2610).\n+  Makes it possible to install multiple crates in parallel.\n+* [Add `cargo test --doc`]\n+  (https://github.com/rust-lang/cargo/pull/2578).\n+* [Add `cargo --explain`]\n+  (https://github.com/rust-lang/cargo/pull/2551).\n+* [Don't print warnings when `-q` is passed]\n+  (https://github.com/rust-lang/cargo/pull/2576).\n+* [Add `cargo doc --lib` and `--bin`]\n+  (https://github.com/rust-lang/cargo/pull/2577).\n+* [Don't require build script output to be UTF-8]\n+  (https://github.com/rust-lang/cargo/pull/2560).\n+* [Correctly attempt multiple git usernames]\n+  (https://github.com/rust-lang/cargo/pull/2584).\n+\n+Performance\n+-----------\n+\n+* [rustc memory usage was reduced by refactoring the context used for\n+  type checking]\n+  (https://github.com/rust-lang/rust/pull/33425).\n+* [Speed up creation of `HashMap`s by caching the random keys used\n+  to initialize the hash state]\n+  (https://github.com/rust-lang/rust/pull/33318).\n+* [The `find` implementation for `Chain` iterators is 2x faster]\n+  (https://github.com/rust-lang/rust/pull/33289).\n+* [Trait selection optimizations speed up type checking by 15%]\n+  (https://github.com/rust-lang/rust/pull/33138).\n+* [Efficient trie lookup for boolean Unicode properties]\n+  (https://github.com/rust-lang/rust/pull/33098).\n+  10x faster than the previous lookup tables.\n+* [Special case `#[derive(Copy, Clone)]` to avoid bloat]\n+  (https://github.com/rust-lang/rust/pull/31414).\n+\n+Usability\n+---------\n+\n+* Many incremental improvements to documentation and rustdoc.\n+* [rustdoc: List blanket trait impls]\n+  (https://github.com/rust-lang/rust/pull/33514).\n+* [rustdoc: Clean up ABI rendering]\n+  (https://github.com/rust-lang/rust/pull/33151).\n+* [Indexing with the wrong type produces a more informative error]\n+  (https://github.com/rust-lang/rust/pull/33401).\n+* [Improve diagnostics for constants being used in irrefutable patterns]\n+  (https://github.com/rust-lang/rust/pull/33406).\n+* [When many method candidates are in scope limit the suggestions to 10]\n+  (https://github.com/rust-lang/rust/pull/33338).\n+* [Remove confusing suggestion when calling a `fn` type]\n+  (https://github.com/rust-lang/rust/pull/33325).\n+* [Do not suggest changing `&mut self` to `&mut mut self`]\n+  (https://github.com/rust-lang/rust/pull/33319).\n+\n+Misc\n+----\n+\n+* [Update i686-linux-android features to match Android ABI]\n+  (https://github.com/rust-lang/rust/pull/33651).\n+* [Update aarch64-linux-android features to match Android ABI]\n+  (https://github.com/rust-lang/rust/pull/33500).\n+* [`std` no longer prints backtraces on platforms where the running\n+  module must be loaded with `env::current_exe`, which can't be relied\n+  on](https://github.com/rust-lang/rust/pull/33554).\n+* This release includes std binaries for the i586-unknown-linux-gnu,\n+  i686-unknown-linux-musl, and armv7-linux-androideabi targets. The\n+  i586 target is for old x86 hardware without SSE2, and the armv7\n+  target is for Android running on modern ARM architectures.\n+* [The `rust-gdb` and `rust-lldb` scripts are distributed on all\n+  Unix platforms](https://github.com/rust-lang/rust/pull/32835).\n+* [On Unix the runtime aborts by calling `libc::abort` instead of\n+  generating an illegal instruction]\n+  (https://github.com/rust-lang/rust/pull/31457).\n+* [Rust is now bootstrapped from the previous release of Rust,\n+  instead of a snapshot from an arbitrary commit]\n+  (https://github.com/rust-lang/rust/pull/32942).\n+\n+Compatibility Notes\n+-------------------\n+\n+* [`AtomicBool` is now bool-sized, not word-sized]\n+  (https://github.com/rust-lang/rust/pull/33579).\n+* [`target_env` for Linux ARM targets is just `gnu`, not\n+  `gnueabihf`, `gnueabi`, etc]\n+  (https://github.com/rust-lang/rust/pull/33403).\n+* [Consistently panic on overflow in `Duration::new`]\n+  (https://github.com/rust-lang/rust/pull/33072).\n+* [Change `String::truncate` to panic less]\n+  (https://github.com/rust-lang/rust/pull/32977).\n+* [Add `:block` to the follow set for `:ty` and `:path`]\n+  (https://github.com/rust-lang/rust/pull/32945).\n+  Affects how macros are parsed.\n+* [Fix macro hygiene bug]\n+  (https://github.com/rust-lang/rust/pull/32923).\n+* [Feature-gated attributes on macro-generated macro invocations are\n+  now rejected]\n+  (https://github.com/rust-lang/rust/pull/32791).\n+* [Suppress fallback and ambiguity errors during type inference]\n+  (https://github.com/rust-lang/rust/pull/32258).\n+  This caused some minor changes to type inference.\n+\n+\n Version 1.9.0 (2016-05-26)\n ==========================\n "}, {"sha": "6451b87673f628c230d2686f3f7dc3773506bd10", "filename": "configure", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/configure", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1178,33 +1178,6 @@ do\n             ;;\n \n         *-msvc)\n-            # There are some MSYS python builds which will auto-translate\n-            # windows-style paths to MSYS-style paths in Python itself.\n-            # Unfortunately this breaks LLVM's build system as somewhere along\n-            # the line LLVM prints a path into a file from Python and then CMake\n-            # later tries to interpret that path. If Python prints a MSYS path\n-            # and CMake tries to use it as a Windows path, you're gonna have a\n-            # Bad Time.\n-            #\n-            # Consequently here we try to detect when that happens and print an\n-            # error if it does.\n-            if $CFG_PYTHON -c 'import sys; print sys.argv[1]' `pwd` | grep '^/' > /dev/null\n-            then\n-                err \"\n-\n-python is silently translating windows paths to MSYS paths \\\n-and the build will fail if this python is used.\n-\n-Either an official python install must be used or an \\\n-alternative python package in MinGW must be used.\n-\n-If you are building under msys2 try installing the mingw-w64-x86_64-python2 \\\n-package instead of python2:\n-\n-$ pacman -R python2 && pacman -S mingw-w64-x86_64-python2\n-\"\n-            fi\n-\n             # There are three builds of cmake on windows: MSVC, MinGW and Cygwin\n             # The Cygwin build does not have generators for Visual Studio, so\n             # detect that here and error.\n@@ -1288,6 +1261,36 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n     esac\n done\n \n+if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ] || [ \"$CFG_OSTYPE\" = \"pc-windows-msvc\" ]\n+then\n+    # There are some MSYS python builds which will auto-translate\n+    # windows-style paths to MSYS-style paths in Python itself.\n+    # Unfortunately this breaks LLVM's build system as somewhere along\n+    # the line LLVM prints a path into a file from Python and then CMake\n+    # later tries to interpret that path. If Python prints a MSYS path\n+    # and CMake tries to use it as a Windows path, you're gonna have a\n+    # Bad Time.\n+    #\n+    # Consequently here we try to detect when that happens and print an\n+    # error if it does.\n+    if $CFG_PYTHON -c 'import sys; print sys.argv[1]' `pwd` | grep '^/' > /dev/null\n+    then\n+        err \"\n+\n+python is silently translating windows paths to MSYS paths \\\n+and the build will fail if this python is used.\n+\n+Either an official python install must be used or an \\\n+alternative python package in MinGW must be used.\n+\n+If you are building under msys2 try installing the mingw-w64-x86_64-python2 \\\n+package instead of python2:\n+\n+$ pacman -S mingw-w64-x86_64-python2\n+\"\n+    fi\n+fi\n+\n if [ -n \"$CFG_PERF\" ]\n then\n     HAVE_PERF_LOGFD=`$CFG_PERF stat --log-fd 2>&1 | grep 'unknown option'`"}, {"sha": "33de8fd0107673ccbeb97c4699df506e1f2d143c", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -10,6 +10,7 @@\n \n import argparse\n import contextlib\n+import datetime\n import hashlib\n import os\n import shutil\n@@ -18,6 +19,8 @@\n import tarfile\n import tempfile\n \n+from time import time\n+\n \n def get(url, path, verbose=False):\n     sha_url = url + \".sha256\"\n@@ -118,6 +121,9 @@ def stage0_data(rust_root):\n             data[a] = b\n     return data\n \n+def format_build_time(duration):\n+    return str(datetime.timedelta(seconds=int(duration)))\n+\n class RustBuild:\n     def download_stage0(self):\n         cache_dst = os.path.join(self.build_dir, \"cache\")\n@@ -265,7 +271,7 @@ def build_triple(self):\n         try:\n             ostype = subprocess.check_output(['uname', '-s']).strip()\n             cputype = subprocess.check_output(['uname', '-m']).strip()\n-        except subprocess.CalledProcessError:\n+        except (subprocess.CalledProcessError, WindowsError):\n             if sys.platform == 'win32':\n                 return 'x86_64-pc-windows-msvc'\n             err = \"uname not found\"\n@@ -372,6 +378,8 @@ def main():\n     rb._rustc_channel, rb._rustc_date = data['rustc'].split('-', 1)\n     rb._cargo_channel, rb._cargo_date = data['cargo'].split('-', 1)\n \n+    start_time = time()\n+\n     # Fetch/build the bootstrap\n     rb.build = rb.build_triple()\n     rb.download_stage0()\n@@ -390,5 +398,9 @@ def main():\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     rb.run(args, env)\n \n+    end_time = time()\n+\n+    print(\"Build completed in %s\" % format_build_time(end_time - start_time))\n+\n if __name__ == '__main__':\n     main()"}, {"sha": "ff0941a97dce1e3fcbfde7bdf64e79dca66ffc33", "filename": "src/bootstrap/build/cc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcc.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -90,6 +90,7 @@ fn set_compiler(cfg: &mut gcc::Config,\n         // compiler already takes into account the triple in question.\n         t if t.contains(\"android\") => {\n             if let Some(ndk) = config.and_then(|c| c.ndk.as_ref()) {\n+                let target = target.replace(\"armv7\", \"arm\");\n                 let compiler = format!(\"{}-{}\", target, gnu_compiler);\n                 cfg.compiler(ndk.join(\"bin\").join(compiler));\n             }"}, {"sha": "0a096f8e4de417aea9560ad28f3e5c3f6a3503c4", "filename": "src/bootstrap/build/check.rs", "status": "modified", "additions": 117, "deletions": 11, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcheck.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -23,6 +23,9 @@ use build_helper::output;\n use bootstrap::{dylib_path, dylib_path_var};\n \n use build::{Build, Compiler, Mode};\n+use build::util;\n+\n+const ADB_TEST_DIR: &'static str = \"/data/tmp\";\n \n /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n ///\n@@ -88,6 +91,7 @@ pub fn compiletest(build: &Build,\n                    target: &str,\n                    mode: &str,\n                    suite: &str) {\n+    println!(\"Check compiletest {} ({} -> {})\", suite, compiler.host, target);\n     let mut cmd = build.tool_cmd(compiler, \"compiletest\");\n \n     // compiletest currently has... a lot of arguments, so let's just pass all\n@@ -105,21 +109,23 @@ pub fn compiletest(build: &Build,\n     cmd.arg(\"--host\").arg(compiler.host);\n     cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(&build.config.build));\n \n-    let mut flags = format!(\"-Crpath\");\n+    let mut flags = vec![\"-Crpath\".to_string()];\n     if build.config.rust_optimize_tests {\n-        flags.push_str(\" -O\");\n+        flags.push(\"-O\".to_string());\n     }\n     if build.config.rust_debuginfo_tests {\n-        flags.push_str(\" -g\");\n+        flags.push(\"-g\".to_string());\n     }\n \n-    cmd.arg(\"--host-rustcflags\").arg(&flags);\n-\n-    let linkflag = format!(\"-Lnative={}\", build.test_helpers_out(target).display());\n-    cmd.arg(\"--target-rustcflags\").arg(format!(\"{} {}\", flags, linkflag));\n+    let mut hostflags = build.rustc_flags(&compiler.host);\n+    hostflags.extend(flags.clone());\n+    cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n \n-    // FIXME: needs android support\n-    cmd.arg(\"--android-cross-path\").arg(\"\");\n+    let mut targetflags = build.rustc_flags(&target);\n+    targetflags.extend(flags);\n+    targetflags.push(format!(\"-Lnative={}\",\n+                             build.test_helpers_out(target).display()));\n+    cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n \n     // FIXME: CFG_PYTHON should probably be detected more robustly elsewhere\n     let python_default = \"python\";\n@@ -180,6 +186,16 @@ pub fn compiletest(build: &Build,\n     }\n     build.add_bootstrap_key(compiler, &mut cmd);\n \n+    cmd.arg(\"--adb-path\").arg(\"adb\");\n+    cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n+    if target.contains(\"android\") {\n+        // Assume that cc for this target comes from the android sysroot\n+        cmd.arg(\"--android-cross-path\")\n+           .arg(build.cc(target).parent().unwrap().parent().unwrap());\n+    } else {\n+        cmd.arg(\"--android-cross-path\").arg(\"\");\n+    }\n+\n     build.run(&mut cmd);\n }\n \n@@ -302,7 +318,97 @@ pub fn krate(build: &Build,\n     let mut dylib_path = dylib_path();\n     dylib_path.insert(0, build.sysroot_libdir(compiler, target));\n     cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n-    cargo.args(&build.flags.args);\n \n-    build.run(&mut cargo);\n+    if target.contains(\"android\") {\n+        build.run(cargo.arg(\"--no-run\"));\n+        krate_android(build, compiler, target, mode);\n+    } else {\n+        cargo.args(&build.flags.args);\n+        build.run(&mut cargo);\n+    }\n+}\n+\n+fn krate_android(build: &Build,\n+                 compiler: &Compiler,\n+                 target: &str,\n+                 mode: Mode) {\n+    let mut tests = Vec::new();\n+    let out_dir = build.cargo_out(compiler, mode, target);\n+    find_tests(&out_dir, target, &mut tests);\n+    find_tests(&out_dir.join(\"deps\"), target, &mut tests);\n+\n+    for test in tests {\n+        build.run(Command::new(\"adb\").arg(\"push\").arg(&test).arg(ADB_TEST_DIR));\n+\n+        let test_file_name = test.file_name().unwrap().to_string_lossy();\n+        let log = format!(\"{}/check-stage{}-T-{}-H-{}-{}.log\",\n+                          ADB_TEST_DIR,\n+                          compiler.stage,\n+                          target,\n+                          compiler.host,\n+                          test_file_name);\n+        let program = format!(\"(cd {dir}; \\\n+                                LD_LIBRARY_PATH=./{target} ./{test} \\\n+                                    --logfile {log} \\\n+                                    {args})\",\n+                              dir = ADB_TEST_DIR,\n+                              target = target,\n+                              test = test_file_name,\n+                              log = log,\n+                              args = build.flags.args.join(\" \"));\n+\n+        let output = output(Command::new(\"adb\").arg(\"shell\").arg(&program));\n+        println!(\"{}\", output);\n+        build.run(Command::new(\"adb\")\n+                          .arg(\"pull\")\n+                          .arg(&log)\n+                          .arg(build.out.join(\"tmp\")));\n+        build.run(Command::new(\"adb\").arg(\"shell\").arg(\"rm\").arg(&log));\n+        if !output.contains(\"result: ok\") {\n+            panic!(\"some tests failed\");\n+        }\n+    }\n+}\n+\n+fn find_tests(dir: &Path,\n+              target: &str,\n+              dst: &mut Vec<PathBuf>) {\n+    for e in t!(dir.read_dir()).map(|e| t!(e)) {\n+        let file_type = t!(e.file_type());\n+        if !file_type.is_file() {\n+            continue\n+        }\n+        let filename = e.file_name().into_string().unwrap();\n+        if (target.contains(\"windows\") && filename.ends_with(\".exe\")) ||\n+           (!target.contains(\"windows\") && !filename.contains(\".\")) {\n+            dst.push(e.path());\n+        }\n+    }\n+}\n+\n+pub fn android_copy_libs(build: &Build,\n+                         compiler: &Compiler,\n+                         target: &str) {\n+    println!(\"Android copy libs to emulator ({})\", target);\n+    build.run(Command::new(\"adb\").arg(\"remount\"));\n+    build.run(Command::new(\"adb\").args(&[\"shell\", \"rm\", \"-r\", ADB_TEST_DIR]));\n+    build.run(Command::new(\"adb\").args(&[\"shell\", \"mkdir\", ADB_TEST_DIR]));\n+    build.run(Command::new(\"adb\")\n+                      .arg(\"push\")\n+                      .arg(build.src.join(\"src/etc/adb_run_wrapper.sh\"))\n+                      .arg(ADB_TEST_DIR));\n+\n+    let target_dir = format!(\"{}/{}\", ADB_TEST_DIR, target);\n+    build.run(Command::new(\"adb\").args(&[\"shell\", \"mkdir\", &target_dir[..]]));\n+\n+    for f in t!(build.sysroot_libdir(compiler, target).read_dir()) {\n+        let f = t!(f);\n+        let name = f.file_name().into_string().unwrap();\n+        if util::is_dylib(&name) {\n+            build.run(Command::new(\"adb\")\n+                              .arg(\"push\")\n+                              .arg(f.path())\n+                              .arg(&target_dir));\n+        }\n+    }\n }"}, {"sha": "498196e9b6dfc12454274e75cd695c2ad2a04b65", "filename": "src/bootstrap/build/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fconfig.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -368,13 +368,13 @@ impl Config {\n                     target.ndk = Some(PathBuf::from(value));\n                 }\n                 \"CFG_I686_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n-                    let target = \"i686-linux-androideabi\".to_string();\n+                    let target = \"i686-linux-android\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n                     target.ndk = Some(PathBuf::from(value));\n                 }\n                 \"CFG_AARCH64_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n-                    let target = \"aarch64-linux-androideabi\".to_string();\n+                    let target = \"aarch64-linux-android\".to_string();\n                     let target = self.target_config.entry(target)\n                                      .or_insert(Target::default());\n                     target.ndk = Some(PathBuf::from(value));"}, {"sha": "6eed7eaf206f4631f584604a5aefa11d70329041", "filename": "src/bootstrap/build/dist.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fdist.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -135,7 +135,6 @@ pub fn rustc(build: &Build, stage: u32, host: &str) {\n \n     // Prepare the overlay which is part of the tarball but won't actually be\n     // installed\n-    t!(fs::create_dir_all(&overlay));\n     let cp = |file: &str| {\n         install(&build.src.join(file), &overlay, 0o644);\n     };\n@@ -199,7 +198,6 @@ pub fn rustc(build: &Build, stage: u32, host: &str) {\n \n         // Copy runtime DLLs needed by the compiler\n         if libdir != \"bin\" {\n-            t!(fs::create_dir_all(image.join(libdir)));\n             for entry in t!(src.join(libdir).read_dir()).map(|e| t!(e)) {\n                 let name = entry.file_name();\n                 if let Some(s) = name.to_str() {\n@@ -221,7 +219,6 @@ pub fn rustc(build: &Build, stage: u32, host: &str) {\n         let cp = |file: &str| {\n             install(&build.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n         };\n-        t!(fs::create_dir_all(&image.join(\"share/doc/rust\")));\n         cp(\"COPYRIGHT\");\n         cp(\"LICENSE-APACHE\");\n         cp(\"LICENSE-MIT\");\n@@ -289,6 +286,7 @@ pub fn std(build: &Build, compiler: &Compiler, target: &str) {\n \n fn install(src: &Path, dstdir: &Path, perms: u32) {\n     let dst = dstdir.join(src.file_name().unwrap());\n+    t!(fs::create_dir_all(dstdir));\n     t!(fs::copy(src, &dst));\n     chmod(&dst, perms);\n }"}, {"sha": "195d1bc90c655fb191f832aeaa46c6bf8e3eb45a", "filename": "src/bootstrap/build/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -128,6 +128,7 @@ pub struct Build {\n ///\n /// These entries currently correspond to the various output directories of the\n /// build system, with each mod generating output in a different directory.\n+#[derive(Clone, Copy)]\n pub enum Mode {\n     /// This cargo is going to build the standard library, placing output in the\n     /// \"stageN-std\" directory.\n@@ -383,8 +384,7 @@ impl Build {\n                                        \"ui\", \"ui\");\n                 }\n                 CheckDebuginfo { compiler } => {\n-                    if target.target.contains(\"msvc\") ||\n-                       target.target.contains(\"android\") {\n+                    if target.target.contains(\"msvc\") {\n                         // nothing to do\n                     } else if target.target.contains(\"apple\") {\n                         check::compiletest(self, &compiler, target.target,\n@@ -434,8 +434,14 @@ impl Build {\n                                            target.target);\n                 }\n \n+                AndroidCopyLibs { compiler } => {\n+                    check::android_copy_libs(self, &compiler, target.target);\n+                }\n+\n+                // pseudo-steps\n                 Dist { .. } |\n-                Doc { .. } | // pseudo-steps\n+                Doc { .. } |\n+                CheckTarget { .. } |\n                 Check { .. } => {}\n             }\n         }"}, {"sha": "f6030cfd090d223e314bd93592a04d5e4bca7d62", "filename": "src/bootstrap/build/native.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fnative.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -49,6 +49,8 @@ pub fn llvm(build: &Build, target: &str) {\n         return\n     }\n \n+    println!(\"Building LLVM for {}\", target);\n+\n     let _ = fs::remove_dir_all(&dst.join(\"build\"));\n     t!(fs::create_dir_all(&dst.join(\"build\")));\n     let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n@@ -167,8 +169,10 @@ pub fn compiler_rt(build: &Build, target: &str) {\n             \"arm\" if target.contains(\"eabihf\") => \"armhf\",\n             _ => arch,\n         };\n-        let target = format!(\"clang_rt.builtins-{}{}\", builtins_arch, os_extra);\n-        (\"linux\".to_string(), target.clone(), target)\n+        let target = format!(\"clang_rt.builtins-{}\", builtins_arch);\n+        (\"linux\".to_string(),\n+         target.clone(),\n+         format!(\"{}{}\", target, os_extra))\n     } else if target.contains(\"apple-darwin\") {\n         let builtins_arch = match arch {\n             \"i686\" => \"i386\","}, {"sha": "5eced00e13973e35109cb32856aa732b16cd9696", "filename": "src/bootstrap/build/sanity.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fsanity.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -139,6 +139,10 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n \");\n             }\n         }\n+\n+        if target.contains(\"arm-linux-android\") {\n+            need_cmd(\"adb\".as_ref());\n+        }\n     }\n \n     for host in build.flags.host.iter() {"}, {"sha": "7cbbd6740a2657a5cbbfda23eea3a572fb30d936", "filename": "src/bootstrap/build/step.rs", "status": "modified", "additions": 87, "deletions": 31, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fbuild%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fstep.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -102,6 +102,7 @@ macro_rules! targets {\n             // Steps for running tests. The 'check' target is just a pseudo\n             // target to depend on a bunch of others.\n             (check, Check { stage: u32, compiler: Compiler<'a> }),\n+            (check_target, CheckTarget { stage: u32, compiler: Compiler<'a> }),\n             (check_linkcheck, CheckLinkcheck { stage: u32 }),\n             (check_cargotest, CheckCargoTest { stage: u32 }),\n             (check_tidy, CheckTidy { stage: u32 }),\n@@ -138,6 +139,9 @@ macro_rules! targets {\n             (dist_mingw, DistMingw { _dummy: () }),\n             (dist_rustc, DistRustc { stage: u32 }),\n             (dist_std, DistStd { compiler: Compiler<'a> }),\n+\n+            // Misc targets\n+            (android_copy_libs, AndroidCopyLibs { compiler: Compiler<'a> }),\n         }\n     }\n }\n@@ -382,37 +386,80 @@ impl<'a> Step<'a> {\n                      self.doc_error_index(stage)]\n             }\n             Source::Check { stage, compiler } => {\n-                vec![\n+                // Check is just a pseudo step which means check all targets,\n+                // so just depend on checking all targets.\n+                build.config.target.iter().map(|t| {\n+                    self.target(t).check_target(stage, compiler)\n+                }).collect()\n+            }\n+            Source::CheckTarget { stage, compiler } => {\n+                // CheckTarget here means run all possible test suites for this\n+                // target. Most of the time, however, we can't actually run\n+                // anything if we're not the build triple as we could be cross\n+                // compiling.\n+                //\n+                // As a result, the base set of targets here is quite stripped\n+                // down from the standard set of targets. These suites have\n+                // their own internal logic to run in cross-compiled situations\n+                // if they'll run at all. For example compiletest knows that\n+                // when testing Android targets we ship artifacts to the\n+                // emulator.\n+                //\n+                // When in doubt the rule of thumb for adding to this list is\n+                // \"should this test suite run on the android bot?\"\n+                let mut base = vec![\n                     self.check_rpass(compiler),\n-                    self.check_rpass_full(compiler),\n                     self.check_rfail(compiler),\n-                    self.check_rfail_full(compiler),\n-                    self.check_cfail(compiler),\n-                    self.check_cfail_full(compiler),\n-                    self.check_pfail(compiler),\n-                    self.check_incremental(compiler),\n-                    self.check_ui(compiler),\n                     self.check_crate_std(compiler),\n                     self.check_crate_test(compiler),\n-                    self.check_crate_rustc(compiler),\n-                    self.check_codegen(compiler),\n-                    self.check_codegen_units(compiler),\n                     self.check_debuginfo(compiler),\n-                    self.check_rustdoc(compiler),\n-                    self.check_pretty(compiler),\n-                    self.check_pretty_rpass(compiler),\n-                    self.check_pretty_rpass_full(compiler),\n-                    self.check_pretty_rfail(compiler),\n-                    self.check_pretty_rfail_full(compiler),\n-                    self.check_pretty_rpass_valgrind(compiler),\n-                    self.check_rpass_valgrind(compiler),\n-                    self.check_error_index(compiler),\n-                    self.check_docs(compiler),\n-                    self.check_rmake(compiler),\n-                    self.check_linkcheck(stage),\n-                    self.check_tidy(stage),\n                     self.dist(stage),\n-                ]\n+                ];\n+\n+                // If we're testing the build triple, then we know we can\n+                // actually run binaries and such, so we run all possible tests\n+                // that we know about.\n+                if self.target == build.config.build {\n+                    base.extend(vec![\n+                        // docs-related\n+                        self.check_docs(compiler),\n+                        self.check_error_index(compiler),\n+                        self.check_rustdoc(compiler),\n+\n+                        // UI-related\n+                        self.check_cfail(compiler),\n+                        self.check_pfail(compiler),\n+                        self.check_ui(compiler),\n+\n+                        // codegen-related\n+                        self.check_incremental(compiler),\n+                        self.check_codegen(compiler),\n+                        self.check_codegen_units(compiler),\n+\n+                        // misc compiletest-test suites\n+                        self.check_rpass_full(compiler),\n+                        self.check_rfail_full(compiler),\n+                        self.check_cfail_full(compiler),\n+                        self.check_pretty_rpass_full(compiler),\n+                        self.check_pretty_rfail_full(compiler),\n+                        self.check_rpass_valgrind(compiler),\n+                        self.check_rmake(compiler),\n+\n+                        // crates\n+                        self.check_crate_rustc(compiler),\n+\n+                        // pretty\n+                        self.check_pretty(compiler),\n+                        self.check_pretty_rpass(compiler),\n+                        self.check_pretty_rfail(compiler),\n+                        self.check_pretty_rpass_valgrind(compiler),\n+\n+                        // misc\n+                        self.check_linkcheck(stage),\n+                        self.check_tidy(stage),\n+                    ]);\n+                }\n+                return base\n             }\n             Source::CheckLinkcheck { stage } => {\n                 vec![self.tool_linkchecker(stage), self.doc(stage)]\n@@ -437,16 +484,20 @@ impl<'a> Step<'a> {\n             Source::CheckCFail { compiler } |\n             Source::CheckRPassValgrind { compiler } |\n             Source::CheckRPass { compiler } => {\n-                vec![\n+                let mut base = vec![\n                     self.libtest(compiler),\n-                    self.tool_compiletest(compiler.stage),\n+                    self.target(compiler.host).tool_compiletest(compiler.stage),\n                     self.test_helpers(()),\n-                ]\n+                ];\n+                if self.target.contains(\"android\") {\n+                    base.push(self.android_copy_libs(compiler));\n+                }\n+                base\n             }\n             Source::CheckDebuginfo { compiler } => {\n                 vec![\n                     self.libtest(compiler),\n-                    self.tool_compiletest(compiler.stage),\n+                    self.target(compiler.host).tool_compiletest(compiler.stage),\n                     self.test_helpers(()),\n                     self.debugger_scripts(compiler.stage),\n                 ]\n@@ -459,13 +510,14 @@ impl<'a> Step<'a> {\n             Source::CheckPrettyRPassValgrind { compiler } |\n             Source::CheckRMake { compiler } => {\n                 vec![self.librustc(compiler),\n-                     self.tool_compiletest(compiler.stage)]\n+                     self.target(compiler.host).tool_compiletest(compiler.stage)]\n             }\n             Source::CheckDocs { compiler } => {\n                 vec![self.libstd(compiler)]\n             }\n             Source::CheckErrorIndex { compiler } => {\n-                vec![self.libstd(compiler), self.tool_error_index(compiler.stage)]\n+                vec![self.libstd(compiler),\n+                     self.target(compiler.host).tool_error_index(compiler.stage)]\n             }\n             Source::CheckCrateStd { compiler } => {\n                 vec![self.libtest(compiler)]\n@@ -529,6 +581,10 @@ impl<'a> Step<'a> {\n                 }\n                 return base\n             }\n+\n+            Source::AndroidCopyLibs { compiler } => {\n+                vec![self.libtest(compiler)]\n+            }\n         }\n     }\n }"}, {"sha": "c657785d78b6e31f094536b736f7275289c0039a", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -25,6 +25,11 @@ all:\n clean:\n \t$(Q)$(BOOTSTRAP) --clean\n \n+rustc-stage1:\n+\t$(Q)$(BOOTSTRAP) --step libtest --stage 1\n+rustc-stage2:\n+\t$(Q)$(BOOTSTRAP) --step libtest --stage 2\n+\n docs: doc\n doc:\n \t$(Q)$(BOOTSTRAP) --step doc"}, {"sha": "ac3d1cda612edccb6f1da53cbf7716e248405f3b", "filename": "src/compiler-rt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiler-rt?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1 +1 @@\n-Subproject commit a1ef94b76029780a510bc2dc9c6a791bd091ff19\n+Subproject commit ac3d1cda612edccb6f1da53cbf7716e248405f3b"}, {"sha": "3fbcbc2f471368ca8cef380ba8a9574724a2b021", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -521,14 +521,14 @@ against `libc` and `libm` by default.\n \n # The \"nullable pointer optimization\"\n \n-Certain types are defined to not be `null`. This includes references (`&T`,\n+Certain types are defined to not be NULL. This includes references (`&T`,\n `&mut T`), boxes (`Box<T>`), and function pointers (`extern \"abi\" fn()`).\n-When interfacing with C, pointers that might be null are often used.\n+When interfacing with C, pointers that might be NULL are often used.\n As a special case, a generic `enum` that contains exactly two variants, one of\n which contains no data and the other containing a single field, is eligible\n for the \"nullable pointer optimization\". When such an enum is instantiated\n with one of the non-nullable types, it is represented as a single pointer,\n-and the non-data variant is represented as the null pointer. So\n+and the non-data variant is represented as the NULL pointer. So\n `Option<extern \"C\" fn(c_int) -> c_int>` is how one represents a nullable\n function pointer using the C ABI.\n "}, {"sha": "8aa7fdff94803735f355f8944c60dc0de0c1bdfa", "filename": "src/doc/book/glossary.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Fglossary.md", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Fglossary.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fglossary.md?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -46,6 +46,12 @@ must abide by that constraint.\n \n [traits]: traits.html\n \n+### Combinators\n+\n+Combinators are higher-order functions that apply only functions and\n+earlier defined combinators to provide a result from its arguments. \n+They can be used to manage control flow in a modular fashion.\n+\n ### DST (Dynamically Sized Type)\n \n A type without a statically known size or alignment. ([more info][link])"}, {"sha": "f7d9c94bc454f31a052f828a7385623801f7ac5c", "filename": "src/doc/book/lifetimes.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flifetimes.md?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -290,7 +290,7 @@ lifetime parameters using three easily memorizable and unambiguous rules. This m\n acts as a shorthand for writing an item signature, while not hiding\n away the actual types involved as full local inference would if applied to it.\n \n-When talking about lifetime elision, we use the term *input lifetime* and\n+When talking about lifetime elision, we use the terms *input lifetime* and\n *output lifetime*. An *input lifetime* is a lifetime associated with a parameter\n of a function, and an *output lifetime* is a lifetime associated with the return\n value of a function. For example, this function has an input lifetime:\n@@ -335,11 +335,13 @@ fn print<'a>(s: &'a str); // expanded\n \n fn debug(lvl: u32, s: &str); // elided\n fn debug<'a>(lvl: u32, s: &'a str); // expanded\n+```\n \n-// In the preceding example, `lvl` doesn\u2019t need a lifetime because it\u2019s not a\n-// reference (`&`). Only things relating to references (such as a `struct`\n-// which contains a reference) need lifetimes.\n+In the preceding example, `lvl` doesn\u2019t need a lifetime because it\u2019s not a\n+reference (`&`). Only things relating to references (such as a `struct`\n+which contains a reference) need lifetimes.\n \n+```rust,ignore\n fn substr(s: &str, until: u32) -> &str; // elided\n fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded\n "}, {"sha": "23ca21b3b49923f01ed930a2dbb4acac7d81ff3b", "filename": "src/doc/book/ownership.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fownership.md?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -214,7 +214,7 @@ But, unlike a move, we can still use `v` afterward. This is because an `i32`\n has no pointers to data somewhere else, copying it is a full copy.\n \n All primitive types implement the `Copy` trait and their ownership is\n-therefore not moved like one would assume, following the \u00b4ownership rules\u00b4.\n+therefore not moved like one would assume, following the \u2018ownership rules\u2019.\n To give an example, the two following snippets of code only compile because the\n `i32` and `bool` types implement the `Copy` trait.\n \n@@ -290,6 +290,6 @@ let (v1, v2, answer) = foo(v1, v2);\n Ugh! The return type, return line, and calling the function gets way more\n complicated.\n \n-Luckily, Rust offers a feature, borrowing, which helps us solve this problem.\n-It\u2019s the topic of the next section!\n+Luckily, Rust offers a feature which helps us solve this problem.\n+It\u2019s called borrowing and is the topic of the next section!\n "}, {"sha": "ae100aec3b5129c7ab43960e5458bd3dbd74b73e", "filename": "src/doc/book/raw-pointers.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Fraw-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Fraw-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fraw-pointers.md?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -17,7 +17,7 @@ Here are some things to remember about raw pointers that are different than\n other pointer types. They:\n \n - are not guaranteed to point to valid memory and are not even\n-  guaranteed to be non-null (unlike both `Box` and `&`);\n+  guaranteed to be non-NULL (unlike both `Box` and `&`);\n - do not have any automatic clean-up, unlike `Box`, and so require\n   manual resource management;\n - are plain-old-data, that is, they don't move ownership, again unlike"}, {"sha": "57bfbce8b84debab2f26a638ae1aed85ecc491ed", "filename": "src/doc/book/references-and-borrowing.md", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -123,7 +123,7 @@ let v = vec![];\n foo(&v);\n ```\n \n-errors with:\n+will give us this error:\n \n ```text\n error: cannot borrow immutable borrowed content `*v` as mutable\n@@ -152,8 +152,8 @@ the thing `y` points at. You\u2019ll notice that `x` had to be marked `mut` as well\n If it wasn\u2019t, we couldn\u2019t take a mutable borrow to an immutable value.\n \n You'll also notice we added an asterisk (`*`) in front of `y`, making it `*y`,\n-this is because `y` is a `&mut` reference. You'll also need to use them for\n-accessing the contents of a reference as well.\n+this is because `y` is a `&mut` reference. You'll need to use astrisks to\n+access the contents of a reference as well.\n \n Otherwise, `&mut` references are like references. There _is_ a large\n difference between the two, and how they interact, though. You can tell\n@@ -179,7 +179,7 @@ As it turns out, there are rules.\n \n # The Rules\n \n-Here\u2019s the rules about borrowing in Rust:\n+Here are the rules for borrowing in Rust:\n \n First, any borrow must last for a scope no greater than that of the owner.\n Second, you may have one or the other of these two kinds of borrows, but not\n@@ -208,12 +208,14 @@ With this in mind, let\u2019s consider our example again.\n Here\u2019s the code:\n \n ```rust,ignore\n-let mut x = 5;\n-let y = &mut x;\n+fn main() {\n+    let mut x = 5;\n+    let y = &mut x;\n \n-*y += 1;\n+    *y += 1;\n \n-println!(\"{}\", x);\n+    println!(\"{}\", x);\n+}\n ```\n \n This code gives us this error:\n@@ -225,7 +227,7 @@ error: cannot borrow `x` as immutable because it is also borrowed as mutable\n ```\n \n This is because we\u2019ve violated the rules: we have a `&mut T` pointing to `x`,\n-and so we aren\u2019t allowed to create any `&T`s. One or the other. The note\n+and so we aren\u2019t allowed to create any `&T`s. It's one or the other. The note\n hints at how to think about this problem:\n \n ```text\n@@ -243,14 +245,16 @@ In Rust, borrowing is tied to the scope that the borrow is valid for. And our\n scopes look like this:\n \n ```rust,ignore\n-let mut x = 5;\n-\n-let y = &mut x;    // -+ &mut borrow of x starts here\n-                   //  |\n-*y += 1;           //  |\n-                   //  |\n-println!(\"{}\", x); // -+ - try to borrow x here\n-                   // -+ &mut borrow of x ends here\n+fn main() {\n+    let mut x = 5;\n+\n+    let y = &mut x;    // -+ &mut borrow of x starts here\n+                       //  |\n+    *y += 1;           //  |\n+                       //  |\n+    println!(\"{}\", x); // -+ - try to borrow x here\n+}                      // -+ &mut borrow of x ends here\n+                       \n ```\n \n The scopes conflict: we can\u2019t make an `&x` while `y` is in scope.\n@@ -269,12 +273,12 @@ println!(\"{}\", x);  // <- try to borrow x here\n ```\n \n There\u2019s no problem. Our mutable borrow goes out of scope before we create an\n-immutable one. But scope is the key to seeing how long a borrow lasts for.\n+immutable one. So scope is the key to seeing how long a borrow lasts for.\n \n ## Issues borrowing prevents\n \n Why have these restrictive rules? Well, as we noted, these rules prevent data\n-races. What kinds of issues do data races cause? Here\u2019s a few.\n+races. What kinds of issues do data races cause? Here are a few.\n \n ### Iterator invalidation\n \n@@ -323,7 +327,7 @@ for i in &v {\n \n We can\u2019t modify `v` because it\u2019s borrowed by the loop.\n \n-### use after free\n+### Use after free\n \n References must not live longer than the resource they refer to. Rust will\n check the scopes of your references to ensure that this is true."}, {"sha": "135778c38b50a2e8bc883b654a331da85389d3dc", "filename": "src/doc/book/strings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fstrings.md?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -9,7 +9,7 @@ strings also work differently than in some other systems languages, such as C.\n Let\u2019s dig into the details. A \u2018string\u2019 is a sequence of Unicode scalar values\n encoded as a stream of UTF-8 bytes. All strings are guaranteed to be a valid\n encoding of UTF-8 sequences. Additionally, unlike some systems languages,\n-strings are not null-terminated and can contain null bytes.\n+strings are not NUL-terminated and can contain NUL bytes.\n \n Rust has two main types of strings: `&str` and `String`. Let\u2019s talk about\n `&str` first. These are called \u2018string slices\u2019. A string slice has a fixed"}, {"sha": "9cab586b82c4713d0ee73597876af5843733e945", "filename": "src/doc/book/unsafe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fdoc%2Fbook%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Funsafe.md?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -63,7 +63,7 @@ In addition, the following are all undefined behaviors in Rust, and must be\n avoided, even when writing `unsafe` code:\n \n * Data races\n-* Dereferencing a null/dangling raw pointer\n+* Dereferencing a NULL/dangling raw pointer\n * Reads of [undef][undef] (uninitialized) memory\n * Breaking the [pointer aliasing rules][aliasing] with raw pointers.\n * `&mut T` and `&T` follow LLVM\u2019s scoped [noalias][noalias] model, except if\n@@ -77,7 +77,7 @@ avoided, even when writing `unsafe` code:\n   * Using `std::ptr::copy_nonoverlapping_memory` (`memcpy32`/`memcpy64`\n     intrinsics) on overlapping buffers\n * Invalid values in primitive types, even in private fields/locals:\n-  * Null/dangling references or boxes\n+  * NULL/dangling references or boxes\n   * A value other than `false` (0) or `true` (1) in a `bool`\n   * A discriminant in an `enum` not included in its type definition\n   * A value in a `char` which is a surrogate or above `char::MAX`"}, {"sha": "b2bb7859661ab63aae27658359731647887741f9", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -139,7 +139,7 @@ def __classify_struct(self):\n             return TYPE_KIND_STR_SLICE\n \n         # REGULAR SLICE\n-        if (unqualified_type_name.startswith(\"&[\") and\n+        if (unqualified_type_name.startswith((\"&[\", \"&mut [\")) and\n             unqualified_type_name.endswith(\"]\") and\n             self.__conforms_to_field_layout(SLICE_FIELD_NAMES)):\n             return TYPE_KIND_SLICE"}, {"sha": "33f22e8579664815349f342aa78794639de159e1", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -211,15 +211,12 @@ def to_string(self):\n                 (\"(len: %i)\" % length))\n \n     def children(self):\n-        cs = []\n         (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n         assert data_ptr.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n         raw_ptr = data_ptr.get_wrapped_value()\n \n         for index in range(0, length):\n-            cs.append((str(index), (raw_ptr + index).dereference()))\n-\n-        return cs\n+            yield (str(index), (raw_ptr + index).dereference())\n \n \n class RustStringSlicePrinter:\n@@ -245,12 +242,10 @@ def to_string(self):\n                 (\"(len: %i, cap: %i)\" % (length, cap)))\n \n     def children(self):\n-        cs = []\n         (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(self.__val)\n         gdb_ptr = data_ptr.get_wrapped_value()\n         for index in range(0, length):\n-            cs.append((str(index), (gdb_ptr + index).dereference()))\n-        return cs\n+            yield (str(index), (gdb_ptr + index).dereference())\n \n \n class RustStdStringPrinter:"}, {"sha": "c8cda4077b79075b4d32a3db7bddcab04b5d4dfd", "filename": "src/etc/platform-intrinsics/aarch64.json", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Faarch64.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Faarch64.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Faarch64.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1,6 +1,6 @@\n {\n-    \"platform\": \"aarch64\",\n-    \"intrinsic_prefix\": \"aarch64_v\",\n+    \"platform\": \"aarch64_v\",\n+    \"intrinsic_prefix\": \"\",\n     \"llvm_prefix\": \"llvm.aarch64.neon.\",\n     \"number_info\": {\n         \"signed\": {"}, {"sha": "39e49e239f34dfcc64e67a71933a0f89ec4037ed", "filename": "src/etc/platform-intrinsics/arm.json", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Farm.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Farm.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Farm.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1,6 +1,6 @@\n {\n-    \"platform\": \"arm\",\n-    \"intrinsic_prefix\": \"arm_v\",\n+    \"platform\": \"arm_v\",\n+    \"intrinsic_prefix\": \"\",\n     \"llvm_prefix\": \"llvm.neon.v\",\n     \"number_info\": {\n         \"signed\": {"}, {"sha": "a4a91170efb3b5334e9f874a48240059a7f7d903", "filename": "src/etc/platform-intrinsics/generator.py", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -26,10 +26,9 @@\n class PlatformInfo(object):\n     def __init__(self, json):\n         self._platform = json['platform']\n-        self._intrinsic_prefix = json['intrinsic_prefix']\n \n-    def intrinsic_prefix(self):\n-        return self._intrinsic_prefix\n+    def platform_prefix(self):\n+        return self._platform\n \n class IntrinsicSet(object):\n     def __init__(self, platform, json):\n@@ -38,6 +37,7 @@ def __init__(self, platform, json):\n         self._intrinsics = json['intrinsics']\n         self._widths = json['width_info']\n         self._platform = platform\n+        self._intrinsic_prefix = json['intrinsic_prefix']\n \n     def intrinsics(self):\n         for raw in self._intrinsics:\n@@ -48,6 +48,9 @@ def intrinsics(self):\n     def platform(self):\n         return self._platform\n \n+    def intrinsic_prefix(self):\n+        return self._intrinsic_prefix\n+\n     def llvm_prefix(self):\n         return self._llvm_prefix\n \n@@ -538,8 +541,14 @@ def intrinsic_suffix(self):\n                                       *self._args,\n                                       width = self._width)\n \n+    def platform_prefix(self):\n+        return self._platform.platform().platform_prefix()\n+\n+    def intrinsic_set_name(self):\n+        return self._platform.intrinsic_prefix()\n+\n     def intrinsic_name(self):\n-        return self._platform.platform().intrinsic_prefix() + self.intrinsic_suffix()\n+        return self._platform.intrinsic_prefix() + self.intrinsic_suffix()\n \n     def compiler_args(self):\n         return ', '.join(arg.compiler_ctor_ref() for arg in self._args_raw)\n@@ -561,6 +570,27 @@ def parse_args():\n         formatter_class = argparse.RawDescriptionHelpFormatter,\n         description = 'Render an intrinsic definition JSON to various formats.',\n         epilog = textwrap.dedent('''\\\n+        Quick How-To:\n+\n+        There are two operating modes: single file and multiple files.\n+\n+        For example, ARM is specified as a single file. To generate the\n+        compiler-definitions for ARM just pass the script the \"arm.json\" file:\n+\n+        python generator.py --format compiler-defs arm.json\n+\n+        The X86 architecture is specified as multiple files (for the different\n+        instruction sets that x86 supports). To generate the compiler\n+        definitions one needs to pass the script a \"platform information file\"\n+        (with the -i flag) next to the files of the different intruction sets.\n+        For example, to generate the X86 compiler-definitions for SSE4.2, just:\n+\n+        python generator.py --format compiler-defs -i x86/info.json sse42.json\n+\n+        And to generate the compiler-definitions for SSE4.1 and SSE4.2, just:\n+\n+        python generator.py --format compiler-defs -i x86/info.json sse41.json sse42.json\n+\n         An intrinsic definition consists of a map with fields:\n         - intrinsic: pattern for the name(s) of the vendor's C intrinsic(s)\n         - llvm: pattern for the name(s) of the internal llvm intrinsic(s)\n@@ -730,8 +760,9 @@ def open(self, platform):\n         return 'extern \"platform-intrinsic\" {'\n \n     def render(self, mono):\n-        return '    fn {}{};'.format(mono.intrinsic_name(),\n-                                     mono.intrinsic_signature())\n+        return '    fn {}{}{};'.format(mono.platform_prefix(),\n+                                       mono.intrinsic_name(),\n+                                       mono.intrinsic_signature())\n \n     def close(self):\n         return '}'\n@@ -765,15 +796,15 @@ def open(self, platform):\n #[inline(never)]\n pub fn find(name: &str) -> Option<Intrinsic> {{\n     if !name.starts_with(\"{0}\") {{ return None }}\n-    Some(match &name[\"{0}\".len()..] {{'''.format(platform.intrinsic_prefix())\n+    Some(match &name[\"{0}\".len()..] {{'''.format(platform.platform_prefix())\n \n     def render(self, mono):\n         return '''\\\n         \"{}\" => Intrinsic {{\n             inputs: {{ static INPUTS: [&'static Type; {}] = [{}]; &INPUTS }},\n             output: {},\n             definition: Named(\"{}\")\n-        }},'''.format(mono.intrinsic_suffix(),\n+        }},'''.format(mono.intrinsic_set_name() + mono.intrinsic_suffix(),\n                       len(mono._args_raw),\n                       mono.compiler_args(),\n                       mono.compiler_ret(),"}, {"sha": "1f41e2ecf3e6d29ba0eb6d4d7d52c981faf40d94", "filename": "src/etc/platform-intrinsics/x86/avx.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Favx.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Favx.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Favx.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1,4 +1,5 @@\n {\n+    \"intrinsic_prefix\": \"_mm\",\n     \"llvm_prefix\": \"llvm.x86.avx.\",\n     \"intrinsics\": [\n         {"}, {"sha": "4e006c1c4cf417c512e32a5c8582d5f86600f142", "filename": "src/etc/platform-intrinsics/x86/avx2.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Favx2.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Favx2.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Favx2.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1,4 +1,5 @@\n {\n+    \"intrinsic_prefix\": \"_mm\",\n     \"llvm_prefix\": \"llvm.x86.avx2.\",\n     \"intrinsics\": [\n         {"}, {"sha": "24e2cbcf8aad10702b1a42651bdb2bb2513c6834", "filename": "src/etc/platform-intrinsics/x86/bmi.json", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fbmi.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fbmi.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fbmi.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -0,0 +1,13 @@\n+{\n+    \"intrinsic_prefix\": \"_bmi\",\n+    \"llvm_prefix\": \"llvm.x86.bmi.\",\n+    \"intrinsics\": [\n+        {\n+            \"intrinsic\": \"_bextr_{0.bitwidth}\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"bextr.{0.bitwidth}\",\n+            \"ret\": \"S(32-64)u\",\n+            \"args\": [\"0\", \"0\"]\n+        }\n+    ]\n+}"}, {"sha": "f5a0db5ef51da359b14ef74211602639722f17a7", "filename": "src/etc/platform-intrinsics/x86/bmi2.json", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fbmi2.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fbmi2.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fbmi2.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -0,0 +1,27 @@\n+{\n+    \"intrinsic_prefix\": \"_bmi2\",\n+    \"llvm_prefix\": \"llvm.x86.bmi.\",\n+    \"intrinsics\": [\n+        {\n+            \"intrinsic\": \"_bzhi_{0.bitwidth}\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"bzhi.{0.bitwidth}\",\n+            \"ret\": \"S(32-64)u\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"_pdep_{0.bitwidth}\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"pdep.{0.bitwidth}\",\n+            \"ret\": \"S(32-64)u\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"_pext_{0.bitwidth}\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"pext.{0.bitwidth}\",\n+            \"ret\": \"S(32-64)u\",\n+            \"args\": [\"0\", \"0\"]\n+        }\n+    ]\n+}"}, {"sha": "dcc26cd501c9bdbfaab71869e60baceba59f7663", "filename": "src/etc/platform-intrinsics/x86/fma.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Ffma.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Ffma.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Ffma.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1,4 +1,5 @@\n {\n+    \"intrinsic_prefix\": \"_mm\",\n     \"llvm_prefix\": \"llvm.x86.fma.\",\n     \"intrinsics\": [\n         {"}, {"sha": "8e90b8579c49ef996a33307d4903f6e95a4862f5", "filename": "src/etc/platform-intrinsics/x86/info.json", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Finfo.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Finfo.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Finfo.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1,26 +1,30 @@\n {\n     \"platform\": \"x86\",\n-    \"intrinsic_prefix\": \"x86_mm\",\n     \"number_info\": {\n         \"signed\": {\n             \"kind\": \"s\",\n             \"kind_short\": \"\",\n             \"data_type\": { \"pattern\": \"epi{bitwidth}\" },\n+            \"bitwidth\": { \"pattern\": \"{bitwidth}\" },\n             \"data_type_short\": { \"8\": \"b\", \"16\": \"w\", \"32\": \"d\", \"64\": \"q\" }\n         },\n         \"unsigned\": {\n             \"kind\": \"u\",\n             \"kind_short\": \"u\",\n             \"data_type\": { \"pattern\": \"epu{bitwidth}\" },\n+            \"bitwidth\": { \"pattern\": \"{bitwidth}\" },\n             \"data_type_short\": { \"8\": \"b\", \"16\": \"w\", \"32\": \"d\", \"64\": \"q\" }\n         },\n         \"float\": {\n             \"kind\": \"f\",\n             \"data_type\": { \"32\": \"ps\", \"64\": \"pd\" },\n+            \"bitwidth\": { \"pattern\": \"{bitwidth}\" },\n             \"data_type_short\": { \"32\": \"ps\", \"64\": \"pd\" }\n         }\n     },\n     \"width_info\": {\n+        \"32\":  { \"width_mm\": \"32\", \"width_suffix\": \"\" },\n+        \"64\":  { \"width_mm\": \"64\", \"width_suffix\": \"\" },\n         \"128\": { \"width_mm\": \"\", \"width_suffix\": \"\" },\n         \"256\": { \"width_mm\": \"256\", \"width_suffix\": \".256\" },\n         \"512\": { \"width_mm\": \"512\", \"width_suffix\": \".512\" }"}, {"sha": "d8eef8a3514aec7267107d6526dcdc214d596ad2", "filename": "src/etc/platform-intrinsics/x86/sse.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1,4 +1,5 @@\n {\n+    \"intrinsic_prefix\": \"_mm\",\n     \"llvm_prefix\": \"llvm.x86.sse.\",\n     \"intrinsics\": [\n         {"}, {"sha": "4d6317d80a57e306ce117902e31570b33c21bb83", "filename": "src/etc/platform-intrinsics/x86/sse2.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse2.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse2.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse2.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1,4 +1,5 @@\n {\n+    \"intrinsic_prefix\": \"_mm\",\n     \"llvm_prefix\": \"llvm.x86.sse2.\",\n     \"intrinsics\": [\n         {"}, {"sha": "119bf208f7e3437d48e8e143f982891da8c176e7", "filename": "src/etc/platform-intrinsics/x86/sse3.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse3.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse3.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse3.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1,4 +1,5 @@\n {\n+    \"intrinsic_prefix\": \"_mm\",\n     \"llvm_prefix\": \"llvm.x86.sse3.\",\n     \"intrinsics\": [\n         {"}, {"sha": "b499637e0d3c6f5046a5a3107c5da7cfaf2afacf", "filename": "src/etc/platform-intrinsics/x86/sse41.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse41.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse41.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse41.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1,4 +1,5 @@\n {\n+    \"intrinsic_prefix\": \"_mm\",\n     \"llvm_prefix\": \"llvm.x86.sse41.\",\n     \"intrinsics\": [\n         {"}, {"sha": "fdee9c8a6671b9e2d914185b6629da4da20be93c", "filename": "src/etc/platform-intrinsics/x86/sse42.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse42.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse42.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fsse42.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1,4 +1,5 @@\n {\n+    \"intrinsic_prefix\": \"_mm\",\n     \"llvm_prefix\": \"llvm.x86.sse42.\",\n     \"intrinsics\": [\n         {"}, {"sha": "5a5617957b3e5b78597a0b4a86cadd3e4838d646", "filename": "src/etc/platform-intrinsics/x86/ssse3.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fssse3.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fssse3.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Fssse3.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1,4 +1,5 @@\n {\n+    \"intrinsic_prefix\": \"_mm\",\n     \"llvm_prefix\": \"llvm.x86.ssse3.\",\n     \"intrinsics\": [\n         {"}, {"sha": "d1322cd60c4cfe2d8601c3f0fab316576afef135", "filename": "src/etc/platform-intrinsics/x86/tbm.json", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Ftbm.json", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Ftbm.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fx86%2Ftbm.json?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -0,0 +1,13 @@\n+{\n+    \"intrinsic_prefix\": \"_tbm\",\n+    \"llvm_prefix\": \"llvm.x86.tbm.\",\n+    \"intrinsics\": [\n+        {\n+            \"intrinsic\": \"_bextri_u{0.bitwidth}\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"bextri.u{0.bitwidth}\",\n+            \"ret\": \"S(32-64)u\",\n+            \"args\": [\"0\", \"0\"]\n+        }\n+    ]\n+}"}, {"sha": "f70ab65bce717044d448d893c445339268293795", "filename": "src/etc/rust-lldb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Frust-lldb", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Fetc%2Frust-lldb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-lldb?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -12,6 +12,17 @@\n # Exit if anything fails\n set -e\n \n+LLDB_VERSION=`lldb --version 2>/dev/null | head -1 | cut -d. -f1`\n+\n+if [ \"$LLDB_VERSION\" = \"lldb-350\" ]\n+then\n+    echo \"***\"\n+\techo \\\n+\"WARNING: This version of LLDB has known issues with Rust and cannot \\\n+display the contents of local variables!\"\n+    echo \"***\"\n+fi\n+\n # Create a tempfile containing the LLDB script we want to execute on startup\n TMPFILE=`mktemp /tmp/rust-lldb-commands.XXXXXX`\n "}, {"sha": "b9f5c6fcab9092a3d4565c5980a82f65888ff664", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -825,8 +825,6 @@ impl<T: Ord> BinaryHeap<T> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(binary_heap_append)]\n-    ///\n     /// use std::collections::BinaryHeap;\n     ///\n     /// let v = vec![-10, 1, 2, 3, 3];\n@@ -840,9 +838,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n     /// assert!(b.is_empty());\n     /// ```\n-    #[unstable(feature = \"binary_heap_append\",\n-           reason = \"needs to be audited\",\n-           issue = \"32526\")]\n+    #[stable(feature = \"binary_heap_append\", since = \"1.11.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n         if self.len() < other.len() {\n             swap(self, other);"}, {"sha": "aea7a1c13a28171778b427920c78c8cd89d3a1d0", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -559,7 +559,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(btree_append)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n@@ -583,8 +582,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(a[&4], \"e\");\n     /// assert_eq!(a[&5], \"f\");\n     /// ```\n-    #[unstable(feature = \"btree_append\", reason = \"recently added as part of collections reform 2\",\n-               issue = \"34152\")]\n+    #[stable(feature = \"btree_append\", since = \"1.11.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n         // Do we have to append anything at all?\n         if other.len() == 0 {\n@@ -914,7 +912,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(btree_split_off)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n@@ -936,9 +933,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(b[&17], \"d\");\n     /// assert_eq!(b[&41], \"e\");\n     /// ```\n-    #[unstable(feature = \"btree_split_off\",\n-               reason = \"recently added as part of collections reform 2\",\n-               issue = \"34152\")]\n+    #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n     pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n         where K: Borrow<Q>\n     {"}, {"sha": "0f885bc2950a6b3426778e7508445b286c76e47e", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -551,7 +551,6 @@ impl<T: Ord> BTreeSet<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(btree_append)]\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut a = BTreeSet::new();\n@@ -575,8 +574,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(a.contains(&4));\n     /// assert!(a.contains(&5));\n     /// ```\n-    #[unstable(feature = \"btree_append\", reason = \"recently added as part of collections reform 2\",\n-               issue = \"34152\")]\n+    #[stable(feature = \"btree_append\", since = \"1.11.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n         self.map.append(&mut other.map);\n     }\n@@ -589,7 +587,6 @@ impl<T: Ord> BTreeSet<T> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(btree_split_off)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n@@ -611,9 +608,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(b[&17], \"d\");\n     /// assert_eq!(b[&41], \"e\");\n     /// ```\n-    #[unstable(feature = \"btree_split_off\",\n-               reason = \"recently added as part of collections reform 2\",\n-               issue = \"34152\")]\n+    #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n     pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self where T: Borrow<Q> {\n         BTreeSet { map: self.map.split_off(key) }\n     }"}, {"sha": "f027d074cb6f0bc8175db50364576b4311b35122", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -38,7 +38,6 @@\n #![feature(fmt_internals)]\n #![feature(heap_api)]\n #![feature(inclusive_range)]\n-#![feature(iter_arith)]\n #![feature(lang_items)]\n #![feature(nonzero)]\n #![feature(pattern)]"}, {"sha": "8ae63808f27404b9abdc4406b6eab7ef40b251f6", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -11,18 +11,14 @@\n #![deny(warnings)]\n \n #![feature(binary_heap_extras)]\n-#![feature(binary_heap_append)]\n #![feature(binary_heap_peek_mut)]\n #![feature(box_syntax)]\n-#![feature(btree_append)]\n-#![feature(btree_split_off)]\n #![feature(btree_range)]\n #![feature(collections)]\n #![feature(collections_bound)]\n #![feature(const_fn)]\n #![feature(fn_traits)]\n #![feature(enumset)]\n-#![feature(iter_arith)]\n #![feature(linked_list_contains)]\n #![feature(pattern)]\n #![feature(rand)]"}, {"sha": "9435be3b0124b60bfb1fd36be9842558548ba449", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -238,7 +238,7 @@ impl<T:Copy> Cell<T> {\n     /// This call borrows `Cell` mutably (at compile-time) which guarantees\n     /// that we possess the only reference.\n     #[inline]\n-    #[unstable(feature = \"cell_get_mut\", issue = \"33444\")]\n+    #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n         unsafe {\n             &mut *self.value.get()\n@@ -509,7 +509,7 @@ impl<T: ?Sized> RefCell<T> {\n     /// This call borrows `RefCell` mutably (at compile-time) so there is no\n     /// need for dynamic checks.\n     #[inline]\n-    #[unstable(feature = \"cell_get_mut\", issue=\"33444\")]\n+    #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n         unsafe {\n             &mut *self.value.get()"}, {"sha": "895a679fc3dccf76b1d7efae56248e31733b3f54", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -840,11 +840,8 @@ pub fn write(output: &mut Write, args: Arguments) -> Result {\n     }\n \n     // There can be only one trailing string piece left.\n-    match pieces.next() {\n-        Some(piece) => {\n-            formatter.buf.write_str(*piece)?;\n-        }\n-        None => {}\n+    if let Some(piece) = pieces.next() {\n+        formatter.buf.write_str(*piece)?;\n     }\n \n     Ok(())"}, {"sha": "6b01ccaceea2f31c3726597244a23ccefdda2fc1", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -11,18 +11,16 @@\n use clone::Clone;\n use cmp::{Ord, PartialOrd, PartialEq, Ordering};\n use default::Default;\n-use num::{Zero, One};\n-use ops::{Add, FnMut, Mul};\n+use ops::FnMut;\n use option::Option::{self, Some, None};\n use marker::Sized;\n \n-use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, FlatMap, Fuse,\n-            Inspect, Map, Peekable, Scan, Skip, SkipWhile, Take, TakeWhile, Rev,\n-            Zip};\n+use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, FlatMap, Fuse};\n+use super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, Take, TakeWhile, Rev};\n+use super::{Zip, Sum, Product};\n use super::ChainState;\n-use super::{DoubleEndedIterator, ExactSizeIterator, Extend, FromIterator,\n-            IntoIterator};\n-use super::ZipImpl;\n+use super::{DoubleEndedIterator, ExactSizeIterator, Extend, FromIterator};\n+use super::{IntoIterator, ZipImpl};\n \n fn _assert_is_object_safe(_: &Iterator<Item=()>) {}\n \n@@ -1820,50 +1818,54 @@ pub trait Iterator {\n     ///\n     /// An empty iterator returns the zero value of the type.\n     ///\n+    /// # Panics\n+    ///\n+    /// When calling `sum` and a primitive integer type is being returned, this\n+    /// method will panic if the computation overflows.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(iter_arith)]\n-    ///\n     /// let a = [1, 2, 3];\n     /// let sum: i32 = a.iter().sum();\n     ///\n     /// assert_eq!(sum, 6);\n     /// ```\n-    #[unstable(feature = \"iter_arith\", reason = \"bounds recently changed\",\n-               issue = \"27739\")]\n-    fn sum<S>(self) -> S where\n-        S: Add<Self::Item, Output=S> + Zero,\n-        Self: Sized,\n+    #[stable(feature = \"iter_arith\", since = \"1.11.0\")]\n+    fn sum<S>(self) -> S\n+        where Self: Sized,\n+              S: Sum<Self::Item>,\n     {\n-        self.fold(Zero::zero(), |s, e| s + e)\n+        Sum::sum(self)\n     }\n \n     /// Iterates over the entire iterator, multiplying all the elements\n     ///\n     /// An empty iterator returns the one value of the type.\n     ///\n+    /// # Panics\n+    ///\n+    /// When calling `product` and a primitive integer type is being returned,\n+    /// this method will panic if the computation overflows.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(iter_arith)]\n-    ///\n     /// fn factorial(n: u32) -> u32 {\n     ///     (1..).take_while(|&i| i <= n).product()\n     /// }\n     /// assert_eq!(factorial(0), 1);\n     /// assert_eq!(factorial(1), 1);\n     /// assert_eq!(factorial(5), 120);\n     /// ```\n-    #[unstable(feature=\"iter_arith\", reason = \"bounds recently changed\",\n-               issue = \"27739\")]\n-    fn product<P>(self) -> P where\n-        P: Mul<Self::Item, Output=P> + One,\n-        Self: Sized,\n+    #[stable(feature = \"iter_arith\", since = \"1.11.0\")]\n+    fn product<P>(self) -> P\n+        where Self: Sized,\n+              P: Product<Self::Item>,\n     {\n-        self.fold(One::one(), |p, e| p * e)\n+        Product::product(self)\n     }\n \n     /// Lexicographically compares the elements of this `Iterator` with those"}, {"sha": "3ebab266e2ffed5494cc069a90172e64833f9b83", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -327,8 +327,9 @@ pub use self::sources::{Empty, empty};\n pub use self::sources::{Once, once};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::traits::{FromIterator, IntoIterator, DoubleEndedIterator, Extend,\n-                       ExactSizeIterator};\n+pub use self::traits::{FromIterator, IntoIterator, DoubleEndedIterator, Extend};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::traits::{ExactSizeIterator, Sum, Product};\n \n mod iterator;\n mod range;"}, {"sha": "c234ef21db6d12878e09e722ed507d058948a42a", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 137, "deletions": 32, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -11,7 +11,6 @@\n use clone::Clone;\n use cmp::PartialOrd;\n use mem;\n-use num::{Zero, One};\n use ops::{self, Add, Sub};\n use option::Option::{self, Some, None};\n use marker::Sized;\n@@ -36,6 +35,24 @@ pub trait Step: PartialOrd + Sized {\n     /// Returns `None` if it is not possible to calculate `steps_between`\n     /// without overflow.\n     fn steps_between(start: &Self, end: &Self, by: &Self) -> Option<usize>;\n+\n+    /// Same as `steps_between`, but with a `by` of 1\n+    fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize>;\n+\n+    /// Tests whether this step is negative or not (going backwards)\n+    fn is_negative(&self) -> bool;\n+\n+    /// Replaces this step with `1`, returning itself\n+    fn replace_one(&mut self) -> Self;\n+\n+    /// Replaces this step with `0`, returning itself\n+    fn replace_zero(&mut self) -> Self;\n+\n+    /// Adds one to this step, returning the result\n+    fn add_one(&self) -> Self;\n+\n+    /// Subtracts one to this step, returning the result\n+    fn sub_one(&self) -> Self;\n }\n \n macro_rules! step_impl_unsigned {\n@@ -65,6 +82,36 @@ macro_rules! step_impl_unsigned {\n                     Some(0)\n                 }\n             }\n+\n+            #[inline]\n+            fn is_negative(&self) -> bool {\n+                false\n+            }\n+\n+            #[inline]\n+            fn replace_one(&mut self) -> Self {\n+                mem::replace(self, 0)\n+            }\n+\n+            #[inline]\n+            fn replace_zero(&mut self) -> Self {\n+                mem::replace(self, 1)\n+            }\n+\n+            #[inline]\n+            fn add_one(&self) -> Self {\n+                *self + 1\n+            }\n+\n+            #[inline]\n+            fn sub_one(&self) -> Self {\n+                *self - 1\n+            }\n+\n+            #[inline]\n+            fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize> {\n+                Self::steps_between(start, end, &1)\n+            }\n         }\n     )*)\n }\n@@ -106,6 +153,36 @@ macro_rules! step_impl_signed {\n                     Some(diff / by_u)\n                 }\n             }\n+\n+            #[inline]\n+            fn is_negative(&self) -> bool {\n+                *self < 0\n+            }\n+\n+            #[inline]\n+            fn replace_one(&mut self) -> Self {\n+                mem::replace(self, 0)\n+            }\n+\n+            #[inline]\n+            fn replace_zero(&mut self) -> Self {\n+                mem::replace(self, 1)\n+            }\n+\n+            #[inline]\n+            fn add_one(&self) -> Self {\n+                *self + 1\n+            }\n+\n+            #[inline]\n+            fn sub_one(&self) -> Self {\n+                *self - 1\n+            }\n+\n+            #[inline]\n+            fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize> {\n+                Self::steps_between(start, end, &1)\n+            }\n         }\n     )*)\n }\n@@ -124,6 +201,37 @@ macro_rules! step_impl_no_between {\n             fn steps_between(_a: &$t, _b: &$t, _by: &$t) -> Option<usize> {\n                 None\n             }\n+\n+            #[inline]\n+            #[allow(unused_comparisons)]\n+            fn is_negative(&self) -> bool {\n+                *self < 0\n+            }\n+\n+            #[inline]\n+            fn replace_one(&mut self) -> Self {\n+                mem::replace(self, 0)\n+            }\n+\n+            #[inline]\n+            fn replace_zero(&mut self) -> Self {\n+                mem::replace(self, 1)\n+            }\n+\n+            #[inline]\n+            fn add_one(&self) -> Self {\n+                *self + 1\n+            }\n+\n+            #[inline]\n+            fn sub_one(&self) -> Self {\n+                *self - 1\n+            }\n+\n+            #[inline]\n+            fn steps_between_by_one(start: &Self, end: &Self) -> Option<usize> {\n+                Self::steps_between(start, end, &1)\n+            }\n         }\n     )*)\n }\n@@ -269,12 +377,12 @@ impl<A> Iterator for StepBy<A, ops::RangeFrom<A>> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n+impl<A: Step + Clone> Iterator for StepBy<A, ops::Range<A>> {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        let rev = self.step_by < A::zero();\n+        let rev = self.step_by.is_negative();\n         if (rev && self.range.start > self.range.end) ||\n            (!rev && self.range.start < self.range.end)\n         {\n@@ -308,7 +416,7 @@ impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n #[unstable(feature = \"inclusive_range\",\n            reason = \"recently added, follows RFC\",\n            issue = \"28237\")]\n-impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n+impl<A: Step + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n     type Item = A;\n \n     #[inline]\n@@ -322,8 +430,7 @@ impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n             Empty { .. } => return None, // empty iterators yield no values\n \n             NonEmpty { ref mut start, ref mut end } => {\n-                let zero = A::zero();\n-                let rev = self.step_by < zero;\n+                let rev = self.step_by.is_negative();\n \n                 // march start towards (maybe past!) end and yield the old value\n                 if (rev && start >= end) ||\n@@ -342,7 +449,7 @@ impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::RangeInclusive<A>> {\n                     }\n                 } else {\n                     // found range in inconsistent state (start at or past end), so become empty\n-                    (Some(mem::replace(end, zero)), None)\n+                    (Some(end.replace_zero()), None)\n                 }\n             }\n         };\n@@ -386,15 +493,15 @@ macro_rules! range_exact_iter_impl {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step + One> Iterator for ops::Range<A> where\n+impl<A: Step> Iterator for ops::Range<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>\n {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            let mut n = &self.start + &A::one();\n+            let mut n = self.start.add_one();\n             mem::swap(&mut n, &mut self.start);\n             Some(n)\n         } else {\n@@ -404,7 +511,7 @@ impl<A: Step + One> Iterator for ops::Range<A> where\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        match Step::steps_between(&self.start, &self.end, &A::one()) {\n+        match Step::steps_between_by_one(&self.start, &self.end) {\n             Some(hint) => (hint, Some(hint)),\n             None => (0, None)\n         }\n@@ -416,14 +523,14 @@ impl<A: Step + One> Iterator for ops::Range<A> where\n range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step + One + Clone> DoubleEndedIterator for ops::Range<A> where\n+impl<A: Step + Clone> DoubleEndedIterator for ops::Range<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>,\n     for<'a> &'a A: Sub<&'a A, Output = A>\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            self.end = &self.end - &A::one();\n+            self.end = self.end.sub_one();\n             Some(self.end.clone())\n         } else {\n             None\n@@ -432,21 +539,21 @@ impl<A: Step + One + Clone> DoubleEndedIterator for ops::Range<A> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step + One> Iterator for ops::RangeFrom<A> where\n+impl<A: Step> Iterator for ops::RangeFrom<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>\n {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        let mut n = &self.start + &A::one();\n+        let mut n = self.start.add_one();\n         mem::swap(&mut n, &mut self.start);\n         Some(n)\n     }\n }\n \n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<A: Step + One> Iterator for ops::RangeInclusive<A> where\n+impl<A: Step> Iterator for ops::RangeInclusive<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>\n {\n     type Item = A;\n@@ -463,23 +570,22 @@ impl<A: Step + One> Iterator for ops::RangeInclusive<A> where\n \n             NonEmpty { ref mut start, ref mut end } => {\n                 if start == end {\n-                    (Some(mem::replace(end, A::one())), Some(mem::replace(start, A::one())))\n+                    (Some(end.replace_one()), Some(start.replace_one()))\n                 } else if start < end {\n-                    let one = A::one();\n-                    let mut n = &*start + &one;\n+                    let mut n = start.add_one();\n                     mem::swap(&mut n, start);\n \n-                    // if the iterator is done iterating, it will change from NonEmpty to Empty\n-                    // to avoid unnecessary drops or clones, we'll reuse either start or end\n-                    // (they are equal now, so it doesn't matter which)\n-                    // to pull out end, we need to swap something back in -- use the previously\n-                    // created A::one() as a dummy value\n+                    // if the iterator is done iterating, it will change from\n+                    // NonEmpty to Empty to avoid unnecessary drops or clones,\n+                    // we'll reuse either start or end (they are equal now, so\n+                    // it doesn't matter which) to pull out end, we need to swap\n+                    // something back in\n \n-                    (if n == *end { Some(mem::replace(end, one)) } else { None },\n+                    (if n == *end { Some(end.replace_one()) } else { None },\n                     // ^ are we done yet?\n                     Some(n)) // < the value to output\n                 } else {\n-                    (Some(mem::replace(start, A::one())), None)\n+                    (Some(start.replace_one()), None)\n                 }\n             }\n         };\n@@ -500,7 +606,7 @@ impl<A: Step + One> Iterator for ops::RangeInclusive<A> where\n             Empty { .. } => (0, Some(0)),\n \n             NonEmpty { ref start, ref end } =>\n-                match Step::steps_between(start, end, &A::one()) {\n+                match Step::steps_between_by_one(start, end) {\n                     Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n                     None => (0, None),\n                 }\n@@ -509,7 +615,7 @@ impl<A: Step + One> Iterator for ops::RangeInclusive<A> where\n }\n \n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<A: Step + One> DoubleEndedIterator for ops::RangeInclusive<A> where\n+impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>,\n     for<'a> &'a A: Sub<&'a A, Output = A>\n {\n@@ -524,16 +630,15 @@ impl<A: Step + One> DoubleEndedIterator for ops::RangeInclusive<A> where\n \n             NonEmpty { ref mut start, ref mut end } => {\n                 if start == end {\n-                    (Some(mem::replace(start, A::one())), Some(mem::replace(end, A::one())))\n+                    (Some(start.replace_one()), Some(end.replace_one()))\n                 } else if start < end {\n-                    let one = A::one();\n-                    let mut n = &*end - &one;\n+                    let mut n = end.sub_one();\n                     mem::swap(&mut n, end);\n \n-                    (if n == *start { Some(mem::replace(start, one)) } else { None },\n+                    (if n == *start { Some(start.replace_one()) } else { None },\n                      Some(n))\n                 } else {\n-                    (Some(mem::replace(end, A::one())), None)\n+                    (Some(end.replace_one()), None)\n                 }\n             }\n         };"}, {"sha": "3549bd6a3bc68f4fcfa52cab27ed36a9817b5378", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -524,3 +524,104 @@ pub trait ExactSizeIterator: Iterator {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, I: ExactSizeIterator + ?Sized> ExactSizeIterator for &'a mut I {}\n \n+/// Trait to represent types that can be created by summing up an iterator.\n+///\n+/// This trait is used to implement the `sum` method on iterators. Types which\n+/// implement the trait can be generated by the `sum` method. Like\n+/// `FromIterator` this trait should rarely be called directly and instead\n+/// interacted with through `Iterator::sum`.\n+#[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+pub trait Sum<A = Self>: Sized {\n+    /// Method which takes an iterator and generates `Self` from the elements by\n+    /// \"summing up\" the items.\n+    fn sum<I: Iterator<Item=A>>(iter: I) -> Self;\n+}\n+\n+/// Trait to represent types that can be created by multiplying elements of an\n+/// iterator.\n+///\n+/// This trait is used to implement the `product` method on iterators. Types\n+/// which implement the trait can be generated by the `product` method. Like\n+/// `FromIterator` this trait should rarely be called directly and instead\n+/// interacted with through `Iterator::product`.\n+#[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+pub trait Product<A = Self>: Sized {\n+    /// Method which takes an iterator and generates `Self` from the elements by\n+    /// multiplying the items.\n+    fn product<I: Iterator<Item=A>>(iter: I) -> Self;\n+}\n+\n+macro_rules! integer_sum_product {\n+    ($($a:ident)*) => ($(\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl Sum for $a {\n+            fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold(0, |a, b| {\n+                    a.checked_add(b).expect(\"overflow in sum\")\n+                })\n+            }\n+        }\n+\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl Product for $a {\n+            fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold(1, |a, b| {\n+                    a.checked_mul(b).expect(\"overflow in product\")\n+                })\n+            }\n+        }\n+\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl<'a> Sum<&'a $a> for $a {\n+            fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold(0, |a, b| {\n+                    a.checked_add(*b).expect(\"overflow in sum\")\n+                })\n+            }\n+        }\n+\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl<'a> Product<&'a $a> for $a {\n+            fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold(1, |a, b| {\n+                    a.checked_mul(*b).expect(\"overflow in product\")\n+                })\n+            }\n+        }\n+    )*)\n+}\n+\n+macro_rules! float_sum_product {\n+    ($($a:ident)*) => ($(\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl Sum for $a {\n+            fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold(0.0, |a, b| a + b)\n+            }\n+        }\n+\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl Product for $a {\n+            fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold(1.0, |a, b| a * b)\n+            }\n+        }\n+\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl<'a> Sum<&'a $a> for $a {\n+            fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold(0.0, |a, b| a + *b)\n+            }\n+        }\n+\n+        #[unstable(feature = \"iter_arith_traits\", issue = \"34529\")]\n+        impl<'a> Product<&'a $a> for $a {\n+            fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold(1.0, |a, b| a * *b)\n+            }\n+        }\n+    )*)\n+}\n+\n+integer_sum_product! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+float_sum_product! { f32 f64 }"}, {"sha": "e849369d647c4754967d63f3d7cd627ae0fc8929", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -59,6 +59,8 @@\n #![deny(missing_debug_implementations)]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n+#![cfg_attr(stage0, allow(unused_attributes))]\n+\n #![feature(allow_internal_unstable)]\n #![feature(asm)]\n #![feature(associated_type_defaults)]"}, {"sha": "4761727cec03ff93594b2fb4d706c960ba99479a", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -321,7 +321,7 @@ pub fn algorithm_m<T: RawFloat>(f: &Big, e: i16) -> T {\n             return underflow(x, v, rem);\n         }\n         if k > T::max_exp_int() {\n-            return T::infinity();\n+            return T::infinity2();\n         }\n         if x < min_sig {\n             u.mul_pow2(1);"}, {"sha": "ff2d85307b1060ef6cb2c5a2bcc619a80fe2b7f5", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -215,11 +215,11 @@ fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n     let (sign, s) = extract_sign(s);\n     let flt = match parse_decimal(s) {\n         ParseResult::Valid(decimal) => convert(decimal)?,\n-        ParseResult::ShortcutToInf => T::infinity(),\n-        ParseResult::ShortcutToZero => T::zero(),\n+        ParseResult::ShortcutToInf => T::infinity2(),\n+        ParseResult::ShortcutToZero => T::zero2(),\n         ParseResult::Invalid => match s {\n-            \"inf\" => T::infinity(),\n-            \"NaN\" => T::nan(),\n+            \"inf\" => T::infinity2(),\n+            \"NaN\" => T::nan2(),\n             _ => { return Err(pfe_invalid()); }\n         }\n     };\n@@ -316,17 +316,17 @@ fn bound_intermediate_digits(decimal: &Decimal, e: i64) -> u64 {\n fn trivial_cases<T: RawFloat>(decimal: &Decimal) -> Option<T> {\n     // There were zeros but they were stripped by simplify()\n     if decimal.integral.is_empty() && decimal.fractional.is_empty() {\n-        return Some(T::zero());\n+        return Some(T::zero2());\n     }\n     // This is a crude approximation of ceil(log10(the real value)). We don't need to worry too\n     // much about overflow here because the input length is tiny (at least compared to 2^64) and\n     // the parser already handles exponents whose absolute value is greater than 10^18\n     // (which is still 10^19 short of 2^64).\n     let max_place = decimal.exp + decimal.integral.len() as i64;\n     if max_place > T::inf_cutoff() {\n-        return Some(T::infinity());\n+        return Some(T::infinity2());\n     } else if max_place < T::zero_cutoff() {\n-        return Some(T::zero());\n+        return Some(T::zero2());\n     }\n     None\n }"}, {"sha": "68e4dc4b359efa73fb3ee5373004d569f756fcd9", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -61,6 +61,27 @@ impl Unpacked {\n pub trait RawFloat : Float + Copy + Debug + LowerExp\n                     + Mul<Output=Self> + Div<Output=Self> + Neg<Output=Self>\n {\n+    // suffix of \"2\" because Float::infinity is deprecated\n+    #[allow(deprecated)]\n+    fn infinity2() -> Self {\n+        Float::infinity()\n+    }\n+\n+    // suffix of \"2\" because Float::nan is deprecated\n+    #[allow(deprecated)]\n+    fn nan2() -> Self {\n+        Float::nan()\n+    }\n+\n+    // suffix of \"2\" because Float::zero is deprecated\n+    fn zero2() -> Self;\n+\n+    // suffix of \"2\" because Float::integer_decode is deprecated\n+    #[allow(deprecated)]\n+    fn integer_decode2(self) -> (u64, i16, i8) {\n+        Float::integer_decode(self)\n+    }\n+\n     /// Get the raw binary representation of the float.\n     fn transmute(self) -> u64;\n \n@@ -146,6 +167,10 @@ pub trait RawFloat : Float + Copy + Debug + LowerExp\n }\n \n impl RawFloat for f32 {\n+    fn zero2() -> Self {\n+        0.0\n+    }\n+\n     fn sig_bits() -> u8 {\n         24\n     }\n@@ -169,7 +194,7 @@ impl RawFloat for f32 {\n     }\n \n     fn unpack(self) -> Unpacked {\n-        let (sig, exp, _sig) = self.integer_decode();\n+        let (sig, exp, _sig) = self.integer_decode2();\n         Unpacked::new(sig, exp)\n     }\n \n@@ -198,6 +223,10 @@ impl RawFloat for f32 {\n \n \n impl RawFloat for f64 {\n+    fn zero2() -> Self {\n+        0.0\n+    }\n+\n     fn sig_bits() -> u8 {\n         53\n     }\n@@ -220,7 +249,7 @@ impl RawFloat for f64 {\n     }\n \n     fn unpack(self) -> Unpacked {\n-        let (sig, exp, _sig) = self.integer_decode();\n+        let (sig, exp, _sig) = self.integer_decode2();\n         Unpacked::new(sig, exp)\n     }\n \n@@ -351,7 +380,7 @@ pub fn prev_float<T: RawFloat>(x: T) -> T {\n pub fn next_float<T: RawFloat>(x: T) -> T {\n     match x.classify() {\n         Nan => panic!(\"next_float: argument is NaN\"),\n-        Infinite => T::infinity(),\n+        Infinite => T::infinity2(),\n         // This seems too good to be true, but it works.\n         // 0.0 is encoded as the all-zero word. Subnormals are 0x000m...m where m is the mantissa.\n         // In particular, the smallest subnormal is 0x0...01 and the largest is 0x000F...F."}, {"sha": "79e1462eaa135eb58013a157fb584f6823b5485f", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -168,7 +168,7 @@ impl Float for f32 {\n     /// Returns `true` if the number is infinite.\n     #[inline]\n     fn is_infinite(self) -> bool {\n-        self == Float::infinity() || self == Float::neg_infinity()\n+        self == INFINITY || self == NEG_INFINITY\n     }\n \n     /// Returns `true` if the number is neither infinite or NaN.\n@@ -230,7 +230,7 @@ impl Float for f32 {\n     #[inline]\n     fn signum(self) -> f32 {\n         if self.is_nan() {\n-            Float::nan()\n+            NAN\n         } else {\n             unsafe { intrinsics::copysignf32(1.0, self) }\n         }\n@@ -240,14 +240,14 @@ impl Float for f32 {\n     /// `Float::infinity()`.\n     #[inline]\n     fn is_sign_positive(self) -> bool {\n-        self > 0.0 || (1.0 / self) == Float::infinity()\n+        self > 0.0 || (1.0 / self) == INFINITY\n     }\n \n     /// Returns `true` if `self` is negative, including `-0.0` and\n     /// `Float::neg_infinity()`.\n     #[inline]\n     fn is_sign_negative(self) -> bool {\n-        self < 0.0 || (1.0 / self) == Float::neg_infinity()\n+        self < 0.0 || (1.0 / self) == NEG_INFINITY\n     }\n \n     /// Returns the reciprocal (multiplicative inverse) of the number."}, {"sha": "35557f61c45420b5ff291aa369876a63e94be7aa", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -168,7 +168,7 @@ impl Float for f64 {\n     /// Returns `true` if the number is infinite.\n     #[inline]\n     fn is_infinite(self) -> bool {\n-        self == Float::infinity() || self == Float::neg_infinity()\n+        self == INFINITY || self == NEG_INFINITY\n     }\n \n     /// Returns `true` if the number is neither infinite or NaN.\n@@ -230,7 +230,7 @@ impl Float for f64 {\n     #[inline]\n     fn signum(self) -> f64 {\n         if self.is_nan() {\n-            Float::nan()\n+            NAN\n         } else {\n             unsafe { intrinsics::copysignf64(1.0, self) }\n         }\n@@ -240,14 +240,14 @@ impl Float for f64 {\n     /// `Float::infinity()`.\n     #[inline]\n     fn is_sign_positive(self) -> bool {\n-        self > 0.0 || (1.0 / self) == Float::infinity()\n+        self > 0.0 || (1.0 / self) == INFINITY\n     }\n \n     /// Returns `true` if `self` is negative, including `-0.0` and\n     /// `Float::neg_infinity()`.\n     #[inline]\n     fn is_sign_negative(self) -> bool {\n-        self < 0.0 || (1.0 / self) == Float::neg_infinity()\n+        self < 0.0 || (1.0 / self) == NEG_INFINITY\n     }\n \n     /// Returns the reciprocal (multiplicative inverse) of the number."}, {"sha": "5420e7bdd2a5a064092b398387c89ec884c97c6b", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -13,7 +13,8 @@\n use prelude::v1::*;\n \n use {f32, f64};\n-use num::{Float, FpCategory};\n+use num::FpCategory;\n+use num::dec2flt::rawfp::RawFloat;\n \n /// Decoded unsigned finite value, such that:\n ///\n@@ -52,7 +53,7 @@ pub enum FullDecoded {\n }\n \n /// A floating point type which can be `decode`d.\n-pub trait DecodableFloat: Float + Copy {\n+pub trait DecodableFloat: RawFloat + Copy {\n     /// The minimum positive normalized value.\n     fn min_pos_norm_value() -> Self;\n }\n@@ -68,7 +69,7 @@ impl DecodableFloat for f64 {\n /// Returns a sign (true when negative) and `FullDecoded` value\n /// from given floating point number.\n pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n-    let (mant, exp, sign) = v.integer_decode();\n+    let (mant, exp, sign) = v.integer_decode2();\n     let even = (mant & 1) == 0;\n     let decoded = match v.classify() {\n         FpCategory::Nan => FullDecoded::Nan,\n@@ -82,7 +83,7 @@ pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n                                           exp: exp, inclusive: even })\n         }\n         FpCategory::Normal => {\n-            let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode();\n+            let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode2();\n             if mant == minnorm.0 {\n                 // neighbors: (maxmant, exp - 1) -- (minnormmant, exp) -- (minnormmant + 1, exp)\n                 // where maxmant = minnormmant * 2 - 1"}, {"sha": "0d79398a8f1d51bd26e975a0a45fe16fe5b58aab", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -109,6 +109,8 @@ pub mod diy_float;\n #[unstable(feature = \"zero_one\",\n            reason = \"unsure of placement, wants to use associated constants\",\n            issue = \"27739\")]\n+#[rustc_deprecated(since = \"1.11.0\", reason = \"no longer used for \\\n+                                               Iterator::sum\")]\n pub trait Zero: Sized {\n     /// The \"zero\" (usually, additive identity) for this type.\n     fn zero() -> Self;\n@@ -121,6 +123,8 @@ pub trait Zero: Sized {\n #[unstable(feature = \"zero_one\",\n            reason = \"unsure of placement, wants to use associated constants\",\n            issue = \"27739\")]\n+#[rustc_deprecated(since = \"1.11.0\", reason = \"no longer used for \\\n+                                               Iterator::product\")]\n pub trait One: Sized {\n     /// The \"one\" (usually, multiplicative identity) for this type.\n     fn one() -> Self;\n@@ -131,13 +135,15 @@ macro_rules! zero_one_impl {\n         #[unstable(feature = \"zero_one\",\n                    reason = \"unsure of placement, wants to use associated constants\",\n                    issue = \"27739\")]\n+        #[allow(deprecated)]\n         impl Zero for $t {\n             #[inline]\n             fn zero() -> Self { 0 }\n         }\n         #[unstable(feature = \"zero_one\",\n                    reason = \"unsure of placement, wants to use associated constants\",\n                    issue = \"27739\")]\n+        #[allow(deprecated)]\n         impl One for $t {\n             #[inline]\n             fn one() -> Self { 1 }\n@@ -151,13 +157,15 @@ macro_rules! zero_one_impl_float {\n         #[unstable(feature = \"zero_one\",\n                    reason = \"unsure of placement, wants to use associated constants\",\n                    issue = \"27739\")]\n+        #[allow(deprecated)]\n         impl Zero for $t {\n             #[inline]\n             fn zero() -> Self { 0.0 }\n         }\n         #[unstable(feature = \"zero_one\",\n                    reason = \"unsure of placement, wants to use associated constants\",\n                    issue = \"27739\")]\n+        #[allow(deprecated)]\n         impl One for $t {\n             #[inline]\n             fn one() -> Self { 1.0 }\n@@ -604,7 +612,7 @@ macro_rules! int_impl {\n         pub fn saturating_add(self, other: Self) -> Self {\n             match self.checked_add(other) {\n                 Some(x) => x,\n-                None if other >= Self::zero() => Self::max_value(),\n+                None if other >= 0 => Self::max_value(),\n                 None => Self::min_value(),\n             }\n         }\n@@ -625,7 +633,7 @@ macro_rules! int_impl {\n         pub fn saturating_sub(self, other: Self) -> Self {\n             match self.checked_sub(other) {\n                 Some(x) => x,\n-                None if other >= Self::zero() => Self::min_value(),\n+                None if other >= 0 => Self::min_value(),\n                 None => Self::max_value(),\n             }\n         }\n@@ -1064,7 +1072,7 @@ macro_rules! int_impl {\n         #[rustc_inherit_overflow_checks]\n         pub fn pow(self, mut exp: u32) -> Self {\n             let mut base = self;\n-            let mut acc = Self::one();\n+            let mut acc = 1;\n \n             while exp > 1 {\n                 if (exp & 1) == 1 {\n@@ -2092,7 +2100,7 @@ macro_rules! uint_impl {\n         #[rustc_inherit_overflow_checks]\n         pub fn pow(self, mut exp: u32) -> Self {\n             let mut base = self;\n-            let mut acc = Self::one();\n+            let mut acc = 1;\n \n             let mut prev_base = self;\n             let mut base_oflo = false;\n@@ -2129,8 +2137,7 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn is_power_of_two(self) -> bool {\n-            (self.wrapping_sub(Self::one())) & self == Self::zero() &&\n-                !(self == Self::zero())\n+            (self.wrapping_sub(1)) & self == 0 && !(self == 0)\n         }\n \n         /// Returns the smallest power of two greater than or equal to `self`.\n@@ -2148,7 +2155,7 @@ macro_rules! uint_impl {\n         #[inline]\n         pub fn next_power_of_two(self) -> Self {\n             let bits = size_of::<Self>() * 8;\n-            let one: Self = Self::one();\n+            let one: Self = 1;\n             one << ((bits - self.wrapping_sub(one).leading_zeros() as usize) % bits)\n         }\n \n@@ -2303,26 +2310,44 @@ pub trait Float: Sized {\n     /// Returns the NaN value.\n     #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     fn nan() -> Self;\n     /// Returns the infinite value.\n     #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     fn infinity() -> Self;\n     /// Returns the negative infinite value.\n     #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     fn neg_infinity() -> Self;\n     /// Returns -0.0.\n     #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     fn neg_zero() -> Self;\n     /// Returns 0.0.\n     #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     fn zero() -> Self;\n     /// Returns 1.0.\n     #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     fn one() -> Self;\n \n     /// Returns true if this value is NaN and false otherwise.\n@@ -2345,6 +2370,9 @@ pub trait Float: Sized {\n     /// Returns the mantissa, exponent and sign as integers, respectively.\n     #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     fn integer_decode(self) -> (u64, i16, i8);\n \n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n@@ -2379,12 +2407,10 @@ pub trait Float: Sized {\n     fn powi(self, n: i32) -> Self;\n \n     /// Convert radians to degrees.\n-    #[unstable(feature = \"float_extras\", reason = \"desirability is unclear\",\n-               issue = \"27752\")]\n+    #[stable(feature = \"deg_rad_conversions\", since=\"1.7.0\")]\n     fn to_degrees(self) -> Self;\n     /// Convert degrees to radians.\n-    #[unstable(feature = \"float_extras\", reason = \"desirability is unclear\",\n-               issue = \"27752\")]\n+    #[stable(feature = \"deg_rad_conversions\", since=\"1.7.0\")]\n     fn to_radians(self) -> Self;\n }\n "}, {"sha": "7753aae147a88d722d532d7198e1d52bf7b3e9cd", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -69,9 +69,7 @@\n \n use cmp::PartialOrd;\n use fmt;\n-use convert::From;\n use marker::{Sized, Unsize};\n-use num::One;\n \n /// The `Drop` trait is used to run some code when a value goes out of scope.\n /// This is sometimes called a 'destructor'.\n@@ -1494,7 +1492,6 @@ impl fmt::Debug for RangeFull {\n /// # Examples\n ///\n /// ```\n-/// #![feature(iter_arith)]\n /// fn main() {\n ///     assert_eq!((3..5), std::ops::Range{ start: 3, end: 5 });\n ///     assert_eq!(3+4+5, (3..6).sum());\n@@ -1558,7 +1555,6 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n /// # Examples\n ///\n /// ```\n-/// #![feature(iter_arith)]\n /// fn main() {\n ///     assert_eq!((2..), std::ops::RangeFrom{ start: 2 });\n ///     assert_eq!(2+3+4, (2..).take(3).sum());\n@@ -1660,7 +1656,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// # Examples\n ///\n /// ```\n-/// #![feature(inclusive_range,inclusive_range_syntax,iter_arith)]\n+/// #![feature(inclusive_range,inclusive_range_syntax)]\n /// fn main() {\n ///     assert_eq!((3...5), std::ops::RangeInclusive::NonEmpty{ start: 3, end: 5 });\n ///     assert_eq!(3+4+5, (3...5).sum());\n@@ -1714,24 +1710,6 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     }\n }\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<Idx: PartialOrd + One + Sub<Output=Idx>> From<Range<Idx>> for RangeInclusive<Idx> {\n-    fn from(range: Range<Idx>) -> RangeInclusive<Idx> {\n-        use self::RangeInclusive::*;\n-\n-        if range.start < range.end {\n-            NonEmpty {\n-                start: range.start,\n-                end: range.end - Idx::one() // can't underflow because end > start >= MIN\n-            }\n-        } else {\n-            Empty {\n-                at: range.start\n-            }\n-        }\n-    }\n-}\n-\n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// # Examples"}, {"sha": "94c6c636ce8fce6469f374dbfdb730f60051ea3b", "filename": "src/libcore/result.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -175,8 +175,11 @@\n //! }\n //!\n //! fn write_info(info: &Info) -> io::Result<()> {\n-//!     let mut file = try!(File::create(\"my_best_friends.txt\"));\n //!     // Early return on error\n+//!     let mut file = match File::create(\"my_best_friends.txt\") {\n+//!            Err(e) => return Err(e),\n+//!            Ok(f) => f,\n+//!     };\n //!     if let Err(e) = file.write_all(format!(\"name: {}\\n\", info.name).as_bytes()) {\n //!         return Err(e)\n //!     }"}, {"sha": "053158c14bf20ffb5ac4f6618cc23a5685a78796", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -19,9 +19,7 @@\n #![feature(core_private_diy_float)]\n #![feature(dec2flt)]\n #![feature(fixed_size_array)]\n-#![feature(float_extras)]\n #![feature(flt2dec)]\n-#![feature(iter_arith)]\n #![feature(libc)]\n #![feature(nonzero)]\n #![feature(rand)]"}, {"sha": "1a3533317dae68c57aed2528469ed575e738e58d", "filename": "src/libcoretest/num/dec2flt/rawfp.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcoretest%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcoretest%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fdec2flt%2Frawfp.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -9,9 +9,24 @@\n // except according to those terms.\n \n use std::f64;\n+use std::mem;\n use core::num::diy_float::Fp;\n use core::num::dec2flt::rawfp::{fp_to_float, prev_float, next_float, round_normal};\n \n+fn integer_decode(f: f64) -> (u64, i16, i8) {\n+    let bits: u64 = unsafe { mem::transmute(f) };\n+    let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n+    let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n+    let mantissa = if exponent == 0 {\n+        (bits & 0xfffffffffffff) << 1\n+    } else {\n+        (bits & 0xfffffffffffff) | 0x10000000000000\n+    };\n+    // Exponent bias + mantissa shift\n+    exponent -= 1023 + 52;\n+    (mantissa, exponent, sign)\n+}\n+\n #[test]\n fn fp_to_float_half_to_even() {\n     fn is_normalized(sig: u64) -> bool {\n@@ -21,12 +36,12 @@ fn fp_to_float_half_to_even() {\n \n     fn conv(sig: u64) -> u64 {\n         // The significands are perfectly in range, so the exponent should not matter\n-        let (m1, e1, _) = fp_to_float::<f64>(Fp { f: sig, e: 0 }).integer_decode();\n+        let (m1, e1, _) = integer_decode(fp_to_float::<f64>(Fp { f: sig, e: 0 }));\n         assert_eq!(e1, 0 + 64 - 53);\n-        let (m2, e2, _) = fp_to_float::<f64>(Fp { f: sig, e: 55 }).integer_decode();\n+        let (m2, e2, _) = integer_decode(fp_to_float::<f64>(Fp { f: sig, e: 55 }));\n         assert_eq!(e2, 55 + 64 - 53);\n         assert_eq!(m2, m1);\n-        let (m3, e3, _) = fp_to_float::<f64>(Fp { f: sig, e: -78 }).integer_decode();\n+        let (m3, e3, _) = integer_decode(fp_to_float::<f64>(Fp { f: sig, e: -78 }));\n         assert_eq!(e3, -78 + 64 - 53);\n         assert_eq!(m3, m2);\n         m3\n@@ -65,7 +80,7 @@ const SOME_FLOATS: [f64; 9] =\n #[test]\n fn human_f64_roundtrip() {\n     for &x in &SOME_FLOATS {\n-        let (f, e, _) = x.integer_decode();\n+        let (f, e, _) = integer_decode(x);\n         let fp = Fp { f: f, e: e};\n         assert_eq!(fp_to_float::<f64>(fp), x);\n     }"}, {"sha": "857aae72c8a5bd5d92a0088a36bbe3c37fc58b37", "filename": "src/libcoretest/num/flt2dec/estimator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::f64;\n use core::num::flt2dec::estimator::*;\n \n #[test]\n@@ -54,7 +53,7 @@ fn test_estimate_scaling_factor() {\n     assert_almost_eq!(estimate_scaling_factor(0x1fffffffffffff, 971), 309);\n \n     for i in -1074..972 {\n-        let expected = f64::ldexp(1.0, i).log10().ceil();\n+        let expected = super::ldexp_f64(1.0, i).log10().ceil();\n         assert_almost_eq!(estimate_scaling_factor(1, i as i16), expected as i16);\n     }\n }"}, {"sha": "0f4d19e7092571495405338fb31ef9f3a1f5fd9b", "filename": "src/libcoretest/num/flt2dec/mod.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -89,6 +89,17 @@ macro_rules! try_fixed {\n     })\n }\n \n+fn ldexp_f32(a: f32, b: i32) -> f32 {\n+    ldexp_f64(a as f64, b) as f32\n+}\n+\n+fn ldexp_f64(a: f64, b: i32) -> f64 {\n+    extern {\n+        fn ldexp(x: f64, n: i32) -> f64;\n+    }\n+    unsafe { ldexp(a, b) }\n+}\n+\n fn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16)\n         where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n     // use a large enough buffer\n@@ -237,7 +248,7 @@ pub fn f32_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     // 10^8 * 0.3355443\n     // 10^8 * 0.33554432\n     // 10^8 * 0.33554436\n-    check_shortest!(f(f32::ldexp(1.0, 25)) => b\"33554432\", 8);\n+    check_shortest!(f(ldexp_f32(1.0, 25)) => b\"33554432\", 8);\n \n     // 10^39 * 0.340282326356119256160033759537265639424\n     // 10^39 * 0.34028234663852885981170418348451692544\n@@ -252,13 +263,13 @@ pub fn f32_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     // 10^-44 * 0\n     // 10^-44 * 0.1401298464324817070923729583289916131280...\n     // 10^-44 * 0.2802596928649634141847459166579832262560...\n-    let minf32 = f32::ldexp(1.0, -149);\n+    let minf32 = ldexp_f32(1.0, -149);\n     check_shortest!(f(minf32) => b\"1\", -44);\n }\n \n pub fn f32_exact_sanity_test<F>(mut f: F)\n         where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n-    let minf32 = f32::ldexp(1.0, -149);\n+    let minf32 = ldexp_f32(1.0, -149);\n \n     check_exact!(f(0.1f32)            => b\"100000001490116119384765625             \", 0);\n     check_exact!(f(0.5f32)            => b\"5                                       \", 0);\n@@ -336,7 +347,7 @@ pub fn f64_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     // 10^20 * 0.18446744073709549568\n     // 10^20 * 0.18446744073709551616\n     // 10^20 * 0.18446744073709555712\n-    check_shortest!(f(f64::ldexp(1.0, 64)) => b\"18446744073709552\", 20);\n+    check_shortest!(f(ldexp_f64(1.0, 64)) => b\"18446744073709552\", 20);\n \n     // pathological case: high = 10^23 (exact). tie breaking should always prefer that.\n     // 10^24 * 0.099999999999999974834176\n@@ -357,13 +368,13 @@ pub fn f64_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     // 10^-323 * 0\n     // 10^-323 * 0.4940656458412465441765687928682213723650...\n     // 10^-323 * 0.9881312916824930883531375857364427447301...\n-    let minf64 = f64::ldexp(1.0, -1074);\n+    let minf64 = ldexp_f64(1.0, -1074);\n     check_shortest!(f(minf64) => b\"5\", -323);\n }\n \n pub fn f64_exact_sanity_test<F>(mut f: F)\n         where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n-    let minf64 = f64::ldexp(1.0, -1074);\n+    let minf64 = ldexp_f64(1.0, -1074);\n \n     check_exact!(f(0.1f64)            => b\"1000000000000000055511151231257827021181\", 0);\n     check_exact!(f(0.45f64)           => b\"4500000000000000111022302462515654042363\", 0);\n@@ -616,7 +627,7 @@ pub fn to_shortest_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f32::MAX, Minus, 1, false), format!(\"34028235{:0>31}.0\", \"\"));\n     assert_eq!(to_string(f, f32::MAX, Minus, 8, false), format!(\"34028235{:0>31}.00000000\", \"\"));\n \n-    let minf32 = f32::ldexp(1.0, -149);\n+    let minf32 = ldexp_f32(1.0, -149);\n     assert_eq!(to_string(f, minf32, Minus,  0, false), format!(\"0.{:0>44}1\", \"\"));\n     assert_eq!(to_string(f, minf32, Minus, 45, false), format!(\"0.{:0>44}1\", \"\"));\n     assert_eq!(to_string(f, minf32, Minus, 46, false), format!(\"0.{:0>44}10\", \"\"));\n@@ -628,7 +639,7 @@ pub fn to_shortest_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f64::MAX, Minus, 8, false),\n                format!(\"17976931348623157{:0>292}.00000000\", \"\"));\n \n-    let minf64 = f64::ldexp(1.0, -1074);\n+    let minf64 = ldexp_f64(1.0, -1074);\n     assert_eq!(to_string(f, minf64, Minus,   0, false), format!(\"0.{:0>323}5\", \"\"));\n     assert_eq!(to_string(f, minf64, Minus, 324, false), format!(\"0.{:0>323}5\", \"\"));\n     assert_eq!(to_string(f, minf64, Minus, 325, false), format!(\"0.{:0>323}50\", \"\"));\n@@ -730,7 +741,7 @@ pub fn to_shortest_exp_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f32::MAX, Minus, (-39, 38), false), \"3.4028235e38\");\n     assert_eq!(to_string(f, f32::MAX, Minus, (-38, 39), false), format!(\"34028235{:0>31}\", \"\"));\n \n-    let minf32 = f32::ldexp(1.0, -149);\n+    let minf32 = ldexp_f32(1.0, -149);\n     assert_eq!(to_string(f, minf32, Minus, ( -4, 16), false), \"1e-45\");\n     assert_eq!(to_string(f, minf32, Minus, (-44, 45), false), \"1e-45\");\n     assert_eq!(to_string(f, minf32, Minus, (-45, 44), false), format!(\"0.{:0>44}1\", \"\"));\n@@ -742,7 +753,7 @@ pub fn to_shortest_exp_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f64::MAX, Minus, (-309, 308), false),\n                \"1.7976931348623157e308\");\n \n-    let minf64 = f64::ldexp(1.0, -1074);\n+    let minf64 = ldexp_f64(1.0, -1074);\n     assert_eq!(to_string(f, minf64, Minus, (  -4,  16), false), \"5e-324\");\n     assert_eq!(to_string(f, minf64, Minus, (-324, 323), false), format!(\"0.{:0>323}5\", \"\"));\n     assert_eq!(to_string(f, minf64, Minus, (-323, 324), false), \"5e-324\");\n@@ -874,7 +885,7 @@ pub fn to_exact_exp_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f32::MAX, Minus, 64, false),\n                \"3.402823466385288598117041834845169254400000000000000000000000000e38\");\n \n-    let minf32 = f32::ldexp(1.0, -149);\n+    let minf32 = ldexp_f32(1.0, -149);\n     assert_eq!(to_string(f, minf32, Minus,   1, false), \"1e-45\");\n     assert_eq!(to_string(f, minf32, Minus,   2, false), \"1.4e-45\");\n     assert_eq!(to_string(f, minf32, Minus,   4, false), \"1.401e-45\");\n@@ -914,7 +925,7 @@ pub fn to_exact_exp_str_test<F>(mut f_: F)\n                  0000000000000000000000000000000000000000000000000000000000000000e308\");\n \n     // okay, this is becoming tough. fortunately for us, this is almost the worst case.\n-    let minf64 = f64::ldexp(1.0, -1074);\n+    let minf64 = ldexp_f64(1.0, -1074);\n     assert_eq!(to_string(f, minf64, Minus,    1, false), \"5e-324\");\n     assert_eq!(to_string(f, minf64, Minus,    2, false), \"4.9e-324\");\n     assert_eq!(to_string(f, minf64, Minus,    4, false), \"4.941e-324\");\n@@ -1120,7 +1131,7 @@ pub fn to_exact_fixed_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f32::MAX, Minus, 2, false),\n                \"340282346638528859811704183484516925440.00\");\n \n-    let minf32 = f32::ldexp(1.0, -149);\n+    let minf32 = ldexp_f32(1.0, -149);\n     assert_eq!(to_string(f, minf32, Minus,   0, false), \"0\");\n     assert_eq!(to_string(f, minf32, Minus,   1, false), \"0.0\");\n     assert_eq!(to_string(f, minf32, Minus,   2, false), \"0.00\");\n@@ -1152,7 +1163,7 @@ pub fn to_exact_fixed_str_test<F>(mut f_: F)\n                 9440758685084551339423045832369032229481658085593321233482747978\\\n                 26204144723168738177180919299881250404026184124858368.0000000000\");\n \n-    let minf64 = f64::ldexp(1.0, -1074);\n+    let minf64 = ldexp_f64(1.0, -1074);\n     assert_eq!(to_string(f, minf64, Minus, 0, false), \"0\");\n     assert_eq!(to_string(f, minf64, Minus, 1, false), \"0.0\");\n     assert_eq!(to_string(f, minf64, Minus, 10, false), \"0.0000000000\");"}, {"sha": "41ad089ecd235d0f753de2b6da8d50043ac4463b", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -144,9 +144,8 @@ impl Rand for char {\n             // Rejection sampling. About 0.2% of numbers with at most\n             // 21-bits are invalid codepoints (surrogates), so this\n             // will succeed first go almost every time.\n-            match char::from_u32(rng.next_u32() & CHAR_MASK) {\n-                Some(c) => return c,\n-                None => {}\n+            if let Some(c) = char::from_u32(rng.next_u32() & CHAR_MASK) {\n+                return c;\n             }\n         }\n     }"}, {"sha": "4e16fae187070ee13880b1a8c189cf91c724d409", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -118,8 +118,6 @@ impl DepGraphThreadData {\n     /// the buffer is full, this may swap.)\n     #[inline]\n     pub fn enqueue(&self, message: DepMessage) {\n-        debug!(\"enqueue: {:?} tasks_pushed={}\", message, self.tasks_pushed.get());\n-\n         // Regardless of whether dep graph construction is enabled, we\n         // still want to check that we always have a valid task on the\n         // stack when a read/write/etc event occurs."}, {"sha": "bf6188faa2fbdf160d7c60032e0bb8613c186042", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1697,13 +1697,10 @@ impl<'a> State<'a> {\n                 self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(&ty))?;\n                 word(&mut self.s, \")\")?;\n \n-                match data.output {\n-                    None => {}\n-                    Some(ref ty) => {\n-                        self.space_if_not_bol()?;\n-                        self.word_space(\"->\")?;\n-                        self.print_type(&ty)?;\n-                    }\n+                if let Some(ref ty) = data.output {\n+                    self.space_if_not_bol()?;\n+                    self.word_space(\"->\")?;\n+                    self.print_type(&ty)?;\n                 }\n             }\n         }"}, {"sha": "d3b4afa2cee7915caa98b010a4b792d8713ea5df", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -842,11 +842,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         where F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, Region, Region)\n     {\n         let vars = TwoRegions { a: a, b: b };\n-        match self.combine_map(t).borrow().get(&vars) {\n-            Some(&c) => {\n-                return ReVar(c);\n-            }\n-            None => {}\n+        if let Some(&c) = self.combine_map(t).borrow().get(&vars) {\n+            return ReVar(c);\n         }\n         let c = self.new_region_var(MiscVariable(origin.span()));\n         self.combine_map(t).borrow_mut().insert(vars, c);"}, {"sha": "48ea953cc1e8b05a137d32659ab11caa20bde3a8", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -30,7 +30,6 @@\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(enumset)]\n-#![feature(iter_arith)]\n #![feature(libc)]\n #![feature(nonzero)]\n #![feature(quote)]"}, {"sha": "01e14ad71b39c8c0e7e1e384950b00cc1b046559", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1055,13 +1055,10 @@ impl<'a> ast_visit::Visitor for EarlyContext<'a> {\n // Output any lints that were previously added to the session.\n impl<'a, 'tcx> IdVisitingOperation for LateContext<'a, 'tcx> {\n     fn visit_id(&mut self, id: ast::NodeId) {\n-        match self.sess().lints.borrow_mut().remove(&id) {\n-            None => {}\n-            Some(lints) => {\n-                debug!(\"LateContext::visit_id: id={:?} lints={:?}\", id, lints);\n-                for (lint_id, span, msg) in lints {\n-                    self.span_lint(lint_id.lint, span, &msg[..])\n-                }\n+        if let Some(lints) = self.sess().lints.borrow_mut().remove(&id) {\n+            debug!(\"LateContext::visit_id: id={:?} lints={:?}\", id, lints);\n+            for (lint_id, span, msg) in lints {\n+                self.span_lint(lint_id.lint, span, &msg[..])\n             }\n         }\n     }"}, {"sha": "fc1294c86c44f518e1b9a7faa5caba80c5e3da20", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -168,9 +168,8 @@ fn build_nodeid_to_index(decl: Option<&hir::FnDecl>,\n     // into cfg itself?  i.e. introduce a fn-based flow-graph in\n     // addition to the current block-based flow-graph, rather than\n     // have to put traversals like this here?\n-    match decl {\n-        None => {}\n-        Some(decl) => add_entries_from_fn_decl(&mut index, decl, cfg.entry)\n+    if let Some(decl) = decl {\n+        add_entries_from_fn_decl(&mut index, decl, cfg.entry);\n     }\n \n     cfg.graph.each_node(|node_idx, node| {"}, {"sha": "cf6905ecf439ab24400902c25129f22647894715", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -105,9 +105,8 @@ fn calculate_type(sess: &session::Session,\n         // If the global prefer_dynamic switch is turned off, first attempt\n         // static linkage (this can fail).\n         config::CrateTypeExecutable if !sess.opts.cg.prefer_dynamic => {\n-            match attempt_static(sess) {\n-                Some(v) => return v,\n-                None => {}\n+            if let Some(v) = attempt_static(sess) {\n+                return v;\n             }\n         }\n \n@@ -119,9 +118,8 @@ fn calculate_type(sess: &session::Session,\n         // to be found, we generate some nice pretty errors.\n         config::CrateTypeStaticlib |\n         config::CrateTypeCdylib => {\n-            match attempt_static(sess) {\n-                Some(v) => return v,\n-                None => {}\n+            if let Some(v) = attempt_static(sess) {\n+                return v;\n             }\n             for cnum in sess.cstore.crates() {\n                 let src = sess.cstore.used_crate_source(cnum);\n@@ -136,9 +134,8 @@ fn calculate_type(sess: &session::Session,\n         // to try to eagerly statically link all dependencies. This is normally\n         // done for end-product dylibs, not intermediate products.\n         config::CrateTypeDylib if !sess.opts.cg.prefer_dynamic => {\n-            match attempt_static(sess) {\n-                Some(v) => return v,\n-                None => {}\n+            if let Some(v) = attempt_static(sess) {\n+                return v;\n             }\n         }\n "}, {"sha": "c8b8c5dbdbbcbc878f2d51cc386a49475253a80f", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -735,26 +735,23 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         for i in 0..autoderefs {\n             let deref_id = ty::MethodCall::autoderef(expr.id, i as u32);\n-            match self.mc.infcx.node_method_ty(deref_id) {\n-                None => {}\n-                Some(method_ty) => {\n-                    let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n-\n-                    // the method call infrastructure should have\n-                    // replaced all late-bound regions with variables:\n-                    let self_ty = method_ty.fn_sig().input(0);\n-                    let self_ty = self.tcx().no_late_bound_regions(&self_ty).unwrap();\n-\n-                    let (m, r) = match self_ty.sty {\n-                        ty::TyRef(r, ref m) => (m.mutbl, r),\n-                        _ => span_bug!(expr.span,\n-                                \"bad overloaded deref type {:?}\",\n-                                method_ty)\n-                    };\n-                    let bk = ty::BorrowKind::from_mutbl(m);\n-                    self.delegate.borrow(expr.id, expr.span, cmt,\n-                                         *r, bk, AutoRef);\n-                }\n+            if let Some(method_ty) = self.mc.infcx.node_method_ty(deref_id) {\n+                let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n+\n+                // the method call infrastructure should have\n+                // replaced all late-bound regions with variables:\n+                let self_ty = method_ty.fn_sig().input(0);\n+                let self_ty = self.tcx().no_late_bound_regions(&self_ty).unwrap();\n+\n+                let (m, r) = match self_ty.sty {\n+                    ty::TyRef(r, ref m) => (m.mutbl, r),\n+                    _ => span_bug!(expr.span,\n+                                   \"bad overloaded deref type {:?}\",\n+                                   method_ty)\n+                };\n+                let bk = ty::BorrowKind::from_mutbl(m);\n+                self.delegate.borrow(expr.id, expr.span, cmt,\n+                                     *r, bk, AutoRef);\n             }\n         }\n     }"}, {"sha": "ea3765c76f89b2ec425fb845286e69338d7e685d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -598,11 +598,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn arm_pats_bindings<F>(&mut self, pat: Option<&hir::Pat>, f: F) where\n         F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId),\n     {\n-        match pat {\n-            Some(pat) => {\n-                self.pat_bindings(pat, f);\n-            }\n-            None => {}\n+        if let Some(pat) = pat {\n+            self.pat_bindings(pat, f);\n         }\n     }\n "}, {"sha": "7f6614a959c894634e2d3898ed0a89c083863f97", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -284,9 +284,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n     fn visit_generics(&mut self, generics: &hir::Generics) {\n         for ty_param in generics.ty_params.iter() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n-            match ty_param.default {\n-                Some(ref ty) => self.visit_ty(&ty),\n-                None => {}\n+            if let Some(ref ty) = ty_param.default {\n+                self.visit_ty(&ty);\n             }\n         }\n         for predicate in &generics.where_clause.predicates {"}, {"sha": "6fb1b16705fe47fce509e180202bc25cf0a75cdd", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -123,9 +123,8 @@ impl<'a> Context<'a> {\n \n impl<'a, 'v> Visitor<'v> for Context<'a> {\n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n-        match lang_items::extract(&i.attrs) {\n-            None => {}\n-            Some(lang_item) => self.register(&lang_item, i.span),\n+        if let Some(lang_item) = lang_items::extract(&i.attrs) {\n+            self.register(&lang_item, i.span);\n         }\n         intravisit::walk_foreign_item(self, i)\n     }"}, {"sha": "57c4af6bed569406138d3096914b43e092ee0ae8", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -250,15 +250,12 @@ impl Session {\n                     msg: String) {\n         let lint_id = lint::LintId::of(lint);\n         let mut lints = self.lints.borrow_mut();\n-        match lints.get_mut(&id) {\n-            Some(arr) => {\n-                let tuple = (lint_id, sp, msg);\n-                if !arr.contains(&tuple) {\n-                    arr.push(tuple);\n-                }\n-                return;\n+        if let Some(arr) = lints.get_mut(&id) {\n+            let tuple = (lint_id, sp, msg);\n+            if !arr.contains(&tuple) {\n+                arr.push(tuple);\n             }\n-            None => {}\n+            return;\n         }\n         lints.insert(id, vec!((lint_id, sp, msg)));\n     }"}, {"sha": "3b9ecb88258540cd011bb543b07be1a8bd5145e7", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -908,6 +908,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.note(\"only the last field of a struct or enum variant \\\n                           may have a dynamically sized type\");\n             }\n+            ObligationCauseCode::ConstSized => {\n+                err.note(\"constant expressions must have a statically known size\");\n+            }\n             ObligationCauseCode::SharedStatic => {\n                 err.note(\"shared static variables must have a type that implements `Sync`\");\n             }"}, {"sha": "17aa6544fe798d169244c092d16fa17ecf6a45e4", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -127,6 +127,9 @@ pub enum ObligationCauseCode<'tcx> {\n     // Types of fields (other than the last) in a struct must be sized.\n     FieldSized,\n \n+    // Constant expressions must be sized.\n+    ConstSized,\n+\n     // static items must have `Sync` type\n     SharedStatic,\n "}, {"sha": "14b0a8070983c84a3628b665e1d07648689768ea", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -168,13 +168,12 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             // which is incorrect.  This value was computed based on the crutch\n             // value for the type contents of list.  The correct value is\n             // TC::OwnsOwned.  This manifested as issue #4821.\n-            match cache.get(&ty) {\n-                Some(tc) => { return *tc; }\n-                None => {}\n+            if let Some(tc) = cache.get(&ty) {\n+                return *tc;\n             }\n-            match tcx.tc_cache.borrow().get(&ty) {    // Must check both caches!\n-                Some(tc) => { return *tc; }\n-                None => {}\n+            // Must check both caches!\n+            if let Some(tc) = tcx.tc_cache.borrow().get(&ty) {\n+                return *tc;\n             }\n             cache.insert(ty, TC::None);\n "}, {"sha": "b334964bf489b4e4fac8e9e533e4fc771b887b88", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -521,9 +521,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.0 }\n \n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-                match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n-                    None => {}\n-                    Some(u) => return u\n+                if let Some(u) = self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n+                    return u;\n                 }\n \n                 // FIXME(eddyb) should local contexts have a cache too?\n@@ -714,4 +713,3 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         false\n     }\n }\n-"}, {"sha": "21c14e6fe4c3b16c2d39eac6769274bcb445c47b", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -712,16 +712,13 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                         // struct Foo;\n                         // struct Bar<T> { x: Bar<Foo> }\n \n-                        match iter.next() {\n-                            Some(&seen_type) => {\n-                                if same_struct_or_enum(seen_type, def) {\n-                                    debug!(\"SelfRecursive: {:?} contains {:?}\",\n-                                           seen_type,\n-                                           ty);\n-                                    return Representability::SelfRecursive;\n-                                }\n+                        if let Some(&seen_type) = iter.next() {\n+                            if same_struct_or_enum(seen_type, def) {\n+                                debug!(\"SelfRecursive: {:?} contains {:?}\",\n+                                       seen_type,\n+                                       ty);\n+                                return Representability::SelfRecursive;\n                             }\n-                            None => {}\n                         }\n \n                         // We also need to know whether the first item contains other types"}, {"sha": "c9822a4fee7498b4da41c83a2bffe357df515eb5", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -274,11 +274,8 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     /// `lp` and any of its base paths that do not yet have an index.\n     pub fn move_path(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                      lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n-        match self.path_map.borrow().get(&lp) {\n-            Some(&index) => {\n-                return index;\n-            }\n-            None => {}\n+        if let Some(&index) = self.path_map.borrow().get(&lp) {\n+            return index;\n         }\n \n         let index = match lp.kind {"}, {"sha": "a5a9dea61ad7c99661851be39303634677eb4198", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -176,9 +176,8 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n \n                 // Second, if there is a guard on each arm, make sure it isn't\n                 // assigning or borrowing anything mutably.\n-                match arm.guard {\n-                    Some(ref guard) => check_for_mutation_in_guard(cx, &guard),\n-                    None => {}\n+                if let Some(ref guard) = arm.guard {\n+                    check_for_mutation_in_guard(cx, &guard);\n                 }\n             }\n "}, {"sha": "726ba4fc1924fd48f3b3fc25b7c0d38df381c0f3", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -27,7 +27,6 @@\n #![feature(staged_api)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n-#![feature(iter_arith)]\n #![feature(question_mark)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]"}, {"sha": "9123463149936da2b434d8e4c84c14288261f12f", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -15,6 +15,7 @@ use std::marker::PhantomData;\n use std::ops::{Index, IndexMut, Range};\n use std::fmt;\n use std::vec;\n+use std::u32;\n \n use rustc_serialize as serialize;\n \n@@ -31,6 +32,11 @@ impl Idx for usize {\n     fn index(self) -> usize { self }\n }\n \n+impl Idx for u32 {\n+    fn new(idx: usize) -> Self { assert!(idx <= u32::MAX as usize); idx as u32 }\n+    fn index(self) -> usize { self as usize }\n+}\n+\n #[derive(Clone)]\n pub struct IndexVec<I: Idx, T> {\n     pub raw: Vec<T>,"}, {"sha": "c079146edbf42bbe59989fca939aa519fa374662", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -208,11 +208,17 @@ impl<O: ForestObligation> ObligationForest<O> {\n     ///\n     /// This CAN be done in a snapshot\n     pub fn register_obligation(&mut self, obligation: O) {\n-        self.register_obligation_at(obligation, None)\n+        // Ignore errors here - there is no guarantee of success.\n+        let _ = self.register_obligation_at(obligation, None);\n     }\n \n-    fn register_obligation_at(&mut self, obligation: O, parent: Option<NodeIndex>) {\n-        if self.done_cache.contains(obligation.as_predicate()) { return }\n+    // returns Err(()) if we already know this obligation failed.\n+    fn register_obligation_at(&mut self, obligation: O, parent: Option<NodeIndex>)\n+                              -> Result<(), ()>\n+    {\n+        if self.done_cache.contains(obligation.as_predicate()) {\n+            return Ok(())\n+        }\n \n         match self.waiting_cache.entry(obligation.as_predicate().clone()) {\n             Entry::Occupied(o) => {\n@@ -226,15 +232,21 @@ impl<O: ForestObligation> ObligationForest<O> {\n                         self.nodes[o.get().get()].dependents.push(parent);\n                     }\n                 }\n+                if let NodeState::Error = self.nodes[o.get().get()].state.get() {\n+                    Err(())\n+                } else {\n+                    Ok(())\n+                }\n             }\n             Entry::Vacant(v) => {\n                 debug!(\"register_obligation_at({:?}, {:?}) - ok\",\n                        obligation, parent);\n                 v.insert(NodeIndex::new(self.nodes.len()));\n                 self.cache_list.push(obligation.as_predicate().clone());\n                 self.nodes.push(Node::new(parent, obligation));\n+                Ok(())\n             }\n-        };\n+        }\n     }\n \n     /// Convert all remaining obligations to the given error.\n@@ -306,12 +318,19 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 Ok(Some(children)) => {\n                     // if we saw a Some(_) result, we are not (yet) stalled\n                     stalled = false;\n+                    self.nodes[index].state.set(NodeState::Success);\n+\n                     for child in children {\n-                        self.register_obligation_at(child,\n-                                                    Some(NodeIndex::new(index)));\n+                        let st = self.register_obligation_at(\n+                            child,\n+                            Some(NodeIndex::new(index))\n+                        );\n+                        if let Err(()) = st {\n+                            // error already reported - propagate it\n+                            // to our node.\n+                            self.error_at(index);\n+                        }\n                     }\n-\n-                    self.nodes[index].state.set(NodeState::Success);\n                 }\n                 Err(err) => {\n                     let backtrace = self.error_at(index);"}, {"sha": "a95b2b84b34c85471ebac43575d7748570784a15", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -418,3 +418,43 @@ fn orphan() {\n     let errors = forest.to_errors(());\n     assert_eq!(errors.len(), 0);\n }\n+\n+#[test]\n+fn simultaneous_register_and_error() {\n+    // check that registering a failed obligation works correctly\n+    let mut forest = ObligationForest::new();\n+    forest.register_obligation(\"A\");\n+    forest.register_obligation(\"B\");\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A\" => Err(\"An error\"),\n+                \"B\" => Ok(Some(vec![\"A\"])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err, vec![super::Error {\n+        error: \"An error\",\n+        backtrace: vec![\"A\"]\n+    }]);\n+\n+    let mut forest = ObligationForest::new();\n+    forest.register_obligation(\"B\");\n+    forest.register_obligation(\"A\");\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A\" => Err(\"An error\"),\n+                \"B\" => Ok(Some(vec![\"A\"])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err, vec![super::Error {\n+        error: \"An error\",\n+        backtrace: vec![\"A\"]\n+    }]);\n+}"}, {"sha": "277789f5312eee0dd9ce8c73e133714ec6d0832a", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -116,34 +116,20 @@ pub fn compile_input(sess: &Session,\n         let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n         let id = link::find_crate_name(Some(sess), &krate.attrs, input);\n         let ExpansionResult { expanded_crate, defs, analysis, resolutions, mut hir_forest } = {\n-            let make_glob_map = control.make_glob_map;\n-            phase_2_configure_and_expand(sess, &cstore, krate, &id, addl_plugins, make_glob_map)?\n+            phase_2_configure_and_expand(\n+                sess, &cstore, krate, &id, addl_plugins, control.make_glob_map,\n+                |expanded_crate| {\n+                    let mut state = CompileState::state_after_expand(\n+                        input, sess, outdir, output, &cstore, expanded_crate, &id,\n+                    );\n+                    controller_entry_point!(after_expand, sess, state, Ok(()));\n+                    Ok(())\n+                }\n+            )?\n         };\n \n-        controller_entry_point!(after_expand,\n-                                sess,\n-                                CompileState::state_after_expand(input,\n-                                                                 sess,\n-                                                                 outdir,\n-                                                                 output,\n-                                                                 &cstore,\n-                                                                 &expanded_crate,\n-                                                                 &id),\n-                                Ok(()));\n-\n         write_out_deps(sess, &outputs, &id);\n \n-        controller_entry_point!(after_write_deps,\n-                                sess,\n-                                CompileState::state_after_write_deps(input,\n-                                                                     sess,\n-                                                                     outdir,\n-                                                                     output,\n-                                                                     &cstore,\n-                                                                     &expanded_crate,\n-                                                                     &id),\n-                                Ok(()));\n-\n         let arenas = ty::CtxtArenas::new();\n \n         // Construct the HIR map\n@@ -239,8 +225,15 @@ pub fn compile_input(sess: &Session,\n                             phase5_result);\n     phase5_result?;\n \n+    write::cleanup_llvm(&trans);\n+\n     phase_6_link_output(sess, &trans, &outputs);\n \n+    controller_entry_point!(compilation_done,\n+                            sess,\n+                            CompileState::state_when_compilation_done(input, sess, outdir, output),\n+                            Ok(()));\n+\n     Ok(())\n }\n \n@@ -285,10 +278,10 @@ pub fn source_name(input: &Input) -> String {\n pub struct CompileController<'a> {\n     pub after_parse: PhaseController<'a>,\n     pub after_expand: PhaseController<'a>,\n-    pub after_write_deps: PhaseController<'a>,\n     pub after_hir_lowering: PhaseController<'a>,\n     pub after_analysis: PhaseController<'a>,\n     pub after_llvm: PhaseController<'a>,\n+    pub compilation_done: PhaseController<'a>,\n \n     pub make_glob_map: MakeGlobMap,\n }\n@@ -298,10 +291,10 @@ impl<'a> CompileController<'a> {\n         CompileController {\n             after_parse: PhaseController::basic(),\n             after_expand: PhaseController::basic(),\n-            after_write_deps: PhaseController::basic(),\n             after_hir_lowering: PhaseController::basic(),\n             after_analysis: PhaseController::basic(),\n             after_llvm: PhaseController::basic(),\n+            compilation_done: PhaseController::basic(),\n             make_glob_map: MakeGlobMap::No,\n         }\n     }\n@@ -406,23 +399,6 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n         }\n     }\n \n-    fn state_after_write_deps(input: &'a Input,\n-                              session: &'ast Session,\n-                              out_dir: &'a Option<PathBuf>,\n-                              out_file: &'a Option<PathBuf>,\n-                              cstore: &'a CStore,\n-                              krate: &'a ast::Crate,\n-                              crate_name: &'a str)\n-                              -> CompileState<'a, 'b, 'ast, 'tcx> {\n-        CompileState {\n-            crate_name: Some(crate_name),\n-            cstore: Some(cstore),\n-            expanded_crate: Some(krate),\n-            out_file: out_file.as_ref().map(|s| &**s),\n-            ..CompileState::empty(input, session, out_dir)\n-        }\n-    }\n-\n     fn state_after_hir_lowering(input: &'a Input,\n                                 session: &'ast Session,\n                                 out_dir: &'a Option<PathBuf>,\n@@ -486,6 +462,17 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n             ..CompileState::empty(input, session, out_dir)\n         }\n     }\n+\n+    fn state_when_compilation_done(input: &'a Input,\n+                                    session: &'ast Session,\n+                                    out_dir: &'a Option<PathBuf>,\n+                                    out_file: &'a Option<PathBuf>)\n+                                    -> CompileState<'a, 'b, 'ast, 'tcx> {\n+        CompileState {\n+            out_file: out_file.as_ref().map(|s| &**s),\n+            ..CompileState::empty(input, session, out_dir)\n+        }\n+    }\n }\n \n pub fn phase_1_parse_input<'a>(sess: &'a Session,\n@@ -556,13 +543,16 @@ pub struct ExpansionResult<'a> {\n /// standard library and prelude, and name resolution.\n ///\n /// Returns `None` if we're aborting after handling -W help.\n-pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n-                                        cstore: &CStore,\n-                                        mut krate: ast::Crate,\n-                                        crate_name: &'a str,\n-                                        addl_plugins: Option<Vec<String>>,\n-                                        make_glob_map: MakeGlobMap)\n-                                        -> Result<ExpansionResult<'a>, usize> {\n+pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n+                                           cstore: &CStore,\n+                                           mut krate: ast::Crate,\n+                                           crate_name: &'a str,\n+                                           addl_plugins: Option<Vec<String>>,\n+                                           make_glob_map: MakeGlobMap,\n+                                           after_expand: F)\n+                                           -> Result<ExpansionResult<'a>, usize>\n+    where F: FnOnce(&ast::Crate) -> CompileResult,\n+{\n     let time_passes = sess.time_passes();\n \n     // strip before anything else because crate metadata may use #[cfg_attr]\n@@ -745,9 +735,23 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n          \"AST validation\",\n          || ast_validation::check_crate(sess, &krate));\n \n-    time(sess.time_passes(), \"name resolution\", || {\n+    time(sess.time_passes(), \"name resolution\", || -> CompileResult {\n+        // Currently, we ignore the name resolution data structures for the purposes of dependency\n+        // tracking. Instead we will run name resolution and include its output in the hash of each\n+        // item, much like we do for macro expansion. In other words, the hash reflects not just\n+        // its contents but the results of name resolution on those contents. Hopefully we'll push\n+        // this back at some point.\n+        let _ignore = sess.dep_graph.in_ignore();\n+        resolver.build_reduced_graph(&krate);\n+        resolver.resolve_imports();\n+\n+        // Since import resolution will eventually happen in expansion,\n+        // don't perform `after_expand` until after import resolution.\n+        after_expand(&krate)?;\n+\n         resolver.resolve_crate(&krate);\n-    });\n+        Ok(())\n+    })?;\n \n     // Lower ast -> hir.\n     let hir_forest = time(sess.time_passes(), \"lowering ast -> hir\", || {"}, {"sha": "c9569a63436f5f1b2e5a891d1260d1324d54704d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -511,7 +511,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n         }\n \n         if sess.opts.no_analysis || sess.opts.debugging_opts.ast_json {\n-            control.after_write_deps.stop = Compilation::Stop;\n+            control.after_hir_lowering.stop = Compilation::Stop;\n         }\n \n         if !sess.opts.output_types.keys().any(|&i| i == OutputType::Exe) {"}, {"sha": "f2020303089d2e3d52fef55df7ca4d3986b4e98a", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -30,12 +30,15 @@ const ARM_WHITELIST: &'static [&'static str] = &[\n const X86_WHITELIST: &'static [&'static str] = &[\n     \"avx\\0\",\n     \"avx2\\0\",\n+    \"bmi\\0\",\n+    \"bmi2\\0\",\n     \"sse\\0\",\n     \"sse2\\0\",\n     \"sse3\\0\",\n     \"sse4.1\\0\",\n     \"sse4.2\\0\",\n     \"ssse3\\0\",\n+    \"tbm\\0\",\n ];\n \n /// Add `target_feature = \"...\"` cfgs for a variety of platform"}, {"sha": "15a0ab0f284b3efdde3be345078029b4be4446af", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -116,9 +116,11 @@ fn test_env<F>(source_string: &str,\n         input: source_string.to_string(),\n     };\n     let krate = driver::phase_1_parse_input(&sess, krate_config, &input).unwrap();\n-    let driver::ExpansionResult { defs, resolutions, mut hir_forest, .. } =\n-        driver::phase_2_configure_and_expand(&sess, &cstore, krate, \"test\", None, MakeGlobMap::No)\n-            .expect(\"phase 2 aborted\");\n+    let driver::ExpansionResult { defs, resolutions, mut hir_forest, .. } = {\n+        driver::phase_2_configure_and_expand(\n+            &sess, &cstore, krate, \"test\", None, MakeGlobMap::No, |_| Ok(()),\n+        ).expect(\"phase 2 aborted\")\n+    };\n     let _ignore = dep_graph.in_ignore();\n \n     let arenas = ty::CtxtArenas::new();"}, {"sha": "4dc1a5e4f5e9f6dda3e8bc63fa9ffab1af28c15e", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -150,12 +150,9 @@ impl LateLintPass for UnusedResults {\n                 if attr.check_name(\"must_use\") {\n                     let mut msg = \"unused result which must be used\".to_string();\n                     // check for #[must_use=\"...\"]\n-                    match attr.value_str() {\n-                        None => {}\n-                        Some(s) => {\n-                            msg.push_str(\": \");\n-                            msg.push_str(&s);\n-                        }\n+                    if let Some(s) = attr.value_str() {\n+                        msg.push_str(\": \");\n+                        msg.push_str(&s);\n                     }\n                     cx.span_lint(UNUSED_MUST_USE, sp, &msg);\n                     return true;"}, {"sha": "a2c808cbcb6b6dae988880d354dc5528b01ea85c", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -24,19 +24,17 @@ fn main() {\n     let llvm_config = env::var_os(\"LLVM_CONFIG\")\n                           .map(PathBuf::from)\n                           .unwrap_or_else(|| {\n-                              match env::var_os(\"CARGO_TARGET_DIR\").map(PathBuf::from) {\n-                                  Some(dir) => {\n-                                      let to_test = dir.parent()\n-                                                       .unwrap()\n-                                                       .parent()\n-                                                       .unwrap()\n-                                                       .join(&target)\n-                                                       .join(\"llvm/bin/llvm-config\");\n-                                      if Command::new(&to_test).output().is_ok() {\n-                                          return to_test;\n-                                      }\n+                              if let Some(dir) = env::var_os(\"CARGO_TARGET_DIR\")\n+                                      .map(PathBuf::from) {\n+                                  let to_test = dir.parent()\n+                                                   .unwrap()\n+                                                   .parent()\n+                                                   .unwrap()\n+                                                   .join(&target)\n+                                                   .join(\"llvm/bin/llvm-config\");\n+                                  if Command::new(&to_test).output().is_ok() {\n+                                      return to_test;\n                                   }\n-                                  None => {}\n                               }\n                               PathBuf::from(\"llvm-config\")\n                           });"}, {"sha": "2d3302c2eef3a8078a4c6683a94f546770ed19b0", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -16,6 +16,7 @@ rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "2e8c5a7c23418ba137017befcbd86b4a57613481", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -60,7 +60,7 @@ use rustc_serialize::{Encodable, EncoderHelpers};\n \n struct DecodeContext<'a, 'b, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    cdata: &'b cstore::crate_metadata,\n+    cdata: &'b cstore::CrateMetadata,\n     from_id_range: IdRange,\n     to_id_range: IdRange,\n     // Cache the last used filemap for translating spans as an optimization.\n@@ -121,7 +121,7 @@ impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n \n /// Decodes an item from its AST in the cdata's metadata and adds it to the\n /// ast-map.\n-pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::crate_metadata,\n+pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n                                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      parent_def_path: ast_map::DefPath,\n                                      parent_did: DefId,\n@@ -246,7 +246,7 @@ impl<S:serialize::Encoder> def_id_encoder_helpers for S\n trait def_id_decoder_helpers {\n     fn read_def_id(&mut self, dcx: &DecodeContext) -> DefId;\n     fn read_def_id_nodcx(&mut self,\n-                         cdata: &cstore::crate_metadata) -> DefId;\n+                         cdata: &cstore::CrateMetadata) -> DefId;\n }\n \n impl<D:serialize::Decoder> def_id_decoder_helpers for D\n@@ -258,7 +258,7 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D\n     }\n \n     fn read_def_id_nodcx(&mut self,\n-                         cdata: &cstore::crate_metadata)\n+                         cdata: &cstore::CrateMetadata)\n                          -> DefId {\n         let did: DefId = Decodable::decode(self).unwrap();\n         decoder::translate_def_id(cdata, did)\n@@ -858,17 +858,17 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n     // Versions of the type reading functions that don't need the full\n     // DecodeContext.\n     fn read_ty_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         cdata: &cstore::crate_metadata) -> Ty<'tcx>;\n+                         cdata: &cstore::CrateMetadata) -> Ty<'tcx>;\n     fn read_tys_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>>;\n+                          cdata: &cstore::CrateMetadata) -> Vec<Ty<'tcx>>;\n     fn read_substs_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             cdata: &cstore::crate_metadata)\n+                             cdata: &cstore::CrateMetadata)\n                              -> subst::Substs<'tcx>;\n }\n \n impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_ty_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                         cdata: &cstore::crate_metadata)\n+                         cdata: &cstore::CrateMetadata)\n                          -> Ty<'tcx> {\n         self.read_opaque(|_, doc| {\n             Ok(\n@@ -879,15 +879,15 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     }\n \n     fn read_tys_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                          cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>> {\n+                          cdata: &cstore::CrateMetadata) -> Vec<Ty<'tcx>> {\n         self.read_to_vec(|this| Ok(this.read_ty_nodcx(tcx, cdata)) )\n             .unwrap()\n             .into_iter()\n             .collect()\n     }\n \n     fn read_substs_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                             cdata: &cstore::crate_metadata)\n+                             cdata: &cstore::CrateMetadata)\n                              -> subst::Substs<'tcx>\n     {\n         self.read_opaque(|_, doc| {"}, {"sha": "ff072cce5db9667ccd5cb998ee0cdcb6384cdd78", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -252,3 +252,7 @@ pub fn rustc_version() -> String {\n }\n \n pub const tag_panic_strategy: usize = 0x114;\n+\n+// NB: increment this if you change the format of metadata such that\n+// rustc_version can't be found.\n+pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2];"}, {"sha": "269e284b22d6cb268d3d5aceca737da1fc90be13", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 40, "deletions": 63, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -12,7 +12,6 @@\n \n //! Validates all used crates and extern libraries and loads their metadata\n \n-use common::rustc_version;\n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use decoder;\n use loader::{self, CratePaths};\n@@ -24,7 +23,7 @@ use rustc::session::{config, Session};\n use rustc::session::config::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n use rustc::hir::map as hir_map;\n \n use std::cell::{RefCell, Cell};\n@@ -132,7 +131,7 @@ struct ExtensionCrate {\n }\n \n enum PMDSource {\n-    Registered(Rc<cstore::crate_metadata>),\n+    Registered(Rc<cstore::CrateMetadata>),\n     Owned(MetadataBlob),\n }\n \n@@ -236,25 +235,6 @@ impl<'a> CrateReader<'a> {\n         return ret;\n     }\n \n-    fn verify_rustc_version(&self,\n-                            name: &str,\n-                            span: Span,\n-                            metadata: &MetadataBlob) {\n-        let crate_rustc_version = decoder::crate_rustc_version(metadata.as_slice());\n-        if crate_rustc_version != Some(rustc_version()) {\n-            let mut err = struct_span_fatal!(self.sess, span, E0514,\n-                                             \"the crate `{}` has been compiled with {}, which is \\\n-                                              incompatible with this version of rustc\",\n-                                              name,\n-                                              crate_rustc_version\n-                                              .as_ref().map(|s| &**s)\n-                                              .unwrap_or(\"an old version of rustc\"));\n-            err.help(\"consider removing the compiled binaries and recompiling \\\n-                      with your current version of rustc\");\n-            err.emit();\n-        }\n-    }\n-\n     fn verify_no_symbol_conflicts(&self,\n                                   span: Span,\n                                   metadata: &MetadataBlob) {\n@@ -294,9 +274,8 @@ impl<'a> CrateReader<'a> {\n                       span: Span,\n                       lib: loader::Library,\n                       explicitly_linked: bool)\n-                      -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n+                      -> (ast::CrateNum, Rc<cstore::CrateMetadata>,\n                           cstore::CrateSource) {\n-        self.verify_rustc_version(name, span, &lib.metadata);\n         self.verify_no_symbol_conflicts(span, &lib.metadata);\n \n         // Claim this crate number and cache it\n@@ -318,10 +297,10 @@ impl<'a> CrateReader<'a> {\n \n         let loader::Library { dylib, rlib, metadata } = lib;\n \n-        let cnum_map = self.resolve_crate_deps(root, metadata.as_slice(), span);\n+        let cnum_map = self.resolve_crate_deps(root, metadata.as_slice(), cnum, span);\n         let staged_api = self.is_staged_api(metadata.as_slice());\n \n-        let cmeta = Rc::new(cstore::crate_metadata {\n+        let cmeta = Rc::new(cstore::CrateMetadata {\n             name: name.to_string(),\n             extern_crate: Cell::new(None),\n             index: decoder::load_index(metadata.as_slice()),\n@@ -364,7 +343,7 @@ impl<'a> CrateReader<'a> {\n                      span: Span,\n                      kind: PathKind,\n                      explicitly_linked: bool)\n-                     -> (ast::CrateNum, Rc<cstore::crate_metadata>, cstore::CrateSource) {\n+                     -> (ast::CrateNum, Rc<cstore::CrateMetadata>, cstore::CrateSource) {\n         let result = match self.existing_match(name, hash, kind) {\n             Some(cnum) => LoadResult::Previous(cnum),\n             None => {\n@@ -381,6 +360,7 @@ impl<'a> CrateReader<'a> {\n                     rejected_via_hash: vec!(),\n                     rejected_via_triple: vec!(),\n                     rejected_via_kind: vec!(),\n+                    rejected_via_version: vec!(),\n                     should_match_name: true,\n                 };\n                 match self.load(&mut load_ctxt) {\n@@ -438,8 +418,11 @@ impl<'a> CrateReader<'a> {\n \n     fn update_extern_crate(&mut self,\n                            cnum: ast::CrateNum,\n-                           mut extern_crate: ExternCrate)\n+                           mut extern_crate: ExternCrate,\n+                           visited: &mut FnvHashSet<(ast::CrateNum, bool)>)\n     {\n+        if !visited.insert((cnum, extern_crate.direct)) { return }\n+\n         let cmeta = self.cstore.get_crate_data(cnum);\n         let old_extern_crate = cmeta.extern_crate.get();\n \n@@ -458,24 +441,24 @@ impl<'a> CrateReader<'a> {\n         }\n \n         cmeta.extern_crate.set(Some(extern_crate));\n-\n         // Propagate the extern crate info to dependencies.\n         extern_crate.direct = false;\n-        for &dep_cnum in cmeta.cnum_map.borrow().values() {\n-            self.update_extern_crate(dep_cnum, extern_crate);\n+        for &dep_cnum in cmeta.cnum_map.borrow().iter() {\n+            self.update_extern_crate(dep_cnum, extern_crate, visited);\n         }\n     }\n \n     // Go through the crate metadata and load any crates that it references\n     fn resolve_crate_deps(&mut self,\n                           root: &Option<CratePaths>,\n                           cdata: &[u8],\n-                          span : Span)\n-                          -> cstore::cnum_map {\n+                          krate: ast::CrateNum,\n+                          span: Span)\n+                          -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n         // The map from crate numbers in the crate we're resolving to local crate\n         // numbers\n-        decoder::get_crate_deps(cdata).iter().map(|dep| {\n+        let map: FnvHashMap<_, _> = decoder::get_crate_deps(cdata).iter().map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, _, _) = self.resolve_crate(root,\n                                                         &dep.name,\n@@ -485,7 +468,13 @@ impl<'a> CrateReader<'a> {\n                                                         PathKind::Dependency,\n                                                         dep.explicitly_linked);\n             (dep.cnum, local_cnum)\n-        }).collect()\n+        }).collect();\n+\n+        let max_cnum = map.values().cloned().max().unwrap_or(0);\n+\n+        // we map 0 and all other holes in the map to our parent crate. The \"additional\"\n+        // self-dependencies should be harmless.\n+        (0..max_cnum+1).map(|cnum| map.get(&cnum).cloned().unwrap_or(krate)).collect()\n     }\n \n     fn read_extension_crate(&mut self, span: Span, info: &CrateInfo) -> ExtensionCrate {\n@@ -508,6 +497,7 @@ impl<'a> CrateReader<'a> {\n             rejected_via_hash: vec!(),\n             rejected_via_triple: vec!(),\n             rejected_via_kind: vec!(),\n+            rejected_via_version: vec!(),\n             should_match_name: true,\n         };\n         let library = self.load(&mut load_ctxt).or_else(|| {\n@@ -826,7 +816,7 @@ impl<'a> CrateReader<'a> {\n     fn inject_dependency_if(&self,\n                             krate: ast::CrateNum,\n                             what: &str,\n-                            needs_dep: &Fn(&cstore::crate_metadata) -> bool) {\n+                            needs_dep: &Fn(&cstore::CrateMetadata) -> bool) {\n         // don't perform this validation if the session has errors, as one of\n         // those errors may indicate a circular dependency which could cause\n         // this to stack overflow.\n@@ -837,7 +827,17 @@ impl<'a> CrateReader<'a> {\n         // Before we inject any dependencies, make sure we don't inject a\n         // circular dependency by validating that this crate doesn't\n         // transitively depend on any crates satisfying `needs_dep`.\n-        validate(self, krate, krate, what, needs_dep);\n+        for dep in self.cstore.crate_dependencies_in_rpo(krate) {\n+            let data = self.cstore.get_crate_data(dep);\n+            if needs_dep(&data) {\n+                self.sess.err(&format!(\"the crate `{}` cannot depend \\\n+                                        on a crate that needs {}, but \\\n+                                        it depends on `{}`\",\n+                                       self.cstore.get_crate_data(krate).name(),\n+                                       what,\n+                                       data.name()));\n+            }\n+        }\n \n         // All crates satisfying `needs_dep` do not explicitly depend on the\n         // crate provided for this compile, but in order for this compilation to\n@@ -849,32 +849,8 @@ impl<'a> CrateReader<'a> {\n             }\n \n             info!(\"injecting a dep from {} to {}\", cnum, krate);\n-            let mut cnum_map = data.cnum_map.borrow_mut();\n-            let remote_cnum = cnum_map.len() + 1;\n-            let prev = cnum_map.insert(remote_cnum as ast::CrateNum, krate);\n-            assert!(prev.is_none());\n+            data.cnum_map.borrow_mut().push(krate);\n         });\n-\n-        fn validate(me: &CrateReader,\n-                    krate: ast::CrateNum,\n-                    root: ast::CrateNum,\n-                    what: &str,\n-                    needs_dep: &Fn(&cstore::crate_metadata) -> bool) {\n-            let data = me.cstore.get_crate_data(krate);\n-            if needs_dep(&data) {\n-                let krate_name = data.name();\n-                let data = me.cstore.get_crate_data(root);\n-                let root_name = data.name();\n-                me.sess.err(&format!(\"the crate `{}` cannot depend \\\n-                                      on a crate that needs {}, but \\\n-                                      it depends on `{}`\", root_name, what,\n-                                      krate_name));\n-            }\n-\n-            for (_, &dep) in data.cnum_map.borrow().iter() {\n-                validate(me, dep, root, what, needs_dep);\n-            }\n-        }\n     }\n }\n \n@@ -948,7 +924,8 @@ impl<'a> LocalCrateReader<'a> {\n                                                          span: i.span,\n                                                          direct: true,\n                                                          path_len: len,\n-                                                     });\n+                                                     },\n+                                                     &mut FnvHashSet());\n                     self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n                 }\n             }"}, {"sha": "95e3c53ecb40245e420bff18e81a92d8c9bb6b2e", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use cstore;\n+use common;\n use decoder;\n use encoder;\n use loader;\n@@ -588,7 +589,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn metadata_encoding_version(&self) -> &[u8]\n     {\n-        encoder::metadata_encoding_version\n+        common::metadata_encoding_version\n     }\n \n     /// Returns a map from a sufficiently visible external item (i.e. an external item that is"}, {"sha": "774d0f7ea188608820c21df7a014c87ecdac6cfb", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -15,6 +15,7 @@\n \n pub use self::MetadataBlob::*;\n \n+use common;\n use creader;\n use decoder;\n use index;\n@@ -26,6 +27,7 @@ use rustc::hir::map::DefKey;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{ExternCrate};\n use rustc::session::config::PanicStrategy;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{RefCell, Ref, Cell};\n@@ -46,7 +48,7 @@ pub use middle::cstore::{CrateSource, LinkMeta};\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type cnum_map = FnvHashMap<ast::CrateNum, ast::CrateNum>;\n+pub type CrateNumMap = IndexVec<ast::CrateNum, ast::CrateNum>;\n \n pub enum MetadataBlob {\n     MetadataVec(Bytes),\n@@ -64,7 +66,7 @@ pub struct ImportedFileMap {\n     pub translated_filemap: Rc<syntax_pos::FileMap>\n }\n \n-pub struct crate_metadata {\n+pub struct CrateMetadata {\n     pub name: String,\n \n     /// Information about the extern crate that caused this crate to\n@@ -73,7 +75,7 @@ pub struct crate_metadata {\n     pub extern_crate: Cell<Option<ExternCrate>>,\n \n     pub data: MetadataBlob,\n-    pub cnum_map: RefCell<cnum_map>,\n+    pub cnum_map: RefCell<CrateNumMap>,\n     pub cnum: ast::CrateNum,\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n     pub staged_api: bool,\n@@ -97,7 +99,7 @@ pub struct crate_metadata {\n \n pub struct CStore {\n     pub dep_graph: DepGraph,\n-    metas: RefCell<FnvHashMap<ast::CrateNum, Rc<crate_metadata>>>,\n+    metas: RefCell<FnvHashMap<ast::CrateNum, Rc<CrateMetadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: RefCell<NodeMap<ast::CrateNum>>,\n     used_crate_sources: RefCell<Vec<CrateSource>>,\n@@ -128,7 +130,7 @@ impl CStore {\n         self.metas.borrow().len() as ast::CrateNum + 1\n     }\n \n-    pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<crate_metadata> {\n+    pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<CrateMetadata> {\n         self.metas.borrow().get(&cnum).unwrap().clone()\n     }\n \n@@ -137,12 +139,12 @@ impl CStore {\n         decoder::get_crate_hash(cdata.data())\n     }\n \n-    pub fn set_crate_data(&self, cnum: ast::CrateNum, data: Rc<crate_metadata>) {\n+    pub fn set_crate_data(&self, cnum: ast::CrateNum, data: Rc<CrateMetadata>) {\n         self.metas.borrow_mut().insert(cnum, data);\n     }\n \n     pub fn iter_crate_data<I>(&self, mut i: I) where\n-        I: FnMut(ast::CrateNum, &Rc<crate_metadata>),\n+        I: FnMut(ast::CrateNum, &Rc<CrateMetadata>),\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n             i(k, v);\n@@ -151,7 +153,7 @@ impl CStore {\n \n     /// Like `iter_crate_data`, but passes source paths (if available) as well.\n     pub fn iter_crate_data_origins<I>(&self, mut i: I) where\n-        I: FnMut(ast::CrateNum, &crate_metadata, Option<CrateSource>),\n+        I: FnMut(ast::CrateNum, &CrateMetadata, Option<CrateSource>),\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n             let origin = self.opt_used_crate_source(k);\n@@ -182,6 +184,30 @@ impl CStore {\n         self.statically_included_foreign_items.borrow_mut().clear();\n     }\n \n+    pub fn crate_dependencies_in_rpo(&self, krate: ast::CrateNum) -> Vec<ast::CrateNum>\n+    {\n+        let mut ordering = Vec::new();\n+        self.push_dependencies_in_postorder(&mut ordering, krate);\n+        ordering.reverse();\n+        ordering\n+    }\n+\n+    pub fn push_dependencies_in_postorder(&self,\n+                                          ordering: &mut Vec<ast::CrateNum>,\n+                                          krate: ast::CrateNum)\n+    {\n+        if ordering.contains(&krate) { return }\n+\n+        let data = self.get_crate_data(krate);\n+        for &dep in data.cnum_map.borrow().iter() {\n+            if dep != krate {\n+                self.push_dependencies_in_postorder(ordering, dep);\n+            }\n+        }\n+\n+        ordering.push(krate);\n+    }\n+\n     // This method is used when generating the command line to pass through to\n     // system linker. The linker expects undefined symbols on the left of the\n     // command line to be defined in libraries on the right, not the other way\n@@ -194,17 +220,8 @@ impl CStore {\n     pub fn do_get_used_crates(&self, prefer: LinkagePreference)\n                               -> Vec<(ast::CrateNum, Option<PathBuf>)> {\n         let mut ordering = Vec::new();\n-        fn visit(cstore: &CStore, cnum: ast::CrateNum,\n-                 ordering: &mut Vec<ast::CrateNum>) {\n-            if ordering.contains(&cnum) { return }\n-            let meta = cstore.get_crate_data(cnum);\n-            for (_, &dep) in meta.cnum_map.borrow().iter() {\n-                visit(cstore, dep, ordering);\n-            }\n-            ordering.push(cnum);\n-        }\n         for (&num, _) in self.metas.borrow().iter() {\n-            visit(self, num, &mut ordering);\n+            self.push_dependencies_in_postorder(&mut ordering, num);\n         }\n         info!(\"topological ordering: {:?}\", ordering);\n         ordering.reverse();\n@@ -264,7 +281,7 @@ impl CStore {\n     }\n }\n \n-impl crate_metadata {\n+impl CrateMetadata {\n     pub fn data<'a>(&'a self) -> &'a [u8] { self.data.as_slice() }\n     pub fn name(&self) -> &str { decoder::get_crate_name(self.data()) }\n     pub fn hash(&self) -> Svh { decoder::get_crate_hash(self.data()) }\n@@ -312,20 +329,25 @@ impl crate_metadata {\n }\n \n impl MetadataBlob {\n-    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n-        let slice = match *self {\n+    pub fn as_slice_raw<'a>(&'a self) -> &'a [u8] {\n+        match *self {\n             MetadataVec(ref vec) => &vec[..],\n             MetadataArchive(ref ar) => ar.as_slice(),\n-        };\n-        if slice.len() < 4 {\n+        }\n+    }\n+\n+    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n+        let slice = self.as_slice_raw();\n+        let len_offset = 4 + common::metadata_encoding_version.len();\n+        if slice.len() < len_offset+4 {\n             &[] // corrupt metadata\n         } else {\n-            let len = (((slice[0] as u32) << 24) |\n-                       ((slice[1] as u32) << 16) |\n-                       ((slice[2] as u32) << 8) |\n-                       ((slice[3] as u32) << 0)) as usize;\n-            if len + 4 <= slice.len() {\n-                &slice[4.. len + 4]\n+            let len = (((slice[len_offset+0] as u32) << 24) |\n+                       ((slice[len_offset+1] as u32) << 16) |\n+                       ((slice[len_offset+2] as u32) << 8) |\n+                       ((slice[len_offset+3] as u32) << 0)) as usize;\n+            if len <= slice.len() - 4 - len_offset {\n+                &slice[len_offset + 4..len_offset + len + 4]\n             } else {\n                 &[] // corrupt or old metadata\n             }"}, {"sha": "eada2a9cd7a63332f6b30aeb10712a785d047f3e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -15,7 +15,7 @@\n use self::Family::*;\n \n use astencode::decode_inlined_item;\n-use cstore::{self, crate_metadata};\n+use cstore::{self, CrateMetadata};\n use common::*;\n use def_key;\n use encoder::def_to_u64;\n@@ -30,7 +30,7 @@ use rustc::util::nodemap::FnvHashMap;\n use rustc::hir;\n use rustc::session::config::PanicStrategy;\n \n-use middle::cstore::{LOCAL_CRATE, FoundAst, InlinedItem, LinkagePreference};\n+use middle::cstore::{FoundAst, InlinedItem, LinkagePreference};\n use middle::cstore::{DefLike, DlDef, DlField, DlImpl, tls};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex};\n@@ -61,9 +61,9 @@ use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax_pos::{self, Span, BytePos, NO_EXPANSION};\n \n-pub type Cmd<'a> = &'a crate_metadata;\n+pub type Cmd<'a> = &'a CrateMetadata;\n \n-impl crate_metadata {\n+impl CrateMetadata {\n     fn get_item(&self, item_id: DefIndex) -> Option<rbml::Doc> {\n         self.index.lookup_item(self.data(), item_id).map(|pos| {\n             reader::doc_at(self.data(), pos as usize).unwrap().doc\n@@ -663,7 +663,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                                      mut get_crate_data: G,\n                                      mut callback: F) where\n     F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n+    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n {\n     // Iterate over all children.\n     for child_info_doc in reader::tagged_docs(item_doc, tag_mod_child) {\n@@ -682,15 +682,12 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n         };\n \n         // Get the item.\n-        match crate_data.get_item(child_def_id.index) {\n-            None => {}\n-            Some(child_item_doc) => {\n-                // Hand off the item to the callback.\n-                let child_name = item_name(&intr, child_item_doc);\n-                let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n-                let visibility = item_visibility(child_item_doc);\n-                callback(def_like, child_name, visibility);\n-            }\n+        if let Some(child_item_doc) = crate_data.get_item(child_def_id.index) {\n+            // Hand off the item to the callback.\n+            let child_name = item_name(&intr, child_item_doc);\n+            let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n+            let visibility = item_visibility(child_item_doc);\n+            callback(def_like, child_name, visibility);\n         }\n     }\n \n@@ -758,7 +755,7 @@ pub fn each_child_of_item<F, G>(intr: Rc<IdentInterner>,\n                                get_crate_data: G,\n                                callback: F) where\n     F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n+    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n {\n     // Find the item.\n     let item_doc = match cdata.get_item(id) {\n@@ -779,7 +776,7 @@ pub fn each_top_level_item_of_crate<F, G>(intr: Rc<IdentInterner>,\n                                           get_crate_data: G,\n                                           callback: F) where\n     F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n+    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n {\n     let root_doc = rbml::Doc::new(cdata.data());\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n@@ -1348,25 +1345,16 @@ pub fn translate_def_id(cdata: Cmd, did: DefId) -> DefId {\n         return DefId { krate: cdata.cnum, index: did.index };\n     }\n \n-    match cdata.cnum_map.borrow().get(&did.krate) {\n-        Some(&n) => {\n-            DefId {\n-                krate: n,\n-                index: did.index,\n-            }\n-        }\n-        None => bug!(\"didn't find a crate in the cnum_map\")\n+    DefId {\n+        krate: cdata.cnum_map.borrow()[did.krate],\n+        index: did.index\n     }\n }\n \n // Translate a DefId from the current compilation environment to a DefId\n // for an external crate.\n fn reverse_translate_def_id(cdata: Cmd, did: DefId) -> Option<DefId> {\n-    if did.krate == cdata.cnum {\n-        return Some(DefId { krate: LOCAL_CRATE, index: did.index });\n-    }\n-\n-    for (&local, &global) in cdata.cnum_map.borrow().iter() {\n+    for (local, &global) in cdata.cnum_map.borrow().iter_enumerated() {\n         if global == did.krate {\n             return Some(DefId { krate: local, index: did.index });\n         }\n@@ -1545,10 +1533,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n         let cnum = spec.split(':').nth(0).unwrap();\n         let link = spec.split(':').nth(1).unwrap();\n         let cnum: ast::CrateNum = cnum.parse().unwrap();\n-        let cnum = match cdata.cnum_map.borrow().get(&cnum) {\n-            Some(&n) => n,\n-            None => bug!(\"didn't find a crate in the cnum_map\")\n-        };\n+        let cnum = cdata.cnum_map.borrow()[cnum];\n         result.push((cnum, if link == \"d\" {\n             LinkagePreference::RequireDynamic\n         } else {"}, {"sha": "b6f49569958d68189effffc864b47396c1029410", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1351,6 +1351,7 @@ fn my_visit_expr(expr: &hir::Expr,\n \n             rbml_w.start_tag(tag_items_data_item);\n             encode_def_id_and_key(ecx, rbml_w, def_id);\n+            encode_name(rbml_w, syntax::parse::token::intern(\"<closure>\"));\n \n             rbml_w.start_tag(tag_items_closure_ty);\n             write_closure_type(ecx, rbml_w, &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n@@ -1505,7 +1506,7 @@ fn encode_polarity(rbml_w: &mut Encoder, polarity: hir::ImplPolarity) {\n \n fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n     fn get_ordered_deps(cstore: &cstore::CStore)\n-                        -> Vec<(CrateNum, Rc<cstore::crate_metadata>)> {\n+                        -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = Vec::new();\n         cstore.iter_crate_data(|cnum, val| {\n@@ -1736,7 +1737,7 @@ fn encode_reachable(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n }\n \n fn encode_crate_dep(rbml_w: &mut Encoder,\n-                    dep: &cstore::crate_metadata) {\n+                    dep: &cstore::CrateMetadata) {\n     rbml_w.start_tag(tag_crate_dep);\n     rbml_w.wr_tagged_str(tag_crate_dep_crate_name, &dep.name());\n     let hash = decoder::get_crate_hash(dep.data());\n@@ -1798,10 +1799,6 @@ fn encode_panic_strategy(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n     }\n }\n \n-// NB: Increment this as you change the metadata encoding version.\n-#[allow(non_upper_case_globals)]\n-pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2 ];\n-\n pub fn encode_metadata(ecx: EncodeContext, krate: &hir::Crate) -> Vec<u8> {\n     let mut wr = Cursor::new(Vec::new());\n \n@@ -1835,12 +1832,25 @@ pub fn encode_metadata(ecx: EncodeContext, krate: &hir::Crate) -> Vec<u8> {\n     // the length of the metadata to the start of the metadata. Later on this\n     // will allow us to slice the metadata to the precise length that we just\n     // generated regardless of trailing bytes that end up in it.\n-    let len = v.len() as u32;\n-    v.insert(0, (len >>  0) as u8);\n-    v.insert(0, (len >>  8) as u8);\n-    v.insert(0, (len >> 16) as u8);\n-    v.insert(0, (len >> 24) as u8);\n-    return v;\n+    //\n+    // We also need to store the metadata encoding version here, because\n+    // rlibs don't have it. To get older versions of rustc to ignore\n+    // this metadata, there are 4 zero bytes at the start, which are\n+    // treated as a length of 0 by old compilers.\n+\n+    let len = v.len();\n+    let mut result = vec![];\n+    result.push(0);\n+    result.push(0);\n+    result.push(0);\n+    result.push(0);\n+    result.extend(metadata_encoding_version.iter().cloned());\n+    result.push((len >> 24) as u8);\n+    result.push((len >> 16) as u8);\n+    result.push((len >>  8) as u8);\n+    result.push((len >>  0) as u8);\n+    result.extend(v);\n+    result\n }\n \n fn encode_metadata_inner(rbml_w: &mut Encoder,"}, {"sha": "cd92493e3db703adc8e7931d51357fbc6292406f", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -36,6 +36,7 @@ extern crate rustc_errors as errors;\n \n #[macro_use]\n extern crate rustc;\n+extern crate rustc_data_structures;\n extern crate rustc_back;\n extern crate rustc_llvm;\n extern crate rustc_const_math;"}, {"sha": "48c8bcff1ec560a12db7bdba3f24b9be15b922ba", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 58, "deletions": 19, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -213,8 +213,8 @@\n //! metadata::loader or metadata::creader for all the juicy details!\n \n use cstore::{MetadataBlob, MetadataVec, MetadataArchive};\n+use common::{metadata_encoding_version, rustc_version};\n use decoder;\n-use encoder;\n \n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n@@ -260,6 +260,7 @@ pub struct Context<'a> {\n     pub rejected_via_hash: Vec<CrateMismatch>,\n     pub rejected_via_triple: Vec<CrateMismatch>,\n     pub rejected_via_kind: Vec<CrateMismatch>,\n+    pub rejected_via_version: Vec<CrateMismatch>,\n     pub should_match_name: bool,\n }\n \n@@ -336,6 +337,10 @@ impl<'a> Context<'a> {\n             struct_span_err!(self.sess, self.span, E0462,\n                              \"found staticlib `{}` instead of rlib or dylib{}\",\n                              self.ident, add)\n+        } else if !self.rejected_via_version.is_empty() {\n+            struct_span_err!(self.sess, self.span, E0514,\n+                             \"found crate `{}` compiled by an incompatible version of rustc{}\",\n+                             self.ident, add)\n         } else {\n             struct_span_err!(self.sess, self.span, E0463,\n                              \"can't find crate for `{}`{}\",\n@@ -350,7 +355,7 @@ impl<'a> Context<'a> {\n             }\n         }\n         if !self.rejected_via_hash.is_empty() {\n-            err.note(\"perhaps this crate needs to be recompiled?\");\n+            err.note(\"perhaps that crate needs to be recompiled?\");\n             let mismatches = self.rejected_via_hash.iter();\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n                 err.note(&format!(\"crate `{}` path #{}: {}\",\n@@ -367,13 +372,22 @@ impl<'a> Context<'a> {\n             }\n         }\n         if !self.rejected_via_kind.is_empty() {\n-            err.help(\"please recompile this crate using --crate-type lib\");\n+            err.help(\"please recompile that crate using --crate-type lib\");\n             let mismatches = self.rejected_via_kind.iter();\n             for (i, &CrateMismatch { ref path, .. }) in mismatches.enumerate() {\n                 err.note(&format!(\"crate `{}` path #{}: {}\",\n                                   self.ident, i+1, path.display()));\n             }\n         }\n+        if !self.rejected_via_version.is_empty() {\n+            err.help(&format!(\"please recompile that crate using this compiler ({})\",\n+                              rustc_version()));\n+            let mismatches = self.rejected_via_version.iter();\n+            for (i, &CrateMismatch { ref path, ref got }) in mismatches.enumerate() {\n+                err.note(&format!(\"crate `{}` path #{}: {} compiled by {:?}\",\n+                                  self.ident, i+1, path.display(), got));\n+            }\n+        }\n \n         err.emit();\n         self.sess.abort_if_errors();\n@@ -489,19 +503,11 @@ impl<'a> Context<'a> {\n                                                self.crate_name);\n                 err.note(\"candidates:\");\n                 for (_, lib) in libraries {\n-                    match lib.dylib {\n-                        Some((ref p, _)) => {\n-                            err.note(&format!(\"path: {}\",\n-                                              p.display()));\n-                        }\n-                        None => {}\n+                    if let Some((ref p, _)) = lib.dylib {\n+                        err.note(&format!(\"path: {}\", p.display()));\n                     }\n-                    match lib.rlib {\n-                        Some((ref p, _)) => {\n-                            err.note(&format!(\"path: {}\",\n-                                              p.display()));\n-                        }\n-                        None => {}\n+                    if let Some((ref p, _)) = lib.rlib {\n+                        err.note(&format!(\"path: {}\", p.display()));\n                     }\n                     let data = lib.metadata.as_slice();\n                     let name = decoder::get_crate_name(data);\n@@ -591,6 +597,17 @@ impl<'a> Context<'a> {\n     }\n \n     fn crate_matches(&mut self, crate_data: &[u8], libpath: &Path) -> Option<Svh> {\n+        let crate_rustc_version = decoder::crate_rustc_version(crate_data);\n+        if crate_rustc_version != Some(rustc_version()) {\n+            let message = crate_rustc_version.unwrap_or(format!(\"an unknown compiler\"));\n+            info!(\"Rejecting via version: expected {} got {}\", rustc_version(), message);\n+            self.rejected_via_version.push(CrateMismatch {\n+                path: libpath.to_path_buf(),\n+                got: message\n+            });\n+            return None;\n+        }\n+\n         if self.should_match_name {\n             match decoder::maybe_get_crate_name(crate_data) {\n                 Some(ref name) if self.crate_name == *name => {}\n@@ -742,6 +759,21 @@ impl ArchiveMetadata {\n     pub fn as_slice<'a>(&'a self) -> &'a [u8] { unsafe { &*self.data } }\n }\n \n+fn verify_decompressed_encoding_version(blob: &MetadataBlob, filename: &Path)\n+                                        -> Result<(), String>\n+{\n+    let data = blob.as_slice_raw();\n+    if data.len() < 4+metadata_encoding_version.len() ||\n+        !<[u8]>::eq(&data[..4], &[0, 0, 0, 0]) ||\n+        &data[4..4+metadata_encoding_version.len()] != metadata_encoding_version\n+    {\n+        Err((format!(\"incompatible metadata version found: '{}'\",\n+                     filename.display())))\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n // Just a small wrapper to time how long reading metadata takes.\n fn get_metadata_section(target: &Target, flavor: CrateFlavor, filename: &Path)\n                         -> Result<MetadataBlob, String> {\n@@ -772,7 +804,10 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n         return match ArchiveMetadata::new(archive).map(|ar| MetadataArchive(ar)) {\n             None => Err(format!(\"failed to read rlib metadata: '{}'\",\n                                 filename.display())),\n-            Some(blob) => Ok(blob)\n+            Some(blob) => {\n+                try!(verify_decompressed_encoding_version(&blob, filename));\n+                Ok(blob)\n+            }\n         };\n     }\n     unsafe {\n@@ -801,12 +836,12 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n                 let cvbuf: *const u8 = cbuf as *const u8;\n-                let vlen = encoder::metadata_encoding_version.len();\n+                let vlen = metadata_encoding_version.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);\n                 let minsz = cmp::min(vlen, csz);\n                 let buf0 = slice::from_raw_parts(cvbuf, minsz);\n-                let version_ok = buf0 == encoder::metadata_encoding_version;\n+                let version_ok = buf0 == metadata_encoding_version;\n                 if !version_ok {\n                     return Err((format!(\"incompatible metadata version found: '{}'\",\n                                         filename.display())));\n@@ -817,7 +852,11 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n                        csz - vlen);\n                 let bytes = slice::from_raw_parts(cvbuf1, csz - vlen);\n                 match flate::inflate_bytes(bytes) {\n-                    Ok(inflated) => return Ok(MetadataVec(inflated)),\n+                    Ok(inflated) => {\n+                        let blob = MetadataVec(inflated);\n+                        try!(verify_decompressed_encoding_version(&blob, filename));\n+                        return Ok(blob);\n+                    }\n                     Err(_) => {}\n                 }\n             }"}, {"sha": "119640af463aa8bf768dddfc23ede46bd996df88", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -396,16 +396,13 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n \n                 let pos = self.parse_vuint();\n                 let key = ty::CReaderCacheKey { cnum: self.krate, pos: pos };\n-                match tcx.rcache.borrow().get(&key).cloned() {\n-                    Some(tt) => {\n-                        // If there is a closure buried in the type some where, then we\n-                        // need to re-convert any def ids (see case 'k', below). That means\n-                        // we can't reuse the cached version.\n-                        if !tt.has_closure_types() {\n-                            return tt;\n-                        }\n+                if let Some(tt) = tcx.rcache.borrow().get(&key).cloned() {\n+                    // If there is a closure buried in the type some where, then we\n+                    // need to re-convert any def ids (see case 'k', below). That means\n+                    // we can't reuse the cached version.\n+                    if !tt.has_closure_types() {\n+                        return tt;\n                     }\n-                    None => {}\n                 }\n \n                 let mut substate = TyDecoder::new(self.data,"}, {"sha": "1afeccdf8e3a9b9a6735f0472f7f8e21aa60e40c", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -64,9 +64,9 @@ pub struct ty_abbrev {\n pub type abbrev_map<'tcx> = RefCell<FnvHashMap<Ty<'tcx>, ty_abbrev>>;\n \n pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n-    match cx.abbrevs.borrow_mut().get(&t) {\n-        Some(a) => { w.write_all(&a.s); return; }\n-        None => {}\n+    if let Some(a) = cx.abbrevs.borrow_mut().get(&t) {\n+        w.write_all(&a.s);\n+        return;\n     }\n \n     let pos = w.position();"}, {"sha": "91ecad8402fd40b2df5e50b97da5d7910d8c7614", "filename": "src/librustc_platform_intrinsics/x86.rs", "status": "modified", "additions": 899, "deletions": 849, "changes": 1748, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_platform_intrinsics%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_platform_intrinsics%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Fx86.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e"}, {"sha": "66b0d663424aa829a95c673de86b76e27b63ae8e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1167,18 +1167,6 @@ impl<'a> Resolver<'a> {\n \n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n-        // Currently, we ignore the name resolution data structures for\n-        // the purposes of dependency tracking. Instead we will run name\n-        // resolution and include its output in the hash of each item,\n-        // much like we do for macro expansion. In other words, the hash\n-        // reflects not just its contents but the results of name\n-        // resolution on those contents. Hopefully we'll push this back at\n-        // some point.\n-        let _ignore = self.session.dep_graph.in_ignore();\n-\n-        self.build_reduced_graph(krate);\n-        resolve_imports::resolve_imports(self);\n-\n         self.current_module = self.graph_root;\n         visit::walk_crate(self, krate);\n "}, {"sha": "16a59fbb800024afcd24c43de94a8b15307da684", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -30,6 +30,12 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use std::cell::{Cell, RefCell};\n \n+impl<'a> Resolver<'a> {\n+    pub fn resolve_imports(&mut self) {\n+        ImportResolver { resolver: self }.resolve_imports();\n+    }\n+}\n+\n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n pub enum ImportDirectiveSubclass {\n@@ -722,8 +728,3 @@ fn import_directive_subclass_to_string(subclass: &ImportDirectiveSubclass) -> St\n         GlobImport { .. } => \"*\".to_string(),\n     }\n }\n-\n-pub fn resolve_imports(resolver: &mut Resolver) {\n-    let mut import_resolver = ImportResolver { resolver: resolver };\n-    import_resolver.resolve_imports();\n-}"}, {"sha": "0580c51d9a17a745db2140e59ef8b3885624849c", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -299,12 +299,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             let mut result = String::from(\"<\");\n                             result.push_str(&rustc::hir::print::ty_to_string(&ty));\n \n-                            match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n-                                Some(def_id) => {\n-                                    result.push_str(\" as \");\n-                                    result.push_str(&self.tcx.item_path_str(def_id));\n-                                }\n-                                None => {}\n+                            if let Some(def_id) = self.tcx\n+                                    .trait_of_item(self.tcx.map.local_def_id(id)) {\n+                                result.push_str(\" as \");\n+                                result.push_str(&self.tcx.item_path_str(def_id));\n                             }\n                             result.push_str(\">\");\n                             result"}, {"sha": "3ef6e29a6f83894da32612e3ba11b5fa4fcd780a", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1706,17 +1706,13 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             //\n             // In such cases, the more general path is unsafe, because\n             // it assumes it is matching against a valid value.\n-            match simple_name(pat) {\n-                Some(name) => {\n-                    let var_scope = cleanup::var_scope(tcx, local.id);\n-                    return mk_binding_alloca(\n-                        bcx, pat.id, name, var_scope, (),\n-                        \"_match::store_local\",\n-                        |(), bcx, Datum { val: v, .. }| expr::trans_into(bcx, &init_expr,\n-                                                                         expr::SaveIn(v)));\n-                }\n-\n-                None => {}\n+            if let Some(name) = simple_name(pat) {\n+                let var_scope = cleanup::var_scope(tcx, local.id);\n+                return mk_binding_alloca(\n+                    bcx, pat.id, name, var_scope, (),\n+                    \"_match::store_local\",\n+                    |(), bcx, Datum { val: v, .. }| expr::trans_into(bcx, &init_expr,\n+                                                                     expr::SaveIn(v)));\n             }\n \n             // General path."}, {"sha": "23c4258caf7bd9c5ca873ba44d9c4ac28880f2d0", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -191,9 +191,8 @@ pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 t: Ty<'tcx>)\n                                 -> Rc<Repr<'tcx>> {\n     debug!(\"Representing: {}\", t);\n-    match cx.adt_reprs().borrow().get(&t) {\n-        Some(repr) => return repr.clone(),\n-        None => {}\n+    if let Some(repr) = cx.adt_reprs().borrow().get(&t) {\n+        return repr.clone();\n     }\n \n     let repr = Rc::new(represent_type_uncached(cx, t));"}, {"sha": "744712b22b060ef3cafafef22dc282fb8329daa2", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -136,14 +136,17 @@ pub fn build_link_meta<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     return r;\n }\n \n-pub fn get_linker(sess: &Session) -> (String, Command) {\n+// The third parameter is for an extra path to add to PATH for MSVC\n+// cross linkers for host toolchain DLL dependencies\n+pub fn get_linker(sess: &Session) -> (String, Command, Option<PathBuf>) {\n     if let Some(ref linker) = sess.opts.cg.linker {\n-        (linker.clone(), Command::new(linker))\n+        (linker.clone(), Command::new(linker), None)\n     } else if sess.target.target.options.is_like_msvc {\n-        (\"link.exe\".to_string(), msvc::link_exe_cmd(sess))\n+        let (cmd, host) = msvc::link_exe_cmd(sess);\n+        (\"link.exe\".to_string(), cmd, host)\n     } else {\n         (sess.target.target.options.linker.clone(),\n-         Command::new(&sess.target.target.options.linker))\n+         Command::new(&sess.target.target.options.linker), None)\n     }\n }\n \n@@ -153,17 +156,15 @@ pub fn get_ar_prog(sess: &Session) -> String {\n     })\n }\n \n-fn command_path(sess: &Session) -> OsString {\n+fn command_path(sess: &Session, extra: Option<PathBuf>) -> OsString {\n     // The compiler's sysroot often has some bundled tools, so add it to the\n     // PATH for the child.\n     let mut new_path = sess.host_filesearch(PathKind::All)\n                            .get_tools_search_paths();\n     if let Some(path) = env::var_os(\"PATH\") {\n         new_path.extend(env::split_paths(&path));\n     }\n-    if sess.target.target.options.is_like_msvc {\n-        new_path.extend(msvc::host_dll_path());\n-    }\n+    new_path.extend(extra);\n     env::join_paths(new_path).unwrap()\n }\n \n@@ -379,7 +380,7 @@ fn archive_config<'a>(sess: &'a Session,\n         src: input.map(|p| p.to_path_buf()),\n         lib_search_paths: archive_search_paths(sess),\n         ar_prog: get_ar_prog(sess),\n-        command_path: command_path(sess),\n+        command_path: command_path(sess, None),\n     }\n }\n \n@@ -616,8 +617,8 @@ fn link_natively(sess: &Session,\n     info!(\"preparing {:?} from {:?} to {:?}\", crate_type, objects, out_filename);\n \n     // The invocations of cc share some flags across platforms\n-    let (pname, mut cmd) = get_linker(sess);\n-    cmd.env(\"PATH\", command_path(sess));\n+    let (pname, mut cmd, extra) = get_linker(sess);\n+    cmd.env(\"PATH\", command_path(sess, extra));\n \n     let root = sess.target_filesearch(PathKind::Native).get_lib_path();\n     cmd.args(&sess.target.target.options.pre_link_args);\n@@ -682,10 +683,15 @@ fn link_natively(sess: &Session,\n             info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout[..]));\n         },\n         Err(e) => {\n-            // Trying to diagnose https://github.com/rust-lang/rust/issues/33844\n             sess.struct_err(&format!(\"could not exec the linker `{}`: {}\", pname, e))\n                 .note(&format!(\"{:?}\", &cmd))\n                 .emit();\n+            if sess.target.target.options.is_like_msvc && e.kind() == io::ErrorKind::NotFound {\n+                sess.note_without_error(\"the msvc targets depend on the msvc linker \\\n+                    but `link.exe` was not found\");\n+                sess.note_without_error(\"please ensure that VS 2013 or VS 2015 was installed \\\n+                    with the Visual C++ option\");\n+            }\n             sess.abort_if_errors();\n         }\n     }"}, {"sha": "c10312a8e17103f1d147367224e4c6e07db49df4", "filename": "src/librustc_trans/back/msvc/arch.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fback%2Fmsvc%2Farch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fback%2Fmsvc%2Farch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Farch.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_camel_case_types, non_snake_case)]\n+\n+use libc::c_void;\n+use std::mem;\n+\n+type DWORD = u32;\n+type WORD = u16;\n+type LPVOID = *mut c_void;\n+type DWORD_PTR = usize;\n+\n+const PROCESSOR_ARCHITECTURE_INTEL: WORD = 0;\n+const PROCESSOR_ARCHITECTURE_AMD64: WORD = 9;\n+\n+#[repr(C)]\n+struct SYSTEM_INFO {\n+    wProcessorArchitecture: WORD,\n+    _wReserved: WORD,\n+    _dwPageSize: DWORD,\n+    _lpMinimumApplicationAddress: LPVOID,\n+    _lpMaximumApplicationAddress: LPVOID,\n+    _dwActiveProcessorMask: DWORD_PTR,\n+    _dwNumberOfProcessors: DWORD,\n+    _dwProcessorType: DWORD,\n+    _dwAllocationGranularity: DWORD,\n+    _wProcessorLevel: WORD,\n+    _wProcessorRevision: WORD,\n+}\n+\n+extern \"system\" {\n+    fn GetNativeSystemInfo(lpSystemInfo: *mut SYSTEM_INFO);\n+}\n+\n+pub enum Arch {\n+    X86,\n+    Amd64,\n+}\n+\n+pub fn host_arch() -> Option<Arch> {\n+    let mut info = unsafe { mem::zeroed() };\n+    unsafe { GetNativeSystemInfo(&mut info) };\n+    match info.wProcessorArchitecture {\n+        PROCESSOR_ARCHITECTURE_INTEL => Some(Arch::X86),\n+        PROCESSOR_ARCHITECTURE_AMD64 => Some(Arch::Amd64),\n+        _ => None,\n+    }\n+}"}, {"sha": "16aef6ee8ca3543047ba07c85d867f9eae1de881", "filename": "src/librustc_trans/back/msvc/mod.rs", "status": "modified", "additions": 185, "deletions": 168, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -31,8 +31,18 @@\n //! paths/files is based on Microsoft's logic in their vcvars bat files, but\n //! comments can also be found below leading through the various code paths.\n \n+// A simple macro to make this option mess easier to read\n+macro_rules! otry {\n+    ($expr:expr) => (match $expr {\n+        Some(val) => val,\n+        None => return None,\n+    })\n+}\n+\n #[cfg(windows)]\n mod registry;\n+#[cfg(windows)]\n+mod arch;\n \n #[cfg(windows)]\n mod platform {\n@@ -42,212 +52,223 @@ mod platform {\n     use std::path::{Path, PathBuf};\n     use std::process::Command;\n     use session::Session;\n-    use super::registry::{LOCAL_MACHINE};\n+    use super::arch::{host_arch, Arch};\n+    use super::registry::LOCAL_MACHINE;\n \n-    // Cross toolchains depend on dlls from the host toolchain\n-    // We can't just add it to the Command's PATH in `link_exe_cmd` because it\n-    // is later overridden so we publicly expose it here instead\n-    pub fn host_dll_path() -> Option<PathBuf> {\n-        get_vc_dir().and_then(|(_, vcdir)| {\n-            host_dll_subdir().map(|sub| {\n-                vcdir.join(\"bin\").join(sub)\n+    // First we need to figure out whether the environment is already correctly\n+    // configured by vcvars. We do this by looking at the environment variable\n+    // `VCINSTALLDIR` which is always set by vcvars, and unlikely to be set\n+    // otherwise. If it is defined, then we find `link.exe` in `PATH and trust\n+    // that everything else is configured correctly.\n+    //\n+    // If `VCINSTALLDIR` wasn't defined (or we couldn't find the linker where\n+    // it claimed it should be), then we resort to finding everything\n+    // ourselves. First we find where the latest version of MSVC is installed\n+    // and what version it is. Then based on the version we find the\n+    // appropriate SDKs.\n+    //\n+    // If despite our best efforts we are still unable to find MSVC then we\n+    // just blindly call `link.exe` and hope for the best.\n+    //\n+    // This code only supports VC 11 through 15. For versions older than that\n+    // the user will need to manually execute the appropriate vcvars bat file\n+    // and it should hopefully work.\n+    //\n+    // The second member of the tuple we return is the directory for the host\n+    // linker toolchain, which is necessary when using the cross linkers.\n+    pub fn link_exe_cmd(sess: &Session) -> (Command, Option<PathBuf>) {\n+        let arch = &sess.target.target.arch;\n+        env::var_os(\"VCINSTALLDIR\").and_then(|_| {\n+            debug!(\"Detected that vcvars was already run.\");\n+            let path = otry!(env::var_os(\"PATH\"));\n+            // Mingw has its own link which is not the link we want so we\n+            // look for `cl.exe` too as a precaution.\n+            env::split_paths(&path).find(|path| {\n+                path.join(\"cl.exe\").is_file()\n+                    && path.join(\"link.exe\").is_file()\n+            }).map(|path| {\n+                (Command::new(path.join(\"link.exe\")), None)\n             })\n+        }).or_else(|| {\n+            None.or_else(|| {\n+                find_msvc_latest(arch, \"15.0\")\n+            }).or_else(|| {\n+                find_msvc_latest(arch, \"14.0\")\n+            }).or_else(|| {\n+                find_msvc_12(arch)\n+            }).or_else(|| {\n+                find_msvc_11(arch)\n+            }).map(|(cmd, path)| (cmd, Some(path)))\n+        }).unwrap_or_else(|| {\n+            debug!(\"Failed to locate linker.\");\n+            (Command::new(\"link.exe\"), None)\n         })\n     }\n \n-    pub fn link_exe_cmd(sess: &Session) -> Command {\n-        let arch = &sess.target.target.arch;\n-        let (binsub, libsub, vclibsub) =\n-            match (bin_subdir(arch), lib_subdir(arch), vc_lib_subdir(arch)) {\n-            (Some(x), Some(y), Some(z)) => (x, y, z),\n-            _ => return Command::new(\"link.exe\"),\n-        };\n+    // For MSVC 14 or newer we need to find the Universal CRT as well as either\n+    // the Windows 10 SDK or Windows 8.1 SDK.\n+    fn find_msvc_latest(arch: &str, ver: &str) -> Option<(Command, PathBuf)> {\n+        let vcdir = otry!(get_vc_dir(ver));\n+        let (mut cmd, host) = otry!(get_linker(&vcdir, arch));\n+        let sub = otry!(lib_subdir(arch));\n+        let ucrt = otry!(get_ucrt_dir());\n+        debug!(\"Found Universal CRT {:?}\", ucrt);\n+        add_lib(&mut cmd, &ucrt.join(\"ucrt\").join(sub));\n+        if let Some(dir) = get_sdk10_dir() {\n+            debug!(\"Found Win10 SDK {:?}\", dir);\n+            add_lib(&mut cmd, &dir.join(\"um\").join(sub));\n+        } else if let Some(dir) = get_sdk81_dir() {\n+            debug!(\"Found Win8.1 SDK {:?}\", dir);\n+            add_lib(&mut cmd, &dir.join(\"um\").join(sub));\n+        } else {\n+            return None\n+        }\n+        Some((cmd, host))\n+    }\n \n-        // First we need to figure out whether the environment is already correctly\n-        // configured by vcvars. We do this by looking at the environment variable\n-        // `VCINSTALLDIR` which is always set by vcvars, and unlikely to be set\n-        // otherwise. If it is defined, then we derive the path to `link.exe` from\n-        // that and trust that everything else is configured correctly.\n-        //\n-        // If `VCINSTALLDIR` wasn't defined (or we couldn't find the linker where it\n-        // claimed it should be), then we resort to finding everything ourselves.\n-        // First we find where the latest version of MSVC is installed and what\n-        // version it is. Then based on the version we find the appropriate SDKs.\n-        //\n-        // For MSVC 14 (VS 2015) we look for the Win10 SDK and failing that we look\n-        // for the Win8.1 SDK. We also look for the Universal CRT.\n-        //\n-        // For MSVC 12 (VS 2013) we look for the Win8.1 SDK.\n-        //\n-        // For MSVC 11 (VS 2012) we look for the Win8 SDK.\n-        //\n-        // For all other versions the user has to execute the appropriate vcvars bat\n-        // file themselves to configure the environment.\n-        //\n-        // If despite our best efforts we are still unable to find MSVC then we just\n-        // blindly call `link.exe` and hope for the best.\n-        return env::var_os(\"VCINSTALLDIR\").and_then(|dir| {\n-            debug!(\"Environment already configured by user. Assuming it works.\");\n-            let mut p = PathBuf::from(dir);\n-            p.push(\"bin\");\n-            p.push(binsub);\n-            p.push(\"link.exe\");\n-            if !p.is_file() { return None }\n-            Some(Command::new(p))\n-        }).or_else(|| {\n-            get_vc_dir().and_then(|(ver, vcdir)| {\n-                debug!(\"Found VC installation directory {:?}\", vcdir);\n-                let linker = vcdir.clone().join(\"bin\").join(binsub).join(\"link.exe\");\n-                if !linker.is_file() { return None }\n-                let mut cmd = Command::new(linker);\n-                add_lib(&mut cmd, &vcdir.join(\"lib\").join(vclibsub));\n-                if ver == \"14.0\" {\n-                    if let Some(dir) = get_ucrt_dir() {\n-                        debug!(\"Found Universal CRT {:?}\", dir);\n-                        add_lib(&mut cmd, &dir.join(\"ucrt\").join(libsub));\n-                    }\n-                    if let Some(dir) = get_sdk10_dir() {\n-                        debug!(\"Found Win10 SDK {:?}\", dir);\n-                        add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n-                    } else if let Some(dir) = get_sdk81_dir() {\n-                        debug!(\"Found Win8.1 SDK {:?}\", dir);\n-                        add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n-                    }\n-                } else if ver == \"12.0\" {\n-                    if let Some(dir) = get_sdk81_dir() {\n-                        debug!(\"Found Win8.1 SDK {:?}\", dir);\n-                        add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n-                    }\n-                } else { // ver == \"11.0\"\n-                    if let Some(dir) = get_sdk8_dir() {\n-                        debug!(\"Found Win8 SDK {:?}\", dir);\n-                        add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n-                    }\n-                }\n-                Some(cmd)\n-            })\n-        }).unwrap_or_else(|| {\n-            debug!(\"Failed to locate linker.\");\n-            Command::new(\"link.exe\")\n-        });\n+    // For MSVC 12 we need to find the Windows 8.1 SDK.\n+    fn find_msvc_12(arch: &str) -> Option<(Command, PathBuf)> {\n+        let vcdir = otry!(get_vc_dir(\"12.0\"));\n+        let (mut cmd, host) = otry!(get_linker(&vcdir, arch));\n+        let sub = otry!(lib_subdir(arch));\n+        let sdk81 = otry!(get_sdk81_dir());\n+        debug!(\"Found Win8.1 SDK {:?}\", sdk81);\n+        add_lib(&mut cmd, &sdk81.join(\"um\").join(sub));\n+        Some((cmd, host))\n+    }\n+\n+    // For MSVC 11 we need to find the Windows 8 SDK.\n+    fn find_msvc_11(arch: &str) -> Option<(Command, PathBuf)> {\n+        let vcdir = otry!(get_vc_dir(\"11.0\"));\n+        let (mut cmd, host) = otry!(get_linker(&vcdir, arch));\n+        let sub = otry!(lib_subdir(arch));\n+        let sdk8 = otry!(get_sdk8_dir());\n+        debug!(\"Found Win8 SDK {:?}\", sdk8);\n+        add_lib(&mut cmd, &sdk8.join(\"um\").join(sub));\n+        Some((cmd, host))\n     }\n-    // A convenience function to make the above code simpler\n+\n+    // A convenience function to append library paths.\n     fn add_lib(cmd: &mut Command, lib: &Path) {\n         let mut arg: OsString = \"/LIBPATH:\".into();\n         arg.push(lib);\n         cmd.arg(arg);\n     }\n \n-    // To find MSVC we look in a specific registry key for the newest of the\n-    // three versions that we support.\n-    fn get_vc_dir() -> Option<(&'static str, PathBuf)> {\n-        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\VisualStudio\\SxS\\VC7\".as_ref())\n-        .ok().and_then(|key| {\n-            [\"14.0\", \"12.0\", \"11.0\"].iter().filter_map(|ver| {\n-                key.query_str(ver).ok().map(|p| (*ver, p.into()))\n-            }).next()\n-        })\n+    // Given a possible MSVC installation directory, we look for the linker and\n+    // then add the MSVC library path.\n+    fn get_linker(path: &Path, arch: &str) -> Option<(Command, PathBuf)> {\n+        debug!(\"Looking for linker in {:?}\", path);\n+        bin_subdir(arch).into_iter().map(|(sub, host)| {\n+            (path.join(\"bin\").join(sub).join(\"link.exe\"),\n+             path.join(\"bin\").join(host))\n+        }).filter(|&(ref path, _)| {\n+            path.is_file()\n+        }).map(|(path, host)| {\n+            (Command::new(path), host)\n+        }).filter_map(|(mut cmd, host)| {\n+            let sub = otry!(vc_lib_subdir(arch));\n+            add_lib(&mut cmd, &path.join(\"lib\").join(sub));\n+            Some((cmd, host))\n+        }).next()\n+    }\n+\n+    // To find MSVC we look in a specific registry key for the version we are\n+    // trying to find.\n+    fn get_vc_dir(ver: &str) -> Option<PathBuf> {\n+        let key = otry!(LOCAL_MACHINE\n+            .open(r\"SOFTWARE\\Microsoft\\VisualStudio\\SxS\\VC7\".as_ref()).ok());\n+        let path = otry!(key.query_str(ver).ok());\n+        Some(path.into())\n     }\n \n     // To find the Universal CRT we look in a specific registry key for where\n     // all the Universal CRTs are located and then sort them asciibetically to\n     // find the newest version. While this sort of sorting isn't ideal,  it is\n     // what vcvars does so that's good enough for us.\n     fn get_ucrt_dir() -> Option<PathBuf> {\n-        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots\".as_ref())\n-        .ok().and_then(|key| {\n-            key.query_str(\"KitsRoot10\").ok()\n-        }).and_then(|root| {\n-            fs::read_dir(Path::new(&root).join(\"Lib\")).ok()\n-        }).and_then(|readdir| {\n-            let mut dirs: Vec<_> = readdir.filter_map(|dir| {\n-                dir.ok()\n-            }).map(|dir| {\n-                dir.path()\n-            }).filter(|dir| {\n-                dir.components().last().and_then(|c| {\n-                    c.as_os_str().to_str()\n-                }).map(|c| c.starts_with(\"10.\")).unwrap_or(false)\n-            }).collect();\n-            dirs.sort();\n-            dirs.pop()\n-        })\n+        let key = otry!(LOCAL_MACHINE\n+            .open(r\"SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots\".as_ref()).ok());\n+        let root = otry!(key.query_str(\"KitsRoot10\").ok());\n+        let readdir = otry!(fs::read_dir(Path::new(&root).join(\"lib\")).ok());\n+        readdir.filter_map(|dir| {\n+            dir.ok()\n+        }).map(|dir| {\n+            dir.path()\n+        }).filter(|dir| {\n+            dir.components().last().and_then(|c| {\n+                c.as_os_str().to_str()\n+            }).map(|c| {\n+                c.starts_with(\"10.\") && dir.join(\"ucrt\").is_dir()\n+            }).unwrap_or(false)\n+        }).max()\n     }\n \n     // Vcvars finds the correct version of the Windows 10 SDK by looking\n-    // for the include um/Windows.h because sometimes a given version will\n+    // for the include `um\\Windows.h` because sometimes a given version will\n     // only have UCRT bits without the rest of the SDK. Since we only care about\n-    // libraries and not includes, we just look for the folder `um` in the lib\n-    // section. Like we do for the Universal CRT, we sort the possibilities\n+    // libraries and not includes, we instead look for `um\\x64\\kernel32.lib`.\n+    // Since the 32-bit and 64-bit libraries are always installed together we\n+    // only need to bother checking x64, making this code a tiny bit simpler.\n+    // Like we do for the Universal CRT, we sort the possibilities\n     // asciibetically to find the newest one as that is what vcvars does.\n     fn get_sdk10_dir() -> Option<PathBuf> {\n-        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v10.0\".as_ref())\n-        .ok().and_then(|key| {\n-            key.query_str(\"InstallationFolder\").ok()\n-        }).and_then(|root| {\n-            fs::read_dir(Path::new(&root).join(\"lib\")).ok()\n-        }).and_then(|readdir| {\n-            let mut dirs: Vec<_> = readdir.filter_map(|dir| dir.ok())\n-                .map(|dir| dir.path()).collect();\n-            dirs.sort();\n-            dirs.into_iter().rev().filter(|dir| {\n-                dir.join(\"um\").is_dir()\n-            }).next()\n-        })\n+        let key = otry!(LOCAL_MACHINE\n+            .open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v10.0\".as_ref()).ok());\n+        let root = otry!(key.query_str(\"InstallationFolder\").ok());\n+        let readdir = otry!(fs::read_dir(Path::new(&root).join(\"lib\")).ok());\n+        let mut dirs: Vec<_> = readdir.filter_map(|dir| dir.ok())\n+            .map(|dir| dir.path()).collect();\n+        dirs.sort();\n+        dirs.into_iter().rev().filter(|dir| {\n+            dir.join(\"um\").join(\"x64\").join(\"kernel32.lib\").is_file()\n+        }).next()\n     }\n \n     // Interestingly there are several subdirectories, `win7` `win8` and\n     // `winv6.3`. Vcvars seems to only care about `winv6.3` though, so the same\n     // applies to us. Note that if we were targetting kernel mode drivers\n     // instead of user mode applications, we would care.\n     fn get_sdk81_dir() -> Option<PathBuf> {\n-        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v8.1\".as_ref())\n-        .ok().and_then(|key| {\n-            key.query_str(\"InstallationFolder\").ok()\n-        }).map(|root| {\n-            Path::new(&root).join(\"lib\").join(\"winv6.3\")\n-        })\n+        let key = otry!(LOCAL_MACHINE\n+            .open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v8.1\".as_ref()).ok());\n+        let root = otry!(key.query_str(\"InstallationFolder\").ok());\n+        Some(Path::new(&root).join(\"lib\").join(\"winv6.3\"))\n     }\n \n     fn get_sdk8_dir() -> Option<PathBuf> {\n-        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v8.0\".as_ref())\n-        .ok().and_then(|key| {\n-            key.query_str(\"InstallationFolder\").ok()\n-        }).map(|root| {\n-            Path::new(&root).join(\"lib\").join(\"win8\")\n-        })\n+        let key = otry!(LOCAL_MACHINE\n+            .open(r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v8.0\".as_ref()).ok());\n+        let root = otry!(key.query_str(\"InstallationFolder\").ok());\n+        Some(Path::new(&root).join(\"lib\").join(\"win8\"))\n     }\n \n     // When choosing the linker toolchain to use, we have to choose the one\n     // which matches the host architecture. Otherwise we end up in situations\n     // where someone on 32-bit Windows is trying to cross compile to 64-bit and\n     // it tries to invoke the native 64-bit linker which won't work.\n     //\n-    // FIXME - This currently functions based on the host architecture of rustc\n-    // itself but it should instead detect the bitness of the OS itself.\n+    // For the return value of this function, the first member of the tuple is\n+    // the folder of the linker we will be invoking, while the second member\n+    // is the folder of the host toolchain for that linker which is essential\n+    // when using a cross linker. We return a Vec since on x64 there are often\n+    // two linkers that can target the architecture we desire. The 64-bit host\n+    // linker is preferred, and hence first, due to 64-bit allowing it more\n+    // address space to work with and potentially being faster.\n     //\n     // FIXME - Figure out what happens when the host architecture is arm.\n-    //\n-    // FIXME - Some versions of MSVC may not come with all these toolchains.\n-    // Consider returning an array of toolchains and trying them one at a time\n-    // until the linker is found.\n-    fn bin_subdir(arch: &str) -> Option<&'static str> {\n-        if cfg!(target_arch = \"x86_64\") {\n-            match arch {\n-                \"x86\" => Some(\"amd64_x86\"),\n-                \"x86_64\" => Some(\"amd64\"),\n-                \"arm\" => Some(\"amd64_arm\"),\n-                _ => None,\n-            }\n-        } else if cfg!(target_arch = \"x86\") {\n-            match arch {\n-                \"x86\" => Some(\"\"),\n-                \"x86_64\" => Some(\"x86_amd64\"),\n-                \"arm\" => Some(\"x86_arm\"),\n-                _ => None,\n-            }\n-        } else { None }\n+    fn bin_subdir(arch: &str) -> Vec<(&'static str, &'static str)> {\n+        match (arch, host_arch()) {\n+            (\"x86\", Some(Arch::X86)) => vec![(\"\", \"\")],\n+            (\"x86\", Some(Arch::Amd64)) => vec![(\"amd64_x86\", \"amd64\"), (\"\", \"\")],\n+            (\"x86_64\", Some(Arch::X86)) => vec![(\"x86_amd64\", \"\")],\n+            (\"x86_64\", Some(Arch::Amd64)) => vec![(\"amd64\", \"amd64\"), (\"x86_amd64\", \"\")],\n+            (\"arm\", Some(Arch::X86)) => vec![(\"x86_arm\", \"\")],\n+            (\"arm\", Some(Arch::Amd64)) => vec![(\"amd64_arm\", \"amd64\"), (\"x86_arm\", \"\")],\n+            _ => vec![],\n+        }\n     }\n+\n     fn lib_subdir(arch: &str) -> Option<&'static str> {\n         match arch {\n             \"x86\" => Some(\"x86\"),\n@@ -256,6 +277,7 @@ mod platform {\n             _ => None,\n         }\n     }\n+\n     // MSVC's x86 libraries are not in a subfolder\n     fn vc_lib_subdir(arch: &str) -> Option<&'static str> {\n         match arch {\n@@ -265,11 +287,6 @@ mod platform {\n             _ => None,\n         }\n     }\n-    fn host_dll_subdir() -> Option<&'static str> {\n-        if cfg!(target_arch = \"x86_64\") { Some(\"amd64\") }\n-        else if cfg!(target_arch = \"x86\") { Some(\"\") }\n-        else { None }\n-    }\n }\n \n // If we're not on Windows, then there's no registry to search through and MSVC\n@@ -279,9 +296,9 @@ mod platform {\n     use std::path::PathBuf;\n     use std::process::Command;\n     use session::Session;\n-    pub fn link_exe_cmd(_sess: &Session) -> Command {\n-        Command::new(\"link.exe\")\n+    pub fn link_exe_cmd(_sess: &Session) -> (Command, Option<PathBuf>) {\n+        (Command::new(\"link.exe\"), None)\n     }\n-    pub fn host_dll_path() -> Option<PathBuf> { None }\n }\n+\n pub use self::platform::*;"}, {"sha": "ec20381d1890d1f55f5d6e543104503ac4542ae5", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -616,11 +616,19 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n     }\n \n-    llvm::LLVMDisposeModule(llmod);\n-    llvm::LLVMContextDispose(llcx);\n     llvm::LLVMRustDisposeTargetMachine(tm);\n }\n \n+\n+pub fn cleanup_llvm(trans: &CrateTranslation) {\n+    for module in trans.modules.iter() {\n+        unsafe {\n+            llvm::LLVMDisposeModule(module.llmod);\n+            llvm::LLVMContextDispose(module.llcx);\n+        }\n+    }\n+}\n+\n pub fn run_passes(sess: &Session,\n                   trans: &CrateTranslation,\n                   output_types: &HashMap<OutputType, Option<PathBuf>>,\n@@ -970,7 +978,7 @@ fn run_work_multithreaded(sess: &Session,\n }\n \n pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n-    let (pname, mut cmd) = get_linker(sess);\n+    let (pname, mut cmd, _) = get_linker(sess);\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(&outputs.path(OutputType::Object))\n                            .arg(&outputs.temp_path(OutputType::Assembly));"}, {"sha": "7a572fdadc3d795bdac78a20a3bb3ea80449ed96", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -136,11 +136,8 @@ pub struct _InsnCtxt {\n impl Drop for _InsnCtxt {\n     fn drop(&mut self) {\n         TASK_LOCAL_INSN_KEY.with(|slot| {\n-            match slot.borrow_mut().as_mut() {\n-                Some(ctx) => {\n-                    ctx.pop();\n-                }\n-                None => {}\n+            if let Some(ctx) = slot.borrow_mut().as_mut() {\n+                ctx.pop();\n             }\n         })\n     }"}, {"sha": "5596ab0d819e0a3470f7b6a2e360a0c72de87fa2", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -138,18 +138,15 @@ pub fn addr_of(ccx: &CrateContext,\n                align: machine::llalign,\n                kind: &str)\n                -> ValueRef {\n-    match ccx.const_globals().borrow().get(&cv) {\n-        Some(&gv) => {\n-            unsafe {\n-                // Upgrade the alignment in cases where the same constant is used with different\n-                // alignment requirements\n-                if align > llvm::LLVMGetAlignment(gv) {\n-                    llvm::LLVMSetAlignment(gv, align);\n-                }\n+    if let Some(&gv) = ccx.const_globals().borrow().get(&cv) {\n+        unsafe {\n+            // Upgrade the alignment in cases where the same constant is used with different\n+            // alignment requirements\n+            if align > llvm::LLVMGetAlignment(gv) {\n+                llvm::LLVMSetAlignment(gv, align);\n             }\n-            return gv;\n         }\n-        None => {}\n+        return gv;\n     }\n     let gv = addr_of_mut(ccx, cv, align, kind);\n     unsafe {"}, {"sha": "d36878b03322a30fbe24c4c98c66bdaed168a242", "filename": "src/librustc_trans/diagnostics.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdiagnostics.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -12,6 +12,44 @@\n \n register_long_diagnostics! {\n \n+E0510: r##\"\n+`return_address` was used in an invalid context. Erroneous code example:\n+\n+```ignore\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn return_address() -> *const u8;\n+}\n+\n+unsafe fn by_value() -> i32 {\n+    let _ = return_address();\n+    // error: invalid use of `return_address` intrinsic: function does\n+    //        not use out pointer\n+    0\n+}\n+```\n+\n+Return values may be stored in a return register(s) or written into a so-called\n+out pointer. In case the returned value is too big (this is\n+target-ABI-dependent and generally not portable or future proof) to fit into\n+the return register(s), the compiler will return the value by writing it into\n+space allocated in the caller's stack frame. Example:\n+\n+```\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn return_address() -> *const u8;\n+}\n+\n+unsafe fn by_pointer() -> String {\n+    let _ = return_address();\n+    String::new() // ok!\n+}\n+```\n+\"##,\n+\n E0511: r##\"\n Invalid monomorphization of an intrinsic function was used. Erroneous code\n example:"}, {"sha": "bd24647edf00b4b0f349c7e60f90bbab479a2dbe", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -617,6 +617,18 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n         },\n \n+\n+        (_, \"return_address\") => {\n+            if !fcx.fn_ty.ret.is_indirect() {\n+                span_err!(tcx.sess, span, E0510,\n+                          \"invalid use of `return_address` intrinsic: function \\\n+                           does not use out pointer\");\n+                C_null(Type::i8p(ccx))\n+            } else {\n+                PointerCast(bcx, llvm::get_param(fcx.llfn, 0), Type::i8p(ccx))\n+            }\n+        }\n+\n         (_, \"discriminant_value\") => {\n             let val_ty = substs.types.get(FnSpace, 0);\n             match val_ty.sty {"}, {"sha": "9cb5d8b6ad62a2e43781bb64b3b7806f5fabe425", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -28,7 +28,6 @@\n #![feature(const_fn)]\n #![feature(custom_attribute)]\n #![allow(unused_attributes)]\n-#![feature(iter_arith)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "c3f2c4f2c8bfe5bf333550dbadc1ff6687690620", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -572,11 +572,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         // will only succeed if both operands are constant.\n         // This is necessary to determine when an overflow Assert\n         // will always panic at runtime, and produce a warning.\n-        match const_scalar_checked_binop(bcx.tcx(), op, lhs, rhs, input_ty) {\n-            Some((val, of)) => {\n-                return OperandValue::Pair(val, C_bool(bcx.ccx(), of));\n-            }\n-            None => {}\n+        if let Some((val, of)) = const_scalar_checked_binop(bcx.tcx(), op, lhs, rhs, input_ty) {\n+            return OperandValue::Pair(val, C_bool(bcx.ccx(), of));\n         }\n \n         let (val, of) = match op {"}, {"sha": "ab859b88a85972d55200ba32260199974fa94422", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -169,8 +169,7 @@ pub struct Instance<'tcx> {\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ppaux::parameterized(f, &self.substs, self.def, ppaux::Ns::Value, &[],\n-                             |tcx| Some(tcx.lookup_item_type(self.def).generics))\n+        ppaux::parameterized(f, &self.substs, self.def, ppaux::Ns::Value, &[], |_| None)\n     }\n }\n "}, {"sha": "0fb08ec9855de006bebaa15071f41af6dc453d43", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -275,6 +275,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" =>\n                 (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n \n+            \"return_address\" => (0, vec![], tcx.mk_imm_ptr(tcx.types.u8)),\n+\n             \"assume\" => (0, vec![tcx.types.bool], tcx.mk_nil()),\n \n             \"discriminant_value\" => (1, vec!["}, {"sha": "6a1baf13b273d4f2bda0c4f4c3d4cf1b688ca38c", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -864,9 +864,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     // THE ACTUAL SEARCH\n \n     fn pick(mut self) -> PickResult<'tcx> {\n-        match self.pick_core() {\n-            Some(r) => return r,\n-            None => {}\n+        if let Some(r) = self.pick_core() {\n+            return r;\n         }\n \n         let static_candidates = mem::replace(&mut self.static_candidates, vec![]);\n@@ -929,9 +928,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n-        match self.pick_by_value_method(step) {\n-            Some(result) => return Some(result),\n-            None => {}\n+        if let Some(result) = self.pick_by_value_method(step) {\n+            return Some(result);\n         }\n \n         self.pick_autorefd_method(step)\n@@ -1003,12 +1001,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let mut possibly_unsatisfied_predicates = Vec::new();\n \n         debug!(\"searching inherent candidates\");\n-        match self.consider_candidates(self_ty, &self.inherent_candidates,\n-                                       &mut possibly_unsatisfied_predicates) {\n-            None => {}\n-            Some(pick) => {\n-                return Some(pick);\n-            }\n+        if let Some(pick) = self.consider_candidates(self_ty,\n+                                                     &self.inherent_candidates,\n+                                                     &mut possibly_unsatisfied_predicates) {\n+            return Some(pick);\n         }\n \n         debug!(\"searching extension candidates\");"}, {"sha": "3bc90f05d2536c2f41ebcef9a45dcfc4bc2a5a29", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1157,6 +1157,7 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         let rty = ccx.tcx.node_id_to_type(id);\n         let fcx = FnCtxt::new(&inh, ty::FnConverging(rty), e.id);\n         let declty = fcx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n+        fcx.require_type_is_sized(declty, e.span, traits::ConstSized);\n         fcx.check_const_with_ty(sp, e, declty);\n     });\n }"}, {"sha": "9786132dc537b53c57c0a4b47abde6fe863536ac", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -334,13 +334,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         };\n \n         //NB(jroesch): We need to match twice to avoid a double borrow which would cause an ICE\n-        match new_method {\n-            Some(method) => {\n-                self.tcx().tables.borrow_mut().method_map.insert(\n-                    method_call,\n-                    method);\n-            }\n-            None => {}\n+        if let Some(method) = new_method {\n+            self.tcx().tables.borrow_mut().method_map.insert(method_call, method);\n         }\n     }\n "}, {"sha": "198e9afd5e12c77f1604d753ba612ba8414ad38c", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -174,12 +174,9 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        match self.inherent_impls.borrow().get(&base_def_id) {\n-            Some(implementation_list) => {\n-                implementation_list.borrow_mut().push(impl_def_id);\n-                return;\n-            }\n-            None => {}\n+        if let Some(implementation_list) = self.inherent_impls.borrow().get(&base_def_id) {\n+            implementation_list.borrow_mut().push(impl_def_id);\n+            return;\n         }\n \n         self.inherent_impls.borrow_mut().insert("}, {"sha": "84452589dfda389a9bc7e708c55dc16f9f497e9f", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -76,7 +76,6 @@ This API is completely unstable and subject to change.\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(iter_arith)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -313,14 +312,13 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n fn check_for_entry_fn(ccx: &CrateCtxt) {\n     let tcx = ccx.tcx;\n     let _task = tcx.dep_graph.in_task(DepNode::CheckEntryFn);\n-    match *tcx.sess.entry_fn.borrow() {\n-        Some((id, sp)) => match tcx.sess.entry_type.get() {\n+    if let Some((id, sp)) = *tcx.sess.entry_fn.borrow() {\n+        match tcx.sess.entry_type.get() {\n             Some(config::EntryMain) => check_main_fn_ty(ccx, id, sp),\n             Some(config::EntryStart) => check_start_fn_ty(ccx, id, sp),\n             Some(config::EntryNone) => {}\n             None => bug!(\"entry function without a type\")\n-        },\n-        None => {}\n+        }\n     }\n }\n "}, {"sha": "85ea94e02e8d794014a13263b2d9db970337abe6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -149,9 +149,9 @@ pub fn run_core(search_paths: SearchPaths,\n     let name = link::find_crate_name(Some(&sess), &krate.attrs, &input);\n \n     let driver::ExpansionResult { defs, analysis, resolutions, mut hir_forest, .. } = {\n-        let make_glob_map = resolve::MakeGlobMap::No;\n-        driver::phase_2_configure_and_expand(&sess, &cstore, krate, &name, None, make_glob_map)\n-            .expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n+        driver::phase_2_configure_and_expand(\n+            &sess, &cstore, krate, &name, None, resolve::MakeGlobMap::No, |_| Ok(()),\n+        ).expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n     };\n \n     let arenas = ty::CtxtArenas::new();"}, {"sha": "77c4a0f8174a3296d00a2a94a480d912375cead7", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -131,9 +131,8 @@ impl fmt::Display for clean::Generics {\n                     write!(f, \":&nbsp;{}\", TyParamBounds(&tp.bounds))?;\n                 }\n \n-                match tp.default {\n-                    Some(ref ty) => { write!(f, \"&nbsp;=&nbsp;{}\", ty)?; },\n-                    None => {}\n+                if let Some(ref ty) = tp.default {\n+                    write!(f, \"&nbsp;=&nbsp;{}\", ty)?;\n                 };\n             }\n         }\n@@ -401,15 +400,12 @@ fn primitive_link(f: &mut fmt::Formatter,\n                 }\n                 (_, render::Unknown) => None,\n             };\n-            match loc {\n-                Some(root) => {\n-                    write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\",\n-                           root,\n-                           path.0.first().unwrap(),\n-                           prim.to_url_str())?;\n-                    needs_termination = true;\n-                }\n-                None => {}\n+            if let Some(root) = loc {\n+                write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\",\n+                       root,\n+                       path.0.first().unwrap(),\n+                       prim.to_url_str())?;\n+                needs_termination = true;\n             }\n         }\n         None => {}"}, {"sha": "84e98a6739193e9b917135c3b218e00cb15bd08f", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -352,9 +352,8 @@ fn write_header(class: Option<&str>,\n                 out: &mut Write)\n                 -> io::Result<()> {\n     write!(out, \"<pre \")?;\n-    match id {\n-        Some(id) => write!(out, \"id='{}' \", id)?,\n-        None => {}\n+    if let Some(id) = id {\n+        write!(out, \"id='{}' \", id)?;\n     }\n     write!(out, \"class='rust {}'>\\n\", class.unwrap_or(\"\"))\n }"}, {"sha": "acf867561a6370aa6084c3426f6497071dd7118b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -589,19 +589,16 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     // Attach all orphan methods to the type's definition if the type\n     // has since been learned.\n     for &(did, ref item) in orphan_methods {\n-        match paths.get(&did) {\n-            Some(&(ref fqp, _)) => {\n-                search_index.push(IndexItem {\n-                    ty: shortty(item),\n-                    name: item.name.clone().unwrap(),\n-                    path: fqp[..fqp.len() - 1].join(\"::\"),\n-                    desc: Escape(&shorter(item.doc_value())).to_string(),\n-                    parent: Some(did),\n-                    parent_idx: None,\n-                    search_type: get_index_search_type(&item),\n-                });\n-            },\n-            None => {}\n+        if let Some(&(ref fqp, _)) = paths.get(&did) {\n+            search_index.push(IndexItem {\n+                ty: shortty(item),\n+                name: item.name.clone().unwrap(),\n+                path: fqp[..fqp.len() - 1].join(\"::\"),\n+                desc: Escape(&shorter(item.doc_value())).to_string(),\n+                parent: Some(did),\n+                parent_idx: None,\n+                search_type: get_index_search_type(&item),\n+            });\n         }\n     }\n \n@@ -2093,15 +2090,12 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         <h2 id='implementors'>Implementors</h2>\n         <ul class='item-list' id='implementors-list'>\n     \")?;\n-    match cache.implementors.get(&it.def_id) {\n-        Some(implementors) => {\n-            for i in implementors {\n-                write!(w, \"<li><code>\")?;\n-                fmt_impl_for_trait_page(&i.impl_, w)?;\n-                writeln!(w, \"</code></li>\")?;\n-            }\n+    if let Some(implementors) = cache.implementors.get(&it.def_id) {\n+        for i in implementors {\n+            write!(w, \"<li><code>\")?;\n+            fmt_impl_for_trait_page(&i.impl_, w)?;\n+            writeln!(w, \"</code></li>\")?;\n         }\n-        None => {}\n     }\n     write!(w, \"</ul>\")?;\n     write!(w, r#\"<script type=\"text/javascript\" async"}, {"sha": "e3bc8037d13b67b0395baeb7560bb6b964a8c283", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -95,9 +95,9 @@ pub fn run(input: &str,\n     cfg.extend(config::parse_cfgspecs(cfgs.clone()));\n     let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, &input));\n     let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n-        let make_glob_map = MakeGlobMap::No;\n-        phase_2_configure_and_expand(&sess, &cstore, krate, \"rustdoc-test\", None, make_glob_map)\n-            .expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n+        phase_2_configure_and_expand(\n+            &sess, &cstore, krate, \"rustdoc-test\", None, MakeGlobMap::No, |_| Ok(())\n+        ).expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n     };\n \n     let dep_graph = DepGraph::new(false);"}, {"sha": "6c4b6c4506b814fd7d19b5575841b6703ef54f52", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1764,9 +1764,8 @@ impl<T: Iterator<Item=char>> Parser<T> {\n                     return self.parse_array(first);\n                 }\n                 ParseArrayComma => {\n-                    match self.parse_array_comma_or_end() {\n-                        Some(evt) => { return evt; }\n-                        None => {}\n+                    if let Some(evt) = self.parse_array_comma_or_end() {\n+                        return evt;\n                     }\n                 }\n                 ParseObject(first) => {\n@@ -2583,9 +2582,8 @@ impl<'a, T: Encodable> fmt::Display for AsPrettyJson<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = PrettyEncoder::new(&mut shim);\n-        match self.indent {\n-            Some(n) => encoder.set_indent(n),\n-            None => {}\n+        if let Some(n) = self.indent {\n+            encoder.set_indent(n);\n         }\n         match self.inner.encode(&mut encoder) {\n             Ok(_) => Ok(()),"}, {"sha": "7a676c041ad89084e72b2ea5325923f0e0fabf4b", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -110,13 +110,15 @@ mod cmath {\n         }\n \n         #[inline]\n+        #[allow(deprecated)]\n         pub unsafe fn frexpf(x: c_float, value: &mut c_int) -> c_float {\n             let (a, b) = f64::frexp(x as f64);\n             *value = b as c_int;\n             a as c_float\n         }\n \n         #[inline]\n+        #[allow(deprecated)]\n         pub unsafe fn ldexpf(x: c_float, n: c_int) -> c_float {\n             f64::ldexp(x as f64, n as isize) as c_float\n         }\n@@ -265,7 +267,11 @@ impl f32 {\n     /// [floating-point]: ../reference.html#machine-types\n     #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n+    #[allow(deprecated)]\n     pub fn integer_decode(self) -> (u64, i16, i8) {\n         num::Float::integer_decode(self)\n     }\n@@ -718,6 +724,9 @@ impl f32 {\n     #[unstable(feature = \"float_extras\",\n                reason = \"pending integer conventions\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n     pub fn ldexp(x: f32, exp: isize) -> f32 {\n         unsafe { cmath::ldexpf(x, exp as c_int) }\n@@ -747,6 +756,9 @@ impl f32 {\n     #[unstable(feature = \"float_extras\",\n                reason = \"pending integer conventions\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n     pub fn frexp(self) -> (f32, isize) {\n         unsafe {\n@@ -773,6 +785,9 @@ impl f32 {\n     #[unstable(feature = \"float_extras\",\n                reason = \"unsure about its place in the world\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n     pub fn next_after(self, other: f32) -> f32 {\n         unsafe { cmath::nextafterf(self, other) }\n@@ -1384,6 +1399,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_integer_decode() {\n         assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n         assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n@@ -1711,6 +1727,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_ldexp() {\n         let f1 = 2.0f32.powi(-123);\n         let f2 = 2.0f32.powi(-111);\n@@ -1731,6 +1748,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_frexp() {\n         let f1 = 2.0f32.powi(-123);\n         let f2 = 2.0f32.powi(-111);\n@@ -1750,6 +1768,7 @@ mod tests {\n     }\n \n     #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n+    #[allow(deprecated)]\n     fn test_frexp_nowin() {\n         let inf: f32 = f32::INFINITY;\n         let neg_inf: f32 = f32::NEG_INFINITY;"}, {"sha": "67a1c302483d20644bdd157def4bed445c47e6fa", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -209,7 +209,11 @@ impl f64 {\n     /// [floating-point]: ../reference.html#machine-types\n     #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n+    #[allow(deprecated)]\n     pub fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n \n     /// Returns the largest integer less than or equal to a number.\n@@ -613,6 +617,9 @@ impl f64 {\n     #[unstable(feature = \"float_extras\",\n                reason = \"pending integer conventions\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n     pub fn ldexp(x: f64, exp: isize) -> f64 {\n         unsafe { cmath::ldexp(x, exp as c_int) }\n@@ -640,6 +647,9 @@ impl f64 {\n     #[unstable(feature = \"float_extras\",\n                reason = \"pending integer conventions\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n     pub fn frexp(self) -> (f64, isize) {\n         unsafe {\n@@ -664,6 +674,9 @@ impl f64 {\n     #[unstable(feature = \"float_extras\",\n                reason = \"unsure about its place in the world\",\n                issue = \"27752\")]\n+    #[rustc_deprecated(since = \"1.11.0\",\n+                       reason = \"never really came to fruition and easily \\\n+                                 implementable outside the standard library\")]\n     #[inline]\n     pub fn next_after(self, other: f64) -> f64 {\n         unsafe { cmath::nextafter(self, other) }\n@@ -1277,6 +1290,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_integer_decode() {\n         assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n         assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n@@ -1604,6 +1618,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_ldexp() {\n         let f1 = 2.0f64.powi(-123);\n         let f2 = 2.0f64.powi(-111);\n@@ -1624,6 +1639,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_frexp() {\n         let f1 = 2.0f64.powi(-123);\n         let f2 = 2.0f64.powi(-111);\n@@ -1643,6 +1659,7 @@ mod tests {\n     }\n \n     #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n+    #[allow(deprecated)]\n     fn test_frexp_nowin() {\n         let inf: f64 = INFINITY;\n         let neg_inf: f64 = NEG_INFINITY;"}, {"sha": "20804d62dfab663401f07293496b3c4d1066973d", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -17,6 +17,7 @@\n #![allow(missing_docs)]\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub use core::num::{Zero, One};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::num::{FpCategory, ParseIntError, ParseFloatError, TryFromIntError};\n@@ -46,7 +47,6 @@ pub fn test_num<T>(ten: T, two: T) where\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n     use u8;\n     use u16;\n     use u32;\n@@ -198,15 +198,14 @@ mod tests {\n \n     #[test]\n     fn test_pow() {\n-        fn naive_pow<T: Mul<Output=T> + One + Copy>(base: T, exp: usize) -> T {\n-            let one: T = T::one();\n+        fn naive_pow<T: Mul<Output=T> + Copy>(one: T, base: T, exp: usize) -> T {\n             (0..exp).fold(one, |acc, _| acc * base)\n         }\n         macro_rules! assert_pow {\n             (($num:expr, $exp:expr) => $expected:expr) => {{\n                 let result = $num.pow($exp);\n                 assert_eq!(result, $expected);\n-                assert_eq!(result, naive_pow($num, $exp));\n+                assert_eq!(result, naive_pow(1, $num, $exp));\n             }}\n         }\n         assert_pow!((3u32,     0 ) => 1);"}, {"sha": "ad4cdef615847719d2f63ff078b8f36346a302e9", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1057,7 +1057,6 @@ impl PathBuf {\n         self._push(path.as_ref())\n     }\n \n-    #[allow(deprecated)]\n     fn _push(&mut self, path: &Path) {\n         // in general, a separator is needed if the rightmost byte is not a separator\n         let mut need_sep = self.as_mut_vec().last().map(|c| !is_sep_byte(*c)).unwrap_or(false);\n@@ -1443,8 +1442,7 @@ impl Path {\n     /// `is_absolute` and `has_root` are equivalent.\n     ///\n     /// * On Windows, a path is absolute if it has a prefix and starts with the\n-    /// root: `c:\\windows` is absolute, while `c:temp` and `\\temp` are not. In\n-    /// other words, `path.is_absolute() == path.prefix().is_some() && path.has_root()`.\n+    /// root: `c:\\windows` is absolute, while `c:temp` and `\\temp` are not.\n     ///\n     /// # Examples\n     ///"}, {"sha": "f0fd42fc99b806eadba0b261ddefe2ca61872980", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -12,8 +12,6 @@\n \n use io::{self, ErrorKind};\n use libc;\n-use num::One;\n-use ops::Neg;\n \n #[cfg(target_os = \"android\")]   pub use os::android as platform;\n #[cfg(target_os = \"bitrig\")]    pub use os::bitrig as platform;\n@@ -123,17 +121,32 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     }\n }\n \n-pub fn cvt<T: One + PartialEq + Neg<Output=T>>(t: T) -> io::Result<T> {\n-    let one: T = T::one();\n-    if t == -one {\n+#[doc(hidden)]\n+pub trait IsMinusOne {\n+    fn is_minus_one(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_minus_one {\n+    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n+        fn is_minus_one(&self) -> bool {\n+            *self == -1\n+        }\n+    })*)\n+}\n+\n+impl_is_minus_one! { i8 i16 i32 i64 isize }\n+\n+pub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n+    if t.is_minus_one() {\n         Err(io::Error::last_os_error())\n     } else {\n         Ok(t)\n     }\n }\n \n pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n-    where T: One + PartialEq + Neg<Output=T>, F: FnMut() -> T\n+    where T: IsMinusOne,\n+          F: FnMut() -> T\n {\n     loop {\n         match cvt(f()) {"}, {"sha": "12219c1e9d42bf750717bdb1c8f16b169c17d1e7", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -14,7 +14,6 @@ use prelude::v1::*;\n \n use ffi::{OsStr, OsString};\n use io::{self, ErrorKind};\n-use num::Zero;\n use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n use time::Duration;\n@@ -178,8 +177,22 @@ pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     }\n }\n \n-fn cvt<I: PartialEq + Zero>(i: I) -> io::Result<I> {\n-    if i == I::zero() {\n+trait IsZero {\n+    fn is_zero(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_zero {\n+    ($($t:ident)*) => ($(impl IsZero for $t {\n+        fn is_zero(&self) -> bool {\n+            *self == 0\n+        }\n+    })*)\n+}\n+\n+impl_is_zero! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n+fn cvt<I: IsZero>(i: I) -> io::Result<I> {\n+    if i.is_zero() {\n         Err(io::Error::last_os_error())\n     } else {\n         Ok(i)"}, {"sha": "71e164f012f1f7c4dfe9cba2ef212660414da296", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -17,8 +17,6 @@ use io::{self, Read};\n use libc::{c_int, c_void, c_ulong};\n use mem;\n use net::{SocketAddr, Shutdown};\n-use num::One;\n-use ops::Neg;\n use ptr;\n use sync::Once;\n use sys::c;\n@@ -60,11 +58,26 @@ fn last_error() -> io::Error {\n     io::Error::from_raw_os_error(unsafe { c::WSAGetLastError() })\n }\n \n+#[doc(hidden)]\n+pub trait IsMinusOne {\n+    fn is_minus_one(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_minus_one {\n+    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n+        fn is_minus_one(&self) -> bool {\n+            *self == -1\n+        }\n+    })*)\n+}\n+\n+impl_is_minus_one! { i8 i16 i32 i64 isize }\n+\n /// Checks if the signed integer is the Windows constant `SOCKET_ERROR` (-1)\n /// and if so, returns the last error from the Windows socket interface. This\n /// function must be called before another call to the socket API is made.\n-pub fn cvt<T: One + PartialEq + Neg<Output=T>>(t: T) -> io::Result<T> {\n-    if t == -T::one() {\n+pub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n+    if t.is_minus_one() {\n         Err(last_error())\n     } else {\n         Ok(t)\n@@ -82,7 +95,8 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n \n /// Just to provide the same interface as sys/unix/net.rs\n pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n-    where T: One + PartialEq + Neg<Output=T>, F: FnMut() -> T\n+    where T: IsMinusOne,\n+          F: FnMut() -> T\n {\n     cvt(f())\n }"}, {"sha": "e01bd2a93aacdfcb9b806a0af3e5960fdff47d12", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 65, "deletions": 40, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -34,6 +34,27 @@ thread_local! {\n     static USED_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new())\n }\n \n+enum AttrError {\n+    MultipleItem(InternedString),\n+    UnknownMetaItem(InternedString),\n+    MissingSince,\n+    MissingFeature,\n+    MultipleStabilityLevels,\n+}\n+\n+fn handle_errors(diag: &Handler, span: Span, error: AttrError) {\n+    match error {\n+        AttrError::MultipleItem(item) => span_err!(diag, span, E0538,\n+                                                   \"multiple '{}' items\", item),\n+        AttrError::UnknownMetaItem(item) => span_err!(diag, span, E0541,\n+                                                      \"unknown meta item '{}'\", item),\n+        AttrError::MissingSince => span_err!(diag, span, E0542, \"missing 'since'\"),\n+        AttrError::MissingFeature => span_err!(diag, span, E0546, \"missing 'feature'\"),\n+        AttrError::MultipleStabilityLevels => span_err!(diag, span, E0544,\n+                                                        \"multiple stability levels\"),\n+    }\n+}\n+\n pub fn mark_used(attr: &Attribute) {\n     let AttrId(id) = attr.node.id;\n     USED_ATTRS.with(|slot| {\n@@ -303,10 +324,10 @@ pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<Inte\n             if let s@Some(_) = attr.value_str() {\n                 s\n             } else {\n-                diag.struct_span_err(attr.span,\n-                                     \"export_name attribute has invalid format\")\n-                    .help(\"use #[export_name=\\\"*\\\"]\")\n-                    .emit();\n+                struct_span_err!(diag, attr.span, E0533,\n+                                 \"export_name attribute has invalid format\")\n+                                .help(\"use #[export_name=\\\"*\\\"]\")\n+                                .emit();\n                 None\n             }\n         } else {\n@@ -339,14 +360,16 @@ pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> In\n             MetaItemKind::List(ref n, ref items) if n == \"inline\" => {\n                 mark_used(attr);\n                 if items.len() != 1 {\n-                    diagnostic.map(|d|{ d.span_err(attr.span, \"expected one argument\"); });\n+                    diagnostic.map(|d|{ span_err!(d, attr.span, E0534, \"expected one argument\"); });\n                     InlineAttr::None\n                 } else if contains_name(&items[..], \"always\") {\n                     InlineAttr::Always\n                 } else if contains_name(&items[..], \"never\") {\n                     InlineAttr::Never\n                 } else {\n-                    diagnostic.map(|d|{ d.span_err((*items[0]).span, \"invalid argument\"); });\n+                    diagnostic.map(|d| {\n+                        span_err!(d, (*items[0]).span, E0535, \"invalid argument\");\n+                    });\n                     InlineAttr::None\n                 }\n             }\n@@ -374,13 +397,13 @@ pub fn cfg_matches(cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n             mis.iter().all(|mi| cfg_matches(cfgs, &mi, sess, features)),\n         ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"not\" => {\n             if mis.len() != 1 {\n-                sess.span_diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n+                span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n                 return false;\n             }\n             !cfg_matches(cfgs, &mis[0], sess, features)\n         }\n         ast::MetaItemKind::List(ref pred, _) => {\n-            sess.span_diagnostic.span_err(cfg.span, &format!(\"invalid predicate `{}`\", pred));\n+            span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", pred);\n             false\n         },\n         ast::MetaItemKind::Word(_) | ast::MetaItemKind::NameValue(..) => {\n@@ -446,23 +469,23 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n         if let Some(metas) = attr.meta_item_list() {\n             let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n                 if item.is_some() {\n-                    diagnostic.span_err(meta.span, &format!(\"multiple '{}' items\",\n-                                                             meta.name()));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n                     *item = Some(v);\n                     true\n                 } else {\n-                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                    span_err!(diagnostic, meta.span, E0539, \"incorrect meta item\");\n                     false\n                 }\n             };\n \n             match tag {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n-                        diagnostic.span_err(item_sp, \"multiple rustc_deprecated attributes\");\n+                        span_err!(diagnostic, item_sp, E0540,\n+                                  \"multiple rustc_deprecated attributes\");\n                         break\n                     }\n \n@@ -473,8 +496,8 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             \"since\" => if !get(meta, &mut since) { continue 'outer },\n                             \"reason\" => if !get(meta, &mut reason) { continue 'outer },\n                             _ => {\n-                                diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n-                                                                        meta.name()));\n+                                handle_errors(diagnostic, meta.span,\n+                                              AttrError::UnknownMetaItem(meta.name()));\n                                 continue 'outer\n                             }\n                         }\n@@ -488,18 +511,18 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             })\n                         }\n                         (None, _) => {\n-                            diagnostic.span_err(attr.span(), \"missing 'since'\");\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince);\n                             continue\n                         }\n                         _ => {\n-                            diagnostic.span_err(attr.span(), \"missing 'reason'\");\n+                            span_err!(diagnostic, attr.span(), E0543, \"missing 'reason'\");\n                             continue\n                         }\n                     }\n                 }\n                 \"unstable\" => {\n                     if stab.is_some() {\n-                        diagnostic.span_err(item_sp, \"multiple stability levels\");\n+                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels);\n                         break\n                     }\n \n@@ -512,8 +535,8 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             \"reason\" => if !get(meta, &mut reason) { continue 'outer },\n                             \"issue\" => if !get(meta, &mut issue) { continue 'outer },\n                             _ => {\n-                                diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n-                                                                        meta.name()));\n+                                handle_errors(diagnostic, meta.span,\n+                                              AttrError::UnknownMetaItem(meta.name()));\n                                 continue 'outer\n                             }\n                         }\n@@ -528,7 +551,8 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                         if let Ok(issue) = issue.parse() {\n                                             issue\n                                         } else {\n-                                            diagnostic.span_err(attr.span(), \"incorrect 'issue'\");\n+                                            span_err!(diagnostic, attr.span(), E0545,\n+                                                      \"incorrect 'issue'\");\n                                             continue\n                                         }\n                                     }\n@@ -538,18 +562,18 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             })\n                         }\n                         (None, _, _) => {\n-                            diagnostic.span_err(attr.span(), \"missing 'feature'\");\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature);\n                             continue\n                         }\n                         _ => {\n-                            diagnostic.span_err(attr.span(), \"missing 'issue'\");\n+                            span_err!(diagnostic, attr.span(), E0547, \"missing 'issue'\");\n                             continue\n                         }\n                     }\n                 }\n                 \"stable\" => {\n                     if stab.is_some() {\n-                        diagnostic.span_err(item_sp, \"multiple stability levels\");\n+                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels);\n                         break\n                     }\n \n@@ -560,8 +584,8 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             \"feature\" => if !get(meta, &mut feature) { continue 'outer },\n                             \"since\" => if !get(meta, &mut since) { continue 'outer },\n                             _ => {\n-                                diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n-                                                                        meta.name()));\n+                                handle_errors(diagnostic, meta.span,\n+                                              AttrError::UnknownMetaItem(meta.name()));\n                                 continue 'outer\n                             }\n                         }\n@@ -578,19 +602,19 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             })\n                         }\n                         (None, _) => {\n-                            diagnostic.span_err(attr.span(), \"missing 'feature'\");\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature);\n                             continue\n                         }\n                         _ => {\n-                            diagnostic.span_err(attr.span(), \"missing 'since'\");\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince);\n                             continue\n                         }\n                     }\n                 }\n                 _ => unreachable!()\n             }\n         } else {\n-            diagnostic.span_err(attr.span(), \"incorrect stability attribute type\");\n+            span_err!(diagnostic, attr.span(), E0548, \"incorrect stability attribute type\");\n             continue\n         }\n     }\n@@ -603,8 +627,9 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n             }\n             stab.rustc_depr = Some(rustc_depr);\n         } else {\n-            diagnostic.span_err(item_sp, \"rustc_deprecated attribute must be paired with \\\n-                                          either stable or unstable attribute\");\n+            span_err!(diagnostic, item_sp, E0549,\n+                      \"rustc_deprecated attribute must be paired with \\\n+                       either stable or unstable attribute\");\n         }\n     }\n \n@@ -627,22 +652,21 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n         mark_used(attr);\n \n         if depr.is_some() {\n-            diagnostic.span_err(item_sp, \"multiple deprecated attributes\");\n+            span_err!(diagnostic, item_sp, E0550, \"multiple deprecated attributes\");\n             break\n         }\n \n         depr = if let Some(metas) = attr.meta_item_list() {\n             let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n                 if item.is_some() {\n-                    diagnostic.span_err(meta.span, &format!(\"multiple '{}' items\",\n-                                                             meta.name()));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n                     *item = Some(v);\n                     true\n                 } else {\n-                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                    span_err!(diagnostic, meta.span, E0551, \"incorrect meta item\");\n                     false\n                 }\n             };\n@@ -654,8 +678,8 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n                     \"since\" => if !get(meta, &mut since) { continue 'outer },\n                     \"note\" => if !get(meta, &mut note) { continue 'outer },\n                     _ => {\n-                        diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n-                                                                meta.name()));\n+                        handle_errors(diagnostic, meta.span,\n+                                      AttrError::UnknownMetaItem(meta.name()));\n                         continue 'outer\n                     }\n                 }\n@@ -689,7 +713,7 @@ pub fn require_unique_names(diagnostic: &Handler, metas: &[P<MetaItem>]) {\n \n         if !set.insert(name.clone()) {\n             panic!(diagnostic.span_fatal(meta.span,\n-                                  &format!(\"duplicate meta item `{}`\", name)));\n+                                         &format!(\"duplicate meta item `{}`\", name)));\n         }\n     }\n }\n@@ -718,8 +742,8 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                                 Some(ity) => Some(ReprInt(item.span, ity)),\n                                 None => {\n                                     // Not a word we recognize\n-                                    diagnostic.span_err(item.span,\n-                                                        \"unrecognized representation hint\");\n+                                    span_err!(diagnostic, item.span, E0552,\n+                                              \"unrecognized representation hint\");\n                                     None\n                                 }\n                             }\n@@ -731,7 +755,8 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                         }\n                     }\n                     // Not a word:\n-                    _ => diagnostic.span_err(item.span, \"unrecognized enum representation hint\")\n+                    _ => span_err!(diagnostic, item.span, E0553,\n+                                   \"unrecognized enum representation hint\"),\n                 }\n             }\n         }"}, {"sha": "eb30657bd56ead7a804b8fd7b22c9c10fe6051ed", "filename": "src/libsyntax/diagnostic_list.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+// Error messages for EXXXX errors.\n+// Each message should start and end with a new line, and be wrapped to 80 characters.\n+// In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n+register_long_diagnostics! {\n+\n+E0533: r##\"\n+```compile_fail,E0533\n+#[export_name]\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\"##,\n+\n+}\n+\n+register_diagnostics! {\n+    E0534, // expected one argument\n+    E0535, // invalid argument\n+    E0536, // expected 1 cfg-pattern\n+    E0537, // invalid predicate\n+    E0538, // multiple [same] items\n+    E0539, // incorrect meta item\n+    E0540, // multiple rustc_deprecated attributes\n+    E0541, // unknown meta item\n+    E0542, // missing 'since'\n+    E0543, // missing 'reason'\n+    E0544, // multiple stability levels\n+    E0545, // incorrect 'issue'\n+    E0546, // missing 'feature'\n+    E0547, // missing 'issue'\n+    E0548, // incorrect stability attribute type\n+    E0549, // rustc_deprecated attribute must be paired with either stable or unstable attribute\n+    E0550, // multiple deprecated attributes\n+    E0551, // incorrect meta item\n+    E0552, // unrecognized representation hint\n+    E0553, // unrecognized enum representation hint\n+    E0554, // #[feature] may not be used on the [] release channel\n+    E0555, // malformed feature attribute, expected #![feature(...)]\n+    E0556, // malformed feature, expected just one word\n+    E0557, // feature has been removed\n+}"}, {"sha": "92670cd9def9015cc14d76809f3ba0f93e560046", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -944,9 +944,8 @@ impl SyntaxEnv {\n \n     pub fn find(&self, k: Name) -> Option<Rc<SyntaxExtension>> {\n         for frame in self.chain.iter().rev() {\n-            match frame.map.get(&k) {\n-                Some(v) => return Some(v.clone()),\n-                None => {}\n+            if let Some(v) = frame.map.get(&k) {\n+                return Some(v.clone());\n             }\n         }\n         None"}, {"sha": "40944a9a1c2d360bf13c78a9b1a45d742f2fb998", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -225,12 +225,9 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n         } else { /* repeat */\n             *r.repeat_idx.last_mut().unwrap() += 1;\n             r.stack.last_mut().unwrap().idx = 0;\n-            match r.stack.last().unwrap().sep.clone() {\n-                Some(tk) => {\n-                    r.cur_tok = tk; /* repeat same span, I guess */\n-                    return ret_val;\n-                }\n-                None => {}\n+            if let Some(tk) = r.stack.last().unwrap().sep.clone() {\n+                r.cur_tok = tk; // repeat same span, I guess\n+                return ret_val;\n             }\n         }\n     }"}, {"sha": "27485ee65fcc037640e5309d2534d583e47e91da", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1103,17 +1103,16 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n \n         match attr.meta_item_list() {\n             None => {\n-                span_handler.span_err(attr.span, \"malformed feature attribute, \\\n-                                                  expected #![feature(...)]\");\n+                span_err!(span_handler, attr.span, E0555,\n+                          \"malformed feature attribute, expected #![feature(...)]\");\n             }\n             Some(list) => {\n                 for mi in list {\n                     let name = match mi.node {\n                         ast::MetaItemKind::Word(ref word) => (*word).clone(),\n                         _ => {\n-                            span_handler.span_err(mi.span,\n-                                                  \"malformed feature, expected just \\\n-                                                   one word\");\n+                            span_err!(span_handler, mi.span, E0556,\n+                                      \"malformed feature, expected just one word\");\n                             continue\n                         }\n                     };\n@@ -1123,7 +1122,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n                     }\n                     else if let Some(&(_, _, _)) = REMOVED_FEATURES.iter()\n                         .find(|& &(n, _, _)| name == n) {\n-                        span_handler.span_err(mi.span, \"feature has been removed\");\n+                        span_err!(span_handler, mi.span, E0557, \"feature has been removed\");\n                     }\n                     else if let Some(&(_, _, _)) = ACCEPTED_FEATURES.iter()\n                         .find(|& &(n, _, _)| name == n) {\n@@ -1179,9 +1178,9 @@ fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate,\n         for attr in &krate.attrs {\n             if attr.check_name(\"feature\") {\n                 let release_channel = option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\");\n-                let ref msg = format!(\"#[feature] may not be used on the {} release channel\",\n-                                      release_channel);\n-                span_handler.span_err(attr.span, msg);\n+                span_err!(span_handler, attr.span, E0554,\n+                          \"#[feature] may not be used on the {} release channel\",\n+                          release_channel);\n             }\n         }\n     }"}, {"sha": "8febf1c49ec2badeb618ed632b4c661168da73d4", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -33,6 +33,7 @@\n #![feature(str_escape)]\n #![feature(unicode)]\n #![feature(question_mark)]\n+#![feature(rustc_diagnostic_macros)]\n \n extern crate serialize;\n extern crate term;\n@@ -66,6 +67,18 @@ macro_rules! panictry {\n     })\n }\n \n+#[macro_use]\n+pub mod diagnostics {\n+    #[macro_use]\n+    pub mod macros;\n+    pub mod plugin;\n+    pub mod metadata;\n+}\n+\n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+pub mod diagnostic_list;\n+\n pub mod util {\n     pub mod interner;\n     pub mod lev_distance;\n@@ -80,12 +93,6 @@ pub mod util {\n     pub use self::thin_vec::ThinVec;\n }\n \n-pub mod diagnostics {\n-    pub mod macros;\n-    pub mod plugin;\n-    pub mod metadata;\n-}\n-\n pub mod json;\n \n pub mod syntax {\n@@ -130,3 +137,5 @@ pub mod ext {\n         pub mod macro_rules;\n     }\n }\n+\n+// __build_diagnostic_array! { libsyntax, DIAGNOSTICS }"}, {"sha": "15344cef1dbcf438d157614df5bfd39064462152", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -160,12 +160,9 @@ impl<'a> Parser<'a> {\n             _ => None,\n         };\n \n-        match nt_meta {\n-            Some(meta) => {\n-                self.bump();\n-                return Ok(meta);\n-            }\n-            None => {}\n+        if let Some(meta) = nt_meta {\n+            self.bump();\n+            return Ok(meta);\n         }\n \n         let lo = self.span.lo;"}, {"sha": "77b5c10899a3da8cc158c1003161b44a200d78bf", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -470,15 +470,12 @@ impl<'a> StringReader<'a> {\n     /// PRECONDITION: self.curr is not whitespace\n     /// Eats any kind of comment.\n     fn scan_comment(&mut self) -> Option<TokenAndSpan> {\n-        match self.curr {\n-            Some(c) => {\n-                if c.is_whitespace() {\n-                    self.span_diagnostic.span_err(syntax_pos::mk_sp(self.last_pos, self.last_pos),\n-                                                  \"called consume_any_line_comment, but there \\\n-                                                   was whitespace\");\n-                }\n+        if let Some(c) = self.curr {\n+            if c.is_whitespace() {\n+                self.span_diagnostic.span_err(syntax_pos::mk_sp(self.last_pos, self.last_pos),\n+                                              \"called consume_any_line_comment, but there \\\n+                                               was whitespace\");\n             }\n-            None => {}\n         }\n \n         if self.curr_is('/') {"}, {"sha": "6fa95afd9fb2223c9dec5dc1565cb68a40db4e7f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -2752,9 +2752,8 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        match parse_kleene_op(self)? {\n-            Some(kleene_op) => return Ok((None, kleene_op)),\n-            None => {}\n+        if let Some(kleene_op) = parse_kleene_op(self)? {\n+            return Ok((None, kleene_op));\n         }\n \n         let separator = self.bump_and_get();\n@@ -5691,15 +5690,12 @@ impl<'a> Parser<'a> {\n             }\n             _ => None\n         };\n-        match nt_item {\n-            Some(mut item) => {\n-                self.bump();\n-                let mut attrs = attrs;\n-                mem::swap(&mut item.attrs, &mut attrs);\n-                item.attrs.extend(attrs);\n-                return Ok(Some(P(item)));\n-            }\n-            None => {}\n+        if let Some(mut item) = nt_item {\n+            self.bump();\n+            let mut attrs = attrs;\n+            mem::swap(&mut item.attrs, &mut attrs);\n+            item.attrs.extend(attrs);\n+            return Ok(Some(P(item)));\n         }\n \n         let lo = self.span.lo;"}, {"sha": "ce30c3de7595867490b94ec77281f91d2e1a51fe", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1264,13 +1264,10 @@ impl<'a> State<'a> {\n                     _ => {}\n                 }\n \n-                match *opt_trait {\n-                    Some(ref t) => {\n-                        try!(self.print_trait_ref(t));\n-                        try!(space(&mut self.s));\n-                        try!(self.word_space(\"for\"));\n-                    }\n-                    None => {}\n+                if let Some(ref t) = *opt_trait {\n+                    try!(self.print_trait_ref(t));\n+                    try!(space(&mut self.s));\n+                    try!(self.word_space(\"for\"));\n                 }\n \n                 try!(self.print_type(&ty));\n@@ -1470,11 +1467,8 @@ impl<'a> State<'a> {\n                     try!(self.print_tt(tt_elt));\n                 }\n                 try!(word(&mut self.s, \")\"));\n-                match seq.separator {\n-                    Some(ref tk) => {\n-                        try!(word(&mut self.s, &token_to_string(tk)));\n-                    }\n-                    None => {},\n+                if let Some(ref tk) = seq.separator {\n+                    try!(word(&mut self.s, &token_to_string(tk)));\n                 }\n                 match seq.op {\n                     tokenstream::KleeneOp::ZeroOrMore => word(&mut self.s, \"*\"),"}, {"sha": "f33898109cc57e3110aa40a13b1ac7cfeaefe1da", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -360,13 +360,10 @@ fn find_type_parameters(ty: &ast::Ty, ty_param_names: &[ast::Name], span: Span,\n         fn visit_ty(&mut self, ty: &ast::Ty) {\n             match ty.node {\n                 ast::TyKind::Path(_, ref path) if !path.global => {\n-                    match path.segments.first() {\n-                        Some(segment) => {\n-                            if self.ty_param_names.contains(&segment.identifier.name) {\n-                                self.types.push(P(ty.clone()));\n-                            }\n+                    if let Some(segment) = path.segments.first() {\n+                        if self.ty_param_names.contains(&segment.identifier.name) {\n+                            self.types.push(P(ty.clone()));\n                         }\n-                        None => {}\n                     }\n                 }\n                 _ => {}"}, {"sha": "c6c4b6135c681e1eec0e83b0e05b8679cd006bb4", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -88,12 +88,9 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n         }\n     };\n \n-    match exprs.next() {\n-        None => {}\n-        Some(_) => {\n-            cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n-            return DummyResult::expr(sp);\n-        }\n+    if let Some(_) = exprs.next() {\n+        cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n+        return DummyResult::expr(sp);\n     }\n \n     let e = match env::var(&var[..]) {"}, {"sha": "dc572e652c6713de2597706a78dc074e3014f00d", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -126,16 +126,13 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n \n             panictry!(p.expect(&token::Eq));\n             let e = panictry!(p.parse_expr());\n-            match names.get(name) {\n-                None => {}\n-                Some(prev) => {\n-                    ecx.struct_span_err(e.span,\n-                                        &format!(\"duplicate argument named `{}`\",\n-                                                 name))\n-                       .span_note(prev.span, \"previously here\")\n-                       .emit();\n-                    continue\n-                }\n+            if let Some(prev) = names.get(name) {\n+                ecx.struct_span_err(e.span,\n+                                    &format!(\"duplicate argument named `{}`\",\n+                                             name))\n+                    .span_note(prev.span, \"previously here\")\n+                    .emit();\n+                continue;\n             }\n             order.push(name.to_string());\n             names.insert(name.to_string(), e);\n@@ -665,13 +662,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n             Some(piece) => {\n                 if !parser.errors.is_empty() { break }\n                 cx.verify_piece(&piece);\n-                match cx.trans_piece(&piece) {\n-                    Some(piece) => {\n-                        let s = cx.trans_literal_string();\n-                        cx.str_pieces.push(s);\n-                        cx.pieces.push(piece);\n-                    }\n-                    None => {}\n+                if let Some(piece) = cx.trans_piece(&piece) {\n+                    let s = cx.trans_literal_string();\n+                    cx.str_pieces.push(s);\n+                    cx.pieces.push(piece);\n                 }\n             }\n             None => break"}, {"sha": "c90c93e75acd87f930f76db4dc0fb43691a72132", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -747,12 +747,9 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n             PadOnRight => t.desc.name.as_slice().len(),\n         }\n     }\n-    match tests.iter().max_by_key(|t| len_if_padded(*t)) {\n-        Some(t) => {\n-            let n = t.desc.name.as_slice();\n-            st.max_name_len = n.len();\n-        }\n-        None => {}\n+    if let Some(t) = tests.iter().max_by_key(|t| len_if_padded(*t)) {\n+        let n = t.desc.name.as_slice();\n+        st.max_name_len = n.len();\n     }\n     run_tests(opts, tests, |x| callback(&x, &mut st))?;\n     return st.write_run_finish();"}, {"sha": "c9d1eb39f0a3de464f6028d192e6ad4737ceb1e0", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -213,6 +213,7 @@ dependencies = [\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"serialize 0.0.0\","}, {"sha": "f74855a0849b15ac8698d4fad29c5a1b75c50963", "filename": "src/test/compile-fail/changing-crates.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fchanging-crates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fchanging-crates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchanging-crates.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -17,7 +17,7 @@\n \n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n-//~| NOTE: perhaps this crate needs to be recompiled\n+//~| NOTE: perhaps that crate needs to be recompiled\n //~| NOTE: crate `a` path #1:\n //~| NOTE: crate `b` path #1:\n "}, {"sha": "72a5c5fff608457b2d5770316c4ba62b6a9cf341", "filename": "src/test/compile-fail/const-unsized.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fconst-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fconst-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-unsized.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Debug;\n+\n+const CONST_0: Debug+Sync = *(&0 as &(Debug+Sync));\n+//~^ ERROR `std::fmt::Debug + Sync + 'static: std::marker::Sized` is not satisfied\n+//~| NOTE does not have a constant size known at compile-time\n+//~| NOTE constant expressions must have a statically known size\n+\n+const CONST_FOO: str = *\"foo\";\n+//~^ ERROR `str: std::marker::Sized` is not satisfied\n+//~| NOTE does not have a constant size known at compile-time\n+//~| NOTE constant expressions must have a statically known size\n+\n+static STATIC_1: Debug+Sync = *(&1 as &(Debug+Sync));\n+//~^ ERROR `std::fmt::Debug + Sync + 'static: std::marker::Sized` is not satisfied\n+//~| NOTE does not have a constant size known at compile-time\n+//~| NOTE constant expressions must have a statically known size\n+\n+static STATIC_BAR: str = *\"bar\";\n+//~^ ERROR `str: std::marker::Sized` is not satisfied\n+//~| NOTE does not have a constant size known at compile-time\n+//~| NOTE constant expressions must have a statically known size\n+\n+fn main() {\n+    println!(\"{:?} {:?} {:?} {:?}\", &CONST_0, &CONST_FOO, &STATIC_1, &STATIC_BAR);\n+}"}, {"sha": "906056896be1e6eb3810283737655a019d6e4ee9", "filename": "src/test/compile-fail/intrinsic-return-address.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fintrinsic-return-address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fintrinsic-return-address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintrinsic-return-address.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn return_address() -> *const u8;\n+}\n+\n+unsafe fn f() { let _ = return_address(); }\n+//~^ ERROR invalid use of `return_address` intrinsic: function does not use out pointer\n+\n+unsafe fn g() -> isize { let _ = return_address(); 0 }\n+//~^ ERROR invalid use of `return_address` intrinsic: function does not use out pointer\n+\n+fn main() {}"}, {"sha": "b9382520cf9d3166c3ba6461973d4aeff5a4884d", "filename": "src/test/compile-fail/issue-24446.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fissue-24446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fissue-24446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24446.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -11,6 +11,8 @@\n fn main() {\n     static foo: Fn() -> u32 = || -> u32 {\n         //~^ ERROR: mismatched types\n+        //~| ERROR: `std::ops::Fn() -> u32 + 'static: std::marker::Sized` is not satisfied\n+\n         0\n     };\n }"}, {"sha": "c00be91a2d74daf067a0d99abb6251d0652239c9", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -17,9 +17,8 @@ pub fn main() {\n \n     // Bool => does not implement iterator.\n     for i in false..true {}\n-    //~^ ERROR `bool: std::num::One` is not satisfied\n-    //~^^ ERROR `bool: std::iter::Step` is not satisfied\n-    //~^^^ ERROR `for<'a> &'a bool: std::ops::Add` is not satisfied\n+    //~^ ERROR `bool: std::iter::Step` is not satisfied\n+    //~^^ ERROR `for<'a> &'a bool: std::ops::Add` is not satisfied\n \n     // Unsized type.\n     let arr: &[_] = &[1, 2, 3];"}, {"sha": "d35f2cbb584c767958051215f4ad1dc1e962ed9b", "filename": "src/test/compile-fail/stability-attribute-sanity.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -15,83 +15,84 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n mod bogus_attribute_types_1 {\n-    #[stable(feature = \"a\", since = \"a\", reason)] //~ ERROR unknown meta item 'reason'\n+    #[stable(feature = \"a\", since = \"a\", reason)] //~ ERROR unknown meta item 'reason' [E0541]\n     fn f1() { }\n \n-    #[stable(feature = \"a\", since)] //~ ERROR incorrect meta item\n+    #[stable(feature = \"a\", since)] //~ ERROR incorrect meta item [E0539]\n     fn f2() { }\n \n-    #[stable(feature, since = \"a\")] //~ ERROR incorrect meta item\n+    #[stable(feature, since = \"a\")] //~ ERROR incorrect meta item [E0539]\n     fn f3() { }\n \n-    #[stable(feature = \"a\", since(b))] //~ ERROR incorrect meta item\n+    #[stable(feature = \"a\", since(b))] //~ ERROR incorrect meta item [E0539]\n     fn f5() { }\n \n-    #[stable(feature(b), since = \"a\")] //~ ERROR incorrect meta item\n+    #[stable(feature(b), since = \"a\")] //~ ERROR incorrect meta item [E0539]\n     fn f6() { }\n }\n \n mod bogus_attribute_types_2 {\n-    #[unstable] //~ ERROR incorrect stability attribute type\n+    #[unstable] //~ ERROR incorrect stability attribute type [E0548]\n     fn f1() { }\n \n-    #[unstable = \"a\"] //~ ERROR incorrect stability attribute type\n+    #[unstable = \"a\"] //~ ERROR incorrect stability attribute type [E0548]\n     fn f2() { }\n \n-    #[stable] //~ ERROR incorrect stability attribute type\n+    #[stable] //~ ERROR incorrect stability attribute type [E0548]\n     fn f3() { }\n \n-    #[stable = \"a\"] //~ ERROR incorrect stability attribute type\n+    #[stable = \"a\"] //~ ERROR incorrect stability attribute type [E0548]\n     fn f4() { }\n \n     #[stable(feature = \"a\", since = \"b\")]\n-    #[rustc_deprecated] //~ ERROR incorrect stability attribute type\n+    #[rustc_deprecated] //~ ERROR incorrect stability attribute type [E0548]\n     fn f5() { }\n \n     #[stable(feature = \"a\", since = \"b\")]\n-    #[rustc_deprecated = \"a\"] //~ ERROR incorrect stability attribute type\n+    #[rustc_deprecated = \"a\"] //~ ERROR incorrect stability attribute type [E0548]\n     fn f6() { }\n }\n \n mod missing_feature_names {\n-    #[unstable(issue = \"0\")] //~ ERROR missing 'feature'\n+    #[unstable(issue = \"0\")] //~ ERROR missing 'feature' [E0546]\n     fn f1() { }\n \n-    #[unstable(feature = \"a\")] //~ ERROR missing 'issue'\n+    #[unstable(feature = \"a\")] //~ ERROR missing 'issue' [E0547]\n     fn f2() { }\n \n-    #[stable(since = \"a\")] //~ ERROR missing 'feature'\n+    #[stable(since = \"a\")] //~ ERROR missing 'feature' [E0546]\n     fn f3() { }\n }\n \n mod missing_version {\n-    #[stable(feature = \"a\")] //~ ERROR missing 'since'\n+    #[stable(feature = \"a\")] //~ ERROR missing 'since' [E0542]\n     fn f1() { }\n \n     #[stable(feature = \"a\", since = \"b\")]\n-    #[rustc_deprecated(reason = \"a\")] //~ ERROR missing 'since'\n+    #[rustc_deprecated(reason = \"a\")] //~ ERROR missing 'since' [E0542]\n     fn f2() { }\n }\n \n #[unstable(feature = \"a\", issue = \"0\")]\n-#[stable(feature = \"a\", since = \"b\")]\n-fn multiple1() { } //~ ERROR multiple stability levels\n+#[stable(feature = \"a\", since = \"b\")] //~ ERROR multiple stability levels [E0544]\n+fn multiple1() { }\n \n #[unstable(feature = \"a\", issue = \"0\")]\n-#[unstable(feature = \"a\", issue = \"0\")]\n-fn multiple2() { } //~ ERROR multiple stability levels\n+#[unstable(feature = \"a\", issue = \"0\")] //~ ERROR multiple stability levels [E0544]\n+fn multiple2() { }\n \n #[stable(feature = \"a\", since = \"b\")]\n-#[stable(feature = \"a\", since = \"b\")]\n-fn multiple3() { } //~ ERROR multiple stability levels\n+#[stable(feature = \"a\", since = \"b\")] //~ ERROR multiple stability levels [E0544]\n+fn multiple3() { }\n \n #[stable(feature = \"a\", since = \"b\")]\n #[rustc_deprecated(since = \"b\", reason = \"text\")]\n #[rustc_deprecated(since = \"b\", reason = \"text\")]\n-fn multiple4() { } //~ ERROR multiple rustc_deprecated attributes\n+fn multiple4() { } //~ ERROR multiple rustc_deprecated attributes [E0540]\n //~^ ERROR Invalid stability or deprecation version found\n \n #[rustc_deprecated(since = \"a\", reason = \"text\")]\n-fn deprecated_without_unstable_or_stable() { } //~ ERROR rustc_deprecated attribute must be paired\n+fn deprecated_without_unstable_or_stable() { }\n+//~^ ERROR rustc_deprecated attribute must be paired with either stable or unstable attribute\n \n fn main() { }"}, {"sha": "1638caaa9233740e63a0a19586448ccfcc447516", "filename": "src/test/compile-fail/svh-change-lit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fsvh-change-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fsvh-change-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-lit.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -17,7 +17,7 @@\n \n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n-//~| NOTE: perhaps this crate needs to be recompiled\n+//~| NOTE: perhaps that crate needs to be recompiled\n //~| NOTE: crate `a` path #1:\n //~| NOTE: crate `b` path #1:\n "}, {"sha": "99523ca699f0ead6f703b37835dc1916505f8cd1", "filename": "src/test/compile-fail/svh-change-significant-cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fsvh-change-significant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fsvh-change-significant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-significant-cfg.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -17,7 +17,7 @@\n \n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n-//~| NOTE: perhaps this crate needs to be recompiled\n+//~| NOTE: perhaps that crate needs to be recompiled\n //~| NOTE: crate `a` path #1:\n //~| NOTE: crate `b` path #1:\n "}, {"sha": "dcf4859792d280912295e2c0c7a1f6afafb3d7ad", "filename": "src/test/compile-fail/svh-change-trait-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fsvh-change-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fsvh-change-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-trait-bound.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -17,7 +17,7 @@\n \n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n-//~| NOTE: perhaps this crate needs to be recompiled\n+//~| NOTE: perhaps that crate needs to be recompiled\n //~| NOTE: crate `a` path #1:\n //~| NOTE: crate `b` path #1:\n "}, {"sha": "7e51ca456b21a4607bf75e4a92fbe92802200094", "filename": "src/test/compile-fail/svh-change-type-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-arg.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -17,7 +17,7 @@\n \n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n-//~| NOTE: perhaps this crate needs to be recompiled\n+//~| NOTE: perhaps that crate needs to be recompiled\n //~| NOTE: crate `a` path #1:\n //~| NOTE: crate `b` path #1:\n "}, {"sha": "54ca87d84c1ec371df5a16b03efbd17ddfcb51e0", "filename": "src/test/compile-fail/svh-change-type-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-ret.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -17,7 +17,7 @@\n \n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n-//~| NOTE: perhaps this crate needs to be recompiled\n+//~| NOTE: perhaps that crate needs to be recompiled\n //~| NOTE: crate `a` path #1:\n //~| NOTE: crate `b` path #1:\n "}, {"sha": "ea90faaf610888bdb402fd2b9298f873e541508b", "filename": "src/test/compile-fail/svh-change-type-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-static.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -17,7 +17,7 @@\n \n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n-//~| NOTE: perhaps this crate needs to be recompiled\n+//~| NOTE: perhaps that crate needs to be recompiled\n //~| NOTE: crate `a` path #1:\n //~| NOTE: crate `b` path #1:\n "}, {"sha": "c0a5a0a17eb2655c8d0d9bcd87b102cb7515a6e7", "filename": "src/test/compile-fail/svh-use-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fsvh-use-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fcompile-fail%2Fsvh-use-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-use-trait.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -22,7 +22,7 @@\n \n extern crate uta;\n extern crate utb; //~ ERROR: found possibly newer version of crate `uta` which `utb` depends\n-//~| NOTE: perhaps this crate needs to be recompiled?\n+//~| NOTE: perhaps that crate needs to be recompiled?\n //~| NOTE: crate `uta` path #1:\n //~| NOTE: crate `utb` path #1:\n "}, {"sha": "bb5385235230702be34bde4f397005f5c0d77f4b", "filename": "src/test/debuginfo/pretty-huge-vec.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fdebuginfo%2Fpretty-huge-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fdebuginfo%2Fpretty-huge-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-huge-vec.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-windows failing on win32 bot\n+// ignore-freebsd: gdb package too new\n+// ignore-android: FIXME(#10381)\n+// compile-flags:-g\n+// min-gdb-version 7.7\n+// min-lldb-version: 310\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command: run\n+\n+// gdb-command: print vec\n+// gdb-check:$1 = Vec<u8>(len: 1000000000, cap: 1000000000) = {[...]...}\n+\n+// gdb-command: print slice\n+// gdb-check:$2 = &[u8](len: 1000000000) = {[...]...}\n+\n+\n+#![allow(unused_variables)]\n+\n+fn main() {\n+\n+    // Vec\n+    let mut vec: Vec<u8> = Vec::with_capacity(1_000_000_000);\n+    unsafe{ vec.set_len(1_000_000_000) }\n+    let slice = &vec[..];\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() { () }"}, {"sha": "75169658fe6a23264f74fa3ce238dc2b02ada032", "filename": "src/test/debuginfo/pretty-uninitialized-vec.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fdebuginfo%2Fpretty-uninitialized-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fdebuginfo%2Fpretty-uninitialized-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-uninitialized-vec.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-windows failing on win32 bot\n+// ignore-freebsd: gdb package too new\n+// ignore-android: FIXME(#10381)\n+// compile-flags:-g\n+// min-gdb-version 7.7\n+// min-lldb-version: 310\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command: run\n+\n+// gdb-command: print vec\n+// gdb-check:$1 = Vec<i32>(len: [...], cap: [...])[...]\n+\n+\n+#![allow(unused_variables)]\n+\n+fn main() {\n+\n+    let vec;\n+    zzz(); // #break\n+    vec = vec![0];\n+\n+}\n+\n+fn zzz() { () }"}, {"sha": "cdb5bc4ecfb6ec371976059ad75cc9d7c85ac047", "filename": "src/test/debuginfo/vec-slices.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -53,6 +53,11 @@\n // gdb-command:print *((int64_t[2]*)('vec_slices::MUT_VECT_SLICE'.data_ptr))\n // gdb-check:$15 = {64, 65}\n \n+//gdb-command:print mut_slice.length\n+//gdb-check:$16 = 5\n+//gdb-command:print *((int64_t[5]*)(mut_slice.data_ptr))\n+//gdb-check:$17 = {1, 2, 3, 4, 5}\n+\n \n // === LLDB TESTS ==================================================================================\n \n@@ -106,6 +111,8 @@ fn main() {\n         MUT_VECT_SLICE = VECT_SLICE;\n     }\n \n+    let mut_slice: &mut [i64] = &mut [1, 2, 3, 4, 5];\n+\n     zzz(); // #break\n }\n "}, {"sha": "21e1463b6ef955efdf9929e42acf2f4944c7deaa", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -241,8 +241,9 @@ fn compile_program(input: &str, sysroot: PathBuf)\n         let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, &input));\n \n         let driver::ExpansionResult { defs, analysis, resolutions, mut hir_forest, .. } = {\n-            driver::phase_2_configure_and_expand(&sess, &cstore, krate, &id, None, MakeGlobMap::No)\n-                .expect(\"phase_2 returned `None`\")\n+            driver::phase_2_configure_and_expand(\n+                &sess, &cstore, krate, &id, None, MakeGlobMap::No, |_| Ok(()),\n+            ).expect(\"phase_2 returned `None`\")\n         };\n \n         let arenas = ty::CtxtArenas::new();"}, {"sha": "6a8e1728b20a83773edaac0598ce0e119455cdd0", "filename": "src/test/run-make/llvm-phase/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Frun-make%2Fllvm-phase%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Frun-make%2Fllvm-phase%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-phase%2FMakefile?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) test.rs\n+\t$(call RUN,test $(RUSTC))"}, {"sha": "402b5ed83556cd5f5326168269e67c157c554de5", "filename": "src/test/run-make/llvm-phase/test.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(plugin, rustc_private, box_syntax)]\n+\n+extern crate rustc;\n+extern crate rustc_driver;\n+extern crate rustc_llvm;\n+#[macro_use] extern crate syntax;\n+extern crate getopts;\n+\n+use rustc_driver::{CompilerCalls, Compilation};\n+use rustc_driver::driver::CompileController;\n+use rustc::session::Session;\n+use syntax::codemap::FileLoader;\n+use std::io;\n+use std::path::{PathBuf, Path};\n+\n+struct JitLoader;\n+\n+impl FileLoader for JitLoader {\n+    fn file_exists(&self, _: &Path) -> bool { true }\n+    fn abs_path(&self, _: &Path) -> Option<PathBuf> { None }\n+    fn read_file(&self, _: &Path) -> io::Result<String> {\n+        Ok(r#\"\n+#[no_mangle]\n+pub fn test_add(a: i32, b: i32) -> i32 { a + b }\n+\"#.to_string())\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+struct JitCalls;\n+\n+impl<'a> CompilerCalls<'a> for JitCalls {\n+    fn build_controller(&mut self,\n+                        _: &Session,\n+                        _: &getopts::Matches)\n+                        -> CompileController<'a> {\n+        let mut cc = CompileController::basic();\n+        cc.after_llvm.stop = Compilation::Stop;\n+        cc.after_llvm.run_callback_on_error = true;\n+        cc.after_llvm.callback = Box::new(|state| {\n+            state.session.abort_if_errors();\n+            let trans = state.trans.unwrap();\n+            assert_eq!(trans.modules.len(), 1);\n+            let rs_llmod = trans.modules[0].llmod;\n+            unsafe { rustc_llvm::LLVMDumpModule(rs_llmod) };\n+        });\n+        cc\n+    }\n+}\n+\n+fn main() {\n+    use rustc_driver;\n+\n+    let mut path = match std::env::args().nth(2) {\n+        Some(path) => PathBuf::from(&path),\n+        None => panic!(\"missing rustc path\")\n+    };\n+\n+    // Remove two segments from rustc path to get sysroot.\n+    path.pop();\n+    path.pop();\n+\n+    let args: Vec<String> =\n+        format!(\"_ _ --sysroot {} --crate-type dylib\", path.to_str().unwrap())\n+        .split(' ').map(|s| s.to_string()).collect();\n+\n+    let (result, _) = rustc_driver::run_compiler_with_file_loader(\n+        &args, &mut JitCalls, box JitLoader);\n+    if let Err(n) = result {\n+        panic!(\"Error {}\", n);\n+    }\n+}"}, {"sha": "0da4af34ef03d9ae30dd28a9200174f47f21ee55", "filename": "src/test/run-make/many-crates-but-no-match/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -28,7 +28,7 @@ all:\n \t# Ensure crateC fails to compile since A1 is \"missing\" and A2/A3 hashes do not match\n \t$(RUSTC) -L $(A2) -L $(A3) crateC.rs >$(LOG) 2>&1 || true\n \tgrep \"error: found possibly newer version of crate \\`crateA\\` which \\`crateB\\` depends on\" $(LOG)\n-\tgrep \"note: perhaps this crate needs to be recompiled?\" $(LOG)\n+\tgrep \"note: perhaps that crate needs to be recompiled?\" $(LOG)\n \tgrep \"note: crate \\`crateA\\` path #1:\" $(LOG)\n \tgrep \"note: crate \\`crateA\\` path #2:\" $(LOG)\n \tgrep \"note: crate \\`crateB\\` path #1:\" $(LOG)"}, {"sha": "63aed3f009fd7d7832544957a4894d7d500f856f", "filename": "src/test/run-pass/intrinsic-return-address.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Frun-pass%2Fintrinsic-return-address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Frun-pass%2Fintrinsic-return-address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-return-address.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![feature(intrinsics)]\n+\n+use std::ptr;\n+\n+struct Point {\n+    x: f32,\n+    y: f32,\n+    z: f32,\n+}\n+\n+extern \"rust-intrinsic\" {\n+    fn return_address() -> *const u8;\n+}\n+\n+fn f(result: &mut usize) -> Point {\n+    unsafe {\n+        *result = return_address() as usize;\n+        Point {\n+            x: 1.0,\n+            y: 2.0,\n+            z: 3.0,\n+        }\n+    }\n+\n+}\n+\n+fn main() {\n+    let mut intrinsic_reported_address = 0;\n+    let pt = f(&mut intrinsic_reported_address);\n+    let actual_address = &pt as *const Point as usize;\n+    assert_eq!(intrinsic_reported_address, actual_address);\n+}"}, {"sha": "e6217243eeb4a3db8931fa6d032b32789d69b132", "filename": "src/test/run-pass/issue-34503.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Frun-pass%2Fissue-34503.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Frun-pass%2Fissue-34503.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-34503.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    struct X;\n+    trait Foo<T> {\n+        fn foo(&self) where (T, Option<T>): Ord {}\n+        fn bar(&self, x: &Option<T>) -> bool\n+        where Option<T>: Ord { *x < *x }\n+    }\n+    impl Foo<X> for () {}\n+    let _ = &() as &Foo<X>;\n+}"}, {"sha": "aaf129e7b8e4abf413e65847100a8dcf03f95ab8", "filename": "src/test/run-pass/range_inclusive.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange_inclusive.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -117,11 +117,6 @@ pub fn main() {\n     assert_eq!(nonsense.next(), None);\n     assert_eq!(nonsense, RangeInclusive::Empty { at: 10 });\n \n-    // conversion\n-    assert_eq!(0...9, (0..10).into());\n-    assert_eq!(0...0, (0..1).into());\n-    assert_eq!(RangeInclusive::Empty { at: 1 }, (1..0).into());\n-\n     // output\n     assert_eq!(format!(\"{:?}\", 0...10), \"0...10\");\n     assert_eq!(format!(\"{:?}\", ...10), \"...10\");"}, {"sha": "577da5c5af11d2b012eed6d4f860731c3050a452", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -1012,8 +1012,7 @@ actual:\\n\\\n \n         // Parse the JSON output from the compiler and extract out the messages.\n         let actual_errors = json::parse_output(&file_name, &proc_res.stderr, &proc_res);\n-        let mut unexpected = 0;\n-        let mut not_found = 0;\n+        let mut unexpected = Vec::new();\n         let mut found = vec![false; expected_errors.len()];\n         for actual_error in &actual_errors {\n             let opt_index =\n@@ -1045,12 +1044,13 @@ actual:\\n\\\n                                      .map_or(String::from(\"message\"),\n                                              |k| k.to_string()),\n                                      actual_error.msg));\n-                        unexpected += 1;\n+                        unexpected.push(actual_error.clone());\n                     }\n                 }\n             }\n         }\n \n+        let mut not_found = Vec::new();\n         // anything not yet found is a problem\n         for (index, expected_error) in expected_errors.iter().enumerate() {\n             if !found[index] {\n@@ -1062,18 +1062,22 @@ actual:\\n\\\n                              .map_or(\"message\".into(),\n                                      |k| k.to_string()),\n                              expected_error.msg));\n-                not_found += 1;\n+                not_found.push(expected_error.clone());\n             }\n         }\n \n-        if unexpected > 0 || not_found > 0 {\n+        if unexpected.len() > 0 || not_found.len() > 0 {\n             self.error(\n                 &format!(\"{} unexpected errors found, {} expected errors not found\",\n-                         unexpected, not_found));\n+                         unexpected.len(), not_found.len()));\n             print!(\"status: {}\\ncommand: {}\\n\",\n                    proc_res.status, proc_res.cmdline);\n-            println!(\"actual errors (from JSON output): {:#?}\\n\", actual_errors);\n-            println!(\"expected errors (from test file): {:#?}\\n\", expected_errors);\n+            if unexpected.len() > 0 {\n+                println!(\"unexpected errors (from JSON output): {:#?}\\n\", unexpected);\n+            }\n+            if not_found.len() > 0 {\n+                println!(\"not found errors (from test file): {:#?}\\n\", not_found);\n+            }\n             panic!();\n         }\n     }"}, {"sha": "80c37d5597592de4e873a4876f1b274219c8e837", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -138,22 +138,6 @@ fn check(cache: &mut Cache,\n         return None;\n     }\n \n-    if file.ends_with(\"std/sys/ext/index.html\") {\n-        return None;\n-    }\n-\n-    if let Some(file) = file.to_str() {\n-        // FIXME(#31948)\n-        if file.contains(\"ParseFloatError\") {\n-            return None;\n-        }\n-        // weird reexports, but this module is on its way out, so chalk it up to\n-        // \"rustdoc weirdness\" and move on from there\n-        if file.contains(\"scoped_tls\") {\n-            return None;\n-        }\n-    }\n-\n     let mut parser = UrlParser::new();\n     parser.base_url(base);\n \n@@ -170,12 +154,24 @@ fn check(cache: &mut Cache,\n \n     // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n     with_attrs_in_source(&contents, \" href\", |url, i| {\n+        // Ignore external URLs\n+        if url.starts_with(\"http:\") || url.starts_with(\"https:\") ||\n+           url.starts_with(\"javascript:\") || url.starts_with(\"ftp:\") ||\n+           url.starts_with(\"irc:\") || url.starts_with(\"data:\") {\n+            return;\n+        }\n         // Once we've plucked out the URL, parse it using our base url and\n-        // then try to extract a file path. If either of these fail then we\n-        // just keep going.\n+        // then try to extract a file path.\n         let (parsed_url, path) = match url_to_file_path(&parser, url) {\n             Some((url, path)) => (url, PathBuf::from(path)),\n-            None => return,\n+            None => {\n+                *errors = true;\n+                println!(\"{}:{}: invalid link - {}\",\n+                         pretty_file.display(),\n+                         i + 1,\n+                         url);\n+                return;\n+            }\n         };\n \n         // Alright, if we've found a file name then this file had better\n@@ -197,10 +193,11 @@ fn check(cache: &mut Cache,\n                 Ok(res) => res,\n                 Err(LoadError::IOError(err)) => panic!(format!(\"{}\", err)),\n                 Err(LoadError::BrokenRedirect(target, _)) => {\n-                    print!(\"{}:{}: broken redirect to {}\",\n-                           pretty_file.display(),\n-                           i + 1,\n-                           target.display());\n+                    *errors = true;\n+                    println!(\"{}:{}: broken redirect to {}\",\n+                             pretty_file.display(),\n+                             i + 1,\n+                             target.display());\n                     return;\n                 }\n                 Err(LoadError::IsRedirect) => unreachable!(),"}, {"sha": "436dc1197533638504fb8c6e808f1e8d51137b1c", "filename": "src/tools/rustbook/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftools%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297e3969e27c69e0a556af66c94a700a561eeb7e/src%2Ftools%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fmain.rs?ref=297e3969e27c69e0a556af66c94a700a561eeb7e", "patch": "@@ -10,7 +10,6 @@\n \n #![deny(warnings)]\n \n-#![feature(iter_arith)]\n #![feature(rustc_private)]\n #![feature(rustdoc)]\n #![feature(question_mark)]"}]}