{"sha": "5eeb567a27eba18420a620ca7d0c007e29d8bc0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlZWI1NjdhMjdlYmExODQyMGE2MjBjYTdkMGMwMDdlMjlkOGJjMGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-06T20:46:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-06T20:46:15Z"}, "message": "Auto merge of #61601 - Centril:rollup-uegbsns, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #61376 (Add Bound::cloned())\n - #61554 (Change visit api)\n - #61559 (Make visitors iterate)\n - #61585 (Update .mailmap with my name)\n - #61591 (Update .mailmap)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e2e372e69972bcb438f6fc9951d4b05831190bf9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2e372e69972bcb438f6fc9951d4b05831190bf9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eeb567a27eba18420a620ca7d0c007e29d8bc0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eeb567a27eba18420a620ca7d0c007e29d8bc0c", "html_url": "https://github.com/rust-lang/rust/commit/5eeb567a27eba18420a620ca7d0c007e29d8bc0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b36867093fb774bcbd9f787cbc470a5f44c1310", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b36867093fb774bcbd9f787cbc470a5f44c1310", "html_url": "https://github.com/rust-lang/rust/commit/8b36867093fb774bcbd9f787cbc470a5f44c1310"}, {"sha": "9e97970fe240df0b9a6e65055e670f40f02e416d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e97970fe240df0b9a6e65055e670f40f02e416d", "html_url": "https://github.com/rust-lang/rust/commit/9e97970fe240df0b9a6e65055e670f40f02e416d"}], "stats": {"total": 291, "additions": 174, "deletions": 117}, "files": [{"sha": "5673cc5cfbc9db3abd85d60332310f6348b7ff5e", "filename": ".mailmap", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=5eeb567a27eba18420a620ca7d0c007e29d8bc0c", "patch": "@@ -56,6 +56,7 @@ Chris Thorn <chris@thorn.co> Chris Thorn <thorn@thoughtbot.com>\n Chris Vittal <christopher.vittal@gmail.com> Christopher Vittal <christopher.vittal@gmail.com>\n Christian Poveda <christianpoveda@protonmail.com> <cn.poveda.ruiz@gmail.com>\n Christian Poveda <christianpoveda@protonmail.com> <z1mvader@protonmail.com>\n+Christian Poveda <christianpoveda@protonmail.com> <cpovedar@fnal.gov>\n Clark Gaebel <cg.wowus.cg@gmail.com> <cgaebel@mozilla.com>\n Clinton Ryan <clint.ryan3@gmail.com>\n Corey Richardson <corey@octayn.net> Elaine \"See More\" Nemo <corey@octayn.net>\n@@ -139,6 +140,7 @@ Kang Seonghoon <kang.seonghoon@mearie.org> <public+git@mearie.org>\n Keegan McAllister <mcallister.keegan@gmail.com> <kmcallister@mozilla.com>\n Kevin Butler <haqkrs@gmail.com>\n Kyeongwoon Lee <kyeongwoon.lee@samsung.com>\n+Lauren\u021biu Nicola <lnicola@dend.ro>\n Lee Jeffery <leejeffery@gmail.com> Lee Jeffery <lee@leejeffery.co.uk>\n Lee Wondong <wdlee91@gmail.com>\n Lennart Kudling <github@kudling.de>"}, {"sha": "af24cbe1c5c480ab3499474ea81d3138746efb53", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=5eeb567a27eba18420a620ca7d0c007e29d8bc0c", "patch": "@@ -70,6 +70,7 @@\n #![feature(arbitrary_self_types)]\n #![feature(asm)]\n #![feature(associated_type_defaults)]\n+#![feature(bound_cloned)]\n #![feature(cfg_target_has_atomic)]\n #![feature(concat_idents)]\n #![feature(const_fn)]"}, {"sha": "1b4c4218cc15bb95e25ab47e803e6096414fdc1b", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=5eeb567a27eba18420a620ca7d0c007e29d8bc0c", "patch": "@@ -696,6 +696,29 @@ pub enum Bound<T> {\n     Unbounded,\n }\n \n+impl<T: Clone> Bound<&T> {\n+    /// Map a `Bound<&T>` to a `Bound<T>` by cloning the contents of the bound.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(bound_cloned)]\n+    /// use std::ops::Bound::*;\n+    /// use std::ops::RangeBounds;\n+    ///\n+    /// assert_eq!((1..12).start_bound(), Included(&1));\n+    /// assert_eq!((1..12).start_bound().cloned(), Included(1));\n+    /// ```\n+    #[unstable(feature = \"bound_cloned\", issue = \"61356\")]\n+    pub fn cloned(self) -> Bound<T> {\n+        match self {\n+            Bound::Unbounded => Bound::Unbounded,\n+            Bound::Included(x) => Bound::Included(x.clone()),\n+            Bound::Excluded(x) => Bound::Excluded(x.clone()),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n /// `RangeBounds` is implemented by Rust's built-in range types, produced\n /// by range syntax like `..`, `a..`, `..b`, `..=c`, `d..e`, or `f..=g`."}, {"sha": "928bdd7a7600256cff29cea50e4c7a75a09f464a", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=5eeb567a27eba18420a620ca7d0c007e29d8bc0c", "patch": "@@ -1,3 +1,4 @@\n+#![feature(bound_cloned)]\n #![feature(box_syntax)]\n #![feature(cell_update)]\n #![feature(core_private_bignum)]"}, {"sha": "48755ae4c16411914f3cbd7820f618a8718b1ce0", "filename": "src/libcore/tests/ops.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=5eeb567a27eba18420a620ca7d0c007e29d8bc0c", "patch": "@@ -1,4 +1,4 @@\n-use core::ops::{Range, RangeFull, RangeFrom, RangeTo, RangeInclusive};\n+use core::ops::{Bound, Range, RangeFull, RangeFrom, RangeTo, RangeInclusive};\n \n // Test the Range structs without the syntactic sugar.\n \n@@ -82,3 +82,18 @@ fn test_range_is_empty() {\n     assert!( (NAN ..= EPSILON).is_empty());\n     assert!( (NAN ..= NAN).is_empty());\n }\n+\n+#[test]\n+fn test_bound_cloned_unbounded() {\n+    assert_eq!(Bound::<&u32>::Unbounded.cloned(), Bound::Unbounded);\n+}\n+\n+#[test]\n+fn test_bound_cloned_included() {\n+    assert_eq!(Bound::Included(&3).cloned(), Bound::Included(3));\n+}\n+\n+#[test]\n+fn test_bound_cloned_excluded() {\n+    assert_eq!(Bound::Excluded(&3).cloned(), Bound::Excluded(3));\n+}"}, {"sha": "2f19f591830f9d9233894f4468ece66a1222c7d1", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=5eeb567a27eba18420a620ca7d0c007e29d8bc0c", "patch": "@@ -151,17 +151,17 @@ macro_rules! make_mir_visitor {\n                 self.super_place(place, context, location);\n             }\n \n-            fn visit_projection(&mut self,\n-                                place: & $($mutability)? Projection<'tcx>,\n+            fn visit_place_base(&mut self,\n+                                place_base: & $($mutability)? PlaceBase<'tcx>,\n                                 context: PlaceContext,\n                                 location: Location) {\n-                self.super_projection(place, context, location);\n+                self.super_place_base(place_base, context, location);\n             }\n \n-            fn visit_projection_elem(&mut self,\n-                                     place: & $($mutability)? PlaceElem<'tcx>,\n-                                     location: Location) {\n-                self.super_projection_elem(place, location);\n+            fn visit_projection(&mut self,\n+                                place: & $($mutability)? Projection<'tcx>,\n+                                location: Location) {\n+                self.super_projection(place, location);\n             }\n \n             fn visit_constant(&mut self,\n@@ -676,36 +676,40 @@ macro_rules! make_mir_visitor {\n                             context: PlaceContext,\n                             location: Location) {\n                 match place {\n-                    Place::Base(PlaceBase::Local(local)) => {\n-                        self.visit_local(local, context, location);\n-                    }\n-                    Place::Base(PlaceBase::Static(box Static { kind: _, ty })) => {\n-                        self.visit_ty(& $($mutability)? *ty, TyContext::Location(location));\n+                    Place::Base(place_base) => {\n+                        self.visit_place_base(place_base, context, location);\n                     }\n                     Place::Projection(proj) => {\n-                        self.visit_projection(proj, context, location);\n+                        let context = if context.is_mutating_use() {\n+                            PlaceContext::MutatingUse(MutatingUseContext::Projection)\n+                        } else {\n+                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n+                        };\n+\n+                        self.visit_place(& $($mutability)? proj.base, context, location);\n+                        self.visit_projection(proj, location);\n                     }\n                 }\n             }\n \n-            fn super_projection(&mut self,\n-                                proj: & $($mutability)? Projection<'tcx>,\n+            fn super_place_base(&mut self,\n+                                place_base: & $($mutability)? PlaceBase<'tcx>,\n                                 context: PlaceContext,\n                                 location: Location) {\n-                let Projection { base, elem } = proj;\n-                let context = if context.is_mutating_use() {\n-                    PlaceContext::MutatingUse(MutatingUseContext::Projection)\n-                } else {\n-                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n-                };\n-                self.visit_place(base, context, location);\n-                self.visit_projection_elem(elem, location);\n+                match place_base {\n+                    PlaceBase::Local(local) => {\n+                        self.visit_local(local, context, location);\n+                    }\n+                    PlaceBase::Static(box Static { kind: _, ty }) => {\n+                        self.visit_ty(& $($mutability)? *ty, TyContext::Location(location));\n+                    }\n+                }\n             }\n \n-            fn super_projection_elem(&mut self,\n-                                     proj: & $($mutability)? PlaceElem<'tcx>,\n-                                     location: Location) {\n-                match proj {\n+            fn super_projection(&mut self,\n+                                proj: & $($mutability)? Projection<'tcx>,\n+                                location: Location) {\n+                match & $($mutability)? proj.elem {\n                     ProjectionElem::Deref => {\n                     }\n                     ProjectionElem::Subslice { from: _, to: _ } => {"}, {"sha": "549608bf7ee5fb5a9e7ee9621d82d38acb7817be", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 48, "deletions": 37, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=5eeb567a27eba18420a620ca7d0c007e29d8bc0c", "patch": "@@ -154,51 +154,62 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                    context: PlaceContext,\n                    location: Location) {\n         debug!(\"visit_place(place={:?}, context={:?})\", place, context);\n+        let mut context = context;\n         let cx = self.fx.cx;\n \n-        if let mir::Place::Projection(ref proj) = *place {\n-            // Allow uses of projections that are ZSTs or from scalar fields.\n-            let is_consume = match context {\n-                PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n-                PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => true,\n-                _ => false\n-            };\n-            if is_consume {\n-                let base_ty = proj.base.ty(self.fx.mir, cx.tcx());\n-                let base_ty = self.fx.monomorphize(&base_ty);\n-\n-                // ZSTs don't require any actual memory access.\n-                let elem_ty = base_ty\n-                    .projection_ty(cx.tcx(), &proj.elem)\n-                    .ty;\n-                let elem_ty = self.fx.monomorphize(&elem_ty);\n-                if cx.layout_of(elem_ty).is_zst() {\n-                    return;\n-                }\n-\n-                if let mir::ProjectionElem::Field(..) = proj.elem {\n-                    let layout = cx.layout_of(base_ty.ty);\n-                    if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n-                        // Recurse with the same context, instead of `Projection`,\n-                        // potentially stopping at non-operand projections,\n-                        // which would trigger `not_ssa` on locals.\n-                        self.visit_place(&proj.base, context, location);\n+        place.iterate(|place_base, place_projections| {\n+            for proj in place_projections {\n+                // Allow uses of projections that are ZSTs or from scalar fields.\n+                let is_consume = match context {\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => true,\n+                    _ => false\n+                };\n+                if is_consume {\n+                    let base_ty = proj.base.ty(self.fx.mir, cx.tcx());\n+                    let base_ty = self.fx.monomorphize(&base_ty);\n+\n+                    // ZSTs don't require any actual memory access.\n+                    let elem_ty = base_ty\n+                        .projection_ty(cx.tcx(), &proj.elem)\n+                        .ty;\n+                    let elem_ty = self.fx.monomorphize(&elem_ty);\n+                    if cx.layout_of(elem_ty).is_zst() {\n                         return;\n                     }\n+\n+                    if let mir::ProjectionElem::Field(..) = proj.elem {\n+                        let layout = cx.layout_of(base_ty.ty);\n+                        if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n+                            // Recurse with the same context, instead of `Projection`,\n+                            // potentially stopping at non-operand projections,\n+                            // which would trigger `not_ssa` on locals.\n+                            continue;\n+                        }\n+                    }\n                 }\n-            }\n \n-            // A deref projection only reads the pointer, never needs the place.\n-            if let mir::ProjectionElem::Deref = proj.elem {\n-                return self.visit_place(\n-                    &proj.base,\n-                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n-                    location\n-                );\n+                // A deref projection only reads the pointer, never needs the place.\n+                if let mir::ProjectionElem::Deref = proj.elem {\n+                    return self.visit_place(\n+                        &proj.base,\n+                        PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n+                        location\n+                    );\n+                }\n+\n+                context = if context.is_mutating_use() {\n+                    PlaceContext::MutatingUse(MutatingUseContext::Projection)\n+                } else {\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n+                };\n             }\n-        }\n \n-        self.super_place(place, context, location);\n+            // Default base visit behavior\n+            if let mir::PlaceBase::Local(local) = place_base {\n+                self.visit_local(local, context, location);\n+            }\n+        });\n     }\n \n     fn visit_local(&mut self,"}, {"sha": "91b4af9655a43be0dbc34654844ea37209d2960d", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=5eeb567a27eba18420a620ca7d0c007e29d8bc0c", "patch": "@@ -185,7 +185,7 @@ use rustc::ty::{self, TypeFoldable, Ty, TyCtxt, GenericParamDefKind, Instance};\n use rustc::ty::print::obsolete::DefPathBasedNames;\n use rustc::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc::session::config::EntryFnType;\n-use rustc::mir::{self, Location, Place, PlaceBase, Promoted, Static, StaticKind};\n+use rustc::mir::{self, Location, PlaceBase, Promoted, Static, StaticKind};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::{MonoItem, InstantiationMode};\n use rustc::mir::interpret::{Scalar, GlobalId, GlobalAlloc, ErrorHandled};\n@@ -655,14 +655,12 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.super_terminator_kind(kind, location);\n     }\n \n-    fn visit_place(&mut self,\n-                    place: &mir::Place<'tcx>,\n-                    context: mir::visit::PlaceContext,\n-                    location: Location) {\n-        match place {\n-            Place::Base(\n-                PlaceBase::Static(box Static{ kind:StaticKind::Static(def_id), .. })\n-            ) => {\n+    fn visit_place_base(&mut self,\n+                        place_base: &mir::PlaceBase<'tcx>,\n+                        _context: mir::visit::PlaceContext,\n+                        location: Location) {\n+        match place_base {\n+            PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), .. }) => {\n                 debug!(\"visiting static {:?} @ {:?}\", def_id, location);\n \n                 let tcx = self.tcx;\n@@ -671,10 +669,13 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     self.output.push(MonoItem::Static(*def_id));\n                 }\n             }\n-            _ => {}\n+            PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. }) => {\n+                // FIXME: should we handle promoteds here instead of eagerly in collect_neighbours?\n+            }\n+            PlaceBase::Local(_) => {\n+                // Locals have no relevance for collector\n+            }\n         }\n-\n-        self.super_place(place, context, location);\n     }\n }\n "}, {"sha": "4e8cc124e50407fe97dc49772ec636cabc4debb5", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeb567a27eba18420a620ca7d0c007e29d8bc0c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=5eeb567a27eba18420a620ca7d0c007e29d8bc0c", "patch": "@@ -199,11 +199,39 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n     fn visit_place(&mut self,\n                     place: &Place<'tcx>,\n                     context: PlaceContext,\n-                    location: Location) {\n-        match place {\n-            &Place::Projection(box Projection {\n-                ref base, ref elem\n-            }) => {\n+                    _location: Location) {\n+        place.iterate(|place_base, place_projections| {\n+            match place_base {\n+                PlaceBase::Local(..) => {\n+                    // Locals are safe.\n+                }\n+                PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. }) => {\n+                    bug!(\"unsafety checking should happen before promotion\")\n+                }\n+                PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), .. }) => {\n+                    if self.tcx.is_mutable_static(*def_id) {\n+                        self.require_unsafe(\"use of mutable static\",\n+                            \"mutable statics can be mutated by multiple threads: aliasing \\\n+                             violations or data races will cause undefined behavior\",\n+                             UnsafetyViolationKind::General);\n+                    } else if self.tcx.is_foreign_item(*def_id) {\n+                        let source_info = self.source_info;\n+                        let lint_root =\n+                            self.source_scope_local_data[source_info.scope].lint_root;\n+                        self.register_violations(&[UnsafetyViolation {\n+                            source_info,\n+                            description: InternedString::intern(\"use of extern static\"),\n+                            details: InternedString::intern(\n+                                \"extern statics are not controlled by the Rust type system: \\\n+                                invalid data, aliasing violations or data races will cause \\\n+                                undefined behavior\"),\n+                            kind: UnsafetyViolationKind::ExternStatic(lint_root)\n+                        }], &[]);\n+                    }\n+                }\n+            }\n+\n+            for proj in place_projections {\n                 if context.is_borrow() {\n                     if util::is_disaligned(self.tcx, self.mir, self.param_env, place) {\n                         let source_info = self.source_info;\n@@ -220,7 +248,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         }], &[]);\n                     }\n                 }\n-                let is_borrow_of_interior_mut = context.is_borrow() && !base\n+                let is_borrow_of_interior_mut = context.is_borrow() && !proj.base\n                     .ty(self.mir, self.tcx)\n                     .ty\n                     .is_freeze(self.tcx, self.param_env, self.source_info.span);\n@@ -236,15 +264,15 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     );\n                 }\n                 let old_source_info = self.source_info;\n-                if let &Place::Base(PlaceBase::Local(local)) = base {\n+                if let Place::Base(PlaceBase::Local(local)) = proj.base {\n                     if self.mir.local_decls[local].internal {\n                         // Internal locals are used in the `move_val_init` desugaring.\n                         // We want to check unsafety against the source info of the\n                         // desugaring, rather than the source info of the RHS.\n                         self.source_info = self.mir.local_decls[local].source_info;\n                     }\n                 }\n-                let base_ty = base.ty(self.mir, self.tcx).ty;\n+                let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n                 match base_ty.sty {\n                     ty::RawPtr(..) => {\n                         self.require_unsafe(\"dereference of raw pointer\",\n@@ -260,8 +288,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                                     MutatingUseContext::AsmOutput\n                                 )\n                             {\n-                                let elem_ty = match elem {\n-                                    &ProjectionElem::Field(_, ty) => ty,\n+                                let elem_ty = match proj.elem {\n+                                    ProjectionElem::Field(_, ty) => ty,\n                                     _ => span_bug!(\n                                         self.source_info.span,\n                                         \"non-field projection {:?} from union?\",\n@@ -292,36 +320,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n                 self.source_info = old_source_info;\n             }\n-            &Place::Base(PlaceBase::Local(..)) => {\n-                // locals are safe\n-            }\n-            &Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })) => {\n-                bug!(\"unsafety checking should happen before promotion\")\n-            }\n-            &Place::Base(\n-                PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), .. })\n-            ) => {\n-                if self.tcx.is_mutable_static(def_id) {\n-                    self.require_unsafe(\"use of mutable static\",\n-                        \"mutable statics can be mutated by multiple threads: aliasing violations \\\n-                         or data races will cause undefined behavior\",\n-                         UnsafetyViolationKind::General);\n-                } else if self.tcx.is_foreign_item(def_id) {\n-                    let source_info = self.source_info;\n-                    let lint_root =\n-                        self.source_scope_local_data[source_info.scope].lint_root;\n-                    self.register_violations(&[UnsafetyViolation {\n-                        source_info,\n-                        description: InternedString::intern(\"use of extern static\"),\n-                        details: InternedString::intern(\n-                            \"extern statics are not controlled by the Rust type system: invalid \\\n-                            data, aliasing violations or data races will cause undefined behavior\"),\n-                        kind: UnsafetyViolationKind::ExternStatic(lint_root)\n-                    }], &[]);\n-                }\n-            }\n-        };\n-        self.super_place(place, context, location);\n+        });\n     }\n }\n "}]}