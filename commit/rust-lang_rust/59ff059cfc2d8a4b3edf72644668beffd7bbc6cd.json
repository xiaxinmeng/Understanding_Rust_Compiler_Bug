{"sha": "59ff059cfc2d8a4b3edf72644668beffd7bbc6cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZmYwNTljZmMyZDhhNGIzZWRmNzI2NDQ2NjhiZWZmZDdiYmM2Y2Q=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-04-01T20:35:13Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-04-01T20:35:13Z"}, "message": "Add ensure_capacity and rename min to len", "tree": {"sha": "d652446603c0f5e00c9ab2932163f102845b9c44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d652446603c0f5e00c9ab2932163f102845b9c44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59ff059cfc2d8a4b3edf72644668beffd7bbc6cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59ff059cfc2d8a4b3edf72644668beffd7bbc6cd", "html_url": "https://github.com/rust-lang/rust/commit/59ff059cfc2d8a4b3edf72644668beffd7bbc6cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59ff059cfc2d8a4b3edf72644668beffd7bbc6cd/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8b3aea4d67c444a8704e39888eab37fc2b4cf95", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8b3aea4d67c444a8704e39888eab37fc2b4cf95", "html_url": "https://github.com/rust-lang/rust/commit/e8b3aea4d67c444a8704e39888eab37fc2b4cf95"}], "stats": {"total": 41, "additions": 26, "deletions": 15}, "files": [{"sha": "0a5b79c36aad86c1326f4959414a1bade713a24e", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/59ff059cfc2d8a4b3edf72644668beffd7bbc6cd/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ff059cfc2d8a4b3edf72644668beffd7bbc6cd/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=59ff059cfc2d8a4b3edf72644668beffd7bbc6cd", "patch": "@@ -161,14 +161,21 @@ impl<T> TypedArena<T> {\n         available_capacity_bytes >= at_least_bytes\n     }\n \n+    /// Ensures there's enough space in the current chunk to fit `len` objects.\n+    #[inline]\n+    fn ensure_capacity(&self, len: usize) {\n+        if !self.can_allocate(len) {\n+            self.grow(len);\n+            debug_assert!(self.can_allocate(len));\n+        }\n+    }\n+\n     #[inline]\n     unsafe fn alloc_raw_slice(&self, len: usize) -> *mut T {\n         assert!(mem::size_of::<T>() != 0);\n         assert!(len != 0);\n \n-        if !self.can_allocate(len) {\n-            self.grow(len);\n-        }\n+        self.ensure_capacity(len);\n \n         let start_ptr = self.ptr.get();\n         self.ptr.set(start_ptr.add(len));\n@@ -203,19 +210,20 @@ impl<T> TypedArena<T> {\n \n         match size_hint {\n             (min, Some(max)) if min == max => {\n-                if min == 0 {\n+                // We know the exact number of elements the iterator will produce here\n+                let len = min;\n+\n+                if len == 0 {\n                     return &mut [];\n                 }\n \n-                if !self.can_allocate(min) {\n-                    self.grow(min);\n-                }\n+                self.ensure_capacity(len);\n \n                 let slice = self.ptr.get();\n \n                 unsafe {\n                     let mut ptr = self.ptr.get();\n-                    for _ in 0..min {\n+                    for _ in 0..len {\n                         // Write into uninitialized memory.\n                         ptr::write(ptr, iter.next().unwrap());\n                         // Advance the pointer.\n@@ -224,7 +232,7 @@ impl<T> TypedArena<T> {\n                         // we destroy the correct amount\n                         self.ptr.set(ptr);\n                     }\n-                    slice::from_raw_parts_mut(slice, min)\n+                    slice::from_raw_parts_mut(slice, len)\n                 }\n             }\n             _ => {\n@@ -239,7 +247,7 @@ impl<T> TypedArena<T> {\n                         let len = vec.len();\n                         let start_ptr = self.alloc_raw_slice(len);\n                         vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n-                        vev.set_len(0);\n+                        vec.set_len(0);\n                         slice::from_raw_parts_mut(start_ptr, len)\n                     }\n                 })\n@@ -488,16 +496,19 @@ impl DroplessArena {\n \n         match size_hint {\n             (min, Some(max)) if min == max => {\n-                if min == 0 {\n+                // We know the exact number of elements the iterator will produce here\n+                let len = min;\n+\n+                if len == 0 {\n                     return &mut []\n                 }\n-                let size = min.checked_mul(mem::size_of::<T>()).unwrap();\n+                let size = len.checked_mul(mem::size_of::<T>()).unwrap();\n                 let mem = self.alloc_raw(size, mem::align_of::<T>()) as *mut _ as *mut T;\n                 unsafe {\n-                    for i in 0..min {\n+                    for i in 0..len {\n                         ptr::write(mem.offset(i as isize), iter.next().unwrap())\n                     }\n-                    slice::from_raw_parts_mut(mem, min)\n+                    slice::from_raw_parts_mut(mem, len)\n                 }\n             }\n             (_, _) => {\n@@ -515,7 +526,7 @@ impl DroplessArena {\n                             mem::align_of::<T>()\n                         ) as *mut _ as *mut T;\n                         vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n-                        vev.set_len(0);\n+                        vec.set_len(0);\n                         slice::from_raw_parts_mut(start_ptr, len)\n                     }\n                 })"}]}