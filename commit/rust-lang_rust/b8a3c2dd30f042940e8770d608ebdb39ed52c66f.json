{"sha": "b8a3c2dd30f042940e8770d608ebdb39ed52c66f", "node_id": "C_kwDOAAsO6NoAKGI4YTNjMmRkMzBmMDQyOTQwZTg3NzBkNjA4ZWJkYjM5ZWQ1MmM2NmY", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-12-04T09:26:24Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-12-04T09:26:24Z"}, "message": "Sync from rust fd02567705326884ddb94535d2ab230a9595dc2a", "tree": {"sha": "6ee26eb1d38bb075908bf9bca3d2e17dd6e685fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ee26eb1d38bb075908bf9bca3d2e17dd6e685fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8a3c2dd30f042940e8770d608ebdb39ed52c66f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8a3c2dd30f042940e8770d608ebdb39ed52c66f", "html_url": "https://github.com/rust-lang/rust/commit/b8a3c2dd30f042940e8770d608ebdb39ed52c66f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e12a882a6762b58a544d45da043a1b311c7fab22", "url": "https://api.github.com/repos/rust-lang/rust/commits/e12a882a6762b58a544d45da043a1b311c7fab22", "html_url": "https://github.com/rust-lang/rust/commit/e12a882a6762b58a544d45da043a1b311c7fab22"}, {"sha": "f1dc349c4bdb201ac8f14cb8c29820cfc0a3f246", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1dc349c4bdb201ac8f14cb8c29820cfc0a3f246", "html_url": "https://github.com/rust-lang/rust/commit/f1dc349c4bdb201ac8f14cb8c29820cfc0a3f246"}], "stats": {"total": 252, "additions": 13, "deletions": 239}, "files": [{"sha": "3f1278de16820e723ab2a4a67da7a465f0b544ec", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b8a3c2dd30f042940e8770d608ebdb39ed52c66f", "patch": "@@ -19,11 +19,6 @@ version = \"1.0.60\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c794e162a5eff65c72ef524dfe393eb923c354e350bb78b9c7383df13f3bc142\"\n \n-[[package]]\n-name = \"ar\"\n-version = \"0.8.0\"\n-source = \"git+https://github.com/bjorn3/rust-ar.git?branch=do_not_remove_cg_clif_ranlib#de9ab0e56bf3a208381d342aa5b60f9ff2891648\"\n-\n [[package]]\n name = \"arrayvec\"\n version = \"0.7.2\"\n@@ -348,7 +343,6 @@ dependencies = [\n name = \"rustc_codegen_cranelift\"\n version = \"0.1.0\"\n dependencies = [\n- \"ar\",\n  \"cranelift-codegen\",\n  \"cranelift-frontend\",\n  \"cranelift-jit\","}, {"sha": "2b216ca072f0096832412085a0eae3fda4dc79ff", "filename": "Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=b8a3c2dd30f042940e8770d608ebdb39ed52c66f", "patch": "@@ -25,7 +25,6 @@ target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n-ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.9.1\"\n libloading = { version = \"0.7.3\", optional = true }\n once_cell = \"1.10.0\""}, {"sha": "2be70e8e421b2961e97b53c99f38c83256940365", "filename": "build_system/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/build_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/build_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Futils.rs?ref=b8a3c2dd30f042940e8770d608ebdb39ed52c66f", "patch": "@@ -207,5 +207,5 @@ pub(crate) fn copy_dir_recursively(from: &Path, to: &Path) {\n }\n \n pub(crate) fn is_ci() -> bool {\n-    env::var(\"CI\").as_ref().map(|val| &**val) == Ok(\"true\")\n+    env::var(\"CI\").as_deref() == Ok(\"true\")\n }"}, {"sha": "5a29bc18def549cd035bb0a1144b5cab54addef4", "filename": "src/archive.rs", "status": "modified", "additions": 5, "deletions": 219, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=b8a3c2dd30f042940e8770d608ebdb39ed52c66f", "patch": "@@ -1,35 +1,15 @@\n-//! Creation of ar archives like for the lib and staticlib crate type\n-\n-use std::collections::BTreeMap;\n-use std::fs::File;\n-use std::io::{self, Read, Seek};\n use std::path::{Path, PathBuf};\n \n-use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n+use rustc_codegen_ssa::back::archive::{\n+    get_native_object_symbols, ArArchiveBuilder, ArchiveBuilder, ArchiveBuilderBuilder,\n+};\n use rustc_session::Session;\n \n-use object::read::archive::ArchiveFile;\n-use object::{Object, ObjectSymbol, ReadCache};\n-\n-#[derive(Debug)]\n-enum ArchiveEntry {\n-    FromArchive { archive_index: usize, file_range: (u64, u64) },\n-    File(PathBuf),\n-}\n-\n pub(crate) struct ArArchiveBuilderBuilder;\n \n impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n-        Box::new(ArArchiveBuilder {\n-            sess,\n-            use_gnu_style_archive: sess.target.archive_format == \"gnu\",\n-            // FIXME fix builtin ranlib on macOS\n-            no_builtin_ranlib: sess.target.is_like_osx,\n-\n-            src_archives: vec![],\n-            entries: vec![],\n-        })\n+        Box::new(ArArchiveBuilder::new(sess, get_native_object_symbols))\n     }\n \n     fn create_dll_import_lib(\n@@ -40,200 +20,6 @@ impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n         _tmpdir: &Path,\n         _is_direct_dependency: bool,\n     ) -> PathBuf {\n-        bug!(\"creating dll imports is not supported\");\n-    }\n-}\n-\n-pub(crate) struct ArArchiveBuilder<'a> {\n-    sess: &'a Session,\n-    use_gnu_style_archive: bool,\n-    no_builtin_ranlib: bool,\n-\n-    src_archives: Vec<File>,\n-    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n-    // the end of an archive for linkers to not get confused.\n-    entries: Vec<(Vec<u8>, ArchiveEntry)>,\n-}\n-\n-impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn add_file(&mut self, file: &Path) {\n-        self.entries.push((\n-            file.file_name().unwrap().to_str().unwrap().to_string().into_bytes(),\n-            ArchiveEntry::File(file.to_owned()),\n-        ));\n-    }\n-\n-    fn add_archive(\n-        &mut self,\n-        archive_path: &Path,\n-        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n-    ) -> std::io::Result<()> {\n-        let read_cache = ReadCache::new(std::fs::File::open(&archive_path)?);\n-        let archive = ArchiveFile::parse(&read_cache).unwrap();\n-        let archive_index = self.src_archives.len();\n-\n-        for entry in archive.members() {\n-            let entry = entry.map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n-            let file_name = String::from_utf8(entry.name().to_vec())\n-                .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n-            if !skip(&file_name) {\n-                self.entries.push((\n-                    file_name.into_bytes(),\n-                    ArchiveEntry::FromArchive { archive_index, file_range: entry.file_range() },\n-                ));\n-            }\n-        }\n-\n-        self.src_archives.push(read_cache.into_inner());\n-        Ok(())\n-    }\n-\n-    fn build(mut self: Box<Self>, output: &Path) -> bool {\n-        enum BuilderKind {\n-            Bsd(ar::Builder<File>),\n-            Gnu(ar::GnuBuilder<File>),\n-        }\n-\n-        let sess = self.sess;\n-\n-        let mut symbol_table = BTreeMap::new();\n-\n-        let mut entries = Vec::new();\n-\n-        for (mut entry_name, entry) in self.entries {\n-            // FIXME only read the symbol table of the object files to avoid having to keep all\n-            // object files in memory at once, or read them twice.\n-            let data = match entry {\n-                ArchiveEntry::FromArchive { archive_index, file_range } => {\n-                    // FIXME read symbols from symtab\n-                    let src_read_cache = &mut self.src_archives[archive_index];\n-\n-                    src_read_cache.seek(io::SeekFrom::Start(file_range.0)).unwrap();\n-                    let mut data = std::vec::from_elem(0, usize::try_from(file_range.1).unwrap());\n-                    src_read_cache.read_exact(&mut data).unwrap();\n-\n-                    data\n-                }\n-                ArchiveEntry::File(file) => std::fs::read(file).unwrap_or_else(|err| {\n-                    sess.fatal(&format!(\n-                        \"error while reading object file during archive building: {}\",\n-                        err\n-                    ));\n-                }),\n-            };\n-\n-            if !self.no_builtin_ranlib {\n-                if symbol_table.contains_key(&entry_name) {\n-                    // The ar crate can't handle creating a symbol table in case of multiple archive\n-                    // members with the same name. Work around this by prepending a number until we\n-                    // get a unique name.\n-                    for i in 1.. {\n-                        let new_name = format!(\"{}_\", i)\n-                            .into_bytes()\n-                            .into_iter()\n-                            .chain(entry_name.iter().copied())\n-                            .collect::<Vec<_>>();\n-                        if !symbol_table.contains_key(&new_name) {\n-                            entry_name = new_name;\n-                            break;\n-                        }\n-                    }\n-                }\n-\n-                match object::File::parse(&*data) {\n-                    Ok(object) => {\n-                        symbol_table.insert(\n-                            entry_name.to_vec(),\n-                            object\n-                                .symbols()\n-                                .filter_map(|symbol| {\n-                                    if symbol.is_undefined() || symbol.is_local() {\n-                                        None\n-                                    } else {\n-                                        symbol.name().map(|name| name.as_bytes().to_vec()).ok()\n-                                    }\n-                                })\n-                                .collect::<Vec<_>>(),\n-                        );\n-                    }\n-                    Err(err) => {\n-                        let err = err.to_string();\n-                        if err == \"Unknown file magic\" {\n-                            // Not an object file; skip it.\n-                        } else if object::read::archive::ArchiveFile::parse(&*data).is_ok() {\n-                            // Nested archive file; skip it.\n-                        } else {\n-                            sess.fatal(&format!(\n-                                \"error parsing `{}` during archive creation: {}\",\n-                                String::from_utf8_lossy(&entry_name),\n-                                err\n-                            ));\n-                        }\n-                    }\n-                }\n-            }\n-\n-            entries.push((entry_name, data));\n-        }\n-\n-        let mut builder = if self.use_gnu_style_archive {\n-            BuilderKind::Gnu(\n-                ar::GnuBuilder::new(\n-                    File::create(output).unwrap_or_else(|err| {\n-                        sess.fatal(&format!(\n-                            \"error opening destination during archive building: {}\",\n-                            err\n-                        ));\n-                    }),\n-                    entries.iter().map(|(name, _)| name.clone()).collect(),\n-                    ar::GnuSymbolTableFormat::Size32,\n-                    symbol_table,\n-                )\n-                .unwrap(),\n-            )\n-        } else {\n-            BuilderKind::Bsd(\n-                ar::Builder::new(\n-                    File::create(output).unwrap_or_else(|err| {\n-                        sess.fatal(&format!(\n-                            \"error opening destination during archive building: {}\",\n-                            err\n-                        ));\n-                    }),\n-                    symbol_table,\n-                )\n-                .unwrap(),\n-            )\n-        };\n-\n-        let any_members = !entries.is_empty();\n-\n-        // Add all files\n-        for (entry_name, data) in entries.into_iter() {\n-            let header = ar::Header::new(entry_name, data.len() as u64);\n-            match builder {\n-                BuilderKind::Bsd(ref mut builder) => builder.append(&header, &mut &*data).unwrap(),\n-                BuilderKind::Gnu(ref mut builder) => builder.append(&header, &mut &*data).unwrap(),\n-            }\n-        }\n-\n-        // Finalize archive\n-        std::mem::drop(builder);\n-\n-        if self.no_builtin_ranlib {\n-            let ranlib = crate::toolchain::get_toolchain_binary(self.sess, \"ranlib\");\n-\n-            // Run ranlib to be able to link the archive\n-            let status = std::process::Command::new(ranlib)\n-                .arg(output)\n-                .status()\n-                .expect(\"Couldn't run ranlib\");\n-\n-            if !status.success() {\n-                self.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n-            }\n-        }\n-\n-        any_members\n+        unimplemented!(\"creating dll imports is not yet supported\");\n     }\n }"}, {"sha": "45522fb1a4cab422fc5713905fe8f45d23fb2b49", "filename": "src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=b8a3c2dd30f042940e8770d608ebdb39ed52c66f", "patch": "@@ -2,7 +2,7 @@ use std::env;\n use std::str::FromStr;\n \n fn bool_env_var(key: &str) -> bool {\n-    env::var(key).as_ref().map(|val| &**val) == Ok(\"1\")\n+    env::var(key).as_deref() == Ok(\"1\")\n }\n \n /// The mode to use for compilation."}, {"sha": "9b29b17e3a1110df46a37f47b3db75ab80580f38", "filename": "src/constant.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=b8a3c2dd30f042940e8770d608ebdb39ed52c66f", "patch": "@@ -255,9 +255,9 @@ pub(crate) fn data_id_for_alloc_id(\n     mutability: rustc_hir::Mutability,\n ) -> DataId {\n     cx.todo.push(TodoItem::Alloc(alloc_id));\n-    *cx.anon_allocs.entry(alloc_id).or_insert_with(|| {\n-        module.declare_anonymous_data(mutability == rustc_hir::Mutability::Mut, false).unwrap()\n-    })\n+    *cx.anon_allocs\n+        .entry(alloc_id)\n+        .or_insert_with(|| module.declare_anonymous_data(mutability.is_mut(), false).unwrap())\n }\n \n fn data_id_for_static(\n@@ -341,12 +341,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                     }\n                 };\n                 let data_id = *cx.anon_allocs.entry(alloc_id).or_insert_with(|| {\n-                    module\n-                        .declare_anonymous_data(\n-                            alloc.inner().mutability == rustc_hir::Mutability::Mut,\n-                            false,\n-                        )\n-                        .unwrap()\n+                    module.declare_anonymous_data(alloc.inner().mutability.is_mut(), false).unwrap()\n                 });\n                 (data_id, alloc, None)\n             }"}, {"sha": "fe8af21ac6de567cff94a34ec13e625f8876fe4a", "filename": "src/value_and_place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a3c2dd30f042940e8770d608ebdb39ed52c66f/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=b8a3c2dd30f042940e8770d608ebdb39ed52c66f", "patch": "@@ -108,8 +108,8 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     // FIXME remove\n-    // Forces the data value of a dyn* value to the stack and returns a pointer to it as well as the\n-    // vtable pointer.\n+    /// Forces the data value of a dyn* value to the stack and returns a pointer to it as well as the\n+    /// vtable pointer.\n     pub(crate) fn dyn_star_force_data_on_stack(\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,"}]}