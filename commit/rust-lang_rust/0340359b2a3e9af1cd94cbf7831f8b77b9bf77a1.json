{"sha": "0340359b2a3e9af1cd94cbf7831f8b77b9bf77a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNDAzNTliMmEzZTlhZjFjZDk0Y2JmNzgzMWY4Yjc3YjliZjc3YTE=", "commit": {"author": {"name": "Dylan McKay", "email": "me@dylanmckay.io", "date": "2020-05-17T04:36:23Z"}, "committer": {"name": "Dylan McKay", "email": "me@dylanmckay.io", "date": "2020-06-09T05:41:04Z"}, "message": "[AVR] Update ABI type classification logic to match the the AVR-Clang ABI\n\nThis patch brings the AVR calling convention argument classification\nlogic in line with AVR Clang's behaviour.\n\nAVR-Clang currently uses the `clang::DefaultABIInfo` ABI implementation.\nThis calling convention promotes all aggregates to indirect, no matter their\nsize.\n\nIt is also unnecessary to perform any integer width extension for AVR as\nthe minimum argument size matches the minimum describable size of\nabi::Primitive::Int - 8 bits.\n\nAt some point in the future, an AVR-GCC compatible argument\nclassification implementation should be adopted in both Clang and Rust.", "tree": {"sha": "ef9e4760ac137c6bf453f9d3270b2c92b43d0bf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef9e4760ac137c6bf453f9d3270b2c92b43d0bf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0340359b2a3e9af1cd94cbf7831f8b77b9bf77a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0340359b2a3e9af1cd94cbf7831f8b77b9bf77a1", "html_url": "https://github.com/rust-lang/rust/commit/0340359b2a3e9af1cd94cbf7831f8b77b9bf77a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0340359b2a3e9af1cd94cbf7831f8b77b9bf77a1/comments", "author": {"login": "dylanmckay", "id": 7722159, "node_id": "MDQ6VXNlcjc3MjIxNTk=", "avatar_url": "https://avatars.githubusercontent.com/u/7722159?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylanmckay", "html_url": "https://github.com/dylanmckay", "followers_url": "https://api.github.com/users/dylanmckay/followers", "following_url": "https://api.github.com/users/dylanmckay/following{/other_user}", "gists_url": "https://api.github.com/users/dylanmckay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylanmckay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylanmckay/subscriptions", "organizations_url": "https://api.github.com/users/dylanmckay/orgs", "repos_url": "https://api.github.com/users/dylanmckay/repos", "events_url": "https://api.github.com/users/dylanmckay/events{/privacy}", "received_events_url": "https://api.github.com/users/dylanmckay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dylanmckay", "id": 7722159, "node_id": "MDQ6VXNlcjc3MjIxNTk=", "avatar_url": "https://avatars.githubusercontent.com/u/7722159?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylanmckay", "html_url": "https://github.com/dylanmckay", "followers_url": "https://api.github.com/users/dylanmckay/followers", "following_url": "https://api.github.com/users/dylanmckay/following{/other_user}", "gists_url": "https://api.github.com/users/dylanmckay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylanmckay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylanmckay/subscriptions", "organizations_url": "https://api.github.com/users/dylanmckay/orgs", "repos_url": "https://api.github.com/users/dylanmckay/repos", "events_url": "https://api.github.com/users/dylanmckay/events{/privacy}", "received_events_url": "https://api.github.com/users/dylanmckay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f0652ff67dc477227b48a3ccb3d398e0c492909", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f0652ff67dc477227b48a3ccb3d398e0c492909", "html_url": "https://github.com/rust-lang/rust/commit/1f0652ff67dc477227b48a3ccb3d398e0c492909"}], "stats": {"total": 36, "additions": 31, "deletions": 5}, "files": [{"sha": "c1f7a1e3af58612af767fb4bcf15e8d685796e5f", "filename": "src/librustc_target/abi/call/avr.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0340359b2a3e9af1cd94cbf7831f8b77b9bf77a1/src%2Flibrustc_target%2Fabi%2Fcall%2Favr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0340359b2a3e9af1cd94cbf7831f8b77b9bf77a1/src%2Flibrustc_target%2Fabi%2Fcall%2Favr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Favr.rs?ref=0340359b2a3e9af1cd94cbf7831f8b77b9bf77a1", "patch": "@@ -1,20 +1,46 @@\n-#![allow(non_upper_case_globals)]\n+//! LLVM-frontend specific AVR calling convention implementation.\n+//!\n+//! # Current calling convention ABI\n+//!\n+//! Inherited from Clang's `clang::DefaultABIInfo` implementation - self described\n+//! as\n+//!\n+//! > the default implementation for ABI specific details. This implementation\n+//! > provides information which results in\n+//! > self-consistent and sensible LLVM IR generation, but does not\n+//! > conform to any particular ABI.\n+//! >\n+//! > - Doxygen Doxumentation of `clang::DefaultABIInfo`\n+//!\n+//! This calling convention may not match AVR-GCC in all cases.\n+//!\n+//! In the future, an AVR-GCC compatible argument classification ABI should be\n+//! adopted in both Rust and Clang.\n+//!\n+//! *NOTE*: Currently, this module implements the same calling convention\n+//! that clang with AVR currently does - the default, simple, unspecialized\n+//! ABI implementation available to all targets. This ABI is not\n+//! binary-compatible with AVR-GCC. Once LLVM [PR46140](https://bugs.llvm.org/show_bug.cgi?id=46140)\n+//! is completed, this module should be updated to match so that both Clang\n+//! and Rust emit code to the same AVR-GCC compatible ABI.\n+//!\n+//! In particular, both Clang and Rust may not have the same semantics\n+//! when promoting arguments to indirect references as AVR-GCC. It is important\n+//! to note that the core AVR ABI implementation within LLVM itself is ABI\n+//! compatible with AVR-GCC - Rust and AVR-GCC only differ in the small amount\n+//! of compiler frontend specific calling convention logic implemented here.\n \n use crate::abi::call::{ArgAbi, FnAbi};\n \n fn classify_ret_ty<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n     if ret.layout.is_aggregate() {\n         ret.make_indirect();\n-    } else {\n-        ret.extend_integer_width_to(8); // Is 8 correct?\n     }\n }\n \n fn classify_arg_ty<Ty>(arg: &mut ArgAbi<'_, Ty>) {\n     if arg.layout.is_aggregate() {\n         arg.make_indirect();\n-    } else {\n-        arg.extend_integer_width_to(8);\n     }\n }\n "}]}