{"sha": "b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YzczNjA1ZWFkMGRjMjdlYjA5ZTVmNTg2MDMyNmIyY2YyYzVjZDE=", "commit": {"author": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2011-06-08T07:59:34Z"}, "committer": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2011-06-08T07:59:34Z"}, "message": "Merge remote branch 'graydon/master'", "tree": {"sha": "931ac195a7d135b9438966f6ee038d67d6895d08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/931ac195a7d135b9438966f6ee038d67d6895d08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "html_url": "https://github.com/rust-lang/rust/commit/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/comments", "author": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0788442019daa6509ebc3b0d7dac0ad1d4b424f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0788442019daa6509ebc3b0d7dac0ad1d4b424f", "html_url": "https://github.com/rust-lang/rust/commit/a0788442019daa6509ebc3b0d7dac0ad1d4b424f"}, {"sha": "0857d22c046c90c3e6ee3adebcee360b2d298341", "url": "https://api.github.com/repos/rust-lang/rust/commits/0857d22c046c90c3e6ee3adebcee360b2d298341", "html_url": "https://github.com/rust-lang/rust/commit/0857d22c046c90c3e6ee3adebcee360b2d298341"}], "stats": {"total": 3118, "additions": 1619, "deletions": 1499}, "files": [{"sha": "362b97ea03656903c1b31d9d6b07fe6c89eb32a7", "filename": "Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -144,9 +144,9 @@ COMPILER_INPUTS := $(wildcard $(addprefix $(S)src/comp/, \\\n ######################################################################\n \n LREQ := rt/$(CFG_RUNTIME) rustllvm/$(CFG_RUSTLLVM)\n-SREQ0 := stage0/rustc$(X) $(LREQ) stage1/glue.o stage1/$(CFG_STDLIB)\n-SREQ1 := stage1/rustc$(X) $(LREQ) stage2/glue.o stage2/$(CFG_STDLIB)\n-SREQ2 := stage2/rustc$(X) $(LREQ) stage3/glue.o stage3/$(CFG_STDLIB)\n+SREQ0 := stage0/rustc$(X) $(LREQ) rt/main.a stage1/glue.o stage1/$(CFG_STDLIB)\n+SREQ1 := stage1/rustc$(X) $(LREQ) rt/main.a stage2/glue.o stage2/$(CFG_STDLIB)\n+SREQ2 := stage2/rustc$(X) $(LREQ) rt/main.a stage3/glue.o stage3/$(CFG_STDLIB)\n \n \n ######################################################################"}, {"sha": "305b06b5e0a380c8bce53e8d166d004e0a7e9375", "filename": "mk/clean.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -28,6 +28,8 @@ clean:\n \t$(Q)rm -f stage3/rustc$(X) stage3/$(CFG_STDLIB) stage3/glue*\n \t$(Q)rm -f rustllvm/$(CFG_RUSTLLVM) rustllvm/rustllvmbits.a\n \t$(Q)rm -f rt/$(CFG_RUNTIME)\n+\t$(Q)rm -f rt/main.o\n+\t$(Q)rm -f rt/main.a\n \t$(Q)rm -Rf $(PKG_NAME)-*.tar.gz dist\n \t$(Q)rm -f $(foreach ext,o a d bc s exe,$(wildcard stage*/*.$(ext)))\n \t$(Q)rm -Rf $(foreach ext,out out.tmp                      \\"}, {"sha": "1cc6dfb57f45f52d8c813332c63af5e74aaa78a7", "filename": "mk/rt.mk", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -76,6 +76,18 @@ rt/%.o: rt/%.s $(MKFILES)\n \t@$(call E, compile: $@)\n \t$(Q)$(call CFG_COMPILE_C, $@, $(RUNTIME_INCS)) $<\n \n+ifdef CFG_WINDOWSY\n+rt/main.ll: rt/main.ll.in\n+\tsed 's/MAIN/WinMain@16/' < $^ > $@\n+else\n+rt/main.ll: rt/main.ll.in\n+\tsed 's/MAIN/main/' < $^ > $@\n+endif\n+\n+rt/main.a: rt/main.o\n+\trm -f $@\n+\tar crs $@ $^\n+\n rt/%.o: rt/%.ll $(MKFILES)\n \t@$(call E, llc: $@)\n \t$(Q)$(LLC) -filetype=obj -relocation-model=pic -march=x86 -o $@ $<"}, {"sha": "c98882e41a872649e53351d05e188cbac17ef751", "filename": "mk/stage1.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/mk%2Fstage1.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/mk%2Fstage1.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage1.mk?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -44,7 +44,7 @@ stage1/%.o: stage1/%.s\n stage1/%$(X): stage1/%.o  $(SREQ0)\n \t@$(call E, link [gcc]: $@)\n \t$(Q)gcc $(CFG_GCCISH_CFLAGS) stage1/glue.o -o $@ $< \\\n-      -Lstage1 -Lrustllvm -Lrt -lrustrt -lrustllvm -lstd -lm\n+      -Lstage1 -Lrustllvm -Lrt rt/main.a -lrustrt -lrustllvm -lstd -lm\n \t@# dsymutil sometimes fails or prints a warning, but the\n \t@# program still runs.  Since it simplifies debugging other\n \t@# programs, I\\'ll live with the noise."}, {"sha": "0d87400c1e2983e83e101687d0ed051653b7814a", "filename": "mk/stage2.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/mk%2Fstage2.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/mk%2Fstage2.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage2.mk?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -44,7 +44,7 @@ stage2/%.o: stage2/%.s\n stage2/%$(X): stage2/%.o  $(SREQ1)\n \t@$(call E, link [gcc]: $@)\n \t$(Q)gcc $(CFG_GCCISH_CFLAGS) stage2/glue.o -o $@ $< \\\n-      -Lstage2 -Lrustllvm -Lrt -lrustrt -lrustllvm -lstd -lm\n+      -Lstage2 -Lrustllvm -Lrt rt/main.a -lrustrt -lrustllvm -lstd -lm\n \t@# dsymutil sometimes fails or prints a warning, but the\n \t@# program still runs.  Since it simplifies debugging other\n \t@# programs, I\\'ll live with the noise."}, {"sha": "77d09440883e750c40c9a453d4f32cf1208d935c", "filename": "mk/stage3.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/mk%2Fstage3.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/mk%2Fstage3.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage3.mk?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -23,7 +23,7 @@ stage3/rustc.o: $(COMPILER_CRATE) $(COMPILER_INPUTS) $(SREQ2)\n \t$(STAGE2) -c -o $@ $<\n \n stage3/glue.o: stage2/rustc$(X) stage2/$(CFG_STDLIB) stage2/intrinsics.bc \\\n-                rustllvm/$(CFG_RUSTLLVM) rt/$(CFG_RUNTIME)\n+               rustllvm/$(CFG_RUSTLLVM) rt/$(CFG_RUNTIME)\n \t@$(call E, generate: $@)\n \t$(STAGE2) -c -o $@ --glue\n \n@@ -44,7 +44,7 @@ stage3/%.o: stage3/%.s\n stage3/%$(X): stage3/%.o  $(SREQ2)\n \t@$(call E, link [gcc]: $@)\n \t$(Q)gcc $(CFG_GCCISH_CFLAGS) stage3/glue.o -o $@ $< \\\n-      -Lstage3 -Lrustllvm -Lrt -lrustrt -lrustllvm -lstd -lm\n+      -Lstage3 -Lrustllvm -Lrt rt/main.a -lrustrt -lrustllvm -lstd -lm\n \t@# dsymutil sometimes fails or prints a warning, but the\n \t@# program still runs.  Since it simplifies debugging other\n \t@# programs, I\\'ll live with the noise."}, {"sha": "db7a3dd4d33cf4c2140a2fe3111fbef46b3ddb5c", "filename": "mk/tests.mk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -185,7 +185,7 @@ compile-check: tidy \\\n %.stage0$(X): %.stage0.o  $(SREQ0)\n \t@$(call E, link [gcc]: $@)\n \t$(Q)gcc $(CFG_GCCISH_CFLAGS) stage1/glue.o -o $@ $< \\\n-      -Lstage1 -Lrt -lrustrt -lstd -lm\n+      -Lstage1 -Lrt rt/main.a -lrustrt -lstd -lm\n \t@# dsymutil sometimes fails or prints a warning, but the\n \t@# program still runs.  Since it simplifies debugging other\n \t@# programs, I\\'ll live with the noise.\n@@ -194,7 +194,7 @@ compile-check: tidy \\\n %.stage1$(X): %.stage1.o $(SREQ1)\n \t@$(call E, link [gcc]: $@)\n \t$(Q)gcc $(CFG_GCCISH_CFLAGS) stage2/glue.o -o $@ $< \\\n-      -Lstage2 -Lrt -lrustrt -lstd -lm\n+      -Lstage2 -Lrt rt/main.a -lrustrt -lstd -lm\n \t@# dsymutil sometimes fails or prints a warning, but the\n \t@# program still runs.  Since it simplifies debugging other\n \t@# programs, I\\'ll live with the noise.\n@@ -203,7 +203,7 @@ compile-check: tidy \\\n %.stage2$(X): %.stage2.o $(SREQ2)\n \t@$(call E, link [gcc]: $@)\n \t$(Q)gcc $(CFG_GCCISH_CFLAGS) stage3/glue.o -o $@ $< \\\n-      -Lstage3 -Lrt -lrustrt -lstd -lm\n+      -Lstage3 -Lrt rt/main.a -lrustrt -lstd -lm\n \t@# dsymutil sometimes fails or prints a warning, but the\n \t@# program still runs.  Since it simplifies debugging other\n \t@# programs, I\\'ll live with the noise."}, {"sha": "6469bbd3ced259a967adfe4f7aab274951cbe6f7", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 244, "deletions": 2, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -1,8 +1,18 @@\n import driver::session;\n import lib::llvm::llvm;\n import middle::trans;\n+import middle::metadata;\n+import middle::ty;\n import std::str;\n import std::fs;\n+import std::vec;\n+import std::option;\n+import option::some;\n+import option::none;\n+import std::sha1::sha1;\n+import std::sort;\n+import trans::crate_ctxt;\n+import front::ast;\n \n import lib::llvm::llvm::ModuleRef;\n import lib::llvm::llvm::ValueRef;\n@@ -49,7 +59,7 @@ fn link_intrinsics(session::session sess, ModuleRef llmod) {\n \n     auto linkres = llvm::LLVMLinkModules(llmod, llintrinsicsmod);\n     llvm::LLVMDisposeModule(llintrinsicsmod);\n-    \n+\n     if (linkres == False) {\n         llvm_err(sess, \"couldn't link the module with the intrinsics\");\n         fail;\n@@ -58,7 +68,7 @@ fn link_intrinsics(session::session sess, ModuleRef llmod) {\n \n mod write {\n     fn is_object_or_assembly_or_exe(output_type ot) -> bool {\n-        if ( (ot == output_type_assembly) || \n+        if ( (ot == output_type_assembly) ||\n              (ot == output_type_object) ||\n              (ot == output_type_exe) ) {\n             ret true;\n@@ -218,3 +228,235 @@ mod write {\n     }\n }\n \n+/*\n+ * Name mangling and its relationship to metadata. This is complex. Read\n+ * carefully.\n+ *\n+ * The semantic model of Rust linkage is, broadly, that \"there's no global\n+ * namespace\" between crates. Our aim is to preserve the illusion of this\n+ * model despite the fact that it's not *quite* possible to implement on\n+ * modern linkers. We initially didn't use system linkers at all, but have\n+ * been convinced of their utility.\n+ *\n+ * There are a few issues to handle:\n+ *\n+ *  - Linkers operate on a flat namespace, so we have to flatten names.\n+ *    We do this using the C++ namespace-mangling technique. Foo::bar\n+ *    symbols and such.\n+ *\n+ *  - Symbols with the same name but different types need to get different\n+ *    linkage-names. We do this by hashing a string-encoding of the type into\n+ *    a fixed-size (currently 16-byte hex) cryptographic hash function (CHF:\n+ *    we use SHA1) to \"prevent collisions\". This is not airtight but 16 hex\n+ *    digits on uniform probability means you're going to need 2**32 same-name\n+ *    symbols in the same process before you're even hitting birthday-paradox\n+ *    collision probability.\n+ *\n+ *  - Symbols in dirrerent crates but with same names \"within\" the crate need\n+ *    to get different linkage-names.\n+ *\n+ * So here is what we do:\n+ *\n+ *  - Separate the meta tags into two sets: exported and local. Only work with\n+ *    the exported ones when considering linkage.\n+ *\n+ *  - Consider two exported tags as special (and madatory): name and vers.\n+ *    Every crate gets them; if it doesn't name them explicitly we infer them\n+ *    as basename(crate) and \"0.1\", respectively. Call these CNAME, CVERS.\n+ *\n+ *  - Define CMETA as all the non-name, non-vers exported meta tags in the\n+ *    crate (in sorted order).\n+ *\n+ *  - Define CMH as hash(CMETA).\n+ *\n+ *  - Compile our crate to lib CNAME-CMH-CVERS.so\n+ *\n+ *  - Define STH(sym) as hash(CNAME, CMH, type_str(sym))\n+ *\n+ *  - Suffix a mangled sym with ::STH@CVERS, so that it is unique in the\n+ *    name, non-name metadata, and type sense, and versioned in the way\n+ *    system linkers understand.\n+ *\n+ */\n+\n+\n+iter crate_export_metas(ast::crate c) -> @ast::meta_item {\n+    for (@ast::crate_directive cdir in c.node.directives) {\n+        alt (cdir.node) {\n+            case (ast::cdir_meta(?v, ?mis)) {\n+                if (v == ast::export_meta) {\n+                    for (@ast::meta_item mi in mis) {\n+                        put mi;\n+                    }\n+                }\n+            }\n+            case (_) {}\n+        }\n+    }\n+}\n+fn get_crate_meta(&session::session sess,\n+                  &ast::crate c, str k, str default,\n+                  bool warn_default) -> str {\n+    let vec[@ast::meta_item] v = [];\n+    for each (@ast::meta_item mi in crate_export_metas(c)) {\n+        if (mi.node.name == k) {\n+            v += [mi];\n+        }\n+    }\n+    alt (vec::len(v)) {\n+        case (0u) {\n+            if (warn_default) {\n+                sess.warn(#fmt(\"missing meta '%s', using '%s' as default\",\n+                               k, default));\n+            }\n+            ret default;\n+        }\n+        case (1u) {\n+            ret v.(0).node.value;\n+        }\n+        case (_) {\n+            sess.span_err(v.(1).span, #fmt(\"duplicate meta '%s'\", k));\n+        }\n+    }\n+}\n+\n+// This calculates CMH as defined above\n+fn crate_meta_extras_hash(sha1 sha, &ast::crate crate) -> str {\n+    fn lteq(&@ast::meta_item ma,\n+            &@ast::meta_item mb) -> bool {\n+        ret ma.node.name <= mb.node.name;\n+    }\n+\n+    fn len_and_str(&str s) -> str {\n+        ret #fmt(\"%u_%s\", str::byte_len(s), s);\n+    }\n+\n+    let vec[mutable @ast::meta_item] v = [mutable];\n+    for each (@ast::meta_item mi in crate_export_metas(crate)) {\n+        if (mi.node.name != \"name\" &&\n+            mi.node.name != \"vers\") {\n+            v += [mutable mi];\n+        }\n+    }\n+    sort::quick_sort(lteq, v);\n+    sha.reset();\n+    for (@ast::meta_item m in v) {\n+        sha.input_str(len_and_str(m.node.name));\n+        sha.input_str(len_and_str(m.node.value));\n+    }\n+    ret truncated_sha1_result(sha);\n+}\n+\n+fn crate_meta_name(&session::session sess, &ast::crate crate,\n+                       &str output) -> str {\n+    auto os = str::split(fs::basename(output), '.' as u8);\n+    assert vec::len(os) >= 2u;\n+    vec::pop(os);\n+    ret get_crate_meta(sess, crate, \"name\", str::connect(os, \".\"),\n+                       sess.get_opts().shared);\n+}\n+\n+fn crate_meta_vers(&session::session sess, &ast::crate crate) -> str {\n+    ret get_crate_meta(sess, crate, \"vers\", \"0.0\",\n+                       sess.get_opts().shared);\n+}\n+\n+fn truncated_sha1_result(sha1 sha) -> str {\n+    ret str::substr(sha.result_str(), 0u, 16u);\n+}\n+\n+\n+\n+// This calculates STH for a symbol, as defined above\n+fn symbol_hash(ty::ctxt tcx, sha1 sha, &ty::t t,\n+               str crate_meta_name,\n+               str crate_meta_extras_hash) -> str {\n+    // NB: do *not* use abbrevs here as we want the symbol names\n+    // to be independent of one another in the crate.\n+    auto cx = @rec(ds=metadata::def_to_str, tcx=tcx,\n+                   abbrevs=metadata::ac_no_abbrevs);\n+    sha.reset();\n+    sha.input_str(crate_meta_name);\n+    sha.input_str(\"-\");\n+    sha.input_str(crate_meta_name);\n+    sha.input_str(\"-\");\n+    sha.input_str(metadata::Encode::ty_str(cx, t));\n+    auto hash = truncated_sha1_result(sha);\n+    // Prefix with _ so that it never blends into adjacent digits\n+    ret \"_\" + hash;\n+}\n+\n+fn get_symbol_hash(&@crate_ctxt ccx, &ty::t t) -> str {\n+    auto hash = \"\";\n+    alt (ccx.type_sha1s.find(t)) {\n+        case (some(?h)) { hash = h; }\n+        case (none) {\n+            hash = symbol_hash(ccx.tcx, ccx.sha, t,\n+                               ccx.crate_meta_name,\n+                               ccx.crate_meta_extras_hash);\n+            ccx.type_sha1s.insert(t, hash);\n+        }\n+    }\n+    ret hash;\n+}\n+\n+\n+fn mangle(&vec[str] ss) -> str {\n+\n+    // Follow C++ namespace-mangling style\n+\n+    auto n = \"_ZN\"; // Begin name-sequence.\n+\n+    for (str s in ss) {\n+        n += #fmt(\"%u%s\", str::byte_len(s), s);\n+    }\n+\n+    n += \"E\"; // End name-sequence.\n+    ret n;\n+}\n+\n+\n+fn exported_name(&vec[str] path, &str hash, &str vers) -> str {\n+    // FIXME: versioning isn't working yet\n+    ret mangle(path + [hash]); //  + \"@\" + vers;\n+}\n+\n+fn mangle_exported_name(&@crate_ctxt ccx, &vec[str] path,\n+                        &ty::t t) -> str {\n+    auto hash = get_symbol_hash(ccx, t);\n+    ret exported_name(path, hash, ccx.crate_meta_vers);\n+}\n+\n+fn mangle_internal_name_by_type_only(&@crate_ctxt ccx, &ty::t t,\n+                                     &str name) -> str {\n+    auto f = metadata::def_to_str;\n+    auto cx = @rec(ds=f, tcx=ccx.tcx, abbrevs=metadata::ac_no_abbrevs);\n+    auto s = ty::ty_to_short_str(ccx.tcx, t);\n+\n+    auto hash = get_symbol_hash(ccx, t);\n+    ret mangle([name, s, hash]);\n+}\n+\n+fn mangle_internal_name_by_path_and_seq(&@crate_ctxt ccx, &vec[str] path,\n+                                       &str flav) -> str {\n+    ret mangle(path + [ccx.names.next(flav)]);\n+}\n+\n+fn mangle_internal_name_by_path(&@crate_ctxt ccx, &vec[str] path) -> str {\n+    ret mangle(path);\n+}\n+\n+fn mangle_internal_name_by_seq(&@crate_ctxt ccx, &str flav) -> str {\n+    ret ccx.names.next(flav);\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "a33416c8638b4791a736f62aa499ea18cbcfd3b0", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -125,7 +125,7 @@ fn pretty_print_input(session::session sess, eval::env env, str input,\n                       pp_mode ppm) {\n     auto def = tup(ast::local_crate, 0);\n     auto p = front::parser::new_parser(sess, env, def, input, 0u, 0u);\n-    auto crate = front::parser::parse_crate_from_source_file(p);\n+    auto crate = parse_input(sess, p, input);\n \n     auto mode;\n     alt (ppm) {"}, {"sha": "e0080ca2651560c42c84d85efa3cc5c76b9a4a06", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -6,6 +6,9 @@ import std::uint;\n import std::term;\n import std::io;\n import std::map;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n \n tag os {\n     os_win32;\n@@ -48,9 +51,16 @@ fn span_to_str(span sp, codemap::codemap cm) -> str {\n               lo.col, hi.line, hi.col));\n }\n \n-fn emit_diagnostic(span sp, str msg, str kind, u8 color,\n+fn emit_diagnostic(option::t[span] sp, str msg, str kind, u8 color,\n                    codemap::codemap cm) {\n-    io::stdout().write_str(span_to_str(sp, cm) + \": \");\n+    auto ss = \"<input>:0:0:0:0\";\n+    alt (sp) {\n+        case (some(?ssp)) {\n+            ss = span_to_str(ssp, cm);\n+        }\n+        case (none) {}\n+    }\n+    io::stdout().write_str(ss + \": \");\n \n     if (term::color_supported()) {\n         term::fg(io::stdout().get_buf_writer(), color);\n@@ -85,12 +95,12 @@ state obj session(ast::crate_num cnum,\n \n     fn span_err(span sp, str msg) -> ! {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        emit_diagnostic(sp, msg, \"error\", 9u8, cm);\n+        emit_diagnostic(some(sp), msg, \"error\", 9u8, cm);\n         fail;\n     }\n \n     fn err(str msg) -> ! {\n-        log_err #fmt(\"error: %s\", msg);\n+        emit_diagnostic(none[span], msg, \"error\", 9u8, cm);\n         fail;\n     }\n \n@@ -103,29 +113,32 @@ state obj session(ast::crate_num cnum,\n \n     fn span_warn(span sp, str msg) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        emit_diagnostic(sp, msg, \"warning\", 11u8, cm);\n+        emit_diagnostic(some(sp), msg, \"warning\", 11u8, cm);\n+    }\n+\n+    fn warn(str msg) {\n+        emit_diagnostic(none[span], msg, \"warning\", 11u8, cm);\n     }\n \n     fn span_note(span sp, str msg) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        emit_diagnostic(sp, msg, \"note\", 10u8, cm);\n+        emit_diagnostic(some(sp), msg, \"note\", 10u8, cm);\n+    }\n+\n+    fn span_bug(span sp, str msg) -> ! {\n+        self.span_err(sp, #fmt(\"internal compiler error %s\", msg));\n     }\n \n     fn bug(str msg) -> ! {\n-        log_err #fmt(\"error: internal compiler error %s\", msg);\n-        fail;\n+        self.err(#fmt(\"internal compiler error %s\", msg));\n     }\n \n     fn span_unimpl(span sp, str msg) -> ! {\n-        // FIXME: Use constants, but rustboot doesn't know how to export them.\n-        emit_diagnostic(sp, \"internal compiler error: unimplemented \" + msg,\n-                        \"error\", 9u8, cm);\n-        fail;\n+        self.span_bug(sp, \"unimplemented \" + msg);\n     }\n-    \n+\n     fn unimpl(str msg) -> ! {\n-        log_err #fmt(\"error: unimplemented %s\", msg);\n-        fail;\n+        self.bug(\"unimplemented \" + msg);\n     }\n \n     fn get_external_crate(int num) -> crate_metadata {"}, {"sha": "f670c2760a7c5b13c17bb1617129648cf4bd3bf0", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -71,6 +71,11 @@ type crate = spanned[crate_];\n type crate_ = rec(vec[@crate_directive] directives,\n                   _mod module);\n \n+tag meta_visibility {\n+    export_meta;\n+    local_meta;\n+}\n+\n tag crate_directive_ {\n     cdir_expr(@expr);\n     // FIXME: cdir_let should be eliminated\n@@ -80,7 +85,7 @@ tag crate_directive_ {\n     cdir_src_mod(ident, option::t[filename]);\n     cdir_dir_mod(ident, option::t[filename], vec[@crate_directive]);\n     cdir_view_item(@view_item);\n-    cdir_meta(vec[@meta_item]);\n+    cdir_meta(meta_visibility, vec[@meta_item]);\n     cdir_syntax(path);\n     cdir_auth(path, _auth);\n }"}, {"sha": "a8e881ee036c3605003925da38b5171bdfb6fc52", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -418,8 +418,13 @@ fn eval_crate_directive(ctx cx,\n             vec::push[@ast::view_item](view_items, vi);\n         }\n \n-        case (ast::cdir_meta(?mi)) {\n-            cx.sess.add_metadata(mi);\n+        case (ast::cdir_meta(?vi, ?mi)) {\n+            // FIXME: we should actually record, for documentation-sake,\n+            // the metadata that's not exported. It would be nice to have\n+            // compiled-in to the target crate, not just in theh AST.\n+            if (vi == ast::export_meta) {\n+                cx.sess.add_metadata(mi);\n+            }\n         }\n \n         case (ast::cdir_syntax(?pth)) {}"}, {"sha": "b84a740a917de519e4352d1ad7b9c7a7a962f8ee", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -2362,10 +2362,14 @@ fn parse_crate_directive(&parser p) -> ast::crate_directive\n         expect(p, token::SEMI);\n         ret spanned(lo, hi, ast::cdir_auth(n, a));\n     } else if (eat_word(p, \"meta\")) {\n+        auto mv = ast::local_meta;\n+        if (eat_word(p, \"export\")) {\n+            mv = ast::export_meta;\n+        }\n         auto mis = parse_meta(p);\n         auto hi = p.get_hi_pos();\n         expect(p, token::SEMI);\n-        ret spanned(lo, hi, ast::cdir_meta(mis));\n+        ret spanned(lo, hi, ast::cdir_meta(mv, mis));\n     } else if (eat_word(p, \"mod\")) {\n         auto id = parse_ident(p);\n         auto file_opt = none[filename];"}, {"sha": "59f3cf56387c529841f0bd9982b2c10ccb2bc2e1", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -230,17 +230,6 @@ mod Encode {\n             }\n             case (ty::ty_type) {w.write_char('Y');}\n             case (ty::ty_task) {w.write_char('a');}\n-\n-            // These two don't appear in crate metadata, but are here because\n-            // `hash_ty()` uses this function.\n-            case (ty::ty_bound_param(?id)) {\n-                w.write_char('o');\n-                w.write_str(common::uistr(id));\n-            }\n-            case (ty::ty_local(?def)) {\n-                w.write_char('L');\n-                w.write_str(cx.ds(def));\n-            }\n         }\n     }\n "}, {"sha": "01192deb8da7f7edbda91a1b91084d3ea66bc050", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 111, "deletions": 197, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -6,7 +6,7 @@\n // particular definition to the LLVM IR output we're producing.\n //\n // Hopefully useful general knowledge about trans:\n-// \n+//\n //   * There's no way to find out the ty::t type of a ValueRef.  Doing so\n //     would be \"trying to get the eggs out of an omelette\" (credit:\n //     pcwalton).  You can, instead, find out its TypeRef by calling val_ty,\n@@ -24,6 +24,7 @@ import std::map::hashmap;\n import std::option;\n import std::option::some;\n import std::option::none;\n+import std::fs;\n \n import front::ast;\n import front::creader;\n@@ -62,6 +63,15 @@ import lib::llvm::False;\n import lib::llvm::True;\n import lib::llvm::Bool;\n \n+import link::mangle_internal_name_by_type_only;\n+import link::mangle_internal_name_by_seq;\n+import link::mangle_internal_name_by_path;\n+import link::mangle_internal_name_by_path_and_seq;\n+import link::mangle_exported_name;\n+import link::crate_meta_name;\n+import link::crate_meta_vers;\n+import link::crate_meta_extras_hash;\n+\n state obj namegen(mutable int i) {\n     fn next(str prefix) -> str {\n         i += 1;\n@@ -119,6 +129,9 @@ state type crate_ctxt = rec(session::session sess,\n                                     @ast::native_item] native_items,\n                             hashmap[ast::def_id, str] item_symbols,\n                             mutable option::t[ValueRef] main_fn,\n+                            str crate_meta_name,\n+                            str crate_meta_vers,\n+                            str crate_meta_extras_hash,\n                             // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n                             hashmap[ty::t, uint] tag_sizes,\n                             hashmap[ast::def_id, ValueRef] discrims,\n@@ -166,14 +179,14 @@ type fn_ctxt = rec(\n     ValueRef lltaskptr,\n     ValueRef llenv,\n     ValueRef llretptr,\n-    \n+\n     // The next three elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in the\n     // function, due to LLVM's quirks.\n \n     // A block for all the function's allocas, so that LLVM will coalesce them\n     // into a single alloca call.\n-    mutable BasicBlockRef llallocas, \n+    mutable BasicBlockRef llallocas,\n \n     // A block containing code that copies incoming arguments to space already\n     // allocated by code in the llallocas block.  (LLVM requires that\n@@ -313,70 +326,6 @@ fn extend_path(@local_ctxt cx, &str name) -> @local_ctxt {\n   ret @rec(path = cx.path + [name] with *cx);\n }\n \n-fn get_type_sha1(&@crate_ctxt ccx, &ty::t t) -> str {\n-    auto hash = \"\";\n-    alt (ccx.type_sha1s.find(t)) {\n-        case (some(?h)) { hash = h; }\n-        case (none) {\n-            ccx.sha.reset();\n-            auto f = metadata::def_to_str;\n-            // NB: do *not* use abbrevs here as we want the symbol names\n-            // to be independent of one another in the crate.\n-            auto cx = @rec(ds=f,\n-                           tcx=ccx.tcx,\n-                           abbrevs=metadata::ac_no_abbrevs);\n-\n-            ccx.sha.input_str(metadata::Encode::ty_str(cx, t));\n-            hash = str::substr(ccx.sha.result_str(), 0u, 16u);\n-            // Prefix with _ so that it never blends into adjacent digits\n-            hash = \"_\" + hash;\n-            ccx.type_sha1s.insert(t, hash);\n-        }\n-    }\n-    ret hash;\n-}\n-\n-fn mangle(&vec[str] ss) -> str {\n-\n-    // Follow C++ namespace-mangling style\n-\n-    auto n = \"_ZN\"; // Begin name-sequence.\n-\n-    for (str s in ss) {\n-        n += #fmt(\"%u%s\", str::byte_len(s), s);\n-    }\n-\n-    n += \"E\"; // End name-sequence.\n-    ret n;\n-}\n-\n-fn mangle_name_by_type(&@crate_ctxt ccx, &vec[str] path, &ty::t t) -> str {\n-    auto hash = get_type_sha1(ccx, t);\n-    ret mangle(path + [hash]);\n-}\n-\n-fn mangle_name_by_type_only(&@crate_ctxt ccx, &ty::t t, &str name) -> str {\n-    auto f = metadata::def_to_str;\n-    auto cx = @rec(ds=f, tcx=ccx.tcx, abbrevs=metadata::ac_no_abbrevs);\n-    auto s = ty::ty_to_short_str(ccx.tcx, t);\n-\n-    auto hash = get_type_sha1(ccx, t);\n-    ret mangle([name, s, hash]);\n-}\n-\n-fn mangle_name_by_path_and_seq(&@crate_ctxt ccx, &vec[str] path,\n-                               &str flav) -> str {\n-    ret mangle(path + [ccx.names.next(flav)]);\n-}\n-\n-fn mangle_name_by_path(&@crate_ctxt ccx, &vec[str] path) -> str {\n-    ret mangle(path);\n-}\n-\n-fn mangle_name_by_seq(&@crate_ctxt ccx, &str flav) -> str {\n-    ret ccx.names.next(flav);\n-}\n-\n fn res(@block_ctxt bcx, ValueRef val) -> result {\n     ret rec(bcx = bcx,\n             val = val);\n@@ -955,10 +904,6 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n         case (ty::ty_param(_)) {\n             llty = T_i8();\n         }\n-        case (ty::ty_bound_param(_)) {\n-            cx.tcx.sess.span_err(sp, \n-                                 \"trans::type_of called on ty_bound_param\");\n-        }\n         case (ty::ty_type) { llty = T_ptr(T_tydesc(cx.tn)); }\n     }\n \n@@ -1350,7 +1295,6 @@ fn static_size_of_tag(&@crate_ctxt cx, &span sp, &ty::t t) -> uint {\n         auto tup_ty = simplify_type(cx, ty::mk_imm_tup(cx.tcx, variant.args));\n \n         // Perform any type parameter substitutions.\n-        tup_ty = ty::bind_params_in_type(cx.tcx, tup_ty);\n         tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n \n         // Here we possibly do a recursive call.\n@@ -1424,10 +1368,8 @@ fn dynamic_size_of(&@block_ctxt cx, ty::t t) -> result {\n                 let vec[ty::t] raw_tys = variant.args;\n                 let vec[ty::t] tys = [];\n                 for (ty::t raw_ty in raw_tys) {\n-                    auto t = ty::bind_params_in_type(cx.fcx.lcx.ccx.tcx,\n-                                                    raw_ty);\n-                    t = ty::substitute_type_params(cx.fcx.lcx.ccx.tcx, tps,\n-                                                   t);\n+                    auto t = ty::substitute_type_params(cx.fcx.lcx.ccx.tcx,\n+                                                        tps, raw_ty);\n                     tys += [t];\n                 }\n \n@@ -1604,9 +1546,8 @@ fn GEP_tag(@block_ctxt cx,\n     auto i = 0;\n     let vec[ty::t] true_arg_tys = [];\n     for (ty::t aty in arg_tys) {\n-        auto arg_ty = ty::bind_params_in_type(cx.fcx.lcx.ccx.tcx, aty);\n-        arg_ty = ty::substitute_type_params(cx.fcx.lcx.ccx.tcx, ty_substs,\n-                                           arg_ty);\n+        auto arg_ty = ty::substitute_type_params(cx.fcx.lcx.ccx.tcx,\n+                                                 ty_substs, aty);\n         true_arg_tys += [arg_ty];\n         if (i == ix) {\n             elem_ty = arg_ty;\n@@ -1914,10 +1855,10 @@ fn declare_tydesc(&@local_ctxt cx, &span sp, &ty::t t,\n \n     auto name;\n     if (cx.ccx.sess.get_opts().debuginfo) {\n-        name = mangle_name_by_type_only(cx.ccx, t, \"tydesc\");\n+        name = mangle_internal_name_by_type_only(cx.ccx, t, \"tydesc\");\n         name = sanitize(name);\n     } else {\n-        name = mangle_name_by_seq(cx.ccx, \"tydesc\");\n+        name = mangle_internal_name_by_seq(cx.ccx, \"tydesc\");\n     }\n \n     auto gvar = llvm::LLVMAddGlobal(ccx.llmod, T_tydesc(ccx.tn),\n@@ -1948,10 +1889,12 @@ fn declare_generic_glue(&@local_ctxt cx,\n                         &str name) -> ValueRef {\n     auto fn_nm;\n     if (cx.ccx.sess.get_opts().debuginfo) {\n-        fn_nm = mangle_name_by_type_only(cx.ccx, t, \"glue_\" + name);\n+        fn_nm = mangle_internal_name_by_type_only(cx.ccx, t,\n+                                                  \"glue_\" + name);\n         fn_nm = sanitize(fn_nm);\n     } else {\n-        fn_nm = mangle_name_by_seq(cx.ccx,  \"glue_\" + name);\n+        fn_nm = mangle_internal_name_by_seq(cx.ccx,\n+                                            \"glue_\" + name);\n     }\n     auto llfn = decl_fastcall_fn(cx.ccx.llmod, fn_nm, llfnty);\n     set_glue_inlining(cx, llfn, t);\n@@ -2794,10 +2737,8 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n                                 auto llfldp_b = rslt.val;\n                                 variant_cx = rslt.bcx;\n \n-                                auto ty_subst = ty::bind_params_in_type(\n-                                    cx.fcx.lcx.ccx.tcx, a.ty);\n-                                ty_subst = ty::substitute_type_params(\n-                                    cx.fcx.lcx.ccx.tcx, tps, ty_subst);\n+                                auto ty_subst = ty::substitute_type_params(\n+                                    cx.fcx.lcx.ccx.tcx, tps, a.ty);\n \n                                 auto llfld_a =\n                                     load_if_immediate(variant_cx,\n@@ -3684,13 +3625,11 @@ fn autoderef(&@block_ctxt cx, ValueRef v, &ty::t t) -> result {\n \n                 v1 = load_if_immediate(cx, v1, t1);\n             }\n-            case (_) {\n-                ret res(cx, v1);\n-            }\n+            case (_) { break; }\n         }\n     }\n \n-    fail; // fools the return-checker\n+    ret res(cx, v1);\n }\n \n fn autoderefed_ty(&@crate_ctxt ccx, &ty::t t) -> ty::t {\n@@ -3701,13 +3640,11 @@ fn autoderefed_ty(&@crate_ctxt ccx, &ty::t t) -> ty::t {\n             case (ty::ty_box(?mt)) {\n                 t1 = mt.ty;\n             }\n-            case (_) {\n-                ret t1;\n-            }\n+            case (_) { break; }\n         }\n     }\n \n-    fail; // fools the return-checker\n+    ret t1;\n }\n \n fn trans_binary(&@block_ctxt cx, ast::binop op,\n@@ -3873,7 +3810,7 @@ fn trans_if(&@block_ctxt cx, &@ast::expr cond,\n             }\n \n             // FIXME: This isn't quite right, particularly re: dynamic types\n-            auto expr_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx.node_types,\n+            auto expr_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx,\n                                            ann);\n             if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n                 expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n@@ -4107,7 +4044,8 @@ fn trans_for_each(&@block_ctxt cx,\n \n     // Step 2: Declare foreach body function.\n \n-    let str s = mangle_name_by_path_and_seq(lcx.ccx, lcx.path, \"foreach\");\n+    let str s = mangle_internal_name_by_path_and_seq(lcx.ccx, lcx.path,\n+                                                     \"foreach\");\n \n     // The 'env' arg entering the body function is a fake env member (as in\n     // the env-part of the normal rust calling convention) that actually\n@@ -4257,7 +4195,7 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n \n         case (ast::pat_lit(?lt, ?ann)) {\n             auto lllit = trans_lit(cx.fcx.lcx.ccx, *lt, ann);\n-            auto lltype = ty::ann_to_type(cx.fcx.lcx.ccx.tcx.node_types, ann);\n+            auto lltype = ty::ann_to_type(cx.fcx.lcx.ccx.tcx, ann);\n             auto lleq = trans_compare(cx, ast::eq, lltype, llval, lllit);\n \n             auto matched_cx = new_sub_block_ctxt(lleq.bcx, \"matched_cx\");\n@@ -4295,7 +4233,7 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n             cx.build.CondBr(lleq, matched_cx.llbb, next_cx.llbb);\n \n             auto ty_params =\n-                ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx.node_types, ann);\n+                ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx, ann);\n \n             if (vec::len[@ast::pat](subpats) > 0u) {\n                 auto llblobptr = matched_cx.build.GEP(lltagptr,\n@@ -4356,7 +4294,7 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat,\n             auto llblobptr = cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n \n             auto ty_param_substs =\n-                ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx.node_types, ann);\n+                ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx, ann);\n \n             auto this_cx = cx;\n             auto i = 0;\n@@ -4405,7 +4343,7 @@ fn trans_alt(&@block_ctxt cx, &@ast::expr expr,\n                                   \"non-exhaustive match failure\");\n \n     // FIXME: This isn't quite right, particularly re: dynamic types\n-    auto expr_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx.node_types, ann);\n+    auto expr_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx, ann);\n     auto expr_llty;\n     if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, expr_ty)) {\n         expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n@@ -4470,8 +4408,8 @@ fn lval_generic_fn(&@block_ctxt cx,\n         lv = trans_external_path(cx, fn_id, tpt);\n     }\n \n-    auto tys = ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx.node_types, ann);\n-    auto monoty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx.node_types, ann);\n+    auto tys = ty::ann_to_type_params(cx.fcx.lcx.ccx.tcx, ann);\n+    auto monoty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx, ann);\n \n     if (vec::len[ty::t](tys) != 0u) {\n         auto bcx = lv.res.bcx;\n@@ -4806,7 +4744,8 @@ fn trans_bind_thunk(&@local_ctxt cx,\n     // Construct a thunk-call with signature incoming_fty, and that copies\n     // args forward into a call to outgoing_fty:\n \n-    let str s = mangle_name_by_path_and_seq(cx.ccx, cx.path, \"thunk\");\n+    let str s = mangle_internal_name_by_path_and_seq(cx.ccx, cx.path,\n+                                                     \"thunk\");\n     let TypeRef llthunk_ty = get_pair_fn_ty(type_of(cx.ccx, sp,\n                                                     incoming_fty));\n     let ValueRef llthunk = decl_internal_fastcall_fn(cx.ccx.llmod,\n@@ -5358,7 +5297,8 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f,\n \n     }\n \n-    auto ret_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx.node_types, ann);\n+    auto ret_ty = ty::ann_to_type(cx.fcx.lcx.ccx.tcx, ann);\n+\n     auto args_res = trans_args(f_res.res.bcx,\n                                llenv, f_res.llobj,\n                                f_res.generic,\n@@ -5824,13 +5764,17 @@ fn load_if_immediate(&@block_ctxt cx, ValueRef v, &ty::t t) -> ValueRef {\n \n fn trans_log(int lvl, &@block_ctxt cx, &@ast::expr e) -> result {\n     auto lcx = cx.fcx.lcx;\n-    auto modname = str::connect(lcx.module_path, \"::\");\n+    auto modname = link::mangle_internal_name_by_path(lcx.ccx,\n+                                                      lcx.module_path);\n     auto global;\n     if (lcx.ccx.module_data.contains_key(modname)) {\n         global = lcx.ccx.module_data.get(modname);\n     } else {\n-        global = llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(),\n-                                    str::buf(\"_rust_mod_log_\" + modname));\n+        auto s =\n+            link::mangle_internal_name_by_path_and_seq(lcx.ccx,\n+                                                       lcx.module_path,\n+                                                       \"loglevel\");\n+        global = llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), str::buf(s));\n         llvm::LLVMSetGlobalConstant(global, False);\n         llvm::LLVMSetInitializer(global, C_null(T_int()));\n         llvm::LLVMSetLinkage(global, lib::llvm::LLVMInternalLinkage\n@@ -6226,8 +6170,8 @@ fn trans_spawn(&@block_ctxt cx,\n     ret res(bcx, new_task);\n }\n \n-fn mk_spawn_wrapper(&@block_ctxt cx, \n-                    &@ast::expr func, \n+fn mk_spawn_wrapper(&@block_ctxt cx,\n+                    &@ast::expr func,\n                     &ty::t args_ty) -> result {\n     auto llmod = cx.fcx.lcx.ccx.llmod;\n     let TypeRef args_ty_tref = type_of(cx.fcx.lcx.ccx, cx.sp, args_ty);\n@@ -6240,9 +6184,9 @@ fn mk_spawn_wrapper(&@block_ctxt cx,\n \n     // TODO: construct a name based on tname\n     let str wrap_name =\n-        mangle_name_by_path_and_seq(cx.fcx.lcx.ccx,\n-                                    cx.fcx.lcx.path,\n-                                    \"spawn_wrapper\");\n+        mangle_internal_name_by_path_and_seq(cx.fcx.lcx.ccx,\n+                                             cx.fcx.lcx.path,\n+                                             \"spawn_wrapper\");\n     auto llfndecl = decl_fastcall_fn(llmod, wrap_name,\n                                      wrapper_fn_type);\n \n@@ -6253,7 +6197,7 @@ fn mk_spawn_wrapper(&@block_ctxt cx,\n     // 3u to skip the three implicit args\n     let ValueRef arg = llvm::LLVMGetParam(fcx.llfn, 3u);\n \n-    let vec[ValueRef] child_args = \n+    let vec[ValueRef] child_args =\n         [llvm::LLVMGetParam(fcx.llfn, 0u),\n          llvm::LLVMGetParam(fcx.llfn, 1u),\n          llvm::LLVMGetParam(fcx.llfn, 2u)];\n@@ -6272,19 +6216,19 @@ fn mk_spawn_wrapper(&@block_ctxt cx,\n             }\n         }\n     }\n-    \n+\n     // Find the function\n     auto fnptr = trans_lval(fbcx, func).res;\n     fbcx = fnptr.bcx;\n-    \n+\n     auto llfnptr = fbcx.build.GEP(fnptr.val,\n                                   [C_int(0), C_int(0)]);\n     auto llfn = fbcx.build.Load(llfnptr);\n-    \n+\n     fbcx.build.FastCall(llfn,\n                         child_args);\n     fbcx.build.RetVoid();\n-    \n+\n     finish_fn(fcx, fbcx.llbb);\n \n     // TODO: make sure we clean up everything we need to.\n@@ -6720,7 +6664,7 @@ fn new_local_ctxt(&@crate_ctxt ccx) -> @local_ctxt {\n     let vec[ast::ty_param] obj_typarams = [];\n     let vec[ast::obj_field] obj_fields = [];\n     ret @rec(path=pth,\n-             module_path=[crate_name(ccx, \"main\")],\n+             module_path=[ccx.crate_meta_name],\n              obj_typarams = obj_typarams,\n              obj_fields = obj_fields,\n              ccx = ccx);\n@@ -6907,7 +6851,7 @@ fn is_terminated(&@block_ctxt cx) -> bool {\n }\n \n fn arg_tys_of_fn(&@crate_ctxt ccx, ast::ann ann) -> vec[ty::arg] {\n-    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx.node_types, ann))) {\n+    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx, ann))) {\n         case (ty::ty_fn(_, ?arg_tys, _, _)) {\n             ret arg_tys;\n         }\n@@ -6924,7 +6868,7 @@ fn ret_ty_of_fn_ty(&@crate_ctxt ccx, ty::t t) -> ty::t {\n \n \n fn ret_ty_of_fn(&@crate_ctxt ccx, ast::ann ann) -> ty::t {\n-    ret ret_ty_of_fn_ty(ccx, ty::ann_to_type(ccx.tcx.node_types, ann));\n+    ret ret_ty_of_fn_ty(ccx, ty::ann_to_type(ccx.tcx, ann));\n }\n \n fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, val_self_pair llself) {\n@@ -7095,7 +7039,7 @@ fn create_vtbl(@local_ctxt cx,\n \n         let @local_ctxt mcx = @rec(path = cx.path + [\"method\",\n                                                      m.node.ident] with *cx);\n-        let str s = mangle_name_by_path(mcx.ccx, mcx.path);\n+        let str s = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n         let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s,\n                                                       llfnty);\n         cx.ccx.item_ids.insert(m.node.id, llfn);\n@@ -7107,7 +7051,8 @@ fn create_vtbl(@local_ctxt cx,\n         methods += [llfn];\n     }\n     auto vtbl = C_struct(methods);\n-    auto vtbl_name = mangle_name_by_path(cx.ccx, cx.path + [\"vtbl\"]);\n+    auto vtbl_name = mangle_internal_name_by_path(cx.ccx,\n+                                                  cx.path + [\"vtbl\"]);\n     auto gvar = llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl),\n                                    str::buf(vtbl_name));\n     llvm::LLVMSetInitializer(gvar, vtbl);\n@@ -7124,7 +7069,7 @@ fn trans_dtor(@local_ctxt cx,\n               &@ast::method dtor) -> ValueRef {\n \n     auto llfnty = T_dtor(cx.ccx, dtor.span, llself_ty);\n-    let str s = mangle_name_by_path(cx.ccx, cx.path + [\"drop\"]);\n+    let str s = mangle_internal_name_by_path(cx.ccx, cx.path + [\"drop\"]);\n     let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n     cx.ccx.item_ids.insert(dtor.node.id, llfn);\n     cx.ccx.item_symbols.insert(dtor.node.id, s);\n@@ -7517,23 +7462,29 @@ fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp,\n         }\n     }\n \n+    let bool is_main = (str::eq(vec::top(path), \"main\") &&\n+                        !ccx.sess.get_opts().shared);\n+\n     // Declare the function itself.\n-    let str s = mangle_name_by_path(ccx, path);\n+    let str s =\n+        if (is_main) { \"_rust_main\" }\n+        else { mangle_internal_name_by_path(ccx, path) };\n+\n     let ValueRef llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfty);\n \n     // Declare the global constant pair that points to it.\n-    let str ps = mangle_name_by_type(ccx, path, node_ann_type(ccx, ann));\n-\n+    let str ps = mangle_exported_name(ccx, path, node_ann_type(ccx, ann));\n     register_fn_pair(ccx, ps, llpairty, llfn, id);\n \n-    if (str::eq(vec::top(path), \"main\") &&\n-        !ccx.sess.get_opts().shared) {\n+    if (is_main) {\n         if (ccx.main_fn != none[ValueRef]) {\n             ccx.sess.span_err(sp, \"multiple 'main' functions\");\n         }\n-        log #fmt(\"registering %s as main function for crate\", ps);\n+        llvm::LLVMSetLinkage(llfn, lib::llvm::LLVMExternalLinkage\n+                             as llvm::Linkage);\n         ccx.main_fn = some(llfn);\n     }\n+\n }\n \n fn register_fn_pair(&@crate_ctxt cx, str ps, TypeRef llpairty, ValueRef llfn,\n@@ -7564,7 +7515,7 @@ fn native_fn_ty_param_count(&@crate_ctxt cx, &ast::def_id id) -> uint {\n     alt (native_item.node) {\n         case (ast::native_item_ty(_,_)) {\n             cx.sess.bug(\"decl_native_fn_and_pair(): native fn isn't \" +\n-                        \"actually a fn?!\");\n+                        \"actually a fn\");\n         }\n         case (ast::native_item_fn(_, _, _, ?tps, _, _)) {\n             count = vec::len[ast::ty_param](tps);\n@@ -7592,14 +7543,15 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n \n     // Declare the wrapper.\n     auto t = node_ann_type(ccx, ann);\n+\n     auto wrapper_type = native_fn_wrapper_type(ccx, sp, num_ty_param, t);\n-    let str s = mangle_name_by_path(ccx, path);\n+    let str s = mangle_internal_name_by_path(ccx, path);\n     let ValueRef wrapper_fn = decl_internal_fastcall_fn(ccx.llmod, s,\n                                                         wrapper_type);\n \n     // Declare the global constant pair that points to it.\n     auto wrapper_pair_type = T_fn_pair(ccx.tn, wrapper_type);\n-    let str ps = mangle_name_by_type(ccx, path, node_ann_type(ccx, ann));\n+    let str ps = mangle_exported_name(ccx, path, node_ann_type(ccx, ann));\n \n     register_fn_pair(ccx, ps, wrapper_pair_type, wrapper_fn, id);\n \n@@ -7937,7 +7889,7 @@ fn trans_constant(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast::item it) {\n                 auto discrim_val = C_int(i as int);\n \n                 auto p = wcx.path + [ident, variant.node.name, \"discrim\"];\n-                auto s = mangle_name_by_type(ccx, p, ty::mk_int(ccx.tcx));\n+                auto s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n                 auto discrim_gvar = llvm::LLVMAddGlobal(ccx.llmod, T_int(),\n                                                        str::buf(s));\n \n@@ -7956,8 +7908,8 @@ fn trans_constant(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast::item it) {\n             // with consts.\n             auto v = C_int(1);\n             ccx.item_ids.insert(cid, v);\n-            auto s = mangle_name_by_type(ccx, wcx.path + [name],\n-                                         node_ann_type(ccx, ann));\n+            auto s = mangle_exported_name(ccx, wcx.path + [name],\n+                                          node_ann_type(ccx, ann));\n             ccx.item_symbols.insert(cid, s);\n         }\n \n@@ -7996,51 +7948,6 @@ fn create_typedefs(&@crate_ctxt cx) {\n     llvm::LLVMAddTypeName(cx.llmod, str::buf(\"tydesc\"), T_tydesc(cx.tn));\n }\n \n-fn trans_main_fn(@local_ctxt cx, ValueRef crate_map) {\n-    auto T_main_args = [T_int(), T_int()];\n-    auto T_rust_start_args = [T_int(), T_int(), T_int(), T_int()];\n-\n-    auto main_name;\n-    if (str::eq(std::os::target_os(), \"win32\")) {\n-        main_name = \"WinMain@16\";\n-    } else {\n-        main_name = \"main\";\n-    }\n-\n-    auto llmain =\n-        decl_cdecl_fn(cx.ccx.llmod, main_name, T_fn(T_main_args, T_int()));\n-\n-    auto llrust_start = decl_cdecl_fn(cx.ccx.llmod, \"rust_start\",\n-                                      T_fn(T_rust_start_args, T_int()));\n-\n-    auto llargc = llvm::LLVMGetParam(llmain, 0u);\n-    auto llargv = llvm::LLVMGetParam(llmain, 1u);\n-    auto llrust_main = alt (cx.ccx.main_fn) {\n-        case (none) {\n-            cx.ccx.sess.err(\"missing 'main' function\");\n-            // FIXME: shouldn't sess.err's ! result unify with f?\n-            C_nil()\n-        }\n-        case (some(?f)) { f }\n-    };\n-\n-    //\n-    // Emit the moral equivalent of:\n-    //\n-    // main(int argc, char **argv) {\n-    //     rust_start(&_rust.main, argc, argv);\n-    // }\n-    //\n-\n-    let BasicBlockRef llbb =\n-        llvm::LLVMAppendBasicBlock(llmain, str::buf(\"\"));\n-    auto b = new_builder(llbb);\n-\n-    auto start_args = [p2i(llrust_main), llargc, llargv, p2i(crate_map)];\n-\n-    b.Ret(b.Call(llrust_start, start_args));\n-}\n-\n fn declare_intrinsics(ModuleRef llmod) -> hashmap[str,ValueRef] {\n \n     let vec[TypeRef] T_memmove32_args = [T_ptr(T_i8()), T_ptr(T_i8()),\n@@ -8211,8 +8118,6 @@ fn create_module_map(&@crate_ctxt ccx) -> ValueRef {\n     auto maptype = T_array(elttype, ccx.module_data.size() + 1u);\n     auto map = llvm::LLVMAddGlobal(ccx.llmod, maptype,\n                                   str::buf(\"_rust_mod_map\"));\n-    llvm::LLVMSetLinkage(map, lib::llvm::LLVMInternalLinkage\n-                         as llvm::Linkage);\n     let vec[ValueRef] elts = [];\n     for each (@tup(str, ValueRef) item in ccx.module_data.items()) {\n         auto elt = C_struct([p2i(C_cstr(ccx, item._0)), p2i(item._1)]);\n@@ -8224,15 +8129,6 @@ fn create_module_map(&@crate_ctxt ccx) -> ValueRef {\n     ret map;\n }\n \n-fn crate_name(&@crate_ctxt ccx, &str deflt) -> str {\n-    for (@ast::meta_item item in ccx.sess.get_metadata()) {\n-        if (str::eq(item.node.name, \"name\")) {\n-            ret item.node.value;\n-        }\n-    }\n-    ret deflt;\n-}\n-\n // FIXME use hashed metadata instead of crate names once we have that\n fn create_crate_map(&@crate_ctxt ccx) -> ValueRef {\n     let vec[ValueRef] subcrates = [];\n@@ -8245,7 +8141,13 @@ fn create_crate_map(&@crate_ctxt ccx) -> ValueRef {\n         i += 1;\n     }\n     vec::push[ValueRef](subcrates, C_int(0));\n-    auto sym_name = \"_rust_crate_map_\" + crate_name(ccx, \"__none__\");\n+    auto mapname;\n+    if (ccx.sess.get_opts().shared) {\n+        mapname = ccx.crate_meta_name;\n+    } else {\n+        mapname = \"toplevel\";\n+    }\n+    auto sym_name = \"_rust_crate_map_\" + mapname;\n     auto arrtype = T_array(T_int(), vec::len[ValueRef](subcrates));\n     auto maptype = T_struct([T_int(), arrtype]);\n     auto map = llvm::LLVMAddGlobal(ccx.llmod, maptype, str::buf(sym_name));\n@@ -8279,7 +8181,7 @@ fn trans_crate(&session::session sess, &@ast::crate crate,\n     auto sha1s = map::mk_hashmap[ty::t,str](hasher, eqer);\n     auto abbrevs = map::mk_hashmap[ty::t,metadata::ty_abbrev](hasher, eqer);\n     auto short_names = map::mk_hashmap[ty::t,str](hasher, eqer);\n-\n+    auto sha = std::sha1::mk_sha1();\n     auto ccx = @rec(sess = sess,\n                     llmod = llmod,\n                     td = td,\n@@ -8291,6 +8193,10 @@ fn trans_crate(&session::session sess, &@ast::crate crate,\n                     native_items = new_def_hash[@ast::native_item](),\n                     item_symbols = new_def_hash[str](),\n                     mutable main_fn = none[ValueRef],\n+                    crate_meta_name = crate_meta_name(sess, *crate, output),\n+                    crate_meta_vers = crate_meta_vers(sess, *crate),\n+                    crate_meta_extras_hash =\n+                    crate_meta_extras_hash(sha, *crate),\n                     tag_sizes = tag_sizes,\n                     discrims = new_def_hash[ValueRef](),\n                     discrim_symbols = new_def_hash[str](),\n@@ -8302,7 +8208,7 @@ fn trans_crate(&session::session sess, &@ast::crate crate,\n                     lltypes = lltypes,\n                     glues = glues,\n                     names = namegen(0),\n-                    sha = std::sha1::mk_sha1(),\n+                    sha = sha,\n                     type_sha1s = sha1s,\n                     type_abbrevs = abbrevs,\n                     type_short_names = short_names,\n@@ -8322,9 +8228,17 @@ fn trans_crate(&session::session sess, &@ast::crate crate,\n     trans_constants(ccx, crate);\n     trans_mod(cx, crate.node.module);\n     auto crate_map = create_crate_map(ccx);\n+\n     if (!sess.get_opts().shared) {\n-        trans_main_fn(cx, crate_map);\n-    }\n+      auto gvar = llvm::LLVMAddGlobal(cx.ccx.llmod, T_ptr(T_int()),\n+                                    str::buf(\"_rust_fetch_this_object_hack\"));\n+\n+      auto gvar2 = llvm::LLVMAddGlobal(cx.ccx.llmod, T_ptr(T_ptr(T_int())),\n+                                   str::buf(\"_rust_fetch_this_object_hack2\"));\n+     llvm::LLVMSetInitializer(gvar2, gvar);\n+     llvm::LLVMSetGlobalConstant(gvar, True);\n+     llvm::LLVMSetGlobalConstant(gvar2, True);\n+   }\n \n     emit_tydescs(ccx);\n "}, {"sha": "b801954b933e33dcb6891b6bca92ae5dc846ec78", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -482,7 +482,7 @@ fn controlflow_def_id(&crate_ctxt ccx, &def_id d) -> controlflow {\n  If it has a function type with a ! annotation,\n the answer is noreturn. */\n fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n-    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx.node_types,\n+    alt (ty::struct(ccx.tcx, ty::ann_to_type(ccx.tcx,\n                                              expr_ann(e)))) {\n         case (ty::ty_fn(_,_,_,?cf)) {\n             ret cf;"}, {"sha": "3d0c612a085c439e87f502a765b497444098d926", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 311, "deletions": 493, "changes": 804, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -9,6 +9,7 @@ import std::map::hashmap;\n import std::option;\n import std::option::none;\n import std::option::some;\n+import std::smallintmap;\n \n import driver::session;\n import front::ast;\n@@ -88,9 +89,7 @@ type raw_t = rec(sty struct,\n                  option::t[str] cname,\n                  uint hash,\n                  bool has_params,\n-                 bool has_bound_params,\n-                 bool has_vars,\n-                 bool has_locals);\n+                 bool has_vars);\n \n type t = uint;\n \n@@ -118,23 +117,15 @@ tag sty {\n     ty_fn(ast::proto, vec[arg], t, controlflow);\n     ty_native_fn(ast::native_abi, vec[arg], t);\n     ty_obj(vec[method]);\n-    ty_var(int);                                    // ephemeral type var\n-    ty_local(ast::def_id);                           // type of a local var\n+    ty_var(int);                                    // type variable\n     ty_param(uint);                                 // fn/tag type param\n-    ty_bound_param(uint);                           // bound param, only paths\n     ty_type;\n     ty_native;\n     // TODO: ty_fn_arg(t), for a possibly-aliased function argument\n }\n \n // Data structures used in type unification\n \n-type unify_handler = obj {\n-    fn resolve_local(ast::def_id id) -> option::t[t];\n-    fn record_local(ast::def_id id, t ty);  // TODO: -> unify::result\n-    fn record_param(uint index, t binding) -> unify::result;\n-};\n-\n tag type_err {\n     terr_mismatch;\n     terr_controlflow_mismatch;\n@@ -259,132 +250,101 @@ fn mk_raw_ty(&ctxt cx, &sty st, &option::t[str] cname) -> raw_t {\n     auto h = hash_type_info(st, cname);\n \n     let bool has_params = false;\n-    let bool has_bound_params = false;\n     let bool has_vars = false;\n-    let bool has_locals = false;\n \n     fn derive_flags_t(&ctxt cx,\n                       &mutable bool has_params,\n-                      &mutable bool has_bound_params,\n                       &mutable bool has_vars,\n-                      &mutable bool has_locals,\n                       &t tt) {\n         auto rt = interner::get[raw_t](*cx.ts, tt);\n         has_params = has_params || rt.has_params;\n-        has_bound_params = has_bound_params || rt.has_bound_params;\n         has_vars = has_vars || rt.has_vars;\n-        has_locals = has_locals || rt.has_locals;\n     }\n \n     fn derive_flags_mt(&ctxt cx,\n                        &mutable bool has_params,\n-                       &mutable bool has_bound_params,\n                        &mutable bool has_vars,\n-                       &mutable bool has_locals,\n                        &mt m) {\n-        derive_flags_t(cx, has_params, has_bound_params,\n-                       has_vars, has_locals, m.ty);\n+        derive_flags_t(cx, has_params, has_vars, m.ty);\n     }\n \n \n     fn derive_flags_arg(&ctxt cx,\n                         &mutable bool has_params,\n-                        &mutable bool has_bound_params,\n                         &mutable bool has_vars,\n-                        &mutable bool has_locals,\n                         &arg a) {\n-        derive_flags_t(cx, has_params, has_bound_params,\n-                       has_vars, has_locals, a.ty);\n+        derive_flags_t(cx, has_params, has_vars, a.ty);\n     }\n \n     fn derive_flags_sig(&ctxt cx,\n                         &mutable bool has_params,\n-                        &mutable bool has_bound_params,\n                         &mutable bool has_vars,\n-                        &mutable bool has_locals,\n                         &vec[arg] args,\n                         &t tt) {\n         for (arg a in args) {\n-            derive_flags_arg(cx, has_params, has_bound_params,\n-                             has_vars, has_locals, a);\n+            derive_flags_arg(cx, has_params, has_vars, a);\n         }\n-        derive_flags_t(cx, has_params, has_bound_params,\n-                       has_vars, has_locals, tt);\n+        derive_flags_t(cx, has_params, has_vars, tt);\n     }\n \n     alt (st) {\n         case (ty_param(_)) {\n             has_params = true;\n         }\n-        case (ty_bound_param(_)) {\n-            has_bound_params = true;\n-        }\n         case (ty_var(_)) { has_vars = true; }\n-        case (ty_local(_)) { has_locals = true; }\n         case (ty_tag(_, ?tys)) {\n             for (t tt in tys) {\n-                derive_flags_t(cx, has_params, has_bound_params,\n-                               has_vars, has_locals, tt);\n+                derive_flags_t(cx, has_params, has_vars, tt);\n             }\n         }\n         case (ty_box(?m)) {\n-            derive_flags_mt(cx, has_params, has_bound_params,\n-                            has_vars, has_locals, m);\n+            derive_flags_mt(cx, has_params, has_vars, m);\n         }\n \n         case (ty_vec(?m)) {\n-            derive_flags_mt(cx, has_params, has_bound_params,\n-                            has_vars, has_locals, m);\n+            derive_flags_mt(cx, has_params, has_vars, m);\n         }\n \n         case (ty_port(?tt)) {\n-            derive_flags_t(cx, has_params, has_bound_params,\n-                           has_vars, has_locals, tt);\n+            derive_flags_t(cx, has_params, has_vars, tt);\n         }\n \n         case (ty_chan(?tt)) {\n-            derive_flags_t(cx, has_params, has_bound_params,\n-                           has_vars, has_locals, tt);\n+            derive_flags_t(cx, has_params, has_vars, tt);\n         }\n \n         case (ty_tup(?mts)) {\n             for (mt m in mts) {\n-                derive_flags_mt(cx, has_params, has_bound_params,\n-                                has_vars, has_locals, m);\n+                derive_flags_mt(cx, has_params, has_vars, m);\n             }\n         }\n \n         case (ty_rec(?flds)) {\n             for (field f in flds) {\n-                derive_flags_mt(cx, has_params, has_bound_params,\n-                                has_vars, has_locals, f.mt);\n+                derive_flags_mt(cx, has_params, has_vars, f.mt);\n             }\n         }\n \n         case (ty_fn(_, ?args, ?tt, _)) {\n-            derive_flags_sig(cx, has_params, has_bound_params,\n-                             has_vars, has_locals, args, tt);\n+            derive_flags_sig(cx, has_params, has_vars, args, tt);\n         }\n \n         case (ty_native_fn(_, ?args, ?tt)) {\n-            derive_flags_sig(cx, has_params, has_bound_params,\n-                             has_vars, has_locals, args, tt);\n+            derive_flags_sig(cx, has_params, has_vars, args, tt);\n         }\n \n         case (ty_obj(?meths)) {\n             for (method m in meths) {\n-                derive_flags_sig(cx, has_params, has_bound_params,\n-                                 has_vars, has_locals, m.inputs, m.output);\n+                derive_flags_sig(cx, has_params, has_vars, m.inputs,\n+                                 m.output);\n             }\n         }\n         case (_) { }\n     }\n \n     ret rec(struct=st, cname=cname, hash=h,\n-            has_params = has_params,\n-            has_bound_params = has_bound_params,\n-            has_vars = has_vars,\n-            has_locals = has_locals);\n+            has_params=has_params,\n+            has_vars=has_vars);\n }\n \n fn intern(&ctxt cx, &sty st, &option::t[str] cname) {\n@@ -485,18 +445,10 @@ fn mk_var(&ctxt cx, int v) -> t {\n     ret gen_ty(cx, ty_var(v));\n }\n \n-fn mk_local(&ctxt cx, ast::def_id did) -> t {\n-    ret gen_ty(cx, ty_local(did));\n-}\n-\n fn mk_param(&ctxt cx, uint n) -> t {\n     ret gen_ty(cx, ty_param(n));\n }\n \n-fn mk_bound_param(&ctxt cx, uint n) -> t {\n-    ret gen_ty(cx, ty_bound_param(n));\n-}\n-\n fn mk_type(&ctxt cx) -> t    { ret idx_type; }\n fn mk_native(&ctxt cx) -> t  { ret idx_native; }\n \n@@ -594,12 +546,12 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         ret mstr + ty_to_str(cx, m.ty);\n     }\n \n-    alt (cname(cx, typ)) {\n+    /*alt (cname(cx, typ)) {\n         case (some(?cs)) {\n             ret cs;\n         }\n         case (_) { }\n-    }\n+    }*/\n \n     auto s = \"\";\n \n@@ -664,20 +616,10 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n             s += \"<T\" + util::common::istr(v) + \">\";\n         }\n \n-        case (ty_local(?id)) {\n-            s += \"<L\" + util::common::istr(id._0) + \":\" +\n-                util::common::istr(id._1) + \">\";\n-        }\n-\n         case (ty_param(?id)) {\n             s += \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)]);\n         }\n \n-        case (ty_bound_param(?id)) {\n-            s += \"''\" + str::unsafe_from_bytes([('a' as u8) +\n-                                                    (id as u8)]);\n-        }\n-\n         case (_) {\n             s += ty_to_short_str(cx, typ);\n         }\n@@ -753,9 +695,7 @@ fn walk_ty(&ctxt cx, ty_walk walker, t ty) {\n             }\n         }\n         case (ty_var(_))         { /* no-op */ }\n-        case (ty_local(_))       { /* no-op */ }\n         case (ty_param(_))       { /* no-op */ }\n-        case (ty_bound_param(_)) { /* no-op */ }\n     }\n \n     walker(ty);\n@@ -853,9 +793,7 @@ fn fold_ty(&ctxt cx, ty_fold fld, t ty_0) -> t {\n             ty = copy_cname(cx, mk_obj(cx, new_methods), ty);\n         }\n         case (ty_var(_))         { /* no-op */ }\n-        case (ty_local(_))       { /* no-op */ }\n         case (ty_param(_))       { /* no-op */ }\n-        case (ty_bound_param(_)) { /* no-op */ }\n     }\n \n     ret fld(ty);\n@@ -921,9 +859,7 @@ fn sequence_element_type(&ctxt cx, &t ty) -> t {\n         // NB: This is not exhaustive.\n     }\n \n-    // FIXME: add sess.err or sess.span_err explaining failure (issue\n-    // #444)\n-    fail;\n+    cx.sess.bug(\"sequence_element_type called on non-sequence value\");\n }\n \n fn type_is_tup_like(&ctxt cx, &t ty) -> bool {\n@@ -949,8 +885,8 @@ fn get_element_type(&ctxt cx, &t ty, uint i) -> t {\n         // tag.\n     }\n \n-    // FIXME: add sess.err or sess.span_err explaining failure (issue #444)\n-    fail;\n+    cx.sess.bug(\"get_element_type called on a value other than a \"\n+                + \"tuple or record\");\n }\n \n fn type_is_box(&ctxt cx, &t ty) -> bool {\n@@ -1020,7 +956,6 @@ fn type_has_pointers(&ctxt cx, &t ty) -> bool {\n             for (variant_info variant in variants) {\n                 auto tup_ty = mk_imm_tup(cx, variant.args);\n                 // Perform any type parameter substitutions.\n-                tup_ty = bind_params_in_type(cx, tup_ty);\n                 tup_ty = substitute_type_params(cx, tps, tup_ty);\n                 if (type_has_pointers(cx, tup_ty)) { ret true; }\n             }\n@@ -1230,13 +1165,11 @@ fn hash_type_structure(&sty st) -> uint {\n             ret h;\n         }\n         case (ty_var(?v)) { ret hash_uint(28u, v as uint); }\n-        case (ty_local(?did)) { ret hash_def(29u, did); }\n-        case (ty_param(?pid)) { ret hash_uint(30u, pid); }\n-        case (ty_bound_param(?pid)) { ret hash_uint(31u, pid); }\n-        case (ty_type) { ret 32u; }\n-        case (ty_native) { ret 33u; }\n-        case (ty_bot) { ret 34u; }\n-        case (ty_ptr(?mt)) { ret hash_subty(35u, mt.ty); }\n+        case (ty_param(?pid)) { ret hash_uint(29u, pid); }\n+        case (ty_type) { ret 30u; }\n+        case (ty_native) { ret 31u; }\n+        case (ty_bot) { ret 32u; }\n+        case (ty_ptr(?mt)) { ret hash_subty(33u, mt.ty); }\n     }\n }\n \n@@ -1472,24 +1405,12 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                 case (_) { ret false; }\n             }\n         }\n-        case (ty_local(?did_a)) {\n-            alt (b) {\n-                case (ty_local(?did_b)) { ret equal_def(did_a, did_b); }\n-                case (_) { ret false; }\n-            }\n-        }\n         case (ty_param(?pid_a)) {\n             alt (b) {\n                 case (ty_param(?pid_b)) { ret pid_a == pid_b; }\n                 case (_) { ret false; }\n             }\n         }\n-        case (ty_bound_param(?pid_a)) {\n-            alt (b) {\n-                case (ty_bound_param(?pid_b)) { ret pid_a == pid_b; }\n-                case (_) { ret false; }\n-            }\n-        }\n         case (ty_type) {\n             alt (b) {\n                 case (ty_type) { ret true; }\n@@ -1544,24 +1465,25 @@ fn eq_ty(&t a, &t b) -> bool { ret a == b; }\n \n // Type lookups\n \n-fn ann_to_ty_param_substs_opt_and_ty(&node_type_table ntt, &ast::ann ann)\n-        -> ty_param_substs_opt_and_ty {\n-    alt ({ntt.(ann.id)}) {\n+fn ann_to_ty_param_substs_opt_and_ty(&ctxt cx, &ast::ann ann)\n+    -> ty_param_substs_opt_and_ty {\n+\n+    // Pull out the node type table.\n+    alt ({cx.node_types.(ann.id)}) {\n         case (none) {\n-            log_err \"ann_to_ty_param_substs_opt_and_ty() called on an \" +\n-                \"untyped node\";\n-            fail;\n+            cx.sess.bug(\"ann_to_ty_param_substs_opt_and_ty() called on an \" +\n+                        \"untyped node\");\n         }\n         case (some(?tpot)) { ret tpot; }\n     }\n }\n \n-fn ann_to_type(&node_type_table ntt, &ast::ann ann) -> t {\n-    ret ann_to_ty_param_substs_opt_and_ty(ntt, ann)._1;\n+fn ann_to_type(&ctxt cx, &ast::ann ann) -> t {\n+    ret ann_to_ty_param_substs_opt_and_ty(cx, ann)._1;\n }\n \n-fn ann_to_type_params(&node_type_table ntt, &ast::ann ann) -> vec[t] {\n-    alt (ann_to_ty_param_substs_opt_and_ty(ntt, ann)._0) {\n+fn ann_to_type_params(&ctxt cx, &ast::ann ann) -> vec[t] {\n+    alt (ann_to_ty_param_substs_opt_and_ty(cx, ann)._0) {\n         case (none) {\n             let vec[t] result = [];\n             ret result;\n@@ -1570,24 +1492,29 @@ fn ann_to_type_params(&node_type_table ntt, &ast::ann ann) -> vec[t] {\n     }\n }\n \n-fn ann_has_type_params(&node_type_table ntt, &ast::ann ann) -> bool {\n-    auto tpt = ann_to_ty_param_substs_opt_and_ty(ntt, ann);\n+fn ann_has_type_params(&ctxt cx, &ast::ann ann) -> bool {\n+    auto tpt = ann_to_ty_param_substs_opt_and_ty(cx, ann);\n     ret !option::is_none[vec[t]](tpt._0);\n }\n \n \n-// Returns the type of an annotation, with type parameter substitutions\n-// performed if applicable.\n-fn ann_to_monotype(&ctxt cx, ast::ann a) -> t {\n-    auto tpot = ann_to_ty_param_substs_opt_and_ty(cx.node_types, a);\n+// Returns a type with type parameter substitutions performed if applicable.\n+fn ty_param_substs_opt_and_ty_to_monotype(&ctxt cx,\n+                                          &ty_param_substs_opt_and_ty tpot)\n+        -> t {\n     alt (tpot._0) {\n         case (none) { ret tpot._1; }\n-        case (some(?tps)) {\n-            ret substitute_type_params(cx, tps, tpot._1);\n-        }\n+        case (some(?tps)) { ret substitute_type_params(cx, tps, tpot._1); }\n     }\n }\n \n+// Returns the type of an annotation, with type parameter substitutions\n+// performed if applicable.\n+fn ann_to_monotype(&ctxt cx, ast::ann a) -> t {\n+    auto tpot = ann_to_ty_param_substs_opt_and_ty(cx, a);\n+    ret ty_param_substs_opt_and_ty_to_monotype(cx, tpot);\n+}\n+\n \n // Returns the number of distinct type parameters in the given type.\n fn count_ty_params(&ctxt cx, t ty) -> uint {\n@@ -1619,48 +1546,40 @@ fn type_contains_vars(&ctxt cx, &t typ) -> bool {\n     ret interner::get[raw_t](*cx.ts, typ).has_vars;\n }\n \n-fn type_contains_locals(&ctxt cx, &t typ) -> bool {\n-    ret interner::get[raw_t](*cx.ts, typ).has_locals;\n-}\n-\n fn type_contains_params(&ctxt cx, &t typ) -> bool {\n     ret interner::get[raw_t](*cx.ts, typ).has_params;\n }\n \n-fn type_contains_bound_params(&ctxt cx, &t typ) -> bool {\n-    ret interner::get[raw_t](*cx.ts, typ).has_bound_params;\n-}\n-\n // Type accessors for substructures of types\n \n fn ty_fn_args(&ctxt cx, &t fty) -> vec[arg] {\n     alt (struct(cx, fty)) {\n         case (ty::ty_fn(_, ?a, _, _)) { ret a; }\n         case (ty::ty_native_fn(_, ?a, _)) { ret a; }\n     }\n-    fail;\n+    cx.sess.bug(\"ty_fn_args() called on non-fn type\");\n }\n \n fn ty_fn_proto(&ctxt cx, &t fty) -> ast::proto {\n     alt (struct(cx, fty)) {\n         case (ty::ty_fn(?p, _, _, _)) { ret p; }\n     }\n-    fail;\n+    cx.sess.bug(\"ty_fn_proto() called on non-fn type\");\n }\n \n fn ty_fn_abi(&ctxt cx, &t fty) -> ast::native_abi {\n     alt (struct(cx, fty)) {\n         case (ty::ty_native_fn(?a, _, _)) { ret a; }\n     }\n-    fail;\n+    cx.sess.bug(\"ty_fn_abi() called on non-native-fn type\");\n }\n \n fn ty_fn_ret(&ctxt cx, &t fty) -> t {\n     alt (struct(cx, fty)) {\n         case (ty::ty_fn(_, _, ?r, _)) { ret r; }\n         case (ty::ty_native_fn(_, _, ?r)) { ret r; }\n     }\n-    fail;\n+    cx.sess.bug(\"ty_fn_ret() called on non-fn type\");\n }\n \n fn is_fn_ty(&ctxt cx, &t fty) -> bool {\n@@ -1671,69 +1590,18 @@ fn is_fn_ty(&ctxt cx, &t fty) -> bool {\n     }\n }\n \n-\n-// Type accessors for AST nodes\n-\n-// Given an item, returns the associated type as well as the number of type\n-// parameters it has.\n-fn native_item_ty(&node_type_table ntt, &@ast::native_item it)\n-        -> ty_param_count_and_ty {\n-    auto ty_param_count;\n-    auto result_ty;\n-    alt (it.node) {\n-        case (ast::native_item_fn(_, _, _, ?tps, _, ?ann)) {\n-            ty_param_count = vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ntt, ann);\n-        }\n+fn ty_var_id(&ctxt cx, t typ) -> int {\n+    alt (struct(cx, typ)) {\n+        case (ty::ty_var(?vid)) { ret vid; }\n+        case (_) { log_err \"ty_var_id called on non-var ty\"; fail; }\n     }\n-    ret tup(ty_param_count, result_ty);\n }\n \n-fn item_ty(&node_type_table ntt, &@ast::item it) -> ty_param_count_and_ty {\n-    auto ty_param_count;\n-    auto result_ty;\n-    alt (it.node) {\n-        case (ast::item_const(_, _, _, _, ?ann)) {\n-            ty_param_count = 0u;\n-            result_ty = ann_to_type(ntt, ann);\n-        }\n-        case (ast::item_fn(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ntt, ann);\n-        }\n-        case (ast::item_mod(_, _, _)) {\n-            fail;   // modules are typeless\n-        }\n-        case (ast::item_ty(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ntt, ann);\n-        }\n-        case (ast::item_tag(_, _, ?tps, ?did, ?ann)) {\n-            ty_param_count = vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ntt, ann);\n-        }\n-        case (ast::item_obj(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = vec::len[ast::ty_param](tps);\n-            result_ty = ann_to_type(ntt, ann);\n-        }\n-    }\n \n-    ret tup(ty_param_count, result_ty);\n-}\n-\n-fn stmt_ty(&ctxt cx, &@ast::stmt s) -> t {\n-    alt (s.node) {\n-        case (ast::stmt_expr(?e,_)) {\n-            ret expr_ty(cx, e);\n-        }\n-        case (_) {\n-            ret mk_nil(cx);\n-        }\n-    }\n-}\n+// Type accessors for AST nodes\n \n fn block_ty(&ctxt cx, &ast::block b) -> t {\n-    ret ann_to_type(cx.node_types, b.node.a);\n+    ret ann_to_type(cx, b.node.a);\n }\n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n@@ -1820,18 +1688,18 @@ fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr)\n         -> tup(vec[t], t) {\n     auto a = expr_ann(expr);\n \n-    ret tup(ann_to_type_params(cx.node_types, a),\n-            ann_to_type(cx.node_types, a));\n+    ret tup(ann_to_type_params(cx, a),\n+            ann_to_type(cx, a));\n }\n \n-fn expr_has_ty_params(&node_type_table ntt, &@ast::expr expr) -> bool {\n-    ret ann_has_type_params(ntt, expr_ann(expr));\n+fn expr_has_ty_params(&ctxt cx, &@ast::expr expr) -> bool {\n+    ret ann_has_type_params(cx, expr_ann(expr));\n }\n \n fn decl_local_ty(&ctxt cx, &@ast::decl d) -> t {\n     alt (d.node) {\n         case (ast::decl_local(?l)) {\n-            ret ann_to_type(cx.node_types, l.ann);\n+            ret ann_to_type(cx, l.ann);\n         }\n         case (_) {\n             cx.sess.bug(\"decl_local_ty called on an item decl\");\n@@ -1941,55 +1809,88 @@ fn is_lval(&@ast::expr expr) -> bool {\n mod unify {\n     tag result {\n         ures_ok(t);\n-        ures_err(type_err, t, t);\n+        ures_err(type_err);\n+    }\n+\n+    tag union_result {\n+        unres_ok;\n+        unres_err(type_err);\n     }\n \n-    tag set_result {\n-        usr_ok(vec[t]);\n-        usr_err(type_err, t, t);\n+    tag fixup_result {\n+        fix_ok(t);      // fixup succeeded\n+        fix_err(int);   // fixup failed because a type variable was unresolved\n     }\n \n-    type bindings[T] = rec(ufind::ufind sets,\n-                           hashmap[T,uint] ids,\n-                           mutable vec[mutable option::t[t]] types);\n+    type var_bindings = rec(ufind::ufind sets,\n+                            smallintmap::smallintmap[t] types);\n \n-    fn mk_bindings[T](map::hashfn[T] hasher, map::eqfn[T] eqer)\n-            -> @bindings[T] {\n-        let vec[mutable option::t[t]] types = [mutable];\n-        ret @rec(sets=ufind::make(),\n-                 ids=map::mk_hashmap[T,uint](hasher, eqer),\n-                 mutable types=types);\n+    type ctxt = rec(@var_bindings vb, ty_ctxt tcx);\n+\n+    fn mk_var_bindings() -> @var_bindings {\n+        ret @rec(sets=ufind::make(), types=smallintmap::mk[t]());\n     }\n \n-    fn record_binding[T](&@ctxt cx, &@bindings[T] bindings, &T key, t typ)\n-            -> result {\n-        auto n = get_or_create_set[T](bindings, key);\n+    // Unifies two sets.\n+    fn union(&@ctxt cx, uint set_a, uint set_b) -> union_result {\n+        ufind::grow(cx.vb.sets, uint::max(set_a, set_b) + 1u);\n \n-        auto result_type = typ;\n-        if (n < vec::len[option::t[t]](bindings.types)) {\n-            alt (bindings.types.(n)) {\n-                case (some(?old_type)) {\n-                    alt (unify_step(cx, old_type, typ)) {\n-                        case (ures_ok(?unified_type)) {\n-                            result_type = unified_type;\n+        auto root_a = ufind::find(cx.vb.sets, set_a);\n+        auto root_b = ufind::find(cx.vb.sets, set_b);\n+        ufind::union(cx.vb.sets, set_a, set_b);\n+        auto root_c = ufind::find(cx.vb.sets, set_a);\n+\n+        alt (smallintmap::find[t](cx.vb.types, root_a)) {\n+            case (none[t]) {\n+                alt (smallintmap::find[t](cx.vb.types, root_b)) {\n+                    case (none[t]) { ret unres_ok; }\n+                    case (some[t](?t_b)) {\n+                        smallintmap::insert[t](cx.vb.types, root_c, t_b);\n+                        ret unres_ok;\n+                    }\n+                }\n+            }\n+            case (some[t](?t_a)) {\n+                alt (smallintmap::find[t](cx.vb.types, root_b)) {\n+                    case (none[t]) {\n+                        smallintmap::insert[t](cx.vb.types, root_c, t_a);\n+                        ret unres_ok;\n+                    }\n+                    case (some[t](?t_b)) {\n+                        alt (unify_step(cx, t_a, t_b)) {\n+                            case (ures_ok(?t_c)) {\n+                                smallintmap::insert[t](cx.vb.types, root_c,\n+                                                       t_c);\n+                                ret unres_ok;\n+                            }\n+                            case (ures_err(?terr)) { ret unres_err(terr); }\n                         }\n-                        case (?res) { ret res; }\n                     }\n                 }\n-                case (none) { /* fall through */ }\n             }\n         }\n+    }\n \n-        vec::grow_set[option::t[t]](bindings.types, n, none[t],\n-                                    some[t](result_type));\n+    fn record_var_binding(&@ctxt cx, int key, t typ) -> result {\n+        ufind::grow(cx.vb.sets, (key as uint) + 1u);\n \n+        auto result_type = typ;\n+        alt (smallintmap::find[t](cx.vb.types, key as uint)) {\n+            case (some(?old_type)) {\n+                alt (unify_step(cx, old_type, typ)) {\n+                    case (ures_ok(?unified_type)) {\n+                        result_type = unified_type;\n+                    }\n+                    case (?res) { ret res; }\n+                }\n+            }\n+            case (none) { /* fall through */ }\n+        }\n+\n+        smallintmap::insert[t](cx.vb.types, key as uint, result_type);\n         ret ures_ok(typ);\n     }\n \n-    type ctxt = rec(@bindings[int] bindings,\n-                    unify_handler handler,\n-                    ty_ctxt tcx);\n-\n     // Wraps the given type in an appropriate cname.\n     //\n     // TODO: This doesn't do anything yet. We should carry the cname up from\n@@ -2003,7 +1904,7 @@ mod unify {\n             ret ures_ok(expected);\n         }\n \n-        ret ures_err(terr_mismatch, expected, actual);\n+        ret ures_err(terr_mismatch);\n     }\n \n     // Unifies two mutability flags.\n@@ -2035,8 +1936,7 @@ mod unify {\n         auto expected_len = vec::len[arg](expected_inputs);\n         auto actual_len = vec::len[arg](actual_inputs);\n         if (expected_len != actual_len) {\n-            ret fn_common_res_err(ures_err(terr_arg_count,\n-                                           expected, actual));\n+            ret fn_common_res_err(ures_err(terr_arg_count));\n         }\n \n         // TODO: as above, we should have an iter2 iterator.\n@@ -2054,8 +1954,7 @@ mod unify {\n                 result_mode = expected_input.mode;\n             } else if (expected_input.mode != actual_input.mode) {\n                 // FIXME this is the wrong error\n-                ret fn_common_res_err(ures_err(terr_arg_count,\n-                                               expected, actual));\n+                ret fn_common_res_err(ures_err(terr_arg_count));\n             } else {\n                 result_mode = expected_input.mode;\n             }\n@@ -2099,7 +1998,7 @@ mod unify {\n         -> result {\n \n         if (e_proto != a_proto) {\n-            ret ures_err(terr_mismatch, expected, actual);\n+            ret ures_err(terr_mismatch);\n         }\n         alt (expected_cf) {\n             case (ast::return) { } // ok\n@@ -2114,8 +2013,7 @@ mod unify {\n                            this check is necessary to ensure that the\n                            annotation in an object method matches the\n                            declared object type */\n-                        ret ures_err(terr_controlflow_mismatch,\n-                                     expected, actual);\n+                        ret ures_err(terr_controlflow_mismatch);\n                     }\n                 }\n             }\n@@ -2143,9 +2041,7 @@ mod unify {\n                        &vec[arg] expected_inputs, &t expected_output,\n                        &vec[arg] actual_inputs, &t actual_output)\n         -> result {\n-        if (e_abi != a_abi) {\n-            ret ures_err(terr_mismatch, expected, actual);\n-        }\n+        if (e_abi != a_abi) { ret ures_err(terr_mismatch); }\n \n         auto t = unify_fn_common(cx, expected, actual,\n                                  expected_inputs, expected_output,\n@@ -2172,16 +2068,13 @@ mod unify {\n       let uint expected_len = vec::len[method](expected_meths);\n       let uint actual_len = vec::len[method](actual_meths);\n \n-      if (expected_len != actual_len) {\n-        ret ures_err(terr_meth_count, expected, actual);\n-      }\n+      if (expected_len != actual_len) { ret ures_err(terr_meth_count); }\n \n       while (i < expected_len) {\n         auto e_meth = expected_meths.(i);\n         auto a_meth = actual_meths.(i);\n         if (! str::eq(e_meth.ident, a_meth.ident)) {\n-          ret ures_err(terr_obj_meths(e_meth.ident, a_meth.ident),\n-                       expected, actual);\n+          ret ures_err(terr_obj_meths(e_meth.ident, a_meth.ident));\n         }\n         auto r = unify_fn(cx,\n                           e_meth.proto, a_meth.proto,\n@@ -2210,16 +2103,42 @@ mod unify {\n       ret ures_ok(t);\n     }\n \n-    fn get_or_create_set[T](&@bindings[T] bindings, &T key) -> uint {\n-        auto set_num;\n-        alt (bindings.ids.find(key)) {\n-            case (none) {\n-                set_num = ufind::make_set(bindings.sets);\n-                bindings.ids.insert(key, set_num);\n+    // FIXME: This function should not be necessary, but it is for now until\n+    // we eliminate pushdown. The typechecker should never rely on early\n+    // resolution of type variables.\n+    fn resolve_all_vars(&ty_ctxt tcx, &@var_bindings vb, t typ) -> t {\n+        fn folder(ty_ctxt tcx, @var_bindings vb, @bool success, t typ) -> t {\n+            alt (struct(tcx, typ)) {\n+                case (ty_var(?vid)) {\n+                    // It's possible that we haven't even created the var set.\n+                    // Handle this case gracefully.\n+                    if ((vid as uint) >= ufind::set_count(vb.sets)) {\n+                        *success = false; ret typ;\n+                    }\n+\n+                    auto root_id = ufind::find(vb.sets, vid as uint);\n+                    alt (smallintmap::find[t](vb.types, root_id)) {\n+                        case (some[t](?typ2)) {\n+                            ret fold_ty(tcx, bind folder(tcx, vb, success, _),\n+                                        typ2);\n+                        }\n+                        case (none[t]) { *success = false; ret typ; }\n+                    }\n+                    log \"\"; // fixes ambiguity\n+                    *success = false; ret typ;\n+                }\n+\n+                case (_) { ret typ; }\n             }\n-            case (some(?n)) { set_num = n; }\n         }\n-        ret set_num;\n+\n+        auto success = @true;\n+        auto rty = fold_ty(tcx, bind folder(tcx, vb, success, _), typ);\n+        /*if (*success) { ret rty; }\n+        log_err \"*** failed! type \" + ty::ty_to_str(tcx, typ) + \" => \" +\n+            ty::ty_to_str(tcx, rty);\n+        ret typ;*/\n+        ret rty;\n     }\n \n     fn unify_step(&@ctxt cx, &t expected, &t actual) -> result {\n@@ -2232,71 +2151,57 @@ mod unify {\n         // Fast path.\n         if (eq_ty(expected, actual)) { ret ures_ok(expected); }\n \n-        alt (struct(cx.tcx, actual)) {\n+        // Stage 1: Handle the cases in which one side or another is a type\n+        // variable.\n \n-            // a _|_ type can be used anywhere\n-            case (ty::ty_bot) {\n-                ret ures_ok(expected);\n-            }\n-       \n+        alt (struct(cx.tcx, actual)) {\n             // If the RHS is a variable type, then just do the appropriate\n             // binding.\n             case (ty::ty_var(?actual_id)) {\n-                auto actual_n = get_or_create_set[int](cx.bindings,\n-                                                       actual_id);\n+                auto actual_n = actual_id as uint;\n                 alt (struct(cx.tcx, expected)) {\n                     case (ty::ty_var(?expected_id)) {\n-                        auto expected_n = get_or_create_set[int](cx.bindings,\n-                                                                 expected_id);\n-                        ufind::union(cx.bindings.sets, expected_n, actual_n);\n+                        auto expected_n = expected_id as uint;\n+                        union(cx, expected_n, actual_n);\n                     }\n-\n                     case (_) {\n                         // Just bind the type variable to the expected type.\n-                        alt (record_binding[int](cx, cx.bindings, actual_id,\n-                                                 expected)) {\n+                        alt (record_var_binding(cx, actual_id, expected)) {\n                             case (ures_ok(_)) { /* fall through */ }\n                             case (?res) { ret res; }\n                         }\n                     }\n                 }\n-                ret ures_ok(actual);\n-            }\n-            case (ty::ty_local(?actual_id)) {\n-                auto result_ty;\n-                alt (cx.handler.resolve_local(actual_id)) {\n-                    case (none) { result_ty = expected; }\n-                    case (some(?actual_ty)) {\n-                        auto result = unify_step(cx, expected, actual_ty);\n-                        alt (result) {\n-                            case (ures_ok(?rty)) { result_ty = rty; }\n-                            case (_) { ret result; }\n-                        }\n-                    }\n-                }\n-\n-                cx.handler.record_local(actual_id, result_ty);\n-                ret ures_ok(result_ty);\n+                ret ures_ok(mk_var(cx.tcx, actual_id));\n             }\n-            case (ty::ty_bound_param(?actual_id)) {\n-                alt (struct(cx.tcx, expected)) {\n-                    case (ty::ty_local(_)) {\n-                        log_err \"TODO: bound param unifying with local\";\n-                        fail;\n-                    }\n \n-                    case (_) {\n-                        ret cx.handler.record_param(actual_id, expected);\n-                    }\n+            case (_) { /* empty */ }\n+        }\n+\n+        alt (struct(cx.tcx, expected)) {\n+            case (ty::ty_var(?expected_id)) {\n+                // Add a binding. (`actual` can't actually be a var here.)\n+                alt (record_var_binding(cx, expected_id, actual)) {\n+                    case (ures_ok(_)) { /* fall through */ }\n+                    case (?res) { ret res; }\n                 }\n+                ret ures_ok(mk_var(cx.tcx, expected_id));\n             }\n-            case (_) { /* empty */ }\n+\n+            case (_) { /* fall through */ }\n+        }\n+\n+        // Stage 2: Handle all other cases.\n+\n+        alt (struct(cx.tcx, actual)) {\n+            case (ty::ty_bot)        { ret ures_ok(expected);                }\n+            case (_)                 { /* fall through */                    }\n         }\n \n         alt (struct(cx.tcx, expected)) {\n             case (ty::ty_nil)        { ret struct_cmp(cx, expected, actual); }\n             // _|_ unifies with anything\n-            case (ty::ty_bot)        { ret ures_ok(expected);                }\n+            case (ty::ty_bot)        { ret ures_ok(actual);                  }\n             case (ty::ty_bool)       { ret struct_cmp(cx, expected, actual); }\n             case (ty::ty_int)        { ret struct_cmp(cx, expected, actual); }\n             case (ty::ty_uint)       { ret struct_cmp(cx, expected, actual); }\n@@ -2313,7 +2218,7 @@ mod unify {\n                     case (ty::ty_tag(?actual_id, ?actual_tps)) {\n                         if (expected_id._0 != actual_id._0 ||\n                                 expected_id._1 != actual_id._1) {\n-                            ret ures_err(terr_mismatch, expected, actual);\n+                            ret ures_err(terr_mismatch);\n                         }\n \n                         // TODO: factor this cruft out, see the TODO in the\n@@ -2346,18 +2251,15 @@ mod unify {\n                     case (_) { /* fall through */ }\n                 }\n \n-                ret ures_err(terr_mismatch, expected, actual);\n+                ret ures_err(terr_mismatch);\n             }\n \n             case (ty::ty_box(?expected_mt)) {\n                 alt (struct(cx.tcx, actual)) {\n                     case (ty::ty_box(?actual_mt)) {\n                         auto mut;\n                         alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n-                            case (none) {\n-                                ret ures_err(terr_box_mutability, expected,\n-                                             actual);\n-                            }\n+                            case (none) { ret ures_err(terr_box_mutability); }\n                             case (some(?m)) { mut = m; }\n                         }\n \n@@ -2375,9 +2277,7 @@ mod unify {\n                         }\n                     }\n \n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2386,10 +2286,7 @@ mod unify {\n                     case (ty::ty_vec(?actual_mt)) {\n                         auto mut;\n                         alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n-                            case (none) {\n-                                ret ures_err(terr_vec_mutability, expected,\n-                                             actual);\n-                            }\n+                            case (none) { ret ures_err(terr_vec_mutability); }\n                             case (some(?m)) { mut = m; }\n                         }\n \n@@ -2407,9 +2304,7 @@ mod unify {\n                         }\n                     }\n \n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                   }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2429,9 +2324,7 @@ mod unify {\n                         }\n                     }\n \n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2451,9 +2344,7 @@ mod unify {\n                         }\n                     }\n \n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2465,7 +2356,7 @@ mod unify {\n                         if (expected_len != actual_len) {\n                             auto err = terr_tuple_size(expected_len,\n                                                        actual_len);\n-                            ret ures_err(err, expected, actual);\n+                            ret ures_err(err);\n                         }\n \n                         // TODO: implement an iterator that can iterate over\n@@ -2481,7 +2372,7 @@ mod unify {\n                                            actual_elem.mut)) {\n                                 case (none) {\n                                     auto err = terr_tuple_mutability;\n-                                    ret ures_err(err, expected, actual);\n+                                    ret ures_err(err);\n                                 }\n                                 case (some(?m)) { mut = m; }\n                             }\n@@ -2505,9 +2396,7 @@ mod unify {\n                         ret ures_ok(mk_tup(cx.tcx, result_elems));\n                     }\n \n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2519,7 +2408,7 @@ mod unify {\n                         if (expected_len != actual_len) {\n                             auto err = terr_record_size(expected_len,\n                                                         actual_len);\n-                            ret ures_err(err, expected, actual);\n+                            ret ures_err(err);\n                         }\n \n                         // TODO: implement an iterator that can iterate over\n@@ -2534,8 +2423,7 @@ mod unify {\n                             alt (unify_mut(expected_field.mt.mut,\n                                            actual_field.mt.mut)) {\n                                 case (none) {\n-                                    ret ures_err(terr_record_mutability,\n-                                                 expected, actual);\n+                                    ret ures_err(terr_record_mutability);\n                                 }\n                                 case (some(?m)) { mut = m; }\n                             }\n@@ -2545,7 +2433,7 @@ mod unify {\n                                 auto err =\n                                     terr_record_fields(expected_field.ident,\n                                                        actual_field.ident);\n-                                ret ures_err(err, expected, actual);\n+                                ret ures_err(err);\n                             }\n \n                             auto result = unify_step(cx,\n@@ -2569,9 +2457,7 @@ mod unify {\n                         ret ures_ok(mk_rec(cx.tcx, result_fields));\n                     }\n \n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2587,9 +2473,7 @@ mod unify {\n                                      expected_cf, actual_cf);\n                     }\n \n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2603,9 +2487,7 @@ mod unify {\n                                             expected_inputs, expected_output,\n                                             actual_inputs, actual_output);\n                     }\n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n \n@@ -2615,150 +2497,87 @@ mod unify {\n                         ret unify_obj(cx, expected, actual,\n                                       expected_meths, actual_meths);\n                     }\n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n+                    case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n+        }\n+    }\n \n-            case (ty::ty_var(?expected_id)) {\n-                // Add a binding. (`actual` can't actually be a var here.)\n-                alt (record_binding[int](cx, cx.bindings, expected_id,\n-                                         actual)) {\n-                    case (ures_ok(_)) { /* fall through */ }\n-                    case (?res) { ret res; }\n-                }\n-                ret ures_ok(expected);\n-            }\n+    fn unify(&t expected,\n+             &t actual,\n+             &@var_bindings vb,\n+             &ty_ctxt tcx) -> result {\n+        auto cx = @rec(vb=vb, tcx=tcx);\n+        ret unify_step(cx, expected, actual);\n+    }\n \n-            case (ty::ty_local(?expected_id)) {\n-                auto result_ty;\n-                alt (cx.handler.resolve_local(expected_id)) {\n-                    case (none) { result_ty = actual; }\n-                    case (some(?expected_ty)) {\n-                        auto result = unify_step(cx, expected_ty, actual);\n-                        alt (result) {\n-                            case (ures_ok(?rty)) { result_ty = rty; }\n-                            case (_) { ret result; }\n-                        }\n-                    }\n+    fn dump_var_bindings(ty_ctxt tcx, @var_bindings vb) {\n+        auto i = 0u;\n+        while (i < vec::len[ufind::node](vb.sets.nodes)) {\n+            auto sets = \"\";\n+            auto j = 0u;\n+            while (j < vec::len[option::t[uint]](vb.sets.nodes)) {\n+                if (ufind::find(vb.sets, j) == i) { sets += #fmt(\" %u\", j); }\n+                j += 1u;\n+            }\n+\n+            auto typespec;\n+            alt (smallintmap::find[t](vb.types, i)) {\n+                case (none[t]) { typespec = \"\"; }\n+                case (some[t](?typ)) {\n+                    typespec = \" =\" + ty_to_str(tcx, typ);\n                 }\n-\n-                cx.handler.record_local(expected_id, result_ty);\n-                ret ures_ok(result_ty);\n             }\n \n-            case (ty::ty_bound_param(?expected_id)) {\n-                ret cx.handler.record_param(expected_id, actual);\n-            }\n+            log_err #fmt(\"set %u:%s%s\", i, typespec, sets);\n+            i += 1u;\n         }\n     }\n \n-    // Performs type binding substitution.\n-    fn substitute(&ty_ctxt tcx,\n-                  &@bindings[int] bindings,\n-                  &vec[t] set_types,\n-                  &t typ) -> t {\n-        if (!type_contains_vars(tcx, typ)) {\n-            ret typ;\n-        }\n+    // Fixups and substitutions\n \n-        fn substituter(ty_ctxt tcx,\n-                       @bindings[int] bindings,\n-                       vec[t] types,\n-                       t typ) -> t {\n+    fn fixup_vars(ty_ctxt tcx, @var_bindings vb, t typ) -> fixup_result {\n+        fn subst_vars(ty_ctxt tcx, @var_bindings vb,\n+                      @mutable option::t[int] unresolved, t typ) -> t {\n             alt (struct(tcx, typ)) {\n-                case (ty_var(?id)) {\n-                    alt (bindings.ids.find(id)) {\n-                        case (some(?n)) {\n-                            auto root = ufind::find(bindings.sets, n);\n-                            ret types.(root);\n-                        }\n-                        case (none) { ret typ; }\n+                case (ty::ty_var(?vid)) {\n+                    if ((vid as uint) >= ufind::set_count(vb.sets)) {\n+                        *unresolved = some[int](vid);\n+                        ret typ;\n                     }\n-                }\n-                case (_) { ret typ; }\n-            }\n-        }\n-\n-        auto f = bind substituter(tcx, bindings, set_types, _);\n-        ret fold_ty(tcx, f, typ);\n-    }\n-\n-    fn unify_sets[T](&ty_ctxt tcx, &@bindings[T] bindings) -> set_result {\n-        obj handler() {\n-            fn resolve_local(ast::def_id id) -> option::t[t] {\n-                log_err \"resolve_local in unify_sets\";\n-                fail;\n-            }\n-            fn record_local(ast::def_id id, t ty) {\n-                log_err \"record_local in unify_sets\";\n-                fail;\n-            }\n-            fn record_param(uint index, t binding) -> unify::result {\n-                log_err \"record_param in unify_sets\";\n-                fail;\n-            }\n-        }\n \n-        auto node_count = vec::len[option::t[t]](bindings.types);\n-\n-        let vec[option::t[t]] results =\n-            vec::init_elt[option::t[t]](none[t], node_count);\n-\n-        auto i = 0u;\n-        while (i < node_count) {\n-            auto root = ufind::find(bindings.sets, i);\n-            alt (bindings.types.(i)) {\n-                case (none) { /* nothing to do */ }\n-                case (some(?actual)) {\n-                    alt (results.(root)) {\n-                        case (none) { results.(root) = some[t](actual); }\n-                        case (some(?expected)) {\n-                            // FIXME: Is this right?\n-                            auto bindings = mk_bindings[int](int::hash,\n-                                                             int::eq_alias);\n-                            alt (unify(expected, actual, handler(), bindings,\n-                                    tcx)) {\n-                                case (ures_ok(?result_ty)) {\n-                                    results.(i) = some[t](result_ty);\n-                                }\n-                                case (ures_err(?e, ?t_a, ?t_b)) {\n-                                    ret usr_err(e, t_a, t_b);\n-                                }\n-                            }\n+                    auto root_id = ufind::find(vb.sets, vid as uint);\n+                    alt (smallintmap::find[t](vb.types, root_id)) {\n+                        case (none[t]) {\n+                            *unresolved = some[int](vid);\n+                            ret typ;\n+                        }\n+                        case (some[t](?rt)) {\n+                            ret fold_ty(tcx,\n+                                bind subst_vars(tcx, vb, unresolved, _), rt);\n                         }\n                     }\n                 }\n+                case (_) { ret typ; }\n             }\n-            i += 1u;\n         }\n \n-        // FIXME: This is equivalent to map(option::get, results) but it\n-        // causes an assertion in typeck at the moment.\n-        let vec[t] real_results = [];\n-        for (option::t[t] typ in results) {\n-            real_results += [option::get[t](typ)];\n-        }\n-\n-        ret usr_ok(real_results);\n-    }\n+        auto unresolved = @mutable none[int];\n+        auto rty = fold_ty(tcx, bind subst_vars(tcx, vb, unresolved, _), typ);\n \n-    fn unify(&t expected,\n-             &t actual,\n-             &unify_handler handler,\n-             &@bindings[int] bindings,\n-             &ty_ctxt tcx) -> result {\n-        auto cx = @rec(bindings=bindings, handler=handler, tcx=tcx);\n-        ret unify_step(cx, expected, actual);\n+        auto ur = *unresolved;\n+        alt (ur) {\n+            case (none[int]) { ret fix_ok(rty); }\n+            case (some[int](?var_id)) { ret fix_err(var_id); }\n+        }\n     }\n \n-    fn fixup(&ty_ctxt tcx, &@bindings[int] bindings, t typ) -> result {\n-        alt (unify_sets[int](tcx, bindings)) {\n-            case (usr_ok(?set_types)) {\n-                ret ures_ok(substitute(tcx, bindings, set_types, typ));\n-            }\n-            case (usr_err(?terr, ?t0, ?t1)) { ret ures_err(terr, t0, t1); }\n+    fn resolve_type_var(&ty_ctxt tcx, &@var_bindings vb, int vid)\n+            -> fixup_result {\n+        auto root_id = ufind::find(vb.sets, vid as uint);\n+        alt (smallintmap::find[t](vb.types, root_id)) {\n+            case (none[t]) { ret fix_ok(mk_var(tcx, vid)); }\n+            case (some[t](?rt)) { ret fixup_vars(tcx, vb, rt); }\n         }\n     }\n }\n@@ -2813,47 +2632,46 @@ fn type_err_to_str(&ty::type_err err) -> str {\n     }\n }\n \n-// Performs bound type parameter replacement using the supplied mapping from\n-// parameter IDs to types.\n-fn substitute_type_params(&ctxt cx, &vec[t] bindings, &t typ) -> t {\n-    if (!type_contains_bound_params(cx, typ)) {\n-        ret typ;\n+// Converts type parameters in a type to type variables and returns the\n+// resulting type along with a list of type variable IDs.\n+fn bind_params_in_type(&ctxt cx, fn()->int next_ty_var, t typ,\n+                       uint ty_param_count)\n+        -> tup(vec[int], t) {\n+    let vec[int] param_var_ids = [];\n+    auto i = 0u;\n+    while (i < ty_param_count) {\n+        param_var_ids += [next_ty_var()];\n+        i += 1u;\n     }\n-    fn replacer(&ctxt cx, vec[t] bindings, t typ) -> t {\n+\n+    fn binder(ctxt cx, vec[int] param_var_ids, fn()->int next_ty_var, t typ)\n+            -> t {\n         alt (struct(cx, typ)) {\n-            case (ty_bound_param(?param_index)) {\n-                ret bindings.(param_index);\n-            }\n+            case (ty_param(?index)) { ret mk_var(cx, param_var_ids.(index)); }\n             case (_) { ret typ; }\n         }\n     }\n \n-    auto f = bind replacer(cx, bindings, _);\n-    ret fold_ty(cx, f, typ);\n+    auto f = bind binder(cx, param_var_ids, next_ty_var, _);\n+    auto new_typ = fold_ty(cx, f, typ);\n+    ret tup(param_var_ids, new_typ);\n }\n \n-// Converts type parameters in a type to bound type parameters.\n-fn bind_params_in_type(&ctxt cx, &t typ) -> t {\n-    if (!type_contains_params(cx, typ)) {\n-        ret typ;\n-    }\n-    fn binder(&ctxt cx, t typ) -> t {\n+// Replaces type parameters in the given type using the given list of\n+// substitions.\n+fn substitute_type_params(&ctxt cx, vec[ty::t] substs, t typ) -> t {\n+    if (!type_contains_params(cx, typ)) { ret typ; }\n+\n+    fn substituter(ctxt cx, vec[ty::t] substs, t typ) -> t {\n         alt (struct(cx, typ)) {\n-            case (ty_bound_param(?index)) {\n-                log_err \"bind_params_in_type() called on type that already \" +\n-                    \"has bound params in it\";\n-                fail;\n-            }\n-            case (ty_param(?index)) { ret mk_bound_param(cx, index); }\n+            case (ty_param(?idx)) { ret substs.(idx); }\n             case (_) { ret typ; }\n         }\n     }\n \n-    auto f = bind binder(cx, _);\n-    ret fold_ty(cx, f, typ);\n+    ret fold_ty(cx, bind substituter(cx, substs, _), typ);\n }\n \n-\n fn def_has_ty_params(&ast::def def) -> bool {\n     alt (def) {\n         case (ast::def_fn(_))            { ret true;  }\n@@ -2924,9 +2742,9 @@ fn tag_variant_with_id(&ctxt cx,\n         }\n         i += 1u;\n     }\n+            \n+    cx.sess.bug(\"tag_variant_with_id(): no variant exists with that ID\");\n \n-    log_err \"tag_variant_with_id(): no variant exists with that ID\";\n-    fail;\n }\n \n // If the given item is in an external crate, looks up its type and adds it to\n@@ -2948,19 +2766,19 @@ fn lookup_item_type(ctxt cx, ast::def_id did) -> ty_param_count_and_ty {\n     }\n }\n \n-fn ret_ty_of_fn_ty(ty_ctxt tcx, t a_ty) -> t {\n-    alt (ty::struct(tcx, a_ty)) {\n+fn ret_ty_of_fn_ty(ctxt cx, t a_ty) -> t {\n+    alt (ty::struct(cx, a_ty)) {\n         case (ty::ty_fn(_, _, ?ret_ty, _)) {\n             ret ret_ty;\n         }\n         case (_) {\n-            fail;\n+            cx.sess.bug(\"ret_ty_of_fn_ty() called on non-function type\");\n         }\n     }\n }\n \n-fn ret_ty_of_fn(ty_ctxt tcx, ast::ann ann) -> t {\n-    ret ret_ty_of_fn_ty(tcx, ann_to_type(tcx.node_types, ann));\n+fn ret_ty_of_fn(ctxt cx, ast::ann ann) -> t {\n+    ret ret_ty_of_fn_ty(cx, ann_to_type(cx, ann));\n }\n \n // Local Variables:"}, {"sha": "db3f3ede0c7012674e84d31575ef7ca7f1ce5d1c", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 799, "deletions": 753, "changes": 1552, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1"}, {"sha": "1ecafe1f02fe5b2c27f37269c4c35904022a6787", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -68,7 +68,7 @@ fn walk_crate_directive(&ast_visitor v, @ast::crate_directive cd) {\n         case (ast::cdir_view_item(?vi)) {\n             walk_view_item(v, vi);\n         }\n-        case (ast::cdir_meta(_)) {}\n+        case (ast::cdir_meta(_,_)) {}\n         case (ast::cdir_syntax(_)) {}\n         case (ast::cdir_auth(_, _)) {}\n     }"}, {"sha": "2c7e65dcb22002bdb92117c8de4222badb1f87b2", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -945,7 +945,7 @@ fn print_decl(&ps s, &@ast::decl decl) {\n                         case (mo_untyped) { /* no-op */ }\n                         case (mo_typed(?tcx)) {\n                             auto lty =\n-                                ty::ann_to_type(tcx.node_types, loc.ann);\n+                                ty::ann_to_type(tcx, loc.ann);\n                             word_space(s, ty::ty_to_str(tcx, lty));\n                         }\n                         case (mo_identified) { /* no-op */ }"}, {"sha": "92e90e62cbf42f06f95e141ee74c2781352573ee", "filename": "src/lib/fs.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -19,6 +19,20 @@ fn dirname(path p) -> path {\n     ret str::substr(p, 0u, i as uint);\n }\n \n+fn basename(path p) -> path {\n+    let int i = str::rindex(p, os_fs::path_sep as u8);\n+    if (i == -1) {\n+        i = str::rindex(p, os_fs::alt_path_sep as u8);\n+        if (i == -1) {\n+            ret p;\n+        }\n+    }\n+    auto len = str::byte_len(p);\n+    if ((i+1) as uint >= len) { ret p; }\n+\n+    ret str::slice(p, i+1 as uint, len);\n+}\n+\n // FIXME: Need some typestate to avoid bounds check when len(pre) == 0\n fn connect(path pre, path post) -> path {\n     auto len = str::byte_len(pre);"}, {"sha": "49e9efa20f4c537d53c9c7e3d18773034851d654", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -38,3 +38,7 @@ fn truncate[T](&smallintmap[T] m, uint len) {\n     m.v = vec::slice_mut[option::t[T]](m.v, 0u, len);\n }\n \n+fn max_key[T](&smallintmap[T] m) -> uint {\n+    ret vec::len[option::t[T]](m.v);\n+}\n+"}, {"sha": "b35b150528d9cb816d4452fa28acb732e4264706", "filename": "src/lib/std.rc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -1,8 +1,10 @@\n meta (name = \"std\",\n-      desc = \"Rust standard library\",\n+      vers = \"0.1\",\n       uuid = \"122bed0b-c19b-4b82-b0b7-7ae8aead7297\",\n-      url = \"http://rust-lang.org/src/std\",\n-      ver = \"0.0.1\");\n+      url = \"http://rust-lang.org/src/std\");\n+\n+meta (comment = \"Rust standard library\",\n+      license = \"BSD\");\n \n // Built-in types support modules.\n "}, {"sha": "275efd813e487f50fc6e727551def9e1247487b7", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -20,6 +20,12 @@ fn make_set(&ufind ufnd) -> uint {\n     ret idx;\n }\n \n+/// Creates sets as necessary to ensure that least `n` sets are present in the\n+/// data structure.\n+fn grow(&ufind ufnd, uint n) {\n+    while (set_count(ufnd) < n) { make_set(ufnd); }\n+}\n+\n fn find(&ufind ufnd, uint n) -> uint {\n     alt (ufnd.nodes.(n)) {\n         case (none) { ret n; }\n@@ -37,12 +43,17 @@ fn union(&ufind ufnd, uint m, uint n) {\n     }\n }\n \n+fn set_count(&ufind ufnd) -> uint {\n+    ret vec::len[node](ufnd.nodes);\n+}\n+\n // Removes all sets with IDs greater than or equal to the given value.\n fn prune(&ufind ufnd, uint n) {\n     // TODO: Use \"slice\" once we get rid of \"mutable?\"\n-    while (n != 0u) {\n+    auto len = vec::len[node](ufnd.nodes);\n+    while (len != n) {\n         vec::pop[node](ufnd.nodes);\n-        n -= 1u;\n+        len -= 1u;\n     }\n }\n "}, {"sha": "c5aeb49d80b720dbbcbbc4eec61243aedcd78e1b", "filename": "src/lib/uint.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -12,6 +12,11 @@ fn ne(uint x, uint y) -> bool { ret x != y; }\n fn ge(uint x, uint y) -> bool { ret x >= y; }\n fn gt(uint x, uint y) -> bool { ret x > y; }\n \n+fn max(uint x, uint y) -> uint {\n+    if (x > y) { ret x; }\n+    ret y;\n+}\n+\n iter range(uint lo, uint hi) -> uint {\n     auto lo_ = lo;\n     while (lo_ < hi) {"}, {"sha": "2f82f330446ebab846260f5338f32963df9896e5", "filename": "src/lib/vec.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -210,15 +210,15 @@ fn unshift[T](&mutable array[T] v, &T t) {\n     v = res;\n }\n \n-fn grow[T](&array[T] v, uint n, &T initval) {\n+fn grow[T](&mutable array[T] v, uint n, &T initval) {\n     let uint i = n;\n     while (i > 0u) {\n         i -= 1u;\n         v += [initval];\n     }\n }\n \n-fn grow_set[T](&vec[mutable T] v, uint index, &T initval, &T val) {\n+fn grow_set[T](&mutable vec[mutable T] v, uint index, &T initval, &T val) {\n     auto length = vec::len(v);\n     if (index >= length) {\n         grow(v, index - length + 1u, initval);\n@@ -393,6 +393,12 @@ fn reversed[T](vec[T] v) -> vec[T] {\n     ret res;\n }\n \n+/// Truncates the vector to length `new_len`.\n+/// FIXME: This relies on a typechecker bug (covariance vs. invariance).\n+fn truncate[T](&mutable vec[mutable? T] v, uint new_len) {\n+    v = slice[T](v, 0u, new_len);\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "d956fb8681724a450682a6ea86a8b36e865d47f7", "filename": "src/rt/main.ll.in", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Frt%2Fmain.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Frt%2Fmain.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmain.ll.in?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -0,0 +1,24 @@\n+%0 = type { i32, [1 x i32] }\n+%1 = type { i32, i32 }\n+%2 = type { i32, %3 }\n+%3 = type { %tydesc*, %4, i1, {} }\n+%4 = type { i1*, i1* }\n+%5 = type { i32, i32, i32, i32, [0 x %6*] }\n+%6 = type { i32, i32, i32, i32, [0 x i8] }\n+\n+\n+@_rust_crate_map_toplevel = external global %0\n+\n+declare fastcc void @_rust_main(i1* nocapture, %task*, %2* nocapture, %5*);\n+declare i32 @rust_start(i32, i32, i32, i32)\n+\n+%tydesc = type { %tydesc**, i32, i32, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*, i8*, i8)* }\n+\n+%task = type { i32, i32, i32, i32, i32, i32, i32, i32 }\n+\n+@_rust_fetch_this_object_hack = global i32 0\n+\n+define i32 @\"MAIN\"(i32, i32) {\n+  %3 = tail call i32 @rust_start(i32 ptrtoint (void (i1*, %task*, %2*, %5*)* @_rust_main to i32), i32 %0, i32 %1, i32 ptrtoint (%0* @_rust_crate_map_toplevel to i32))\n+  ret i32 %3\n+}"}, {"sha": "5b41fb5a15874a551a175d7d2e534be9ef66cae5", "filename": "src/snapshots.txt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -1,3 +1,8 @@\n+S 2011-06-07 a4ca75e\n+  linux-i386 3de95184c59f5b0554df3da995090aaba26a190f\n+  macos-i386 1537f2e01c746dc6ca2a9bfb4b2e81256bb01e96\n+  winnt-i386 538765c5c4c31dfe8d6e998ef7503beb5cfa1525\n+\n S 2011-06-03 f29d046\n   linux-i386 76e4ee5b9148aae30ebfaabb12791bfee4fa8727\n   macos-i386 e146fa18f4b0f22fe4fd7fd104242837569d7702"}, {"sha": "9a7591ab7cebdd7830320b4f9f30ca643e030d85", "filename": "src/test/compile-fail/ext-nonexistent.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -1,5 +1,4 @@\n-\n // error-pattern:unknown syntax expander\n fn main() {\n   #iamnotanextensionthatexists(\"\");\n-}\n\\ No newline at end of file\n+}"}, {"sha": "b492f103c2034e0950aad0d5928f71e755f00d7a", "filename": "src/test/compile-fail/vector-no-ann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs?ref=b5c73605ead0dc27eb09e5f5860326b2cf2c5cd1", "patch": "@@ -1,6 +1,6 @@\n // xfail-stage0\n \n-// error-pattern:Ambiguous type\n+// error-pattern:cannot determine a type\n fn main() -> () {\n   auto foo = [];\n }"}]}