{"sha": "466135bfef4d110213a9aeb46f8199fa89a5f267", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2NjEzNWJmZWY0ZDExMDIxM2E5YWViNDZmODE5OWZhODlhNWYyNjc=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-12-04T19:58:21Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-12-29T00:40:48Z"}, "message": "libcore: Make it unsafe to create NonZero and impl Deref.", "tree": {"sha": "381e70fefb4baaa32da847cd2d236dcc0c0e171a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/381e70fefb4baaa32da847cd2d236dcc0c0e171a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/466135bfef4d110213a9aeb46f8199fa89a5f267", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/466135bfef4d110213a9aeb46f8199fa89a5f267", "html_url": "https://github.com/rust-lang/rust/commit/466135bfef4d110213a9aeb46f8199fa89a5f267", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/466135bfef4d110213a9aeb46f8199fa89a5f267/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4af50548b9ed283acb62768624a8cd942eabe964", "url": "https://api.github.com/repos/rust-lang/rust/commits/4af50548b9ed283acb62768624a8cd942eabe964", "html_url": "https://github.com/rust-lang/rust/commit/4af50548b9ed283acb62768624a8cd942eabe964"}], "stats": {"total": 114, "additions": 55, "deletions": 59}, "files": [{"sha": "47e7ddac07ce2083ca85b84de65bc5bf5572f2be", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/466135bfef4d110213a9aeb46f8199fa89a5f267/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466135bfef4d110213a9aeb46f8199fa89a5f267/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=466135bfef4d110213a9aeb46f8199fa89a5f267", "patch": "@@ -164,7 +164,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUint::new(1),\n             data: data,\n         };\n-        Arc { _ptr: NonZero(unsafe { mem::transmute(x) }) }\n+        Arc { _ptr: unsafe { NonZero::new(mem::transmute(x)) } }\n     }\n \n     /// Downgrades the `Arc<T>` to a `Weak<T>` reference.\n@@ -193,8 +193,7 @@ impl<T> Arc<T> {\n         // pointer is valid. Furthermore, we know that the `ArcInner` structure itself is `Sync`\n         // because the inner data is `Sync` as well, so we're ok loaning out an immutable pointer\n         // to these contents.\n-        let NonZero(ptr) = self._ptr;\n-        unsafe { &*ptr }\n+        unsafe { &**self._ptr }\n     }\n }\n \n@@ -281,8 +280,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n         // pointer that will ever be returned to T. Our reference count is guaranteed to be 1 at\n         // this point, and we required the Arc itself to be `mut`, so we're returning the only\n         // possible reference to the inner data.\n-        let NonZero(ptr) = self._ptr;\n-        let inner = unsafe { &mut *ptr };\n+        let inner = unsafe { &mut **self._ptr };\n         &mut inner.data\n     }\n }\n@@ -317,7 +315,7 @@ impl<T: Sync + Send> Drop for Arc<T> {\n     fn drop(&mut self) {\n         // This structure has #[unsafe_no_drop_flag], so this drop glue may run more than once (but\n         // it is guaranteed to be zeroed after the first if it's run more than once)\n-        let NonZero(ptr) = self._ptr;\n+        let ptr = *self._ptr;\n         if ptr.is_null() { return }\n \n         // Because `fetch_sub` is already atomic, we do not need to synchronize with other threads\n@@ -388,8 +386,7 @@ impl<T: Sync + Send> Weak<T> {\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n         // See comments above for why this is \"safe\"\n-        let NonZero(ptr) = self._ptr;\n-        unsafe { &*ptr }\n+        unsafe { &**self._ptr }\n     }\n }\n \n@@ -445,7 +442,7 @@ impl<T: Sync + Send> Drop for Weak<T> {\n     /// } // implicit drop\n     /// ```\n     fn drop(&mut self) {\n-        let NonZero(ptr) = self._ptr;\n+        let ptr = *self._ptr;\n \n         // see comments above for why this check is here\n         if ptr.is_null() { return }"}, {"sha": "3d73c64bf4d64b19113861a15942d1bb48a7072d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/466135bfef4d110213a9aeb46f8199fa89a5f267/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466135bfef4d110213a9aeb46f8199fa89a5f267/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=466135bfef4d110213a9aeb46f8199fa89a5f267", "patch": "@@ -195,7 +195,7 @@ impl<T> Rc<T> {\n                 // there is an implicit weak pointer owned by all the strong pointers, which\n                 // ensures that the weak destructor never frees the allocation while the strong\n                 // destructor is running, even if the weak pointer is stored inside the strong one.\n-                _ptr: NonZero(transmute(box RcBox {\n+                _ptr: NonZero::new(transmute(box RcBox {\n                     value: value,\n                     strong: Cell::new(1),\n                     weak: Cell::new(1)\n@@ -280,8 +280,7 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n             let val = ptr::read(&*rc); // copy the contained object\n             // destruct the box and skip our Drop\n             // we can ignore the refcounts because we know we're unique\n-            let NonZero(ptr) = rc._ptr;\n-            deallocate(ptr as *mut u8, size_of::<RcBox<T>>(),\n+            deallocate(*rc._ptr as *mut u8, size_of::<RcBox<T>>(),\n                         min_align_of::<RcBox<T>>());\n             forget(rc);\n             Ok(val)\n@@ -311,10 +310,7 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n #[experimental]\n pub fn get_mut<'a, T>(rc: &'a mut Rc<T>) -> Option<&'a mut T> {\n     if is_unique(rc) {\n-        let inner = unsafe {\n-            let NonZero(ptr) = rc._ptr;\n-            &mut *ptr\n-        };\n+        let inner = unsafe { &mut **rc._ptr };\n         Some(&mut inner.value)\n     } else {\n         None\n@@ -346,10 +342,7 @@ impl<T: Clone> Rc<T> {\n         // pointer that will ever be returned to T. Our reference count is guaranteed to be 1 at\n         // this point, and we required the `Rc<T>` itself to be `mut`, so we're returning the only\n         // possible reference to the inner value.\n-        let inner = unsafe {\n-            let NonZero(ptr) = self._ptr;\n-            &mut *ptr\n-        };\n+        let inner = unsafe { &mut **self._ptr };\n         &mut inner.value\n     }\n }\n@@ -397,7 +390,7 @@ impl<T> Drop for Rc<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let NonZero(ptr) = self._ptr;\n+            let ptr = *self._ptr;\n             if !ptr.is_null() {\n                 self.dec_strong();\n                 if self.strong() == 0 {\n@@ -689,7 +682,7 @@ impl<T> Drop for Weak<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let NonZero(ptr) = self._ptr;\n+            let ptr = *self._ptr;\n             if !ptr.is_null() {\n                 self.dec_weak();\n                 // the weak count starts at 1, and will only go to zero if all the strong pointers\n@@ -750,18 +743,12 @@ trait RcBoxPtr<T> {\n \n impl<T> RcBoxPtr<T> for Rc<T> {\n     #[inline(always)]\n-    fn inner(&self) -> &RcBox<T> {\n-        let NonZero(ptr) = self._ptr;\n-        unsafe { &(*ptr) }\n-    }\n+    fn inner(&self) -> &RcBox<T> { unsafe { &(**self._ptr) } }\n }\n \n impl<T> RcBoxPtr<T> for Weak<T> {\n     #[inline(always)]\n-    fn inner(&self) -> &RcBox<T> {\n-        let NonZero(ptr) = self._ptr;\n-        unsafe { &(*ptr) }\n-    }\n+    fn inner(&self) -> &RcBox<T> { unsafe { &(**self._ptr) } }\n }\n \n #[cfg(test)]"}, {"sha": "6f61865728041ffa5e3f87123a495a7bc9ae547b", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/466135bfef4d110213a9aeb46f8199fa89a5f267/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466135bfef4d110213a9aeb46f8199fa89a5f267/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=466135bfef4d110213a9aeb46f8199fa89a5f267", "patch": "@@ -176,7 +176,7 @@ impl<T> Vec<T> {\n         // non-null value which is fine since we never call deallocate on the ptr\n         // if cap is 0. The reason for this is because the pointer of a slice\n         // being NULL would break the null pointer optimization for enums.\n-        Vec { ptr: NonZero(EMPTY as *mut T), len: 0, cap: 0 }\n+        Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: 0 }\n     }\n \n     /// Constructs a new, empty `Vec<T>` with the specified capacity.\n@@ -209,15 +209,15 @@ impl<T> Vec<T> {\n     #[stable]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n-            Vec { ptr: NonZero(EMPTY as *mut T), len: 0, cap: uint::MAX }\n+            Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: uint::MAX }\n         } else if capacity == 0 {\n             Vec::new()\n         } else {\n             let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             let ptr = unsafe { allocate(size, mem::min_align_of::<T>()) };\n             if ptr.is_null() { ::alloc::oom() }\n-            Vec { ptr: NonZero(ptr as *mut T), len: 0, cap: capacity }\n+            Vec { ptr: unsafe { NonZero::new(ptr as *mut T) }, len: 0, cap: capacity }\n         }\n     }\n \n@@ -284,7 +284,7 @@ impl<T> Vec<T> {\n     #[unstable = \"needs finalization\"]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n                                  capacity: uint) -> Vec<T> {\n-        Vec { ptr: NonZero(ptr), len: length, cap: capacity }\n+        Vec { ptr: NonZero::new(ptr), len: length, cap: capacity }\n     }\n \n     /// Creates a vector by copying the elements from a raw pointer.\n@@ -792,24 +792,23 @@ impl<T> Vec<T> {\n     pub fn shrink_to_fit(&mut self) {\n         if mem::size_of::<T>() == 0 { return }\n \n-        let NonZero(ptr) = self.ptr;\n         if self.len == 0 {\n             if self.cap != 0 {\n                 unsafe {\n-                    dealloc(ptr, self.cap)\n+                    dealloc(*self.ptr, self.cap)\n                 }\n                 self.cap = 0;\n             }\n         } else {\n             unsafe {\n                 // Overflow check is unnecessary as the vector is already at\n                 // least this large.\n-                let ptr = reallocate(ptr as *mut u8,\n+                let ptr = reallocate(*self.ptr as *mut u8,\n                                      self.cap * mem::size_of::<T>(),\n                                      self.len * mem::size_of::<T>(),\n                                      mem::min_align_of::<T>()) as *mut T;\n                 if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero(ptr);\n+                self.ptr = NonZero::new(ptr);\n             }\n             self.cap = self.len;\n         }\n@@ -867,10 +866,9 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        let NonZero(ptr) = self.ptr;\n         unsafe {\n             mem::transmute(RawSlice {\n-                data: ptr as *const T,\n+                data: *self.ptr as *const T,\n                 len: self.len,\n             })\n         }\n@@ -893,7 +891,7 @@ impl<T> Vec<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n-            let NonZero(ptr) = self.ptr;\n+            let ptr = *self.ptr;\n             let cap = self.cap;\n             let begin = ptr as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n@@ -1113,16 +1111,15 @@ impl<T> Vec<T> {\n             let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n             if old_size > size { panic!(\"capacity overflow\") }\n             unsafe {\n-                let NonZero(ptr) = self.ptr;\n-                let ptr = alloc_or_realloc(ptr, old_size, size);\n+                let ptr = alloc_or_realloc(*self.ptr, old_size, size);\n                 if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero(ptr);\n+                self.ptr = NonZero::new(ptr);\n             }\n             self.cap = max(self.cap, 2) * 2;\n         }\n \n         unsafe {\n-            let NonZero(end) = self.ptr.offset(self.len as int);\n+            let end = *self.ptr.offset(self.len as int);\n             ptr::write(&mut *end, value);\n             self.len += 1;\n         }\n@@ -1167,11 +1164,11 @@ impl<T> Vec<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n         unsafe {\n-            let begin = self.ptr.0 as *const T;\n+            let begin = *self.ptr as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n-                (self.ptr.0 as uint + self.len()) as *const T\n+                (*self.ptr as uint + self.len()) as *const T\n             } else {\n-                self.ptr.0.offset(self.len() as int) as *const T\n+                (*self.ptr).offset(self.len() as int) as *const T\n             };\n             self.set_len(0);\n             Drain {\n@@ -1236,10 +1233,9 @@ impl<T> Vec<T> {\n             let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             unsafe {\n-                let NonZero(ptr) = self.ptr;\n-                let ptr = alloc_or_realloc(ptr, self.cap * mem::size_of::<T>(), size);\n+                let ptr = alloc_or_realloc(*self.ptr, self.cap * mem::size_of::<T>(), size);\n                 if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero(ptr);\n+                self.ptr = NonZero::new(ptr);\n             }\n             self.cap = capacity;\n         }\n@@ -1360,10 +1356,9 @@ impl<T> AsSlice<T> for Vec<T> {\n     #[inline]\n     #[stable]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n-        let NonZero(ptr) = self.ptr;\n         unsafe {\n             mem::transmute(RawSlice {\n-                data: ptr as *const T,\n+                data: *self.ptr as *const T,\n                 len: self.len\n             })\n         }\n@@ -1388,8 +1383,7 @@ impl<T> Drop for Vec<T> {\n                 for x in self.iter() {\n                     ptr::read(x);\n                 }\n-                let NonZero(ptr) = self.ptr;\n-                dealloc(ptr, self.cap)\n+                dealloc(*self.ptr, self.cap)\n             }\n         }\n     }\n@@ -1427,7 +1421,7 @@ impl<T> IntoIter<T> {\n             for _x in self { }\n             let IntoIter { allocation, cap, ptr: _ptr, end: _end } = self;\n             mem::forget(self);\n-            Vec { ptr: NonZero(allocation), cap: cap, len: 0 }\n+            Vec { ptr: NonZero::new(allocation), cap: cap, len: 0 }\n         }\n     }\n "}, {"sha": "23eb117680a0232073e19dbcf737f95bb866cef5", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/466135bfef4d110213a9aeb46f8199fa89a5f267/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466135bfef4d110213a9aeb46f8199fa89a5f267/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=466135bfef4d110213a9aeb46f8199fa89a5f267", "patch": "@@ -90,10 +90,10 @@\n use mem;\n use clone::Clone;\n use intrinsics;\n-use kinds::Copy;\n+use kinds::{Copy, Send, Sync};\n+use ops::Deref;\n use option::Option;\n use option::Option::{Some, None};\n-use kinds::{Send, Sync};\n \n use cmp::{PartialEq, Eq, Ord, PartialOrd, Equiv};\n use cmp::Ordering;\n@@ -115,7 +115,25 @@ pub use intrinsics::set_memory;\n /// NULL or 0 that might allow certain optimizations.\n #[lang=\"non_zero\"]\n #[deriving(Clone, PartialEq, Eq, PartialOrd)]\n-pub struct NonZero<T>(pub T);\n+#[experimental]\n+pub struct NonZero<T>(T);\n+\n+impl<T> NonZero<T> {\n+    /// Create an instance of NonZero with the provided value.\n+    /// You must indeed ensure that the value is actually \"non-zero\".\n+    #[inline(always)]\n+    pub unsafe fn new(inner: T) -> NonZero<T> {\n+        NonZero(inner)\n+    }\n+}\n+\n+impl<T> Deref<T> for NonZero<T> {\n+    #[inline]\n+    fn deref<'a>(&'a self) -> &'a T {\n+        let NonZero(ref inner) = *self;\n+        inner\n+    }\n+}\n \n impl<T: Copy> Copy for NonZero<T> {}\n "}]}