{"sha": "0da281b6068a7d889ae89a9bd8991284cc9b7535", "node_id": "C_kwDOAAsO6NoAKDBkYTI4MWI2MDY4YTdkODg5YWU4OWE5YmQ4OTkxMjg0Y2M5Yjc1MzU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-27T10:05:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-27T10:05:16Z"}, "message": "Auto merge of #103623 - matthiaskrgr:rollup-318yc1t, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #103035 (Even nicer errors from assert_unsafe_precondition)\n - #103106 (Try to say that memory outside the AM is always exposed)\n - #103475 (Make param index generation a bit more robust)\n - #103525 (Move a wf-check into the site where the value is instantiated)\n - #103564 (library: allow some unused things in Miri)\n - #103586 (Process registered region obligation in `resolve_regions_with_wf_tys`)\n - #103592 (rustdoc: remove redundant CSS selector `.notable-traits .notable`)\n - #103593 (Remove an unused parser function (`Expr::returns`))\n - #103611 (Add test for issue 103574)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "85ff8caeb0d7c81c6899184d87dd3cb61817b6ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85ff8caeb0d7c81c6899184d87dd3cb61817b6ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0da281b6068a7d889ae89a9bd8991284cc9b7535", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0da281b6068a7d889ae89a9bd8991284cc9b7535", "html_url": "https://github.com/rust-lang/rust/commit/0da281b6068a7d889ae89a9bd8991284cc9b7535", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0da281b6068a7d889ae89a9bd8991284cc9b7535/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9dd3d29ec848efd753667292277fd9f297d7db8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9dd3d29ec848efd753667292277fd9f297d7db8d", "html_url": "https://github.com/rust-lang/rust/commit/9dd3d29ec848efd753667292277fd9f297d7db8d"}, {"sha": "2252f7aa78f4a75704137e666eae2fbedc0d600e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2252f7aa78f4a75704137e666eae2fbedc0d600e", "html_url": "https://github.com/rust-lang/rust/commit/2252f7aa78f4a75704137e666eae2fbedc0d600e"}], "stats": {"total": 571, "additions": 431, "deletions": 140}, "files": [{"sha": "4ef43735a62c8eac79b0499268553cfd223e91d3", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -1112,24 +1112,6 @@ pub struct Expr {\n }\n \n impl Expr {\n-    /// Returns `true` if this expression would be valid somewhere that expects a value;\n-    /// for example, an `if` condition.\n-    pub fn returns(&self) -> bool {\n-        if let ExprKind::Block(ref block, _) = self.kind {\n-            match block.stmts.last().map(|last_stmt| &last_stmt.kind) {\n-                // Implicit return\n-                Some(StmtKind::Expr(_)) => true,\n-                // Last statement is an explicit return?\n-                Some(StmtKind::Semi(expr)) => matches!(expr.kind, ExprKind::Ret(_)),\n-                // This is a block that doesn't end in either an implicit or explicit return.\n-                _ => false,\n-            }\n-        } else {\n-            // This is not a block, it is a value.\n-            true\n-        }\n-    }\n-\n     /// Is this expr either `N`, or `{ N }`.\n     ///\n     /// If this is not the case, name resolution does not resolve `N` when using"}, {"sha": "7ac44312695d9aac94ac0f20648763a9e229b564", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -137,3 +137,12 @@ hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(l\n hir_analysis_missing_parentheses_in_range = can't call method `{$method_name}` on type `{$ty_str}`\n \n hir_analysis_add_missing_parentheses_in_range = you must surround the range in parentheses to call its `{$func_name}` function\n+\n+hir_analysis_const_impl_for_non_const_trait =\n+    const `impl` for trait `{$trait_name}` which is not marked with `#[const_trait]`\n+    .suggestion = mark `{$trait_name}` as const\n+    .note = marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+    .adding = adding a non-const method body in the future would be a breaking change\n+\n+hir_analysis_const_bound_for_non_const_trait =\n+    ~const can only be applied to `#[const_trait]` traits"}, {"sha": "6baf98449775da892321c3a68134e0038a11709b", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 50, "deletions": 18, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -36,7 +36,7 @@ use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECT\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::astconv_object_safety_violations;\n@@ -275,6 +275,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             item_segment.args(),\n             item_segment.infer_args,\n             None,\n+            None,\n         );\n         if let Some(b) = item_segment.args().bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n@@ -324,6 +325,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generic_args: &'a hir::GenericArgs<'_>,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>,\n+        constness: Option<ty::BoundConstness>,\n     ) -> (SubstsRef<'tcx>, GenericArgCountResult) {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n@@ -534,6 +536,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             &mut substs_ctx,\n         );\n \n+        if let Some(ty::BoundConstness::ConstIfConst) = constness\n+            && generics.has_self && !tcx.has_attr(def_id, sym::const_trait)\n+        {\n+            tcx.sess.emit_err(crate::errors::ConstBoundForNonConstTrait { span } );\n+        }\n+\n         (substs, arg_count)\n     }\n \n@@ -601,6 +609,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             item_segment.args(),\n             item_segment.infer_args,\n             None,\n+            None,\n         );\n \n         if let Some(b) = item_segment.args().bindings.first() {\n@@ -620,6 +629,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         trait_ref: &hir::TraitRef<'_>,\n         self_ty: Ty<'tcx>,\n+        constness: ty::BoundConstness,\n     ) -> ty::TraitRef<'tcx> {\n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1.iter(), |_| {});\n \n@@ -629,6 +639,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             self_ty,\n             trait_ref.path.segments.last().unwrap(),\n             true,\n+            Some(constness),\n         )\n     }\n \n@@ -655,6 +666,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             args,\n             infer_args,\n             Some(self_ty),\n+            Some(constness),\n         );\n \n         let tcx = self.tcx();\n@@ -680,6 +692,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 speculative,\n                 &mut dup_bindings,\n                 binding_span.unwrap_or(binding.span),\n+                constness,\n             );\n             // Okay to ignore `Err` because of `ErrorGuaranteed` (see above).\n         }\n@@ -783,13 +796,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         trait_segment: &hir::PathSegment<'_>,\n         is_impl: bool,\n+        constness: Option<ty::BoundConstness>,\n     ) -> ty::TraitRef<'tcx> {\n         let (substs, _) = self.create_substs_for_ast_trait_ref(\n             span,\n             trait_def_id,\n             self_ty,\n             trait_segment,\n             is_impl,\n+            constness,\n         );\n         if let Some(b) = trait_segment.args().bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n@@ -805,6 +820,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         trait_segment: &'a hir::PathSegment<'a>,\n         is_impl: bool,\n+        constness: Option<ty::BoundConstness>,\n     ) -> (SubstsRef<'tcx>, GenericArgCountResult) {\n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment, is_impl);\n \n@@ -816,6 +832,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             trait_segment.args(),\n             trait_segment.infer_args,\n             Some(self_ty),\n+            constness,\n         )\n     }\n \n@@ -1027,6 +1044,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         speculative: bool,\n         dup_bindings: &mut FxHashMap<DefId, Span>,\n         path_span: Span,\n+        constness: ty::BoundConstness,\n     ) -> Result<(), ErrorGuaranteed> {\n         // Given something like `U: SomeTrait<T = X>`, we want to produce a\n         // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n@@ -1122,10 +1140,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 trait_ref.substs,\n             );\n \n-            debug!(\n-                \"add_predicates_for_ast_type_binding: substs for trait-ref and assoc_item: {:?}\",\n-                substs_trait_ref_and_assoc_item\n-            );\n+            debug!(?substs_trait_ref_and_assoc_item);\n \n             ty::ProjectionTy {\n                 item_def_id: assoc_item.def_id,\n@@ -1146,8 +1161,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     tcx.collect_constrained_late_bound_regions(&projection_ty);\n                 let late_bound_in_ty =\n                     tcx.collect_referenced_late_bound_regions(&trait_ref.rebind(ty));\n-                debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n-                debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n+                debug!(?late_bound_in_trait_ref);\n+                debug!(?late_bound_in_ty);\n \n                 // FIXME: point at the type params that don't have appropriate lifetimes:\n                 // struct S1<F: for<'a> Fn(&i32, &i32) -> &'a i32>(F);\n@@ -1648,6 +1663,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     // Checks that `bounds` contains exactly one element and reports appropriate\n     // errors otherwise.\n+    #[instrument(level = \"debug\", skip(self, all_candidates, ty_param_name, is_equality), ret)]\n     fn one_bound_for_assoc_type<I>(\n         &self,\n         all_candidates: impl Fn() -> I,\n@@ -1677,10 +1693,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 return Err(reported);\n             }\n         };\n-        debug!(\"one_bound_for_assoc_type: bound = {:?}\", bound);\n+        debug!(?bound);\n \n         if let Some(bound2) = next_cand {\n-            debug!(\"one_bound_for_assoc_type: bound2 = {:?}\", bound2);\n+            debug!(?bound2);\n \n             let is_equality = is_equality();\n             let bounds = IntoIterator::into_iter([bound, bound2]).chain(matching_candidates);\n@@ -1776,6 +1792,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     // parameter or `Self`.\n     // NOTE: When this function starts resolving `Trait::AssocTy` successfully\n     // it should also start reporting the `BARE_TRAIT_OBJECTS` lint.\n+    #[instrument(level = \"debug\", skip(self, hir_ref_id, span, qself, assoc_segment), fields(assoc_ident=?assoc_segment.ident), ret)]\n     pub fn associated_path_to_ty(\n         &self,\n         hir_ref_id: hir::HirId,\n@@ -1793,8 +1810,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             Res::Err\n         };\n \n-        debug!(\"associated_path_to_ty: {:?}::{}\", qself_ty, assoc_ident);\n-\n         // Check if we have an enum variant.\n         let mut variant_resolution = None;\n         if let ty::Adt(adt_def, _) = qself_ty.kind() {\n@@ -2050,6 +2065,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         item_def_id: DefId,\n         trait_segment: &hir::PathSegment<'_>,\n         item_segment: &hir::PathSegment<'_>,\n+        constness: ty::BoundConstness,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n@@ -2094,8 +2110,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n \n-        let trait_ref =\n-            self.ast_path_to_mono_trait_ref(span, trait_def_id, self_ty, trait_segment, false);\n+        let trait_ref = self.ast_path_to_mono_trait_ref(\n+            span,\n+            trait_def_id,\n+            self_ty,\n+            trait_segment,\n+            false,\n+            Some(constness),\n+        );\n \n         let item_substs = self.create_substs_for_associated_item(\n             span,\n@@ -2534,12 +2556,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             Res::Def(DefKind::AssocTy, def_id) => {\n                 debug_assert!(path.segments.len() >= 2);\n                 self.prohibit_generics(path.segments[..path.segments.len() - 2].iter(), |_| {});\n+                // HACK: until we support `<Type as ~const Trait>`, assume all of them are.\n+                let constness = if tcx.has_attr(tcx.parent(def_id), sym::const_trait) {\n+                    ty::BoundConstness::ConstIfConst\n+                } else {\n+                    ty::BoundConstness::NotConst\n+                };\n                 self.qpath_to_ty(\n                     span,\n                     opt_self_ty,\n                     def_id,\n                     &path.segments[path.segments.len() - 2],\n                     path.segments.last().unwrap(),\n+                    constness,\n                 )\n             }\n             Res::PrimTy(prim_ty) => {\n@@ -2658,6 +2687,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     &GenericArgs::none(),\n                     true,\n                     None,\n+                    None,\n                 );\n                 EarlyBinder(self.normalize_ty(span, tcx.at(span).type_of(def_id)))\n                     .subst(tcx, substs)\n@@ -2766,6 +2796,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self, hir_id, unsafety, abi, decl, generics, hir_ty), ret)]\n     pub fn ty_of_fn(\n         &self,\n         hir_id: hir::HirId,\n@@ -2775,8 +2806,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generics: Option<&hir::Generics<'_>>,\n         hir_ty: Option<&hir::Ty<'_>>,\n     ) -> ty::PolyFnSig<'tcx> {\n-        debug!(\"ty_of_fn\");\n-\n         let tcx = self.tcx();\n         let bound_vars = tcx.late_bound_vars(hir_id);\n         debug!(?bound_vars);\n@@ -2826,7 +2855,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::FnRetTy::DefaultReturn(..) => tcx.mk_unit(),\n         };\n \n-        debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n+        debug!(?output_ty);\n \n         let fn_ty = tcx.mk_fn_sig(input_tys.into_iter(), output_ty, decl.c_variadic, unsafety, abi);\n         let bare_fn_ty = ty::Binder::bind_with_vars(fn_ty, bound_vars);\n@@ -2903,8 +2932,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(i), .. }) =\n                 hir.get(hir.get_parent_node(fn_hir_id)) else { bug!(\"ImplItem should have Impl parent\") };\n \n-        let trait_ref =\n-            self.instantiate_mono_trait_ref(i.of_trait.as_ref()?, self.ast_ty_to_ty(i.self_ty));\n+        let trait_ref = self.instantiate_mono_trait_ref(\n+            i.of_trait.as_ref()?,\n+            self.ast_ty_to_ty(i.self_ty),\n+            ty::BoundConstness::NotConst,\n+        );\n \n         let assoc = tcx.associated_items(trait_ref.def_id).find_by_name_and_kind(\n             tcx,"}, {"sha": "70a171c02b26b5140b1016244e160920be48a8f5", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -713,6 +713,10 @@ fn resolve_regions_with_wf_tys<'tcx>(\n \n     add_constraints(&infcx, region_bound_pairs);\n \n+    infcx.process_registered_region_obligations(\n+        outlives_environment.region_bound_pairs(),\n+        param_env,\n+    );\n     let errors = infcx.resolve_regions(&outlives_environment);\n \n     debug!(?errors, \"errors\");"}, {"sha": "e261bb07f954541a4bd85390fe3b0d10c06ecedf", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -1143,7 +1143,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n         }\n \n         ImplItem(hir::ImplItem { kind: ImplItemKind::Fn(sig, _), generics, .. }) => {\n-            // Do not try to inference the return type for a impl method coming from a trait\n+            // Do not try to infer the return type for a impl method coming from a trait\n             if let Item(hir::Item { kind: ItemKind::Impl(i), .. }) =\n                 tcx.hir().get(tcx.hir().get_parent_node(hir_id))\n                 && i.of_trait.is_some()\n@@ -1286,15 +1286,46 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n \n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n-    match tcx.hir().expect_item(def_id.expect_local()).kind {\n+    let item = tcx.hir().expect_item(def_id.expect_local());\n+    match item.kind {\n         hir::ItemKind::Impl(ref impl_) => impl_.of_trait.as_ref().map(|ast_trait_ref| {\n             let selfty = tcx.type_of(def_id);\n-            <dyn AstConv<'_>>::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n+            <dyn AstConv<'_>>::instantiate_mono_trait_ref(\n+                &icx,\n+                ast_trait_ref,\n+                selfty,\n+                check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n+            )\n         }),\n         _ => bug!(),\n     }\n }\n \n+fn check_impl_constness(\n+    tcx: TyCtxt<'_>,\n+    constness: hir::Constness,\n+    ast_trait_ref: &hir::TraitRef<'_>,\n+) -> ty::BoundConstness {\n+    match constness {\n+        hir::Constness::Const => {\n+            if let Some(trait_def_id) = ast_trait_ref.trait_def_id() && !tcx.has_attr(trait_def_id, sym::const_trait) {\n+                let trait_name = tcx.item_name(trait_def_id).to_string();\n+                tcx.sess.emit_err(errors::ConstImplForNonConstTrait {\n+                    trait_ref_span: ast_trait_ref.path.span,\n+                    trait_name,\n+                    local_trait_span: trait_def_id.as_local().map(|_| tcx.def_span(trait_def_id).shrink_to_lo()),\n+                    marking: (),\n+                    adding: (),\n+                });\n+                ty::BoundConstness::NotConst\n+            } else {\n+                ty::BoundConstness::ConstIfConst\n+            }\n+        },\n+        hir::Constness::NotConst => ty::BoundConstness::NotConst,\n+    }\n+}\n+\n fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n     let is_rustc_reservation = tcx.has_attr(def_id, sym::rustc_reservation_impl);\n     let item = tcx.hir().expect_item(def_id.expect_local());"}, {"sha": "c7777a946893a689e3eb56b45109a7138320f38a", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -249,6 +249,11 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n     // Now create the real type and const parameters.\n     let type_start = own_start - has_self as u32 + params.len() as u32;\n     let mut i = 0;\n+    let mut next_index = || {\n+        let prev = i;\n+        i += 1;\n+        prev as u32 + type_start\n+    };\n \n     const TYPE_DEFAULT_NOT_ALLOWED: &'static str = \"defaults for type parameters are only allowed in \\\n     `struct`, `enum`, `type`, or `trait` definitions\";\n@@ -278,15 +283,13 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n \n             let kind = ty::GenericParamDefKind::Type { has_default: default.is_some(), synthetic };\n \n-            let param_def = ty::GenericParamDef {\n-                index: type_start + i as u32,\n+            Some(ty::GenericParamDef {\n+                index: next_index(),\n                 name: param.name.ident().name,\n                 def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind,\n-            };\n-            i += 1;\n-            Some(param_def)\n+            })\n         }\n         GenericParamKind::Const { default, .. } => {\n             if !matches!(allow_defaults, Defaults::Allowed) && default.is_some() {\n@@ -297,15 +300,13 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                 );\n             }\n \n-            let param_def = ty::GenericParamDef {\n-                index: type_start + i as u32,\n+            Some(ty::GenericParamDef {\n+                index: next_index(),\n                 name: param.name.ident().name,\n                 def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind: ty::GenericParamDefKind::Const { has_default: default.is_some() },\n-            };\n-            i += 1;\n-            Some(param_def)\n+            })\n         }\n     }));\n \n@@ -323,8 +324,8 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             &[\"<closure_kind>\", \"<closure_signature>\", \"<upvars>\"][..]\n         };\n \n-        params.extend(dummy_args.iter().enumerate().map(|(i, &arg)| ty::GenericParamDef {\n-            index: type_start + i as u32,\n+        params.extend(dummy_args.iter().map(|&arg| ty::GenericParamDef {\n+            index: next_index(),\n             name: Symbol::intern(arg),\n             def_id,\n             pure_wrt_drop: false,\n@@ -337,7 +338,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n         let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n         if let Node::Expr(&Expr { kind: ExprKind::ConstBlock(_), .. }) = parent_node {\n             params.push(ty::GenericParamDef {\n-                index: type_start,\n+                index: next_index(),\n                 name: Symbol::intern(\"<const_ty>\"),\n                 def_id,\n                 pure_wrt_drop: false,"}, {"sha": "bd0c1f5dd109860884c610498e1e8d0d9129814a", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -249,3 +249,24 @@ pub struct ExpectedUsedSymbol {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_const_impl_for_non_const_trait)]\n+pub struct ConstImplForNonConstTrait {\n+    #[primary_span]\n+    pub trait_ref_span: Span,\n+    pub trait_name: String,\n+    #[suggestion(applicability = \"machine-applicable\", code = \"#[const_trait]\")]\n+    pub local_trait_span: Option<Span>,\n+    #[note]\n+    pub marking: (),\n+    #[note(adding)]\n+    pub adding: (),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_const_bound_for_non_const_trait)]\n+pub struct ConstBoundForNonConstTrait {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "30feabe1a09591913d4f60a44edeb4f9dee11b14", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -303,32 +303,6 @@ impl<'tcx> WfPredicates<'tcx> {\n         let obligations = if trait_pred.constness == ty::BoundConstness::NotConst {\n             self.nominal_obligations_without_const(trait_ref.def_id, trait_ref.substs)\n         } else {\n-            if !tcx.has_attr(trait_ref.def_id, rustc_span::sym::const_trait) {\n-                if let Some(item) = self.item &&\n-                   let hir::ItemKind::Impl(impl_) = item.kind &&\n-                   let Some(trait_) = &impl_.of_trait &&\n-                   let Some(def_id) = trait_.trait_def_id() &&\n-                   def_id == trait_ref.def_id\n-                {\n-                    let trait_name = tcx.item_name(def_id);\n-                    let mut err = tcx.sess.struct_span_err(\n-                        self.span,\n-                        &format!(\"const `impl` for trait `{trait_name}` which is not marked with `#[const_trait]`\"),\n-                    );\n-                    if def_id.is_local() {\n-                        let sp = tcx.def_span(def_id).shrink_to_lo();\n-                        err.span_suggestion(sp, &format!(\"mark `{trait_name}` as const\"), \"#[const_trait]\", rustc_errors::Applicability::MachineApplicable);\n-                    }\n-                    err.note(\"marking a trait with `#[const_trait]` ensures all default method bodies are `const`\");\n-                    err.note(\"adding a non-const method body in the future would be a breaking change\");\n-                    err.emit();\n-                } else {\n-                    tcx.sess.span_err(\n-                        self.span,\n-                        \"~const can only be applied to `#[const_trait]` traits\",\n-                    );\n-                }\n-            }\n             self.nominal_obligations(trait_ref.def_id, trait_ref.substs)\n         };\n "}, {"sha": "3412d3730d01175de0d2febcaa1d6615f4a05ff2", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -101,7 +101,7 @@ pub const unsafe fn unreachable_unchecked() -> ! {\n     // SAFETY: the safety contract for `intrinsics::unreachable` must\n     // be upheld by the caller.\n     unsafe {\n-        intrinsics::assert_unsafe_precondition!(() => false);\n+        intrinsics::assert_unsafe_precondition!(\"hint::unreachable_unchecked must never be reached\", () => false);\n         intrinsics::unreachable()\n     }\n }"}, {"sha": "1dc79afe83fdba4593a0b667c8f4840646dc8c71", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -2203,15 +2203,17 @@ extern \"rust-intrinsic\" {\n /// the occasional mistake, and this check should help them figure things out.\n #[allow_internal_unstable(const_eval_select)] // permit this to be called in stably-const fn\n macro_rules! assert_unsafe_precondition {\n-    ($([$($tt:tt)*])?($($i:ident:$ty:ty),*$(,)?) => $e:expr) => {\n+    ($name:expr, $([$($tt:tt)*])?($($i:ident:$ty:ty),*$(,)?) => $e:expr) => {\n         if cfg!(debug_assertions) {\n             // allow non_snake_case to allow capturing const generics\n             #[allow(non_snake_case)]\n             #[inline(always)]\n             fn runtime$(<$($tt)*>)?($($i:$ty),*) {\n                 if !$e {\n                     // don't unwind to reduce impact on code size\n-                    ::core::panicking::panic_str_nounwind(\"unsafe precondition violated\");\n+                    ::core::panicking::panic_str_nounwind(\n+                        concat!(\"unsafe precondition(s) violated: \", $name)\n+                    );\n                 }\n             }\n             #[allow(non_snake_case)]\n@@ -2350,7 +2352,10 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n     // SAFETY: the safety contract for `copy_nonoverlapping` must be\n     // upheld by the caller.\n     unsafe {\n-        assert_unsafe_precondition!([T](src: *const T, dst: *mut T, count: usize) =>\n+        assert_unsafe_precondition!(\n+            \"ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null \\\n+            and the specified memory ranges do not overlap\",\n+            [T](src: *const T, dst: *mut T, count: usize) =>\n             is_aligned_and_not_null(src)\n                 && is_aligned_and_not_null(dst)\n                 && is_nonoverlapping(src, dst, count)\n@@ -2436,8 +2441,11 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n \n     // SAFETY: the safety contract for `copy` must be upheld by the caller.\n     unsafe {\n-        assert_unsafe_precondition!([T](src: *const T, dst: *mut T) =>\n-            is_aligned_and_not_null(src) && is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::copy requires that both pointer arguments are aligned aligned and non-null\",\n+            [T](src: *const T, dst: *mut T) =>\n+            is_aligned_and_not_null(src) && is_aligned_and_not_null(dst)\n+        );\n         copy(src, dst, count)\n     }\n }\n@@ -2505,7 +2513,10 @@ pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n \n     // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n     unsafe {\n-        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::write_bytes requires that the destination pointer is aligned and non-null\",\n+            [T](dst: *mut T) => is_aligned_and_not_null(dst)\n+        );\n         write_bytes(dst, val, count)\n     }\n }"}, {"sha": "6b6f3417f8ad5788ab7aebce12024111ed6665af", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -56,7 +56,10 @@ macro_rules! nonzero_integers {\n                 pub const unsafe fn new_unchecked(n: $Int) -> Self {\n                     // SAFETY: this is guaranteed to be safe by the caller.\n                     unsafe {\n-                        core::intrinsics::assert_unsafe_precondition!((n: $Int) => n != 0);\n+                        core::intrinsics::assert_unsafe_precondition!(\n+                            concat!(stringify!($Ty), \"::new_unchecked requires a non-zero argument\"),\n+                            (n: $Int) => n != 0\n+                        );\n                         Self(n)\n                     }\n                 }"}, {"sha": "3e06776d2c6fae5f569e6c41690b75d13b096dd6", "filename": "library/core/src/ops/index_range.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -19,7 +19,12 @@ impl IndexRange {\n     #[inline]\n     pub const unsafe fn new_unchecked(start: usize, end: usize) -> Self {\n         // SAFETY: comparisons on usize are pure\n-        unsafe { assert_unsafe_precondition!((start: usize, end: usize) => start <= end) };\n+        unsafe {\n+            assert_unsafe_precondition!(\n+               \"IndexRange::new_unchecked requires `start <= end`\",\n+                (start: usize, end: usize) => start <= end\n+            )\n+        };\n         IndexRange { start, end }\n     }\n "}, {"sha": "1390e09dd96aec4c74b785ab6b26a8a0353812ac", "filename": "library/core/src/ptr/alignment.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -76,7 +76,12 @@ impl Alignment {\n     #[inline]\n     pub const unsafe fn new_unchecked(align: usize) -> Self {\n         // SAFETY: Precondition passed to the caller.\n-        unsafe { assert_unsafe_precondition!((align: usize) => align.is_power_of_two()) };\n+        unsafe {\n+            assert_unsafe_precondition!(\n+               \"Alignment::new_unchecked requires a power of two\",\n+                (align: usize) => align.is_power_of_two()\n+            )\n+        };\n \n         // SAFETY: By precondition, this must be a power of two, and\n         // our variants encompass all possible powers of two."}, {"sha": "5a083227bb0efda119a32a6458b3d129affaace6", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -761,7 +761,10 @@ impl<T: ?Sized> *const T {\n         // SAFETY: The comparison has no side-effects, and the intrinsic\n         // does this check internally in the CTFE implementation.\n         unsafe {\n-            assert_unsafe_precondition!([T](this: *const T, origin: *const T) => this >= origin)\n+            assert_unsafe_precondition!(\n+                \"ptr::sub_ptr requires `this >= origin`\",\n+                [T](this: *const T, origin: *const T) => this >= origin\n+            )\n         };\n \n         let pointee_size = mem::size_of::<T>();"}, {"sha": "565c38d222a2c4339ceec5e77fc9d8a0adeae978", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -581,12 +581,21 @@ pub const fn invalid_mut<T>(addr: usize) -> *mut T {\n /// Convert an address back to a pointer, picking up a previously 'exposed' provenance.\n ///\n /// This is equivalent to `addr as *const T`. The provenance of the returned pointer is that of *any*\n-/// pointer that was previously passed to [`expose_addr`][pointer::expose_addr] or a `ptr as usize`\n-/// cast. If there is no previously 'exposed' provenance that justifies the way this pointer will be\n-/// used, the program has undefined behavior. Note that there is no algorithm that decides which\n-/// provenance will be used. You can think of this as \"guessing\" the right provenance, and the guess\n-/// will be \"maximally in your favor\", in the sense that if there is any way to avoid undefined\n-/// behavior, then that is the guess that will be taken.\n+/// pointer that was previously exposed by passing it to [`expose_addr`][pointer::expose_addr],\n+/// or a `ptr as usize` cast. In addition, memory which is outside the control of the Rust abstract\n+/// machine (MMIO registers, for example) is always considered to be exposed, so long as this memory\n+/// is disjoint from memory that will be used by the abstract machine such as the stack, heap,\n+/// and statics.\n+///\n+/// If there is no 'exposed' provenance that justifies the way this pointer will be used,\n+/// the program has undefined behavior. In particular, the aliasing rules still apply: pointers\n+/// and references that have been invalidated due to aliasing accesses cannot be used any more,\n+/// even if they have been exposed!\n+///\n+/// Note that there is no algorithm that decides which provenance will be used. You can think of this\n+/// as \"guessing\" the right provenance, and the guess will be \"maximally in your favor\", in the sense\n+/// that if there is any way to avoid undefined behavior (while upholding all aliasing requirements),\n+/// then that is the guess that will be taken.\n ///\n /// On platforms with multiple address spaces, it is your responsibility to ensure that the\n /// address makes sense in the address space that this pointer will be used with.\n@@ -889,7 +898,10 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n     // SAFETY: the caller must guarantee that `x` and `y` are\n     // valid for writes and properly aligned.\n     unsafe {\n-        assert_unsafe_precondition!([T](x: *mut T, y: *mut T, count: usize) =>\n+        assert_unsafe_precondition!(\n+            \"ptr::swap_nonoverlapping requires that both pointer arguments are aligned and non-null \\\n+            and the specified memory ranges do not overlap\",\n+            [T](x: *mut T, y: *mut T, count: usize) =>\n             is_aligned_and_not_null(x)\n                 && is_aligned_and_not_null(y)\n                 && is_nonoverlapping(x, y, count)\n@@ -986,7 +998,10 @@ pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n     // and cannot overlap `src` since `dst` must point to a distinct\n     // allocated object.\n     unsafe {\n-        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::replace requires that the pointer argument is aligned and non-null\",\n+            [T](dst: *mut T) => is_aligned_and_not_null(dst)\n+        );\n         mem::swap(&mut *dst, &mut src); // cannot overlap\n     }\n     src\n@@ -1117,7 +1132,10 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n     // Also, since we just wrote a valid value into `tmp`, it is guaranteed\n     // to be properly initialized.\n     unsafe {\n-        assert_unsafe_precondition!([T](src: *const T) => is_aligned_and_not_null(src));\n+        assert_unsafe_precondition!(\n+            \"ptr::read requires that the pointer argument is aligned and non-null\",\n+            [T](src: *const T) => is_aligned_and_not_null(src)\n+        );\n         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n         tmp.assume_init()\n     }\n@@ -1311,7 +1329,10 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n     // `dst` cannot overlap `src` because the caller has mutable access\n     // to `dst` while `src` is owned by this function.\n     unsafe {\n-        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::write requires that the pointer argument is aligned and non-null\",\n+            [T](dst: *mut T) => is_aligned_and_not_null(dst)\n+        );\n         copy_nonoverlapping(&src as *const T, dst, 1);\n         intrinsics::forget(src);\n     }\n@@ -1475,7 +1496,10 @@ pub const unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n pub unsafe fn read_volatile<T>(src: *const T) -> T {\n     // SAFETY: the caller must uphold the safety contract for `volatile_load`.\n     unsafe {\n-        assert_unsafe_precondition!([T](src: *const T) => is_aligned_and_not_null(src));\n+        assert_unsafe_precondition!(\n+            \"ptr::read_volatile requires that the pointer argument is aligned and non-null\",\n+            [T](src: *const T) => is_aligned_and_not_null(src)\n+        );\n         intrinsics::volatile_load(src)\n     }\n }\n@@ -1546,7 +1570,10 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n     // SAFETY: the caller must uphold the safety contract for `volatile_store`.\n     unsafe {\n-        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::write_volatile requires that the pointer argument is aligned and non-null\",\n+            [T](dst: *mut T) => is_aligned_and_not_null(dst)\n+        );\n         intrinsics::volatile_store(dst, src);\n     }\n }"}, {"sha": "c18264d13ebac78993f8cbc9ab9090ed521fe0be", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -197,7 +197,7 @@ impl<T: ?Sized> NonNull<T> {\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n         // SAFETY: the caller must guarantee that `ptr` is non-null.\n         unsafe {\n-            assert_unsafe_precondition!([T: ?Sized](ptr: *mut T) => !ptr.is_null());\n+            assert_unsafe_precondition!(\"NonNull::new_unchecked requires that the pointer is non-null\", [T: ?Sized](ptr: *mut T) => !ptr.is_null());\n             NonNull { pointer: ptr as _ }\n         }\n     }"}, {"sha": "6d2f7330d5db55fd4b4a20dde265b8982351fb52", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -232,7 +232,10 @@ unsafe impl<T> const SliceIndex<[T]> for usize {\n         // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n         // so the call to `add` is safe.\n         unsafe {\n-            assert_unsafe_precondition!([T](this: usize, slice: *const [T]) => this < slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked requires that the index is within the slice\",\n+                [T](this: usize, slice: *const [T]) => this < slice.len()\n+            );\n             slice.as_ptr().add(self)\n         }\n     }\n@@ -242,7 +245,10 @@ unsafe impl<T> const SliceIndex<[T]> for usize {\n         let this = self;\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n-            assert_unsafe_precondition!([T](this: usize, slice: *mut [T]) => this < slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked_mut requires that the index is within the slice\",\n+                [T](this: usize, slice: *mut [T]) => this < slice.len()\n+            );\n             slice.as_mut_ptr().add(self)\n         }\n     }\n@@ -295,8 +301,10 @@ unsafe impl<T> const SliceIndex<[T]> for ops::IndexRange {\n         // so the call to `add` is safe.\n \n         unsafe {\n-            assert_unsafe_precondition!([T](end: usize, slice: *const [T]) =>\n-                end <= slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked requires that the index is within the slice\",\n+                [T](end: usize, slice: *const [T]) => end <= slice.len()\n+            );\n             ptr::slice_from_raw_parts(slice.as_ptr().add(self.start()), self.len())\n         }\n     }\n@@ -306,8 +314,10 @@ unsafe impl<T> const SliceIndex<[T]> for ops::IndexRange {\n         let end = self.end();\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n-            assert_unsafe_precondition!([T](end: usize, slice: *mut [T]) =>\n-                end <= slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked_mut requires that the index is within the slice\",\n+                [T](end: usize, slice: *mut [T]) => end <= slice.len()\n+            );\n             ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start()), self.len())\n         }\n     }\n@@ -367,8 +377,11 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n         // so the call to `add` is safe.\n \n         unsafe {\n-            assert_unsafe_precondition!([T](this: ops::Range<usize>, slice: *const [T]) =>\n-            this.end >= this.start && this.end <= slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked requires that the range is within the slice\",\n+                [T](this: ops::Range<usize>, slice: *const [T]) =>\n+                this.end >= this.start && this.end <= slice.len()\n+            );\n             ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start)\n         }\n     }\n@@ -378,8 +391,11 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n         let this = ops::Range { start: self.start, end: self.end };\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n-            assert_unsafe_precondition!([T](this: ops::Range<usize>, slice: *mut [T]) =>\n-                this.end >= this.start && this.end <= slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked_mut requires that the range is within the slice\",\n+                [T](this: ops::Range<usize>, slice: *mut [T]) =>\n+                this.end >= this.start && this.end <= slice.len()\n+            );\n             ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n         }\n     }"}, {"sha": "4f1bb17344b2943f74c86996e8ac7edb4b8af358", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -653,7 +653,10 @@ impl<T> [T] {\n         let ptr = this.as_mut_ptr();\n         // SAFETY: caller has to guarantee that `a < self.len()` and `b < self.len()`\n         unsafe {\n-            assert_unsafe_precondition!([T](a: usize, b: usize, this: &mut [T]) => a < this.len() && b < this.len());\n+            assert_unsafe_precondition!(\n+                \"slice::swap_unchecked requires that the indices are within the slice\",\n+                [T](a: usize, b: usize, this: &mut [T]) => a < this.len() && b < this.len()\n+            );\n             ptr::swap(ptr.add(a), ptr.add(b));\n         }\n     }\n@@ -969,7 +972,10 @@ impl<T> [T] {\n         let this = self;\n         // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n         let new_len = unsafe {\n-            assert_unsafe_precondition!([T](this: &[T], N: usize) => N != 0 && this.len() % N == 0);\n+            assert_unsafe_precondition!(\n+                \"slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n+                [T](this: &[T], N: usize) => N != 0 && this.len() % N == 0\n+            );\n             exact_div(self.len(), N)\n         };\n         // SAFETY: We cast a slice of `new_len * N` elements into\n@@ -1109,7 +1115,10 @@ impl<T> [T] {\n         let this = &*self;\n         // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n         let new_len = unsafe {\n-            assert_unsafe_precondition!([T](this: &[T], N: usize) => N != 0 && this.len() % N == 0);\n+            assert_unsafe_precondition!(\n+                \"slice::as_chunks_unchecked_mut requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n+                [T](this: &[T], N: usize) => N != 0 && this.len() % N == 0\n+            );\n             exact_div(this.len(), N)\n         };\n         // SAFETY: We cast a slice of `new_len * N` elements into\n@@ -1685,7 +1694,10 @@ impl<T> [T] {\n         // `[ptr; mid]` and `[mid; len]` are not overlapping, so returning a mutable reference\n         // is fine.\n         unsafe {\n-            assert_unsafe_precondition!((mid: usize, len: usize) => mid <= len);\n+            assert_unsafe_precondition!(\n+                \"slice::split_at_mut_unchecked requires the index to be within the slice\",\n+                (mid: usize, len: usize) => mid <= len\n+            );\n             (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid))\n         }\n     }"}, {"sha": "052fd34d0b6b7492ca91e0cee82a0c03bef3ea2f", "filename": "library/core/src/slice/raw.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -92,8 +92,10 @@ use crate::ptr;\n pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n     // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n     unsafe {\n-        assert_unsafe_precondition!([T](data: *const T, len: usize) =>\n-            is_aligned_and_not_null(data) && is_valid_allocation_size::<T>(len)\n+        assert_unsafe_precondition!(\n+            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n+            [T](data: *const T, len: usize) => is_aligned_and_not_null(data)\n+                && is_valid_allocation_size::<T>(len)\n         );\n         &*ptr::slice_from_raw_parts(data, len)\n     }\n@@ -135,8 +137,10 @@ pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T]\n pub const unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n     // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n     unsafe {\n-        assert_unsafe_precondition!([T](data: *mut T, len: usize) =>\n-            is_aligned_and_not_null(data) && is_valid_allocation_size::<T>(len)\n+        assert_unsafe_precondition!(\n+            \"slice::from_raw_parts_mut requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n+            [T](data: *mut T, len: usize) => is_aligned_and_not_null(data)\n+                && is_valid_allocation_size::<T>(len)\n         );\n         &mut *ptr::slice_from_raw_parts_mut(data, len)\n     }"}, {"sha": "37a49f2d78acdb24179d078f4e84b32ed017a573", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -1,3 +1,6 @@\n+// miri has some special hacks here that make things unused.\n+#![cfg_attr(miri, allow(unused))]\n+\n use crate::os::unix::prelude::*;\n \n use crate::ffi::{CStr, OsStr, OsString};\n@@ -850,7 +853,6 @@ impl DirEntry {\n         target_os = \"fuchsia\",\n         target_os = \"redox\"\n     )))]\n-    #[cfg_attr(miri, allow(unused))]\n     fn name_cstr(&self) -> &CStr {\n         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }\n     }\n@@ -862,7 +864,6 @@ impl DirEntry {\n         target_os = \"fuchsia\",\n         target_os = \"redox\"\n     ))]\n-    #[cfg_attr(miri, allow(unused))]\n     fn name_cstr(&self) -> &CStr {\n         &self.name\n     }"}, {"sha": "141f16d17f0221bacf36984fa39f565710721053", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -20,6 +20,7 @@\n #![feature(is_terminal)]\n #![feature(staged_api)]\n #![feature(process_exitcode_internals)]\n+#![feature(panic_can_unwind)]\n #![feature(test)]\n \n // Public reexports\n@@ -54,6 +55,7 @@ use std::{\n     collections::VecDeque,\n     env, io,\n     io::prelude::Write,\n+    mem::ManuallyDrop,\n     panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo},\n     process::{self, Command, Termination},\n     sync::mpsc::{channel, Sender},\n@@ -112,6 +114,29 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Option<Opt\n             process::exit(ERROR_EXIT_CODE);\n         }\n     } else {\n+        if !opts.nocapture {\n+            // If we encounter a non-unwinding panic, flush any captured output from the current test,\n+            // and stop  capturing output to ensure that the non-unwinding panic message is visible.\n+            // We also acquire the locks for both output streams to prevent output from other threads\n+            // from interleaving with the panic message or appearing after it.\n+            let builtin_panic_hook = panic::take_hook();\n+            let hook = Box::new({\n+                move |info: &'_ PanicInfo<'_>| {\n+                    if !info.can_unwind() {\n+                        std::mem::forget(std::io::stderr().lock());\n+                        let mut stdout = ManuallyDrop::new(std::io::stdout().lock());\n+                        if let Some(captured) = io::set_output_capture(None) {\n+                            if let Ok(data) = captured.lock() {\n+                                let _ = stdout.write_all(&data);\n+                                let _ = stdout.flush();\n+                            }\n+                        }\n+                    }\n+                    builtin_panic_hook(info);\n+                }\n+            });\n+            panic::set_hook(hook);\n+        }\n         match console::run_tests_console(&opts, tests) {\n             Ok(true) => {}\n             Ok(false) => process::exit(ERROR_EXIT_CODE),"}, {"sha": "5a1a6c0f0f9b12b58249f924cf4882c87c730ffc", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -1293,7 +1293,7 @@ h3.variant {\n \tcontent: \"\\00a0\\00a0\\00a0\";\n }\n \n-.notable-traits .notable, .notable-traits .docblock {\n+.notable-traits .docblock {\n \tmargin: 0;\n }\n "}, {"sha": "efe0cb15f08a08bbd0543f937a5f534e4081c7be", "filename": "src/test/rustdoc-gui/notable-trait.goml", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Frustdoc-gui%2Fnotable-trait.goml", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Frustdoc-gui%2Fnotable-trait.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fnotable-trait.goml?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -24,7 +24,23 @@ assert-position: (\n     \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n     {\"x\": 951},\n )\n-\n+// The tooltip should be beside the `i`\n+click: \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\"\n+compare-elements-position-near: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n+    {\"y\": 2}\n+)\n+compare-elements-position-false: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n+    (\"x\")\n+)\n+// The docblock should be flush with the border.\n+assert-css: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']/*[@class='docblock']\",\n+    {\"margin-left\": \"0px\"}\n+)\n \n // Now only the `i` should be on the next line.\n size: (1055, 600)\n@@ -81,6 +97,27 @@ assert-position: (\n     \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n     {\"x\": 289},\n )\n+// The tooltip should be below `i`\n+compare-elements-position-near-false: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n+    {\"y\": 2}\n+)\n+compare-elements-position-false: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n+    (\"x\")\n+)\n+compare-elements-position-near: (\n+    \"//*[@id='method.create_an_iterator_from_read']/parent::*\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n+    {\"x\": 5}\n+)\n+// The docblock should be flush with the border.\n+assert-css: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']/*[@class='docblock']\",\n+    {\"margin-left\": \"0px\"}\n+)\n \n // Checking on very small mobile. The `i` should be on its own line.\n size: (365, 600)"}, {"sha": "62aa22d41ed8efaf357688b39af5e7fb6d7f6cda", "filename": "src/test/ui/marker_trait_attr/overlap-marker-trait-with-static-lifetime.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+#![feature(marker_trait_attr)]\n+\n+#[marker]\n+trait Marker {}\n+\n+impl Marker for &'static () {}\n+impl Marker for &'static () {}\n+\n+fn main() {}"}, {"sha": "eabce1aeff14030e48d58264fab8329b7cffaa7e", "filename": "src/test/ui/marker_trait_attr/overlap-marker-trait-with-underscore-lifetime.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-underscore-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-underscore-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-underscore-lifetime.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -0,0 +1,9 @@\n+#![feature(marker_trait_attr)]\n+\n+#[marker]\n+trait Marker {}\n+\n+impl Marker for &'_ () {} //~ ERROR type annotations needed\n+impl Marker for &'_ () {} //~ ERROR type annotations needed\n+\n+fn main() {}"}, {"sha": "235c89e200aeea2e72140831c8f5d9c2987a8e09", "filename": "src/test/ui/marker_trait_attr/overlap-marker-trait-with-underscore-lifetime.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-underscore-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-underscore-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-underscore-lifetime.stderr?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -0,0 +1,31 @@\n+error[E0283]: type annotations needed: cannot satisfy `&(): Marker`\n+  --> $DIR/overlap-marker-trait-with-underscore-lifetime.rs:6:6\n+   |\n+LL | impl Marker for &'_ () {}\n+   |      ^^^^^^\n+   |\n+note: multiple `impl`s satisfying `&(): Marker` found\n+  --> $DIR/overlap-marker-trait-with-underscore-lifetime.rs:6:1\n+   |\n+LL | impl Marker for &'_ () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+LL | impl Marker for &'_ () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0283]: type annotations needed: cannot satisfy `&(): Marker`\n+  --> $DIR/overlap-marker-trait-with-underscore-lifetime.rs:7:6\n+   |\n+LL | impl Marker for &'_ () {}\n+   |      ^^^^^^\n+   |\n+note: multiple `impl`s satisfying `&(): Marker` found\n+  --> $DIR/overlap-marker-trait-with-underscore-lifetime.rs:6:1\n+   |\n+LL | impl Marker for &'_ () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+LL | impl Marker for &'_ () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "67e551797755b66ad955154c31f25c606becc540", "filename": "src/test/ui/marker_trait_attr/overlap-marker-trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -7,7 +7,8 @@\n \n use std::fmt::{Debug, Display};\n \n-#[marker] trait Marker {}\n+#[marker]\n+trait Marker {}\n \n impl<T: Debug> Marker for T {}\n impl<T: Display> Marker for T {}"}, {"sha": "133bc0484ee002914a0d6ccd8a795f23ab95e5c1", "filename": "src/test/ui/marker_trait_attr/overlap-marker-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait.stderr?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -1,11 +1,11 @@\n error[E0277]: the trait bound `NotDebugOrDisplay: Marker` is not satisfied\n-  --> $DIR/overlap-marker-trait.rs:27:17\n+  --> $DIR/overlap-marker-trait.rs:28:17\n    |\n LL |     is_marker::<NotDebugOrDisplay>();\n    |                 ^^^^^^^^^^^^^^^^^ the trait `Marker` is not implemented for `NotDebugOrDisplay`\n    |\n note: required by a bound in `is_marker`\n-  --> $DIR/overlap-marker-trait.rs:15:17\n+  --> $DIR/overlap-marker-trait.rs:16:17\n    |\n LL | fn is_marker<T: Marker>() { }\n    |                 ^^^^^^ required by this bound in `is_marker`"}, {"sha": "f7654458feb018e33364845bf218aa327d8ff9ca", "filename": "src/test/ui/marker_trait_attr/overlap-permitted-for-annotated-marker-traits.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-permitted-for-annotated-marker-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-permitted-for-annotated-marker-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmarker_trait_attr%2Foverlap-permitted-for-annotated-marker-traits.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -7,7 +7,8 @@\n \n use std::fmt::{Debug, Display};\n \n-#[marker] trait MyMarker {}\n+#[marker]\n+trait MyMarker {}\n \n impl<T: Debug> MyMarker for T {}\n impl<T: Display> MyMarker for T {}"}, {"sha": "d4f42b787e4da40339f0572b8007f55cc5433163", "filename": "src/test/ui/rfc-2632-const-trait-impl/super-traits-fail-2.nn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.nn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.nn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.nn.stderr?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -1,8 +1,8 @@\n error: ~const can only be applied to `#[const_trait]` traits\n-  --> $DIR/super-traits-fail-2.rs:11:12\n+  --> $DIR/super-traits-fail-2.rs:11:19\n    |\n LL | trait Bar: ~const Foo {}\n-   |            ^^^^^^^^^^\n+   |                   ^^^\n \n error: aborting due to previous error\n "}, {"sha": "d4f42b787e4da40339f0572b8007f55cc5433163", "filename": "src/test/ui/rfc-2632-const-trait-impl/super-traits-fail-2.ny.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.ny.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.ny.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.ny.stderr?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -1,8 +1,8 @@\n error: ~const can only be applied to `#[const_trait]` traits\n-  --> $DIR/super-traits-fail-2.rs:11:12\n+  --> $DIR/super-traits-fail-2.rs:11:19\n    |\n LL | trait Bar: ~const Foo {}\n-   |            ^^^^^^^^^^\n+   |                   ^^^\n \n error: aborting due to previous error\n "}, {"sha": "d433e1cfa698acd8d153a904cae92acf669002d1", "filename": "src/test/ui/rfc-2632-const-trait-impl/super-traits-fail-3.nn.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-3.nn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-3.nn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-3.nn.stderr?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -1,14 +1,14 @@\n error: ~const can only be applied to `#[const_trait]` traits\n-  --> $DIR/super-traits-fail-3.rs:12:12\n+  --> $DIR/super-traits-fail-3.rs:12:19\n    |\n LL | trait Bar: ~const Foo {}\n-   |            ^^^^^^^^^^\n+   |                   ^^^\n \n error: ~const can only be applied to `#[const_trait]` traits\n-  --> $DIR/super-traits-fail-3.rs:15:17\n+  --> $DIR/super-traits-fail-3.rs:15:24\n    |\n LL | const fn foo<T: ~const Bar>(x: &T) {\n-   |                 ^^^^^^^^^^\n+   |                        ^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2a7e8e00bc78cf8298be44d13b45084f8970580b", "filename": "src/test/ui/rfc-2632-const-trait-impl/super-traits-fail-3.ny.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-3.ny.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-3.ny.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-3.ny.stderr?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -1,8 +1,8 @@\n error: ~const can only be applied to `#[const_trait]` traits\n-  --> $DIR/super-traits-fail-3.rs:12:12\n+  --> $DIR/super-traits-fail-3.rs:12:19\n    |\n LL | trait Bar: ~const Foo {}\n-   |            ^^^^^^^^^^\n+   |                   ^^^\n \n error: aborting due to previous error\n "}, {"sha": "e5978c12a09814ff83bda0c965eddd265192369a", "filename": "src/test/ui/rfc-2632-const-trait-impl/super-traits-fail-3.yn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-3.yn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-3.yn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-3.yn.stderr?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -1,8 +1,8 @@\n error: ~const can only be applied to `#[const_trait]` traits\n-  --> $DIR/super-traits-fail-3.rs:15:17\n+  --> $DIR/super-traits-fail-3.rs:15:24\n    |\n LL | const fn foo<T: ~const Bar>(x: &T) {\n-   |                 ^^^^^^^^^^\n+   |                        ^^^\n \n error: aborting due to previous error\n "}, {"sha": "bcbf4f941ecd94922bbd2bc9400539761d3ddc78", "filename": "src/test/ui/wf/issue-103573.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fwf%2Fissue-103573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fwf%2Fissue-103573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fissue-103573.rs?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -0,0 +1,22 @@\n+trait TraitA {\n+    type TypeA;\n+}\n+\n+trait TraitD {\n+    type TypeD;\n+}\n+\n+pub trait TraitB {\n+    type TypeB: TraitD;\n+\n+    fn f(_: &<Self::TypeB as TraitD>::TypeD);\n+}\n+\n+pub trait TraitC<E> {\n+    type TypeC<'a>: TraitB;\n+\n+    fn g<'a>(_: &<<Self::TypeC<'a> as TraitB>::TypeB as TraitA>::TypeA);\n+    //~^ ERROR the trait bound `<<Self as TraitC<E>>::TypeC<'a> as TraitB>::TypeB: TraitA` is not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "fcf3f15e4d3f6f98ecdbadd689a8b3682480a470", "filename": "src/test/ui/wf/issue-103573.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fwf%2Fissue-103573.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0da281b6068a7d889ae89a9bd8991284cc9b7535/src%2Ftest%2Fui%2Fwf%2Fissue-103573.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fissue-103573.stderr?ref=0da281b6068a7d889ae89a9bd8991284cc9b7535", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: the trait bound `<<Self as TraitC<E>>::TypeC<'a> as TraitB>::TypeB: TraitA` is not satisfied\n+  --> $DIR/issue-103573.rs:18:5\n+   |\n+LL |     fn g<'a>(_: &<<Self::TypeC<'a> as TraitB>::TypeB as TraitA>::TypeA);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `TraitA` is not implemented for `<<Self as TraitC<E>>::TypeC<'a> as TraitB>::TypeB`\n+   |\n+help: consider further restricting the associated type\n+   |\n+LL |     fn g<'a>(_: &<<Self::TypeC<'a> as TraitB>::TypeB as TraitA>::TypeA) where <<Self as TraitC<E>>::TypeC<'a> as TraitB>::TypeB: TraitA;\n+   |                                                                         +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}