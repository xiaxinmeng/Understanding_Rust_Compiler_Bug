{"sha": "c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5YTEwYmQyNmIxMzA1ZTUwN2I3YTVhMjNjY2IwYTJhNjRiOGRiYmE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-12T16:52:38Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-24T22:34:20Z"}, "message": "trans: move exported_symbol to Instance::symbol_name.", "tree": {"sha": "1f0044641935defe8d7e82b219272ef2b7bd06ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f0044641935defe8d7e82b219272ef2b7bd06ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "html_url": "https://github.com/rust-lang/rust/commit/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6a5e4884a6c5be54acd53773e68faf02d79f52f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6a5e4884a6c5be54acd53773e68faf02d79f52f", "html_url": "https://github.com/rust-lang/rust/commit/a6a5e4884a6c5be54acd53773e68faf02d79f52f"}], "stats": {"total": 272, "additions": 146, "deletions": 126}, "files": [{"sha": "61978ca71d2fa9af7696486036308dfd5d9dc1a8", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "patch": "@@ -205,6 +205,7 @@ pub trait CrateStore<'tcx> {\n     fn is_impl(&self, did: DefId) -> bool;\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool;\n+    fn is_foreign_item(&self, did: DefId) -> bool;\n     fn is_static_method(&self, did: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n     fn is_typedef(&self, did: DefId) -> bool;\n@@ -399,6 +400,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool\n         { bug!(\"is_extern_item\") }\n+    fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n     fn is_static_method(&self, did: DefId) -> bool { bug!(\"is_static_method\") }\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n     fn is_typedef(&self, did: DefId) -> bool { bug!(\"is_typedef\") }"}, {"sha": "5d5820251491a3d47d0e0d4aab5c41bfc0fae420", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "patch": "@@ -284,6 +284,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::is_extern_item(&cdata, did.index, tcx)\n     }\n \n+    fn is_foreign_item(&self, did: DefId) -> bool {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::is_foreign_item(&cdata, did.index)\n+    }\n+\n     fn is_static_method(&self, def: DefId) -> bool\n     {\n         self.dep_graph.read(DepNode::MetaData(def));"}, {"sha": "2c4edcea611d85d988baf08c07a8e3865e81809f", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "patch": "@@ -1634,6 +1634,16 @@ pub fn is_extern_item<'a, 'tcx>(cdata: Cmd,\n     }\n }\n \n+pub fn is_foreign_item(cdata: Cmd, id: DefIndex) -> bool {\n+    let item_doc = cdata.lookup_item(id);\n+    let parent_item_id = match item_parent_item(cdata, item_doc) {\n+        None => return false,\n+        Some(item_id) => item_id,\n+    };\n+    let parent_item_doc = cdata.lookup_item(parent_item_id.index);\n+    item_family(parent_item_doc) == ForeignMod\n+}\n+\n pub fn is_impl(cdata: Cmd, id: DefIndex) -> bool {\n     let item_doc = cdata.lookup_item(id);\n     match item_family(item_doc) {"}, {"sha": "5476b21dd8c11c503b513e4f07b763712e898054", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "patch": "@@ -1354,6 +1354,8 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     let _task = index.record(def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, def_id);\n+    let parent_id = ecx.tcx.map.get_parent(nitem.id);\n+    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_visibility(rbml_w, &nitem.vis);\n     match nitem.node {\n       hir::ForeignItemFn(ref fndecl, _) => {"}, {"sha": "170c8f75b5056c5ab9054bd7562623a197fabea4", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 80, "deletions": 68, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "patch": "@@ -103,6 +103,7 @@ use util::sha2::{Digest, Sha256};\n \n use rustc::middle::{cstore, weak_lang_items};\n use rustc::hir::def_id::DefId;\n+use rustc::hir::map as hir_map;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::hir::map::definitions::{DefPath, DefPathData};\n@@ -192,89 +193,100 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn exported_name<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                               instance: Instance<'tcx>)\n-                               -> String {\n-    let Instance { def: def_id, ref substs } = instance;\n+impl<'a, 'tcx> Instance<'tcx> {\n+    pub fn symbol_name(self, scx: &SharedCrateContext<'a, 'tcx>) -> String {\n+        let Instance { def: def_id, ref substs } = self;\n \n-    debug!(\"exported_name(def_id={:?}, substs={:?})\",\n-           def_id, substs);\n+        debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n+               def_id, substs);\n \n-    let node_id = scx.tcx().map.as_local_node_id(instance.def);\n+        let node_id = scx.tcx().map.as_local_node_id(def_id);\n \n-    if let Some(id) = node_id {\n-        if scx.sess().plugin_registrar_fn.get() == Some(id) {\n-            let svh = &scx.link_meta().crate_hash;\n-            let idx = instance.def.index;\n-            return scx.sess().generate_plugin_registrar_symbol(svh, idx);\n+        if let Some(id) = node_id {\n+            if scx.sess().plugin_registrar_fn.get() == Some(id) {\n+                let svh = &scx.link_meta().crate_hash;\n+                let idx = def_id.index;\n+                return scx.sess().generate_plugin_registrar_symbol(svh, idx);\n+            }\n         }\n-    }\n-\n-    // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n-    let attrs;\n-    let attrs = if let Some(id) = node_id {\n-        scx.tcx().map.attrs(id)\n-    } else {\n-        attrs = scx.sess().cstore.item_attrs(def_id);\n-        &attrs[..]\n-    };\n \n-    if let Some(name) = attr::find_export_name_attr(scx.sess().diagnostic(), attrs) {\n-        // Use provided name\n-        return name.to_string();\n-    }\n+        // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n+        let attrs = scx.tcx().get_attrs(def_id);\n+        let is_foreign = if let Some(id) = node_id {\n+            match scx.tcx().map.get(id) {\n+                hir_map::NodeForeignItem(_) => true,\n+                _ => false\n+            }\n+        } else {\n+            scx.sess().cstore.is_foreign_item(def_id)\n+        };\n \n-    if attr::contains_name(attrs, \"no_mangle\") {\n-        // Don't mangle\n-        return scx.tcx().item_name(instance.def).as_str().to_string()\n-    }\n-    if let Some(name) = weak_lang_items::link_name(attrs) {\n-        return name.to_string();\n-    }\n+        if let Some(name) = weak_lang_items::link_name(&attrs) {\n+            return name.to_string();\n+        }\n \n-    let def_path = scx.tcx().def_path(def_id);\n-\n-    // We want to compute the \"type\" of this item. Unfortunately, some\n-    // kinds of items (e.g., closures) don't have an entry in the\n-    // item-type array. So walk back up the find the closest parent\n-    // that DOES have an entry.\n-    let mut ty_def_id = def_id;\n-    let instance_ty;\n-    loop {\n-        let key = scx.tcx().def_key(ty_def_id);\n-        match key.disambiguated_data.data {\n-            DefPathData::TypeNs(_) |\n-            DefPathData::ValueNs(_) => {\n-                instance_ty = scx.tcx().lookup_item_type(ty_def_id);\n-                break;\n+        if is_foreign {\n+            if let Some(name) = attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n+                return name.to_string();\n             }\n-            _ => {\n-                // if we're making a symbol for something, there ought\n-                // to be a value or type-def or something in there\n-                // *somewhere*\n-                ty_def_id.index = key.parent.unwrap_or_else(|| {\n-                    bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                         parent\", def_id, ty_def_id);\n-                });\n+            // Don't mangle foreign items.\n+            return scx.tcx().item_name(def_id).as_str().to_string();\n+        }\n+\n+        if let Some(name) = attr::find_export_name_attr(scx.sess().diagnostic(), &attrs) {\n+            // Use provided name\n+            return name.to_string();\n+        }\n+\n+        if attr::contains_name(&attrs, \"no_mangle\") {\n+            // Don't mangle\n+            return scx.tcx().item_name(def_id).as_str().to_string();\n+        }\n+\n+        let def_path = scx.tcx().def_path(def_id);\n+\n+        // We want to compute the \"type\" of this item. Unfortunately, some\n+        // kinds of items (e.g., closures) don't have an entry in the\n+        // item-type array. So walk back up the find the closest parent\n+        // that DOES have an entry.\n+        let mut ty_def_id = def_id;\n+        let instance_ty;\n+        loop {\n+            let key = scx.tcx().def_key(ty_def_id);\n+            match key.disambiguated_data.data {\n+                DefPathData::TypeNs(_) |\n+                DefPathData::ValueNs(_) => {\n+                    instance_ty = scx.tcx().lookup_item_type(ty_def_id);\n+                    break;\n+                }\n+                _ => {\n+                    // if we're making a symbol for something, there ought\n+                    // to be a value or type-def or something in there\n+                    // *somewhere*\n+                    ty_def_id.index = key.parent.unwrap_or_else(|| {\n+                        bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n+                             parent\", def_id, ty_def_id);\n+                    });\n+                }\n             }\n         }\n-    }\n \n-    // Erase regions because they may not be deterministic when hashed\n-    // and should not matter anyhow.\n-    let instance_ty = scx.tcx().erase_regions(&instance_ty.ty);\n+        // Erase regions because they may not be deterministic when hashed\n+        // and should not matter anyhow.\n+        let instance_ty = scx.tcx().erase_regions(&instance_ty.ty);\n \n-    let hash = get_symbol_hash(scx, &def_path, instance_ty, substs.types.as_slice());\n+        let hash = get_symbol_hash(scx, &def_path, instance_ty, substs.types.as_slice());\n \n-    let mut buffer = SymbolPathBuffer {\n-        names: Vec::with_capacity(def_path.data.len())\n-    };\n+        let mut buffer = SymbolPathBuffer {\n+            names: Vec::with_capacity(def_path.data.len())\n+        };\n \n-    item_path::with_forced_absolute_paths(|| {\n-        scx.tcx().push_item_path(&mut buffer, def_id);\n-    });\n+        item_path::with_forced_absolute_paths(|| {\n+            scx.tcx().push_item_path(&mut buffer, def_id);\n+        });\n \n-    mangle(buffer.names.into_iter(), Some(&hash[..]))\n+        mangle(buffer.names.into_iter(), Some(&hash[..]))\n+    }\n }\n \n struct SymbolPathBuffer {"}, {"sha": "94ef80d3b858759d037cfeb3cf134d89151c9c25", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "patch": "@@ -30,7 +30,7 @@ pub use self::ValueOrigin::*;\n use super::CrateTranslation;\n use super::ModuleTranslation;\n \n-use back::{link, symbol_names};\n+use back::link;\n use lint;\n use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n@@ -2635,10 +2635,7 @@ fn iter_functions(llmod: llvm::ModuleRef) -> ValueIter {\n /// This list is later used by linkers to determine the set of symbols needed to\n /// be exposed from a dynamic library and it's also encoded into the metadata.\n pub fn filter_reachable_ids(scx: &SharedCrateContext) -> NodeSet {\n-    scx.reachable().iter().map(|x| *x).filter(|id| {\n-        // First, only worry about nodes which have a symbol name\n-        scx.item_symbols().borrow().contains_key(id)\n-    }).filter(|&id| {\n+    scx.reachable().iter().map(|x| *x).filter(|&id| {\n         // Next, we want to ignore some FFI functions that are not exposed from\n         // this crate. Reachable FFI functions can be lumped into two\n         // categories:\n@@ -2656,7 +2653,18 @@ pub fn filter_reachable_ids(scx: &SharedCrateContext) -> NodeSet {\n             hir_map::NodeForeignItem(..) => {\n                 scx.sess().cstore.is_statically_included_foreign_item(id)\n             }\n-            _ => true,\n+\n+            // Only consider nodes that actually have exported symbols.\n+            hir_map::NodeItem(&hir::Item {\n+                node: hir::ItemStatic(..), .. }) |\n+            hir_map::NodeItem(&hir::Item {\n+                node: hir::ItemFn(..), .. }) |\n+            hir_map::NodeTraitItem(&hir::TraitItem {\n+                node: hir::MethodTraitItem(_, Some(_)), .. }) |\n+            hir_map::NodeImplItem(&hir::ImplItem {\n+                node: hir::ImplItemKind::Method(..), .. }) => true,\n+\n+            _ => false\n         }\n     }).collect()\n }\n@@ -2775,8 +2783,9 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         .collect();\n \n     let sess = shared_ccx.sess();\n-    let mut reachable_symbols = reachable_symbol_ids.iter().map(|id| {\n-        shared_ccx.item_symbols().borrow()[id].to_string()\n+    let mut reachable_symbols = reachable_symbol_ids.iter().map(|&id| {\n+        let def_id = shared_ccx.tcx().map.local_def_id(id);\n+        Instance::mono(&shared_ccx, def_id).symbol_name(&shared_ccx)\n     }).collect::<Vec<_>>();\n     if sess.entry_fn.borrow().is_some() {\n         reachable_symbols.push(\"main\".to_string());\n@@ -2799,8 +2808,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         reachable_symbols.extend(syms.into_iter().filter(|did| {\n             sess.cstore.is_extern_item(shared_ccx.tcx(), *did)\n         }).map(|did| {\n-            let instance = Instance::mono(shared_ccx.tcx(), did);\n-            symbol_names::exported_name(&shared_ccx, instance)\n+            Instance::mono(&shared_ccx, did).symbol_name(&shared_ccx)\n         }));\n     }\n "}, {"sha": "e7fa871d23db585d5bec52e1de2ae0dbe4fe1514", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 16, "deletions": 31, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "patch": "@@ -499,44 +499,20 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return immediate_rvalue(llfn, fn_ptr_ty);\n     }\n \n-    let attrs;\n     let local_id = ccx.tcx().map.as_local_node_id(def_id);\n-    let maybe_node = local_id.and_then(|id| tcx.map.find(id));\n-    let (sym, attrs, local_item) = match maybe_node {\n+    let local_item = match local_id.and_then(|id| tcx.map.find(id)) {\n         Some(hir_map::NodeItem(&hir::Item {\n-            ref attrs, id, span, node: hir::ItemFn(..), ..\n+            span, node: hir::ItemFn(..), ..\n         })) |\n         Some(hir_map::NodeTraitItem(&hir::TraitItem {\n-            ref attrs, id, span, node: hir::MethodTraitItem(_, Some(_)), ..\n+            span, node: hir::MethodTraitItem(_, Some(_)), ..\n         })) |\n         Some(hir_map::NodeImplItem(&hir::ImplItem {\n-            ref attrs, id, span, node: hir::ImplItemKind::Method(..), ..\n+            span, node: hir::ImplItemKind::Method(..), ..\n         })) => {\n-            let sym = symbol_names::exported_name(ccx.shared(), instance);\n-\n-            if declare::get_defined_value(ccx, &sym).is_some() {\n-                ccx.sess().span_fatal(span,\n-                    &format!(\"symbol `{}` is already defined\", sym));\n-            }\n-\n-            (sym, &attrs[..], Some(id))\n-        }\n-\n-        Some(hir_map::NodeForeignItem(&hir::ForeignItem {\n-            ref attrs, name, node: hir::ForeignItemFn(..), ..\n-        })) => {\n-            (imported_name(name, attrs).to_string(), &attrs[..], None)\n-        }\n-\n-        None => {\n-            attrs = ccx.sess().cstore.item_attrs(def_id);\n-            let sym = symbol_names::exported_name(ccx.shared(), instance);\n-            (sym, &attrs[..], None)\n-        }\n-\n-        ref variant => {\n-            bug!(\"get_fn: unexpected variant: {:?}\", variant)\n+            Some(span)\n         }\n+        _ => None\n     };\n \n     // This is subtle and surprising, but sometimes we have to bitcast\n@@ -563,8 +539,16 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n \n+    let sym = instance.symbol_name(ccx.shared());\n     let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n     let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n+        if let Some(span) = local_item {\n+            if declare::get_defined_value(ccx, &sym).is_some() {\n+                ccx.sess().span_fatal(span,\n+                    &format!(\"symbol `{}` is already defined\", sym));\n+            }\n+        }\n+\n         if common::val_ty(llfn) != llptrty {\n             if local_item.is_some() {\n                 bug!(\"symbol `{}` previously declared as {:?}, now wanted as {:?}\",\n@@ -581,7 +565,8 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         assert_eq!(common::val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n \n-        attributes::from_fn_attrs(ccx, attrs, llfn);\n+        let attrs = ccx.tcx().get_attrs(def_id);\n+        attributes::from_fn_attrs(ccx, &attrs, llfn);\n         if local_item.is_some() {\n             // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n             attributes::unwind(llfn, true);"}, {"sha": "5e0d34c2a674d5b851c248aee2a19fc02f91d1b6", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "patch": "@@ -150,7 +150,7 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return llfn;\n     }\n \n-    let symbol = symbol_names::exported_name(ccx.shared(), instance);\n+    let symbol = instance.symbol_name(ccx.shared());\n \n     // Compute the rust-call form of the closure call method.\n     let sig = &tcx.closure_type(closure_id, substs).sig;"}, {"sha": "bf7d1ef4d0636dcbedee13cf6d96cdf0761d1ca3", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "patch": "@@ -19,8 +19,7 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use {abi, adt, closure, debuginfo, expr, machine};\n-use base::{self, imported_name, push_ctxt};\n-use back::symbol_names;\n+use base::{self, push_ctxt};\n use callee::Callee;\n use collector;\n use trans_item::TransItem;\n@@ -1018,6 +1017,8 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n         return Datum::new(g, ty, Lvalue::new(\"static\"));\n     }\n \n+    let sym = instance.symbol_name(ccx.shared());\n+\n     let g = if let Some(id) = ccx.tcx().map.as_local_node_id(def_id) {\n         let llty = type_of::type_of(ccx, ty);\n         match ccx.tcx().map.get(id) {\n@@ -1028,7 +1029,6 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                 // we need to get the symbol from metadata instead of\n                 // using the current crate's name/version\n                 // information in the hash of the symbol\n-                let sym = symbol_names::exported_name(ccx.shared(), instance);\n                 debug!(\"making {}\", sym);\n \n                 // Create the global before evaluating the initializer;\n@@ -1043,9 +1043,8 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n             }\n \n             hir_map::NodeForeignItem(&hir::ForeignItem {\n-                ref attrs, name, span, node: hir::ForeignItemStatic(..), ..\n+                ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let ident = imported_name(name, attrs);\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -1067,7 +1066,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                     };\n                     unsafe {\n                         // Declare a symbol `foo` with the desired linkage.\n-                        let g1 = declare::declare_global(ccx, &ident, llty2);\n+                        let g1 = declare::declare_global(ccx, &sym, llty2);\n                         llvm::SetLinkage(g1, linkage);\n \n                         // Declare an internal global `extern_with_linkage_foo` which\n@@ -1077,18 +1076,18 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                         // `extern_with_linkage_foo` will instead be initialized to\n                         // zero.\n                         let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n-                        real_name.push_str(&ident);\n+                        real_name.push_str(&sym);\n                         let g2 = declare::define_global(ccx, &real_name, llty).unwrap_or_else(||{\n                             ccx.sess().span_fatal(span,\n-                                &format!(\"symbol `{}` is already defined\", ident))\n+                                &format!(\"symbol `{}` is already defined\", sym))\n                         });\n                         llvm::SetLinkage(g2, llvm::InternalLinkage);\n                         llvm::LLVMSetInitializer(g2, g1);\n                         g2\n                     }\n                 } else {\n                     // Generate an external declaration.\n-                    declare::declare_global(ccx, &ident, llty)\n+                    declare::declare_global(ccx, &sym, llty)\n                 };\n \n                 for attr in attrs {\n@@ -1105,8 +1104,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n     } else {\n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n-        let name = symbol_names::exported_name(ccx.shared(), instance);\n-        let g = declare::declare_global(ccx, &name, type_of::type_of(ccx, ty));\n+        let g = declare::declare_global(ccx, &sym, type_of::type_of(ccx, ty));\n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the\n         // thread-local attribute locally if it was present remotely. If we"}, {"sha": "b0f8edac0a623ab85ba6455023dc6f722f910952", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::symbol_names;\n use llvm::ValueRef;\n use llvm;\n use rustc::hir::def_id::DefId;\n@@ -88,7 +87,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         monomorphizing.insert(fn_id, depth + 1);\n     }\n \n-    let symbol = symbol_names::exported_name(ccx.shared(), instance);\n+    let symbol = instance.symbol_name(ccx.shared());\n \n     debug!(\"monomorphize_fn mangled to {}\", symbol);\n     assert!(declare::get_defined_value(ccx, &symbol).is_none());"}, {"sha": "11e9e9f3204a28a3b9e0860e3434596a9dbfcf61", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "patch": "@@ -14,7 +14,6 @@\n //! item-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n-use back::symbol_names;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor};\n use syntax::ast;\n@@ -53,7 +52,7 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n                 let instance = Instance::mono(self.ccx.shared(), def_id);\n-                let name = symbol_names::exported_name(self.ccx.shared(), instance);\n+                let name = instance.symbol_name(self.ccx.shared());\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n             } else if attr.check_name(ITEM_PATH) {\n                 let path = tcx.item_path_str(def_id);"}, {"sha": "93fa48b880fdf9a599263134a3eb5a78c7fae8dc", "filename": "src/test/compile-fail/symbol-names/impl1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Ftest%2Fcompile-fail%2Fsymbol-names%2Fimpl1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba/src%2Ftest%2Fcompile-fail%2Fsymbol-names%2Fimpl1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsymbol-names%2Fimpl1.rs?ref=c9a10bd26b1305e507b7a5a23ccb0a2a64b8dbba", "patch": "@@ -25,7 +25,7 @@ mod bar {\n     use foo::Foo;\n \n     impl Foo {\n-        #[rustc_symbol_name] //~ ERROR _ZN5impl13bar26_$LT$impl$u20$foo..Foo$GT$3baz\n+        #[rustc_symbol_name] //~ ERROR _ZN5impl13bar33_$LT$impl$u20$impl1..foo..Foo$GT$3baz\n         #[rustc_item_path] //~ ERROR item-path(bar::<impl foo::Foo>::baz)\n         fn baz() { }\n     }"}]}