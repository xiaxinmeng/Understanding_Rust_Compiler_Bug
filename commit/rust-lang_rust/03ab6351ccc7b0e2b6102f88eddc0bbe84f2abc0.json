{"sha": "03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYWI2MzUxY2NjN2IwZTJiNjEwMmY4OGVkZGMwYmJlODRmMmFiYzA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-06-15T01:21:47Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-06-28T14:44:16Z"}, "message": "librustc: Rewrite reachability and forbid duplicate methods in type implementations.\n\nThis should allow fewer symbols to be exported.", "tree": {"sha": "a9f1b03920bb7864d6149976872072ed0c3b8ede", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9f1b03920bb7864d6149976872072ed0c3b8ede"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "html_url": "https://github.com/rust-lang/rust/commit/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1531ed946e2d650fc6cb5af6258fed8003e9443", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1531ed946e2d650fc6cb5af6258fed8003e9443", "html_url": "https://github.com/rust-lang/rust/commit/a1531ed946e2d650fc6cb5af6258fed8003e9443"}], "stats": {"total": 2258, "additions": 1314, "deletions": 944}, "files": [{"sha": "fad04b772eb7c630e0aa5470c3727ab016a9162e", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -12,6 +12,8 @@\n \n use core::prelude::*;\n \n+use core::str;\n+\n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n@@ -34,6 +36,20 @@ pub struct Doc {\n     end: uint,\n }\n \n+impl Doc {\n+    pub fn get(&self, tag: uint) -> Doc {\n+        reader::get_doc(*self, tag)\n+    }\n+\n+    pub fn as_str_slice<'a>(&'a self) -> &'a str {\n+        str::from_bytes_slice(self.data.slice(self.start, self.end))\n+    }\n+\n+    pub fn as_str(&self) -> ~str {\n+        self.as_str_slice().to_owned()\n+    }\n+}\n+\n pub struct TaggedDoc {\n     tag: uint,\n     doc: Doc,\n@@ -94,20 +110,6 @@ pub mod reader {\n \n     // ebml reading\n \n-    impl Doc {\n-        pub fn get(&self, tag: uint) -> Doc {\n-            get_doc(*self, tag)\n-        }\n-\n-        pub fn as_str_slice<'a>(&'a self) -> &'a str {\n-            str::from_bytes_slice(self.data.slice(self.start, self.end))\n-        }\n-\n-        pub fn as_str(&self) -> ~str {\n-            self.as_str_slice().to_owned()\n-        }\n-    }\n-\n     struct Res {\n         val: uint,\n         next: uint"}, {"sha": "56168f923ad7b58f1e306323650dd8b5d7c0a560", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -153,7 +153,7 @@ impl Sem<()> {\n \n #[doc(hidden)]\n impl Sem<~[Waitqueue]> {\n-    pub fn access<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn access_waitqueue<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -456,7 +456,9 @@ impl Clone for Mutex {\n \n impl Mutex {\n     /// Run a function with ownership of the mutex.\n-    pub fn lock<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n+    pub fn lock<U>(&self, blk: &fn() -> U) -> U {\n+        (&self.sem).access_waitqueue(blk)\n+    }\n \n     /// Run a function with ownership of the mutex and a handle to a condvar.\n     pub fn lock_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n@@ -559,7 +561,7 @@ impl RWlock {\n         unsafe {\n             do task::unkillable {\n                 (&self.order_lock).acquire();\n-                do (&self.access_lock).access {\n+                do (&self.access_lock).access_waitqueue {\n                     (&self.order_lock).release();\n                     task::rekillable(blk)\n                 }"}, {"sha": "672c4cd648cf5512ec8b7541fcbbc82d3b769ee3", "filename": "src/libextra/test.rs", "status": "modified", "additions": 124, "deletions": 124, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -19,15 +19,21 @@ use core::prelude::*;\n \n use getopts;\n use sort;\n+use stats::Stats;\n use term;\n+use time::precise_time_ns;\n \n use core::comm::{stream, SharedChan};\n use core::either;\n use core::io;\n+use core::num;\n use core::option;\n+use core::rand::RngUtil;\n+use core::rand;\n use core::result;\n use core::task;\n use core::to_str::ToStr;\n+use core::u64;\n use core::uint;\n use core::vec;\n \n@@ -609,152 +615,146 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n     }\n }\n \n-pub mod bench {\n-    use core::prelude::*;\n-\n-    use core::num;\n-    use core::rand::RngUtil;\n-    use core::rand;\n-    use core::u64;\n-    use core::vec;\n-    use stats::Stats;\n-    use test::{BenchHarness, BenchSamples};\n-    use time::precise_time_ns;\n-\n-    impl BenchHarness {\n-        /// Callback for benchmark functions to run in their body.\n-        pub fn iter(&mut self, inner:&fn()) {\n-            self.ns_start = precise_time_ns();\n-            let k = self.iterations;\n-            for u64::range(0, k) |_| {\n-                inner();\n-            }\n-            self.ns_end = precise_time_ns();\n+impl BenchHarness {\n+    /// Callback for benchmark functions to run in their body.\n+    pub fn iter(&mut self, inner:&fn()) {\n+        self.ns_start = precise_time_ns();\n+        let k = self.iterations;\n+        for u64::range(0, k) |_| {\n+            inner();\n         }\n+        self.ns_end = precise_time_ns();\n+    }\n \n-        pub fn ns_elapsed(&mut self) -> u64 {\n-            if self.ns_start == 0 || self.ns_end == 0 {\n-                0\n-            } else {\n-                self.ns_end - self.ns_start\n-            }\n+    pub fn ns_elapsed(&mut self) -> u64 {\n+        if self.ns_start == 0 || self.ns_end == 0 {\n+            0\n+        } else {\n+            self.ns_end - self.ns_start\n         }\n+    }\n \n-        pub fn ns_per_iter(&mut self) -> u64 {\n-            if self.iterations == 0 {\n-                0\n-            } else {\n-                self.ns_elapsed() / self.iterations\n-            }\n+    pub fn ns_per_iter(&mut self) -> u64 {\n+        if self.iterations == 0 {\n+            0\n+        } else {\n+            self.ns_elapsed() / self.iterations\n         }\n+    }\n \n-        pub fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n-            self.iterations = n;\n-            debug!(\"running benchmark for %u iterations\",\n-                   n as uint);\n-            f(self);\n-        }\n+    pub fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n+        self.iterations = n;\n+        debug!(\"running benchmark for %u iterations\",\n+               n as uint);\n+        f(self);\n+    }\n \n-        // This is the Go benchmark algorithm. It produces a single\n-        // datapoint and always tries to run for 1s.\n-        pub fn go_bench(&mut self, f: &fn(&mut BenchHarness)) {\n-\n-            // Rounds a number down to the nearest power of 10.\n-            fn round_down_10(n: u64) -> u64 {\n-                let mut n = n;\n-                let mut res = 1;\n-                while n > 10 {\n-                    n = n / 10;\n-                    res *= 10;\n-                }\n-                res\n-            }\n+    // This is the Go benchmark algorithm. It produces a single\n+    // datapoint and always tries to run for 1s.\n+    pub fn go_bench(&mut self, f: &fn(&mut BenchHarness)) {\n \n-            // Rounds x up to a number of the form [1eX, 2eX, 5eX].\n-            fn round_up(n: u64) -> u64 {\n-                let base = round_down_10(n);\n-                if n < (2 * base) {\n-                    2 * base\n-                } else if n < (5 * base) {\n-                    5 * base\n-                } else {\n-                    10 * base\n-                }\n+        // Rounds a number down to the nearest power of 10.\n+        fn round_down_10(n: u64) -> u64 {\n+            let mut n = n;\n+            let mut res = 1;\n+            while n > 10 {\n+                n = n / 10;\n+                res *= 10;\n             }\n+            res\n+        }\n \n-            // Initial bench run to get ballpark figure.\n-            let mut n = 1_u64;\n-            self.bench_n(n, f);\n-\n-            while n < 1_000_000_000 &&\n-                self.ns_elapsed() < 1_000_000_000 {\n-                let last = n;\n-\n-                // Try to estimate iter count for 1s falling back to 1bn\n-                // iterations if first run took < 1ns.\n-                if self.ns_per_iter() == 0 {\n-                    n = 1_000_000_000;\n-                } else {\n-                    n = 1_000_000_000 / self.ns_per_iter();\n-                }\n-\n-                n = u64::max(u64::min(n+n/2, 100*last), last+1);\n-                n = round_up(n);\n-                self.bench_n(n, f);\n+        // Rounds x up to a number of the form [1eX, 2eX, 5eX].\n+        fn round_up(n: u64) -> u64 {\n+            let base = round_down_10(n);\n+            if n < (2 * base) {\n+                2 * base\n+            } else if n < (5 * base) {\n+                5 * base\n+            } else {\n+                10 * base\n             }\n         }\n \n-        // This is a more statistics-driven benchmark algorithm.\n-        // It stops as quickly as 50ms, so long as the statistical\n-        // properties are satisfactory. If those properties are\n-        // not met, it may run as long as the Go algorithm.\n-        pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> ~[f64] {\n-\n-            let mut rng = rand::rng();\n-            let mut magnitude = 10;\n-            let mut prev_madp = 0.0;\n+        // Initial bench run to get ballpark figure.\n+        let mut n = 1_u64;\n+        self.bench_n(n, f);\n \n-            loop {\n-                let n_samples = rng.gen_uint_range(50, 60);\n-                let n_iter = rng.gen_uint_range(magnitude,\n-                                                magnitude * 2);\n+        while n < 1_000_000_000 &&\n+            self.ns_elapsed() < 1_000_000_000 {\n+            let last = n;\n \n-                let samples = do vec::from_fn(n_samples) |_| {\n-                    self.bench_n(n_iter as u64, f);\n-                    self.ns_per_iter() as f64\n-                };\n+            // Try to estimate iter count for 1s falling back to 1bn\n+            // iterations if first run took < 1ns.\n+            if self.ns_per_iter() == 0 {\n+                n = 1_000_000_000;\n+            } else {\n+                n = 1_000_000_000 / self.ns_per_iter();\n+            }\n \n-                // Eliminate outliers\n-                let med = samples.median();\n-                let mad = samples.median_abs_dev();\n-                let samples = do vec::filter(samples) |f| {\n-                    num::abs(*f - med) <= 3.0 * mad\n-                };\n+            n = u64::max(u64::min(n+n/2, 100*last), last+1);\n+            n = round_up(n);\n+            self.bench_n(n, f);\n+        }\n+    }\n \n-                debug!(\"%u samples, median %f, MAD=%f, %u survived filter\",\n-                       n_samples, med as float, mad as float,\n-                       samples.len());\n-\n-                if samples.len() != 0 {\n-                    // If we have _any_ cluster of signal...\n-                    let curr_madp = samples.median_abs_dev_pct();\n-                    if self.ns_elapsed() > 1_000_000 &&\n-                        (curr_madp < 1.0 ||\n-                         num::abs(curr_madp - prev_madp) < 0.1) {\n-                        return samples;\n-                    }\n-                    prev_madp = curr_madp;\n-\n-                    if n_iter > 20_000_000 ||\n-                        self.ns_elapsed() > 20_000_000 {\n-                        return samples;\n-                    }\n+    // This is a more statistics-driven benchmark algorithm.\n+    // It stops as quickly as 50ms, so long as the statistical\n+    // properties are satisfactory. If those properties are\n+    // not met, it may run as long as the Go algorithm.\n+    pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> ~[f64] {\n+\n+        let mut rng = rand::rng();\n+        let mut magnitude = 10;\n+        let mut prev_madp = 0.0;\n+\n+        loop {\n+            let n_samples = rng.gen_uint_range(50, 60);\n+            let n_iter = rng.gen_uint_range(magnitude,\n+                                            magnitude * 2);\n+\n+            let samples = do vec::from_fn(n_samples) |_| {\n+                self.bench_n(n_iter as u64, f);\n+                self.ns_per_iter() as f64\n+            };\n+\n+            // Eliminate outliers\n+            let med = samples.median();\n+            let mad = samples.median_abs_dev();\n+            let samples = do vec::filter(samples) |f| {\n+                num::abs(*f - med) <= 3.0 * mad\n+            };\n+\n+            debug!(\"%u samples, median %f, MAD=%f, %u survived filter\",\n+                   n_samples, med as float, mad as float,\n+                   samples.len());\n+\n+            if samples.len() != 0 {\n+                // If we have _any_ cluster of signal...\n+                let curr_madp = samples.median_abs_dev_pct();\n+                if self.ns_elapsed() > 1_000_000 &&\n+                    (curr_madp < 1.0 ||\n+                     num::abs(curr_madp - prev_madp) < 0.1) {\n+                    return samples;\n                 }\n+                prev_madp = curr_madp;\n \n-                magnitude *= 2;\n+                if n_iter > 20_000_000 ||\n+                    self.ns_elapsed() > 20_000_000 {\n+                    return samples;\n+                }\n             }\n+\n+            magnitude *= 2;\n         }\n     }\n+}\n+\n+pub mod bench {\n+    use core::prelude::*;\n+\n+    use core::vec;\n+    use test::{BenchHarness, BenchSamples};\n \n     pub fn benchmark(f: &fn(&mut BenchHarness)) -> BenchSamples {\n "}, {"sha": "18693b52fc87eaab11d139b311c5ac4aa8f83775", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -19,7 +19,7 @@ use front;\n use lib::llvm::llvm;\n use metadata::{creader, cstore, filesearch};\n use metadata;\n-use middle::{trans, freevars, kind, ty, typeck, lint, astencode};\n+use middle::{trans, freevars, kind, ty, typeck, lint, astencode, reachable};\n use middle;\n use util::common::time;\n use util::ppaux;\n@@ -299,10 +299,16 @@ pub fn compile_rest(sess: Session,\n         time(time_passes, ~\"kind checking\", ||\n              kind::check_crate(ty_cx, method_map, crate));\n \n+        let reachable_map =\n+            time(time_passes, ~\"reachability checking\", ||\n+                reachable::find_reachable(ty_cx, method_map, crate));\n+\n         time(time_passes, ~\"lint checking\", ||\n              lint::check_crate(ty_cx, crate));\n \n-        if phases.to == cu_no_trans { return (Some(crate), Some(ty_cx)); }\n+        if phases.to == cu_no_trans {\n+            return (Some(crate), Some(ty_cx));\n+        }\n \n         let maps = astencode::Maps {\n             root_map: root_map,\n@@ -315,9 +321,13 @@ pub fn compile_rest(sess: Session,\n \n         let outputs = outputs.get_ref();\n         time(time_passes, ~\"translation\", ||\n-             trans::base::trans_crate(sess, crate, ty_cx,\n+             trans::base::trans_crate(sess,\n+                                      crate,\n+                                      ty_cx,\n                                       &outputs.obj_filename,\n-                                      exp_map2, maps))\n+                                      exp_map2,\n+                                      reachable_map,\n+                                      maps))\n     };\n \n     let outputs = outputs.get_ref();"}, {"sha": "b1967752e45c816ca8b201c6d4bf144d8625ea52", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 34, "deletions": 41, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -16,7 +16,6 @@ use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n-use middle::trans::reachable;\n use middle::ty::node_id_to_type;\n use middle::ty;\n use middle;\n@@ -60,7 +59,6 @@ pub type encode_inlined_item<'self> = &'self fn(ecx: &EncodeContext,\n pub struct EncodeParams<'self> {\n     diag: @span_handler,\n     tcx: ty::ctxt,\n-    reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'self HashMap<ast::node_id, ~str>,\n     discrim_symbols: &'self HashMap<ast::node_id, @str>,\n@@ -87,7 +85,6 @@ pub struct EncodeContext<'self> {\n     diag: @span_handler,\n     tcx: ty::ctxt,\n     stats: @mut Stats,\n-    reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'self HashMap<ast::node_id, ~str>,\n     discrim_symbols: &'self HashMap<ast::node_id, @str>,\n@@ -157,8 +154,8 @@ fn encode_trait_ref(ebml_w: &mut writer::Encoder,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n \n     ebml_w.start_tag(tag);\n     tyencode::enc_trait_ref(ebml_w.writer, ty_str_ctxt, trait_ref);\n@@ -185,8 +182,8 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n     for params.iter().advance |param| {\n         ebml_w.start_tag(tag);\n         tyencode::enc_type_param_def(ebml_w.writer, ty_str_ctxt, param);\n@@ -218,8 +215,8 @@ pub fn write_type(ecx: &EncodeContext,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n@@ -231,8 +228,8 @@ pub fn write_vstore(ecx: &EncodeContext,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n@@ -264,8 +261,8 @@ fn encode_method_fty(ecx: &EncodeContext,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n     tyencode::enc_bare_fn_ty(ebml_w.writer, ty_str_ctxt, typ);\n \n     ebml_w.end_tag();\n@@ -780,13 +777,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         index: @mut ~[entry<int>],\n                         path: &[ast_map::path_elt]) {\n     let tcx = ecx.tcx;\n-    let must_write =\n-        match item.node {\n-          item_enum(_, _) | item_impl(*) | item_trait(*) | item_struct(*) |\n-          item_mod(*) | item_foreign_mod(*) | item_static(*) => true,\n-          _ => false\n-        };\n-    if !must_write && !reachable(ecx, item.id) { return; }\n \n     fn add_to_index_(item: @item, ebml_w: &writer::Encoder,\n                      index: @mut ~[entry<int>]) {\n@@ -898,23 +888,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n \n-        // If this is a tuple- or enum-like struct, encode the type of the\n-        // constructor.\n-        if struct_def.fields.len() > 0 &&\n-                struct_def.fields[0].node.kind == ast::unnamed_field {\n-            let ctor_id = match struct_def.ctor_id {\n-                Some(ctor_id) => ctor_id,\n-                None => ecx.tcx.sess.bug(\"struct def didn't have ctor id\"),\n-            };\n-\n-            encode_info_for_struct_ctor(ecx,\n-                                        ebml_w,\n-                                        path,\n-                                        item.ident,\n-                                        ctor_id,\n-                                        index);\n-        }\n-\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n@@ -944,6 +917,23 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let bkts = create_index(idx);\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n+\n+        // If this is a tuple- or enum-like struct, encode the type of the\n+        // constructor.\n+        if struct_def.fields.len() > 0 &&\n+                struct_def.fields[0].node.kind == ast::unnamed_field {\n+            let ctor_id = match struct_def.ctor_id {\n+                Some(ctor_id) => ctor_id,\n+                None => ecx.tcx.sess.bug(\"struct def didn't have ctor id\"),\n+            };\n+\n+            encode_info_for_struct_ctor(ecx,\n+                                        ebml_w,\n+                                        path,\n+                                        item.ident,\n+                                        ctor_id,\n+                                        index);\n+        }\n       }\n       item_impl(ref generics, opt_trait, ty, ref methods) => {\n         add_to_index();\n@@ -1092,7 +1082,6 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 index: @mut ~[entry<int>],\n                                 path: ast_map::path,\n                                 abi: AbiSet) {\n-    if !reachable(ecx, nitem.id) { return; }\n     index.push(entry { val: nitem.id, pos: ebml_w.writer.tell() });\n \n     ebml_w.start_tag(tag_items_data_item);\n@@ -1162,6 +1151,12 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                 visit::visit_foreign_item(ni, (cx, v));\n                 match items.get_copy(&ni.id) {\n                     ast_map::node_foreign_item(_, abi, _, pt) => {\n+                        debug!(\"writing foreign item %s::%s\",\n+                               ast_map::path_to_str(\n+                                *pt,\n+                                token::get_ident_interner()),\n+                               *token::ident_to_str(&ni.ident));\n+\n                         let mut ebml_w = copy ebml_w;\n                         // See above\n                         let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n@@ -1466,7 +1461,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n         total_bytes: 0,\n         n_inlines: 0\n     };\n-    let EncodeParams{item_symbols, diag, tcx, reachable, reexports2,\n+    let EncodeParams{item_symbols, diag, tcx, reexports2,\n                      discrim_symbols, cstore, encode_inlined_item,\n                      link_meta, _} = parms;\n     let type_abbrevs = @mut HashMap::new();\n@@ -1475,7 +1470,6 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n         diag: diag,\n         tcx: tcx,\n         stats: stats,\n-        reachable: reachable,\n         reexports2: reexports2,\n         item_symbols: item_symbols,\n         discrim_symbols: discrim_symbols,\n@@ -1557,7 +1551,6 @@ pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n         diag: tcx.diag,\n         ds: def_to_str,\n         tcx: tcx,\n-        reachable: |_id| false,\n         abbrevs: tyencode::ac_no_abbrevs};\n     do io::with_str_writer |wr| {\n         tyencode::enc_ty(wr, cx, t);"}, {"sha": "fb72617b743fc017f7fe995932faaa9b22aa2a99", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -31,7 +31,6 @@ pub struct ctxt {\n     ds: @fn(def_id) -> ~str,\n     // The type context.\n     tcx: ty::ctxt,\n-    reachable: @fn(node_id) -> bool,\n     abbrevs: abbrev_ctxt\n }\n "}, {"sha": "70e94844319e7922379fe382998e24df9dfb021c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -368,14 +368,17 @@ impl tr for ast::def {\n             ast::def_static_method(did.tr(xcx),\n                                    did2_opt.map(|did2| did2.tr(xcx)),\n                                    p)\n-          },\n-          ast::def_self_ty(nid) => ast::def_self_ty(xcx.tr_id(nid)),\n-          ast::def_self(nid, i) => ast::def_self(xcx.tr_id(nid), i),\n-          ast::def_mod(did) => ast::def_mod(did.tr(xcx)),\n-          ast::def_foreign_mod(did) => ast::def_foreign_mod(did.tr(xcx)),\n-          ast::def_static(did, m) => ast::def_static(did.tr(xcx), m),\n-          ast::def_arg(nid, b) => ast::def_arg(xcx.tr_id(nid), b),\n-          ast::def_local(nid, b) => ast::def_local(xcx.tr_id(nid), b),\n+          }\n+          ast::def_method(did0, did1) => {\n+            ast::def_method(did0.tr(xcx), did1.map(|did1| did1.tr(xcx)))\n+          }\n+          ast::def_self_ty(nid) => { ast::def_self_ty(xcx.tr_id(nid)) }\n+          ast::def_self(nid, i) => { ast::def_self(xcx.tr_id(nid), i) }\n+          ast::def_mod(did) => { ast::def_mod(did.tr(xcx)) }\n+          ast::def_foreign_mod(did) => { ast::def_foreign_mod(did.tr(xcx)) }\n+          ast::def_static(did, m) => { ast::def_static(did.tr(xcx), m) }\n+          ast::def_arg(nid, b) => { ast::def_arg(xcx.tr_id(nid), b) }\n+          ast::def_local(nid, b) => { ast::def_local(xcx.tr_id(nid), b) }\n           ast::def_variant(e_did, v_did) => {\n             ast::def_variant(e_did.tr(xcx), v_did.tr(xcx))\n           },\n@@ -692,12 +695,12 @@ trait get_ty_str_ctxt {\n \n impl<'self> get_ty_str_ctxt for e::EncodeContext<'self> {\n     fn ty_str_ctxt(&self) -> @tyencode::ctxt {\n-        let r = self.reachable;\n-        @tyencode::ctxt {diag: self.tcx.sess.diagnostic(),\n-                        ds: e::def_to_str,\n-                        tcx: self.tcx,\n-                        reachable: |a| r.contains(&a),\n-                        abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)}\n+        @tyencode::ctxt {\n+            diag: self.tcx.sess.diagnostic(),\n+            ds: e::def_to_str,\n+            tcx: self.tcx,\n+            abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)\n+        }\n     }\n }\n "}, {"sha": "1361f2c245afc8344bc51226c32a979d32f5be24", "filename": "src/librustc/middle/reachable.rs", "status": "added", "additions": 414, "deletions": 0, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -0,0 +1,414 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Finds items that are externally reachable, to determine which items\n+// need to have their metadata (and possibly their AST) serialized.\n+// All items that can be referred to through an exported name are\n+// reachable, and when a reachable thing is inline or generic, it\n+// makes all other generics or inline functions that it references\n+// reachable as well.\n+\n+use core::prelude::*;\n+use core::iterator::IteratorUtil;\n+\n+use middle::resolve;\n+use middle::ty;\n+use middle::typeck;\n+\n+use core::hashmap::HashSet;\n+use syntax::ast::*;\n+use syntax::ast;\n+use syntax::ast_map;\n+use syntax::ast_util::def_id_of_def;\n+use syntax::attr;\n+use syntax::codemap;\n+use syntax::parse::token;\n+use syntax::visit::Visitor;\n+use syntax::visit;\n+\n+// Returns true if the given set of attributes contains the `#[inline]`\n+// attribute.\n+fn attributes_specify_inlining(attrs: &[attribute]) -> bool {\n+    attr::attrs_contains_name(attrs, \"inline\")\n+}\n+\n+// Returns true if the given set of generics implies that the item it's\n+// associated with must be inlined.\n+fn generics_require_inlining(generics: &Generics) -> bool {\n+    !generics.ty_params.is_empty()\n+}\n+\n+// Returns true if the given item must be inlined because it may be\n+// monomorphized or it was marked with `#[inline]`. This will only return\n+// true for functions.\n+fn item_might_be_inlined(item: @item) -> bool {\n+    if attributes_specify_inlining(item.attrs) {\n+        return true\n+    }\n+\n+    match item.node {\n+        item_fn(_, _, _, ref generics, _) => {\n+            generics_require_inlining(generics)\n+        }\n+        _ => false,\n+    }\n+}\n+\n+// Returns true if the given type method must be inlined because it may be\n+// monomorphized or it was marked with `#[inline]`.\n+fn ty_method_might_be_inlined(ty_method: &ty_method) -> bool {\n+    attributes_specify_inlining(ty_method.attrs) ||\n+        generics_require_inlining(&ty_method.generics)\n+}\n+\n+// Returns true if the given trait method must be inlined because it may be\n+// monomorphized or it was marked with `#[inline]`.\n+fn trait_method_might_be_inlined(trait_method: &trait_method) -> bool {\n+    match *trait_method {\n+        required(ref ty_method) => ty_method_might_be_inlined(ty_method),\n+        provided(_) => true\n+    }\n+}\n+\n+// Information needed while computing reachability.\n+struct ReachableContext {\n+    // The type context.\n+    tcx: ty::ctxt,\n+    // The method map, which links node IDs of method call expressions to the\n+    // methods they've been resolved to.\n+    method_map: typeck::method_map,\n+    // The set of items which must be exported in the linkage sense.\n+    reachable_symbols: @mut HashSet<node_id>,\n+    // A worklist of item IDs. Each item ID in this worklist will be inlined\n+    // and will be scanned for further references.\n+    worklist: @mut ~[node_id],\n+}\n+\n+impl ReachableContext {\n+    // Creates a new reachability computation context.\n+    fn new(tcx: ty::ctxt, method_map: typeck::method_map)\n+           -> ReachableContext {\n+        ReachableContext {\n+            tcx: tcx,\n+            method_map: method_map,\n+            reachable_symbols: @mut HashSet::new(),\n+            worklist: @mut ~[],\n+        }\n+    }\n+\n+    // Step 1: Mark all public symbols, and add all public symbols that might\n+    // be inlined to a worklist.\n+    fn mark_public_symbols(&self, crate: @crate) {\n+        let reachable_symbols = self.reachable_symbols;\n+        let worklist = self.worklist;\n+        let visitor = visit::mk_vt(@Visitor {\n+            visit_item: |item, _, visitor| {\n+                match item.node {\n+                    item_fn(*) => {\n+                        reachable_symbols.insert(item.id);\n+                        if item_might_be_inlined(item) {\n+                            worklist.push(item.id)\n+                        }\n+                    }\n+                    item_struct(ref struct_def, _) => {\n+                        match struct_def.ctor_id {\n+                            None => {}\n+                            Some(ctor_id) => {\n+                                reachable_symbols.insert(ctor_id);\n+                            }\n+                        }\n+                    }\n+                    item_enum(ref enum_def, _) => {\n+                        for enum_def.variants.each |variant| {\n+                            reachable_symbols.insert(variant.node.id);\n+                        }\n+                    }\n+                    item_impl(ref generics, trait_ref, _, ref methods) => {\n+                        // XXX(pcwalton): We conservatively assume any methods\n+                        // on a trait implementation are reachable, when this\n+                        // is not the case. We could be more precise by only\n+                        // treating implementations of reachable or cross-\n+                        // crate traits as reachable.\n+\n+                        // Mark all public methods as reachable.\n+                        for methods.each |method| {\n+                            if method.vis == public || trait_ref.is_some() {\n+                                reachable_symbols.insert(method.id);\n+                            }\n+                        }\n+\n+                        if generics_require_inlining(generics) {\n+                            // If the impl itself has generics, add all public\n+                            // symbols to the worklist.\n+                            for methods.each |method| {\n+                                if method.vis == public ||\n+                                        trait_ref.is_some() {\n+                                    worklist.push(method.id)\n+                                }\n+                            }\n+                        } else {\n+                            // Otherwise, add only public methods that have\n+                            // generics to the worklist.\n+                            for methods.each |method| {\n+                                let generics = &method.generics;\n+                                let attrs = &method.attrs;\n+                                if generics_require_inlining(generics) ||\n+                                        attributes_specify_inlining(*attrs) ||\n+                                        method.vis == public ||\n+                                        trait_ref.is_some() {\n+                                    worklist.push(method.id)\n+                                }\n+                            }\n+                        }\n+                    }\n+                    item_trait(_, _, ref trait_methods) => {\n+                        // Mark all provided methods as reachable.\n+                        for trait_methods.each |trait_method| {\n+                            match *trait_method {\n+                                provided(method) => {\n+                                    reachable_symbols.insert(method.id);\n+                                    worklist.push(method.id)\n+                                }\n+                                required(_) => {}\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                if item.vis == public {\n+                    visit::visit_item(item, (), visitor)\n+                }\n+            },\n+            .. *visit::default_visitor()\n+        });\n+\n+        visit::visit_crate(crate, (), visitor)\n+    }\n+\n+    // Returns true if the given def ID represents a local item that is\n+    // eligible for inlining and false otherwise.\n+    fn def_id_represents_local_inlined_item(tcx: ty::ctxt, def_id: def_id)\n+                                            -> bool {\n+        if def_id.crate != local_crate {\n+            return false\n+        }\n+\n+        let node_id = def_id.node;\n+        match tcx.items.find(&node_id) {\n+            Some(&ast_map::node_item(item, _)) => {\n+                match item.node {\n+                    item_fn(*) => item_might_be_inlined(item),\n+                    _ => false,\n+                }\n+            }\n+            Some(&ast_map::node_trait_method(trait_method, _, _)) => {\n+                match *trait_method {\n+                    required(_) => false,\n+                    provided(_) => true,\n+                }\n+            }\n+            Some(&ast_map::node_method(method, impl_did, _)) => {\n+                if generics_require_inlining(&method.generics) ||\n+                        attributes_specify_inlining(method.attrs) {\n+                    true\n+                } else {\n+                    // Check the impl. If the generics on the self type of the\n+                    // impl require inlining, this method does too.\n+                    assert!(impl_did.crate == local_crate);\n+                    match tcx.items.find(&impl_did.node) {\n+                        Some(&ast_map::node_item(item, _)) => {\n+                            match item.node {\n+                                item_impl(ref generics, _, _, _) => {\n+                                    generics_require_inlining(generics)\n+                                }\n+                                _ => false\n+                            }\n+                        }\n+                        Some(_) => {\n+                            tcx.sess.span_bug(method.span,\n+                                              \"method is not inside an \\\n+                                               impl?!\")\n+                        }\n+                        None => {\n+                            tcx.sess.span_bug(method.span,\n+                                              \"the impl that this method is \\\n+                                               supposedly inside of doesn't \\\n+                                               exist in the AST map?!\")\n+                        }\n+                    }\n+                }\n+            }\n+            Some(_) => false,\n+            None => tcx.sess.bug(\"def ID not in def map?!\"),\n+        }\n+    }\n+\n+    // Helper function to set up a visitor for `propagate()` below.\n+    fn init_visitor(&self) -> visit::vt<()> {\n+        let (worklist, method_map) = (self.worklist, self.method_map);\n+        let (tcx, reachable_symbols) = (self.tcx, self.reachable_symbols);\n+        visit::mk_vt(@visit::Visitor {\n+            visit_expr: |expr, _, visitor| {\n+                match expr.node {\n+                    expr_path(_) => {\n+                        let def = match tcx.def_map.find(&expr.id) {\n+                            Some(&def) => def,\n+                            None => {\n+                                tcx.sess.span_bug(expr.span,\n+                                                  \"def ID not in def map?!\")\n+                            }\n+                        };\n+\n+                        let def_id = def_id_of_def(def);\n+                        if ReachableContext::\n+                                def_id_represents_local_inlined_item(tcx,\n+                                                                     def_id) {\n+                            worklist.push(def_id.node)\n+                        }\n+                        reachable_symbols.insert(def_id.node);\n+                    }\n+                    expr_method_call(*) => {\n+                        match method_map.find(&expr.id) {\n+                            Some(&typeck::method_map_entry {\n+                                origin: typeck::method_static(def_id),\n+                                _\n+                            }) => {\n+                                if ReachableContext::\n+                                    def_id_represents_local_inlined_item(\n+                                        tcx,\n+                                        def_id) {\n+                                    worklist.push(def_id.node)\n+                                }\n+                                reachable_symbols.insert(def_id.node);\n+                            }\n+                            Some(_) => {}\n+                            None => {\n+                                tcx.sess.span_bug(expr.span,\n+                                                  \"method call expression \\\n+                                                   not in method map?!\")\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                visit::visit_expr(expr, (), visitor)\n+            },\n+            ..*visit::default_visitor()\n+        })\n+    }\n+\n+    // Step 2: Mark all symbols that the symbols on the worklist touch.\n+    fn propagate(&self) {\n+        let visitor = self.init_visitor();\n+        let mut scanned = HashSet::new();\n+        while self.worklist.len() > 0 {\n+            let search_item = self.worklist.pop();\n+            if scanned.contains(&search_item) {\n+                loop\n+            }\n+            scanned.insert(search_item);\n+            self.reachable_symbols.insert(search_item);\n+\n+            // Find the AST block corresponding to the item and visit it,\n+            // marking all path expressions that resolve to something\n+            // interesting.\n+            match self.tcx.items.find(&search_item) {\n+                Some(&ast_map::node_item(item, _)) => {\n+                    match item.node {\n+                        item_fn(_, _, _, _, ref search_block) => {\n+                            visit::visit_block(search_block, (), visitor)\n+                        }\n+                        _ => {\n+                            self.tcx.sess.span_bug(item.span,\n+                                                   \"found non-function item \\\n+                                                    in worklist?!\")\n+                        }\n+                    }\n+                }\n+                Some(&ast_map::node_trait_method(trait_method, _, _)) => {\n+                    match *trait_method {\n+                        required(ref ty_method) => {\n+                            self.tcx.sess.span_bug(ty_method.span,\n+                                                   \"found required method in \\\n+                                                    worklist?!\")\n+                        }\n+                        provided(ref method) => {\n+                            visit::visit_block(&method.body, (), visitor)\n+                        }\n+                    }\n+                }\n+                Some(&ast_map::node_method(ref method, _, _)) => {\n+                    visit::visit_block(&method.body, (), visitor)\n+                }\n+                Some(_) => {\n+                    let ident_interner = token::get_ident_interner();\n+                    let desc = ast_map::node_id_to_str(self.tcx.items,\n+                                                       search_item,\n+                                                       ident_interner);\n+                    self.tcx.sess.bug(fmt!(\"found unexpected thingy in \\\n+                                            worklist: %s\",\n+                                            desc))\n+                }\n+                None => {\n+                    self.tcx.sess.bug(fmt!(\"found unmapped ID in worklist: \\\n+                                            %d\",\n+                                           search_item))\n+                }\n+            }\n+        }\n+    }\n+\n+    // Step 3: Mark all destructors as reachable.\n+    //\n+    // XXX(pcwalton): This is a conservative overapproximation, but fixing\n+    // this properly would result in the necessity of computing *type*\n+    // reachability, which might result in a compile time loss.\n+    fn mark_destructors_reachable(&self) {\n+        for self.tcx.destructor_for_type.each |_, destructor_def_id| {\n+            if destructor_def_id.crate == local_crate {\n+                self.reachable_symbols.insert(destructor_def_id.node);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn find_reachable(tcx: ty::ctxt,\n+                      method_map: typeck::method_map,\n+                      crate: @crate)\n+                      -> @mut HashSet<node_id> {\n+    // XXX(pcwalton): We only need to mark symbols that are exported. But this\n+    // is more complicated than just looking at whether the symbol is `pub`,\n+    // because it might be the target of a `pub use` somewhere. For now, I\n+    // think we are fine, because you can't `pub use` something that wasn't\n+    // exported due to the bug whereby `use` only looks through public\n+    // modules even if you're inside the module the `use` appears in. When\n+    // this bug is fixed, however, this code will need to be updated. Probably\n+    // the easiest way to fix this (although a conservative overapproximation)\n+    // is to have the name resolution pass mark all targets of a `pub use` as\n+    // \"must be reachable\".\n+\n+    let reachable_context = ReachableContext::new(tcx, method_map);\n+\n+    // Step 1: Mark all public symbols, and add all public symbols that might\n+    // be inlined to a worklist.\n+    reachable_context.mark_public_symbols(crate);\n+\n+    // Step 2: Mark all symbols that the symbols on the worklist touch.\n+    reachable_context.propagate();\n+\n+    // Step 3: Mark all destructors as reachable.\n+    reachable_context.mark_destructors_reachable();\n+\n+    // Return the set of reachable symbols.\n+    reachable_context.reachable_symbols\n+}\n+"}, {"sha": "224cf7c32a8723c58da267c1ac5fcf655bc0e2aa", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 105, "deletions": 144, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -652,21 +652,9 @@ impl NameBindings {\n                 match self.type_def {\n                     None => None,\n                     Some(ref type_def) => {\n-                        // FIXME (#3784): This is reallllly questionable.\n-                        // Perhaps the right thing to do is to merge def_mod\n-                        // and def_ty.\n                         match (*type_def).type_def {\n                             Some(type_def) => Some(type_def),\n-                            None => {\n-                                match (*type_def).module_def {\n-                                    Some(module_def) => {\n-                                        let module_def = &mut *module_def;\n-                                        module_def.def_id.map(|def_id|\n-                                            def_mod(*def_id))\n-                                    }\n-                                    None => None\n-                                }\n-                            }\n+                            None => None,\n                         }\n                     }\n                 }\n@@ -1230,49 +1218,29 @@ impl Resolver {\n                 visit_item(item, (new_parent, visitor));\n             }\n \n-            item_impl(_, trait_ref_opt, ty, ref methods) => {\n-                // If this implements an anonymous trait and it has static\n-                // methods, then add all the static methods within to a new\n-                // module, if the type was defined within this module.\n+            item_impl(_, None, ty, ref methods) => {\n+                // If this implements an anonymous trait, then add all the\n+                // methods within to a new module, if the type was defined\n+                // within this module.\n                 //\n                 // FIXME (#3785): This is quite unsatisfactory. Perhaps we\n                 // should modify anonymous traits to only be implementable in\n                 // the same module that declared the type.\n \n-                // Bail out early if there are no static methods.\n-                let mut methods_seen = HashMap::new();\n-                let mut has_static_methods = false;\n-                for methods.iter().advance |method| {\n-                    match method.explicit_self.node {\n-                        sty_static => has_static_methods = true,\n-                        _ => {\n-                            // Make sure you can't define duplicate methods\n-                            let ident = method.ident;\n-                            let span = method.span;\n-                            let old_sp = methods_seen.find_or_insert(ident, span);\n-                            if *old_sp != span {\n-                                self.session.span_err(span,\n-                                                      fmt!(\"duplicate definition of method `%s`\",\n-                                                           self.session.str_of(ident)));\n-                                self.session.span_note(*old_sp,\n-                                                       fmt!(\"first definition of method `%s` here\",\n-                                                            self.session.str_of(ident)));\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // If there are static methods, then create the module\n-                // and add them.\n-                match (trait_ref_opt, ty) {\n-                    (None, @Ty { node: ty_path(path, _, _), _ }) if\n-                            has_static_methods && path.idents.len() == 1 => {\n+                // Create the module and add all methods.\n+                match *ty {\n+                    Ty {\n+                        node: ty_path(path, _),\n+                        _\n+                    } if path.idents.len() == 1 => {\n                         let name = path_to_ident(path);\n \n                         let new_parent = match parent.children.find(&name) {\n                             // It already exists\n-                            Some(&child) if child.get_module_if_available().is_some() &&\n-                                            child.get_module().kind == ImplModuleKind => {\n+                            Some(&child) if child.get_module_if_available()\n+                                                 .is_some() &&\n+                                            child.get_module().kind ==\n+                                                ImplModuleKind => {\n                                 ModuleReducedGraphParent(child.get_module())\n                             }\n                             // Create the module\n@@ -1283,39 +1251,45 @@ impl Resolver {\n                                                    ForbidDuplicateModules,\n                                                    sp);\n \n-                                let parent_link = self.get_parent_link(new_parent,\n-                                                                       ident);\n+                                let parent_link =\n+                                    self.get_parent_link(new_parent, ident);\n                                 let def_id = local_def(item.id);\n                                 name_bindings.define_module(Public,\n                                                             parent_link,\n                                                             Some(def_id),\n                                                             ImplModuleKind,\n                                                             sp);\n \n-                                ModuleReducedGraphParent(name_bindings.get_module())\n+                                ModuleReducedGraphParent(\n+                                    name_bindings.get_module())\n                             }\n                         };\n \n-                        // For each static method...\n+                        // For each method...\n                         for methods.iter().advance |method| {\n-                            match method.explicit_self.node {\n+                            // Add the method to the module.\n+                            let ident = method.ident;\n+                            let (method_name_bindings, _) =\n+                                self.add_child(ident,\n+                                               new_parent,\n+                                               ForbidDuplicateValues,\n+                                               method.span);\n+                            let def = match method.explicit_self.node {\n                                 sty_static => {\n-                                    // Add the static method to the\n-                                    // module.\n-                                    let ident = method.ident;\n-                                    let (method_name_bindings, _) =\n-                                        self.add_child(\n-                                            ident,\n-                                            new_parent,\n-                                            ForbidDuplicateValues,\n-                                            method.span);\n-                                    let def = def_fn(local_def(method.id),\n-                                                     method.purity);\n-                                    method_name_bindings.define_value(\n-                                        Public, def, method.span);\n+                                    // Static methods become `def_fn`s.\n+                                    def_fn(local_def(method.id),\n+                                           method.purity)\n                                 }\n-                                _ => {}\n-                            }\n+                                _ => {\n+                                    // Non-static methods become\n+                                    // `def_method`s.\n+                                    def_method(local_def(method.id), None)\n+                                }\n+                            };\n+\n+                            method_name_bindings.define_value(Public,\n+                                                              def,\n+                                                              method.span);\n                         }\n                     }\n                     _ => {}\n@@ -1324,77 +1298,58 @@ impl Resolver {\n                 visit_item(item, (parent, visitor));\n             }\n \n+            item_impl(_, Some(_), ty, ref methods) => {\n+                visit_item(item, parent, visitor);\n+            }\n+\n             item_trait(_, _, ref methods) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n-                // If the trait has static methods, then add all the static\n-                // methods within to a new module.\n-                //\n-                // We only need to create the module if the trait has static\n-                // methods, so check that first.\n-                let mut has_static_methods = false;\n-                for (*methods).iter().advance |method| {\n-                    let ty_m = trait_method_to_ty_method(method);\n-                    match ty_m.explicit_self.node {\n-                        sty_static => {\n-                            has_static_methods = true;\n-                            break;\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-\n-                // Create the module if necessary.\n-                let module_parent_opt;\n-                if has_static_methods {\n-                    let parent_link = self.get_parent_link(parent, ident);\n-                    name_bindings.define_module(privacy,\n-                                                parent_link,\n-                                                Some(local_def(item.id)),\n-                                                TraitModuleKind,\n-                                                sp);\n-                    module_parent_opt = Some(ModuleReducedGraphParent(\n-                        name_bindings.get_module()));\n-                } else {\n-                    module_parent_opt = None;\n-                }\n+                // Add all the methods within to a new module.\n+                let parent_link = self.get_parent_link(parent, ident);\n+                name_bindings.define_module(privacy,\n+                                            parent_link,\n+                                            Some(local_def(item.id)),\n+                                            TraitModuleKind,\n+                                            sp);\n+                let module_parent = ModuleReducedGraphParent(name_bindings.\n+                                                             get_module());\n \n                 // Add the names of all the methods to the trait info.\n                 let mut method_names = HashMap::new();\n                 for methods.iter().advance |method| {\n                     let ty_m = trait_method_to_ty_method(method);\n \n                     let ident = ty_m.ident;\n-                    // Add it to the trait info if not static,\n-                    // add it as a name in the trait module otherwise.\n-                    match ty_m.explicit_self.node {\n-                        sty_static => {\n-                            let def = def_static_method(\n-                                local_def(ty_m.id),\n-                                Some(local_def(item.id)),\n-                                ty_m.purity);\n \n-                            let (method_name_bindings, _) =\n-                                self.add_child(ident,\n-                                               module_parent_opt.get(),\n-                                               ForbidDuplicateValues,\n-                                               ty_m.span);\n-                            method_name_bindings.define_value(Public,\n-                                                              def,\n-                                                              ty_m.span);\n+                    // Add it as a name in the trait module.\n+                    let def = match ty_m.explicit_self.node {\n+                        sty_static => {\n+                            // Static methods become `def_static_method`s.\n+                            def_static_method(local_def(ty_m.id),\n+                                              Some(local_def(item.id)),\n+                                              ty_m.purity)\n                         }\n                         _ => {\n-                            // Make sure you can't define duplicate methods\n-                            let old_sp = method_names.find_or_insert(ident, ty_m.span);\n-                            if *old_sp != ty_m.span {\n-                                self.session.span_err(ty_m.span,\n-                                                      fmt!(\"duplicate definition of method `%s`\",\n-                                                           self.session.str_of(ident)));\n-                                self.session.span_note(*old_sp,\n-                                                       fmt!(\"first definition of method `%s` here\",\n-                                                            self.session.str_of(ident)));\n-                            }\n+                            // Non-static methods become `def_method`s.\n+                            def_method(local_def(ty_m.id),\n+                                       Some(local_def(item.id)))\n+                        }\n+                    };\n+\n+                    let (method_name_bindings, _) =\n+                        self.add_child(ident,\n+                                       module_parent,\n+                                       ForbidDuplicateValues,\n+                                       ty_m.span);\n+                    method_name_bindings.define_value(Public, def, ty_m.span);\n+\n+                    // Add it to the trait info if not static.\n+                    match ty_m.explicit_self.node {\n+                        sty_static => {}\n+                        _ => {\n+                            method_names.insert(ident);\n                         }\n                     }\n                 }\n@@ -1751,6 +1706,9 @@ impl Resolver {\n             child_name_bindings.define_type(privacy, def, dummy_sp());\n             self.structs.insert(def_id);\n           }\n+          def_method(*) => {\n+            // Ignored; handled elsewhere.\n+          }\n           def_self(*) | def_arg(*) | def_local(*) |\n           def_prim_ty(*) | def_ty_param(*) | def_binding(*) |\n           def_use(*) | def_upvar(*) | def_region(*) |\n@@ -2391,7 +2349,8 @@ impl Resolver {\n         }\n         match type_result {\n             BoundResult(target_module, name_bindings) => {\n-                debug!(\"(resolving single import) found type target\");\n+                debug!(\"(resolving single import) found type target: %?\",\n+                        name_bindings.type_def.get().type_def);\n                 import_resolution.type_target =\n                     Some(Target(target_module, name_bindings));\n                 import_resolution.type_id = directive.id;\n@@ -3269,22 +3228,8 @@ impl Resolver {\n     pub fn add_exports_for_module(@mut self,\n                                   exports2: &mut ~[Export2],\n                                   module_: @mut Module) {\n-        for module_.children.iter().advance |(ident, namebindings)| {\n-            debug!(\"(computing exports) maybe export '%s'\",\n-                   self.session.str_of(*ident));\n-            self.add_exports_of_namebindings(&mut *exports2,\n-                                             *ident,\n-                                             *namebindings,\n-                                             TypeNS,\n-                                             false);\n-            self.add_exports_of_namebindings(&mut *exports2,\n-                                             *ident,\n-                                             *namebindings,\n-                                             ValueNS,\n-                                             false);\n-        }\n-\n-        for module_.import_resolutions.iter().advance |(ident, importresolution)| {\n+        for module_.import_resolutions.iter().advance |ident,\n+                                                       importresolution| {\n             if importresolution.privacy != Public {\n                 debug!(\"(computing exports) not reexporting private `%s`\",\n                        self.session.str_of(*ident));\n@@ -4518,8 +4463,8 @@ impl Resolver {\n \n         if path.global {\n             return self.resolve_crate_relative_path(path,\n-                                                 self.xray_context,\n-                                                 namespace);\n+                                                    self.xray_context,\n+                                                    namespace);\n         }\n \n         if path.idents.len() > 1 {\n@@ -4947,6 +4892,22 @@ impl Resolver {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `%s`\",\n                                self.idents_to_str(path.idents));\n+\n+                        // First-class methods are not supported yet; error\n+                        // out here.\n+                        match def {\n+                            def_method(*) => {\n+                                self.session.span_err(expr.span,\n+                                                      \"first-class methods \\\n+                                                       are not supported\");\n+                                self.session.span_note(expr.span,\n+                                                       \"call the method \\\n+                                                        using the `.` \\\n+                                                        syntax\");\n+                            }\n+                            _ => {}\n+                        }\n+\n                         self.record_def(expr.id, def);\n                     }\n                     None => {\n@@ -5415,7 +5376,7 @@ pub fn resolve_crate(session: Session,\n                   -> CrateMap {\n     let resolver = @mut Resolver(session, lang_items, crate);\n     resolver.resolve();\n-    let Resolver{def_map, export_map2, trait_map, _} = copy *resolver;\n+    let Resolver { def_map, export_map2, trait_map, _ } = copy *resolver;\n     CrateMap {\n         def_map: def_map,\n         exp_map2: export_map2,"}, {"sha": "53d0118aa0e6eb94d9090f3874f151309606260d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -54,7 +54,6 @@ use middle::trans::machine;\n use middle::trans::machine::{llalign_of_min, llsize_of};\n use middle::trans::meth;\n use middle::trans::monomorphize;\n-use middle::trans::reachable;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::trans::type_of::*;\n@@ -2437,7 +2436,6 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n             }\n           }\n           ast_map::node_method(m, _, pth) => {\n-            exprt = true;\n             register_method(ccx, id, pth, m)\n           }\n           ast_map::node_foreign_item(ni, _, _, pth) => {\n@@ -2511,7 +2509,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n                               variant))\n           }\n         };\n-        if !(exprt || ccx.reachable.contains(&id)) {\n+        if !exprt {\n             lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n         }\n         ccx.item_vals.insert(id, val);\n@@ -2890,16 +2888,12 @@ pub fn trans_crate(sess: session::Session,\n                    tcx: ty::ctxt,\n                    output: &Path,\n                    emap2: resolve::ExportMap2,\n-                   maps: astencode::Maps) -> (ContextRef, ModuleRef, LinkMeta) {\n+                   reachable_map: @mut HashSet<ast::node_id>,\n+                   maps: astencode::Maps)\n+                   -> (ContextRef, ModuleRef, LinkMeta) {\n \n     let mut symbol_hasher = hash::default_state();\n     let link_meta = link::build_link_meta(sess, crate, output, &mut symbol_hasher);\n-    let reachable = reachable::find_reachable(\n-        &crate.node.module,\n-        emap2,\n-        tcx,\n-        maps.method_map\n-    );\n \n     // Append \".rc\" to crate name as LLVM module identifier.\n     //"}, {"sha": "3405db8e52f6b66f2ae063b383a8e835d24109aa", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -146,7 +146,7 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n             ast::def_static(*) | ast::def_ty(*) | ast::def_prim_ty(*) |\n             ast::def_use(*) | ast::def_typaram_binder(*) |\n             ast::def_region(*) | ast::def_label(*) | ast::def_ty_param(*) |\n-            ast::def_self_ty(*) => {\n+            ast::def_self_ty(*) | ast::def_method(*) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     fmt!(\"Cannot translate def %? \\"}, {"sha": "94a314862cbb458faa1a7154476e3fb7a8379a64", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -117,7 +117,84 @@ pub fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n     }\n }\n \n-pub type ExternMap = HashMap<@str, ValueRef>;\n+pub type ExternMap = @mut HashMap<@str, ValueRef>;\n+\n+// Crate context.  Every crate we compile has one of these.\n+pub struct CrateContext {\n+     sess: session::Session,\n+     llmod: ModuleRef,\n+     td: TargetData,\n+     tn: @TypeNames,\n+     externs: ExternMap,\n+     intrinsics: HashMap<&'static str, ValueRef>,\n+     item_vals: @mut HashMap<ast::node_id, ValueRef>,\n+     exp_map2: resolve::ExportMap2,\n+     item_symbols: @mut HashMap<ast::node_id, ~str>,\n+     link_meta: LinkMeta,\n+     enum_sizes: @mut HashMap<ty::t, uint>,\n+     discrims: @mut HashMap<ast::def_id, ValueRef>,\n+     discrim_symbols: @mut HashMap<ast::node_id, @str>,\n+     tydescs: @mut HashMap<ty::t, @mut tydesc_info>,\n+     // Set when running emit_tydescs to enforce that no more tydescs are\n+     // created.\n+     finished_tydescs: @mut bool,\n+     // Track mapping of external ids to local items imported for inlining\n+     external: @mut HashMap<ast::def_id, Option<ast::node_id>>,\n+     // Cache instances of monomorphized functions\n+     monomorphized: @mut HashMap<mono_id, ValueRef>,\n+     monomorphizing: @mut HashMap<ast::def_id, uint>,\n+     // Cache computed type parameter uses (see type_use.rs)\n+     type_use_cache: @mut HashMap<ast::def_id, @~[type_use::type_uses]>,\n+     // Cache generated vtables\n+     vtables: @mut HashMap<mono_id, ValueRef>,\n+     // Cache of constant strings,\n+     const_cstr_cache: @mut HashMap<@str, ValueRef>,\n+\n+     // Reverse-direction for const ptrs cast from globals.\n+     // Key is an int, cast from a ValueRef holding a *T,\n+     // Val is a ValueRef holding a *[T].\n+     //\n+     // Needed because LLVM loses pointer->pointee association\n+     // when we ptrcast, and we have to ptrcast during translation\n+     // of a [T] const because we form a slice, a [*T,int] pair, not\n+     // a pointer to an LLVM array type.\n+     const_globals: @mut HashMap<int, ValueRef>,\n+\n+     // Cache of emitted const values\n+     const_values: @mut HashMap<ast::node_id, ValueRef>,\n+\n+     // Cache of external const values\n+     extern_const_values: @mut HashMap<ast::def_id, ValueRef>,\n+\n+     module_data: @mut HashMap<~str, ValueRef>,\n+     lltypes: @mut HashMap<ty::t, TypeRef>,\n+     llsizingtypes: @mut HashMap<ty::t, TypeRef>,\n+     adt_reprs: @mut HashMap<ty::t, @adt::Repr>,\n+     names: namegen,\n+     next_addrspace: addrspace_gen,\n+     symbol_hasher: @mut hash::State,\n+     type_hashcodes: @mut HashMap<ty::t, @str>,\n+     type_short_names: @mut HashMap<ty::t, ~str>,\n+     all_llvm_symbols: @mut HashSet<@str>,\n+     tcx: ty::ctxt,\n+     maps: astencode::Maps,\n+     stats: @mut Stats,\n+     upcalls: @upcall::Upcalls,\n+     tydesc_type: TypeRef,\n+     int_type: TypeRef,\n+     float_type: TypeRef,\n+     opaque_vec_type: TypeRef,\n+     builder: BuilderRef_res,\n+     shape_cx: shape::Ctxt,\n+     crate_map: ValueRef,\n+     // Set when at least one function uses GC. Needed so that\n+     // decl_gc_metadata knows whether to link to the module metadata, which\n+     // is not emitted by LLVM's GC pass when no functions use GC.\n+     uses_gc: @mut bool,\n+     dbg_cx: Option<debuginfo::DebugContext>,\n+     do_not_commit_warning_issued: @mut bool,\n+     reachable_map: @mut HashSet<ast::node_id>,\n+}\n \n // Types used for llself.\n pub struct ValSelfData {"}, {"sha": "64d6bbec87c48a36d7b9e651a67206b3a02fb55c", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -37,7 +37,6 @@ pub mod foreign;\n pub mod reflect;\n pub mod debuginfo;\n pub mod type_use;\n-pub mod reachable;\n pub mod machine;\n pub mod adt;\n pub mod asm;"}, {"sha": "e950c24c49e8d415c40bac705c59ada2357b1fc0", "filename": "src/librustc/middle/trans/reachable.rs", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/a1531ed946e2d650fc6cb5af6258fed8003e9443/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1531ed946e2d650fc6cb5af6258fed8003e9443/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=a1531ed946e2d650fc6cb5af6258fed8003e9443", "patch": "@@ -1,246 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Finds items that are externally reachable, to determine which items\n-// need to have their metadata (and possibly their AST) serialized.\n-// All items that can be referred to through an exported name are\n-// reachable, and when a reachable thing is inline or generic, it\n-// makes all other generics or inline functions that it references\n-// reachable as well.\n-\n-use core::prelude::*;\n-\n-use middle::resolve;\n-use middle::ty;\n-use middle::typeck;\n-\n-use core::hashmap::HashSet;\n-use syntax::ast;\n-use syntax::ast::*;\n-use syntax::ast_util::def_id_of_def;\n-use syntax::attr;\n-use syntax::codemap;\n-use syntax::print::pprust::expr_to_str;\n-use syntax::{visit, ast_map};\n-\n-pub type map = @HashSet<node_id>;\n-\n-struct ctx<'self> {\n-    exp_map2: resolve::ExportMap2,\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n-    rmap: &'self mut HashSet<node_id>,\n-}\n-\n-pub fn find_reachable(crate_mod: &_mod, exp_map2: resolve::ExportMap2,\n-                      tcx: ty::ctxt, method_map: typeck::method_map) -> map {\n-    let mut rmap = HashSet::new();\n-    {\n-        let cx = @mut ctx {\n-            exp_map2: exp_map2,\n-            tcx: tcx,\n-            method_map: method_map,\n-            rmap: &mut rmap\n-        };\n-        traverse_public_mod(cx, ast::crate_node_id, crate_mod);\n-        traverse_all_resources_and_impls(cx, crate_mod);\n-    }\n-    return @rmap;\n-}\n-\n-fn traverse_exports(cx: @mut ctx, mod_id: node_id) -> bool {\n-    let mut found_export = false;\n-    match cx.exp_map2.find(&mod_id) {\n-      Some(ref exp2s) => {\n-        for (*exp2s).iter().advance |e2| {\n-            found_export = true;\n-            traverse_def_id(cx, e2.def_id)\n-        };\n-      }\n-      None => ()\n-    }\n-    return found_export;\n-}\n-\n-fn traverse_def_id(cx: @mut ctx, did: def_id) {\n-    if did.crate != local_crate { return; }\n-    match cx.tcx.items.find(&did.node) {\n-        None => (), // This can happen for self, for example\n-        Some(&ast_map::node_item(item, _)) => traverse_public_item(cx, item),\n-        Some(&ast_map::node_method(_, impl_id, _)) => traverse_def_id(cx, impl_id),\n-        Some(&ast_map::node_foreign_item(item, _, _, _)) => {\n-            let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n-            cx.rmap.insert(item.id);\n-        }\n-        Some(&ast_map::node_variant(ref v, _, _)) => {\n-            let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n-            cx.rmap.insert(v.node.id);\n-        }\n-        _ => ()\n-    }\n-}\n-\n-fn traverse_public_mod(cx: @mut ctx, mod_id: node_id, m: &_mod) {\n-    if !traverse_exports(cx, mod_id) {\n-        // No exports, so every local item is exported\n-        for m.items.iter().advance |item| {\n-            traverse_public_item(cx, *item);\n-        }\n-    }\n-}\n-\n-fn traverse_public_item(cx: @mut ctx, item: @item) {\n-    {\n-        // FIXME #6021: naming rmap shouldn't be necessary\n-        let cx = &mut *cx;\n-        let rmap: &mut HashSet<node_id> = cx.rmap;\n-        if rmap.contains(&item.id) { return; }\n-        rmap.insert(item.id);\n-    }\n-\n-    match item.node {\n-      item_mod(ref m) => traverse_public_mod(cx, item.id, m),\n-      item_foreign_mod(ref nm) => {\n-          if !traverse_exports(cx, item.id) {\n-              for nm.items.iter().advance |item| {\n-                  let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n-                  cx.rmap.insert(item.id);\n-              }\n-          }\n-      }\n-      item_fn(_, _, _, ref generics, ref blk) => {\n-        if generics.ty_params.len() > 0u ||\n-           attr::find_inline_attr(item.attrs) != attr::ia_none {\n-            traverse_inline_body(cx, blk);\n-        }\n-      }\n-      item_impl(ref generics, _, _, ref ms) => {\n-        for ms.iter().advance |m| {\n-            if generics.ty_params.len() > 0u ||\n-                m.generics.ty_params.len() > 0u ||\n-                attr::find_inline_attr(m.attrs) != attr::ia_none\n-            {\n-                {\n-                    let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n-                    cx.rmap.insert(m.id);\n-                }\n-                traverse_inline_body(cx, &m.body);\n-            }\n-        }\n-      }\n-      item_struct(ref struct_def, _) => {\n-        for struct_def.ctor_id.iter().advance |&ctor_id| {\n-            let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n-            cx.rmap.insert(ctor_id);\n-        }\n-      }\n-      item_ty(t, _) => {\n-        traverse_ty(t, (cx,\n-                        visit::mk_vt(@visit::Visitor {visit_ty: traverse_ty,\n-                                                      ..*visit::default_visitor()})))\n-      }\n-      item_static(*) |\n-      item_enum(*) | item_trait(*) => (),\n-      item_mac(*) => fail!(\"item macros unimplemented\")\n-    }\n-}\n-\n-fn traverse_ty<'a>(ty: @Ty, (cx, v): (@mut ctx<'a>, visit::vt<@mut ctx<'a>>)) {\n-    {\n-        let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n-        if cx.rmap.contains(&ty.id) { return; }\n-        cx.rmap.insert(ty.id);\n-    }\n-\n-    match ty.node {\n-      ty_path(p, _bounds, p_id) => {\n-        match cx.tcx.def_map.find(&p_id) {\n-          // Kind of a hack to check this here, but I'm not sure what else\n-          // to do\n-          Some(&def_prim_ty(_)) => { /* do nothing */ }\n-          Some(&d) => traverse_def_id(cx, def_id_of_def(d)),\n-          None    => { /* do nothing -- but should we fail here? */ }\n-        }\n-        for p.types.iter().advance |t| {\n-            (v.visit_ty)(*t, (cx, v));\n-        }\n-      }\n-      _ => visit::visit_ty(ty, (cx, v))\n-    }\n-}\n-\n-fn traverse_inline_body(cx: @mut ctx, body: &blk) {\n-    fn traverse_expr<'a>(e: @expr, (cx, v): (@mut ctx<'a>,\n-                                             visit::vt<@mut ctx<'a>>)) {\n-        match e.node {\n-          expr_path(_) => {\n-            match cx.tcx.def_map.find(&e.id) {\n-                Some(&d) => {\n-                    traverse_def_id(cx, def_id_of_def(d));\n-                }\n-                None => cx.tcx.sess.span_bug(\n-                    e.span,\n-                    fmt!(\"Unbound node id %? while traversing %s\",\n-                         e.id,\n-                         expr_to_str(e, cx.tcx.sess.intr())))\n-            }\n-          }\n-          expr_method_call(*) => {\n-            match cx.method_map.find(&e.id) {\n-              Some(&typeck::method_map_entry {\n-                  origin: typeck::method_static(did),\n-                  _\n-                }) => {\n-                traverse_def_id(cx, did);\n-              }\n-              Some(_) => {}\n-              None => {\n-                cx.tcx.sess.span_bug(e.span, \"expr_method_call not in \\\n-                                              method map\");\n-              }\n-            }\n-          }\n-          _ => ()\n-        }\n-        visit::visit_expr(e, (cx, v));\n-    }\n-    // Don't ignore nested items: for example if a generic fn contains a\n-    // generic impl (as in deque::create), we need to monomorphize the\n-    // impl as well\n-    fn traverse_item(i: @item, (cx, _v): (@mut ctx, visit::vt<@mut ctx>)) {\n-      traverse_public_item(cx, i);\n-    }\n-    visit::visit_block(body, (cx, visit::mk_vt(@visit::Visitor {\n-        visit_expr: traverse_expr,\n-        visit_item: traverse_item,\n-         ..*visit::default_visitor()\n-    })));\n-}\n-\n-fn traverse_all_resources_and_impls(cx: @mut ctx, crate_mod: &_mod) {\n-    visit::visit_mod(\n-        crate_mod,\n-        codemap::dummy_sp(),\n-        0,\n-        (cx,\n-        visit::mk_vt(@visit::Visitor {\n-            visit_expr: |_e, (_cx, _v)| { },\n-            visit_item: |i, (cx, v)| {\n-                visit::visit_item(i, (cx, v));\n-                match i.node {\n-                    item_impl(*) => {\n-                        traverse_public_item(cx, i);\n-                    }\n-                    _ => ()\n-                }\n-            },\n-            ..*visit::default_visitor()\n-        })));\n-}"}, {"sha": "b4a710e15b885c3fbe523e416e10724c3b6b74d0", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -791,10 +791,6 @@ impl FnCtxt {\n         ast_ty_to_ty(self, self, ast_t)\n     }\n \n-    pub fn expr_to_str(&self, expr: @ast::expr) -> ~str {\n-        expr.repr(self.tcx())\n-    }\n-\n     pub fn pat_to_str(&self, pat: @ast::pat) -> ~str {\n         pat.repr(self.tcx())\n     }\n@@ -3293,6 +3289,9 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n       ast::def_self_ty(*) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found self ty\");\n       }\n+      ast::def_method(*) => {\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found method\");\n+      }\n     }\n }\n "}, {"sha": "5065a475a4055acb40071a8bec66f73b5af30d40", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -81,10 +81,20 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: &ast::crate) {\n         })));\n }\n \n-impl CrateCtxt {\n+pub trait ToTy {\n     fn to_ty<RS:region_scope + Copy + 'static>(\n-        &self, rs: &RS, ast_ty: &ast::Ty) -> ty::t\n-    {\n+             &self,\n+             rs: &RS,\n+             ast_ty: &ast::Ty)\n+             -> ty::t;\n+}\n+\n+impl ToTy for CrateCtxt {\n+    fn to_ty<RS:region_scope + Copy + 'static>(\n+             &self,\n+             rs: &RS,\n+             ast_ty: &ast::Ty)\n+             -> ty::t {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }"}, {"sha": "7a4ea0999efab6e5d2a60169ca72ed07e53646ac", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -64,7 +64,8 @@ use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n-use middle::typeck::infer::{cres, InferCtxt, ures};\n+use middle::typeck::infer::unify::{InferCtxtMethods, UnifyInferCtxtMethods};\n+use middle::typeck::infer::{InferCtxt, cres, ures};\n use util::common::indent;\n \n use core::result::{iter_vec2, map_vec2};"}, {"sha": "ed19310d5d69eec6fa597cb62149d937ec637e44", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 77, "deletions": 39, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -71,15 +71,53 @@ impl LatticeValue for ty::t {\n     }\n }\n \n-impl CombineFields {\n-    pub fn var_sub_var<T:Copy + InferStr + LatticeValue,\n-                       V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n-                                                                        a_id:\n-                                                                        V,\n-                                                                        b_id:\n-                                                                        V)\n-                                                                        ->\n-                                                                        ures {\n+pub trait CombineFieldsLatticeMethods {\n+    fn var_sub_var<T:Copy + InferStr + LatticeValue,\n+                   V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n+                                                                    a_id: V,\n+                                                                    b_id: V)\n+                                                                    -> ures;\n+    /// make variable a subtype of T\n+    fn var_sub_t<T:Copy + InferStr + LatticeValue,\n+                 V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                 &self,\n+                 a_id: V,\n+                 b: T)\n+                 -> ures;\n+    fn t_sub_var<T:Copy + InferStr + LatticeValue,\n+                 V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                 &self,\n+                 a: T,\n+                 b_id: V)\n+                 -> ures;\n+    fn merge_bnd<T:Copy + InferStr + LatticeValue>(\n+                 &self,\n+                 a: &Bound<T>,\n+                 b: &Bound<T>,\n+                 lattice_op: LatticeOp<T>)\n+                 -> cres<Bound<T>>;\n+    fn set_var_to_merged_bounds<T:Copy + InferStr + LatticeValue,\n+                                V:Copy+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n+                                &self,\n+                                v_id: V,\n+                                a: &Bounds<T>,\n+                                b: &Bounds<T>,\n+                                rank: uint)\n+                                -> ures;\n+    fn bnds<T:Copy + InferStr + LatticeValue>(\n+            &self,\n+            a: &Bound<T>,\n+            b: &Bound<T>)\n+            -> ures;\n+}\n+\n+impl CombineFieldsLatticeMethods for CombineFields {\n+    fn var_sub_var<T:Copy + InferStr + LatticeValue,\n+                   V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                   &self,\n+                   a_id: V,\n+                   b_id: V)\n+                   -> ures {\n         /*!\n          *\n          * Make one variable a subtype of another variable.  This is a\n@@ -127,12 +165,12 @@ impl CombineFields {\n     }\n \n     /// make variable a subtype of T\n-    pub fn var_sub_t<T:Copy + InferStr + LatticeValue,\n-                     V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n-                                                                      a_id: V,\n-                                                                      b: T)\n-                                                                      -> ures\n-                                                                      {\n+    fn var_sub_t<T:Copy + InferStr + LatticeValue,\n+                 V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                 &self,\n+                 a_id: V,\n+                 b: T)\n+                 -> ures {\n         /*!\n          *\n          * Make a variable (`a_id`) a subtype of the concrete type `b` */\n@@ -151,12 +189,12 @@ impl CombineFields {\n             a_id, a_bounds, b_bounds, node_a.rank)\n     }\n \n-    pub fn t_sub_var<T:Copy + InferStr + LatticeValue,\n-                     V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n-                                                                      a: T,\n-                                                                      b_id: V)\n-                                                                      -> ures\n-                                                                      {\n+    fn t_sub_var<T:Copy + InferStr + LatticeValue,\n+                 V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                 &self,\n+                 a: T,\n+                 b_id: V)\n+                 -> ures {\n         /*!\n          *\n          * Make a concrete type (`a`) a subtype of the variable `b_id` */\n@@ -175,12 +213,12 @@ impl CombineFields {\n             b_id, a_bounds, b_bounds, node_b.rank)\n     }\n \n-    pub fn merge_bnd<T:Copy + InferStr + LatticeValue>(&self,\n-                                                       a: &Bound<T>,\n-                                                       b: &Bound<T>,\n-                                                       lattice_op:\n-                                                       LatticeOp<T>)\n-                                                       -> cres<Bound<T>> {\n+    fn merge_bnd<T:Copy + InferStr + LatticeValue>(\n+                 &self,\n+                 a: &Bound<T>,\n+                 b: &Bound<T>,\n+                 lattice_op: LatticeOp<T>)\n+                 -> cres<Bound<T>> {\n         /*!\n          *\n          * Combines two bounds into a more general bound. */\n@@ -202,14 +240,14 @@ impl CombineFields {\n         }\n     }\n \n-    pub fn set_var_to_merged_bounds<T:Copy + InferStr + LatticeValue,\n-                                    V:Copy+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n-                                    &self,\n-                                    v_id: V,\n-                                    a: &Bounds<T>,\n-                                    b: &Bounds<T>,\n-                                    rank: uint)\n-                                    -> ures {\n+    fn set_var_to_merged_bounds<T:Copy + InferStr + LatticeValue,\n+                                V:Copy+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n+                                &self,\n+                                v_id: V,\n+                                a: &Bounds<T>,\n+                                b: &Bounds<T>,\n+                                rank: uint)\n+                                -> ures {\n         /*!\n          *\n          * Updates the bounds for the variable `v_id` to be the intersection\n@@ -264,10 +302,10 @@ impl CombineFields {\n         uok()\n     }\n \n-    pub fn bnds<T:Copy + InferStr + LatticeValue>(&self,\n-                                                  a: &Bound<T>,\n-                                                  b: &Bound<T>)\n-                                                  -> ures {\n+    fn bnds<T:Copy + InferStr + LatticeValue>(&self,\n+                                              a: &Bound<T>,\n+                                              b: &Bound<T>)\n+                                              -> ures {\n         debug!(\"bnds(%s <: %s)\", a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n         let _r = indenter();"}, {"sha": "1311907eed2eea01c63b5eeeb16067660e5e5c92", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -54,7 +54,7 @@ use middle::ty;\n use middle::typeck::infer::{Bounds, cyclic_ty, fixup_err, fres, InferCtxt};\n use middle::typeck::infer::{region_var_bound_by_region_var, unresolved_ty};\n use middle::typeck::infer::to_str::InferStr;\n-use middle::typeck::infer::unify::Root;\n+use middle::typeck::infer::unify::{Root, UnifyInferCtxtMethods};\n use util::common::{indent, indenter};\n use util::ppaux::ty_to_str;\n "}, {"sha": "eb912aa2dda4b7c06f1e0e4d432d96d0ee7a86cd", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -18,6 +18,7 @@ use middle::typeck::infer::combine::*;\n use middle::typeck::infer::cres;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::InferCtxt;\n+use middle::typeck::infer::lattice::CombineFieldsLatticeMethods;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::to_str::InferStr;\n use util::common::{indent, indenter};"}, {"sha": "a185633a7ac77ea0716ee9fe3cfcf5b194a3eff9", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 68, "deletions": 27, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -40,9 +40,31 @@ pub trait UnifyVid<T> {\n                                       -> &'v mut ValsAndBindings<Self, T>;\n }\n \n-impl InferCtxt {\n-    pub fn get<T:Copy, V:Copy+Eq+Vid+UnifyVid<T>>(&mut self, vid: V)\n-                                                  -> Node<V, T> {\n+pub trait UnifyInferCtxtMethods {\n+    fn get<T:Copy,\n+           V:Copy + Eq + Vid + UnifyVid<T>>(\n+           &mut self,\n+           vid: V)\n+           -> Node<V, T>;\n+    fn set<T:Copy + InferStr,\n+           V:Copy + Vid + ToStr + UnifyVid<T>>(\n+           &mut self,\n+           vid: V,\n+           new_v: VarValue<V, T>);\n+    fn unify<T:Copy + InferStr,\n+             V:Copy + Vid + ToStr + UnifyVid<T>>(\n+             &mut self,\n+             node_a: &Node<V, T>,\n+             node_b: &Node<V, T>)\n+             -> (V, uint);\n+}\n+\n+impl UnifyInferCtxtMethods for InferCtxt {\n+    fn get<T:Copy,\n+           V:Copy + Eq + Vid + UnifyVid<T>>(\n+           &mut self,\n+           vid: V)\n+           -> Node<V, T> {\n         /*!\n          *\n          * Find the root node for `vid`. This uses the standard\n@@ -84,10 +106,11 @@ impl InferCtxt {\n         }\n     }\n \n-    pub fn set<T:Copy + InferStr,\n-               V:Copy + Vid + ToStr + UnifyVid<T>>(&mut self,\n-                                                   vid: V,\n-                                                   new_v: VarValue<V, T>) {\n+    fn set<T:Copy + InferStr,\n+           V:Copy + Vid + ToStr + UnifyVid<T>>(\n+           &mut self,\n+           vid: V,\n+           new_v: VarValue<V, T>) {\n         /*!\n          *\n          * Sets the value for `vid` to `new_v`.  `vid` MUST be a root node!\n@@ -102,11 +125,12 @@ impl InferCtxt {\n         vb.vals.insert(vid.to_uint(), new_v);\n     }\n \n-    pub fn unify<T:Copy + InferStr,\n-                 V:Copy + Vid + ToStr + UnifyVid<T>>(&mut self,\n-                                                     node_a: &Node<V, T>,\n-                                                     node_b: &Node<V, T>)\n-                                                     -> (V, uint) {\n+    fn unify<T:Copy + InferStr,\n+             V:Copy + Vid + ToStr + UnifyVid<T>>(\n+             &mut self,\n+             node_a: &Node<V, T>,\n+             node_b: &Node<V, T>)\n+             -> (V, uint) {\n         // Rank optimization: if you don't know what it is, check\n         // out <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n \n@@ -155,14 +179,31 @@ pub fn mk_err<T:SimplyUnifiable>(a_is_expected: bool,\n     }\n }\n \n-impl InferCtxt {\n-    pub fn simple_vars<T:Copy+Eq+InferStr+SimplyUnifiable,\n-                       V:Copy+Eq+Vid+ToStr+UnifyVid<Option<T>>>(&mut self,\n-                                                                a_is_expected:\n-                                                                bool,\n-                                                                a_id: V,\n-                                                                b_id: V)\n-                                                                -> ures {\n+pub trait InferCtxtMethods {\n+    fn simple_vars<T:Copy + Eq + InferStr + SimplyUnifiable,\n+                   V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+                   &mut self,\n+                   a_is_expected: bool,\n+                   a_id: V,\n+                   b_id: V)\n+                   -> ures;\n+    fn simple_var_t<T:Copy + Eq + InferStr + SimplyUnifiable,\n+                    V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+                    &mut self,\n+                    a_is_expected: bool,\n+                    a_id: V,\n+                    b: T)\n+                    -> ures;\n+}\n+\n+impl InferCtxtMethods for InferCtxt {\n+    fn simple_vars<T:Copy + Eq + InferStr + SimplyUnifiable,\n+                   V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+                   &mut self,\n+                   a_is_expected: bool,\n+                   a_id: V,\n+                   b_id: V)\n+                   -> ures {\n         /*!\n          *\n          * Unifies two simple variables.  Because simple variables do\n@@ -194,13 +235,13 @@ impl InferCtxt {\n         return uok();\n     }\n \n-    pub fn simple_var_t<T:Copy+Eq+InferStr+SimplyUnifiable,\n-                        V:Copy+Eq+Vid+ToStr+UnifyVid<Option<T>>>(&mut self,\n-                                                                 a_is_expected\n-                                                                 : bool,\n-                                                                 a_id: V,\n-                                                                 b: T)\n-                                                                 -> ures {\n+    fn simple_var_t<T:Copy + Eq + InferStr + SimplyUnifiable,\n+                    V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+                    &mut self,\n+                    a_is_expected: bool,\n+                    a_id: V,\n+                    b: T)\n+                    -> ures {\n         /*!\n          *\n          * Sets the value of the variable `a_id` to `b`.  Because"}, {"sha": "957cf02ed77ec436fc3e92b4c1da9aba346600dc", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -80,6 +80,7 @@ pub mod middle {\n     pub mod moves;\n     pub mod entry;\n     pub mod effect;\n+    pub mod reachable;\n }\n \n pub mod front {"}, {"sha": "ca13ba39d59c4b7067d1e720dc8ca36e6e3c230f", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -185,7 +185,20 @@ impl<'self> PkgScript<'self> {\n \n }\n \n-impl Ctx {\n+pub trait CtxMethods {\n+    fn run(&self, cmd: &str, args: ~[~str]);\n+    fn do_cmd(&self, _cmd: &str, _pkgname: &str);\n+    fn build(&self, workspace: &Path, pkgid: &PkgId);\n+    fn clean(&self, workspace: &Path, id: &PkgId);\n+    fn info(&self);\n+    fn install(&self, workspace: &Path, id: &PkgId);\n+    fn prefer(&self, _id: &str, _vers: Option<~str>);\n+    fn test(&self);\n+    fn uninstall(&self, _id: &str, _vers: Option<~str>);\n+    fn unprefer(&self, _id: &str, _vers: Option<~str>);\n+}\n+\n+impl CtxMethods for Ctx {\n \n     fn run(&self, cmd: &str, args: ~[~str]) {\n         match cmd {"}, {"sha": "b3b696a9a603e67c17d563dcdc4f1441463afbc9", "filename": "src/libstd/path.rs", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -335,8 +335,8 @@ mod stat {\n     }\n }\n \n-\n-impl Path {\n+#[cfg(target_os = \"win32\")]\n+impl WindowsPath {\n     pub fn stat(&self) -> Option<libc::stat> {\n         unsafe {\n              do str::as_c_str(self.to_str()) |buf| {\n@@ -349,12 +349,35 @@ impl Path {\n         }\n     }\n \n-    #[cfg(unix)]\n-    pub fn lstat(&self) -> Option<libc::stat> {\n+    pub fn exists(&self) -> bool {\n+        match self.stat() {\n+            None => false,\n+            Some(_) => true,\n+        }\n+    }\n+\n+    pub fn get_size(&self) -> Option<i64> {\n+        match self.stat() {\n+            None => None,\n+            Some(ref st) => Some(st.st_size as i64),\n+        }\n+    }\n+\n+    pub fn get_mode(&self) -> Option<uint> {\n+        match self.stat() {\n+            None => None,\n+            Some(ref st) => Some(st.st_mode as uint),\n+        }\n+    }\n+}\n+\n+#[cfg(not(target_os = \"win32\"))]\n+impl PosixPath {\n+    pub fn stat(&self) -> Option<libc::stat> {\n         unsafe {\n-            do str::as_c_str(self.to_str()) |buf| {\n+             do str::as_c_str(self.to_str()) |buf| {\n                 let mut st = stat::arch::default_stat();\n-                match libc::lstat(buf, &mut st) {\n+                match libc::stat(buf, &mut st) {\n                     0 => Some(st),\n                     _ => None,\n                 }\n@@ -396,7 +419,7 @@ impl Path {\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n-impl Path {\n+impl PosixPath {\n     pub fn get_atime(&self) -> Option<(i64, int)> {\n         match self.stat() {\n             None => None,\n@@ -428,9 +451,24 @@ impl Path {\n     }\n }\n \n+#[cfg(unix)]\n+impl PosixPath {\n+    pub fn lstat(&self) -> Option<libc::stat> {\n+        unsafe {\n+            do str::as_c_str(self.to_str()) |buf| {\n+                let mut st = stat::arch::default_stat();\n+                match libc::lstat(buf, &mut st) {\n+                    0 => Some(st),\n+                    _ => None,\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"macos\")]\n-impl Path {\n+impl PosixPath {\n     pub fn get_birthtime(&self) -> Option<(i64, int)> {\n         match self.stat() {\n             None => None,\n@@ -443,7 +481,7 @@ impl Path {\n }\n \n #[cfg(target_os = \"win32\")]\n-impl Path {\n+impl WindowsPath {\n     pub fn get_atime(&self) -> Option<(i64, int)> {\n         match self.stat() {\n             None => None,"}, {"sha": "9c94f36fba3f9be01f51e22bdf6da0f108611c0f", "filename": "src/libstd/str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -859,7 +859,8 @@ pub mod raw {\n     /// invalidated later.\n     pub unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n         let s = s as *u8;\n-        let mut (curr, len) = (s, 0u);\n+        let mut curr = s;\n+        let mut len = 0u;\n         while *curr != 0u8 {\n             len += 1u;\n             curr = ptr::offset(s, len);"}, {"sha": "8e1c51caf7c1aaeeabd6935b720647a6524fbff9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -205,7 +205,8 @@ pub enum def {\n     def_struct(def_id),\n     def_typaram_binder(node_id), /* struct, impl or trait with ty params */\n     def_region(node_id),\n-    def_label(node_id)\n+    def_label(node_id),\n+    def_method(def_id /* method */, Option<def_id> /* trait */),\n }\n \n \n@@ -1047,7 +1048,7 @@ pub struct trait_ref {\n pub enum visibility { public, private, inherited }\n \n impl visibility {\n-    fn inherit_from(&self, parent_visibility: visibility) -> visibility {\n+    pub fn inherit_from(&self, parent_visibility: visibility) -> visibility {\n         match self {\n             &inherited => parent_visibility,\n             &public | &private => *self"}, {"sha": "6761736d2f374e61026af19e4b7137eb03461fe2", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -59,7 +59,7 @@ pub fn def_id_of_def(d: def) -> def_id {\n       def_fn(id, _) | def_static_method(id, _, _) | def_mod(id) |\n       def_foreign_mod(id) | def_static(id, _) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n-      def_use(id) | def_struct(id) | def_trait(id) => {\n+      def_use(id) | def_struct(id) | def_trait(id) | def_method(id, _) => {\n         id\n       }\n       def_arg(id, _) | def_local(id, _) | def_self(id, _) | def_self_ty(id)"}, {"sha": "04f62f35749034e7a147274ad108a62034de6ac3", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 0, "deletions": 248, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -51,251 +51,3 @@ pub fn token_to_str(token: &token::Token) -> ~str {\n     token::to_str(get_ident_interner(), token)\n }\n \n-impl Parser {\n-    // convert a token to a string using self's reader\n-    pub fn token_to_str(&self, token: &token::Token) -> ~str {\n-        token::to_str(get_ident_interner(), token)\n-    }\n-\n-    // convert the current token to a string using self's reader\n-    pub fn this_token_to_str(&self) -> ~str {\n-        self.token_to_str(self.token)\n-    }\n-\n-    pub fn unexpected_last(&self, t: &token::Token) -> ! {\n-        self.span_fatal(\n-            *self.last_span,\n-            fmt!(\n-                \"unexpected token: `%s`\",\n-                self.token_to_str(t)\n-            )\n-        );\n-    }\n-\n-    pub fn unexpected(&self) -> ! {\n-        self.fatal(\n-            fmt!(\n-                \"unexpected token: `%s`\",\n-                self.this_token_to_str()\n-            )\n-        );\n-    }\n-\n-    // expect and consume the token t. Signal an error if\n-    // the next token is not t.\n-    pub fn expect(&self, t: &token::Token) {\n-        if *self.token == *t {\n-            self.bump();\n-        } else {\n-            self.fatal(\n-                fmt!(\n-                    \"expected `%s` but found `%s`\",\n-                    self.token_to_str(t),\n-                    self.this_token_to_str()\n-                )\n-            )\n-        }\n-    }\n-\n-    pub fn parse_ident(&self) -> ast::ident {\n-        self.check_strict_keywords();\n-        self.check_reserved_keywords();\n-        match *self.token {\n-            token::IDENT(i, _) => {\n-                self.bump();\n-                i\n-            }\n-            token::INTERPOLATED(token::nt_ident(*)) => {\n-                self.bug(\"ident interpolation not converted to real token\");\n-            }\n-            _ => {\n-                self.fatal(\n-                    fmt!(\n-                        \"expected ident, found `%s`\",\n-                        self.this_token_to_str()\n-                    )\n-                );\n-            }\n-        }\n-    }\n-\n-    pub fn parse_path_list_ident(&self) -> ast::path_list_ident {\n-        let lo = self.span.lo;\n-        let ident = self.parse_ident();\n-        let hi = self.last_span.hi;\n-        spanned(lo, hi, ast::path_list_ident_ { name: ident,\n-                                                id: self.get_id() })\n-    }\n-\n-    // consume token 'tok' if it exists. Returns true if the given\n-    // token was present, false otherwise.\n-    pub fn eat(&self, tok: &token::Token) -> bool {\n-        return if *self.token == *tok { self.bump(); true } else { false };\n-    }\n-\n-    pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n-        token::is_keyword(kw, self.token)\n-    }\n-\n-    // if the next token is the given keyword, eat it and return\n-    // true. Otherwise, return false.\n-    pub fn eat_keyword(&self, kw: keywords::Keyword) -> bool {\n-        let is_kw = match *self.token {\n-            token::IDENT(sid, false) => kw.to_ident().name == sid.name,\n-            _ => false\n-        };\n-        if is_kw { self.bump() }\n-        is_kw\n-    }\n-\n-    // if the given word is not a keyword, signal an error.\n-    // if the next token is not the given word, signal an error.\n-    // otherwise, eat it.\n-    pub fn expect_keyword(&self, kw: keywords::Keyword) {\n-        if !self.eat_keyword(kw) {\n-            self.fatal(\n-                fmt!(\n-                    \"expected `%s`, found `%s`\",\n-                    self.id_to_str(kw.to_ident()),\n-                    self.this_token_to_str()\n-                )\n-            );\n-        }\n-    }\n-\n-    // signal an error if the given string is a strict keyword\n-    pub fn check_strict_keywords(&self) {\n-        if token::is_strict_keyword(self.token) {\n-            self.span_err(*self.last_span,\n-                          fmt!(\"found `%s` in ident position\", self.this_token_to_str()));\n-        }\n-    }\n-\n-    // signal an error if the current token is a reserved keyword\n-    pub fn check_reserved_keywords(&self) {\n-        if token::is_reserved_keyword(self.token) {\n-            self.fatal(fmt!(\"`%s` is a reserved keyword\", self.this_token_to_str()));\n-        }\n-    }\n-\n-    // expect and consume a GT. if a >> is seen, replace it\n-    // with a single > and continue. If a GT is not seen,\n-    // signal an error.\n-    pub fn expect_gt(&self) {\n-        if *self.token == token::GT {\n-            self.bump();\n-        } else if *self.token == token::BINOP(token::SHR) {\n-            self.replace_token(\n-                token::GT,\n-                self.span.lo + BytePos(1u),\n-                self.span.hi\n-            );\n-        } else {\n-            let mut s: ~str = ~\"expected `\";\n-            s.push_str(self.token_to_str(&token::GT));\n-            s.push_str(\"`, found `\");\n-            s.push_str(self.this_token_to_str());\n-            s.push_str(\"`\");\n-            self.fatal(s);\n-        }\n-    }\n-\n-    // parse a sequence bracketed by '<' and '>', stopping\n-    // before the '>'.\n-    pub fn parse_seq_to_before_gt<T: Copy>(&self,\n-                                           sep: Option<token::Token>,\n-                                           f: &fn(&Parser) -> T)\n-                                           -> OptVec<T> {\n-        let mut first = true;\n-        let mut v = opt_vec::Empty;\n-        while *self.token != token::GT\n-            && *self.token != token::BINOP(token::SHR) {\n-            match sep {\n-              Some(ref t) => {\n-                if first { first = false; }\n-                else { self.expect(t); }\n-              }\n-              _ => ()\n-            }\n-            v.push(f(self));\n-        }\n-        return v;\n-    }\n-\n-    pub fn parse_seq_to_gt<T: Copy>(&self,\n-                                    sep: Option<token::Token>,\n-                                    f: &fn(&Parser) -> T)\n-                                    -> OptVec<T> {\n-        let v = self.parse_seq_to_before_gt(sep, f);\n-        self.expect_gt();\n-        return v;\n-    }\n-\n-    // parse a sequence, including the closing delimiter. The function\n-    // f must consume tokens until reaching the next separator or\n-    // closing bracket.\n-    pub fn parse_seq_to_end<T: Copy>(&self,\n-                                     ket: &token::Token,\n-                                     sep: SeqSep,\n-                                     f: &fn(&Parser) -> T)\n-                                     -> ~[T] {\n-        let val = self.parse_seq_to_before_end(ket, sep, f);\n-        self.bump();\n-        val\n-    }\n-\n-    // parse a sequence, not including the closing delimiter. The function\n-    // f must consume tokens until reaching the next separator or\n-    // closing bracket.\n-    pub fn parse_seq_to_before_end<T: Copy>(&self,\n-                                            ket: &token::Token,\n-                                            sep: SeqSep,\n-                                            f: &fn(&Parser) -> T)\n-                                            -> ~[T] {\n-        let mut first: bool = true;\n-        let mut v: ~[T] = ~[];\n-        while *self.token != *ket {\n-            match sep.sep {\n-              Some(ref t) => {\n-                if first { first = false; }\n-                else { self.expect(t); }\n-              }\n-              _ => ()\n-            }\n-            if sep.trailing_sep_allowed && *self.token == *ket { break; }\n-            v.push(f(self));\n-        }\n-        return v;\n-    }\n-\n-    // parse a sequence, including the closing delimiter. The function\n-    // f must consume tokens until reaching the next separator or\n-    // closing bracket.\n-    pub fn parse_unspanned_seq<T: Copy>(&self,\n-                                        bra: &token::Token,\n-                                        ket: &token::Token,\n-                                        sep: SeqSep,\n-                                        f: &fn(&Parser) -> T)\n-                                        -> ~[T] {\n-        self.expect(bra);\n-        let result = self.parse_seq_to_before_end(ket, sep, f);\n-        self.bump();\n-        result\n-    }\n-\n-    // NB: Do not use this function unless you actually plan to place the\n-    // spanned list in the AST.\n-    pub fn parse_seq<T: Copy>(&self,\n-                              bra: &token::Token,\n-                              ket: &token::Token,\n-                              sep: SeqSep,\n-                              f: &fn(&Parser) -> T)\n-                              -> spanned<~[T]> {\n-        let lo = self.span.lo;\n-        self.expect(bra);\n-        let result = self.parse_seq_to_before_end(ket, sep, f);\n-        let hi = self.span.hi;\n-        self.bump();\n-        spanned(lo, hi, result)\n-    }\n-}"}, {"sha": "fff4c125af620a8a0faac5ed8e9b6aa252e25f88", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -73,7 +73,26 @@ impl to_bytes::IterBytes for ObsoleteSyntax {\n     }\n }\n \n-impl Parser {\n+pub trait ParserObsoleteMethods {\n+    /// Reports an obsolete syntax non-fatal error.\n+    fn obsolete(&self, sp: span, kind: ObsoleteSyntax);\n+    // Reports an obsolete syntax non-fatal error, and returns\n+    // a placeholder expression\n+    fn obsolete_expr(&self, sp: span, kind: ObsoleteSyntax) -> @expr;\n+    fn report(&self,\n+              sp: span,\n+              kind: ObsoleteSyntax,\n+              kind_str: &str,\n+              desc: &str);\n+    fn token_is_obsolete_ident(&self, ident: &str, token: &Token) -> bool;\n+    fn is_obsolete_ident(&self, ident: &str) -> bool;\n+    fn eat_obsolete_ident(&self, ident: &str) -> bool;\n+    fn try_parse_obsolete_struct_ctor(&self) -> bool;\n+    fn try_parse_obsolete_with(&self) -> bool;\n+    fn try_parse_obsolete_priv_section(&self, attrs: &[attribute]) -> bool;\n+}\n+\n+impl ParserObsoleteMethods for Parser {\n     /// Reports an obsolete syntax non-fatal error.\n     pub fn obsolete(&self, sp: span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {"}, {"sha": "64bdfd4a4d3327e437dffbb4dcb32bb4942ed527", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 249, "deletions": 2, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=03ab6351ccc7b0e2b6102f88eddc0bbe84f2abc0", "patch": "@@ -64,7 +64,7 @@ use codemap::{span, BytePos, spanned, mk_sp};\n use codemap;\n use parse::attr::parser_attr;\n use parse::classify;\n-use parse::common::{seq_sep_none};\n+use parse::common::{SeqSep, seq_sep_none};\n use parse::common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed};\n use parse::lexer::reader;\n use parse::lexer::TokenAndSpan;\n@@ -84,7 +84,7 @@ use parse::obsolete::{ObsoletePurity, ObsoleteStaticMethod};\n use parse::obsolete::{ObsoleteConstItem, ObsoleteFixedLengthVectorType};\n use parse::obsolete::{ObsoleteNamedExternModule, ObsoleteMultipleLocalDecl};\n use parse::obsolete::{ObsoleteMutWithMultipleBindings};\n-use parse::obsolete::{ObsoletePatternCopyKeyword};\n+use parse::obsolete::{ObsoletePatternCopyKeyword, ParserObsoleteMethods};\n use parse::token::{can_begin_expr, get_ident_interner, ident_to_str, is_ident};\n use parse::token::{is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, keywords, special_idents};\n@@ -274,6 +274,253 @@ impl Drop for Parser {\n }\n \n impl Parser {\n+    // convert a token to a string using self's reader\n+    pub fn token_to_str(&self, token: &token::Token) -> ~str {\n+        token::to_str(get_ident_interner(), token)\n+    }\n+\n+    // convert the current token to a string using self's reader\n+    pub fn this_token_to_str(&self) -> ~str {\n+        self.token_to_str(self.token)\n+    }\n+\n+    pub fn unexpected_last(&self, t: &token::Token) -> ! {\n+        self.span_fatal(\n+            *self.last_span,\n+            fmt!(\n+                \"unexpected token: `%s`\",\n+                self.token_to_str(t)\n+            )\n+        );\n+    }\n+\n+    pub fn unexpected(&self) -> ! {\n+        self.fatal(\n+            fmt!(\n+                \"unexpected token: `%s`\",\n+                self.this_token_to_str()\n+            )\n+        );\n+    }\n+\n+    // expect and consume the token t. Signal an error if\n+    // the next token is not t.\n+    pub fn expect(&self, t: &token::Token) {\n+        if *self.token == *t {\n+            self.bump();\n+        } else {\n+            self.fatal(\n+                fmt!(\n+                    \"expected `%s` but found `%s`\",\n+                    self.token_to_str(t),\n+                    self.this_token_to_str()\n+                )\n+            )\n+        }\n+    }\n+\n+    pub fn parse_ident(&self) -> ast::ident {\n+        self.check_strict_keywords();\n+        self.check_reserved_keywords();\n+        match *self.token {\n+            token::IDENT(i, _) => {\n+                self.bump();\n+                i\n+            }\n+            token::INTERPOLATED(token::nt_ident(*)) => {\n+                self.bug(\"ident interpolation not converted to real token\");\n+            }\n+            _ => {\n+                self.fatal(\n+                    fmt!(\n+                        \"expected ident, found `%s`\",\n+                        self.this_token_to_str()\n+                    )\n+                );\n+            }\n+        }\n+    }\n+\n+    pub fn parse_path_list_ident(&self) -> ast::path_list_ident {\n+        let lo = self.span.lo;\n+        let ident = self.parse_ident();\n+        let hi = self.last_span.hi;\n+        spanned(lo, hi, ast::path_list_ident_ { name: ident,\n+                                                id: self.get_id() })\n+    }\n+\n+    // consume token 'tok' if it exists. Returns true if the given\n+    // token was present, false otherwise.\n+    pub fn eat(&self, tok: &token::Token) -> bool {\n+        return if *self.token == *tok { self.bump(); true } else { false };\n+    }\n+\n+    pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n+        token::is_keyword(kw, self.token)\n+    }\n+\n+    // if the next token is the given keyword, eat it and return\n+    // true. Otherwise, return false.\n+    pub fn eat_keyword(&self, kw: keywords::Keyword) -> bool {\n+        let is_kw = match *self.token {\n+            token::IDENT(sid, false) => kw.to_ident().name == sid.name,\n+            _ => false\n+        };\n+        if is_kw { self.bump() }\n+        is_kw\n+    }\n+\n+    // if the given word is not a keyword, signal an error.\n+    // if the next token is not the given word, signal an error.\n+    // otherwise, eat it.\n+    pub fn expect_keyword(&self, kw: keywords::Keyword) {\n+        if !self.eat_keyword(kw) {\n+            self.fatal(\n+                fmt!(\n+                    \"expected `%s`, found `%s`\",\n+                    *self.id_to_str(kw.to_ident()),\n+                    self.this_token_to_str()\n+                )\n+            );\n+        }\n+    }\n+\n+    // signal an error if the given string is a strict keyword\n+    pub fn check_strict_keywords(&self) {\n+        if token::is_strict_keyword(self.token) {\n+            self.span_err(*self.last_span,\n+                          fmt!(\"found `%s` in ident position\", self.this_token_to_str()));\n+        }\n+    }\n+\n+    // signal an error if the current token is a reserved keyword\n+    pub fn check_reserved_keywords(&self) {\n+        if token::is_reserved_keyword(self.token) {\n+            self.fatal(fmt!(\"`%s` is a reserved keyword\", self.this_token_to_str()));\n+        }\n+    }\n+\n+    // expect and consume a GT. if a >> is seen, replace it\n+    // with a single > and continue. If a GT is not seen,\n+    // signal an error.\n+    pub fn expect_gt(&self) {\n+        if *self.token == token::GT {\n+            self.bump();\n+        } else if *self.token == token::BINOP(token::SHR) {\n+            self.replace_token(\n+                token::GT,\n+                self.span.lo + BytePos(1u),\n+                self.span.hi\n+            );\n+        } else {\n+            let mut s: ~str = ~\"expected `\";\n+            s.push_str(self.token_to_str(&token::GT));\n+            s.push_str(\"`, found `\");\n+            s.push_str(self.this_token_to_str());\n+            s.push_str(\"`\");\n+            self.fatal(s);\n+        }\n+    }\n+\n+    // parse a sequence bracketed by '<' and '>', stopping\n+    // before the '>'.\n+    pub fn parse_seq_to_before_gt<T: Copy>(&self,\n+                                           sep: Option<token::Token>,\n+                                           f: &fn(&Parser) -> T)\n+                                           -> OptVec<T> {\n+        let mut first = true;\n+        let mut v = opt_vec::Empty;\n+        while *self.token != token::GT\n+            && *self.token != token::BINOP(token::SHR) {\n+            match sep {\n+              Some(ref t) => {\n+                if first { first = false; }\n+                else { self.expect(t); }\n+              }\n+              _ => ()\n+            }\n+            v.push(f(self));\n+        }\n+        return v;\n+    }\n+\n+    pub fn parse_seq_to_gt<T: Copy>(&self,\n+                                    sep: Option<token::Token>,\n+                                    f: &fn(&Parser) -> T)\n+                                    -> OptVec<T> {\n+        let v = self.parse_seq_to_before_gt(sep, f);\n+        self.expect_gt();\n+        return v;\n+    }\n+\n+    // parse a sequence, including the closing delimiter. The function\n+    // f must consume tokens until reaching the next separator or\n+    // closing bracket.\n+    pub fn parse_seq_to_end<T: Copy>(&self,\n+                                     ket: &token::Token,\n+                                     sep: SeqSep,\n+                                     f: &fn(&Parser) -> T)\n+                                     -> ~[T] {\n+        let val = self.parse_seq_to_before_end(ket, sep, f);\n+        self.bump();\n+        val\n+    }\n+\n+    // parse a sequence, not including the closing delimiter. The function\n+    // f must consume tokens until reaching the next separator or\n+    // closing bracket.\n+    pub fn parse_seq_to_before_end<T: Copy>(&self,\n+                                            ket: &token::Token,\n+                                            sep: SeqSep,\n+                                            f: &fn(&Parser) -> T)\n+                                            -> ~[T] {\n+        let mut first: bool = true;\n+        let mut v: ~[T] = ~[];\n+        while *self.token != *ket {\n+            match sep.sep {\n+              Some(ref t) => {\n+                if first { first = false; }\n+                else { self.expect(t); }\n+              }\n+              _ => ()\n+            }\n+            if sep.trailing_sep_allowed && *self.token == *ket { break; }\n+            v.push(f(self));\n+        }\n+        return v;\n+    }\n+\n+    // parse a sequence, including the closing delimiter. The function\n+    // f must consume tokens until reaching the next separator or\n+    // closing bracket.\n+    pub fn parse_unspanned_seq<T: Copy>(&self,\n+                                        bra: &token::Token,\n+                                        ket: &token::Token,\n+                                        sep: SeqSep,\n+                                        f: &fn(&Parser) -> T)\n+                                        -> ~[T] {\n+        self.expect(bra);\n+        let result = self.parse_seq_to_before_end(ket, sep, f);\n+        self.bump();\n+        result\n+    }\n+\n+    // NB: Do not use this function unless you actually plan to place the\n+    // spanned list in the AST.\n+    pub fn parse_seq<T: Copy>(&self,\n+                              bra: &token::Token,\n+                              ket: &token::Token,\n+                              sep: SeqSep,\n+                              f: &fn(&Parser) -> T)\n+                              -> spanned<~[T]> {\n+        let lo = self.span.lo;\n+        self.expect(bra);\n+        let result = self.parse_seq_to_before_end(ket, sep, f);\n+        let hi = self.span.hi;\n+        self.bump();\n+        spanned(lo, hi, result)\n+    }\n+\n     // advance the parser by one token\n     pub fn bump(&self) {\n         *self.last_span = copy *self.span;"}]}