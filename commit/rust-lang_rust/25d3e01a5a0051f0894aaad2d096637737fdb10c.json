{"sha": "25d3e01a5a0051f0894aaad2d096637737fdb10c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZDNlMDFhNWEwMDUxZjA4OTRhYWFkMmQwOTY2Mzc3MzdmZGIxMGM=", "commit": {"author": {"name": "Markus Siemens", "email": "siemens1993@gmail.com", "date": "2015-02-18T18:08:30Z"}, "committer": {"name": "Markus Siemens", "email": "siemens1993@gmail.com", "date": "2015-02-22T12:41:53Z"}, "message": "Implement append and split_off for VecMap (RFC 509)\n\nImplements `append()` and `split_off()` for `VecMap`. It's worth noting\nthat `append()` will overwrite existing keys (the RFC doesn't specify how\n`append()` should handle duplicate keys).\n\ncc #19986", "tree": {"sha": "dcd6ce1a2c7e0a1c7e9bc2a0e3115f03b8f1fdc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcd6ce1a2c7e0a1c7e9bc2a0e3115f03b8f1fdc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25d3e01a5a0051f0894aaad2d096637737fdb10c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25d3e01a5a0051f0894aaad2d096637737fdb10c", "html_url": "https://github.com/rust-lang/rust/commit/25d3e01a5a0051f0894aaad2d096637737fdb10c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25d3e01a5a0051f0894aaad2d096637737fdb10c/comments", "author": {"login": "msiemens", "id": 1873922, "node_id": "MDQ6VXNlcjE4NzM5MjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1873922?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msiemens", "html_url": "https://github.com/msiemens", "followers_url": "https://api.github.com/users/msiemens/followers", "following_url": "https://api.github.com/users/msiemens/following{/other_user}", "gists_url": "https://api.github.com/users/msiemens/gists{/gist_id}", "starred_url": "https://api.github.com/users/msiemens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msiemens/subscriptions", "organizations_url": "https://api.github.com/users/msiemens/orgs", "repos_url": "https://api.github.com/users/msiemens/repos", "events_url": "https://api.github.com/users/msiemens/events{/privacy}", "received_events_url": "https://api.github.com/users/msiemens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msiemens", "id": 1873922, "node_id": "MDQ6VXNlcjE4NzM5MjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1873922?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msiemens", "html_url": "https://github.com/msiemens", "followers_url": "https://api.github.com/users/msiemens/followers", "following_url": "https://api.github.com/users/msiemens/following{/other_user}", "gists_url": "https://api.github.com/users/msiemens/gists{/gist_id}", "starred_url": "https://api.github.com/users/msiemens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msiemens/subscriptions", "organizations_url": "https://api.github.com/users/msiemens/orgs", "repos_url": "https://api.github.com/users/msiemens/repos", "events_url": "https://api.github.com/users/msiemens/events{/privacy}", "received_events_url": "https://api.github.com/users/msiemens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "html_url": "https://github.com/rust-lang/rust/commit/522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}], "stats": {"total": 172, "additions": 170, "deletions": 2}, "files": [{"sha": "86388dcc4c2bd8758d28bb9b1ebd2a868a8d3bdc", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 170, "deletions": 2, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/25d3e01a5a0051f0894aaad2d096637737fdb10c/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d3e01a5a0051f0894aaad2d096637737fdb10c/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=25d3e01a5a0051f0894aaad2d096637737fdb10c", "patch": "@@ -17,14 +17,14 @@ use self::Entry::*;\n \n use core::prelude::*;\n \n-use core::cmp::Ordering;\n+use core::cmp::{max, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n #[cfg(stage0)] use core::hash::Writer;\n use core::iter::{Enumerate, FilterMap, Map, FromIterator, IntoIterator};\n use core::iter;\n-use core::mem::replace;\n+use core::mem::{replace, swap};\n use core::ops::{Index, IndexMut};\n \n use {vec, slice};\n@@ -335,6 +335,95 @@ impl<V> VecMap<V> {\n         IntoIter { iter: self.v.into_iter().enumerate().filter_map(filter) }\n     }\n \n+    /// Moves all elements from `other` into the map while overwriting existing keys.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecMap;\n+    ///\n+    /// let mut a = VecMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    ///\n+    /// let mut b = VecMap::new();\n+    /// b.insert(3, \"c\");\n+    /// b.insert(4, \"d\");\n+    ///\n+    /// a.append(&mut b);\n+    ///\n+    /// assert_eq!(a.len(), 4);\n+    /// assert_eq!(b.len(), 0);\n+    /// assert_eq!(a[1], \"a\");\n+    /// assert_eq!(a[2], \"b\");\n+    /// assert_eq!(a[3], \"c\");\n+    /// assert_eq!(a[4], \"d\");\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"recently added as part of collections reform 2\")]\n+    pub fn append(&mut self, other: &mut Self) {\n+        self.extend(other.drain());\n+    }\n+\n+    /// Splits the collection into two at the given key.\n+    ///\n+    /// Returns a newly allocated `Self`. `self` contains elements `[0, at)`,\n+    /// and the returned `Self` contains elements `[at, max_key)`.\n+    ///\n+    /// Note that the capacity of `self` does not change.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecMap;\n+    ///\n+    /// let mut a = VecMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"d\");\n+    ///\n+    /// let b = a.split_off(3);\n+    ///\n+    /// assert_eq!(a[1], \"a\");\n+    /// assert_eq!(a[2], \"b\");\n+    ///\n+    /// assert_eq!(b[3], \"c\");\n+    /// assert_eq!(b[4], \"d\");\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"recently added as part of collections reform 2\")]\n+    pub fn split_off(&mut self, at: usize) -> Self {\n+        let mut other = VecMap::new();\n+\n+        if at == 0 {\n+            // Move all elements to other\n+            swap(self, &mut other);\n+            return other\n+        } else if at > self.v.len() {\n+            // No elements to copy\n+            return other;\n+        }\n+\n+        // Look up the index of the first non-None item\n+        let first_index = self.v.iter().position(|el| el.is_some());\n+        let start_index = match first_index {\n+            Some(index) => max(at, index),\n+            None => {\n+                // self has no elements\n+                return other;\n+            }\n+        };\n+\n+        // Fill the new VecMap with `None`s until `start_index`\n+        other.v.extend((0..start_index).map(|_| None));\n+\n+        // Move elements beginning with `start_index` from `self` into `other`\n+        other.v.extend(self.v[start_index..].iter_mut().map(|el| el.take()));\n+\n+        other\n+    }\n+\n     /// Returns an iterator visiting all key-value pairs in ascending order of\n     /// the keys, emptying (but not consuming) the original `VecMap`.\n     /// The iterator's element type is `(usize, &'r V)`. Keeps the allocated memory for reuse.\n@@ -1156,6 +1245,85 @@ mod test_map {\n         assert_eq!(map.len(), 0);\n     }\n \n+    #[test]\n+    fn test_append() {\n+        let mut a = VecMap::new();\n+        a.insert(1, \"a\");\n+        a.insert(2, \"b\");\n+        a.insert(3, \"c\");\n+\n+        let mut b = VecMap::new();\n+        b.insert(3, \"d\");  // Overwrite element from a\n+        b.insert(4, \"e\");\n+        b.insert(5, \"f\");\n+\n+        a.append(&mut b);\n+\n+        assert_eq!(a.len(), 5);\n+        assert_eq!(b.len(), 0);\n+        // Capacity shouldn't change for possible reuse\n+        assert!(b.capacity() >= 4);\n+\n+        assert_eq!(a[1], \"a\");\n+        assert_eq!(a[2], \"b\");\n+        assert_eq!(a[3], \"d\");\n+        assert_eq!(a[4], \"e\");\n+        assert_eq!(a[5], \"f\");\n+    }\n+\n+    #[test]\n+    fn test_split_off() {\n+        // Split within the key range\n+        let mut a = VecMap::new();\n+        a.insert(1, \"a\");\n+        a.insert(2, \"b\");\n+        a.insert(3, \"c\");\n+        a.insert(4, \"d\");\n+\n+        let b = a.split_off(3);\n+\n+        assert_eq!(a.len(), 2);\n+        assert_eq!(b.len(), 2);\n+\n+        assert_eq!(a[1], \"a\");\n+        assert_eq!(a[2], \"b\");\n+\n+        assert_eq!(b[3], \"c\");\n+        assert_eq!(b[4], \"d\");\n+\n+        // Split at 0\n+        a.clear();\n+        a.insert(1, \"a\");\n+        a.insert(2, \"b\");\n+        a.insert(3, \"c\");\n+        a.insert(4, \"d\");\n+\n+        let b = a.split_off(0);\n+\n+        assert_eq!(a.len(), 0);\n+        assert_eq!(b.len(), 4);\n+        assert_eq!(b[1], \"a\");\n+        assert_eq!(b[2], \"b\");\n+        assert_eq!(b[3], \"c\");\n+        assert_eq!(b[4], \"d\");\n+\n+        // Split behind max_key\n+        a.clear();\n+        a.insert(1, \"a\");\n+        a.insert(2, \"b\");\n+        a.insert(3, \"c\");\n+        a.insert(4, \"d\");\n+\n+        let b = a.split_off(5);\n+\n+        assert_eq!(a.len(), 4);\n+        assert_eq!(b.len(), 0);\n+        assert_eq!(a[1], \"a\");\n+        assert_eq!(a[2], \"b\");\n+        assert_eq!(a[3], \"c\");\n+        assert_eq!(a[4], \"d\");\n+    }\n+\n     #[test]\n     fn test_show() {\n         let mut map = VecMap::new();"}]}