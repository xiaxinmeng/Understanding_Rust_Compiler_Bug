{"sha": "7bc94cc3c2ccef8b4d393910bb978a6487db1202", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYzk0Y2MzYzJjY2VmOGI0ZDM5MzkxMGJiOTc4YTY0ODdkYjEyMDI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-09-26T16:51:36Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-09-26T17:21:48Z"}, "message": "Rename `Item.node` to `Item.kind`", "tree": {"sha": "1c7a5175d795992497651e7dfa3e3a0f76f5815a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c7a5175d795992497651e7dfa3e3a0f76f5815a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bc94cc3c2ccef8b4d393910bb978a6487db1202", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bc94cc3c2ccef8b4d393910bb978a6487db1202", "html_url": "https://github.com/rust-lang/rust/commit/7bc94cc3c2ccef8b4d393910bb978a6487db1202", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bc94cc3c2ccef8b4d393910bb978a6487db1202/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21bf983acbb5d7ac8fb9462cbf2cc4c280abd857", "url": "https://api.github.com/repos/rust-lang/rust/commits/21bf983acbb5d7ac8fb9462cbf2cc4c280abd857", "html_url": "https://github.com/rust-lang/rust/commit/21bf983acbb5d7ac8fb9462cbf2cc4c280abd857"}], "stats": {"total": 557, "additions": 279, "deletions": 278}, "files": [{"sha": "c946118b1ea195ebb827067cc1bbd41d0aac2a46", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -65,7 +65,7 @@ impl Display for Target {\n \n impl Target {\n     pub(crate) fn from_item(item: &hir::Item) -> Target {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::ExternCrate(..) => Target::ExternCrate,\n             hir::ItemKind::Use(..) => Target::Use,\n             hir::ItemKind::Static(..) => Target::Static,\n@@ -333,7 +333,7 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n }\n \n fn is_c_like_enum(item: &hir::Item) -> bool {\n-    if let hir::ItemKind::Enum(ref def, _) = item.node {\n+    if let hir::ItemKind::Enum(ref def, _) = item.kind {\n         for variant in &def.variants {\n             match variant.data {\n                 hir::VariantData::Unit(..) => { /* continue */ }"}, {"sha": "3f6c7f22f16bee880a10920c906e710953bccfdf", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -465,7 +465,7 @@ pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param) {\n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.ident);\n-    match item.node {\n+    match item.kind {\n         ItemKind::ExternCrate(orig_name) => {\n             visitor.visit_id(item.hir_id);\n             if let Some(orig_name) = orig_name {"}, {"sha": "d0a9d967a649d7037091f84bce2d0ccd9982cf3a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -437,7 +437,7 @@ impl<'a> LoweringContext<'a> {\n             fn visit_item(&mut self, item: &'tcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n \n-                match item.node {\n+                match item.kind {\n                     ItemKind::Struct(_, ref generics)\n                     | ItemKind::Union(_, ref generics)\n                     | ItemKind::Enum(_, ref generics)\n@@ -1445,7 +1445,7 @@ impl<'a> LoweringContext<'a> {\n             hir_id: opaque_ty_id,\n             ident: Ident::invalid(),\n             attrs: Default::default(),\n-            node: opaque_ty_item_kind,\n+            kind: opaque_ty_item_kind,\n             vis: respan(span.shrink_to_lo(), hir::VisibilityKind::Inherited),\n             span: opaque_ty_span,\n         };"}, {"sha": "ab477d6e1c19449b66bdf7e6e0c50cd4072b5e40", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -73,7 +73,7 @@ impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n         if let Some(hir_id) = item_hir_id {\n             self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n                 let this = &mut ItemLowerer { lctx: this };\n-                if let ItemKind::Impl(.., ref opt_trait_ref, _, _) = item.node {\n+                if let ItemKind::Impl(.., ref opt_trait_ref, _, _) = item.kind {\n                     this.with_trait_impl_ref(opt_trait_ref, |this| {\n                         visit::walk_item(this, item)\n                     });\n@@ -119,7 +119,7 @@ impl LoweringContext<'_> {\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n \n-        let parent_generics = match self.items.get(&parent_hir_id).unwrap().node {\n+        let parent_generics = match self.items.get(&parent_hir_id).unwrap().kind {\n             hir::ItemKind::Impl(_, _, _, ref generics, ..)\n             | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n                 &generics.params[..]\n@@ -168,7 +168,7 @@ impl LoweringContext<'_> {\n     }\n \n     pub(super) fn lower_item_id(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n-        let node_ids = match i.node {\n+        let node_ids = match i.kind {\n             ItemKind::Use(ref use_tree) => {\n                 let mut vec = smallvec![i.id];\n                 self.lower_item_id_use_tree(use_tree, i.id, &mut vec);\n@@ -235,7 +235,7 @@ impl LoweringContext<'_> {\n         }\n         let attrs = attrs.into();\n \n-        if let ItemKind::MacroDef(ref def) = i.node {\n+        if let ItemKind::MacroDef(ref def) = i.kind {\n             if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n                 let body = self.lower_token_stream(def.stream());\n                 let hir_id = self.lower_node_id(i.id);\n@@ -254,13 +254,13 @@ impl LoweringContext<'_> {\n             return None;\n         }\n \n-        let node = self.lower_item_kind(i.id, &mut ident, &attrs, &mut vis, &i.node);\n+        let kind = self.lower_item_kind(i.id, &mut ident, &attrs, &mut vis, &i.kind);\n \n         Some(hir::Item {\n             hir_id: self.lower_node_id(i.id),\n             ident,\n             attrs,\n-            node,\n+            kind,\n             vis,\n             span: i.span,\n         })\n@@ -542,24 +542,23 @@ impl LoweringContext<'_> {\n                         let res = this.lower_res(res);\n                         let path =\n                             this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n-                        let item = hir::ItemKind::Use(P(path), hir::UseKind::Single);\n+                        let kind = hir::ItemKind::Use(P(path), hir::UseKind::Single);\n                         let vis = this.rebuild_vis(&vis);\n \n                         this.insert_item(\n                             hir::Item {\n                                 hir_id: new_id,\n                                 ident,\n                                 attrs: attrs.into_iter().cloned().collect(),\n-                                node: item,\n+                                kind,\n                                 vis,\n                                 span,\n                             },\n                         );\n                     });\n                 }\n \n-                let path =\n-                    P(self.lower_path_extra(ret_res, &path, ParamMode::Explicit, None));\n+                let path = P(self.lower_path_extra(ret_res, &path, ParamMode::Explicit, None));\n                 hir::ItemKind::Use(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n@@ -623,7 +622,7 @@ impl LoweringContext<'_> {\n                         let mut vis = this.rebuild_vis(&vis);\n                         let mut ident = *ident;\n \n-                        let item = this.lower_use_tree(use_tree,\n+                        let kind = this.lower_use_tree(use_tree,\n                                                        &prefix,\n                                                        id,\n                                                        &mut vis,\n@@ -635,7 +634,7 @@ impl LoweringContext<'_> {\n                                 hir_id: new_hir_id,\n                                 ident,\n                                 attrs: attrs.into_iter().cloned().collect(),\n-                                node: item,\n+                                kind,\n                                 vis,\n                                 span: use_tree.span,\n                             },"}, {"sha": "f670d5abe85e4b59f05fd53c9d8bd22df403d395", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -37,7 +37,10 @@ trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n \n impl MaybeFnLike for ast::Item {\n     fn is_fn_like(&self) -> bool {\n-        match self.node { ast::ItemKind::Fn(..) => true, _ => false, }\n+        match self.kind {\n+            ast::ItemKind::Fn(..) => true,\n+            _ => false,\n+        }\n     }\n }\n \n@@ -215,7 +218,7 @@ impl<'a> FnLikeNode<'a> {\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n         match self.node {\n-            map::Node::Item(i) => match i.node {\n+            map::Node::Item(i) => match i.kind {\n                 ast::ItemKind::Fn(ref decl, header, ref generics, block) =>\n                     item_fn(ItemFnParts {\n                         id: i.hir_id,"}, {"sha": "c69d682b6f796462633036a553566daa87e20ab7", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -378,7 +378,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n             this.insert(i.span, i.hir_id, Node::Item(i));\n             this.with_parent(i.hir_id, |this| {\n-                if let ItemKind::Struct(ref struct_def, _) = i.node {\n+                if let ItemKind::Struct(ref struct_def, _) = i.kind {\n                     // If this is a tuple or unit-like struct, register the constructor.\n                     if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                         this.insert(i.span, ctor_hir_id, Node::Ctor(struct_def));"}, {"sha": "4235da76f538bcc365abca0a25c30092150feb9f", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -101,7 +101,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n         // Pick the def data. This need not be unique, but the more\n         // information we encapsulate into, the better\n-        let def_data = match i.node {\n+        let def_data = match i.kind {\n             ItemKind::Impl(..) => DefPathData::Impl,\n             ItemKind::Mod(..) if i.ident.name == kw::Invalid => {\n                 return visit::walk_item(self, i);\n@@ -138,7 +138,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         let def = self.create_def(i.id, def_data, i.span);\n \n         self.with_parent(def, |this| {\n-            match i.node {\n+            match i.kind {\n                 ItemKind::Struct(ref struct_def, _) | ItemKind::Union(ref struct_def, _) => {\n                     // If this is a unit or tuple-like struct, register the constructor.\n                     if let Some(ctor_hir_id) = struct_def.ctor_id() {"}, {"sha": "c13bb3cb1f2dd12eed2ec668dbfc941699956366", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -50,7 +50,7 @@ impl<'hir> Entry<'hir> {\n     fn fn_decl(&self) -> Option<&'hir FnDecl> {\n         match self.node {\n             Node::Item(ref item) => {\n-                match item.node {\n+                match item.kind {\n                     ItemKind::Fn(ref fn_decl, _, _, _) => Some(fn_decl),\n                     _ => None,\n                 }\n@@ -84,7 +84,7 @@ impl<'hir> Entry<'hir> {\n     fn associated_body(self) -> Option<BodyId> {\n         match self.node {\n             Node::Item(item) => {\n-                match item.node {\n+                match item.kind {\n                     ItemKind::Const(_, body) |\n                     ItemKind::Static(.., body) |\n                     ItemKind::Fn(_, _, _, body) => Some(body),\n@@ -293,7 +293,7 @@ impl<'hir> Map<'hir> {\n \n         Some(match node {\n             Node::Item(item) => {\n-                match item.node {\n+                match item.kind {\n                     ItemKind::Static(..) => DefKind::Static,\n                     ItemKind::Const(..) => DefKind::Const,\n                     ItemKind::Fn(..) => DefKind::Fn,\n@@ -453,19 +453,19 @@ impl<'hir> Map<'hir> {\n \n     pub fn body_owner_kind(&self, id: HirId) -> BodyOwnerKind {\n         match self.get(id) {\n-            Node::Item(&Item { node: ItemKind::Const(..), .. }) |\n+            Node::Item(&Item { kind: ItemKind::Const(..), .. }) |\n             Node::TraitItem(&TraitItem { kind: TraitItemKind::Const(..), .. }) |\n             Node::ImplItem(&ImplItem { kind: ImplItemKind::Const(..), .. }) |\n             Node::AnonConst(_) => {\n                 BodyOwnerKind::Const\n             }\n             Node::Ctor(..) |\n-            Node::Item(&Item { node: ItemKind::Fn(..), .. }) |\n+            Node::Item(&Item { kind: ItemKind::Fn(..), .. }) |\n             Node::TraitItem(&TraitItem { kind: TraitItemKind::Method(..), .. }) |\n             Node::ImplItem(&ImplItem { kind: ImplItemKind::Method(..), .. }) => {\n                 BodyOwnerKind::Fn\n             }\n-            Node::Item(&Item { node: ItemKind::Static(_, m, _), .. }) => {\n+            Node::Item(&Item { kind: ItemKind::Static(_, m, _), .. }) => {\n                 BodyOwnerKind::Static(m)\n             }\n             Node::Expr(&Expr { kind: ExprKind::Closure(..), .. }) => {\n@@ -477,17 +477,17 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_owner(&self, id: HirId) -> HirId {\n         match self.get(id) {\n-            Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n-            Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => id,\n+            Node::Item(&Item { kind: ItemKind::Trait(..), .. }) |\n+            Node::Item(&Item { kind: ItemKind::TraitAlias(..), .. }) => id,\n             Node::GenericParam(_) => self.get_parent_node(id),\n             _ => bug!(\"ty_param_owner: {} not a type parameter\", self.node_to_string(id))\n         }\n     }\n \n     pub fn ty_param_name(&self, id: HirId) -> Name {\n         match self.get(id) {\n-            Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n-            Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => kw::SelfUpper,\n+            Node::Item(&Item { kind: ItemKind::Trait(..), .. }) |\n+            Node::Item(&Item { kind: ItemKind::TraitAlias(..), .. }) => kw::SelfUpper,\n             Node::GenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }\n@@ -517,7 +517,7 @@ impl<'hir> Map<'hir> {\n         match self.find_entry(hir_id).unwrap().node {\n             Node::Item(&Item {\n                 span,\n-                node: ItemKind::Mod(ref m),\n+                kind: ItemKind::Mod(ref m),\n                 ..\n             }) => (m, span, hir_id),\n             Node::Crate => (&self.forest.krate.module, self.forest.krate.span, hir_id),\n@@ -568,7 +568,7 @@ impl<'hir> Map<'hir> {\n                 Node::ImplItem(ref impl_item) => Some(&impl_item.generics),\n                 Node::TraitItem(ref trait_item) => Some(&trait_item.generics),\n                 Node::Item(ref item) => {\n-                    match item.node {\n+                    match item.kind {\n                         ItemKind::Fn(_, _, ref generics, _) |\n                         ItemKind::TyAlias(_, ref generics) |\n                         ItemKind::Enum(_, ref generics) |\n@@ -649,7 +649,7 @@ impl<'hir> Map<'hir> {\n         let parent_id = self.get_parent_item(hir_id);\n         match self.get(parent_id) {\n             Node::Item(&Item {\n-                node: ItemKind::Const(..),\n+                kind: ItemKind::Const(..),\n                 ..\n             })\n             | Node::TraitItem(&TraitItem {\n@@ -662,11 +662,11 @@ impl<'hir> Map<'hir> {\n             })\n             | Node::AnonConst(_)\n             | Node::Item(&Item {\n-                node: ItemKind::Static(..),\n+                kind: ItemKind::Static(..),\n                 ..\n             }) => true,\n             Node::Item(&Item {\n-                node: ItemKind::Fn(_, header, ..),\n+                kind: ItemKind::Fn(_, header, ..),\n                 ..\n             }) => header.constness == Constness::Const,\n             _ => false,\n@@ -676,7 +676,7 @@ impl<'hir> Map<'hir> {\n     /// Wether `hir_id` corresponds to a `mod` or a crate.\n     pub fn is_hir_id_module(&self, hir_id: HirId) -> bool {\n         match self.lookup(hir_id) {\n-            Some(Entry { node: Node::Item(Item { node: ItemKind::Mod(_), .. }), .. }) |\n+            Some(Entry { node: Node::Item(Item { kind: ItemKind::Mod(_), .. }), .. }) |\n             Some(Entry { node: Node::Crate, .. }) => true,\n             _ => false,\n         }\n@@ -796,7 +796,7 @@ impl<'hir> Map<'hir> {\n     /// module parent is in this map.\n     pub fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n         match self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(&Item { node: ItemKind::Mod(_), .. }) => true,\n+            Node::Item(&Item { kind: ItemKind::Mod(_), .. }) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => id,\n@@ -808,7 +808,7 @@ impl<'hir> Map<'hir> {\n     pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n         self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(i) => {\n-                match i.node {\n+                match i.kind {\n                     ItemKind::Fn(..)\n                     | ItemKind::Mod(..)\n                     | ItemKind::Enum(..)\n@@ -852,7 +852,7 @@ impl<'hir> Map<'hir> {\n             }\n             match self.get(scope) {\n                 Node::Item(i) => {\n-                    match i.node {\n+                    match i.kind {\n                         ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }) => {}\n                         _ => break,\n                     }\n@@ -872,7 +872,7 @@ impl<'hir> Map<'hir> {\n         let parent = self.get_parent_item(hir_id);\n         if let Some(entry) = self.find_entry(parent) {\n             if let Entry {\n-                node: Node::Item(Item { node: ItemKind::ForeignMod(ref nm), .. }), .. } = entry\n+                node: Node::Item(Item { kind: ItemKind::ForeignMod(ref nm), .. }), .. } = entry\n             {\n                 self.read(hir_id); // reveals some of the content of a node\n                 return nm.abi;\n@@ -905,7 +905,7 @@ impl<'hir> Map<'hir> {\n     pub fn expect_variant_data(&self, id: HirId) -> &'hir VariantData {\n         match self.find(id) {\n             Some(Node::Item(i)) => {\n-                match i.node {\n+                match i.kind {\n                     ItemKind::Struct(ref struct_def, _) |\n                     ItemKind::Union(ref struct_def, _) => struct_def,\n                     _ => bug!(\"struct ID bound to non-struct {}\", self.node_to_string(id))\n@@ -1123,7 +1123,7 @@ impl<'a> NodesMatchingSuffix<'a> {\n             }\n \n             fn item_is_mod(item: &Item) -> bool {\n-                match item.node {\n+                match item.kind {\n                     ItemKind::Mod(_) => true,\n                     _ => false,\n                 }\n@@ -1286,7 +1286,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n \n     match map.find(id) {\n         Some(Node::Item(item)) => {\n-            let item_str = match item.node {\n+            let item_str = match item.kind {\n                 ItemKind::ExternCrate(..) => \"extern crate\",\n                 ItemKind::Use(..) => \"use\",\n                 ItemKind::Static(..) => \"static\","}, {"sha": "abb4a88d04c96bdff641c3eb8abf021f26f086ab", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -2416,7 +2416,7 @@ pub struct Item {\n     pub ident: Ident,\n     pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n-    pub node: ItemKind,\n+    pub kind: ItemKind,\n     pub vis: Visibility,\n     pub span: Span,\n }"}, {"sha": "de9a458c06fcb27732b978d4286ac107538da883", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -474,7 +474,7 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(&item.attrs);\n         self.ann.pre(self, AnnNode::Item(item));\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::ExternCrate(orig_name) => {\n                 self.head(visibility_qualified(&item.vis, \"extern crate\"));\n                 if let Some(orig_name) = orig_name {"}, {"sha": "8e74f1e11eb511b23719a5157bfb5baceda3e908", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -312,15 +312,15 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n             ident,\n             ref attrs,\n             hir_id: _,\n-            ref node,\n+            ref kind,\n             ref vis,\n             span\n         } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n             ident.name.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n-            node.hash_stable(hcx, hasher);\n+            kind.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n         });"}, {"sha": "d31b527a55b6951e6e4663744a6e52b9ba98cba5", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -248,7 +248,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     fn item_scope_tag(item: &hir::Item) -> &'static str {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Impl(..) => \"impl\",\n             hir::ItemKind::Struct(..) => \"struct\",\n             hir::ItemKind::Union(..) => \"union\","}, {"sha": "9c362a5e20791973fa3d360b6d26b6211fe7c63f", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -31,7 +31,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             if let Some(hir_id) = self.tcx().hir().as_local_hir_id(def_id) {\n                 let fndecl = match self.tcx().hir().get(hir_id) {\n                     Node::Item(&hir::Item {\n-                        node: hir::ItemKind::Fn(ref fndecl, ..),\n+                        kind: hir::ItemKind::Fn(ref fndecl, ..),\n                         ..\n                     }) => &fndecl,\n                     Node::TraitItem(&hir::TraitItem {"}, {"sha": "3b3649fd8112fce75ae0a4489c7ceb1a6e1e1e91", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -1036,7 +1036,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                                                 .local_def_id(opaque_parent_hir_id)\n                         };\n                         let (in_definition_scope, origin) = match tcx.hir().find(opaque_hir_id) {\n-                            Some(Node::Item(item)) => match item.node {\n+                            Some(Node::Item(item)) => match item.kind {\n                                 // Anonymous `impl Trait`\n                                 hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                                     impl_trait_fn: Some(parent),"}, {"sha": "fa73a3c6c4628bb1ee29573913a7f0a44b4f10d7", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -981,7 +981,7 @@ for LateContextAndPass<'a, 'tcx, T> {\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         let generics = self.context.generics.take();\n-        self.context.generics = it.node.generics();\n+        self.context.generics = it.kind.generics();\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n             cx.with_param_env(it.hir_id, |cx| {\n                 lint_callback!(cx, check_item, it);"}, {"sha": "a08722e940295b137e326cf530523097a1777210", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -218,7 +218,7 @@ declare_lint_pass!(LintPassImpl => [LINT_PASS_IMPL_WITHOUT_MACRO]);\n \n impl EarlyLintPass for LintPassImpl {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n-        if let ItemKind::Impl(_, _, _, _, Some(lint_pass), _, _) = &item.node {\n+        if let ItemKind::Impl(_, _, _, _, Some(lint_pass), _, _) = &item.kind {\n             if let Some(last) = lint_pass.path.segments.last() {\n                 if last.ident.name == sym::LintPass {\n                     let expn_data = lint_pass.path.span.ctxt().outer_expn_data();"}, {"sha": "845f214106b5c5334f3ec3539092d2998208dc5b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -166,7 +166,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         self.inherited_pub_visibility = false;\n         match node {\n             Node::Item(item) => {\n-                match item.node {\n+                match item.kind {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n                         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                         let def = self.tcx.adt_def(def_id);\n@@ -369,7 +369,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n         if allow_dead_code {\n             self.worklist.push(item.hir_id);\n         }\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Enum(ref enum_def, _) => {\n                 if allow_dead_code {\n                     self.worklist.extend(enum_def.variants.iter().map(|variant| variant.id));\n@@ -482,7 +482,7 @@ struct DeadVisitor<'tcx> {\n \n impl DeadVisitor<'tcx> {\n     fn should_warn_about_item(&mut self, item: &hir::Item) -> bool {\n-        let should_warn = match item.node {\n+        let should_warn = match item.kind {\n             hir::ItemKind::Static(..)\n             | hir::ItemKind::Const(..)\n             | hir::ItemKind::Fn(..)\n@@ -571,7 +571,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n         if self.should_warn_about_item(item) {\n             // For items that have a definition with a signature followed by a\n             // block, point only at the signature.\n-            let span = match item.node {\n+            let span = match item.kind {\n                 hir::ItemKind::Fn(..) |\n                 hir::ItemKind::Mod(..) |\n                 hir::ItemKind::Enum(..) |\n@@ -581,15 +581,15 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                 hir::ItemKind::Impl(..) => self.tcx.sess.source_map().def_span(item.span),\n                 _ => item.span,\n             };\n-            let participle = match item.node {\n+            let participle = match item.kind {\n                 hir::ItemKind::Struct(..) => \"constructed\", // Issue #52325\n                 _ => \"used\"\n             };\n             self.warn_dead_code(\n                 item.hir_id,\n                 span,\n                 item.ident.name,\n-                item.node.descriptive_variant(),\n+                item.kind.descriptive_variant(),\n                 participle,\n             );\n         } else {"}, {"sha": "660fe14ba07001c4a143ccd7817c439dd08e2bd6", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -80,7 +80,7 @@ fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(DefId, EntryFnType)> {\n // Beware, this is duplicated in `libsyntax/entry.rs`, so make sure to keep\n // them in sync.\n fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n-    match item.node {\n+    match item.kind {\n         ItemKind::Fn(..) => {\n             if attr::contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start"}, {"sha": "8be64bf64b5e91c8bcc3d07751c45396fced3621", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -32,7 +32,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item, attrs: CodegenFnAt\n         return true\n     }\n \n-    match item.node {\n+    match item.kind {\n         hir::ItemKind::Fn(_, header, ..) if header.is_const() => {\n             return true;\n         }\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n \n         match self.tcx.hir().find(hir_id) {\n             Some(Node::Item(item)) => {\n-                match item.node {\n+                match item.kind {\n                     hir::ItemKind::Fn(..) =>\n                         item_might_be_inlined(self.tcx, &item, self.tcx.codegen_fn_attrs(def_id)),\n                     _ => false,\n@@ -187,7 +187,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // type of the impl require inlining, this method\n                             // does too.\n                             let impl_hir_id = self.tcx.hir().as_local_hir_id(impl_did).unwrap();\n-                            match self.tcx.hir().expect_item(impl_hir_id).node {\n+                            match self.tcx.hir().expect_item(impl_hir_id).kind {\n                                 hir::ItemKind::Impl(..) => {\n                                     let generics = self.tcx.generics_of(impl_did);\n                                     generics.requires_monomorphization(self.tcx)\n@@ -225,7 +225,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n             if let Node::Item(item) = *node {\n-                let reachable = if let hir::ItemKind::Fn(_, header, ..) = item.node {\n+                let reachable = if let hir::ItemKind::Fn(_, header, ..) = item.kind {\n                     header.abi != Abi::Rust\n                 } else {\n                     false\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n \n         match *node {\n             Node::Item(item) => {\n-                match item.node {\n+                match item.kind {\n                     hir::ItemKind::Fn(.., body) => {\n                         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                         if item_might_be_inlined(self.tcx,\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n         }\n \n         // We need only trait impls here, not inherent impls, and only non-exported ones\n-        if let hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n+        if let hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.kind {\n             if !self.access_levels.is_reachable(item.hir_id) {\n                 self.worklist.extend(impl_item_refs.iter().map(|ii_ref| ii_ref.id.hir_id));\n "}, {"sha": "8340df4fecfac5b5d5c23682f8a954d6a0b92614", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -459,7 +459,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Fn(ref decl, _, ref generics, _) => {\n                 self.visit_early_late(None, decl, generics, |this| {\n                     intravisit::walk_item(this, item);\n@@ -504,12 +504,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             | hir::ItemKind::Impl(_, _, _, ref generics, ..) => {\n                 // Impls permit `'_` to be used and it is equivalent to \"some fresh lifetime name\".\n                 // This is not true for other kinds of items.x\n-                let track_lifetime_uses = match item.node {\n+                let track_lifetime_uses = match item.kind {\n                     hir::ItemKind::Impl(..) => true,\n                     _ => false,\n                 };\n                 // These kinds of items have only early-bound lifetime parameters.\n-                let mut index = if sub_items_have_self_param(&item.node) {\n+                let mut index = if sub_items_have_self_param(&item.kind) {\n                     1 // Self comes before lifetimes\n                 } else {\n                     0\n@@ -637,8 +637,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // `type MyAnonTy<'b> = impl MyTrait<'b>;`\n                 //                 ^                  ^ this gets resolved in the scope of\n                 //                                      the opaque_ty generics\n-                let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).node\n-                {\n+                let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).kind {\n                     // Named opaque `impl Trait` types are reached via `TyKind::Path`.\n                     // This arm is for `impl Trait` in the types of statics, constants and locals.\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n@@ -1263,7 +1262,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n fn compute_object_lifetime_defaults(tcx: TyCtxt<'_>) -> HirIdMap<Vec<ObjectLifetimeDefault>> {\n     let mut map = HirIdMap::default();\n     for item in tcx.hir().krate().items.values() {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Struct(_, ref generics)\n             | hir::ItemKind::Union(_, ref generics)\n             | hir::ItemKind::Enum(_, ref generics)\n@@ -1525,7 +1524,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             {\n                 match parent {\n                     Node::Item(item) => {\n-                        if let hir::ItemKind::Fn(decl, _, _, _) = &item.node {\n+                        if let hir::ItemKind::Fn(decl, _, _, _) = &item.kind {\n                             find_arg_use_span(&decl.inputs);\n                         }\n                     },\n@@ -1733,10 +1732,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n             let parent = self.tcx.hir().expect_item(parent_id);\n-            if sub_items_have_self_param(&parent.node) {\n+            if sub_items_have_self_param(&parent.kind) {\n                 index += 1; // Self comes before lifetimes\n             }\n-            match parent.node {\n+            match parent.kind {\n                 hir::ItemKind::Trait(_, _, ref generics, ..)\n                 | hir::ItemKind::Impl(_, _, _, ref generics, ..) => {\n                     index += generics.params.len() as u32;\n@@ -1867,7 +1866,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n                 match self.tcx.hir().get(fn_id) {\n                     Node::Item(&hir::Item {\n-                        node: hir::ItemKind::Fn(..),\n+                        kind: hir::ItemKind::Fn(..),\n                         ..\n                     })\n                     | Node::TraitItem(&hir::TraitItem {\n@@ -2165,7 +2164,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let body = match self.tcx.hir().get(parent) {\n             // `fn` definitions and methods.\n             Node::Item(&hir::Item {\n-                node: hir::ItemKind::Fn(.., body),\n+                kind: hir::ItemKind::Fn(.., body),\n                 ..\n             }) => Some(body),\n \n@@ -2176,7 +2175,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 if let hir::ItemKind::Trait(.., ref trait_items) = self.tcx\n                     .hir()\n                     .expect_item(self.tcx.hir().get_parent_item(parent))\n-                    .node\n+                    .kind\n                 {\n                     assoc_item_kind = trait_items\n                         .iter()\n@@ -2196,7 +2195,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 if let hir::ItemKind::Impl(.., ref self_ty, ref impl_items) = self.tcx\n                     .hir()\n                     .expect_item(self.tcx.hir().get_parent_item(parent))\n-                    .node\n+                    .kind\n                 {\n                     impl_self = Some(self_ty);\n                     assoc_item_kind = impl_items"}, {"sha": "0e4bab6eaf20cfda7ab118c13455a5c10e6e424b", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     fn visit_item(&mut self, i: &'tcx Item) {\n         let orig_in_trait_impl = self.in_trait_impl;\n         let mut kind = AnnotationKind::Required;\n-        match i.node {\n+        match i.kind {\n             // Inherent impls and foreign modules serve only as containers for other items,\n             // they don't have their own stability. They still can be annotated as unstable\n             // and propagate this unstability to children, but this annotation is completely\n@@ -344,14 +344,14 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n-        match i.node {\n+        match i.kind {\n             // Inherent impls and foreign modules serve only as containers for other items,\n             // they don't have their own stability. They still can be annotated as unstable\n             // and propagate this unstability to children, but this annotation is completely\n             // optional. They inherit stability from their parents when unannotated.\n             hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {}\n \n-            _ => self.check_missing_stability(i.hir_id, i.span, i.node.descriptive_variant())\n+            _ => self.check_missing_stability(i.hir_id, i.span, i.kind.descriptive_variant())\n         }\n \n         intravisit::walk_item(self, i)\n@@ -797,7 +797,7 @@ impl Visitor<'tcx> for Checker<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::ExternCrate(_) => {\n                 // compiler-generated `extern crate` items have a dummy span.\n                 if item.span.is_dummy() { return }"}, {"sha": "1ce5d72ba848e0e9f2f24373ff4efa55294550fd", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -1001,7 +1001,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     Ok(EvaluationResult::EvaluatedToAmbig) => {\n                         if let Some(hir::Node::Item(hir::Item {\n                             ident,\n-                            node: hir::ItemKind::Fn(.., body_id),\n+                            kind: hir::ItemKind::Fn(.., body_id),\n                             ..\n                         })) = self.tcx.hir().get_if_local(def_id) {\n                             let body = self.tcx.hir().body(*body_id);\n@@ -1106,7 +1106,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let parent_node = hir.get_parent_node(obligation.cause.body_id);\n         let node = hir.find(parent_node);\n         if let Some(hir::Node::Item(hir::Item {\n-            node: hir::ItemKind::Fn(decl, _, _, body_id),\n+            kind: hir::ItemKind::Fn(decl, _, _, body_id),\n             ..\n         })) = node {\n             let body = hir.body(*body_id);\n@@ -1163,7 +1163,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             Node::Item(&hir::Item {\n                 span,\n-                node: hir::ItemKind::Fn(ref decl, ..),\n+                kind: hir::ItemKind::Fn(ref decl, ..),\n                 ..\n             }) |\n             Node::ImplItem(&hir::ImplItem {"}, {"sha": "6d0347563d0037bcebcfbaadbc27b3ed5dd68173", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -654,7 +654,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         match self.hir().as_local_hir_id(node_item_def_id) {\n             Some(hir_id) => {\n                 let item = self.hir().expect_item(hir_id);\n-                if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.node {\n+                if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.kind {\n                     defaultness.is_default()\n                 } else {\n                     false"}, {"sha": "daf871463b2b630a7692e7e3973c527ab4919f67", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -1554,7 +1554,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let hir_id = self.hir().as_local_hir_id(scope_def_id).unwrap();\n         match self.hir().get(hir_id) {\n             Node::Item(item) => {\n-                match item.node {\n+                match item.kind {\n                     ItemKind::Fn(..) => { /* `type_of_def_id()` will work */ }\n                     _ => {\n                         return None;"}, {"sha": "f107af0cd07ecbf8abd489978cc52d88fd7fbdfa", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -3164,7 +3164,7 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> AssocItem {\n     let parent_id = tcx.hir().get_parent_item(id);\n     let parent_def_id = tcx.hir().local_def_id(parent_id);\n     let parent_item = tcx.hir().expect_item(parent_id);\n-    match parent_item.node {\n+    match parent_item.kind {\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.hir_id == id) {\n                 let assoc_item = tcx.associated_item_from_impl_item_ref(parent_def_id,\n@@ -3189,7 +3189,7 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> AssocItem {\n \n     span_bug!(parent_item.span,\n               \"unexpected parent of trait or impl item or item not found: {:?}\",\n-              parent_item.node)\n+              parent_item.kind)\n }\n \n #[derive(Clone, HashStable)]\n@@ -3221,7 +3221,7 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> AdtSizedConstraint<'_\n fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item(id);\n-    match item.node {\n+    match item.kind {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             tcx.arena.alloc_from_iter(\n                 trait_item_refs.iter()\n@@ -3262,7 +3262,7 @@ fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n         if let Node::Item(item) = tcx.hir().get(hir_id) {\n-            if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.node {\n+            if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.kind {\n                 return opaque_ty.impl_trait_fn;\n             }\n         }"}, {"sha": "ccecacd62057ca17c2c5773cf96a46148af89f5b", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -230,7 +230,7 @@ impl CodegenCx<'ll, 'tcx> {\n             let llty = self.layout_of(ty).llvm_type(self);\n             let (g, attrs) = match self.tcx.hir().get(id) {\n                 Node::Item(&hir::Item {\n-                    ref attrs, span, node: hir::ItemKind::Static(..), ..\n+                    ref attrs, span, kind: hir::ItemKind::Static(..), ..\n                 }) => {\n                     let sym_str = sym.as_str();\n                     if self.get_declared_value(&sym_str).is_some() {"}, {"sha": "d634b73430a583f2e7a0b46e86fe09a89ea5155f", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -94,11 +94,11 @@ fn reachable_non_generics_provider(\n \n                 // Only consider nodes that actually have exported symbols.\n                 Node::Item(&hir::Item {\n-                    node: hir::ItemKind::Static(..),\n+                    kind: hir::ItemKind::Static(..),\n                     ..\n                 }) |\n                 Node::Item(&hir::Item {\n-                    node: hir::ItemKind::Fn(..), ..\n+                    kind: hir::ItemKind::Fn(..), ..\n                 }) |\n                 Node::ImplItem(&hir::ImplItem {\n                     kind: hir::ImplItemKind::Method(..),\n@@ -367,7 +367,7 @@ fn symbol_export_level(tcx: TyCtxt<'_>, sym_def_id: DefId) -> SymbolExportLevel\n         // Emscripten cannot export statics, so reduce their export level here\n         if tcx.sess.target.target.options.is_like_emscripten {\n             if let Some(Node::Item(&hir::Item {\n-                node: hir::ItemKind::Static(..),\n+                kind: hir::ItemKind::Static(..),\n                 ..\n             })) = tcx.hir().get_if_local(sym_def_id) {\n                 return SymbolExportLevel::Rust;"}, {"sha": "10177d2997a76ffbd81a82e27cad229ced5d11d5", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -30,7 +30,7 @@ impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n             }\n             MonoItem::GlobalAsm(hir_id) => {\n                 let item = cx.tcx().hir().expect_item(hir_id);\n-                if let hir::ItemKind::GlobalAsm(ref ga) = item.node {\n+                if let hir::ItemKind::GlobalAsm(ref ga) = item.kind {\n                     cx.codegen_global_asm(ga);\n                 } else {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and MonoItem type\")"}, {"sha": "abe0ffb0e02c5366367c02d159ed2f15ac978976", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -327,7 +327,7 @@ impl DirtyCleanVisitor<'tcx> {\n         let node = self.tcx.hir().get(item_id);\n         let (name, labels) = match node {\n             HirNode::Item(item) => {\n-                match item.node {\n+                match item.kind {\n                     // note: these are in the same order as hir::Item_;\n                     // FIXME(michaelwoerister): do commented out ones\n \n@@ -391,7 +391,7 @@ impl DirtyCleanVisitor<'tcx> {\n                         &format!(\n                             \"clean/dirty auto-assertions not yet defined \\\n                              for Node::Item.node={:?}\",\n-                            item.node\n+                            item.kind\n                         )\n                     ),\n                 }"}, {"sha": "d0a7eab071c311de1e85c66bc8ed89829c15cfac", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -117,7 +117,7 @@ impl BoxPointers {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        match it.node {\n+        match it.kind {\n             hir::ItemKind::Fn(..) |\n             hir::ItemKind::TyAlias(..) |\n             hir::ItemKind::Enum(..) |\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n         }\n \n         // If it's a struct, we also have to check the fields' types\n-        match it.node {\n+        match it.kind {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 for struct_field in struct_def.fields() {\n@@ -233,7 +233,7 @@ impl EarlyLintPass for UnsafeCode {\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, it: &ast::Item) {\n-        match it.node {\n+        match it.kind {\n             ast::ItemKind::Trait(_, ast::Unsafety::Unsafe, ..) => {\n                 self.report_unsafe(cx, it.span, \"declaration of an `unsafe` trait\")\n             }\n@@ -391,7 +391,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        let desc = match it.node {\n+        let desc = match it.kind {\n             hir::ItemKind::Fn(..) => \"a function\",\n             hir::ItemKind::Mod(..) => \"a module\",\n             hir::ItemKind::Enum(..) => \"an enum\",\n@@ -504,7 +504,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n         if !cx.access_levels.is_reachable(item.hir_id) {\n             return;\n         }\n-        let (def, ty) = match item.node {\n+        let (def, ty) = match item.kind {\n             hir::ItemKind::Struct(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n@@ -563,7 +563,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n             return;\n         }\n \n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Union(..) |\n             hir::ItemKind::Enum(..) => {}\n@@ -766,7 +766,7 @@ impl UnusedDocComment {\n \n impl EarlyLintPass for UnusedDocComment {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n-        if let ast::ItemKind::Mac(..) = item.node {\n+        if let ast::ItemKind::Mac(..) = item.kind {\n             self.warn_if_doc(cx, item.span, \"macro expansions\", true, &item.attrs);\n         }\n     }\n@@ -809,7 +809,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PluginAsLibrary {\n             return;\n         }\n \n-        match it.node {\n+        match it.kind {\n             hir::ItemKind::ExternCrate(..) => (),\n             _ => return,\n         };\n@@ -849,7 +849,7 @@ declare_lint_pass!(InvalidNoMangleItems => [NO_MANGLE_CONST_ITEMS, NO_MANGLE_GEN\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        match it.node {\n+        match it.kind {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n                 if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n                     for param in &generics.params {\n@@ -992,7 +992,7 @@ declare_lint_pass!(\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n     fn check_item(&mut self, ctx: &LateContext<'_, '_>, item: &hir::Item) {\n-        if let hir::ItemKind::Union(ref vdata, _) = item.node {\n+        if let hir::ItemKind::Union(ref vdata, _) = item.kind {\n             for field in vdata.fields() {\n                 let field_ty = ctx.tcx.type_of(\n                     ctx.tcx.hir().local_def_id(field.hir_id));\n@@ -1137,7 +1137,7 @@ impl TypeAliasBounds {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n-        let (ty, type_alias_generics) = match item.node {\n+        let (ty, type_alias_generics) = match item.kind {\n             hir::ItemKind::TyAlias(ref ty, ref generics) => (&*ty, generics),\n             _ => return,\n         };\n@@ -1204,7 +1204,7 @@ fn check_const(cx: &LateContext<'_, '_>, body_id: hir::BodyId) {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedBrokenConst {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        match it.node {\n+        match it.kind {\n             hir::ItemKind::Const(_, body_id) => {\n                 check_const(cx, body_id);\n             },\n@@ -1395,7 +1395,7 @@ impl UnnameableTestItems {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         if self.items_nameable {\n-            if let hir::ItemKind::Mod(..) = it.node {}\n+            if let hir::ItemKind::Mod(..) = it.kind {}\n             else {\n                 self.items_nameable = false;\n                 self.boundary = it.hir_id;\n@@ -1684,7 +1684,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n         let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         if let hir::ItemKind::Struct(_, ref hir_generics)\n             | hir::ItemKind::Enum(_, ref hir_generics)\n-            | hir::ItemKind::Union(_, ref hir_generics) = item.node\n+            | hir::ItemKind::Union(_, ref hir_generics) = item.kind\n         {\n             let inferred_outlives = cx.tcx.inferred_outlives_of(def_id);\n             if inferred_outlives.is_empty() {\n@@ -1812,7 +1812,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n                 // generics, except for tuple struct, which have the `where`\n                 // after the fields of the struct.\n                 let full_where_span = if let hir::ItemKind::Struct(hir::VariantData::Tuple(..), _)\n-                        = item.node\n+                        = item.kind\n                 {\n                     where_span\n                 } else {"}, {"sha": "dceb79fd30985d7aa341d372df2b47993e65a96b", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -136,7 +136,7 @@ impl EarlyLintPass for NonCamelCaseTypes {\n             return;\n         }\n \n-        match it.node {\n+        match it.kind {\n             ast::ItemKind::TyAlias(..) |\n             ast::ItemKind::Enum(..) |\n             ast::ItemKind::Struct(..) |\n@@ -326,7 +326,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        if let hir::ItemKind::Mod(_) = it.node {\n+        if let hir::ItemKind::Mod(_) = it.kind {\n             self.check_snake_case(cx, \"module\", &it.ident);\n         }\n     }\n@@ -387,7 +387,7 @@ impl NonUpperCaseGlobals {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        match it.node {\n+        match it.kind {\n             hir::ItemKind::Static(..) if !attr::contains_name(&it.attrs, sym::no_mangle) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", &it.ident);\n             }"}, {"sha": "1fb377c9ad657f1781225c004cdabd7e90d3f2a6", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -995,7 +995,7 @@ declare_lint_pass!(VariantSizeDifferences => [VARIANT_SIZE_DIFFERENCES]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        if let hir::ItemKind::Enum(ref enum_definition, _) = it.node {\n+        if let hir::ItemKind::Enum(ref enum_definition, _) = it.kind {\n             let item_def_id = cx.tcx.hir().local_def_id(it.hir_id);\n             let t = cx.tcx.type_of(item_def_id);\n             let ty = cx.tcx.erase_regions(&t);"}, {"sha": "3b3995832cb4cb1f9663c6bad8ae604fbc8e3a7e", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -647,7 +647,7 @@ impl UnusedImportBraces {\n \n impl EarlyLintPass for UnusedImportBraces {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n-        if let ast::ItemKind::Use(ref use_tree) = item.node {\n+        if let ast::ItemKind::Use(ref use_tree) = item.kind {\n             self.check_use_tree(cx, use_tree, item);\n         }\n     }"}, {"sha": "0a2a481bb1500d5e5541b687d94ef45d2c414f64", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -999,7 +999,7 @@ impl<'a> CrateLoader<'a> {\n     pub fn process_extern_crate(\n         &mut self, item: &ast::Item, definitions: &Definitions,\n     ) -> CrateNum {\n-        match item.node {\n+        match item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 debug!(\"resolving extern crate stmt. ident: {} orig_name: {:?}\",\n                        item.ident, orig_name);"}, {"sha": "8a7e599ebeb63bf21ec425e4bbf37e2c7f5281ad", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -479,7 +479,7 @@ impl cstore::CStore {\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             attrs: attrs.iter().cloned().collect(),\n-            node: ast::ItemKind::MacroDef(ast::MacroDef {\n+            kind: ast::ItemKind::MacroDef(ast::MacroDef {\n                 tokens: body.into(),\n                 legacy: def.legacy,\n             }),"}, {"sha": "b89da65d09808a70fe0c5ff8c9a57f07d858e39e", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -1117,7 +1117,7 @@ impl EncodeContext<'tcx> {\n \n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n-        let kind = match item.node {\n+        let kind = match item.kind {\n             hir::ItemKind::Static(_, hir::MutMutable, _) => EntryKind::MutStatic,\n             hir::ItemKind::Static(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n@@ -1233,7 +1233,7 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         };\n \n-        let mir = match item.node {\n+        let mir = match item.kind {\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => true,\n             hir::ItemKind::Fn(_, header, ..) => {\n                 let generics = tcx.generics_of(def_id);\n@@ -1252,7 +1252,7 @@ impl EncodeContext<'tcx> {\n             visibility: self.lazy(ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n             span: self.lazy(item.span),\n             attributes: self.encode_attributes(&item.attrs),\n-            children: match item.node {\n+            children: match item.kind {\n                 hir::ItemKind::ForeignMod(ref fm) => {\n                     self.lazy(fm.items\n                         .iter()\n@@ -1286,7 +1286,7 @@ impl EncodeContext<'tcx> {\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n \n-            ty: match item.node {\n+            ty: match item.kind {\n                 hir::ItemKind::Static(..) |\n                 hir::ItemKind::Const(..) |\n                 hir::ItemKind::Fn(..) |\n@@ -1299,14 +1299,14 @@ impl EncodeContext<'tcx> {\n                 _ => None,\n             },\n             inherent_impls: self.encode_inherent_implementations(def_id),\n-            variances: match item.node {\n+            variances: match item.kind {\n                 hir::ItemKind::Enum(..) |\n                 hir::ItemKind::Struct(..) |\n                 hir::ItemKind::Union(..) |\n                 hir::ItemKind::Fn(..) => self.encode_variances_of(def_id),\n                 _ => Lazy::empty(),\n             },\n-            generics: match item.node {\n+            generics: match item.kind {\n                 hir::ItemKind::Static(..) |\n                 hir::ItemKind::Const(..) |\n                 hir::ItemKind::Fn(..) |\n@@ -1320,7 +1320,7 @@ impl EncodeContext<'tcx> {\n                 hir::ItemKind::TraitAlias(..) => Some(self.encode_generics(def_id)),\n                 _ => None,\n             },\n-            predicates: match item.node {\n+            predicates: match item.kind {\n                 hir::ItemKind::Static(..) |\n                 hir::ItemKind::Const(..) |\n                 hir::ItemKind::Fn(..) |\n@@ -1340,7 +1340,7 @@ impl EncodeContext<'tcx> {\n             // so only encode it in that case as an efficiency\n             // hack. (No reason not to expand it in the future if\n             // necessary.)\n-            predicates_defined_on: match item.node {\n+            predicates_defined_on: match item.kind {\n                 hir::ItemKind::Trait(..) |\n                 hir::ItemKind::TraitAlias(..) => Some(self.encode_predicates_defined_on(def_id)),\n                 _ => None, // not *wrong* for other kinds of items, but not needed\n@@ -1728,7 +1728,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => {} // ignore these\n             _ => self.record(def_id, EncodeContext::encode_info_for_item, (def_id, item)),\n@@ -1824,7 +1824,7 @@ impl EncodeContext<'tcx> {\n     /// normally in the visitor walk.\n     fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Static(..) |\n             hir::ItemKind::Const(..) |\n             hir::ItemKind::Fn(..) |\n@@ -1893,7 +1893,7 @@ struct ImplVisitor<'tcx> {\n \n impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemKind::Impl(..) = item.node {\n+        if let hir::ItemKind::Impl(..) = item.kind {\n             let impl_id = self.tcx.hir().local_def_id(item.hir_id);\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n                 self.impls"}, {"sha": "8a4f6e6f17a5112733fc69a4ffe2e3dcd082e4fd", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -19,7 +19,7 @@ struct Collector<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n-        let fm = match it.node {\n+        let fm = match it.kind {\n             hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n         };"}, {"sha": "527d4421fca656d9a9a4250eba539713f707fe66", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -27,7 +27,7 @@ struct Collector {\n \n impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n-        let fm = match it.node {\n+        let fm = match it.kind {\n             hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n         };"}, {"sha": "fe215d9c7999ea66c453d20689fa2da730f2fafc", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -35,7 +35,7 @@ struct Collector<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n-        let fm = match it.node {\n+        let fm = match it.kind {\n             hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n         };"}, {"sha": "6b7fee6effbe1000c2c59b42f5e3c75db7125c7c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -28,7 +28,7 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get(id) {\n         Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n-        | Node::Item(hir::Item { node: hir::ItemKind::Fn(decl, _, _, body_id), .. })\n+        | Node::Item(hir::Item { kind: hir::ItemKind::Fn(decl, _, _, body_id), .. })\n         | Node::ImplItem(\n             hir::ImplItem {\n                 kind: hir::ImplItemKind::Method(hir::MethodSig { decl, .. }, body_id),\n@@ -46,8 +46,8 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n         ) => {\n             (*body_id, decl.output.span())\n         }\n-        Node::Item(hir::Item { node: hir::ItemKind::Static(ty, _, body_id), .. })\n-        | Node::Item(hir::Item { node: hir::ItemKind::Const(ty, body_id), .. })\n+        Node::Item(hir::Item { kind: hir::ItemKind::Static(ty, _, body_id), .. })\n+        | Node::Item(hir::Item { kind: hir::ItemKind::Const(ty, body_id), .. })\n         | Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Const(ty, body_id), .. })\n         | Node::TraitItem(\n             hir::TraitItem { kind: hir::TraitItemKind::Const(ty, Some(body_id)), .. }"}, {"sha": "cc8f4759e183791d20e2f3e52370c380495ba93d", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -981,7 +981,7 @@ struct RootCollector<'a, 'tcx> {\n \n impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::ExternCrate(..) |\n             hir::ItemKind::Use(..)         |\n             hir::ItemKind::ForeignMod(..)  |\n@@ -1141,7 +1141,7 @@ fn create_mono_items_for_default_impls<'tcx>(\n     item: &'tcx hir::Item,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n-    match item.node {\n+    match item.kind {\n         hir::ItemKind::Impl(_, _, _, ref generics, .., ref impl_item_refs) => {\n             for param in &generics.params {\n                 match param.kind {"}, {"sha": "acd53ac68ae3f27d4290f8f20f9ee72217808fce", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -577,7 +577,7 @@ fn is_enclosed(\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n         } else if let Some(Node::Item(&hir::Item {\n-            node: hir::ItemKind::Fn(_, header, _, _),\n+            kind: hir::ItemKind::Fn(_, header, _, _),\n             ..\n         })) = tcx.hir().find(parent_id) {\n             match header.unsafety {"}, {"sha": "89497641c1007ce47c13ea4cd7df372c51eac385", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -538,7 +538,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.has_proc_macro_decls = true;\n         }\n \n-        match item.node {\n+        match item.kind {\n             ItemKind::Impl(unsafety, polarity, _, _, Some(..), ref ty, ref impl_items) => {\n                 self.invalid_visibility(&item.vis, None);\n                 if let TyKind::Err = ty.kind {"}, {"sha": "06683c16e4a9bee0b0e73455bc58440f55ab0f51", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -31,7 +31,7 @@ impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n \n-        if let ItemKind::TyAlias(..) = item.node {\n+        if let ItemKind::TyAlias(..) = item.kind {\n             for attr in self.tcx.get_attrs(item_def_id).iter() {\n                 if attr.check_name(sym::rustc_layout) {\n                     self.dump_layout_of(item_def_id, item, attr);"}, {"sha": "01559a95c9c31d83a7bdf826da85a9be157aed01", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -15,7 +15,7 @@ struct RegistrarFinder {\n \n impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemKind::Fn(..) = item.node {\n+        if let hir::ItemKind::Fn(..) = item.kind {\n             if attr::contains_name(&item.attrs, sym::plugin_registrar) {\n                 self.registrars.push((item.hir_id, item.span));\n             }"}, {"sha": "f44692b7aea7d6193dff4f35d160d017c00d5e7a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -240,7 +240,7 @@ fn def_id_visibility<'tcx>(\n                 }\n                 Node::ImplItem(impl_item) => {\n                     match tcx.hir().get(tcx.hir().get_parent_item(hir_id)) {\n-                        Node::Item(item) => match &item.node {\n+                        Node::Item(item) => match &item.kind {\n                             hir::ItemKind::Impl(.., None, _, _) => &impl_item.vis,\n                             hir::ItemKind::Impl(.., Some(trait_ref), _, _)\n                                 => return def_id_visibility(tcx, trait_ref.path.res.def_id()),\n@@ -572,7 +572,7 @@ impl EmbargoVisitor<'tcx> {\n                 if let ty::Visibility::Public = vis {\n                     let item = self.tcx.hir().expect_item(hir_id);\n                     if let hir::ItemKind::Struct(ref struct_def, _)\n-                        | hir::ItemKind::Union(ref struct_def, _) = item.node\n+                        | hir::ItemKind::Union(ref struct_def, _) = item.kind\n                     {\n                         for field in struct_def.fields() {\n                             let field_vis = ty::Visibility::from_hir(\n@@ -630,12 +630,12 @@ impl EmbargoVisitor<'tcx> {\n                 .and_then(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n                 .map(|module_hir_id| self.tcx.hir().expect_item(module_hir_id))\n              {\n-                if let hir::ItemKind::Mod(m) = &item.node {\n+                if let hir::ItemKind::Mod(m) = &item.kind {\n                     for item_id in m.item_ids.as_ref() {\n                         let item = self.tcx.hir().expect_item(item_id.id);\n                         let def_id = self.tcx.hir().local_def_id(item_id.id);\n                         if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id) { continue; }\n-                        if let hir::ItemKind::Use(..) = item.node {\n+                        if let hir::ItemKind::Use(..) = item.kind {\n                             self.update(item.hir_id, Some(AccessLevel::Exported));\n                         }\n                     }\n@@ -653,7 +653,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let inherited_item_level = match item.node {\n+        let inherited_item_level = match item.kind {\n             hir::ItemKind::Impl(..) =>\n                 Option::<AccessLevel>::of_impl(item.hir_id, self.tcx, &self.access_levels),\n             // Foreign modules inherit level from parents.\n@@ -673,7 +673,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         let item_level = self.update(item.hir_id, inherited_item_level);\n \n         // Update levels of nested things.\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n                     let variant_level = self.update(variant.id, item_level);\n@@ -727,7 +727,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         }\n \n         // Mark all items in interfaces of reachable items as reachable.\n-        match item.node {\n+        match item.kind {\n             // The interface is empty.\n             hir::ItemKind::ExternCrate(..) => {}\n             // All nested items are checked by `visit_item`.\n@@ -1417,7 +1417,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        match item.node {\n+        match item.kind {\n             // Contents of a private mod can be re-exported, so we need\n             // to check internals.\n             hir::ItemKind::Mod(_) => {}\n@@ -1853,7 +1853,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n         let tcx = self.tcx;\n         let item_visibility = ty::Visibility::from_hir(&item.vis, item.hir_id, tcx);\n \n-        match item.node {\n+        match item.kind {\n             // Crates are always public.\n             hir::ItemKind::ExternCrate(..) => {}\n             // All nested items are checked by `visit_item`."}, {"sha": "f1564c300180e5e0ce89170b9b64b08a5836d809", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -588,7 +588,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n \n-        match item.node {\n+        match item.kind {\n             ItemKind::Use(ref use_tree) => {\n                 self.build_reduced_graph_for_use_tree(\n                     // This particular use tree\n@@ -936,7 +936,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     span_err!(self.r.session, item.span, E0468,\n                         \"an `extern crate` loading macros must be at the crate root\");\n                 }\n-                if let ItemKind::ExternCrate(Some(orig_name)) = item.node {\n+                if let ItemKind::ExternCrate(Some(orig_name)) = item.kind {\n                     if orig_name == kw::SelfLower {\n                         self.r.session.span_err(attr.span,\n                             \"`macro_use` is not supported on `extern crate self`\");\n@@ -1064,7 +1064,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn define_macro(&mut self, item: &ast::Item) -> LegacyScope<'a> {\n         let parent_scope = &self.parent_scope;\n         let expansion = parent_scope.expansion;\n-        let (ext, ident, span, is_legacy) = match &item.node {\n+        let (ext, ident, span, is_legacy) = match &item.kind {\n             ItemKind::MacroDef(def) => {\n                 let ext = Lrc::new(self.r.compile_macro(item, self.r.session.edition()));\n                 (ext, item.ident, item.span, def.legacy)\n@@ -1138,7 +1138,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n \n     fn visit_item(&mut self, item: &'b Item) {\n-        let macro_use = match item.node {\n+        let macro_use = match item.kind {\n             ItemKind::MacroDef(..) => {\n                 self.parent_scope.legacy = self.define_macro(item);\n                 return"}, {"sha": "737589acf8d8146fece502646e89af09d8b2230e", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'b> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b> {\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n-        if let ast::ItemKind::Use(..) = item.node {\n+        if let ast::ItemKind::Use(..) = item.kind {\n             if item.vis.node.is_pub() || item.span.is_dummy() {\n                 return;\n             }"}, {"sha": "e02cba6fbfd25793bd10f509083daebbe0a08869", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -700,9 +700,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     fn resolve_item(&mut self, item: &Item) {\n         let name = item.ident.name;\n-        debug!(\"(resolving item) resolving {} ({:?})\", name, item.node);\n+        debug!(\"(resolving item) resolving {} ({:?})\", name, item.kind);\n \n-        match item.node {\n+        match item.kind {\n             ItemKind::TyAlias(_, ref generics) |\n             ItemKind::OpaqueTy(_, ref generics) |\n             ItemKind::Fn(_, _, ref generics, _) => {\n@@ -1805,7 +1805,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         // Descend into the block.\n         for stmt in &block.stmts {\n             if let StmtKind::Item(ref item) = stmt.kind {\n-                if let ItemKind::MacroDef(..) = item.node {\n+                if let ItemKind::MacroDef(..) = item.kind {\n                     num_macro_definition_ribs += 1;\n                     let res = self.r.definitions.local_def_id(item.id);\n                     self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));"}, {"sha": "bf86a374338402e29dce5cc72ab08bcf60d488d2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -290,7 +290,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n         }\n         // find a use statement\n         for item in &module.items {\n-            match item.node {\n+            match item.kind {\n                 ItemKind::Use(..) => {\n                     // don't suggest placing a use before the prelude\n                     // import or other generated ones"}, {"sha": "d81d24e3a1b99895c1cd5c69de3e330b2a13b97b", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -472,13 +472,13 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         let qualname = format!(\"::{}\",\n             self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n \n-        let kind = match item.node {\n+        let kind = match item.kind {\n             ast::ItemKind::Struct(_, _) => DefKind::Struct,\n             ast::ItemKind::Union(_, _) => DefKind::Union,\n             _ => unreachable!(),\n         };\n \n-        let (value, fields) = match item.node {\n+        let (value, fields) = match item.kind {\n             ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, ..), ..) |\n             ast::ItemKind::Union(ast::VariantData::Struct(ref fields, ..), ..) => {\n                 let include_priv_fields = !self.save_ctxt.config.pub_only;\n@@ -1276,7 +1276,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n     fn visit_item(&mut self, item: &'l ast::Item) {\n         use syntax::ast::ItemKind::*;\n         self.process_macro_use(item.span);\n-        match item.node {\n+        match item.kind {\n             Use(ref use_tree) => {\n                 let prefix = ast::Path {\n                     segments: vec![],"}, {"sha": "20cf7949fecde88fb0c295a461a1d13729d25e00", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -177,7 +177,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_item_data(&self, item: &ast::Item) -> Option<Data> {\n-        match item.node {\n+        match item.kind {\n             ast::ItemKind::Fn(ref decl, .., ref generics, _) => {\n                 let qualname = format!(\"::{}\",\n                     self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id)));\n@@ -396,7 +396,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         let (qualname, parent_scope, decl_id, docs, attributes) =\n             match self.tcx.impl_of_method(self.tcx.hir().local_def_id_from_node_id(id)) {\n                 Some(impl_id) => match self.tcx.hir().get_if_local(impl_id) {\n-                    Some(Node::Item(item)) => match item.node {\n+                    Some(Node::Item(item)) => match item.kind {\n                         hir::ItemKind::Impl(.., ref ty, _) => {\n                             let mut qualname = String::from(\"<\");\n                             qualname.push_str(&self.tcx.hir().hir_to_pretty_string(ty.hir_id));\n@@ -612,7 +612,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Node::TraitRef(tr) => tr.path.res,\n \n             Node::Item(&hir::Item {\n-                node: hir::ItemKind::Use(ref path, _),\n+                kind: hir::ItemKind::Use(ref path, _),\n                 ..\n             }) |\n             Node::Visibility(&Spanned {"}, {"sha": "8a0c9069224fe515168ca49e80722550b8344526", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -324,7 +324,7 @@ impl Sig for ast::Item {\n     fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n         let id = Some(self.id);\n \n-        match self.node {\n+        match self.kind {\n             ast::ItemKind::Static(ref ty, m, ref expr) => {\n                 let mut text = \"static \".to_owned();\n                 if m == ast::Mutability::Mutable {"}, {"sha": "f923f51529aa9d4c313f02499a8906750032f848", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -205,7 +205,7 @@ crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {\n             _ => NodeKind::Other,\n         }\n \n-        Node::Item(item) => match item.node {\n+        Node::Item(item) => match item.kind {\n             ItemKind::Impl(.., Some(..), _, _) => NodeKind::TraitImpl,\n             ItemKind::Impl(.., None, _, _) => NodeKind::InherentImpl,\n             ItemKind::Fn(..) => NodeKind::Fn,"}, {"sha": "13b6b1b8aa08dc332652e09e851a404e2dcfbd40", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ),\n             );\n             if let (Some(expr), Item(hir::Item {\n-                node: hir::ItemKind::Fn(..), ..\n+                kind: hir::ItemKind::Fn(..), ..\n             })) = (&block.expr, parent) {\n                 // check that the `if` expr without `else` is the fn body's expr\n                 if expr.span == span {"}, {"sha": "2d4d2e32f23dbada7d2c41f82dd02a6411655d81", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -895,7 +895,7 @@ fn compute_all_traits(tcx: TyCtxt<'_>) -> Vec<DefId> {\n \n     impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n         fn visit_item(&mut self, i: &'v hir::Item) {\n-            match i.node {\n+            match i.kind {\n                 hir::ItemKind::Trait(..) |\n                 hir::ItemKind::TraitAlias(..) => {\n                     let def_id = self.map.local_def_id(i.hir_id);\n@@ -999,7 +999,7 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n         // Find a `use` statement.\n         for item_id in &module.item_ids {\n             let item = self.tcx.hir().expect_item(item_id.id);\n-            match item.node {\n+            match item.kind {\n                 hir::ItemKind::Use(..) => {\n                     // Don't suggest placing a `use` before the prelude\n                     // import or other generated ones."}, {"sha": "15c98432cc221f4f6a69c241872ea9f25d9ce14a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -792,7 +792,7 @@ fn primary_body_of(\n ) -> Option<(hir::BodyId, Option<&hir::Ty>, Option<&hir::FnHeader>, Option<&hir::FnDecl>)> {\n     match tcx.hir().get(id) {\n         Node::Item(item) => {\n-            match item.node {\n+            match item.kind {\n                 hir::ItemKind::Const(ref ty, body) |\n                 hir::ItemKind::Static(ref ty, _, body) =>\n                     Some((body, Some(ty), None, None)),\n@@ -1262,7 +1262,7 @@ fn check_fn<'a, 'tcx>(\n                     }\n \n                     if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n-                        if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n+                        if let ItemKind::Fn(_, _, ref generics, _) = item.kind {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n                                     span,\n@@ -1310,7 +1310,7 @@ fn check_fn<'a, 'tcx>(\n                     }\n \n                     if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n-                        if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n+                        if let ItemKind::Fn(_, _, ref generics, _) = item.kind {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n                                     span,\n@@ -1403,7 +1403,7 @@ fn check_opaque_for_inheriting_lifetimes(\n         }\n     }\n \n-    let prohibit_opaque = match item.node {\n+    let prohibit_opaque = match item.kind {\n         ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::AsyncFn, .. }) |\n         ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::FnReturn, .. }) => {\n             let mut visitor = ProhibitOpaqueVisitor {\n@@ -1421,7 +1421,7 @@ fn check_opaque_for_inheriting_lifetimes(\n \n     debug!(\"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}\", prohibit_opaque);\n     if prohibit_opaque {\n-        let is_async = match item.node {\n+        let is_async = match item.kind {\n             ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => match origin {\n                 hir::OpaqueTyOrigin::AsyncFn => true,\n                 _ => false,\n@@ -1485,7 +1485,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item) {\n         tcx.def_path_str(tcx.hir().local_def_id(it.hir_id))\n     );\n     let _indenter = indenter();\n-    match it.node {\n+    match it.kind {\n         // Consts can play a role in type-checking, so they are included here.\n         hir::ItemKind::Static(..) => {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n@@ -4069,7 +4069,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let node = self.tcx.hir().get(self.tcx.hir().get_parent_item(id));\n         match node {\n             Node::Item(&hir::Item {\n-                node: hir::ItemKind::Fn(_, _, _, body_id), ..\n+                kind: hir::ItemKind::Fn(_, _, _, body_id), ..\n             }) |\n             Node::ImplItem(&hir::ImplItem {\n                 kind: hir::ImplItemKind::Method(_, body_id), ..\n@@ -4094,7 +4094,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn get_node_fn_decl(&self, node: Node<'tcx>) -> Option<(&'tcx hir::FnDecl, ast::Ident, bool)> {\n         match node {\n             Node::Item(&hir::Item {\n-                ident, node: hir::ItemKind::Fn(ref decl, ..), ..\n+                ident, kind: hir::ItemKind::Fn(ref decl, ..), ..\n             }) => {\n                 // This is less than ideal, it will not suggest a return type span on any\n                 // method called `main`, regardless of whether it is actually the entry point,\n@@ -4192,7 +4192,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let mut msg = \"call this function\";\n             match hir.get_if_local(def_id) {\n                 Some(Node::Item(hir::Item {\n-                    node: ItemKind::Fn(.., body_id),\n+                    kind: ItemKind::Fn(.., body_id),\n                     ..\n                 })) |\n                 Some(Node::ImplItem(hir::ImplItem {"}, {"sha": "d55777789502c7917353284b06490cb3eaade867", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -76,7 +76,7 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n            item.hir_id,\n            tcx.def_path_str(def_id));\n \n-    match item.node {\n+    match item.kind {\n         // Right now we check that every default trait implementation\n         // has an implementation of itself. Basically, a case like:\n         //\n@@ -299,7 +299,7 @@ fn check_type_defn<'tcx, F>(\n                         field.span,\n                         fcx.body_id,\n                         traits::FieldSized {\n-                            adt_kind: match item.node.adt_kind() {\n+                            adt_kind: match item.kind.adt_kind() {\n                                 Some(i) => i,\n                                 None => bug!(),\n                             },"}, {"sha": "7af1a342ff36edd98b532739407c13aa4910aae7", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -33,7 +33,7 @@ impl ItemLikeVisitor<'v> for CheckVisitor<'tcx> {\n         if item.vis.node.is_pub() || item.span.is_dummy() {\n             return;\n         }\n-        if let hir::ItemKind::Use(ref path, _) = item.node {\n+        if let hir::ItemKind::Use(ref path, _) = item.kind {\n             self.check_import(item.hir_id, path.span);\n         }\n     }\n@@ -218,7 +218,7 @@ struct ExternCrateToLint {\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemKind::ExternCrate(orig_name) = item.node {\n+        if let hir::ItemKind::ExternCrate(orig_name) = item.kind {\n             let extern_crate_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             self.crates_to_lint.push(\n                 ExternCrateToLint {"}, {"sha": "64bd144dfa226103b652ebe9ccb2c7021b7bc29b", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -53,7 +53,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: DefId) {\n         // Destructors only work on nominal types.\n         if let Some(impl_hir_id) = tcx.hir().as_local_hir_id(impl_did) {\n             if let Some(Node::Item(item)) = tcx.hir().find(impl_hir_id) {\n-                let span = match item.node {\n+                let span = match item.kind {\n                     ItemKind::Impl(.., ref ty, _) => ty.span,\n                     _ => item.span,\n                 };\n@@ -99,7 +99,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n             let item = tcx.hir().expect_item(impl_hir_id);\n-            let span = if let ItemKind::Impl(.., Some(ref tr), _, _) = item.node {\n+            let span = if let ItemKind::Impl(.., Some(ref tr), _, _) = item.kind {\n                 tr.path.span\n             } else {\n                 span\n@@ -116,7 +116,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n             let item = tcx.hir().expect_item(impl_hir_id);\n-            let span = if let ItemKind::Impl(.., ref ty, _) = item.node {\n+            let span = if let ItemKind::Impl(.., ref ty, _) = item.kind {\n                 ty.span\n             } else {\n                 span\n@@ -481,7 +481,7 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n                     let item = gcx.hir().expect_item(impl_hir_id);\n-                    let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.node {\n+                    let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.kind {\n                         t.path.span\n                     } else {\n                         gcx.hir().span(impl_hir_id)"}, {"sha": "90cedb455e3dd11f8e30bf9b3338056ee7b4fd69", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -49,7 +49,7 @@ struct InherentCollect<'tcx> {\n \n impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let ty = match item.node {\n+        let ty = match item.kind {\n             hir::ItemKind::Impl(.., None, ref ty, _) => ty,\n             _ => return\n         };"}, {"sha": "0aae8fbe131781862d2b9292cc9cae585d083332", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -84,7 +84,7 @@ impl InherentOverlapChecker<'tcx> {\n \n impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Enum(..) |\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Trait(..) |"}, {"sha": "667fa50a7cfa4c79a6953ef08b969a5feb893b0b", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -24,7 +24,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         // \"Trait\" impl\n-        if let hir::ItemKind::Impl(.., Some(_), _, _) = item.node {\n+        if let hir::ItemKind::Impl(.., Some(_), _, _) = item.kind {\n             debug!(\"coherence2::orphan check: trait impl {}\",\n                    self.tcx.hir().node_to_string(item.hir_id));\n             let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();"}, {"sha": "b7cc6feee4453eee521e79f823dea7b4ee002965", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -71,7 +71,7 @@ impl UnsafetyChecker<'tcx> {\n \n impl ItemLikeVisitor<'v> for UnsafetyChecker<'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n-        if let hir::ItemKind::Impl(unsafety, polarity, _, ref generics, ..) = item.node {\n+        if let hir::ItemKind::Impl(unsafety, polarity, _, ref generics, ..) = item.kind {\n             self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);\n         }\n     }"}, {"sha": "28c275e2d75abeca5684bffd38bc0477e3180e14", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -288,7 +288,7 @@ fn type_param_predicates(\n         Node::ImplItem(item) => &item.generics,\n \n         Node::Item(item) => {\n-            match item.node {\n+            match item.kind {\n                 ItemKind::Fn(.., ref generics, _)\n                 | ItemKind::Impl(_, _, _, ref generics, ..)\n                 | ItemKind::TyAlias(_, ref generics)\n@@ -403,7 +403,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n     let it = tcx.hir().expect_item(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id);\n     let def_id = tcx.hir().local_def_id(item_id);\n-    match it.node {\n+    match it.kind {\n         // These don't define types.\n         hir::ItemKind::ExternCrate(_)\n         | hir::ItemKind::Use(..)\n@@ -474,7 +474,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n-            if let hir::ItemKind::Fn(..) = it.node {\n+            if let hir::ItemKind::Fn(..) = it.kind {\n                 tcx.fn_sig(def_id);\n             }\n         }\n@@ -638,7 +638,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n     };\n \n     let repr = ReprOptions::new(tcx, def_id);\n-    let (kind, variants) = match item.node {\n+    let (kind, variants) = match item.kind {\n         ItemKind::Enum(ref def, _) => {\n             let mut distance_from_explicit = 0;\n             let variants = def.variants\n@@ -707,7 +707,7 @@ fn super_predicates_of(\n         _ => bug!(\"trait_node_id {} is not an item\", trait_hir_id),\n     };\n \n-    let (generics, bounds) = match item.node {\n+    let (generics, bounds) = match item.kind {\n         hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n         hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n         _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n@@ -753,7 +753,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TraitDef {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item(hir_id);\n \n-    let (is_auto, unsafety) = match item.node {\n+    let (is_auto, unsafety) = match item.kind {\n         hir::ItemKind::Trait(is_auto, unsafety, ..) => (is_auto == hir::IsAuto::Yes, unsafety),\n         hir::ItemKind::TraitAlias(..) => (false, hir::Unsafety::Normal),\n         _ => span_bug!(item.span, \"trait_def_of_item invoked on non-trait\"),\n@@ -878,7 +878,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n             }\n             _ => None,\n         },\n-        Node::Item(item) => match item.node {\n+        Node::Item(item) => match item.kind {\n             hir::ItemKind::Fn(ref fn_decl, .., ref generics, _) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n@@ -918,7 +918,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             kind: hir::ExprKind::Closure(..),\n             ..\n         }) => Some(tcx.closure_base_def_id(def_id)),\n-        Node::Item(item) => match item.node {\n+        Node::Item(item) => match item.kind {\n             ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => impl_trait_fn,\n             _ => None,\n         },\n@@ -935,7 +935,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n         Node::ImplItem(item) => &item.generics,\n \n         Node::Item(item) => {\n-            match item.node {\n+            match item.kind {\n                 ItemKind::Fn(.., ref generics, _) | ItemKind::Impl(_, _, _, ref generics, ..) => {\n                     generics\n                 }\n@@ -1265,7 +1265,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n         },\n \n         Node::Item(item) => {\n-            match item.node {\n+            match item.kind {\n                 ItemKind::Static(ref ty, .., body_id)\n                 | ItemKind::Const(ref ty, body_id) => {\n                     if let hir::TyKind::Infer = ty.kind {\n@@ -1325,7 +1325,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                     span_bug!(\n                         item.span,\n                         \"compute_type_of_item: unexpected item type: {:?}\",\n-                        item.node\n+                        item.kind\n                     );\n                 }\n             }\n@@ -1794,7 +1794,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             ..\n         })\n         | Item(hir::Item {\n-            node: ItemKind::Fn(decl, header, _, _),\n+            kind: ItemKind::Fn(decl, header, _, _),\n             ..\n         }) => match get_infer_ret_ty(&decl.output) {\n             Some(ty) => {\n@@ -1878,7 +1878,7 @@ fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    match tcx.hir().expect_item(hir_id).node {\n+    match tcx.hir().expect_item(hir_id).kind {\n         hir::ItemKind::Impl(.., ref opt_trait_ref, _, _) => {\n             opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 let selfty = tcx.type_of(def_id);\n@@ -1893,7 +1893,7 @@ fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let is_rustc_reservation = tcx.has_attr(def_id, sym::rustc_reservation_impl);\n     let item = tcx.hir().expect_item(hir_id);\n-    match &item.node {\n+    match &item.kind {\n         hir::ItemKind::Impl(_, hir::ImplPolarity::Negative, ..) => {\n             if is_rustc_reservation {\n                 tcx.sess.span_err(item.span, \"reservation impls can't be negative\");\n@@ -2076,7 +2076,7 @@ fn explicit_predicates_of(\n         },\n \n         Node::Item(item) => {\n-            match item.node {\n+            match item.kind {\n                 ItemKind::Impl(_, _, defaultness, ref generics, ..) => {\n                     if defaultness.is_default() {\n                         is_default_impl_trait = tcx.impl_trait_ref(def_id);\n@@ -2310,7 +2310,7 @@ fn explicit_predicates_of(\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n     if let Node::Item(&Item {\n-        node: ItemKind::Impl(..),\n+        kind: ItemKind::Impl(..),\n         ..\n     }) = node\n     {\n@@ -2417,7 +2417,7 @@ fn is_foreign_item(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n fn static_mutability(tcx: TyCtxt<'_>, def_id: DefId) -> Option<hir::Mutability> {\n     match tcx.hir().get_if_local(def_id) {\n         Some(Node::Item(&hir::Item {\n-            node: hir::ItemKind::Static(_, mutbl, _), ..\n+            kind: hir::ItemKind::Static(_, mutbl, _), ..\n         })) |\n         Some(Node::ForeignItem( &hir::ForeignItem {\n             node: hir::ForeignItemKind::Static(_, mutbl), .."}, {"sha": "ab660caa222ae800a49364888288c5ba4f29fbca", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -78,7 +78,7 @@ struct ImplWfCheck<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        if let hir::ItemKind::Impl(.., ref impl_item_refs) = item.node {\n+        if let hir::ItemKind::Impl(.., ref impl_item_refs) = item.kind {\n             let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             enforce_impl_params_are_constrained(self.tcx,\n                                                 impl_def_id,"}, {"sha": "00be1c84599a355563e2feb8b205eb3b302334e3", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -162,7 +162,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     match main_t.kind {\n         ty::FnDef(..) => {\n             if let Some(Node::Item(it)) = tcx.hir().find(main_id) {\n-                if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n+                if let hir::ItemKind::Fn(.., ref generics, _) = it.kind {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n                         let msg = \"`main` function is not allowed to have generic \\\n@@ -227,7 +227,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n     match start_t.kind {\n         ty::FnDef(..) => {\n             if let Some(Node::Item(it)) = tcx.hir().find(start_id) {\n-                if let hir::ItemKind::Fn(.., ref generics, _) = it.node {\n+                if let hir::ItemKind::Fn(.., ref generics, _) = it.kind {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n                         struct_span_err!(tcx.sess, generics.span, E0132,"}, {"sha": "433d04ffa64ff93ebe9f7e0dddfb16f6716092e6", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -66,7 +66,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n         };\n \n         let mut item_required_predicates = RequiredPredicates::default();\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Union(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Struct(..) => {\n                 let adt_def = self.tcx.adt_def(item_did);\n "}, {"sha": "cdb83eb328ac23ca27facfab41ac5b832d3b7b5c", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -30,7 +30,7 @@ fn inferred_outlives_of(\n         .expect(\"expected local def-id\");\n \n     match tcx.hir().get(id) {\n-        Node::Item(item) => match item.node {\n+        Node::Item(item) => match item.kind {\n             hir::ItemKind::Struct(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Union(..) => {\n                 let crate_map = tcx.inferred_outlives_crate(LOCAL_CRATE);\n "}, {"sha": "4dcb467e32b0139b41ec15984bd6aa9fcb22412b", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -68,7 +68,7 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 self.visit_node_helper(item.hir_id);"}, {"sha": "b3c0bee50f3c6fb40e44ee7091813f04eb13ea4c", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -49,7 +49,7 @@ fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n         span_bug!(tcx.hir().span(id), \"asked to compute variance for wrong kind of item\")\n     };\n     match tcx.hir().get(id) {\n-        Node::Item(item) => match item.node {\n+        Node::Item(item) => match item.kind {\n             hir::ItemKind::Enum(..) |\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Union(..) |"}, {"sha": "0489cd90c83c18f9a2841fc1d69efd5e13f24088", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n         debug!(\"add_inferreds for item {}\",\n                self.tcx.hir().node_to_string(item.hir_id));\n \n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 self.add_inferreds_for_item(item.hir_id);"}, {"sha": "532c5f67bf3baecf036ec5908acfba8f34e5efcb", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -333,7 +333,7 @@ pub fn build_impl(cx: &DocContext<'_>, did: DefId, attrs: Option<Attrs<'_>>,\n     }\n \n     let for_ = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-        match tcx.hir().expect_item(hir_id).node {\n+        match tcx.hir().expect_item(hir_id).kind {\n             hir::ItemKind::Impl(.., ref t, _) => {\n                 t.clean(cx)\n             }\n@@ -355,7 +355,7 @@ pub fn build_impl(cx: &DocContext<'_>, did: DefId, attrs: Option<Attrs<'_>>,\n \n     let predicates = tcx.explicit_predicates_of(did);\n     let (trait_items, generics) = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-        match tcx.hir().expect_item(hir_id).node {\n+        match tcx.hir().expect_item(hir_id).kind {\n             hir::ItemKind::Impl(.., ref gen, _, _, ref item_ids) => {\n                 (\n                     item_ids.iter()\n@@ -481,7 +481,7 @@ fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemE\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n     match cx.cstore.load_macro_untracked(did, cx.sess()) {\n         LoadedMacro::MacroDef(def) => {\n-            let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.node {\n+            let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.kind {\n                 let tts: Vec<_> = def.stream().into_trees().collect();\n                 tts.chunks(4).map(|arm| arm[0].span()).collect()\n             } else {"}, {"sha": "026a76f0894199f5a0928b175b145167ae8a0e17", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -275,7 +275,7 @@ impl Clean<ExternalCrate> for CrateNum {\n         let primitives = if root.is_local() {\n             cx.tcx.hir().krate().module.item_ids.iter().filter_map(|&id| {\n                 let item = cx.tcx.hir().expect_item(id.id);\n-                match item.node {\n+                match item.kind {\n                     hir::ItemKind::Mod(_) => {\n                         as_primitive(Res::Def(\n                             DefKind::Mod,\n@@ -319,7 +319,7 @@ impl Clean<ExternalCrate> for CrateNum {\n         let keywords = if root.is_local() {\n             cx.tcx.hir().krate().module.item_ids.iter().filter_map(|&id| {\n                 let item = cx.tcx.hir().expect_item(id.id);\n-                match item.node {\n+                match item.kind {\n                     hir::ItemKind::Mod(_) => {\n                         as_keyword(Res::Def(\n                             DefKind::Mod,\n@@ -2868,7 +2868,7 @@ impl Clean<Type> for hir::Ty {\n             TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n             TyKind::Def(item_id, _) => {\n                 let item = cx.tcx.hir().expect_item(item_id.id);\n-                if let hir::ItemKind::OpaqueTy(ref ty) = item.node {\n+                if let hir::ItemKind::OpaqueTy(ref ty) = item.kind {\n                     ImplTrait(ty.bounds.clean(cx))\n                 } else {\n                     unreachable!()\n@@ -2889,7 +2889,7 @@ impl Clean<Type> for hir::Ty {\n                     // Substitute private type aliases\n                     if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n                         if !cx.renderinfo.borrow().access_levels.is_exported(def_id) {\n-                            alias = Some(&cx.tcx.hir().expect_item(hir_id).node);\n+                            alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);\n                         }\n                     }\n                 };"}, {"sha": "6576165b6ce74ddd071e2fafa2987c7f6d2b5689", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -425,15 +425,15 @@ pub fn make_test(s: &str,\n             match parser.parse_item() {\n                 Ok(Some(item)) => {\n                     if !found_main {\n-                        if let ast::ItemKind::Fn(..) = item.node {\n+                        if let ast::ItemKind::Fn(..) = item.kind {\n                             if item.ident.name == sym::main {\n                                 found_main = true;\n                             }\n                         }\n                     }\n \n                     if !found_extern_crate {\n-                        if let ast::ItemKind::ExternCrate(original) = item.node {\n+                        if let ast::ItemKind::ExternCrate(original) = item.kind {\n                             // This code will never be reached if `cratename` is none because\n                             // `found_extern_crate` is initialized to `true` if it is none.\n                             let cratename = cratename.unwrap();\n@@ -446,7 +446,7 @@ pub fn make_test(s: &str,\n                     }\n \n                     if !found_macro {\n-                        if let ast::ItemKind::Mac(..) = item.node {\n+                        if let ast::ItemKind::Mac(..) = item.kind {\n                             found_macro = true;\n                         }\n                     }\n@@ -882,7 +882,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n     }\n \n     fn visit_item(&mut self, item: &'hir hir::Item) {\n-        let name = if let hir::ItemKind::Impl(.., ref ty, _) = item.node {\n+        let name = if let hir::ItemKind::Impl(.., ref ty, _) = item.kind {\n             self.map.hir_to_pretty_string(ty.hir_id)\n         } else {\n             item.ident.to_string()"}, {"sha": "8cf5fbe849f558be6ef964ab10b629a33e32c491", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -320,7 +320,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         if !self.view_item_stack.insert(res_hir_id) { return false }\n \n         let ret = match tcx.hir().get(res_hir_id) {\n-            Node::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n+            Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n                     let i = self.cx.tcx.hir().expect_item(i.id);\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             self.store_path(def_id);\n         }\n \n-        match item.node {\n+        match item.kind {\n             hir::ItemKind::ForeignMod(ref fm) => {\n                 for item in &fm.items {\n                     self.visit_foreign_item(item, None, om);"}, {"sha": "15b30352e4609967b7be959db40f2e0e1b224db8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -2269,7 +2269,7 @@ pub struct Item {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n-    pub node: ItemKind,\n+    pub kind: ItemKind,\n     pub vis: Visibility,\n     pub span: Span,\n "}, {"sha": "34b5b1e5b5c84ce9c657425b2a3f7ec8d235f871", "filename": "src/libsyntax/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fentry.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -13,7 +13,7 @@ pub enum EntryPointType {\n // Beware, this is duplicated in librustc/middle/entry.rs, make sure to keep\n // them in sync.\n pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n-    match item.node {\n+    match item.kind {\n         ItemKind::Fn(..) => {\n             if attr::contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start"}, {"sha": "54cfb80573e5c572d35bb3f045ce9eee3421713e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -222,7 +222,7 @@ impl Annotatable {\n \n     pub fn derive_allowed(&self) -> bool {\n         match *self {\n-            Annotatable::Item(ref item) => match item.node {\n+            Annotatable::Item(ref item) => match item.kind {\n                 ast::ItemKind::Struct(..) |\n                 ast::ItemKind::Enum(..) |\n                 ast::ItemKind::Union(..) => true,"}, {"sha": "6b93d045588b9242b62080aecb23cf6fc3704e3d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -567,14 +567,14 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn item(&self, span: Span, name: Ident,\n-            attrs: Vec<ast::Attribute>, node: ast::ItemKind) -> P<ast::Item> {\n+            attrs: Vec<ast::Attribute>, kind: ast::ItemKind) -> P<ast::Item> {\n         // FIXME: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n         P(ast::Item {\n             ident: name,\n             attrs,\n             id: ast::DUMMY_NODE_ID,\n-            node,\n+            kind,\n             vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n             span,\n             tokens: None,"}, {"sha": "bc073a667951fbd5ef5abcd0ebb65b041912102c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -293,15 +293,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let krate_item = AstFragment::Items(smallvec![P(ast::Item {\n             attrs: krate.attrs,\n             span: krate.span,\n-            node: ast::ItemKind::Mod(krate.module),\n+            kind: ast::ItemKind::Mod(krate.module),\n             ident: Ident::invalid(),\n             id: ast::DUMMY_NODE_ID,\n             vis: respan(krate.span.shrink_to_lo(), ast::VisibilityKind::Public),\n             tokens: None,\n         })]);\n \n         match self.fully_expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n-            Some(ast::Item { attrs, node: ast::ItemKind::Mod(module), .. }) => {\n+            Some(ast::Item { attrs, kind: ast::ItemKind::Mod(module), .. }) => {\n                 krate.attrs = attrs;\n                 krate.module = module;\n             },\n@@ -689,7 +689,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     fn gate_proc_macro_attr_item(&self, span: Span, item: &Annotatable) {\n         let (kind, gate) = match *item {\n             Annotatable::Item(ref item) => {\n-                match item.node {\n+                match item.kind {\n                     ItemKind::Mod(_) if self.cx.ecfg.proc_macro_hygiene() => return,\n                     ItemKind::Mod(_) => (\"modules\", sym::proc_macro_hygiene),\n                     _ => return,\n@@ -737,7 +737,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         impl<'ast, 'a> Visitor<'ast> for DisallowMacros<'a> {\n             fn visit_item(&mut self, i: &'ast ast::Item) {\n-                if let ast::ItemKind::MacroDef(_) = i.node {\n+                if let ast::ItemKind::MacroDef(_) = i.kind {\n                     emit_feature_err(\n                         self.parse_sess,\n                         sym::proc_macro_hygiene,\n@@ -1247,10 +1247,10 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                                      AstFragmentKind::Items, after_derive).make_items();\n         }\n \n-        match item.node {\n+        match item.kind {\n             ast::ItemKind::Mac(..) => {\n                 self.check_attributes(&item.attrs);\n-                item.and_then(|item| match item.node {\n+                item.and_then(|item| match item.kind {\n                     ItemKind::Mac(mac) => self.collect(\n                         AstFragmentKind::Items, InvocationKind::Bang { mac, span: item.span }\n                     ).make_items(),"}, {"sha": "aec4a683141203e7ba00102cb37a41fb94405192", "filename": "src/libsyntax/ext/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -302,7 +302,7 @@ pub fn compile_declarative_macro(\n     let tt_spec = ast::Ident::new(sym::tt, def.span);\n \n     // Parse the macro_rules! invocation\n-    let body = match def.node {\n+    let body = match def.kind {\n         ast::ItemKind::MacroDef(ref body) => body,\n         _ => unreachable!(),\n     };"}, {"sha": "a06de0f551795f42a2eb940c3a5e5be97f74024f", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -48,7 +48,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n         AstFragmentKind::OptExpr => AstFragment::OptExpr(Some(expr_placeholder())),\n         AstFragmentKind::Items => AstFragment::Items(smallvec![P(ast::Item {\n             id, span, ident, vis, attrs,\n-            node: ast::ItemKind::Mac(mac_placeholder()),\n+            kind: ast::ItemKind::Mac(mac_placeholder()),\n             tokens: None,\n         })]),\n         AstFragmentKind::TraitItems => AstFragment::TraitItems(smallvec![ast::TraitItem {\n@@ -251,7 +251,7 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n     }\n \n     fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n-        match item.node {\n+        match item.kind {\n             ast::ItemKind::Mac(_) => return self.remove(item.id).make_items(),\n             ast::ItemKind::MacroDef(_) => return smallvec![item],\n             _ => {}\n@@ -337,7 +337,7 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n \n     fn visit_mod(&mut self, module: &mut ast::Mod) {\n         noop_visit_mod(module, self);\n-        module.items.retain(|item| match item.node {\n+        module.items.retain(|item| match item.kind {\n             ast::ItemKind::Mac(_) if !self.cx.ecfg.keep_macs => false, // remove macro definitions\n             _ => true,\n         });"}, {"sha": "e17bbf79fd5e064d1d6e2278080c5cc7422f4564", "filename": "src/libsyntax/ext/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -107,7 +107,7 @@ impl MultiItemModifier for ProcMacroDerive {\n                 return Vec::new()\n             }\n         };\n-        match item.node {\n+        match item.kind {\n             ItemKind::Struct(..) |\n             ItemKind::Enum(..) |\n             ItemKind::Union(..) => {},"}, {"sha": "2ed4404fb3ce68b0b831653dba7f2096598934a2", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -302,7 +302,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_item(&mut self, i: &'a ast::Item) {\n-        match i.node {\n+        match i.kind {\n             ast::ItemKind::ForeignMod(ref foreign_module) => {\n                 self.check_abi(foreign_module.abi, i.span);\n             }"}, {"sha": "c448aa980c61b177606f55754d0962de14e6fbe5", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -994,7 +994,7 @@ pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n             id: DUMMY_NODE_ID,\n             vis: respan(span.shrink_to_lo(), VisibilityKind::Public),\n             span,\n-            node: ItemKind::Mod(module),\n+            kind: ItemKind::Mod(module),\n             tokens: None,\n         });\n         let items = vis.flat_map_item(item);\n@@ -1004,8 +1004,8 @@ pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n             let module = Mod { inner: span, items: vec![], inline: true };\n             Crate { module, attrs: vec![], span }\n         } else if len == 1 {\n-            let Item { attrs, span, node, .. } = items.into_iter().next().unwrap().into_inner();\n-            match node {\n+            let Item { attrs, span, kind, .. } = items.into_iter().next().unwrap().into_inner();\n+            match kind {\n                 ItemKind::Mod(module) => Crate { module, attrs, span },\n                 _ => panic!(\"visitor converted a module to not a module\"),\n             }\n@@ -1018,11 +1018,11 @@ pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n // Mutates one item into possibly many items.\n pub fn noop_flat_map_item<T: MutVisitor>(mut item: P<Item>, visitor: &mut T)\n                                          -> SmallVec<[P<Item>; 1]> {\n-    let Item { ident, attrs, id, node, vis, span, tokens: _ } = item.deref_mut();\n+    let Item { ident, attrs, id, kind, vis, span, tokens: _ } = item.deref_mut();\n     visitor.visit_ident(ident);\n     visit_attrs(attrs, visitor);\n     visitor.visit_id(id);\n-    visitor.visit_item_kind(node);\n+    visitor.visit_item_kind(kind);\n     visitor.visit_vis(vis);\n     visitor.visit_span(span);\n "}, {"sha": "ec5d00e0952d79925c18b2b3ad3619cdc87fce66", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -761,7 +761,7 @@ impl<'a> Parser<'a> {\n             );\n             if !items.is_empty() {\n                 let previous_item = &items[items.len() - 1];\n-                let previous_item_kind_name = match previous_item.node {\n+                let previous_item_kind_name = match previous_item.kind {\n                     // Say \"braced struct\" because tuple-structs and\n                     // braceless-empty-struct declarations do take a semicolon.\n                     ItemKind::Struct(..) => Some(\"braced struct\"),"}, {"sha": "83721a2866aad4a65df35ed2719bd383434a5d65", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -1949,13 +1949,13 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn mk_item(&self, span: Span, ident: Ident, node: ItemKind, vis: Visibility,\n+    fn mk_item(&self, span: Span, ident: Ident, kind: ItemKind, vis: Visibility,\n                attrs: Vec<Attribute>) -> P<Item> {\n         P(Item {\n             ident,\n             attrs,\n             id: DUMMY_NODE_ID,\n-            node,\n+            kind,\n             vis,\n             span,\n             tokens: None,"}, {"sha": "3bdb9227b4edd1cfa853a09bf7ede2024c10068f", "filename": "src/libsyntax/parse/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftests.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -299,7 +299,7 @@ fn out_of_line_mod() {\n             &sess,\n         ).unwrap().unwrap();\n \n-        if let ast::ItemKind::Mod(ref m) = item.node {\n+        if let ast::ItemKind::Mod(ref m) = item.kind {\n             assert!(m.items.len() == 2);\n         } else {\n             panic!();"}, {"sha": "675490552e59c03bda37b8c448a51576bfe41c41", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -1142,7 +1142,7 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(&item.attrs);\n         self.ann.pre(self, AnnNode::Item(item));\n-        match item.node {\n+        match item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 self.head(visibility_qualified(&item.vis, \"extern crate\"));\n                 if let Some(orig_name) = orig_name {"}, {"sha": "ea6d27d4f29f59fb8f82b81c14a1eaae8b0686ff", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -230,7 +230,7 @@ pub fn walk_trait_ref<'a, V: Visitor<'a>>(visitor: &mut V, trait_ref: &'a TraitR\n pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.ident);\n-    match item.node {\n+    match item.kind {\n         ItemKind::ExternCrate(orig_name) => {\n             if let Some(orig_name) = orig_name {\n                 visitor.visit_name(item.span, orig_name);"}, {"sha": "9ef2c033b0784a43baaf766d7e478684a42b115c", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -32,7 +32,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n     let is_shallow;\n     match *item {\n         Annotatable::Item(ref annitem) => {\n-            match annitem.node {\n+            match annitem.kind {\n                 ItemKind::Struct(_, Generics { ref params, .. }) |\n                 ItemKind::Enum(_, Generics { ref params, .. }) => {\n                     let container_id = cx.current_expansion.id.expn_data().parent;"}, {"sha": "9f75f72e820f25c8b84d58b634ea3245a3117a66", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -409,7 +409,7 @@ impl<'a> TraitDef<'a> {\n                     }\n                     false\n                 });\n-                let has_no_type_params = match item.node {\n+                let has_no_type_params = match item.kind {\n                     ast::ItemKind::Struct(_, ref generics) |\n                     ast::ItemKind::Enum(_, ref generics) |\n                     ast::ItemKind::Union(_, ref generics) => {\n@@ -431,7 +431,7 @@ impl<'a> TraitDef<'a> {\n                     has_no_type_params;\n                 let use_temporaries = is_packed && is_always_copy;\n \n-                let newitem = match item.node {\n+                let newitem = match item.kind {\n                     ast::ItemKind::Struct(ref struct_def, ref generics) => {\n                         self.expand_struct_def(cx, &struct_def, item.ident, generics, from_scratch,\n                                                use_temporaries)\n@@ -1780,7 +1780,7 @@ pub fn cs_fold1<F, B>(use_foldl: bool,\n /// (for an enum, no variant has any fields)\n pub fn is_type_without_fields(item: &Annotatable) -> bool {\n     if let Annotatable::Item(ref item) = *item {\n-        match item.node {\n+        match item.kind {\n             ast::ItemKind::Enum(ref enum_def, _) => {\n                 enum_def.variants.iter().all(|v| v.data.fields().is_empty())\n             }"}, {"sha": "cd2a9b61a76df395505dc7004f95e12cd08aac0b", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -20,7 +20,7 @@ pub fn expand(\n         vec![item]\n     };\n     let item = match item {\n-        Annotatable::Item(item) => match item.node {\n+        Annotatable::Item(item) => match item.kind {\n             ItemKind::Static(..) => item,\n             _ => return not_static(Annotatable::Item(item)),\n         }"}, {"sha": "72fb5b47c215401af843ceed2bbe527698082e39", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -28,7 +28,7 @@ pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                 ident: ast::Ident::invalid(),\n                 attrs: Vec::new(),\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::ItemKind::GlobalAsm(P(global_asm)),\n+                kind: ast::ItemKind::GlobalAsm(P(global_asm)),\n                 vis: respan(sp.shrink_to_lo(), ast::VisibilityKind::Inherited),\n                 span: cx.with_def_site_ctxt(sp),\n                 tokens: None,"}, {"sha": "315babceae32ce5a9844bac4183738d09f48cbb9", "filename": "src/libsyntax_ext/plugin_macro_defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -28,7 +28,7 @@ fn plugin_macro_def(name: Name, span: Span) -> P<Item> {\n         ident: Ident::new(name, span),\n         attrs: vec![rustc_builtin_macro],\n         id: DUMMY_NODE_ID,\n-        node: ItemKind::MacroDef(MacroDef { tokens: TokenStream::new(trees), legacy: true }),\n+        kind: ItemKind::MacroDef(MacroDef { tokens: TokenStream::new(trees), legacy: true }),\n         vis: respan(span, VisibilityKind::Inherited),\n         span: span,\n         tokens: None,"}, {"sha": "9b53bcb841c67893b384dab42a85cc6b5ebd2252", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -226,7 +226,7 @@ impl<'a> CollectProcMacros<'a> {\n \n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n-        if let ast::ItemKind::MacroDef(..) = item.node {\n+        if let ast::ItemKind::MacroDef(..) = item.kind {\n             if self.is_proc_macro_crate && attr::contains_name(&item.attrs, sym::macro_export) {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n@@ -238,7 +238,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         // we're just not interested in this item.\n         //\n         // If we find one, try to locate a `#[proc_macro_derive]` attribute on it.\n-        let is_fn = match item.node {\n+        let is_fn = match item.kind {\n             ast::ItemKind::Fn(..) => true,\n             _ => false,\n         };"}, {"sha": "5d68a92579f96cf7c0af3074ad682955a32943a0", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -78,7 +78,7 @@ pub fn expand_test_or_bench(\n                 \"`#[test]` attribute is only allowed on non associated functions\").raise();\n         };\n \n-    if let ast::ItemKind::Mac(_) = item.node {\n+    if let ast::ItemKind::Mac(_) = item.kind {\n         cx.parse_sess.span_diagnostic.span_warn(item.span,\n             \"`#[test]` attribute should not be used on macros. Use `#[cfg(test)]` instead.\");\n         return vec![Annotatable::Item(item)];\n@@ -264,7 +264,7 @@ fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n     let has_should_panic_attr = attr::contains_name(&i.attrs, sym::should_panic);\n     let ref sd = cx.parse_sess.span_diagnostic;\n-    if let ast::ItemKind::Fn(ref decl, ref header, ref generics, _) = i.node {\n+    if let ast::ItemKind::Fn(ref decl, ref header, ref generics, _) = i.kind {\n         if header.unsafety == ast::Unsafety::Unsafe {\n             sd.span_err(\n                 i.span,\n@@ -315,7 +315,7 @@ fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n }\n \n fn has_bench_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n-    let has_sig = if let ast::ItemKind::Fn(ref decl, _, _, _) = i.node {\n+    let has_sig = if let ast::ItemKind::Fn(ref decl, _, _, _) = i.kind {\n         // N.B., inadequate check, but we're running\n         // well before resolve, can't get too deep.\n         decl.inputs.len() == 1"}, {"sha": "fc1daa7d9b22ad54b50dd0189758e5efc5d2c3ed", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc94cc3c2ccef8b4d393910bb978a6487db1202/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=7bc94cc3c2ccef8b4d393910bb978a6487db1202", "patch": "@@ -85,7 +85,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n-        if let ast::ItemKind::Mod(mut module) = item.node {\n+        if let ast::ItemKind::Mod(mut module) = item.kind {\n             let tests = mem::take(&mut self.tests);\n             noop_visit_mod(&mut module, self);\n             let mut tests = mem::replace(&mut self.tests, tests);\n@@ -111,7 +111,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n                 }\n                 self.cx.test_cases.extend(tests);\n             }\n-            item.node = ast::ItemKind::Mod(module);\n+            item.kind = ast::ItemKind::Mod(module);\n         }\n         smallvec![P(item)]\n     }\n@@ -142,7 +142,7 @@ impl MutVisitor for EntryPointCleaner {\n             EntryPointType::MainNamed |\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n-                item.map(|ast::Item {id, ident, attrs, node, vis, span, tokens}| {\n+                item.map(|ast::Item {id, ident, attrs, kind, vis, span, tokens}| {\n                     let allow_ident = Ident::new(sym::allow, self.def_site);\n                     let dc_nested = attr::mk_nested_word_item(\n                         Ident::from_str_and_span(\"dead_code\", self.def_site),\n@@ -159,7 +159,7 @@ impl MutVisitor for EntryPointCleaner {\n                             })\n                             .chain(iter::once(allow_dead_code))\n                             .collect(),\n-                        node,\n+                        kind,\n                         vis,\n                         span,\n                         tokens,\n@@ -295,7 +295,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n         ident: main_id,\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n-        node: main,\n+        kind: main,\n         vis: respan(sp, ast::VisibilityKind::Public),\n         span: sp,\n         tokens: None,"}]}