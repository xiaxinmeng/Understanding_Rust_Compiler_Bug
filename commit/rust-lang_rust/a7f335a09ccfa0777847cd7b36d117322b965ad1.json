{"sha": "a7f335a09ccfa0777847cd7b36d117322b965ad1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZjMzNWEwOWNjZmEwNzc3ODQ3Y2Q3YjM2ZDExNzMyMmI5NjVhZDE=", "commit": {"author": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-06-30T15:25:11Z"}, "committer": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-07-02T19:36:02Z"}, "message": "collections::bitv: replace internal iterators with external ones", "tree": {"sha": "8b3f79ad468533ff2482ed8d00f1c7a6efe99cad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b3f79ad468533ff2482ed8d00f1c7a6efe99cad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7f335a09ccfa0777847cd7b36d117322b965ad1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f335a09ccfa0777847cd7b36d117322b965ad1", "html_url": "https://github.com/rust-lang/rust/commit/a7f335a09ccfa0777847cd7b36d117322b965ad1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7f335a09ccfa0777847cd7b36d117322b965ad1/comments", "author": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da0d4be378d289e9e90a48deec674d42205ae4c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/da0d4be378d289e9e90a48deec674d42205ae4c9", "html_url": "https://github.com/rust-lang/rust/commit/da0d4be378d289e9e90a48deec674d42205ae4c9"}], "stats": {"total": 142, "additions": 88, "deletions": 54}, "files": [{"sha": "7dd4535f205391228dfdf558d343e636f7de3064", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 88, "deletions": 54, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/a7f335a09ccfa0777847cd7b36d117322b965ad1/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f335a09ccfa0777847cd7b36d117322b965ad1/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=a7f335a09ccfa0777847cd7b36d117322b965ad1", "patch": "@@ -15,7 +15,7 @@ use core::prelude::*;\n use core::cmp;\n use core::default::Default;\n use core::fmt;\n-use core::iter::{Map, Zip};\n+use core::iter::{Map, Take, Zip};\n use core::ops;\n use core::slice;\n use core::uint;\n@@ -382,21 +382,6 @@ impl cmp::PartialEq for Bitv {\n \n impl cmp::Eq for Bitv {}\n \n-#[inline]\n-fn iterate_bits(base: uint, bits: uint, f: |uint| -> bool) -> bool {\n-    if bits == 0 {\n-        return true;\n-    }\n-    for i in range(0u, uint::BITS) {\n-        if bits & (1 << i) != 0 {\n-            if !f(base + i) {\n-                return false;\n-            }\n-        }\n-    }\n-    return true;\n-}\n-\n /// An iterator for `Bitv`.\n pub struct Bits<'a> {\n     bitv: &'a Bitv,\n@@ -553,39 +538,45 @@ impl BitvSet {\n         BitPositions {set: self, next_idx: 0}\n     }\n \n-    pub fn difference(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n-        for (i, w1, w2) in self.commons(other) {\n-            if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n-                return false\n-            }\n-        };\n-        /* everything we have that they don't also shows up */\n-        self.outliers(other).advance(|(mine, i, w)|\n-            !mine || iterate_bits(i, w, |b| f(&b))\n-        )\n-    }\n-\n-    pub fn symmetric_difference(&self, other: &BitvSet, f: |&uint| -> bool)\n-                                -> bool {\n-        for (i, w1, w2) in self.commons(other) {\n-            if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n-                return false\n-            }\n-        };\n-        self.outliers(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n+    pub fn difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+        TwoBitPositions {\n+            set: self,\n+            other: other,\n+            merge: |w1, w2| w1 & !w2,\n+            current_word: 0,\n+            next_idx: 0\n+        }\n     }\n \n-    pub fn intersection(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n-        self.commons(other).advance(|(i, w1, w2)| iterate_bits(i, w1 & w2, |b| f(&b)))\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+        TwoBitPositions {\n+            set: self,\n+            other: other,\n+            merge: |w1, w2| w1 ^ w2,\n+            current_word: 0,\n+            next_idx: 0\n+        }\n     }\n \n-    pub fn union(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n-        for (i, w1, w2) in self.commons(other) {\n-            if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n-                return false\n-            }\n-        };\n-        self.outliers(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n+    pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Take<TwoBitPositions<'a>> {\n+        let min = cmp::min(self.capacity(), other.capacity());\n+        TwoBitPositions {\n+            set: self,\n+            other: other,\n+            merge: |w1, w2| w1 & w2,\n+            current_word: 0,\n+            next_idx: 0\n+        }.take(min)\n+    }\n+\n+    pub fn union<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+        TwoBitPositions {\n+            set: self,\n+            other: other,\n+            merge: |w1, w2| w1 | w2,\n+            current_word: 0,\n+            next_idx: 0\n+        }\n     }\n }\n \n@@ -634,7 +625,7 @@ impl Set<uint> for BitvSet {\n     }\n \n     fn is_disjoint(&self, other: &BitvSet) -> bool {\n-        self.intersection(other, |_| false)\n+        self.intersection(other).count() > 0\n     }\n \n     fn is_subset(&self, other: &BitvSet) -> bool {\n@@ -737,6 +728,14 @@ pub struct BitPositions<'a> {\n     next_idx: uint\n }\n \n+pub struct TwoBitPositions<'a> {\n+    set: &'a BitvSet,\n+    other: &'a BitvSet,\n+    merge: |uint, uint|: 'a -> uint,\n+    current_word: uint,\n+    next_idx: uint\n+}\n+\n impl<'a> Iterator<uint> for BitPositions<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<uint> {\n@@ -757,6 +756,41 @@ impl<'a> Iterator<uint> for BitPositions<'a> {\n     }\n }\n \n+impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<uint> {\n+        while self.next_idx < self.set.capacity() ||\n+              self.next_idx < self.other.capacity() {\n+            let bit_idx = self.next_idx % uint::BITS;\n+            if bit_idx == 0 {\n+                let &BitvSet(ref s_bitv) = self.set;\n+                let &BitvSet(ref o_bitv) = self.other;\n+                // Merging the two words is a bit of an awkward dance since\n+                // one Bitv might be longer than the other\n+                let word_idx = self.next_idx / uint::BITS;\n+                let w1 = if word_idx < s_bitv.storage.len() {\n+                             *s_bitv.storage.get(word_idx)\n+                         } else { 0 };\n+                let w2 = if word_idx < o_bitv.storage.len() {\n+                             *o_bitv.storage.get(word_idx)\n+                         } else { 0 };\n+                self.current_word = (self.merge)(w1, w2);\n+            }\n+\n+            self.next_idx += 1;\n+            if self.current_word & (1 << bit_idx) != 0 {\n+                return Some(self.next_idx - 1);\n+            }\n+        }\n+        return None;\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let cap = cmp::max(self.set.capacity(), self.other.capacity());\n+        (0, Some(cap - self.next_idx))\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::prelude::*;\n@@ -1274,8 +1308,8 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n-        a.intersection(&b, |x| {\n-            assert_eq!(*x, expected[i]);\n+        a.intersection(&b).advance(|x| {\n+            assert_eq!(x, expected[i]);\n             i += 1;\n             true\n         });\n@@ -1298,8 +1332,8 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 5, 500];\n-        a.difference(&b, |x| {\n-            assert_eq!(*x, expected[i]);\n+        a.difference(&b).advance(|x| {\n+            assert_eq!(x, expected[i]);\n             i += 1;\n             true\n         });\n@@ -1324,8 +1358,8 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 5, 11, 14, 220];\n-        a.symmetric_difference(&b, |x| {\n-            assert_eq!(*x, expected[i]);\n+        a.symmetric_difference(&b).advance(|x| {\n+            assert_eq!(x, expected[i]);\n             i += 1;\n             true\n         });\n@@ -1353,8 +1387,8 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160];\n-        a.union(&b, |x| {\n-            assert_eq!(*x, expected[i]);\n+        a.union(&b).advance(|x| {\n+            assert_eq!(x, expected[i]);\n             i += 1;\n             true\n         });"}]}