{"sha": "0f7c75b74fb7adc436eedc66c0032879293eeac6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmN2M3NWI3NGZiN2FkYzQzNmVlZGM2NmMwMDMyODc5MjkzZWVhYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-22T09:29:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-22T09:29:46Z"}, "message": "Auto merge of #37834 - bluss:peek-none, r=BurntSushi\n\nMake Peekable remember peeking a None\n\nPeekable should remember if a None has been seen in the `.peek()` method.\nIt ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the\nunderlying iterator at most once. This does not by itself make the iterator\nfused.\n\nThanks to @s3bk for the code in `fn peek()` itself.\n\nFixes #37784", "tree": {"sha": "2b34cfc1fa6076cbe90a38091e4ba478f92117d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b34cfc1fa6076cbe90a38091e4ba478f92117d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f7c75b74fb7adc436eedc66c0032879293eeac6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f7c75b74fb7adc436eedc66c0032879293eeac6", "html_url": "https://github.com/rust-lang/rust/commit/0f7c75b74fb7adc436eedc66c0032879293eeac6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f7c75b74fb7adc436eedc66c0032879293eeac6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "html_url": "https://github.com/rust-lang/rust/commit/1c11ea3aedebac562f5125e1cf22ac56a3a8993c"}, {"sha": "6c2a456bf198e7853f570435fc78bbd99c51b9d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c2a456bf198e7853f570435fc78bbd99c51b9d6", "html_url": "https://github.com/rust-lang/rust/commit/6c2a456bf198e7853f570435fc78bbd99c51b9d6"}], "stats": {"total": 132, "additions": 109, "deletions": 23}, "files": [{"sha": "02a2e370547e9f147e038e871d4e619be0d14189", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0f7c75b74fb7adc436eedc66c0032879293eeac6/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7c75b74fb7adc436eedc66c0032879293eeac6/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=0f7c75b74fb7adc436eedc66c0032879293eeac6", "patch": "@@ -1273,54 +1273,68 @@ unsafe impl<I> TrustedLen for Enumerate<I>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Peekable<I: Iterator> {\n     iter: I,\n-    peeked: Option<I::Item>,\n+    /// Remember a peeked value, even if it was None.\n+    peeked: Option<Option<I::Item>>,\n }\n \n+// Peekable must remember if a None has been seen in the `.peek()` method.\n+// It ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the\n+// underlying iterator at most once. This does not by itself make the iterator\n+// fused.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator> Iterator for Peekable<I> {\n     type Item = I::Item;\n \n     #[inline]\n     fn next(&mut self) -> Option<I::Item> {\n-        match self.peeked {\n-            Some(_) => self.peeked.take(),\n+        match self.peeked.take() {\n+            Some(v) => v,\n             None => self.iter.next(),\n         }\n     }\n \n     #[inline]\n     #[rustc_inherit_overflow_checks]\n-    fn count(self) -> usize {\n-        (if self.peeked.is_some() { 1 } else { 0 }) + self.iter.count()\n+    fn count(mut self) -> usize {\n+        match self.peeked.take() {\n+            Some(None) => 0,\n+            Some(Some(_)) => 1 + self.iter.count(),\n+            None => self.iter.count(),\n+        }\n     }\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        match self.peeked {\n-            Some(_) if n == 0 => self.peeked.take(),\n-            Some(_) => {\n-                self.peeked = None;\n-                self.iter.nth(n-1)\n-            },\n-            None => self.iter.nth(n)\n+        match self.peeked.take() {\n+            // the .take() below is just to avoid \"move into pattern guard\"\n+            Some(ref mut v) if n == 0 => v.take(),\n+            Some(None) => None,\n+            Some(Some(_)) => self.iter.nth(n - 1),\n+            None => self.iter.nth(n),\n         }\n     }\n \n     #[inline]\n-    fn last(self) -> Option<I::Item> {\n-        self.iter.last().or(self.peeked)\n+    fn last(mut self) -> Option<I::Item> {\n+        let peek_opt = match self.peeked.take() {\n+            Some(None) => return None,\n+            Some(v) => v,\n+            None => None,\n+        };\n+        self.iter.last().or(peek_opt)\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n+        let peek_len = match self.peeked {\n+            Some(None) => return (0, Some(0)),\n+            Some(Some(_)) => 1,\n+            None => 0,\n+        };\n         let (lo, hi) = self.iter.size_hint();\n-        if self.peeked.is_some() {\n-            let lo = lo.saturating_add(1);\n-            let hi = hi.and_then(|x| x.checked_add(1));\n-            (lo, hi)\n-        } else {\n-            (lo, hi)\n-        }\n+        let lo = lo.saturating_add(peek_len);\n+        let hi = hi.and_then(|x| x.checked_add(peek_len));\n+        (lo, hi)\n     }\n }\n \n@@ -1372,9 +1386,13 @@ impl<I: Iterator> Peekable<I> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&mut self) -> Option<&I::Item> {\n         if self.peeked.is_none() {\n-            self.peeked = self.iter.next();\n+            self.peeked = Some(self.iter.next());\n+        }\n+        match self.peeked {\n+            Some(Some(ref value)) => Some(value),\n+            Some(None) => None,\n+            _ => unreachable!(),\n         }\n-        self.peeked.as_ref()\n     }\n }\n "}, {"sha": "274539dfa6699ff2ae4be624b0d717fbdf769fd5", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0f7c75b74fb7adc436eedc66c0032879293eeac6/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7c75b74fb7adc436eedc66c0032879293eeac6/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=0f7c75b74fb7adc436eedc66c0032879293eeac6", "patch": "@@ -274,6 +274,74 @@ fn test_iterator_peekable_last() {\n     let mut it = ys.iter().peekable();\n     assert_eq!(it.peek(), Some(&&0));\n     assert_eq!(it.last(), Some(&0));\n+\n+    let mut it = ys.iter().peekable();\n+    assert_eq!(it.next(), Some(&0));\n+    assert_eq!(it.peek(), None);\n+    assert_eq!(it.last(), None);\n+}\n+\n+/// This is an iterator that follows the Iterator contract,\n+/// but it is not fused. After having returned None once, it will start\n+/// producing elements if .next() is called again.\n+pub struct CycleIter<'a, T: 'a> {\n+    index: usize,\n+    data: &'a [T],\n+}\n+\n+pub fn cycle<T>(data: &[T]) -> CycleIter<T> {\n+    CycleIter {\n+        index: 0,\n+        data: data,\n+    }\n+}\n+\n+impl<'a, T> Iterator for CycleIter<'a, T> {\n+    type Item = &'a T;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let elt = self.data.get(self.index);\n+        self.index += 1;\n+        self.index %= 1 + self.data.len();\n+        elt\n+    }\n+}\n+\n+#[test]\n+fn test_iterator_peekable_remember_peek_none_1() {\n+    // Check that the loop using .peek() terminates\n+    let data = [1, 2, 3];\n+    let mut iter = cycle(&data).peekable();\n+\n+    let mut n = 0;\n+    while let Some(_) = iter.next() {\n+        let is_the_last = iter.peek().is_none();\n+        assert_eq!(is_the_last, n == data.len() - 1);\n+        n += 1;\n+        if n > data.len() { break; }\n+    }\n+    assert_eq!(n, data.len());\n+}\n+\n+#[test]\n+fn test_iterator_peekable_remember_peek_none_2() {\n+    let data = [0];\n+    let mut iter = cycle(&data).peekable();\n+    iter.next();\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.last(), None);\n+}\n+\n+#[test]\n+fn test_iterator_peekable_remember_peek_none_3() {\n+    let data = [0];\n+    let mut iter = cycle(&data).peekable();\n+    iter.peek();\n+    assert_eq!(iter.nth(0), Some(&0));\n+\n+    let mut iter = cycle(&data).peekable();\n+    iter.next();\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.nth(0), None);\n }\n \n #[test]"}]}