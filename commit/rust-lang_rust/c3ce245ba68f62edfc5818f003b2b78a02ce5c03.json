{"sha": "c3ce245ba68f62edfc5818f003b2b78a02ce5c03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzY2UyNDViYTY4ZjYyZWRmYzU4MThmMDAzYjJiNzhhMDJjZTVjMDM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-08-01T15:11:53Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-08-13T15:40:15Z"}, "message": "quote_expr macro: embed Ident using special encoding that preserves hygiene.\n\nThis adds support to `quote_expr!` and friends for round-trip hygienic\npreservation of Ident.\n\nHere are the pieces of the puzzle:\n\n* adding a method for encoding Ident for re-reading into token tree.\n\n* Support for reading such encoded Idents in the lexer.  Note that one\n  must peek ahead for MOD_SEP after scan_embedded_hygienic_ident.\n\n* To ensure that encoded Idents are only read when we are in the midst\n  of expanding a `quote_expr` or similar, added a\n  `read_embedded_ident` flag on `StringReader`.\n\n* pprust support for encoding Ident's as (uint,uint) pairs (for hygiene).", "tree": {"sha": "0be1530cc0bd24d38a1f8f9d80d196e75be26a60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0be1530cc0bd24d38a1f8f9d80d196e75be26a60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3ce245ba68f62edfc5818f003b2b78a02ce5c03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ce245ba68f62edfc5818f003b2b78a02ce5c03", "html_url": "https://github.com/rust-lang/rust/commit/c3ce245ba68f62edfc5818f003b2b78a02ce5c03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3ce245ba68f62edfc5818f003b2b78a02ce5c03/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d554212de0398ac044e6d815da3bfb184831e77", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d554212de0398ac044e6d815da3bfb184831e77", "html_url": "https://github.com/rust-lang/rust/commit/9d554212de0398ac044e6d815da3bfb184831e77"}], "stats": {"total": 376, "additions": 345, "deletions": 31}, "files": [{"sha": "0ea57e41b0ffc0d0fc9dbd290f91ce5717f617ec", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c3ce245ba68f62edfc5818f003b2b78a02ce5c03/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ce245ba68f62edfc5818f003b2b78a02ce5c03/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c3ce245ba68f62edfc5818f003b2b78a02ce5c03", "patch": "@@ -55,6 +55,12 @@ impl Ident {\n     pub fn as_str<'a>(&'a self) -> &'a str {\n         self.name.as_str()\n     }\n+\n+    pub fn encode_with_hygiene(&self) -> String {\n+        format!(\"\\x00name_{:u},ctxt_{:u}\\x00\",\n+                self.name.uint(),\n+                self.ctxt)\n+    }\n }\n \n impl Show for Ident {"}, {"sha": "d7d6c20b475a688a2bebc48a57100fcc2124db19", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 96, "deletions": 3, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c3ce245ba68f62edfc5818f003b2b78a02ce5c03/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ce245ba68f62edfc5818f003b2b78a02ce5c03/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=c3ce245ba68f62edfc5818f003b2b78a02ce5c03", "patch": "@@ -97,20 +97,39 @@ pub mod rt {\n         fn to_source(&self) -> String;\n     }\n \n+    // FIXME (Issue #16472): This should go away after ToToken impls\n+    // are revised to go directly to token-trees.\n+    trait ToSourceWithHygiene : ToSource {\n+        // Takes a thing and generates a string containing rust code\n+        // for it, encoding Idents as special byte sequences to\n+        // maintain hygiene across serialization and deserialization.\n+        fn to_source_with_hygiene(&self) -> String;\n+    }\n+\n     macro_rules! impl_to_source(\n         (Gc<$t:ty>, $pp:ident) => (\n             impl ToSource for Gc<$t> {\n                 fn to_source(&self) -> String {\n                     pprust::$pp(&**self)\n                 }\n             }\n+            impl ToSourceWithHygiene for Gc<$t> {\n+                fn to_source_with_hygiene(&self) -> String {\n+                    pprust::with_hygiene::$pp(&**self)\n+                }\n+            }\n         );\n         ($t:ty, $pp:ident) => (\n             impl ToSource for $t {\n                 fn to_source(&self) -> String {\n                     pprust::$pp(self)\n                 }\n             }\n+            impl ToSourceWithHygiene for $t {\n+                fn to_source_with_hygiene(&self) -> String {\n+                    pprust::with_hygiene::$pp(self)\n+                }\n+            }\n         );\n     )\n \n@@ -122,13 +141,28 @@ pub mod rt {\n             .to_string()\n     }\n \n+    fn slice_to_source_with_hygiene<'a, T: ToSourceWithHygiene>(\n+        sep: &'static str, xs: &'a [T]) -> String {\n+        xs.iter()\n+            .map(|i| i.to_source_with_hygiene())\n+            .collect::<Vec<String>>()\n+            .connect(sep)\n+            .to_string()\n+    }\n+\n     macro_rules! impl_to_source_slice(\n         ($t:ty, $sep:expr) => (\n             impl<'a> ToSource for &'a [$t] {\n                 fn to_source(&self) -> String {\n                     slice_to_source($sep, *self)\n                 }\n             }\n+\n+            impl<'a> ToSourceWithHygiene for &'a [$t] {\n+                fn to_source_with_hygiene(&self) -> String {\n+                    slice_to_source_with_hygiene($sep, *self)\n+                }\n+            }\n         )\n     )\n \n@@ -138,6 +172,12 @@ pub mod rt {\n         }\n     }\n \n+    impl ToSourceWithHygiene for ast::Ident {\n+        fn to_source_with_hygiene(&self) -> String {\n+            self.encode_with_hygiene()\n+        }\n+    }\n+\n     impl_to_source!(ast::Ty, ty_to_string)\n     impl_to_source!(ast::Block, block_to_string)\n     impl_to_source!(ast::Arg, arg_to_string)\n@@ -156,6 +196,11 @@ pub mod rt {\n             pprust::attribute_to_string(&dummy_spanned(*self))\n         }\n     }\n+    impl ToSourceWithHygiene for ast::Attribute_ {\n+        fn to_source_with_hygiene(&self) -> String {\n+            self.to_source()\n+        }\n+    }\n \n     impl<'a> ToSource for &'a str {\n         fn to_source(&self) -> String {\n@@ -164,26 +209,46 @@ pub mod rt {\n             pprust::lit_to_string(&lit)\n         }\n     }\n+    impl<'a> ToSourceWithHygiene for &'a str {\n+        fn to_source_with_hygiene(&self) -> String {\n+            self.to_source()\n+        }\n+    }\n \n     impl ToSource for () {\n         fn to_source(&self) -> String {\n             \"()\".to_string()\n         }\n     }\n+    impl ToSourceWithHygiene for () {\n+        fn to_source_with_hygiene(&self) -> String {\n+            self.to_source()\n+        }\n+    }\n \n     impl ToSource for bool {\n         fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitBool(*self));\n             pprust::lit_to_string(&lit)\n         }\n     }\n+    impl ToSourceWithHygiene for bool {\n+        fn to_source_with_hygiene(&self) -> String {\n+            self.to_source()\n+        }\n+    }\n \n     impl ToSource for char {\n         fn to_source(&self) -> String {\n             let lit = dummy_spanned(ast::LitChar(*self));\n             pprust::lit_to_string(&lit)\n         }\n     }\n+    impl ToSourceWithHygiene for char {\n+        fn to_source_with_hygiene(&self) -> String {\n+            self.to_source()\n+        }\n+    }\n \n     macro_rules! impl_to_source_int(\n         (signed, $t:ty, $tag:ident) => (\n@@ -194,6 +259,11 @@ pub mod rt {\n                     pprust::lit_to_string(&dummy_spanned(lit))\n                 }\n             }\n+            impl ToSourceWithHygiene for $t {\n+                fn to_source_with_hygiene(&self) -> String {\n+                    self.to_source()\n+                }\n+            }\n         );\n         (unsigned, $t:ty, $tag:ident) => (\n             impl ToSource for $t {\n@@ -202,6 +272,11 @@ pub mod rt {\n                     pprust::lit_to_string(&dummy_spanned(lit))\n                 }\n             }\n+            impl ToSourceWithHygiene for $t {\n+                fn to_source_with_hygiene(&self) -> String {\n+                    self.to_source()\n+                }\n+            }\n         );\n     )\n \n@@ -223,7 +298,7 @@ pub mod rt {\n         ($t:ty) => (\n             impl ToTokens for $t {\n                 fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-                    cx.parse_tts(self.to_source())\n+                    cx.parse_tts_with_hygiene(self.to_source_with_hygiene())\n                 }\n             }\n         )\n@@ -233,7 +308,7 @@ pub mod rt {\n         ($t:ty) => (\n             impl<'a> ToTokens for $t {\n                 fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-                    cx.parse_tts(self.to_source())\n+                    cx.parse_tts_with_hygiene(self.to_source_with_hygiene())\n                 }\n             }\n         )\n@@ -272,7 +347,13 @@ pub mod rt {\n         fn parse_item(&self, s: String) -> Gc<ast::Item>;\n         fn parse_expr(&self, s: String) -> Gc<ast::Expr>;\n         fn parse_stmt(&self, s: String) -> Gc<ast::Stmt>;\n-        fn parse_tts(&self, s: String) -> Vec<ast::TokenTree> ;\n+        fn parse_tts(&self, s: String) -> Vec<ast::TokenTree>;\n+    }\n+\n+    trait ExtParseUtilsWithHygiene {\n+        // FIXME (Issue #16472): This should go away after ToToken impls\n+        // are revised to go directly to token-trees.\n+        fn parse_tts_with_hygiene(&self, s: String) -> Vec<ast::TokenTree>;\n     }\n \n     impl<'a> ExtParseUtils for ExtCtxt<'a> {\n@@ -315,6 +396,18 @@ pub mod rt {\n         }\n     }\n \n+    impl<'a> ExtParseUtilsWithHygiene for ExtCtxt<'a> {\n+\n+        fn parse_tts_with_hygiene(&self, s: String) -> Vec<ast::TokenTree> {\n+            use parse::with_hygiene::parse_tts_from_source_str;\n+            parse_tts_from_source_str(\"<quote expansion>\".to_string(),\n+                                      s,\n+                                      self.cfg(),\n+                                      self.parse_sess())\n+        }\n+\n+    }\n+\n }\n \n pub fn expand_quote_tokens(cx: &mut ExtCtxt,"}, {"sha": "e5275af5ccabef1e71f26972a5eebd1e35bb901d", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/c3ce245ba68f62edfc5818f003b2b78a02ce5c03/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ce245ba68f62edfc5818f003b2b78a02ce5c03/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=c3ce245ba68f62edfc5818f003b2b78a02ce5c03", "patch": "@@ -17,7 +17,9 @@ use parse::token;\n use parse::token::{str_to_ident};\n \n use std::char;\n+use std::fmt;\n use std::mem::replace;\n+use std::num;\n use std::rc::Rc;\n use std::str;\n \n@@ -55,6 +57,11 @@ pub struct StringReader<'a> {\n     /* cached: */\n     pub peek_tok: token::Token,\n     pub peek_span: Span,\n+\n+    // FIXME (Issue #16472): This field should go away after ToToken impls\n+    // are revised to go directly to token-trees.\n+    /// Is \\x00<name>,<ctxt>\\x00 is interpreted as encoded ast::Ident?\n+    read_embedded_ident: bool,\n }\n \n impl<'a> Reader for StringReader<'a> {\n@@ -106,6 +113,17 @@ impl<'a> Reader for TtReader<'a> {\n     }\n }\n \n+// FIXME (Issue #16472): This function should go away after\n+// ToToken impls are revised to go directly to token-trees.\n+pub fn make_reader_with_embedded_idents<'b>(span_diagnostic: &'b SpanHandler,\n+                                            filemap: Rc<codemap::FileMap>)\n+                                            -> StringReader<'b> {\n+    let mut sr = StringReader::new_raw(span_diagnostic, filemap);\n+    sr.read_embedded_ident = true;\n+    sr.advance_token();\n+    sr\n+}\n+\n impl<'a> StringReader<'a> {\n     /// For comments.rs, which hackily pokes into pos and curr\n     pub fn new_raw<'b>(span_diagnostic: &'b SpanHandler,\n@@ -120,6 +138,7 @@ impl<'a> StringReader<'a> {\n             /* dummy values; not read */\n             peek_tok: token::EOF,\n             peek_span: codemap::DUMMY_SP,\n+            read_embedded_ident: false,\n         };\n         sr.bump();\n         sr\n@@ -512,6 +531,81 @@ impl<'a> StringReader<'a> {\n         })\n     }\n \n+    // FIXME (Issue #16472): The scan_embedded_hygienic_ident function\n+    // should go away after we revise the syntax::ext::quote::ToToken\n+    // impls to go directly to token-trees instead of thing -> string\n+    // -> token-trees.  (The function is currently used to resolve\n+    // Issues #15750 and #15962.)\n+    //\n+    // Since this function is only used for certain internal macros,\n+    // and the functionality it provides is not exposed to end user\n+    // programs, pnkfelix deliberately chose to write it in a way that\n+    // favors rustc debugging effectiveness over runtime efficiency.\n+\n+    /// Scan through input of form \\x00name_NNNNNN,ctxt_CCCCCCC\\x00\n+    /// where: `NNNNNN` is a string of characters forming an integer\n+    /// (the name) and `CCCCCCC` is a string of characters forming an\n+    /// integer (the ctxt), separate by a comma and delimited by a\n+    /// `\\x00` marker.\n+    #[inline(never)]\n+    fn scan_embedded_hygienic_ident(&mut self) -> ast::Ident {\n+        fn bump_expecting_char<'a,D:fmt::Show>(r: &mut StringReader<'a>,\n+                                               c: char,\n+                                               described_c: D,\n+                                               where: &str) {\n+            match r.curr {\n+                Some(r_c) if r_c == c => r.bump(),\n+                Some(r_c) => fail!(\"expected {}, hit {}, {}\", described_c, r_c, where),\n+                None      => fail!(\"expected {}, hit EOF, {}\", described_c, where),\n+            }\n+        }\n+\n+        let where = \"while scanning embedded hygienic ident\";\n+\n+        // skip over the leading `\\x00`\n+        bump_expecting_char(self, '\\x00', \"nul-byte\", where);\n+\n+        // skip over the \"name_\"\n+        for c in \"name_\".chars() {\n+            bump_expecting_char(self, c, c, where);\n+        }\n+\n+        let start_bpos = self.last_pos;\n+        let base = 10;\n+\n+        // find the integer representing the name\n+        self.scan_digits(base);\n+        let encoded_name : u32 = self.with_str_from(start_bpos, |s| {\n+            num::from_str_radix(s, 10).unwrap_or_else(|| {\n+                fail!(\"expected digits representing a name, got `{}`, {}, range [{},{}]\",\n+                      s, where, start_bpos, self.last_pos);\n+            })\n+        });\n+\n+        // skip over the `,`\n+        bump_expecting_char(self, ',', \"comma\", where);\n+\n+        // skip over the \"ctxt_\"\n+        for c in \"ctxt_\".chars() {\n+            bump_expecting_char(self, c, c, where);\n+        }\n+\n+        // find the integer representing the ctxt\n+        let start_bpos = self.last_pos;\n+        self.scan_digits(base);\n+        let encoded_ctxt : ast::SyntaxContext = self.with_str_from(start_bpos, |s| {\n+            num::from_str_radix(s, 10).unwrap_or_else(|| {\n+                fail!(\"expected digits representing a ctxt, got `{}`, {}\", s, where);\n+            })\n+        });\n+\n+        // skip over the `\\x00`\n+        bump_expecting_char(self, '\\x00', \"nul-byte\", where);\n+\n+        ast::Ident { name: ast::Name(encoded_name),\n+                     ctxt: encoded_ctxt, }\n+    }\n+\n     /// Scan through any digits (base `radix`) or underscores, and return how\n     /// many digits there were.\n     fn scan_digits(&mut self, radix: uint) -> uint {\n@@ -839,6 +933,17 @@ impl<'a> StringReader<'a> {\n             return self.scan_number(c.unwrap());\n         }\n \n+        if self.read_embedded_ident {\n+            match (c.unwrap(), self.nextch(), self.nextnextch()) {\n+                ('\\x00', Some('n'), Some('a')) => {\n+                    let ast_ident = self.scan_embedded_hygienic_ident();\n+                    let is_mod_name = self.curr_is(':') && self.nextch_is(':');\n+                    return token::IDENT(ast_ident, is_mod_name);\n+                }\n+                _ => {}\n+            }\n+        }\n+\n         match c.expect(\"next_token_inner called at EOF\") {\n           // One-byte tokens.\n           ';' => { self.bump(); return token::SEMI; }"}, {"sha": "af1f296a6ca312eada90eea6740b029a56ae2ee3", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c3ce245ba68f62edfc5818f003b2b78a02ce5c03/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ce245ba68f62edfc5818f003b2b78a02ce5c03/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c3ce245ba68f62edfc5818f003b2b78a02ce5c03", "patch": "@@ -144,6 +144,8 @@ pub fn parse_stmt_from_source_str(name: String,\n     maybe_aborted(p.parse_stmt(attrs),p)\n }\n \n+// Note: keep in sync with `with_hygiene::parse_tts_from_source_str`\n+// until #16472 is resolved.\n pub fn parse_tts_from_source_str(name: String,\n                                  source: String,\n                                  cfg: ast::CrateConfig,\n@@ -160,6 +162,8 @@ pub fn parse_tts_from_source_str(name: String,\n     maybe_aborted(p.parse_all_token_trees(),p)\n }\n \n+// Note: keep in sync with `with_hygiene::new_parser_from_source_str`\n+// until #16472 is resolved.\n // Create a new parser from a source string\n pub fn new_parser_from_source_str<'a>(sess: &'a ParseSess,\n                                       cfg: ast::CrateConfig,\n@@ -192,6 +196,8 @@ pub fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n     p\n }\n \n+// Note: keep this in sync with `with_hygiene::filemap_to_parser` until\n+// #16472 is resolved.\n /// Given a filemap and config, return a parser\n pub fn filemap_to_parser<'a>(sess: &'a ParseSess,\n                              filemap: Rc<FileMap>,\n@@ -248,6 +254,8 @@ pub fn string_to_filemap(sess: &ParseSess, source: String, path: String)\n     sess.span_diagnostic.cm.new_filemap(path, source)\n }\n \n+// Note: keep this in sync with `with_hygiene::filemap_to_tts` (apart\n+// from the StringReader constructor), until #16472 is resolved.\n /// Given a filemap, produce a sequence of token-trees\n pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n     -> Vec<ast::TokenTree> {\n@@ -267,6 +275,67 @@ pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n     Parser::new(sess, cfg, box trdr)\n }\n \n+// FIXME (Issue #16472): The `with_hygiene` mod should go away after\n+// ToToken impls are revised to go directly to token-trees.\n+pub mod with_hygiene {\n+    use ast;\n+    use codemap::FileMap;\n+    use parse::parser::Parser;\n+    use std::rc::Rc;\n+    use super::ParseSess;\n+    use super::{maybe_aborted, string_to_filemap, tts_to_parser};\n+\n+    // Note: keep this in sync with `super::parse_tts_from_source_str` until\n+    // #16472 is resolved.\n+    pub fn parse_tts_from_source_str(name: String,\n+                                     source: String,\n+                                     cfg: ast::CrateConfig,\n+                                     sess: &ParseSess) -> Vec<ast::TokenTree> {\n+        let mut p = new_parser_from_source_str(\n+            sess,\n+            cfg,\n+            name,\n+            source\n+        );\n+        p.quote_depth += 1u;\n+        // right now this is re-creating the token trees from ... token trees.\n+        maybe_aborted(p.parse_all_token_trees(),p)\n+    }\n+\n+    // Note: keep this in sync with `super::new_parser_from_source_str` until\n+    // #16472 is resolved.\n+    // Create a new parser from a source string\n+    fn new_parser_from_source_str<'a>(sess: &'a ParseSess,\n+                                      cfg: ast::CrateConfig,\n+                                      name: String,\n+                                      source: String) -> Parser<'a> {\n+        filemap_to_parser(sess, string_to_filemap(sess, source, name), cfg)\n+    }\n+\n+    // Note: keep this in sync with `super::filemap_to_parserr` until\n+    // #16472 is resolved.\n+    /// Given a filemap and config, return a parser\n+    fn filemap_to_parser<'a>(sess: &'a ParseSess,\n+                             filemap: Rc<FileMap>,\n+                             cfg: ast::CrateConfig) -> Parser<'a> {\n+        tts_to_parser(sess, filemap_to_tts(sess, filemap), cfg)\n+    }\n+\n+    // Note: keep this in sync with `super::filemap_to_tts` until\n+    // #16472 is resolved.\n+    /// Given a filemap, produce a sequence of token-trees\n+    fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n+                      -> Vec<ast::TokenTree> {\n+        // it appears to me that the cfg doesn't matter here... indeed,\n+        // parsing tt's probably shouldn't require a parser at all.\n+        use make_reader = super::lexer::make_reader_with_embedded_idents;\n+        let cfg = Vec::new();\n+        let srdr = make_reader(&sess.span_diagnostic, filemap);\n+        let mut p1 = Parser::new(sess, cfg, box srdr);\n+        p1.parse_all_token_trees()\n+    }\n+}\n+\n /// Abort if necessary\n pub fn maybe_aborted<T>(result: T, mut p: Parser) -> T {\n     p.abort_if_errors();"}, {"sha": "9c1b97f94a825c746f3f1d857bb8d060dbda03e0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 69, "deletions": 28, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c3ce245ba68f62edfc5818f003b2b78a02ce5c03/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3ce245ba68f62edfc5818f003b2b78a02ce5c03/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c3ce245ba68f62edfc5818f003b2b78a02ce5c03", "patch": "@@ -58,7 +58,8 @@ pub struct State<'a> {\n     literals: Option<Vec<comments::Literal> >,\n     cur_cmnt_and_lit: CurrentCommentAndLiteral,\n     boxes: Vec<pp::Breaks>,\n-    ann: &'a PpAnn\n+    ann: &'a PpAnn,\n+    encode_idents_with_hygiene: bool,\n }\n \n pub fn rust_printer(writer: Box<io::Writer>) -> State<'static> {\n@@ -78,7 +79,8 @@ pub fn rust_printer_annotated<'a>(writer: Box<io::Writer>,\n             cur_lit: 0\n         },\n         boxes: Vec::new(),\n-        ann: ann\n+        ann: ann,\n+        encode_idents_with_hygiene: false,\n     }\n }\n \n@@ -148,7 +150,8 @@ impl<'a> State<'a> {\n                 cur_lit: 0\n             },\n             boxes: Vec::new(),\n-            ann: ann\n+            ann: ann,\n+            encode_idents_with_hygiene: false,\n         }\n     }\n }\n@@ -169,70 +172,77 @@ pub fn to_string(f: |&mut State| -> IoResult<()>) -> String {\n     }\n }\n \n+// FIXME (Issue #16472): the thing_to_string_impls macro should go away\n+// after we revise the syntax::ext::quote::ToToken impls to go directly\n+// to token-trees instea of thing -> string -> token-trees.\n+\n+macro_rules! thing_to_string_impls {\n+    ($to_string:ident) => {\n+\n pub fn ty_to_string(ty: &ast::Ty) -> String {\n-    to_string(|s| s.print_type(ty))\n+    $to_string(|s| s.print_type(ty))\n }\n \n pub fn pat_to_string(pat: &ast::Pat) -> String {\n-    to_string(|s| s.print_pat(pat))\n+    $to_string(|s| s.print_pat(pat))\n }\n \n pub fn arm_to_string(arm: &ast::Arm) -> String {\n-    to_string(|s| s.print_arm(arm))\n+    $to_string(|s| s.print_arm(arm))\n }\n \n pub fn expr_to_string(e: &ast::Expr) -> String {\n-    to_string(|s| s.print_expr(e))\n+    $to_string(|s| s.print_expr(e))\n }\n \n pub fn lifetime_to_string(e: &ast::Lifetime) -> String {\n-    to_string(|s| s.print_lifetime(e))\n+    $to_string(|s| s.print_lifetime(e))\n }\n \n pub fn tt_to_string(tt: &ast::TokenTree) -> String {\n-    to_string(|s| s.print_tt(tt))\n+    $to_string(|s| s.print_tt(tt))\n }\n \n pub fn tts_to_string(tts: &[ast::TokenTree]) -> String {\n-    to_string(|s| s.print_tts(tts))\n+    $to_string(|s| s.print_tts(tts))\n }\n \n pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n-    to_string(|s| s.print_stmt(stmt))\n+    $to_string(|s| s.print_stmt(stmt))\n }\n \n pub fn item_to_string(i: &ast::Item) -> String {\n-    to_string(|s| s.print_item(i))\n+    $to_string(|s| s.print_item(i))\n }\n \n pub fn generics_to_string(generics: &ast::Generics) -> String {\n-    to_string(|s| s.print_generics(generics))\n+    $to_string(|s| s.print_generics(generics))\n }\n \n pub fn ty_method_to_string(p: &ast::TypeMethod) -> String {\n-    to_string(|s| s.print_ty_method(p))\n+    $to_string(|s| s.print_ty_method(p))\n }\n \n pub fn method_to_string(p: &ast::Method) -> String {\n-    to_string(|s| s.print_method(p))\n+    $to_string(|s| s.print_method(p))\n }\n \n pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n-    to_string(|s| s.print_fn_block_args(p, false))\n+    $to_string(|s| s.print_fn_block_args(p, false))\n }\n \n pub fn path_to_string(p: &ast::Path) -> String {\n-    to_string(|s| s.print_path(p, false))\n+    $to_string(|s| s.print_path(p, false))\n }\n \n pub fn ident_to_string(id: &ast::Ident) -> String {\n-    to_string(|s| s.print_ident(*id))\n+    $to_string(|s| s.print_ident(*id))\n }\n \n pub fn fun_to_string(decl: &ast::FnDecl, fn_style: ast::FnStyle, name: ast::Ident,\n                   opt_explicit_self: Option<ast::ExplicitSelf_>,\n                   generics: &ast::Generics) -> String {\n-    to_string(|s| {\n+    $to_string(|s| {\n         try!(s.print_fn(decl, Some(fn_style), abi::Rust,\n                         name, generics, opt_explicit_self, ast::Inherited));\n         try!(s.end()); // Close the head box\n@@ -241,7 +251,7 @@ pub fn fun_to_string(decl: &ast::FnDecl, fn_style: ast::FnStyle, name: ast::Iden\n }\n \n pub fn block_to_string(blk: &ast::Block) -> String {\n-    to_string(|s| {\n+    $to_string(|s| {\n         // containing cbox, will be closed by print-block at }\n         try!(s.cbox(indent_unit));\n         // head-ibox, will be closed by print-block after {\n@@ -251,31 +261,57 @@ pub fn block_to_string(blk: &ast::Block) -> String {\n }\n \n pub fn meta_item_to_string(mi: &ast::MetaItem) -> String {\n-    to_string(|s| s.print_meta_item(mi))\n+    $to_string(|s| s.print_meta_item(mi))\n }\n \n pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n-    to_string(|s| s.print_attribute(attr))\n+    $to_string(|s| s.print_attribute(attr))\n }\n \n pub fn lit_to_string(l: &ast::Lit) -> String {\n-    to_string(|s| s.print_literal(l))\n+    $to_string(|s| s.print_literal(l))\n }\n \n pub fn explicit_self_to_string(explicit_self: ast::ExplicitSelf_) -> String {\n-    to_string(|s| s.print_explicit_self(explicit_self, ast::MutImmutable).map(|_| {}))\n+    $to_string(|s| s.print_explicit_self(explicit_self, ast::MutImmutable).map(|_| {}))\n }\n \n pub fn variant_to_string(var: &ast::Variant) -> String {\n-    to_string(|s| s.print_variant(var))\n+    $to_string(|s| s.print_variant(var))\n }\n \n pub fn arg_to_string(arg: &ast::Arg) -> String {\n-    to_string(|s| s.print_arg(arg))\n+    $to_string(|s| s.print_arg(arg))\n }\n \n pub fn mac_to_string(arg: &ast::Mac) -> String {\n-    to_string(|s| s.print_mac(arg))\n+    $to_string(|s| s.print_mac(arg))\n+}\n+\n+} }\n+\n+thing_to_string_impls!(to_string)\n+\n+// FIXME (Issue #16472): the whole `with_hygiene` mod should go away\n+// after we revise the syntax::ext::quote::ToToken impls to go directly\n+// to token-trees instea of thing -> string -> token-trees.\n+\n+pub mod with_hygiene {\n+    use abi;\n+    use ast;\n+    use std::io::IoResult;\n+    use super::indent_unit;\n+\n+    // This function is the trick that all the rest of the routines\n+    // hang on.\n+    pub fn to_string_hyg(f: |&mut super::State| -> IoResult<()>) -> String {\n+        super::to_string(|s| {\n+            s.encode_idents_with_hygiene = true;\n+            f(s)\n+        })\n+    }\n+\n+    thing_to_string_impls!(to_string_hyg)\n }\n \n pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> String {\n@@ -1672,7 +1708,12 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ident(&mut self, ident: ast::Ident) -> IoResult<()> {\n-        word(&mut self.s, token::get_ident(ident).get())\n+        if self.encode_idents_with_hygiene {\n+            let encoded = ident.encode_with_hygiene();\n+            word(&mut self.s, encoded.as_slice())\n+        } else {\n+            word(&mut self.s, token::get_ident(ident).get())\n+        }\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> IoResult<()> {"}]}