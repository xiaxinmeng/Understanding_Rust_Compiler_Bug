{"sha": "bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNGFlZWY3OGJjYzhlMDNlZjkyNzVlNzY1MmY5MWI5MzZmNWRlYzY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-07-20T00:52:34Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-07-20T01:57:28Z"}, "message": "Beginnings of support for constrained types\n\nPrograms with constrained types now parse and typecheck, but\ntypestate doesn't check them specially, so the one relevant test\ncase so far is XFAILed.\n\nAlso rewrote all of the constraint-related data structures in the\nprocess (again), for some reason. I got rid of a superfluous\ndata structure in the context that was mapping front-end constraints\nto resolved constraints, instead handling constraints in the same\nway in which everything else gets resolved.", "tree": {"sha": "debdaf33fc8968b764b2782ea05fdea5cd5e4ae3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/debdaf33fc8968b764b2782ea05fdea5cd5e4ae3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "html_url": "https://github.com/rust-lang/rust/commit/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da2a7e5bd25055de1573a7f862986522213ed1ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/da2a7e5bd25055de1573a7f862986522213ed1ca", "html_url": "https://github.com/rust-lang/rust/commit/da2a7e5bd25055de1573a7f862986522213ed1ca"}], "stats": {"total": 972, "additions": 606, "deletions": 366}, "files": [{"sha": "7e360e7f0e1382f69ba1c26d1293a2b1f69a6de8", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -134,8 +134,8 @@ fn compile_input(session::session sess, ast::crate_cfg cfg, str input,\n              bind resolve::resolve_crate(sess, ast_map, crate));\n     auto freevars =\n         time(time_passes, \"freevar finding\",\n-             bind freevars::annotate_freevars(sess, d._0, crate));\n-    auto ty_cx = ty::mk_ctxt(sess, d._0, d._1, ast_map, freevars);\n+             bind freevars::annotate_freevars(sess, d, crate));\n+    auto ty_cx = ty::mk_ctxt(sess, d, ast_map, freevars);\n     time[()](time_passes, \"typechecking\",\n              bind typeck::check_crate(ty_cx, crate));\n     if (sess.get_opts().run_typestate) {\n@@ -200,8 +200,8 @@ fn pretty_print_input(session::session sess, ast::crate_cfg cfg,\n         case (ppm_typed) {\n             auto amap = middle::ast_map::map_crate(*crate);\n             auto d = resolve::resolve_crate(sess, amap, crate);\n-            auto freevars = freevars::annotate_freevars(sess, d._0, crate);\n-            auto ty_cx = ty::mk_ctxt(sess, d._0, d._1, amap, freevars);\n+            auto freevars = freevars::annotate_freevars(sess, d, crate);\n+            auto ty_cx = ty::mk_ctxt(sess, d, amap, freevars);\n             typeck::check_crate(ty_cx, crate);\n             ann = rec(pre=ann_paren_for_expr,\n                       post=bind ann_typed_post(ty_cx, _));"}, {"sha": "6f55f6d097c2fc9ce2e0110e9e17ddf808431172", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 58, "deletions": 34, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -7,6 +7,7 @@ import std::option;\n import std::option::none;\n import std::option::some;\n import syntax::ast;\n+import syntax::ast::*;\n import ast::respan;\n import middle::ty;\n \n@@ -65,13 +66,15 @@ fn parse_ty_or_bang(@pstate st, str_def sd) -> ty_or_bang {\n     }\n }\n \n-fn parse_constrs(@pstate st, str_def sd) -> (@ty::constr_def)[] {\n-    let (@ty::constr_def)[] rslt = ~[];\n+fn parse_constrs(@pstate st, str_def sd) -> (@ty::constr)[] {\n+    let (@ty::constr)[] rslt = ~[];\n     alt (peek(st) as char) {\n         case (':') {\n-            do  {\n+            do {\n                 next(st);\n-                rslt += ~[parse_constr(st, sd)];\n+                let @ty::constr one = parse_constr[uint](st, sd,\n+                                                         parse_constr_arg);\n+                rslt += ~[one];\n             } while (peek(st) as char == ';')\n         }\n         case (_) { }\n@@ -102,40 +105,50 @@ fn parse_path(@pstate st, str_def sd) -> ast::path {\n     fail \"parse_path: ill-formed path\";\n }\n \n-fn parse_constr(@pstate st, str_def sd) -> @ty::constr_def {\n-    let (@ast::constr_arg)[] args = ~[];\n+type arg_parser[T] = fn (@pstate st, str_def sd)\n+                       -> ast::constr_arg_general_[T];\n+\n+fn parse_constr_arg(@pstate st, str_def sd) -> ast::fn_constr_arg {\n+     alt (peek(st) as char) {\n+      case ('*') {\n+        st.pos += 1u;\n+        ret ast::carg_base;\n+      }\n+      case (?c) {\n+        /* how will we disambiguate between\n+           an arg index and a lit argument? */\n+        if (c >= '0' && c <= '9') {\n+            next(st);\n+          // FIXME\n+          ret ast::carg_ident((c as uint) - 48u);\n+        }\n+        else {\n+          log_err(\"Lit args are unimplemented\");\n+          fail; // FIXME\n+        }\n+        /*\n+          else {\n+          auto lit = parse_lit(st, sd, ',');\n+          args += [respan(st.span, ast::carg_lit(lit))];\n+          }\n+        */\n+      }\n+    }\n+}\n+\n+fn parse_constr[T](@pstate st, str_def sd, arg_parser[T] pser)\n+    -> @ty::constr_general[T] {\n     auto sp = rec(lo=0u,hi=0u); // FIXME: use a real span\n-    let ast::path pth = parse_path(st, sd);\n+    let (@sp_constr_arg[T])[] args = ~[];\n+    let path pth = parse_path(st, sd);\n     let char ignore = next(st) as char;\n     assert(ignore as char == '(');\n     auto def = parse_def(st, sd);\n+    let constr_arg_general_[T] an_arg;\n     do {\n-        alt (peek(st) as char) {\n-            case ('*') {\n-                st.pos += 1u;\n-                args += ~[@respan(sp, ast::carg_base)];\n-            }\n-            case (?c) {\n-                /* how will we disambiguate between\n-                 an arg index and a lit argument? */\n-                if (c >= '0' && c <= '9') {\n-                    // FIXME\n-                    args += ~[@respan(sp,\n-                                      ast::carg_ident((c as uint) - 48u))];\n-                    ignore = next(st) as char;\n-                }\n-                else {\n-                    log_err(\"Lit args are unimplemented\");\n-                    fail; // FIXME\n-                }\n-                /*\n-                else {\n-                    auto lit = parse_lit(st, sd, ',');\n-                    args += [respan(st.span, ast::carg_lit(lit))];\n-                }\n-                */\n-            }\n-        }\n+        an_arg = pser(st, sd);\n+        // FIXME use a real span\n+        args += ~[@respan(sp, an_arg)];\n         ignore = next(st) as char;\n     } while (ignore == ';');\n     assert(ignore == ')');\n@@ -335,7 +348,7 @@ fn parse_hex(@pstate st) -> uint {\n }\n \n fn parse_ty_fn(@pstate st, str_def sd) ->\n-   tup(ty::arg[], ty::t, ast::controlflow, (@ty::constr_def)[]) {\n+   tup(ty::arg[], ty::t, ast::controlflow, (@ty::constr)[]) {\n     assert (next(st) as char == '[');\n     let ty::arg[] inputs = ~[];\n     while (peek(st) as char != ']') {\n@@ -384,3 +397,14 @@ fn parse_def_id(&u8[] buf) -> ast::def_id {\n     auto def_id = uint::parse_buf(def_part_vec, 10u) as int;\n     ret tup(crate_num, def_id);\n }\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "e239d678174057b60ce0f0101248b2b1aa83b9bd", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -8,7 +8,7 @@ import std::int;\n import std::uint;\n import syntax::ast::*;\n import middle::ty;\n-import syntax::print::pprust::lit_to_str;\n+import syntax::print::pprust::*;\n import util::common;\n \n export ctxt;\n@@ -199,8 +199,9 @@ fn enc_proto(&ioivec::writer w, proto proto) {\n         case (proto_fn) { w.write_char('F'); }\n     }\n }\n+\n fn enc_ty_fn(&ioivec::writer w, &@ctxt cx, &ty::arg[] args, &ty::t out,\n-             &controlflow cf, &(@ty::constr_def)[] constrs) {\n+             &controlflow cf, &(@ty::constr)[] constrs) {\n     w.write_char('[');\n     for (ty::arg arg in args) {\n         alt (arg.mode) {\n@@ -214,7 +215,7 @@ fn enc_ty_fn(&ioivec::writer w, &@ctxt cx, &ty::arg[] args, &ty::t out,\n     }\n     w.write_char(']');\n     auto colon = true;\n-    for (@ty::constr_def c in constrs) {\n+    for (@ty::constr c in constrs) {\n         if (colon) {\n             w.write_char(':');\n             colon = false;\n@@ -227,7 +228,8 @@ fn enc_ty_fn(&ioivec::writer w, &@ctxt cx, &ty::arg[] args, &ty::t out,\n     }\n \n }\n-fn enc_constr(&ioivec::writer w, &@ctxt cx, &@ty::constr_def c) {\n+\n+fn enc_constr(&ioivec::writer w, &@ctxt cx, &@ty::constr c) {\n     w.write_str(path_to_str(c.node.path));\n     w.write_char('(');\n     w.write_str(cx.ds(c.node.id));"}, {"sha": "0a3d61b165a6d06a96ba27a13a24937d4abef269", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -1,5 +1,6 @@\n \n import syntax::ast;\n+import syntax::ast::*;\n import ast::ident;\n import ast::fn_ident;\n import ast::def;\n@@ -19,6 +20,7 @@ import middle::ty::constr_table;\n import syntax::visit;\n import visit::vt;\n import std::ivec;\n+import std::int;\n import std::map::hashmap;\n import std::list;\n import std::list::list;\n@@ -28,6 +30,7 @@ import std::option;\n import std::option::some;\n import std::option::none;\n import std::str;\n+import syntax::print::pprust::*;\n \n export resolve_crate;\n export def_map;\n@@ -109,7 +112,6 @@ type def_map = hashmap[node_id, def];\n type env =\n     rec(cstore::cstore cstore,\n         def_map def_map,\n-        constr_table fn_constrs,\n         ast_map::map ast_map,\n         hashmap[ast::node_id, import_state] imports,\n         hashmap[ast::node_id, @indexed_mod] mod_map,\n@@ -124,12 +126,11 @@ tag dir { inside; outside; }\n \n tag namespace { ns_value; ns_type; ns_module; }\n \n-fn resolve_crate(session sess, &ast_map::map amap, @ast::crate crate) ->\n-   tup(def_map, constr_table) {\n+fn resolve_crate(session sess, &ast_map::map amap, @ast::crate crate)\n+  -> def_map {\n     auto e =\n         @rec(cstore=sess.get_cstore(),\n              def_map=new_int_hash[def](),\n-             fn_constrs = new_int_hash[ty::constr_def[]](),\n              ast_map=amap,\n              imports=new_int_hash[import_state](),\n              mod_map=new_int_hash[@indexed_mod](),\n@@ -140,7 +141,7 @@ fn resolve_crate(session sess, &ast_map::map amap, @ast::crate crate) ->\n     resolve_imports(*e);\n     check_for_collisions(e, *crate);\n     resolve_names(e, crate);\n-    ret tup(e.def_map, e.fn_constrs);\n+    ret e.def_map;\n }\n \n \n@@ -249,7 +250,7 @@ fn resolve_names(&@env e, &@ast::crate c) {\n              visit_arm=bind walk_arm(e, _, _, _),\n              visit_expr=bind walk_expr(e, _, _, _),\n              visit_ty=bind walk_ty(e, _, _, _),\n-             visit_constr=bind walk_constr(e, _, _, _),\n+             visit_constr=bind walk_constr(e, _, _, _, _, _),\n              visit_fn=bind visit_fn_with_scope(e, _, _, _, _, _, _, _)\n              with *visit::default_visitor());\n     visit::visit_crate(*c, cons(scope_crate, @nil), visit::mk_vt(v));\n@@ -277,10 +278,9 @@ fn resolve_names(&@env e, &@ast::crate c) {\n             case (_) { }\n         }\n     }\n-    fn walk_constr(@env e, &@ast::constr c, &scopes sc, &vt[scopes] v) {\n-        maybe_insert(e, c.node.id,\n-                     lookup_path_strict(*e, sc, c.span, c.node.path.node,\n-                                        ns_value));\n+    fn walk_constr(@env e, &ast::path p, &span sp, node_id id,\n+                   &scopes sc, &vt[scopes] v) {\n+        maybe_insert(e, id, lookup_path_strict(*e, sc, sp, p.node, ns_value));\n     }\n     fn walk_arm(@env e, &ast::arm a, &scopes sc, &vt[scopes] v) {\n         for (@ast::pat p in a.pats) { walk_pat(*e, sc, p); }\n@@ -411,29 +411,18 @@ fn resolve_constr(@env e, node_id id, &@ast::constr c, &scopes sc,\n     if (option::is_some(new_def)) {\n         alt (option::get(new_def)) {\n             case (ast::def_fn(?pred_id, ast::pure_fn)) {\n-                let ty::constr_general[uint] c_ =\n-                    rec(path=c.node.path, args=c.node.args, id=pred_id);\n-                let ty::constr_def new_constr = respan(c.span, c_);\n-                add_constr(e, id, new_constr);\n+                e.def_map.insert(c.node.id, ast::def_fn(pred_id,\n+                                                        ast::pure_fn));\n             }\n             case (_) {\n                 e.sess.span_err(c.span,\n                                 \"Non-predicate in constraint: \" +\n-                                ast::path_to_str(c.node.path));\n+                                path_to_str(c.node.path));\n             }\n         }\n     }\n }\n \n-fn add_constr(&@env e, node_id id, &ty::constr_def c) {\n-    e.fn_constrs.insert(id,\n-                        alt (e.fn_constrs.find(id)) {\n-                            case (none) { ~[c] }\n-                            case (some(?cs)) { cs + ~[c] }\n-                        });\n-}\n-\n-\n // Import resolution\n fn resolve_import(&env e, &@ast::view_item it, scopes sc) {\n     auto defid;"}, {"sha": "d6303b15fe63de22d6fef054a803631cdebaee8c", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 91, "deletions": 71, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -72,12 +72,12 @@ fn comma_str(&(@constr_arg_use)[] args) -> str {\n     ret rslt;\n }\n \n-fn constraint_to_str(&ty::ctxt tcx, &constr c) -> str {\n-    alt (c.node.c) {\n-        case (ninit(?i)) {\n+fn constraint_to_str(&ty::ctxt tcx, &sp_constr c) -> str {\n+    alt (c.node) {\n+        case (ninit(_,?i)) {\n             ret \"init(\" + i + \" [\" + tcx.sess.span_str(c.span) + \"])\";\n         }\n-        case (npred(?p, ?args)) {\n+        case (npred(?p, _, ?args)) {\n             ret path_to_str(p) + \"(\" + comma_str(args) + \")\" + \"[\" +\n                     tcx.sess.span_str(c.span) + \"]\";\n         }\n@@ -204,31 +204,36 @@ to represent predicate *arguments* however. This type\n \n Both types store an ident and span, for error-logging purposes.\n */\n-type pred_desc_ = rec((@constr_arg_use)[] args, uint bit_num);\n+type pred_args_ = rec((@constr_arg_use)[] args, uint bit_num);\n \n-type pred_desc = spanned[pred_desc_];\n+type pred_args = spanned[pred_args_];\n \n-// FIXME: Should be node_id, since we can only talk\n-// about locals.\n-type constr_arg_use = constr_arg_general[tup(ident, def_id)];\n+// The attached node ID is the *defining* node ID\n+// for this local.\n+type constr_arg_use = spanned[constr_arg_general_[inst]];\n \n tag constraint {\n     cinit(uint, span, ident);\n-    cpred(path, @mutable pred_desc[]);\n+    // FIXME: really only want it to be mutable during collect_locals.\n+    // freeze it after that.\n+    cpred(path, @mutable (pred_args[]));\n }\n \n-tag constr__ {\n-    ninit(ident);\n-    npred(path, (@constr_arg_use)[]);\n+// An ninit variant has a node_id because it refers to a local var.\n+// An npred has a def_id since the definition of the typestate\n+// predicate need not be local.\n+// FIXME: would be nice to give both a def_id field,\n+// and give ninit a constraint saying it's local.\n+tag tsconstr {\n+    ninit(node_id, ident);\n+    npred(path, def_id, (@constr_arg_use)[]);\n }\n \n-type constr_ = rec(node_id id, constr__ c);\n+type sp_constr = spanned[tsconstr];\n \n-type constr = spanned[constr_];\n+type norm_constraint = rec(uint bit_num, sp_constr c);\n \n-type norm_constraint = rec(uint bit_num, constr c);\n-\n-type constr_map = @std::map::hashmap[node_id, constraint];\n+type constr_map = @std::map::hashmap[def_id, constraint];\n \n type fn_info = rec(constr_map constrs,\n                    uint num_constraints,\n@@ -240,6 +245,12 @@ type fn_info = rec(constr_map constrs,\n                    // bug?\n                    @mutable node_id[] used_vars);\n \n+fn tsconstr_to_def_id(&tsconstr t) -> def_id {\n+    alt (t) {\n+        case (ninit(?id,_)) { local_def(id) }\n+        case (npred(_,?id,_)) { id }\n+    }\n+}\n \n /* mapping from node ID to typestate annotation */\n type node_ann_table = @mutable ts_ann[mutable];\n@@ -468,7 +479,7 @@ fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n     }\n }\n \n-fn constraints_expr(&ty::ctxt cx, @expr e) -> (@ty::constr_def)[] {\n+fn constraints_expr(&ty::ctxt cx, @expr e) -> (@ty::constr)[] {\n     alt (ty::struct(cx, ty::node_id_to_type(cx, e.id))) {\n         case (ty::ty_fn(_, _, _, _, ?cs)) { ret cs; }\n         case (_) { ret ~[]; }\n@@ -489,18 +500,17 @@ fn node_id_to_def(&crate_ctxt ccx, node_id id) -> option::t[def] {\n     ret ccx.tcx.def_map.find(id);\n }\n \n-fn norm_a_constraint(node_id id, &constraint c) -> norm_constraint[] {\n+fn norm_a_constraint(def_id id, &constraint c) -> norm_constraint[] {\n     alt (c) {\n         case (cinit(?n, ?sp, ?i)) {\n-            ret ~[rec(bit_num=n, c=respan(sp, rec(id=id, c=ninit(i))))];\n+            ret ~[rec(bit_num=n, c=respan(sp, ninit(id._1, i)))];\n         }\n         case (cpred(?p, ?descs)) {\n             let norm_constraint[] rslt = ~[];\n-            for (pred_desc pd in *descs) {\n+            for (pred_args pd in *descs) {\n                 rslt += ~[rec(bit_num=pd.node.bit_num,\n                               c=respan(pd.span,\n-                                       rec(id=id,\n-                                           c=npred(p, pd.node.args))))];\n+                                       npred(p, id, pd.node.args)))];\n             }\n             ret rslt;\n         }\n@@ -512,32 +522,36 @@ fn norm_a_constraint(node_id id, &constraint c) -> norm_constraint[] {\n // non-exhaustive match in trans.\n fn constraints(&fn_ctxt fcx) -> norm_constraint[] {\n     let norm_constraint[] rslt = ~[];\n-    for each (@tup(node_id, constraint) p in fcx.enclosing.constrs.items()) {\n+    for each (@tup(def_id, constraint) p in fcx.enclosing.constrs.items()) {\n         rslt += norm_a_constraint(p._0, p._1);\n     }\n     ret rslt;\n }\n \n-fn match_args(&fn_ctxt fcx, &pred_desc[] occs, &(@constr_arg_use)[] occ) ->\n+// FIXME\n+// Would rather take an immutable vec as an argument,\n+// should freeze it at some earlier point.\n+fn match_args(&fn_ctxt fcx, &(@mutable pred_args[]) occs,\n+              &(@constr_arg_use)[] occ) ->\n    uint {\n     log \"match_args: looking at \" +\n-        constr_args_to_str(std::util::fst[ident, def_id], occ);\n-    for (pred_desc pd in occs) {\n-        log \"match_args: candidate \" + pred_desc_to_str(pd);\n-        fn eq(&tup(ident, def_id) p, &tup(ident, def_id) q) -> bool {\n+        constr_args_to_str(std::util::fst[ident, node_id], occ);\n+    for (pred_args pd in *occs) {\n+        log \"match_args: candidate \" + pred_args_to_str(pd);\n+        fn eq(&inst p, &inst q) -> bool {\n             ret p._1 == q._1;\n         }\n         if (ty::args_eq(eq, pd.node.args, occ)) { ret pd.node.bit_num; }\n     }\n     fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");\n }\n \n-fn node_id_for_constr(ty::ctxt tcx, node_id t) -> node_id {\n+fn def_id_for_constr(ty::ctxt tcx, node_id t) -> def_id {\n     alt (tcx.def_map.find(t)) {\n         case (none) {\n             tcx.sess.bug(\"node_id_for_constr: bad node_id \" + int::str(t));\n         }\n-        case (some(def_fn(?i,_))) { ret i._1; }\n+        case (some(def_fn(?i,_))) { ret i; }\n         case (_) {\n             tcx.sess.bug(\"node_id_for_constr: pred is not a function\");\n         }\n@@ -550,11 +564,11 @@ fn expr_to_constr_arg(ty::ctxt tcx, &@expr e) -> @constr_arg_use {\n             alt (tcx.def_map.find(e.id)) {\n                 case (some(def_local(?l_id))) {\n                     ret @respan(p.span, carg_ident(tup(p.node.idents.(0),\n-                                                       l_id)));\n+                                                       l_id._1)));\n                 }\n                 case (some(def_arg(?a_id))) {\n                     ret @respan(p.span, carg_ident(tup(p.node.idents.(0),\n-                                                       a_id)));\n+                                                       a_id._1)));\n                 }\n                 case (_) {\n                     tcx.sess.bug(\"exprs_to_constr_args: non-local variable \" +\n@@ -582,7 +596,7 @@ fn exprs_to_constr_args(ty::ctxt tcx, &(@expr)[] args)\n     rslt\n }\n \n-fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n+fn expr_to_constr(ty::ctxt tcx, &@expr e) -> sp_constr {\n     alt (e.node) {\n         case (\n              // FIXME change the first pattern to expr_path to test a\n@@ -591,9 +605,8 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n             alt (operator.node) {\n                 case (expr_path(?p)) {\n                     ret respan(e.span,\n-                               rec(id=node_id_for_constr(tcx, operator.id),\n-                                   c=npred(p, exprs_to_constr_args(tcx,\n-                                           args))));\n+                               npred(p, def_id_for_constr(tcx, operator.id),\n+                                     exprs_to_constr_args(tcx, args)));\n                 }\n                 case (_) {\n                     tcx.sess.span_fatal(operator.span,\n@@ -610,19 +623,19 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n     }\n }\n \n-fn pred_desc_to_str(&pred_desc p) -> str {\n+fn pred_args_to_str(&pred_args p) -> str {\n     \"<\" + uint::str(p.node.bit_num) + \", \" +\n-        constr_args_to_str(std::util::fst[ident, def_id],\n+        constr_args_to_str(std::util::fst[ident, node_id],\n                            p.node.args) + \">\"\n }\n \n fn substitute_constr_args(&ty::ctxt cx, &(@expr)[] actuals,\n-                          &@ty::constr_def c) -> constr__ {\n+                          &@ty::constr c) -> tsconstr {\n     let (@constr_arg_use)[] rslt = ~[];\n     for (@constr_arg a in c.node.args) {\n         rslt += ~[substitute_arg(cx, actuals, a)];\n     }\n-    ret npred(c.node.path, rslt);\n+    ret npred(c.node.path, c.node.id, rslt);\n }\n \n fn substitute_arg(&ty::ctxt cx, &(@expr)[] actuals, @constr_arg a) ->\n@@ -642,8 +655,8 @@ fn substitute_arg(&ty::ctxt cx, &(@expr)[] actuals, @constr_arg a) ->\n     }\n }\n \n-fn pred_desc_matches(&(constr_arg_general_[tup(ident, def_id)])[] pattern,\n-                     &pred_desc desc) -> bool {\n+fn pred_args_matches(&(constr_arg_general_[inst])[] pattern,\n+                     &pred_args desc) -> bool {\n     auto i = 0u;\n     for (@constr_arg_use c in desc.node.args) {\n         auto n = pattern.(i);\n@@ -679,17 +692,17 @@ fn pred_desc_matches(&(constr_arg_general_[tup(ident, def_id)])[] pattern,\n     ret true;\n }\n \n-fn find_instance_(&(constr_arg_general_[tup(ident, def_id)])[] pattern,\n-                  &pred_desc[] descs) -> option::t[uint] {\n-    for (pred_desc d in descs) {\n-        if (pred_desc_matches(pattern, d)) {\n+fn find_instance_(&(constr_arg_general_[inst])[] pattern,\n+                  &pred_args[] descs) -> option::t[uint] {\n+    for (pred_args d in descs) {\n+        if (pred_args_matches(pattern, d)) {\n             ret some(d.node.bit_num);\n         }\n     }\n     ret none;\n }\n \n-type inst = tup(ident, def_id);\n+type inst = tup(ident, node_id);\n type subst = tup(inst, inst)[];\n \n fn find_instances(&fn_ctxt fcx, &subst subst, &constraint c)\n@@ -703,7 +716,7 @@ fn find_instances(&fn_ctxt fcx, &subst subst, &constraint c)\n     alt (c) {\n         case (cinit(_,_,_)) { /* this is dealt with separately */ }\n         case (cpred(?p, ?descs)) {\n-            for (pred_desc d in *descs) {\n+            for (pred_args d in *descs) {\n                 if (args_mention(d.node.args, find_in_subst_bool, subst)) {\n                     auto old_bit_num = d.node.bit_num;\n                     auto new = replace(subst, d);\n@@ -720,7 +733,7 @@ fn find_instances(&fn_ctxt fcx, &subst subst, &constraint c)\n     rslt\n }\n \n-fn find_in_subst(def_id id, &subst s) -> option::t[inst] {\n+fn find_in_subst(node_id id, &subst s) -> option::t[inst] {\n     for (tup(inst, inst) p in s) {\n         if (id == p._0._1) {\n             ret some(p._1);\n@@ -729,7 +742,7 @@ fn find_in_subst(def_id id, &subst s) -> option::t[inst] {\n     ret none;\n }\n \n-fn find_in_subst_bool(&subst s, def_id id) -> bool {\n+fn find_in_subst_bool(&subst s, node_id id) -> bool {\n     is_some(find_in_subst(id, s))\n }\n \n@@ -745,7 +758,7 @@ fn insts_to_str(&(constr_arg_general_[inst])[] stuff) -> str {\n     rslt\n }\n \n-fn replace(subst subst, pred_desc d) -> (constr_arg_general_[inst])[] {\n+fn replace(subst subst, pred_args d) -> (constr_arg_general_[inst])[] {\n     let (constr_arg_general_[inst])[] rslt = ~[];\n     for (@constr_arg_use c in d.node.args) {\n         alt (c.node) {\n@@ -824,6 +837,15 @@ fn local_node_id_to_def_id(&fn_ctxt fcx, &node_id i) -> option::t[def_id] {\n     }\n }\n \n+fn local_node_id_to_local_def_id(&fn_ctxt fcx, &node_id i)\n+    -> option::t[node_id] {\n+    alt (local_node_id_to_def(fcx, i)) {\n+        case (some (def_local(?d_id))) { some(d_id._1) }\n+        case (some (def_arg(?a_id)))  { some(a_id._1) }\n+        case (_)                      { none }\n+    }\n+}\n+\n fn copy_in_postcond(&fn_ctxt fcx, node_id parent_exp, inst dest, inst src,\n                     oper_type ty) {\n     auto post = node_id_to_ts_ann(fcx.ccx, parent_exp).conditions.\n@@ -859,7 +881,7 @@ fn copy_in_poststate_two(&fn_ctxt fcx, &poststate src_post,\n         }\n     }\n \n-    for each (@tup(node_id, constraint) p in\n+    for each (@tup(def_id, constraint) p in\n               fcx.enclosing.constrs.items()) {\n         // replace any occurrences of the src def_id with the\n         // dest def_id\n@@ -878,7 +900,7 @@ fn copy_in_poststate_two(&fn_ctxt fcx, &poststate src_post,\n fn forget_in_postcond(&fn_ctxt fcx, node_id parent_exp, node_id dead_v) {\n     // In the postcondition given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n-    auto d = local_node_id_to_def_id(fcx, dead_v);\n+    auto d = local_node_id_to_local_def_id(fcx, dead_v);\n     alt (d) {\n         case (some(?d_id)) {\n             for (norm_constraint c in constraints(fcx)) {\n@@ -896,7 +918,7 @@ fn forget_in_postcond_still_init(&fn_ctxt fcx, node_id parent_exp,\n                                  node_id dead_v) {\n     // In the postcondition given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n-    auto d = local_node_id_to_def_id(fcx, dead_v);\n+    auto d = local_node_id_to_local_def_id(fcx, dead_v);\n     alt (d) {\n         case (some(?d_id)) {\n             for (norm_constraint c in constraints(fcx)) {\n@@ -913,7 +935,7 @@ fn forget_in_postcond_still_init(&fn_ctxt fcx, node_id parent_exp,\n fn forget_in_poststate(&fn_ctxt fcx, &poststate p, node_id dead_v) -> bool {\n     // In the poststate given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n-    auto d = local_node_id_to_def_id(fcx, dead_v);\n+    auto d = local_node_id_to_local_def_id(fcx, dead_v);\n     auto changed = false;\n     alt (d) {\n         case (some(?d_id)) {\n@@ -932,7 +954,7 @@ fn forget_in_poststate_still_init(&fn_ctxt fcx, &poststate p, node_id dead_v)\n     -> bool {\n     // In the poststate given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n-    auto d = local_node_id_to_def_id(fcx, dead_v);\n+    auto d = local_node_id_to_local_def_id(fcx, dead_v);\n     auto changed = false;\n     alt (d) {\n         case (some(?d_id)) {\n@@ -947,37 +969,35 @@ fn forget_in_poststate_still_init(&fn_ctxt fcx, &poststate p, node_id dead_v)\n     ret changed;\n }\n \n-fn any_eq(&(def_id)[] v, def_id d) -> bool {\n-    for (def_id i in v) {\n+fn any_eq(&(node_id)[] v, node_id d) -> bool {\n+    for (node_id i in v) {\n         if (i == d) { ret true; }\n     }\n     false\n }\n \n-fn constraint_mentions(&fn_ctxt fcx, &norm_constraint c, def_id v) -> bool {\n-    ret (alt (c.c.node.c) {\n-            case (ninit(_)) {\n-                v == local_def(c.c.node.id)\n-            }\n-            case (npred(_, ?args)) {\n+fn constraint_mentions(&fn_ctxt fcx, &norm_constraint c, node_id v) -> bool {\n+    ret (alt (c.c.node) {\n+            case (ninit(?id,_)) { v == id }\n+            case (npred(_, _, ?args)) {\n                 args_mention(args, any_eq, ~[v])\n             }\n         });\n }\n \n fn non_init_constraint_mentions(&fn_ctxt fcx, &norm_constraint c,\n-                                &def_id v) -> bool {\n-    ret (alt (c.c.node.c) {\n-            case (ninit(_)) {\n+                                &node_id v) -> bool {\n+    ret (alt (c.c.node) {\n+            case (ninit(_,_)) {\n                 false\n             }\n-            case (npred(_, ?args)) {\n+            case (npred(_, _, ?args)) {\n                 args_mention(args, any_eq, ~[v])\n             }\n         });\n }\n \n-fn args_mention[T](&(@constr_arg_use)[] args, fn(&(T)[], def_id) -> bool q,\n+fn args_mention[T](&(@constr_arg_use)[] args, fn(&(T)[], node_id) -> bool q,\n                    &(T)[] s) -> bool {\n     /*\n       FIXME"}, {"sha": "e7afe85f34f777b40752d73ab2565de30202dda8", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 20, "deletions": 42, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -1,29 +1,8 @@\n-\n import syntax::ast::*;\n import syntax::walk;\n import std::ivec;\n import std::option::*;\n-import aux::constr_arg_use;\n-import aux::local_node_id_to_def;\n-import aux::fn_ctxt;\n-import aux::fn_info;\n-import aux::log_tritv;\n-import aux::log_tritv_err;\n-import aux::num_constraints;\n-import aux::cinit;\n-import aux::cpred;\n-import aux::ninit;\n-import aux::npred;\n-import aux::pred_desc;\n-import aux::match_args;\n-import aux::constr_;\n-import aux::block_precond;\n-import aux::stmt_precond;\n-import aux::expr_precond;\n-import aux::block_prestate;\n-import aux::expr_prestate;\n-import aux::stmt_prestate;\n-import tstate::aux::node_id_to_ts_ann;\n+import aux::*;\n import tstate::ann::pre_and_post;\n import tstate::ann::precond;\n import tstate::ann::postcond;\n@@ -47,11 +26,12 @@ import tstate::ann::clear_in_prestate;\n import tstate::ann::clear_in_poststate_;\n import tritv::*;\n \n-fn bit_num(&fn_ctxt fcx, &constr_ c) -> uint {\n-    assert (fcx.enclosing.constrs.contains_key(c.id));\n-    auto rslt = fcx.enclosing.constrs.get(c.id);\n-    alt (c.c) {\n-        case (ninit(_)) {\n+fn bit_num(&fn_ctxt fcx, &tsconstr c) -> uint {\n+    auto d = tsconstr_to_def_id(c);\n+    assert (fcx.enclosing.constrs.contains_key(d));\n+    auto rslt = fcx.enclosing.constrs.get(d);\n+    alt (c) {\n+        case (ninit(_,_)) {\n             alt (rslt) {\n                 case (cinit(?n, _, _)) { ret n; }\n                 case (_) {\n@@ -60,11 +40,10 @@ fn bit_num(&fn_ctxt fcx, &constr_ c) -> uint {\n                 }\n             }\n         }\n-        case (npred(_, ?args)) {\n+        case (npred(_, _, ?args)) {\n             alt (rslt) {\n                 case (cpred(_, ?descs)) {\n-                    auto d = *descs;\n-                    ret match_args(fcx, d, args);\n+                    ret match_args(fcx, descs, args);\n                 }\n                 case (_) {\n                     fcx.ccx.tcx.sess.bug(\"bit_num: asked for pred constraint,\"\n@@ -75,7 +54,7 @@ fn bit_num(&fn_ctxt fcx, &constr_ c) -> uint {\n     }\n }\n \n-fn promises(&fn_ctxt fcx, &poststate p, &constr_ c) -> bool {\n+fn promises(&fn_ctxt fcx, &poststate p, &tsconstr c) -> bool {\n     ret promises_(bit_num(fcx, c), p);\n }\n \n@@ -161,12 +140,12 @@ fn intersect_states(&prestate p, &prestate q) -> prestate {\n     ret rslt;\n }\n \n-fn gen(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n+fn gen(&fn_ctxt fcx, node_id id, &tsconstr c) -> bool {\n     ret set_in_postcond(bit_num(fcx, c),\n                         node_id_to_ts_ann(fcx.ccx, id).conditions);\n }\n \n-fn declare_var(&fn_ctxt fcx, &constr_ c, prestate pre) -> prestate {\n+fn declare_var(&fn_ctxt fcx, &tsconstr c, prestate pre) -> prestate {\n     auto rslt = clone(pre);\n     relax_prestate(bit_num(fcx, c), rslt);\n     // idea is this is scoped\n@@ -209,18 +188,18 @@ fn relax_precond_block(&fn_ctxt fcx, node_id i, &block b) {\n     walk::walk_block(v, b);\n }\n \n-fn gen_poststate(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n+fn gen_poststate(&fn_ctxt fcx, node_id id, &tsconstr c) -> bool {\n     log \"gen_poststate\";\n     ret set_in_poststate(bit_num(fcx, c),\n                          node_id_to_ts_ann(fcx.ccx, id).states);\n }\n \n-fn kill_prestate(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n+fn kill_prestate(&fn_ctxt fcx, node_id id, &tsconstr c) -> bool {\n     ret clear_in_prestate(bit_num(fcx, c),\n                            node_id_to_ts_ann(fcx.ccx, id).states);\n }\n \n-fn kill_poststate(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n+fn kill_poststate(&fn_ctxt fcx, node_id id, &tsconstr c) -> bool {\n     log \"kill_poststate\";\n     ret clear_in_poststate(bit_num(fcx, c),\n                            node_id_to_ts_ann(fcx.ccx, id).states);\n@@ -233,9 +212,8 @@ fn clear_in_poststate_expr(&fn_ctxt fcx, &@expr e, &poststate t) {\n                 case (some(?i)) {\n                     alt (local_node_id_to_def(fcx, e.id)) {\n                         case (some(def_local(?d_id))) {\n-                            clear_in_poststate_(bit_num(fcx,\n-                                                        rec(id=d_id._1,\n-                                                            c=ninit(i))), t);\n+                            clear_in_poststate_(\n+                               bit_num(fcx,ninit(d_id._1, i)), t);\n                         }\n                         case (some(_)) { /* ignore args (for now...) */ }\n                         case (_) {\n@@ -252,17 +230,17 @@ fn clear_in_poststate_expr(&fn_ctxt fcx, &@expr e, &poststate t) {\n \n fn set_in_poststate_ident(&fn_ctxt fcx, &node_id id, &ident ident,\n                           &poststate t) -> bool {\n-    ret set_in_poststate_(bit_num(fcx, rec(id=id, c=ninit(ident))), t);\n+    ret set_in_poststate_(bit_num(fcx, ninit(id, ident)), t);\n }\n \n fn clear_in_poststate_ident(&fn_ctxt fcx, &node_id id, &ident ident,\n                             &node_id parent) -> bool {\n-    ret kill_poststate(fcx, parent, rec(id=id, c=ninit(ident)));\n+    ret kill_poststate(fcx, parent, ninit(id, ident));\n }\n \n fn clear_in_prestate_ident(&fn_ctxt fcx, &node_id id, &ident ident,\n                             &node_id parent) -> bool {\n-    ret kill_prestate(fcx, parent, rec(id=id, c=ninit(ident)));\n+    ret kill_prestate(fcx, parent, ninit(id, ident));\n }\n \n //"}, {"sha": "503fbf8fc121c0debbe7418a1cf7111df3325ccd", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -49,10 +49,9 @@ import states::find_pre_post_state_fn;\n fn check_unused_vars(&fn_ctxt fcx) {\n     // FIXME: could be more efficient\n     for (norm_constraint c in constraints(fcx)) {\n-        alt (c.c.node.c) {\n-            case (ninit(?v)) {\n-                if (!vec_contains(fcx.enclosing.used_vars,\n-                                  c.c.node.id)) {\n+        alt (c.c.node) {\n+            case (ninit(?id, ?v)) {\n+                if (!vec_contains(fcx.enclosing.used_vars, id)) {\n                     fcx.ccx.tcx.sess.span_warn(c.c.span,\n                                                \"Unused variable \" + v);\n                 }\n@@ -140,7 +139,7 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f,\n \n     /* Check that the return value is initialized */\n     auto post = aux::block_poststate(fcx.ccx, f.body);\n-    let aux::constr_ ret_c = rec(id=fcx.id, c=aux::ninit(fcx.name));\n+    let tsconstr ret_c = ninit(fcx.id, fcx.name);\n     if (f.proto == ast::proto_fn && !promises(fcx, post, ret_c) &&\n             !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n             f.decl.cf == return) {"}, {"sha": "5005ad5132b2c0ab176af5a12785746ad055d3fb", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -14,12 +14,11 @@ import util::common::new_def_hash;\n import syntax::codemap::span;\n import syntax::ast::respan;\n \n-type ctxt = rec(@mutable (aux::constr[]) cs, ty::ctxt tcx);\n+type ctxt = rec(@mutable (sp_constr[]) cs, ty::ctxt tcx);\n \n fn collect_local(&@local loc, &ctxt cx, &visit::vt[ctxt] v) {\n     log \"collect_local: pushing \" + loc.node.ident;\n-    *cx.cs += ~[respan(loc.span, rec(id=loc.node.id,\n-                                     c=ninit(loc.node.ident)))];\n+    *cx.cs += ~[respan(loc.span, ninit(loc.node.id, loc.node.ident))];\n     visit::visit_local(loc, cx, v);\n }\n \n@@ -34,11 +33,10 @@ fn collect_pred(&@expr e, &ctxt cx, &visit::vt[ctxt] v) {\n         // If it's a call, generate appropriate instances of the\n         // call's constraints.\n         case (expr_call(?operator, ?operands)) {\n-            for (@ty::constr_def c in constraints_expr(cx.tcx, operator)) {\n-                let aux::constr ct = respan(c.span,\n-                      rec(id=c.node.id._1,\n-                          c=aux::substitute_constr_args(cx.tcx, operands,\n-                                                        c)));\n+            for (@ty::constr c in constraints_expr(cx.tcx, operator)) {\n+                let sp_constr ct = respan(c.span,\n+                           aux::substitute_constr_args(cx.tcx, operands,\n+                                                       c));\n                 *cx.cs += ~[ct];\n             }\n         }\n@@ -61,13 +59,14 @@ fn find_locals(&ty::ctxt tcx, &_fn f, &ty_param[] tps, &span sp, &fn_ident i,\n     ret cx;\n }\n \n-fn add_constraint(&ty::ctxt tcx, aux::constr c, uint next, constr_map tbl) ->\n+fn add_constraint(&ty::ctxt tcx, sp_constr c, uint next, constr_map tbl) ->\n    uint {\n-    log aux::constraint_to_str(tcx, c) + \" |-> \" + std::uint::str(next);\n-    alt (c.node.c) {\n-        case (ninit(?i)) { tbl.insert(c.node.id, cinit(next, c.span, i)); }\n-        case (npred(?p, ?args)) {\n-            alt (tbl.find(c.node.id)) {\n+    log constraint_to_str(tcx, c) + \" |-> \" + std::uint::str(next);\n+    alt (c.node) {\n+        case (ninit(?id, ?i)) { tbl.insert(local_def(id),\n+                                           cinit(next, c.span, i)); }\n+        case (npred(?p, ?d_id, ?args)) {\n+            alt (tbl.find(d_id)) {\n                 case (some(?ct)) {\n                     alt (ct) {\n                         case (cinit(_, _, _)) {\n@@ -76,16 +75,15 @@ fn add_constraint(&ty::ctxt tcx, aux::constr c, uint next, constr_map tbl) ->\n                         }\n                         case (cpred(_, ?pds)) {\n                             *pds += ~[respan(c.span,\n-                                             rec(args=args, bit_num=next))];\n+                                            rec(args=args, bit_num=next))];\n                         }\n                     }\n                 }\n                 case (none) {\n-                    tbl.insert(c.node.id,\n-                               cpred(p,\n-                                     @mutable ~[respan(c.span,\n-                                                       rec(args=args,\n-                                                           bit_num=next))]));\n+                    let @mutable(pred_args[]) rslt = @mutable(~[respan(c.span,\n+                                                         rec(args=args,\n+                                                             bit_num=next))]);\n+                    tbl.insert(d_id, cpred(p, rslt));\n                 }\n             }\n         }\n@@ -98,22 +96,21 @@ fn add_constraint(&ty::ctxt tcx, aux::constr c, uint next, constr_map tbl) ->\n    to a bit number in the precondition/postcondition vectors */\n fn mk_fn_info(&crate_ctxt ccx, &_fn f, &ty_param[] tp,\n               &span f_sp, &fn_ident f_name, node_id id) {\n-    auto res_map = @new_int_hash[constraint]();\n+    auto res_map = @new_def_hash[constraint]();\n     let uint next = 0u;\n \n     let ctxt cx = find_locals(ccx.tcx, f, tp, f_sp, f_name, id);\n     /* now we have to add bit nums for both the constraints\n        and the variables... */\n \n-    for (aux::constr c in { *cx.cs }) {\n+    for (sp_constr c in { *cx.cs }) {\n         next = add_constraint(cx.tcx, c, next, res_map);\n     }\n     /* add a pseudo-entry for the function's return value\n        we can safely use the function's name itself for this purpose */\n \n     auto name = fn_ident_to_string(id, f_name);\n-    add_constraint(cx.tcx, respan(f_sp, rec(id=id, c=ninit(name))), next,\n-                   res_map);\n+    add_constraint(cx.tcx, respan(f_sp, ninit(id, name)), next, res_map);\n     let @mutable node_id[] v = @mutable ~[];\n     auto rslt =\n         rec(constrs=res_map,"}, {"sha": "8f802db30bd200cc80c5bc68a0f51610ec5895bc", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -76,7 +76,7 @@ fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n             // make a fake fcx\n             let @mutable node_id[] v = @mutable ~[];\n             auto fake_fcx =\n-                rec(enclosing=rec(constrs=@new_int_hash[constraint](),\n+                rec(enclosing=rec(constrs=@new_def_hash[constraint](),\n                                   num_constraints=0u,\n                                   cf=return,\n                                   used_vars=v),\n@@ -135,7 +135,7 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n                       node_id id) {\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n-    auto v_init = rec(id=l.node.id, c=ninit(l.node.ident));\n+    auto v_init = ninit(l.node.id, l.node.ident);\n     relax_precond_block(fcx, bit_num(fcx, v_init) as node_id, body);\n \n     // Hack: for-loop index variables are frequently ignored,\n@@ -160,7 +160,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n         case (none) {\n             alt (chck) {\n                 case (if_check) {\n-                    let aux::constr c = expr_to_constr(fcx.ccx.tcx, antec);\n+                    let sp_constr c = expr_to_constr(fcx.ccx.tcx, antec);\n                     gen(fcx, antec.id, c.node);\n                 }\n                 case (_) {}\n@@ -188,7 +188,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n              so that it's *not* set in the alternative. */\n             alt (chck) {\n                 case (if_check) {\n-                    let aux::constr c = expr_to_constr(fcx.ccx.tcx, antec);\n+                    let sp_constr c = expr_to_constr(fcx.ccx.tcx, antec);\n                     gen(fcx, antec.id, c.node);\n                 }\n                 case (_) {}\n@@ -219,8 +219,7 @@ fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs, node_id larger_id,\n                     set_pre_and_post(fcx.ccx, larger_id, p.precondition,\n                                      p.postcondition);\n                     gen(fcx, larger_id,\n-                        rec(id=d_id._1,\n-                            c=ninit(path_to_ident(fcx.ccx.tcx, pth))));\n+                        ninit(d_id._1, path_to_ident(fcx.ccx.tcx, pth)));\n                 }\n                 case (_) { find_pre_post_exprs(fcx, ~[lhs, rhs], larger_id); }\n             }\n@@ -256,9 +255,8 @@ fn handle_update(&fn_ctxt fcx, &@expr parent,\n                     alt (df) {\n                         case (def_local(?d_id)) {\n                             auto i =\n-                                bit_num(fcx,\n-                                 rec(id=d_id._1,\n-                                     c=ninit(path_to_ident(fcx.ccx.tcx, p))));\n+                                bit_num(fcx, ninit(d_id._1,\n+                                        path_to_ident(fcx.ccx.tcx, p)));\n                             require_and_preserve(i, expr_pp(fcx.ccx, lhs));\n                         }\n                         case (_) {}\n@@ -269,8 +267,8 @@ fn handle_update(&fn_ctxt fcx, &@expr parent,\n             gen_if_local(fcx, lhs, rhs, parent.id, lhs.id, p);\n             alt (rhs.node) {\n                 case (expr_path(?p1)) {\n-                    auto d = local_node_id_to_def_id(fcx, lhs.id);\n-                    auto d1 = local_node_id_to_def_id(fcx, rhs.id);\n+                    auto d = local_node_id_to_local_def_id(fcx, lhs.id);\n+                    auto d1 = local_node_id_to_local_def_id(fcx, rhs.id);\n                     alt (d) {\n                         case (some(?id)) {\n                             alt (d1) {\n@@ -312,13 +310,11 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n \n             find_pre_post_exprs(fcx, args, e.id);\n             /* see if the call has any constraints on its type */\n-            for (@ty::constr_def c in constraints_expr(fcx.ccx.tcx, operator))\n+            for (@ty::constr c in constraints_expr(fcx.ccx.tcx, operator))\n                 {\n                     auto i =\n-                        bit_num(fcx,\n-                                rec(id=c.node.id._1,\n-                                    c=substitute_constr_args(fcx.ccx.tcx,\n-                                                             args, c)));\n+                        bit_num(fcx, substitute_constr_args(fcx.ccx.tcx,\n+                                                             args, c));\n                     require(i, expr_pp(fcx.ccx, e));\n                 }\n \n@@ -347,8 +343,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                 case (def_local(?d_id)) {\n                     auto i =\n                         bit_num(fcx,\n-                                rec(id=d_id._1,\n-                                    c=ninit(path_to_ident(fcx.ccx.tcx, p))));\n+                          ninit(d_id._1, path_to_ident(fcx.ccx.tcx, p)));\n                     use_var(fcx, d_id._1);\n                     require_and_preserve(i, rslt);\n                 }\n@@ -547,7 +542,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             copy_pre_post(fcx.ccx, e.id, p);\n             /* predicate p holds after this expression executes */\n \n-            let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n+            let sp_constr c = expr_to_constr(fcx.ccx.tcx, p);\n             gen(fcx, e.id, c.node);\n         }\n         case (expr_if_check(?p, ?conseq, ?maybe_alt)) {\n@@ -608,17 +603,17 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s) {\n                                 case (expr_path(?p)) {\n                                     copy_in_postcond(fcx, id,\n                                       tup(alocal.node.ident,\n-                                          local_def(alocal.node.id)),\n+                                          alocal.node.id),\n                                       tup(path_to_ident(fcx.ccx.tcx, p),\n-                                          local_def(an_init.expr.id)),\n-                                             op_to_oper_ty(an_init.op));\n+                                          an_init.expr.id),\n+                                       op_to_oper_ty(an_init.op));\n                                 }\n                                 case (_) {}\n                             }\n \n                             gen(fcx, id,\n-                                rec(id=alocal.node.id,\n-                                    c=ninit(alocal.node.ident)));\n+                                ninit(alocal.node.id,\n+                                      alocal.node.ident));\n \n                             if (an_init.op == init_move &&\n                                 is_path(an_init.expr)) {"}, {"sha": "c806493bdeaa0f920e112a1b68bb2abd5424108a", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -63,8 +63,7 @@ fn seq_states(&fn_ctxt fcx, prestate pres, &(@expr)[] exprs) ->\n }\n \n fn find_pre_post_state_sub(&fn_ctxt fcx, &prestate pres, &@expr e,\n-                           node_id parent, option::t[aux::constr_] c)\n-    -> bool {\n+        node_id parent, option::t[tsconstr] c) -> bool {\n     auto changed = find_pre_post_state_expr(fcx, pres, e);\n \n     changed = set_prestate_ann(fcx.ccx, parent, pres) || changed;\n@@ -118,8 +117,8 @@ fn find_pre_post_state_two(&fn_ctxt fcx, &prestate pres, &@expr lhs,\n             gen_if_local(fcx, post, lhs);\n             alt (rhs.node) {\n                 case (expr_path(?p1)) {\n-                    auto d = local_node_id_to_def_id(fcx, lhs.id);\n-                    auto d1 = local_node_id_to_def_id(fcx, rhs.id);\n+                    auto d = local_node_id_to_local_def_id(fcx, lhs.id);\n+                    auto d1 = local_node_id_to_local_def_id(fcx, rhs.id);\n                     alt (d) {\n                         case (some(?id)) {\n                             alt (d1) {\n@@ -249,7 +248,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n             auto conseq_prestate = expr_poststate(fcx.ccx, antec);\n             alt (chk) {\n                 case (if_check) {\n-                    let aux::constr c = expr_to_constr(fcx.ccx.tcx, antec);\n+                    let sp_constr c = expr_to_constr(fcx.ccx.tcx, antec);\n                     conseq_prestate = tritv_clone(conseq_prestate);\n                     tritv_set(bit_num(fcx, c.node), conseq_prestate, ttrue);\n                 }\n@@ -387,8 +386,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n \n             alt (fcx.enclosing.cf) {\n                 case (noreturn) {\n-                    kill_poststate(fcx, e.id, rec(id=fcx.id,\n-                                                  c=ninit(fcx.name)));\n+                    kill_poststate(fcx, e.id, ninit(fcx.id, fcx.name));\n                 }\n                 case (_) { }\n             }\n@@ -555,7 +553,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         }\n         case (expr_check(_, ?p)) {\n             /* predicate p holds after this expression executes */\n-            let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n+            let sp_constr c = expr_to_constr(fcx.ccx.tcx, p);\n             ret find_pre_post_state_sub(fcx, pres, p, e.id, some(c.node));\n         }\n         case (expr_if_check(?p, ?conseq, ?maybe_alt)) {\n@@ -608,9 +606,9 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n \n                                     auto instlhs =\n                                         tup(alocal.node.ident,\n-                                            local_def(alocal.node.id));\n-                                    auto rhs_d = local_node_id_to_def_id(fcx,\n-                                                          an_init.expr.id);\n+                                            alocal.node.id);\n+                                    auto rhs_d = local_node_id_to_local_def_id\n+                                        (fcx, an_init.expr.id);\n                                     alt (rhs_d) {\n                                         case (some(?rhsid)) {\n                                             auto instrhs ="}, {"sha": "138b98b75702bf0f5d766324fed29ce957ef20bc", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 178, "deletions": 30, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -13,19 +13,15 @@ import std::option::some;\n import std::smallintmap;\n import driver::session;\n import syntax::ast;\n-import ast::def_id;\n-import ast::constr_arg_general;\n-import ast::mutability;\n-import ast::controlflow;\n-import ast::path_to_str;\n-import ast::spanned;\n+import syntax::ast::*;\n import syntax::codemap::span;\n import metadata::csearch;\n import util::common::*;\n import syntax::util::interner;\n import util::ppaux::ty_to_str;\n+import util::ppaux::ty_constr_to_str;\n import util::ppaux::mode_str_1;\n-\n+import syntax::print::pprust::*;\n \n export node_id_to_monotype;\n export node_id_to_type;\n@@ -37,7 +33,8 @@ export arg;\n export args_eq;\n export bind_params_in_type;\n export block_ty;\n-export constr_def;\n+export constr;\n+export constr_;\n export constr_general;\n export constr_table;\n export count_ty_params;\n@@ -67,6 +64,7 @@ export mk_bot;\n export mk_box;\n export mk_chan;\n export mk_char;\n+export mk_constr;\n export mk_ctxt;\n export mk_float;\n export mk_fn;\n@@ -123,6 +121,7 @@ export ty_bot;\n export ty_box;\n export ty_chan;\n export ty_char;\n+export ty_constr;\n export ty_float;\n export ty_fn;\n export ty_fn_abi;\n@@ -151,6 +150,7 @@ export ty_var_id;\n export ty_vec;\n export ty_param_substs_opt_and_ty_to_monotype;\n export ty_fn_args;\n+export type_constr;\n export type_contains_params;\n export type_contains_vars;\n export type_err;\n@@ -193,9 +193,9 @@ type method =\n         arg[] inputs,\n         t output,\n         controlflow cf,\n-        (@constr_def)[] constrs);\n+        (@constr)[] constrs);\n \n-type constr_table = hashmap[ast::node_id, constr_def[]];\n+type constr_table = hashmap[ast::node_id, constr[]];\n \n type mt = rec(t ty, ast::mutability mut);\n \n@@ -212,7 +212,7 @@ type ctxt =\n         ast_map::map items,\n         freevars::freevar_map freevars,\n \n-        constr_table fn_constrs,\n+        //        constr_table fn_constrs,\n         type_cache tcache,\n         creader_cache rcache,\n         hashmap[t, str] short_names_cache,\n@@ -265,22 +265,23 @@ tag sty {\n     ty_task;\n     ty_tup(mt[]);\n     ty_rec(field[]);\n-    ty_fn(ast::proto, arg[], t, controlflow, (@constr_def)[]);\n+    ty_fn(ast::proto, arg[], t, controlflow, (@constr)[]);\n     ty_native_fn(ast::native_abi, arg[], t);\n     ty_obj(method[]);\n     ty_res(def_id, t, t[]);\n     ty_var(int); // type variable\n     ty_param(uint); // fn/tag type param\n     ty_type;\n     ty_native(def_id);\n+    ty_constr(t, (@type_constr)[]);\n     // TODO: ty_fn_arg(t), for a possibly-aliased function argument\n }\n \n-type constr_def = spanned[constr_general[uint]];\n-\n-type constr_general[T] =\n-    rec(ast::path path, (@constr_arg_general[T])[] args, def_id id);\n-\n+// In the middle end, constraints have a def_id attached, referring\n+// to the definition of the operator in the constraint.\n+type constr_general[ARG] = spanned[constr_general_[ARG, def_id]];\n+type type_constr = constr_general[path];\n+type constr = constr_general[uint];\n \n // Data structures used in type unification\n tag type_err {\n@@ -297,6 +298,8 @@ tag type_err {\n     terr_obj_meths(ast::ident, ast::ident);\n     terr_arg_count;\n     terr_mode_mismatch(mode, mode);\n+    terr_constr_len(uint, uint);\n+    terr_constr_mismatch(@type_constr, @type_constr);\n }\n \n type ty_param_count_and_ty = tup(uint, t);\n@@ -392,7 +395,8 @@ fn mk_rcache() -> creader_cache {\n     ret map::mk_hashmap[tup(int, uint, uint), t](h, e);\n }\n \n-fn mk_ctxt(session::session s, resolve::def_map dm, constr_table cs,\n+\n+fn mk_ctxt(session::session s, resolve::def_map dm,\n            ast_map::map amap, freevars::freevar_map freevars) -> ctxt {\n     let node_type_table ntt =\n         @smallintmap::mk[ty::ty_param_substs_opt_and_ty]();\n@@ -405,7 +409,6 @@ fn mk_ctxt(session::session s, resolve::def_map dm, constr_table cs,\n             node_types=ntt,\n             items=amap,\n             freevars=freevars,\n-            fn_constrs=cs,\n             tcache=tcache,\n             rcache=mk_rcache(),\n             short_names_cache=map::mk_hashmap[ty::t,\n@@ -501,6 +504,9 @@ fn mk_raw_ty(&ctxt cx, &sty st, &option::t[str] cname) -> raw_t {\n                 derive_flags_t(cx, has_params, has_vars, tt);\n             }\n         }\n+        case (ty_constr(?tt, _)) {\n+            derive_flags_t(cx, has_params, has_vars, tt);\n+        }\n     }\n     ret rec(struct=st,\n             cname=cname,\n@@ -594,8 +600,12 @@ fn mk_imm_tup(&ctxt cx, &t[] tys) -> t {\n \n fn mk_rec(&ctxt cx, &field[] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n+fn mk_constr(&ctxt cx, &t t, &(@type_constr)[] cs) -> t {\n+    ret gen_ty(cx, ty_constr(t, cs));\n+}\n+\n fn mk_fn(&ctxt cx, &ast::proto proto, &arg[] args, &t ty, &controlflow cf,\n-         &(@constr_def)[] constrs) -> t {\n+         &(@constr)[] constrs) -> t {\n     ret gen_ty(cx, ty_fn(proto, args, ty, cf, constrs));\n }\n \n@@ -1300,6 +1310,33 @@ fn hash_type_structure(&sty st) -> uint {\n         h += h << 5u + hash_ty(subty);\n         ret h;\n     }\n+    fn hash_type_constr(uint id, &@type_constr c)\n+        -> uint {\n+        auto h = id;\n+        h += h << 5u + hash_def(h, c.node.id);\n+        ret hash_type_constr_args(h, c.node.args);\n+    }\n+    fn hash_type_constr_args(uint id, (@ty_constr_arg)[] args) -> uint {\n+        auto h = id;\n+        for (@ty_constr_arg a in args) {\n+            alt (a.node) {\n+                case (carg_base) {\n+                    h += h << 5u;\n+                }\n+                case (carg_lit(_)) {\n+                    // FIXME\n+                    fail \"lit args not implemented yet\";\n+                }\n+                case (carg_ident(?p)) {\n+                    // FIXME: Not sure what to do here.\n+                    h += h << 5u;\n+                }\n+            }\n+        }\n+        ret h;\n+    }\n+\n+\n     fn hash_fn(uint id, &arg[] args, &t rty) -> uint {\n         auto h = id;\n         for (arg a in args) { h += h << 5u + hash_ty(a.ty); }\n@@ -1371,6 +1408,13 @@ fn hash_type_structure(&sty st) -> uint {\n             for (t tp in tps) { h += h << 5u + hash_ty(tp); }\n             ret h;\n         }\n+        case (ty_constr(?t, ?cs)) {\n+            auto h = 36u;\n+            for (@type_constr c in cs) {\n+                h += h << 5u + hash_type_constr(h, c);\n+            }\n+            ret h;\n+        }\n     }\n }\n \n@@ -1392,8 +1436,8 @@ fn hash_ty(&t typ) -> uint { ret typ; }\n // users should use `eq_ty()` instead.\n fn eq_int(&uint x, &uint y) -> bool { ret x == y; }\n \n-fn arg_eq[T](&fn(&T, &T) -> bool  eq, @ast::constr_arg_general[T] a,\n-             @ast::constr_arg_general[T] b) -> bool {\n+fn arg_eq[T](&fn(&T, &T) -> bool eq, @sp_constr_arg[T] a,\n+             @sp_constr_arg[T] b) -> bool {\n     alt (a.node) {\n         case (ast::carg_base) {\n             alt (b.node) {\n@@ -1416,26 +1460,26 @@ fn arg_eq[T](&fn(&T, &T) -> bool  eq, @ast::constr_arg_general[T] a,\n     }\n }\n \n-fn args_eq[T](fn(&T, &T) -> bool eq, &(@ast::constr_arg_general[T])[] a,\n-              &(@ast::constr_arg_general[T])[] b) -> bool {\n+fn args_eq[T](fn(&T, &T) -> bool eq,\n+              &(@sp_constr_arg[T])[] a, &(@sp_constr_arg[T])[] b) -> bool {\n     let uint i = 0u;\n-    for (@ast::constr_arg_general[T] arg in a) {\n+    for (@sp_constr_arg[T] arg in a) {\n         if (!arg_eq(eq, arg, b.(i))) { ret false; }\n         i += 1u;\n     }\n     ret true;\n }\n \n-fn constr_eq(&@constr_def c, &@constr_def d) -> bool {\n+fn constr_eq(&@constr c, &@constr d) -> bool {\n     ret path_to_str(c.node.path) == path_to_str(d.node.path) &&\n             // FIXME: hack\n             args_eq(eq_int, c.node.args, d.node.args);\n }\n \n-fn constrs_eq(&(@constr_def)[] cs, &(@constr_def)[] ds) -> bool {\n+fn constrs_eq(&(@constr)[] cs, &(@constr)[] ds) -> bool {\n     if (ivec::len(cs) != ivec::len(ds)) { ret false; }\n     auto i = 0u;\n-    for (@constr_def c in cs) {\n+    for (@constr c in cs) {\n         if (!constr_eq(c, ds.(i))) { ret false; }\n         i += 1u;\n     }\n@@ -2053,6 +2097,76 @@ mod unify {\n         ret ures_err(terr_mismatch);\n     }\n \n+    // Right now this just checks that the lists of constraints are\n+    // pairwise equal.\n+    fn unify_constrs(&t base_t, (@type_constr)[] expected,\n+                     &(@type_constr)[] actual) -> result {\n+        auto expected_len = ivec::len(expected);\n+        auto actual_len = ivec::len(actual);\n+\n+        if (expected_len != actual_len) {\n+            ret ures_err(terr_constr_len(expected_len, actual_len));\n+        }\n+        auto i = 0u;\n+        auto rslt;\n+        for (@type_constr c in expected) {\n+            rslt = unify_constr(base_t, c, actual.(i));\n+            alt (rslt) {\n+                case (ures_ok(_)) { }\n+                case (ures_err(_)) { ret rslt; }\n+            }\n+            i += 1u;\n+        }\n+        ret ures_ok(base_t);\n+    }\n+    fn unify_constr(&t base_t, @type_constr expected,\n+                    &@type_constr actual_constr) -> result {\n+        auto ok_res = ures_ok(base_t);\n+        auto err_res = ures_err(terr_constr_mismatch(expected,\n+                                                     actual_constr));\n+        if (expected.node.id != actual_constr.node.id) {\n+            ret err_res;\n+        }\n+        auto expected_arg_len = ivec::len(expected.node.args);\n+        auto actual_arg_len = ivec::len(actual_constr.node.args);\n+        if (expected_arg_len != actual_arg_len) {\n+            ret err_res;\n+        }\n+        auto i = 0u;\n+        auto actual;\n+        for (@ty_constr_arg a in expected.node.args) {\n+            actual = actual_constr.node.args.(i);\n+            alt (a.node) {\n+                case (carg_base) {\n+                    alt (actual.node) {\n+                        case (carg_base) { }\n+                        case (_)         { ret err_res; }\n+                    }\n+                }\n+                case (carg_lit(?l)) {\n+                    alt (actual.node) {\n+                        case (carg_lit(?m)) {\n+                            if (l != m) { ret err_res; }\n+                        }\n+                        case (_) { ret err_res; }\n+                    }\n+                }\n+                case (carg_ident(?p)) {\n+                    alt (actual.node) {\n+                        case (carg_ident(?q)) {\n+                            if (p.node != q.node) {\n+                                ret err_res;\n+                            }\n+                        }\n+                        case (_) { ret err_res; }\n+                    }\n+                }\n+            }\n+            i += 1u;\n+        }\n+        ret ok_res;\n+    }\n+\n     // Unifies two mutability flags.\n     fn unify_mut(ast::mutability expected, ast::mutability actual) ->\n        option::t[ast::mutability] {\n@@ -2109,8 +2223,8 @@ mod unify {\n                 &t expected, &t actual, &arg[] expected_inputs,\n                 &t expected_output, &arg[] actual_inputs, &t actual_output,\n                 &controlflow expected_cf, &controlflow actual_cf,\n-                &(@constr_def)[] expected_constrs,\n-                &(@constr_def)[] actual_constrs) -> result {\n+                &(@constr)[] expected_constrs,\n+                &(@constr)[] actual_constrs) -> result {\n         if (e_proto != a_proto) { ret ures_err(terr_mismatch); }\n         alt (expected_cf) {\n             case (ast::return) { }\n@@ -2612,6 +2726,31 @@ mod unify {\n                     case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n+            case (ty::ty_constr(?expected_t, ?expected_constrs)) {\n+                // unify the base types...\n+                alt (struct(cx.tcx, actual)) {\n+                    case (ty::ty_constr(?actual_t, ?actual_constrs)) {\n+                        auto rslt = unify_step(cx, expected_t, actual_t);\n+                        alt (rslt) {\n+                            case (ures_ok(?rty)) {\n+                                // FIXME: probably too restrictive --\n+                                // requires the constraints to be\n+                                // syntactically equal\n+                                ret unify_constrs(expected,\n+                                                  expected_constrs,\n+                                                  actual_constrs);\n+                            }\n+                            case (_) { ret rslt; }\n+                        }\n+                    }\n+                    case (_) {\n+                        // If the actual type is *not* a constrained type,\n+                        // then we go ahead and just ignore the constraints on\n+                        // the expected type. typestate handles the rest.\n+                        ret unify_step(cx, expected_t, actual);\n+                    }\n+                }\n+            }\n         }\n     }\n     fn unify(&t expected, &t actual, &@var_bindings vb, &ty_ctxt tcx) ->\n@@ -2730,6 +2869,15 @@ fn type_err_to_str(&ty::type_err err) -> str {\n                 + mode_str_1(a_mode);\n             fail;\n         }\n+        case (terr_constr_len(?e_len, ?a_len)) {\n+            ret \"Expected a type with \" + uint::str(e_len) + \" constraints, \\\n+              but found one with \" + uint::str(a_len) + \" constraints\";\n+        }\n+        case (terr_constr_mismatch(?e_constr, ?a_constr)) {\n+            ret \"Expected a type with constraint \"\n+              + ty_constr_to_str(e_constr) + \" but found one with constraint \"\n+                + ty_constr_to_str(a_constr);\n+        }\n     }\n }\n "}, {"sha": "4cae44ce142694bcdabd949041426c36aedd4218", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -2,7 +2,6 @@\n import syntax::ast;\n import ast::mutability;\n import ast::local_def;\n-import ast::path_to_str;\n import ast::respan;\n import ast::spanned;\n import syntax::walk;\n@@ -47,6 +46,7 @@ import std::option::some;\n import std::option::from_maybe;\n import std::smallintmap;\n import middle::tstate::ann::ts_ann;\n+import syntax::print::pprust::*;\n \n export check_crate;\n \n@@ -396,6 +396,13 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             }\n             typ = ty::mk_obj(tcx, ty::sort_methods(tmeths));\n         }\n+        case (ast::ty_constr(?t, ?cs)) {\n+            auto out_cs = ~[];\n+            for (@ast::ty_constr constr in cs) {\n+                out_cs += ~[ast_constr_to_constr(tcx, constr)];\n+            }\n+            typ = ty::mk_constr(tcx, ast_ty_to_ty(tcx, getter, t), out_cs);\n+        }\n     }\n     alt (cname) {\n         case (none) {/* no-op */ }\n@@ -2519,18 +2526,18 @@ fn get_obj_info(&@crate_ctxt ccx) -> option::t[obj_info] {\n     ret ivec::last[obj_info](ccx.obj_infos);\n }\n \n-fn ast_constr_to_constr(ty::ctxt tcx, &@ast::constr c)\n-    -> @ty::constr_def {\n+fn ast_constr_to_constr[T](ty::ctxt tcx, &@ast::constr_general[T] c)\n+    -> @ty::constr_general[T] {\n     alt (tcx.def_map.find(c.node.id)) {\n         case (some(ast::def_fn(?pred_id, ast::pure_fn))) {\n             ret @respan(c.span, rec(path=c.node.path, args=c.node.args,\n                                     id=pred_id));\n         }\n         case (_) {\n             tcx.sess.span_fatal(c.span, \"Predicate \"\n-                              + path_to_str(c.node.path)\n-                              + \" is unbound or bound to a non-function or an\\\n-                                impure function\");\n+                      + path_to_str(c.node.path)\n+                      + \" is unbound or bound to a non-function or an \\\n+                        impure function\");\n         }\n     }\n }"}, {"sha": "e2b2e53df07ed1947c615ae88846e970df857e1c", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -444,7 +444,7 @@ tag ty_ {\n     ty_obj(ty_method[]);\n     ty_path(path, node_id);\n     ty_type;\n-    ty_constr(@ty, (@constr)[]);\n+    ty_constr(@ty, (@ty_constr)[]);\n     ty_mac(mac);\n }\n \n@@ -459,16 +459,26 @@ declarations, and ident for uses.\n */\n tag constr_arg_general_[T] { carg_base; carg_ident(T); carg_lit(@lit); }\n \n-type constr_arg = constr_arg_general[uint];\n+type fn_constr_arg = constr_arg_general_[uint];\n+type sp_constr_arg[T] = spanned[constr_arg_general_[T]];\n+type ty_constr_arg = sp_constr_arg[path];\n+type constr_arg = spanned[fn_constr_arg];\n \n-type constr_arg_general[T] = spanned[constr_arg_general_[T]];\n+// Constrained types' args are parameterized by paths, since\n+// we refer to paths directly and not by indices.\n+// The implicit root of such path, in the constraint-list for a\n+// constrained type, is * (referring to the base record)\n \n-type constr_ = rec(path path,\n-                   (@constr_arg_general[uint])[] args,\n-                   node_id id);\n-\n-type constr = spanned[constr_];\n+type constr_general_[ARG, ID] = rec(path path,\n+     (@(spanned[constr_arg_general_[ARG]]))[] args, ID id);\n \n+// In the front end, constraints have a node ID attached.\n+// Typeck turns this to a def_id, using the output of resolve.\n+type constr_general[ARG] = spanned[constr_general_[ARG, node_id]];\n+type constr_ = constr_general_[uint, node_id];\n+type constr = spanned[constr_general_[uint, node_id]];\n+type ty_constr_ = ast::constr_general_[ast::path, ast::node_id];\n+type ty_constr = spanned[ty_constr_];\n \n /* The parser generates ast::constrs; resolve generates\n  a mapping from each function to a list of ty::constr_defs,\n@@ -671,19 +681,6 @@ fn ternary_to_if(&@expr e) -> @ast::expr {\n     }\n }\n \n-// Path stringification\n-fn path_to_str(&ast::path pth) -> str {\n-    auto result = str::connect_ivec(pth.node.idents, \"::\");\n-    if (ivec::len[@ast::ty](pth.node.types) > 0u) {\n-        fn f(&@ast::ty t) -> str { ret print::pprust::ty_to_str(*t); }\n-        result += \"[\";\n-        result += str::connect_ivec(ivec::map(f, pth.node.types), \",\");\n-        result += \"]\";\n-    }\n-    ret result;\n-}\n-\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "a12a7da4aeffb9242fe62b59bbbb43448d935307", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -35,7 +35,7 @@ type ast_fold_precursor =\n         fn (&decl_ d, ast_fold) -> decl_                  fold_decl,\n         fn (&expr_ e, ast_fold) -> expr_                  fold_expr,\n         fn (&ty_ t, ast_fold) -> ty_                      fold_ty,\n-        fn (&constr_ c, ast_fold) -> constr_              fold_constr,\n+        fn (&ast::constr_ c, ast_fold) -> constr_              fold_constr,\n         fn (&_fn f, ast_fold) -> _fn                      fold_fn,\n         fn (&_mod m, ast_fold) -> _mod                    fold_mod,\n         fn (&native_mod, ast_fold) -> native_mod          fold_native_mod,\n@@ -473,7 +473,7 @@ fn noop_fold_ty(&ty_ t, ast_fold fld) -> ty_ {\n }\n \n fn noop_fold_constr(&constr_ c, ast_fold fld) -> constr_ {\n-    ret rec(path=fld.fold_path(c.path), args=c.args, id=c.id);\n+    rec(path=fld.fold_path(c.path), args=c.args, id=c.id)\n }\n \n // functions just don't get spans, for some reason\n@@ -664,7 +664,8 @@ fn make_fold(&ast_fold_precursor afp) -> ast_fold {\n     fn f_ty(&ast_fold_precursor afp, ast_fold f, &@ty x) -> @ty {\n         ret @rec(node=afp.fold_ty(x.node, f), span=x.span);\n     }\n-    fn f_constr(&ast_fold_precursor afp, ast_fold f, &@constr x) -> @constr {\n+    fn f_constr(&ast_fold_precursor afp, ast_fold f, &@ast::constr x)\n+        -> @ast::constr {\n         ret @rec(node=afp.fold_constr(x.node, f), span=x.span);\n     }\n     fn f_fn(&ast_fold_precursor afp, ast_fold f, &_fn x) -> _fn {"}, {"sha": "724fcd75386bbb81d30a16bd0371b2aa1d8ac281", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 71, "deletions": 41, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -14,6 +14,8 @@ import ex=ext::base;\n import codemap::span;\n import std::map::new_str_hash;\n import util::interner;\n+import ast::node_id;\n+import ast::spanned;\n \n tag restriction { UNRESTRICTED; RESTRICT_NO_CALL_EXPRS; }\n \n@@ -22,9 +24,9 @@ tag file_type { CRATE_FILE; SOURCE_FILE; }\n tag ty_or_bang { a_ty(@ast::ty); a_bang; }\n \n type parse_sess = @rec(codemap::codemap cm,\n-                       mutable ast::node_id next_id);\n+                       mutable node_id next_id);\n \n-fn next_node_id(&parse_sess sess) -> ast::node_id {\n+fn next_node_id(&parse_sess sess) -> node_id {\n     auto rv = sess.next_id;\n     sess.next_id += 1;\n     ret rv;\n@@ -51,7 +53,7 @@ type parser =\n         fn get_bad_expr_words() -> hashmap[str, ()] ;\n         fn get_chpos() -> uint ;\n         fn get_byte_pos() -> uint ;\n-        fn get_id() -> ast::node_id ;\n+        fn get_id() -> node_id ;\n         fn get_sess() -> parse_sess;\n     };\n \n@@ -116,7 +118,7 @@ fn new_parser(parse_sess sess, ast::crate_cfg cfg, lexer::reader rdr,\n         fn get_bad_expr_words() -> hashmap[str, ()] { ret bad_words; }\n         fn get_chpos() -> uint { ret rdr.get_chpos(); }\n         fn get_byte_pos() -> uint { ret rdr.get_byte_pos(); }\n-        fn get_id() -> ast::node_id { ret next_node_id(sess); }\n+        fn get_id() -> node_id { ret next_node_id(sess); }\n         fn get_sess() -> parse_sess { ret sess; }\n     }\n \n@@ -188,7 +190,7 @@ fn expect(&parser p, token::token t) {\n     }\n }\n \n-fn spanned[T](uint lo, uint hi, &T node) -> ast::spanned[T] {\n+fn spanned[T](uint lo, uint hi, &T node) -> spanned[T] {\n     ret rec(node=node, span=rec(lo=lo, hi=hi));\n }\n \n@@ -261,7 +263,9 @@ fn parse_ty_fn(ast::proto proto, &parser p, uint lo) -> ast::ty_ {\n     auto inputs =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                        parse_fn_input_ty, p);\n-    auto constrs = parse_constrs(~[], p);\n+    // FIXME: there's no syntax for this right now anyway\n+    //  auto constrs = parse_constrs(~[], p);\n+    let (@ast::constr)[] constrs = ~[];\n     let @ast::ty output;\n     auto cf = ast::return;\n     if (p.peek() == token::RARROW) {\n@@ -275,7 +279,7 @@ fn parse_ty_fn(ast::proto proto, &parser p, uint lo) -> ast::ty_ {\n             }\n         }\n     } else { output = @spanned(lo, inputs.span.hi, ast::ty_nil); }\n-    ret ast::ty_fn(proto, inputs.node, output, cf, constrs.node);\n+    ret ast::ty_fn(proto, inputs.node, output, cf, constrs);\n }\n \n fn parse_proto(&parser p) -> ast::proto {\n@@ -336,6 +340,20 @@ fn ident_index(&parser p, &ast::arg[] args, &ast::ident i) -> uint {\n     p.fatal(\"Unbound variable \" + i + \" in constraint arg\");\n }\n \n+fn parse_type_constr_arg(&parser p) -> @ast::ty_constr_arg {\n+    auto sp = p.get_span();\n+    auto carg = ast::carg_base;\n+    expect(p, token::BINOP(token::STAR));\n+    if (p.peek() == token::DOT) {\n+        // \"*...\" notation for record fields\n+        p.bump();\n+        let ast::path pth = parse_path(p);\n+        carg = ast::carg_ident(pth);\n+    }\n+    // No literals yet, I guess?\n+    ret @rec(node=carg, span=sp);\n+}\n+\n fn parse_constr_arg(&ast::arg[] args, &parser p) -> @ast::constr_arg {\n     auto sp = p.get_span();\n     auto carg = ast::carg_base;\n@@ -355,43 +373,39 @@ fn parse_ty_constr(&ast::arg[] fn_args, &parser p) -> @ast::constr {\n     let rec((@ast::constr_arg)[] node, span span) args =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA), pf,\n                        p);\n-    // FIXME fix the def_id\n-\n     ret @spanned(lo, args.span.hi,\n                  rec(path=path, args=args.node, id=p.get_id()));\n }\n \n-\n-// Use the args list to translate each bound variable\n-// mentioned in a constraint to an arg index.\n-// Seems weird to do this in the parser, but I'm not sure how else to.\n-fn parse_constrs(&ast::arg[] args, &parser p)\n-        -> ast::spanned[(@ast::constr)[]] {\n+fn parse_constr_in_type(&parser p) -> @ast::ty_constr {\n     auto lo = p.get_lo_pos();\n-    auto hi = p.get_hi_pos();\n-    let (@ast::constr)[] constrs = ~[];\n-    if (p.peek() == token::COLON) {\n-        p.bump();\n-        while (true) {\n-            auto constr = parse_ty_constr(args, p);\n-            hi = constr.span.hi;\n-            constrs += ~[constr];\n-            if (p.peek() == token::COMMA) { p.bump(); } else { break; }\n-        }\n-    }\n-    ret spanned(lo, hi, constrs);\n+    auto path = parse_path(p);\n+    let (@ast::ty_constr_arg)[] args =\n+        (parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                        parse_type_constr_arg, p)).node;\n+    auto hi = p.get_lo_pos();\n+    let ast::ty_constr_ tc = rec(path=path, args=args, id=p.get_id());\n+    ret @spanned(lo, hi, tc);\n }\n \n-fn parse_ty_constrs(@ast::ty t, &parser p) -> @ast::ty {\n-    if (p.peek() == token::COLON) {\n-        auto constrs = parse_constrs(~[], p);\n-        ret @spanned(t.span.lo, constrs.span.hi,\n-                     ast::ty_constr(t, constrs.node));\n+\n+fn parse_constrs[T](fn(&parser p) ->\n+                    (@ast::constr_general[T]) pser, &parser p)\n+    ->  (@ast::constr_general[T])[] {\n+    let (@ast::constr_general[T])[] constrs = ~[];\n+    while (true) {\n+        auto constr = pser(p);\n+        constrs += ~[constr];\n+        if (p.peek() == token::COMMA) { p.bump(); } else { break; }\n     }\n-    ret t;\n+    constrs\n+}\n+\n+fn parse_type_constraints(&parser p) -> (@ast::ty_constr)[] {\n+    ret parse_constrs(parse_constr_in_type, p);\n }\n \n-fn parse_ty_postfix(@ast::ty orig_t, &parser p) -> @ast::ty {\n+fn parse_ty_postfix(ast::ty_ orig_t, &parser p) -> @ast::ty {\n     auto lo = p.get_lo_pos();\n     if (p.peek() == token::LBRACKET) {\n         p.bump();\n@@ -413,7 +427,7 @@ fn parse_ty_postfix(@ast::ty orig_t, &parser p) -> @ast::ty {\n             auto seq = parse_seq_to_end(token::RBRACKET,\n                                              some(token::COMMA), parse_ty, p);\n \n-            alt (orig_t.node) {\n+            alt (orig_t) {\n                 case (ast::ty_path(?pth, ?ann)) {\n                     auto hi = p.get_hi_pos();\n                     ret @spanned(lo, hi,\n@@ -432,10 +446,11 @@ fn parse_ty_postfix(@ast::ty orig_t, &parser p) -> @ast::ty {\n \n         expect(p, token::RBRACKET);\n         auto hi = p.get_hi_pos();\n-        auto t = ast::ty_ivec(rec(ty=orig_t, mut=mut));\n-        ret parse_ty_postfix(@spanned(lo, hi, t), p);\n+        // FIXME: spans are probably wrong\n+        auto t = ast::ty_ivec(rec(ty=@spanned(lo, hi, orig_t), mut=mut));\n+        ret parse_ty_postfix(t, p);\n     }\n-    ret parse_ty_constrs(orig_t, p);\n+    ret @spanned(lo, p.get_lo_pos(), orig_t);\n }\n \n fn parse_ty_or_bang(&parser p) -> ty_or_bang {\n@@ -528,7 +543,15 @@ fn parse_ty(&parser p) -> @ast::ty {\n             parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                            parse_ty_field, p);\n         hi = elems.span.hi;\n+        // possible constrs\n+        // FIXME: something seems dodgy or at least repetitive\n+        // about how constrained types get parsed\n         t = ast::ty_rec(elems.node);\n+        if (p.peek() == token::COLON) {\n+            p.bump();\n+            t = ast::ty_constr(@spanned(lo, hi, t),\n+                               parse_type_constraints(p));\n+        }\n     } else if (eat_word(p, \"fn\")) {\n         auto flo = p.get_last_lo_pos();\n         t = parse_ty_fn(ast::proto_fn, p, flo);\n@@ -559,7 +582,7 @@ fn parse_ty(&parser p) -> @ast::ty {\n         t = ast::ty_path(path, p.get_id());\n         hi = path.span.hi;\n     } else { p.fatal(\"expecting type\"); t = ast::ty_nil; fail; }\n-    ret parse_ty_postfix(@spanned(lo, hi, t), p);\n+    ret parse_ty_postfix(t, p);\n }\n \n fn parse_arg(&parser p) -> ast::arg {\n@@ -593,7 +616,7 @@ fn parse_seq_to_end[T](token::token ket, option::t[token::token] sep,\n \n fn parse_seq[T](token::token bra, token::token ket,\n                      option::t[token::token] sep,\n-                     fn(&parser)->T  f, &parser p) -> ast::spanned[T[]] {\n+                     fn(&parser)->T  f, &parser p) -> spanned[T[]] {\n     auto lo = p.get_lo_pos();\n     expect(p, bra);\n     auto result = parse_seq_to_end[T](ket, sep, f, p);\n@@ -1739,7 +1762,14 @@ fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                        parse_arg, p);\n     let ty_or_bang rslt;\n-    auto constrs = parse_constrs(inputs.node, p).node;\n+// Use the args list to translate each bound variable\n+// mentioned in a constraint to an arg index.\n+// Seems weird to do this in the parser, but I'm not sure how else to.\n+    auto constrs = ~[];\n+    if (p.peek() == token::COLON) {\n+        p.bump();\n+        constrs = parse_constrs(bind parse_ty_constr(inputs.node,_), p);\n+    }\n     if (p.peek() == token::RARROW) {\n         p.bump();\n         rslt = parse_ty_or_bang(p);"}, {"sha": "6d79acd64a7cd744c1c2fd51bcd217bb72dd8c31", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -332,7 +332,7 @@ fn print_type(&ps s, &ast::ty ty) {\n             space(s.s);\n             word(s.s, \":\");\n             space(s.s);\n-            word(s.s, ast_constrs_str(cs));\n+            word(s.s, ast_ty_constrs_str(cs));\n         }\n     }\n     end(s);\n@@ -1521,10 +1521,10 @@ fn next_comment(&ps s) -> option::t[lexer::cmnt] {\n // Removing the aliases from the type of f in the next two functions\n // triggers memory corruption, but I haven't isolated the bug yet. FIXME\n fn constr_args_to_str[T](&fn(&T) -> str f,\n-                         &(@ast::constr_arg_general[T])[] args) -> str {\n+                         &(@ast::sp_constr_arg[T])[] args) -> str {\n     auto comma = false;\n     auto s = \"(\";\n-    for (@ast::constr_arg_general[T] a in args) {\n+    for (@ast::sp_constr_arg[T] a in args) {\n         if (comma) { s += \", \"; } else { comma = true; }\n         s += constr_arg_to_str[T](f, a.node);\n     }\n@@ -1547,10 +1547,11 @@ fn constr_arg_to_str[T](&fn(&T) -> str f, &ast::constr_arg_general_[T] c) ->\n fn uint_to_str(&uint i) -> str { ret uint::str(i); }\n \n fn ast_constr_to_str(&@ast::constr c) -> str {\n-    ret ast::path_to_str(c.node.path) +\n-        constr_args_to_str(uint_to_str, c.node.args);\n+    ret path_to_str(c.node.path) +\n+          constr_args_to_str(uint_to_str, c.node.args);\n }\n \n+// FIXME: fix repeated code\n fn ast_constrs_str(&(@ast::constr)[] constrs) -> str {\n     auto s = \"\";\n     auto colon = true;\n@@ -1568,6 +1569,22 @@ fn proto_to_str(&ast::proto p) -> str {\n     };\n }\n \n+fn ty_constr_to_str(&@ast::ty_constr c) -> str {\n+    ret path_to_str(c.node.path) +\n+          constr_args_to_str[ast::path](path_to_str, c.node.args);\n+}\n+\n+\n+fn ast_ty_constrs_str(&(@ast::ty_constr)[] constrs) -> str {\n+    auto s = \"\";\n+    auto colon = true;\n+    for (@ast::ty_constr c in constrs) {\n+        if (colon) { s += \" : \"; colon = false; } else { s += \", \"; }\n+        s += ty_constr_to_str(c);\n+    }\n+    ret s;\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "afb965bb4960d9317ee585e3251b52e50fd7c2aa", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -30,7 +30,9 @@ type visitor[E] =\n          fn(&@decl, &E, &vt[E])  visit_decl,\n          fn(&@expr, &E, &vt[E])  visit_expr,\n          fn(&@ty, &E, &vt[E])  visit_ty,\n-         fn(&@constr, &E, &vt[E])  visit_constr,\n+         // takes the components so that one function can be\n+         // generic over constr and ty_constr\n+         fn(&path, &span, node_id, &E, &vt[E])  visit_constr,\n          fn(&_fn, &ty_param[], &span, &fn_ident, node_id, &E, &vt[E])\n              visit_fn);\n \n@@ -47,7 +49,7 @@ fn default_visitor[E]() -> visitor[E] {\n              visit_decl=bind visit_decl[E](_, _, _),\n              visit_expr=bind visit_expr[E](_, _, _),\n              visit_ty=bind visit_ty[E](_, _, _),\n-             visit_constr=bind visit_constr[E](_, _, _),\n+             visit_constr=bind visit_constr[E](_, _, _, _, _),\n              visit_fn=bind visit_fn[E](_, _, _, _, _, _, _));\n }\n \n@@ -160,7 +162,8 @@ fn visit_ty[E](&@ty t, &E e, &vt[E] v) {\n         }\n         case (ty_fn(_, ?args, ?out, _, ?constrs)) {\n             for (ty_arg a in args) { v.visit_ty(a.node.ty, e, v); }\n-            for (@constr c in constrs) { v.visit_constr(c, e, v); }\n+            for (@constr c in constrs) { v.visit_constr(c.node.path,\n+                                            c.span, c.node.id, e, v); }\n             v.visit_ty(out, e, v);\n         }\n         case (ty_obj(?tmeths)) {\n@@ -175,7 +178,12 @@ fn visit_ty[E](&@ty t, &E e, &vt[E] v) {\n             for (@ty tp in p.node.types) { v.visit_ty(tp, e, v); }\n         }\n         case (ty_type)          { /* no-op */ }\n-        case (ty_constr(?t, _)) { v.visit_ty(t, e, v); }\n+        case (ty_constr(?t, ?cs)) {\n+            v.visit_ty(t, e, v);\n+            for (@spanned[constr_general_[path, node_id]] tc in cs) {\n+                v.visit_constr(tc.node.path, tc.span, tc.node.id, e, v);\n+            }\n+        }\n     }\n }\n \n@@ -186,7 +194,7 @@ fn visit_ty_opt[E](&option::t[@ty] ot, &E e, &vt[E] v) {\n     }\n }\n \n-fn visit_constr[E](&@constr c, &E e, &vt[E] v) {\n+fn visit_constr[E](&path operator, &span sp, node_id id, &E e, &vt[E] v) {\n     // default\n \n }\n@@ -214,7 +222,9 @@ fn visit_native_item[E](&@native_item ni, &E e, &vt[E] v) {\n \n fn visit_fn_decl[E](&fn_decl fd, &E e, &vt[E] v) {\n     for (arg a in fd.inputs) { v.visit_ty(a.ty, e, v); }\n-    for (@constr c in fd.constraints) { v.visit_constr(c, e, v); }\n+    for (@constr c in fd.constraints) {\n+        v.visit_constr(c.node.path, c.span, c.node.id, e, v);\n+    }\n     v.visit_ty(fd.output, e, v);\n }\n "}, {"sha": "da76e7822ae147868b8af05d30f09663a4f36b6a", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -9,6 +9,8 @@ import middle::ty::*;\n import metadata::encoder;\n import syntax::print::pp;\n import syntax::print::pprust;\n+import syntax::print::pprust::path_to_str;\n+import syntax::print::pprust::constr_args_to_str;\n import pp::word;\n import pp::eof;\n import pp::zerobreak;\n@@ -46,7 +48,7 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n     }\n     fn fn_to_str(&ctxt cx, ast::proto proto, option::t[ast::ident] ident,\n                  &arg[] inputs, t output, ast::controlflow cf,\n-                 &(@constr_def)[] constrs) -> str {\n+                 &(@constr)[] constrs) -> str {\n         auto s;\n         alt (proto) {\n             case (ast::proto_iter) { s = \"iter\"; }\n@@ -154,21 +156,27 @@ fn ty_to_short_str(&ctxt cx, t typ) -> str {\n     ret s;\n }\n \n-fn constr_to_str(&@constr_def c) -> str {\n-    ret ast::path_to_str(c.node.path) +\n+fn constr_to_str(&@constr c) -> str {\n+    ret path_to_str(c.node.path) +\n         pprust::constr_args_to_str(pprust::uint_to_str, c.node.args);\n }\n \n-fn constrs_str(&(@constr_def)[] constrs) -> str {\n+fn constrs_str(&(@constr)[] constrs) -> str {\n     auto s = \"\";\n     auto colon = true;\n-    for (@constr_def c in constrs) {\n+    for (@constr c in constrs) {\n         if (colon) { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += constr_to_str(c);\n     }\n     ret s;\n }\n \n+fn ty_constr_to_str[Q](&@ast::spanned[ast::constr_general_[ast::path,Q]]\n+                       c) -> str {\n+    ret path_to_str(c.node.path) +\n+          constr_args_to_str[ast::path](path_to_str, c.node.args);\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "036d41ad5d4ce8b16be9a6347d1b740fda5c8106", "filename": "src/test/compile-fail/constrained-type-missing-check.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Ftest%2Fcompile-fail%2Fconstrained-type-missing-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Ftest%2Fcompile-fail%2Fconstrained-type-missing-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconstrained-type-missing-check.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -0,0 +1,25 @@\n+// -*- rust -*-\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// error-pattern:Unsatisfied precondition\n+\n+tag list {\n+  cons(int,@list);\n+  nil();\n+}\n+\n+type bubu = rec(int x, int y);\n+\n+pred less_than(int x, int y) -> bool { ret x < y; }\n+\n+type ordered_range = rec(int low, int high) : less_than(*.low, *.high);\n+\n+fn main() {\n+// Should fail to compile, b/c we're not doing the check\n+// explicitly that a < b\n+  let int a = 1;\n+  let int b = 2;\n+  let ordered_range c = rec(low=a, high=b);\n+  log c.low;\n+}"}, {"sha": "d3003e8f540b03e230797b94afc5024869783279", "filename": "src/test/run-pass/constrained-type.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Ftest%2Frun-pass%2Fconstrained-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4aeef78bcc8e03ef9275e7652f91b936f5dec6/src%2Ftest%2Frun-pass%2Fconstrained-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstrained-type.rs?ref=bd4aeef78bcc8e03ef9275e7652f91b936f5dec6", "patch": "@@ -1,19 +1,14 @@\n // xfail-stage0\n-// xfail-stage1\n-// xfail-stage2\n // -*- rust -*-\n \n-// Reported as issue #141, as a parse error. Ought to work in full though.\n-\n tag list {\n   cons(int,@list);\n   nil();\n }\n \n type bubu = rec(int x, int y);\n \n-\n-fn less_than(int x, int y) -> bool { ret x < y; }\n+pred less_than(int x, int y) -> bool { ret x < y; }\n \n type ordered_range = rec(int low, int high) : less_than(*.low, *.high);\n "}]}