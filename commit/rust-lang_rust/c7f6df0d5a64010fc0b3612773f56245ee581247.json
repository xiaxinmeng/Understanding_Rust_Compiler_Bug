{"sha": "c7f6df0d5a64010fc0b3612773f56245ee581247", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZjZkZjBkNWE2NDAxMGZjMGIzNjEyNzczZjU2MjQ1ZWU1ODEyNDc=", "commit": {"author": {"name": "Jon Gjengset", "email": "jon@thesquareplanet.com", "date": "2019-09-28T13:25:47Z"}, "committer": {"name": "Jon Gjengset", "email": "jon@thesquareplanet.com", "date": "2019-09-28T13:25:47Z"}, "message": "Merge branch 'master' into format-temporaries", "tree": {"sha": "e0551931779455fb745309d57709124c255c061c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0551931779455fb745309d57709124c255c061c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7f6df0d5a64010fc0b3612773f56245ee581247", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7f6df0d5a64010fc0b3612773f56245ee581247", "html_url": "https://github.com/rust-lang/rust/commit/c7f6df0d5a64010fc0b3612773f56245ee581247", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7f6df0d5a64010fc0b3612773f56245ee581247/comments", "author": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "html_url": "https://github.com/rust-lang/rust/commit/4d34ce2c2515a429bea325b93aea332ac8d6a7b9"}, {"sha": "f3c8eba643a815d720e7f20699b3dca144c845c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c8eba643a815d720e7f20699b3dca144c845c4", "html_url": "https://github.com/rust-lang/rust/commit/f3c8eba643a815d720e7f20699b3dca144c845c4"}], "stats": {"total": 7239, "additions": 619, "deletions": 6620}, "files": [{"sha": "a2e3c581eabba32aa116add9c703e3994c988673", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -69,6 +69,7 @@ David Manescu <david.manescu@gmail.com> <dman2626@uni.sydney.edu.au>\n David Ross <daboross@daboross.net>\n Derek Chiang <derekchiang93@gmail.com> Derek Chiang (Enchi Jiang) <derekchiang93@gmail.com>\n Diggory Hardy <diggory.hardy@gmail.com> Diggory Hardy <github@dhardy.name>\n+Dustin Bensing <dustin.bensing@googlemail.com>\n Dylan Braithwaite <dylanbraithwaite1@gmail.com> <mail@dylanb.me>\n Dzmitry Malyshau <kvarkus@gmail.com>\n E. Dunham <edunham@mozilla.com> edunham <edunham@mozilla.com>"}, {"sha": "5a92011d57033377abb7e80c56bc0b2016bee662", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -534,7 +534,7 @@ name = \"compiletest\"\n version = \"0.0.0\"\n dependencies = [\n  \"diff\",\n- \"env_logger 0.6.2\",\n+ \"env_logger 0.7.0\",\n  \"getopts\",\n  \"lazy_static 1.3.0\",\n  \"libc\",\n@@ -3337,17 +3337,6 @@ dependencies = [\n  \"core\",\n ]\n \n-[[package]]\n-name = \"rustc_ast_borrowck\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"graphviz\",\n- \"log\",\n- \"rustc\",\n- \"rustc_data_structures\",\n- \"syntax_pos\",\n-]\n-\n [[package]]\n name = \"rustc_codegen_llvm\"\n version = \"0.0.0\"\n@@ -3420,12 +3409,11 @@ dependencies = [\n name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n- \"env_logger 0.6.2\",\n+ \"env_logger 0.7.0\",\n  \"graphviz\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n  \"rustc\",\n- \"rustc_ast_borrowck\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -3483,7 +3471,6 @@ dependencies = [\n  \"once_cell\",\n  \"rustc\",\n  \"rustc-rayon\",\n- \"rustc_ast_borrowck\",\n  \"rustc_codegen_ssa\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\","}, {"sha": "e6512bb6f6de9c42a0c28e5fd15499c5395704fc", "filename": "RELEASES.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -47,8 +47,6 @@ Stabilized APIs\n - [`<*mut T>::cast`]\n - [`Duration::as_secs_f32`]\n - [`Duration::as_secs_f64`]\n-- [`Duration::div_duration_f32`]\n-- [`Duration::div_duration_f64`]\n - [`Duration::div_f32`]\n - [`Duration::div_f64`]\n - [`Duration::from_secs_f32`]\n@@ -100,8 +98,6 @@ Compatibility Notes\n [`<*mut T>::cast`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.cast\n [`Duration::as_secs_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f32\n [`Duration::as_secs_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f64\n-[`Duration::div_duration_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_duration_f32\n-[`Duration::div_duration_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_duration_f64\n [`Duration::div_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_f32\n [`Duration::div_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_f64\n [`Duration::from_secs_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_secs_f32"}, {"sha": "ddf012d15029ae090e7e634fdad5245cf17dd44d", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -580,15 +580,14 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(map_get_key_value)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.get_key_value(&1), Some((&1, &\"a\")));\n     /// assert_eq!(map.get_key_value(&2), None);\n     /// ```\n-    #[unstable(feature = \"map_get_key_value\", issue = \"49347\")]\n+    #[stable(feature = \"map_get_key_value\", since = \"1.40.0\")]\n     pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n         where K: Borrow<Q>,\n               Q: Ord"}, {"sha": "be057ed6d59a758dc7c017a7fbb006fce704cbc8", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -369,6 +369,8 @@\n //! [drop-guarantee]: #drop-guarantee\n //! [`poll`]: ../../std/future/trait.Future.html#tymethod.poll\n //! [`Pin::get_unchecked_mut`]: struct.Pin.html#method.get_unchecked_mut\n+//! [`bool`]: ../../std/primitive.bool.html\n+//! [`i32`]: ../../std/primitive.i32.html\n \n #![stable(feature = \"pin\", since = \"1.33.0\")]\n "}, {"sha": "5d06f62f4461673bd8ceed99a219d51cf4d32ec3", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -86,7 +86,6 @@ macro_rules! arena_types {\n                     rustc::infer::canonical::QueryResponse<'tcx, rustc::ty::Ty<'tcx>>\n                 >,\n             [few] crate_inherent_impls: rustc::ty::CrateInherentImpls,\n-            [decode] borrowck: rustc::middle::borrowck::BorrowCheckResult,\n             [few] upstream_monomorphizations:\n                 rustc::util::nodemap::DefIdMap<\n                     rustc_data_structures::fx::FxHashMap<"}, {"sha": "ee22d0b755a097565df5b53cc4db22c2e5da4922", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,87 +0,0 @@\n-use rustc_data_structures::fx::FxHashMap;\n-use std::cell::RefCell;\n-use std::hash::Hash;\n-use std::marker::PhantomData;\n-use crate::util::common::MemoizationMap;\n-\n-use super::{DepKind, DepNodeIndex, DepGraph};\n-\n-/// A DepTrackingMap offers a subset of the `Map` API and ensures that\n-/// we make calls to `read` and `write` as appropriate. We key the\n-/// maps with a unique type for brevity.\n-pub struct DepTrackingMap<M: DepTrackingMapConfig> {\n-    phantom: PhantomData<M>,\n-    graph: DepGraph,\n-    map: FxHashMap<M::Key, (M::Value, DepNodeIndex)>,\n-}\n-\n-pub trait DepTrackingMapConfig {\n-    type Key: Eq + Hash + Clone;\n-    type Value: Clone;\n-    fn to_dep_kind() -> DepKind;\n-}\n-\n-impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n-    pub fn new(graph: DepGraph) -> DepTrackingMap<M> {\n-        DepTrackingMap {\n-            phantom: PhantomData,\n-            graph,\n-            map: Default::default(),\n-        }\n-    }\n-}\n-\n-impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n-    type Key = M::Key;\n-    type Value = M::Value;\n-\n-    /// Memoizes an entry in the dep-tracking-map. If the entry is not\n-    /// already present, then `op` will be executed to compute its value.\n-    /// The resulting dependency graph looks like this:\n-    ///\n-    ///     [op] -> Map(key) -> CurrentTask\n-    ///\n-    /// Here, `[op]` represents whatever nodes `op` reads in the\n-    /// course of execution; `Map(key)` represents the node for this\n-    /// map, and `CurrentTask` represents the current task when\n-    /// `memoize` is invoked.\n-    ///\n-    /// **Important:** when `op` is invoked, the current task will be\n-    /// switched to `Map(key)`. Therefore, if `op` makes use of any\n-    /// HIR nodes or shared state accessed through its closure\n-    /// environment, it must explicitly register a read of that\n-    /// state. As an example, see `type_of_item` in `collect`,\n-    /// which looks something like this:\n-    ///\n-    /// ```\n-    /// fn type_of_item(..., item: &hir::Item) -> Ty<'tcx> {\n-    ///     let item_def_id = ccx.tcx.hir().local_def_id(it.hir_id);\n-    ///     ccx.tcx.item_types.memoized(item_def_id, || {\n-    ///         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id)); // (*)\n-    ///         compute_type_of_item(ccx, item)\n-    ///     });\n-    /// }\n-    /// ```\n-    ///\n-    /// The key is the line marked `(*)`: the closure implicitly\n-    /// accesses the body of the item `item`, so we register a read\n-    /// from `Hir(item_def_id)`.\n-    fn memoize<OP>(&self, key: M::Key, op: OP) -> M::Value\n-        where OP: FnOnce() -> M::Value\n-    {\n-        let graph;\n-        {\n-            let this = self.borrow();\n-            if let Some(&(ref result, dep_node)) = this.map.get(&key) {\n-                this.graph.read_index(dep_node);\n-                return result.clone();\n-            }\n-            graph = this.graph.clone();\n-        }\n-\n-        let (result, dep_node) = graph.with_anon_task(M::to_dep_kind(), op);\n-        self.borrow_mut().map.insert(key, (result.clone(), dep_node));\n-        graph.read_index(dep_node);\n-        result\n-    }\n-}"}, {"sha": "acfdc91523f70fce25036ac59148d453d304e0b4", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -590,7 +590,7 @@ impl DepGraph {\n                 // mark it as green by recursively marking all of its\n                 // dependencies green.\n                 self.try_mark_previous_green(\n-                    tcx.global_tcx(),\n+                    tcx,\n                     data,\n                     prev_index,\n                     &dep_node"}, {"sha": "43f3d7e89cd5c7236589ed72a8ca9ebea47ddcd0", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1,14 +1,12 @@\n pub mod debug;\n mod dep_node;\n-mod dep_tracking_map;\n mod graph;\n mod prev;\n mod query;\n mod safe;\n mod serialized;\n pub mod cgu_reuse_tracker;\n \n-pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId, RecoverKey, label_strs};\n pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor, TaskDeps, hash_result};\n pub use self::graph::WorkProductFileKind;"}, {"sha": "d5e956555bdfb7e4a526027c246af743a10261cf", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 52, "deletions": 20, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -93,70 +93,102 @@ struct CheckAttrVisitor<'tcx> {\n impl CheckAttrVisitor<'tcx> {\n     /// Checks any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n-        if target == Target::Fn || target == Target::Const {\n-            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(item.hir_id));\n-        } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(sym::target_feature)) {\n-            self.tcx.sess.struct_span_err(a.span, \"attribute should be applied to a function\")\n-                .span_label(item.span, \"not a function\")\n-                .emit();\n-        }\n-\n+        let mut is_valid = true;\n         for attr in &item.attrs {\n-            if attr.check_name(sym::inline) {\n+            is_valid &= if attr.check_name(sym::inline) {\n                 self.check_inline(attr, &item.span, target)\n             } else if attr.check_name(sym::non_exhaustive) {\n                 self.check_non_exhaustive(attr, item, target)\n             } else if attr.check_name(sym::marker) {\n                 self.check_marker(attr, item, target)\n-            }\n+            } else if attr.check_name(sym::target_feature) {\n+                self.check_target_feature(attr, item, target)\n+            } else {\n+                true\n+            };\n+        }\n+\n+        if !is_valid {\n+            return;\n+        }\n+\n+        if target == Target::Fn {\n+            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(item.hir_id));\n         }\n \n         self.check_repr(item, target);\n         self.check_used(item, target);\n     }\n \n-    /// Checks if an `#[inline]` is applied to a function or a closure.\n-    fn check_inline(&self, attr: &hir::Attribute, span: &Span, target: Target) {\n+    /// Checks if an `#[inline]` is applied to a function or a closure. Returns `true` if valid.\n+    fn check_inline(&self, attr: &hir::Attribute, span: &Span, target: Target) -> bool {\n         if target != Target::Fn && target != Target::Closure {\n             struct_span_err!(self.tcx.sess,\n                              attr.span,\n                              E0518,\n                              \"attribute should be applied to function or closure\")\n                 .span_label(*span, \"not a function or closure\")\n                 .emit();\n+            false\n+        } else {\n+            true\n         }\n     }\n \n-    /// Checks if the `#[non_exhaustive]` attribute on an `item` is valid.\n-    fn check_non_exhaustive(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) {\n+    /// Checks if the `#[non_exhaustive]` attribute on an `item` is valid. Returns `true` if valid.\n+    fn check_non_exhaustive(\n+        &self,\n+        attr: &hir::Attribute,\n+        item: &hir::Item,\n+        target: Target,\n+    ) -> bool {\n         match target {\n-            Target::Struct | Target::Enum => { /* Valid */ },\n+            Target::Struct | Target::Enum => true,\n             _ => {\n                 struct_span_err!(self.tcx.sess,\n                                  attr.span,\n                                  E0701,\n                                  \"attribute can only be applied to a struct or enum\")\n                     .span_label(item.span, \"not a struct or enum\")\n                     .emit();\n-                return;\n+                false\n             }\n         }\n     }\n \n-    /// Checks if the `#[marker]` attribute on an `item` is valid.\n-    fn check_marker(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) {\n+    /// Checks if the `#[marker]` attribute on an `item` is valid. Returns `true` if valid.\n+    fn check_marker(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) -> bool {\n         match target {\n-            Target::Trait => { /* Valid */ },\n+            Target::Trait => true,\n             _ => {\n                 self.tcx.sess\n                     .struct_span_err(attr.span, \"attribute can only be applied to a trait\")\n                     .span_label(item.span, \"not a trait\")\n                     .emit();\n-                return;\n+                false\n             }\n         }\n     }\n \n+    /// Checks if the `#[target_feature]` attribute on `item` is valid. Returns `true` if valid.\n+    fn check_target_feature(\n+        &self,\n+        attr: &hir::Attribute,\n+        item: &hir::Item,\n+        target: Target,\n+    ) -> bool {\n+        match target {\n+            Target::Fn => true,\n+            _ => {\n+                self.tcx.sess\n+                    .struct_span_err(attr.span, \"attribute should be applied to a function\")\n+                    .span_label(item.span, \"not a function\")\n+                    .emit();\n+                false\n+            },\n+        }\n+    }\n+\n     /// Checks if the `#[repr]` attributes on `item` are valid.\n     fn check_repr(&self, item: &hir::Item, target: Target) {\n         // Extract the names of all repr hints, e.g., [foo, bar, align] for:"}, {"sha": "50fceacaa4486b09ee0d43c450586d2a5a452a6a", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -705,7 +705,6 @@ impl LoweringContext<'_> {\n                         E0628,\n                         \"generators cannot have explicit parameters\"\n                     );\n-                    self.sess.abort_if_errors();\n                 }\n                 Some(match movability {\n                     Movability::Movable => hir::GeneratorMovability::Movable,\n@@ -998,7 +997,7 @@ impl LoweringContext<'_> {\n                     E0727,\n                     \"`async` generators are not yet supported\",\n                 );\n-                self.sess.abort_if_errors();\n+                return hir::ExprKind::Err;\n             },\n             None => self.generator_kind = Some(hir::GeneratorKind::Gen),\n         }"}, {"sha": "42a4a9909f8a94e0c433aa8a7c9b3b284360ee13", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 135, "deletions": 108, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -23,8 +23,6 @@ use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n-use std::result::Result::Err;\n-\n pub mod blocks;\n mod collector;\n mod def_collector;\n@@ -183,6 +181,44 @@ pub struct Map<'hir> {\n     hir_to_node_id: FxHashMap<HirId, NodeId>,\n }\n \n+struct ParentHirIterator<'map> {\n+    current_id: HirId,\n+    map: &'map Map<'map>,\n+}\n+\n+impl<'map> ParentHirIterator<'map> {\n+    fn new(current_id: HirId, map: &'map Map<'map>) -> ParentHirIterator<'map> {\n+        ParentHirIterator {\n+            current_id,\n+            map,\n+        }\n+    }\n+}\n+\n+impl<'map> Iterator for ParentHirIterator<'map> {\n+    type Item = (HirId, Node<'map>);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.current_id == CRATE_HIR_ID {\n+            return None;\n+        }\n+        loop { // There are nodes that do not have entries, so we need to skip them.\n+            let parent_id = self.map.get_parent_node(self.current_id);\n+\n+            if parent_id == self.current_id {\n+                self.current_id = CRATE_HIR_ID;\n+                return None;\n+            }\n+\n+            self.current_id = parent_id;\n+            if let Some(entry) = self.map.find_entry(parent_id) {\n+                return Some((parent_id, entry.node));\n+            }\n+            // If this `HirId` doesn't have an `Entry`, skip it and look for its `parent_id`.\n+        }\n+    }\n+}\n+\n impl<'hir> Map<'hir> {\n     #[inline]\n     fn lookup(&self, id: HirId) -> Option<&Entry<'hir>> {\n@@ -682,45 +718,6 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-\n-    /// If there is some error when walking the parents (e.g., a node does not\n-    /// have a parent in the map or a node can't be found), then we return the\n-    /// last good `HirId` we found. Note that reaching the crate root (`id == 0`),\n-    /// is not an error, since items in the crate module have the crate root as\n-    /// parent.\n-    fn walk_parent_nodes<F, F2>(&self,\n-                                start_id: HirId,\n-                                found: F,\n-                                bail_early: F2)\n-        -> Result<HirId, HirId>\n-        where F: Fn(&Node<'hir>) -> bool, F2: Fn(&Node<'hir>) -> bool\n-    {\n-        let mut id = start_id;\n-        loop {\n-            let parent_id = self.get_parent_node(id);\n-            if parent_id == CRATE_HIR_ID {\n-                return Ok(CRATE_HIR_ID);\n-            }\n-            if parent_id == id {\n-                return Err(id);\n-            }\n-\n-            if let Some(entry) = self.find_entry(parent_id) {\n-                if let Node::Crate = entry.node {\n-                    return Err(id);\n-                }\n-                if found(&entry.node) {\n-                    return Ok(parent_id);\n-                } else if bail_early(&entry.node) {\n-                    return Err(parent_id);\n-                }\n-                id = parent_id;\n-            } else {\n-                return Err(id);\n-            }\n-        }\n-    }\n-\n     /// Retrieves the `HirId` for `id`'s enclosing method, unless there's a\n     /// `while` or `loop` before reaching it, as block tail returns are not\n     /// available in them.\n@@ -744,46 +741,64 @@ impl<'hir> Map<'hir> {\n     /// }\n     /// ```\n     pub fn get_return_block(&self, id: HirId) -> Option<HirId> {\n-        let match_fn = |node: &Node<'_>| {\n-            match *node {\n+        let mut iter = ParentHirIterator::new(id, &self).peekable();\n+        let mut ignore_tail = false;\n+        if let Some(entry) = self.find_entry(id) {\n+            if let Node::Expr(Expr { kind: ExprKind::Ret(_), .. }) = entry.node {\n+                // When dealing with `return` statements, we don't care about climbing only tail\n+                // expressions.\n+                ignore_tail = true;\n+            }\n+        }\n+        while let Some((hir_id, node)) = iter.next() {\n+            if let (Some((_, next_node)), false) = (iter.peek(), ignore_tail) {\n+                match next_node {\n+                    Node::Block(Block { expr: None, .. }) => return None,\n+                    Node::Block(Block { expr: Some(expr), .. }) => {\n+                        if hir_id != expr.hir_id {\n+                            // The current node is not the tail expression of its parent.\n+                            return None;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            match node {\n                 Node::Item(_) |\n                 Node::ForeignItem(_) |\n                 Node::TraitItem(_) |\n                 Node::Expr(Expr { kind: ExprKind::Closure(..), ..}) |\n-                Node::ImplItem(_) => true,\n-                _ => false,\n-            }\n-        };\n-        let match_non_returning_block = |node: &Node<'_>| {\n-            match *node {\n+                Node::ImplItem(_) => return Some(hir_id),\n                 Node::Expr(ref expr) => {\n                     match expr.kind {\n-                        ExprKind::Loop(..) | ExprKind::Ret(..) => true,\n-                        _ => false,\n+                        // Ignore `return`s on the first iteration\n+                        ExprKind::Loop(..) | ExprKind::Ret(..) => return None,\n+                        _ => {}\n                     }\n                 }\n-                _ => false,\n+                Node::Local(_) => return None,\n+                _ => {}\n             }\n-        };\n-\n-        self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n+        }\n+        None\n     }\n \n     /// Retrieves the `HirId` for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n-        match self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(_) |\n-            Node::ForeignItem(_) |\n-            Node::TraitItem(_) |\n-            Node::ImplItem(_) => true,\n-            _ => false,\n-        }, |_| false) {\n-            Ok(id) => id,\n-            Err(id) => id,\n+        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+            match node {\n+                Node::Crate |\n+                Node::Item(_) |\n+                Node::ForeignItem(_) |\n+                Node::TraitItem(_) |\n+                Node::ImplItem(_) => return hir_id,\n+                _ => {}\n+            }\n         }\n+        hir_id\n     }\n \n     /// Returns the `DefId` of `id`'s nearest module parent, or `id` itself if no\n@@ -795,60 +810,64 @@ impl<'hir> Map<'hir> {\n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n-        match self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(&Item { kind: ItemKind::Mod(_), .. }) => true,\n-            _ => false,\n-        }, |_| false) {\n-            Ok(id) => id,\n-            Err(id) => id,\n+        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+            if let Node::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n+                return hir_id;\n+            }\n         }\n+        CRATE_HIR_ID\n     }\n \n     /// Returns the nearest enclosing scope. A scope is roughly an item or block.\n     pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n-        self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(i) => {\n-                match i.kind {\n-                    ItemKind::Fn(..)\n-                    | ItemKind::Mod(..)\n-                    | ItemKind::Enum(..)\n-                    | ItemKind::Struct(..)\n-                    | ItemKind::Union(..)\n-                    | ItemKind::Trait(..)\n-                    | ItemKind::Impl(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::ForeignItem(fi) => {\n-                match fi.kind {\n-                    ForeignItemKind::Fn(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::TraitItem(ti) => {\n-                match ti.kind {\n-                    TraitItemKind::Method(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::ImplItem(ii) => {\n-                match ii.kind {\n-                    ImplItemKind::Method(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::Block(_) => true,\n-            _ => false,\n-        }, |_| false).ok()\n+        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+            if match node {\n+                Node::Item(i) => {\n+                    match i.kind {\n+                        ItemKind::Fn(..)\n+                        | ItemKind::Mod(..)\n+                        | ItemKind::Enum(..)\n+                        | ItemKind::Struct(..)\n+                        | ItemKind::Union(..)\n+                        | ItemKind::Trait(..)\n+                        | ItemKind::Impl(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::ForeignItem(fi) => {\n+                    match fi.kind {\n+                        ForeignItemKind::Fn(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::TraitItem(ti) => {\n+                    match ti.kind {\n+                        TraitItemKind::Method(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::ImplItem(ii) => {\n+                    match ii.kind {\n+                        ImplItemKind::Method(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::Block(_) => true,\n+                _ => false,\n+            } {\n+                return Some(hir_id);\n+            }\n+        }\n+        None\n     }\n \n     /// Returns the defining scope for an opaque type definition.\n-    pub fn get_defining_scope(&self, id: HirId) -> Option<HirId> {\n+    pub fn get_defining_scope(&self, id: HirId) -> HirId {\n         let mut scope = id;\n         loop {\n-            scope = self.get_enclosing_scope(scope)?;\n+            scope = self.get_enclosing_scope(scope).unwrap_or(CRATE_HIR_ID);\n             if scope == CRATE_HIR_ID {\n-                return Some(CRATE_HIR_ID);\n+                return CRATE_HIR_ID;\n             }\n             match self.get(scope) {\n                 Node::Item(i) => {\n@@ -861,7 +880,7 @@ impl<'hir> Map<'hir> {\n                 _ => break,\n             }\n         }\n-        Some(scope)\n+        scope\n     }\n \n     pub fn get_parent_did(&self, id: HirId) -> DefId {\n@@ -1064,6 +1083,14 @@ impl<'hir> Map<'hir> {\n         self.as_local_hir_id(id).map(|id| self.span(id))\n     }\n \n+    pub fn res_span(&self, res: Res) -> Option<Span> {\n+        match res {\n+            Res::Err => None,\n+            Res::Local(id) => Some(self.span(id)),\n+            res => self.span_if_local(res.opt_def_id()?),\n+        }\n+    }\n+\n     pub fn node_to_string(&self, id: HirId) -> String {\n         hir_id_to_string(self, id, true)\n     }"}, {"sha": "6a88ae077c8da642b8672cbeb4e4191db1869340", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1291,17 +1291,6 @@ pub struct Arm {\n     pub body: P<Expr>,\n }\n \n-impl Arm {\n-    // HACK(or_patterns; Centril | dlrobertson): Remove this and\n-    // correctly handle each case in which this method is used.\n-    pub fn top_pats_hack(&self) -> &[P<Pat>] {\n-        match &self.pat.kind {\n-            PatKind::Or(pats) => pats,\n-            _ => std::slice::from_ref(&self.pat),\n-        }\n-    }\n-}\n-\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Guard {\n     If(P<Expr>),\n@@ -1563,7 +1552,7 @@ pub enum ExprKind {\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n     MethodCall(P<PathSegment>, Span, HirVec<Expr>),\n-    /// A tuple (e.g., `(a, b, c ,d)`).\n+    /// A tuple (e.g., `(a, b, c, d)`).\n     Tup(HirVec<Expr>),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n     Binary(BinOp, P<Expr>, P<Expr>),"}, {"sha": "750ca4e32a64e7124f3950a3827da3152e63a2bc", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -93,6 +93,8 @@ impl SuppressRegionErrors {\n     /// checks, so we should ignore errors if NLL is (unconditionally)\n     /// enabled.\n     pub fn when_nll_is_enabled(tcx: TyCtxt<'_>) -> Self {\n+        // FIXME(Centril): Once we actually remove `::Migrate` also make\n+        // this always `true` and then proceed to eliminate the dead code.\n         match tcx.borrowck_mode() {\n             // If we're on Migrate mode, report AST region errors\n             BorrowckMode::Migrate => SuppressRegionErrors { suppressed: false },\n@@ -1460,7 +1462,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // type-checking closure types are in local tables only.\n         if !self.in_progress_tables.is_some() || !ty.has_closure_types() {\n             if !(param_env, ty).has_local_value() {\n-                return ty.is_copy_modulo_regions(self.tcx.global_tcx(), param_env, span);\n+                return ty.is_copy_modulo_regions(self.tcx, param_env, span);\n             }\n         }\n "}, {"sha": "2e19c9c24e9b5fd11e3e79169092f1351c5bc13e", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -561,15 +561,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             def_id, instantiated_ty\n         );\n \n-        let gcx = self.tcx.global_tcx();\n-\n         // Use substs to build up a reverse map from regions to their\n         // identity mappings. This is necessary because of `impl\n         // Trait` lifetimes are computed by replacing existing\n         // lifetimes with 'static and remapping only those used in the\n         // `impl Trait` return type, resulting in the parameters\n         // shifting.\n-        let id_substs = InternalSubsts::identity_for_item(gcx, def_id);\n+        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n         let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> = opaque_defn\n             .substs\n             .iter()\n@@ -854,7 +852,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     )\n                     .emit();\n \n-                self.tcx().global_tcx().mk_region(ty::ReStatic)\n+                self.tcx().mk_region(ty::ReStatic)\n             },\n         }\n     }\n@@ -1215,7 +1213,7 @@ pub fn may_define_opaque_type(\n     let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Named opaque types can be defined by any siblings or children of siblings.\n-    let scope = tcx.hir().get_defining_scope(opaque_hir_id).expect(\"could not get defining scope\");\n+    let scope = tcx.hir().get_defining_scope(opaque_hir_id);\n     // We walk up the node tree until we hit the root or the scope of the opaque type.\n     while hir_id != scope && hir_id != hir::CRATE_HIR_ID {\n         hir_id = tcx.hir().get_parent_item(hir_id);"}, {"sha": "bd9899b644b5e2be6eae2d96af6528a9b34c7bc5", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -100,7 +100,6 @@ pub mod infer;\n pub mod lint;\n \n pub mod middle {\n-    pub mod borrowck;\n     pub mod expr_use_visitor;\n     pub mod cstore;\n     pub mod dead;"}, {"sha": "60c24eeae7b6459cd4fdb64ecb8f63b8504ec08a", "filename": "src/librustc/middle/borrowck.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,31 +0,0 @@\n-use crate::ich::StableHashingContext;\n-\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n-\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub enum SignalledError { SawSomeError, NoErrorsSeen }\n-\n-impl Default for SignalledError {\n-    fn default() -> SignalledError {\n-        SignalledError::NoErrorsSeen\n-    }\n-}\n-\n-impl_stable_hash_for!(enum self::SignalledError { SawSomeError, NoErrorsSeen });\n-\n-#[derive(Debug, Default, RustcEncodable, RustcDecodable)]\n-pub struct BorrowCheckResult {\n-    pub signalled_any_error: SignalledError,\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for BorrowCheckResult {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let BorrowCheckResult {\n-            ref signalled_any_error,\n-        } = *self;\n-        signalled_any_error.hash_stable(hcx, hasher);\n-    }\n-}"}, {"sha": "c1435551a591854918a745eb7bad2ab337566da5", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -82,7 +82,7 @@ impl ExprVisitor<'tcx> {\n \n             // Special-case transmutting from `typeof(function)` and\n             // `Option<typeof(function)>` to present a clearer error.\n-            let from = unpack_option_like(self.tcx.global_tcx(), from);\n+            let from = unpack_option_like(self.tcx, from);\n             if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (&from.kind, sk_to) {\n                 if size_to == Pointer.size(&self.tcx) {\n                     struct_span_err!(self.tcx.sess, span, E0591,"}, {"sha": "3f5f54c94638eba2c0f71f820b18dc5c27429f7a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -749,7 +749,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                              .unwrap_or(ty::ClosureKind::LATTICE_BOTTOM),\n \n                     None =>\n-                        closure_substs.closure_kind(closure_def_id, self.tcx.global_tcx()),\n+                        closure_substs.closure_kind(closure_def_id, self.tcx),\n                 }\n             }\n             _ => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", ty),"}, {"sha": "cf82184ab032c4b5b40ffd665f9715ca5da548fe", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1504,7 +1504,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Goto { .. } => vec![\"\".into()],\n             SwitchInt { ref values, switch_ty, .. } => ty::tls::with(|tcx| {\n                 let param_env = ty::ParamEnv::empty();\n-                let switch_ty = tcx.lift_to_global(&switch_ty).unwrap();\n+                let switch_ty = tcx.lift(&switch_ty).unwrap();\n                 let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n                 values\n                     .iter()"}, {"sha": "4b1558592aee3a7f0015a567254868aaaebe22e7", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -397,10 +397,6 @@ rustc_queries! {\n     }\n \n     BorrowChecking {\n-        query borrowck(key: DefId) -> &'tcx BorrowCheckResult {\n-            cache_on_disk_if { key.is_local() }\n-        }\n-\n         /// Borrow-checks the function body. If this is a closure, returns\n         /// additional requirements that the closure's creator must verify.\n         query mir_borrowck(key: DefId) -> mir::BorrowCheckResult<'tcx> {\n@@ -469,7 +465,7 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        query check_match(key: DefId) -> SignalledError {\n+        query check_match(key: DefId) {\n             cache_on_disk_if { key.is_local() }\n         }\n "}, {"sha": "cbb22f1e4483074cf7a8da90ae06a2ef34312f85", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -478,14 +478,6 @@ impl BorrowckMode {\n             BorrowckMode::Migrate => true,\n         }\n     }\n-\n-    /// Returns whether we should emit the AST-based borrow checker errors.\n-    pub fn use_ast(self) -> bool {\n-        match self {\n-            BorrowckMode::Mir => false,\n-            BorrowckMode::Migrate => false,\n-        }\n-    }\n }\n \n pub enum Input {\n@@ -1268,14 +1260,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     save_analysis: bool = (false, parse_bool, [UNTRACKED],\n         \"write syntax and type analysis (in JSON format) information, in \\\n          addition to normal output\"),\n-    flowgraph_print_loans: bool = (false, parse_bool, [UNTRACKED],\n-        \"include loan analysis data in -Z unpretty flowgraph output\"),\n-    flowgraph_print_moves: bool = (false, parse_bool, [UNTRACKED],\n-        \"include move analysis data in -Z unpretty flowgraph output\"),\n-    flowgraph_print_assigns: bool = (false, parse_bool, [UNTRACKED],\n-        \"include assignment analysis data in -Z unpretty flowgraph output\"),\n-    flowgraph_print_all: bool = (false, parse_bool, [UNTRACKED],\n-        \"include all dataflow analysis data in -Z unpretty flowgraph output\"),\n     print_region_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"prints region inference graph. \\\n          Use with RUST_REGION_GRAPH=help for more info\"),\n@@ -1424,8 +1408,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         valid types are any of the types for `--pretty`, as well as:\n         `expanded`, `expanded,identified`,\n         `expanded,hygiene` (with internal representations),\n-        `flowgraph=<nodeid>` (graphviz formatted flowgraph for node),\n-        `flowgraph,unlabelled=<nodeid>` (unlabelled graphviz formatted flowgraph for node),\n         `everybody_loops` (all function bodies replaced with `loop {}`),\n         `hir` (the HIR), `hir,identified`,\n         `hir,typed` (HIR with types for each node),"}, {"sha": "c117418f63699bd1863b742a879ed789cf638e62", "filename": "src/librustc/session/config/tests.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -589,14 +589,6 @@ fn test_debugging_options_tracking_hash() {\n     assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n     opts.debugging_opts.save_analysis = true;\n     assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-    opts.debugging_opts.flowgraph_print_loans = true;\n-    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-    opts.debugging_opts.flowgraph_print_moves = true;\n-    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-    opts.debugging_opts.flowgraph_print_assigns = true;\n-    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-    opts.debugging_opts.flowgraph_print_all = true;\n-    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n     opts.debugging_opts.print_region_graph = true;\n     assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n     opts.debugging_opts.parse_only = true;"}, {"sha": "d9e83df7ddda6028e2001c00a3158218060a0727", "filename": "src/librustc/traits/chalk_fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -108,7 +108,7 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                     goal: obligation.goal.predicate,\n                 }, &mut orig_values);\n \n-                match infcx.tcx.global_tcx().evaluate_goal(canonical_goal) {\n+                match infcx.tcx.evaluate_goal(canonical_goal) {\n                     Ok(response) => {\n                         if response.is_proven() {\n                             making_progress = true;"}, {"sha": "9dff699deb8af6982f26e5e2a062783dca38b519", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -3,12 +3,10 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use crate::dep_graph::{DepKind, DepTrackingMapConfig};\n-use std::marker::PhantomData;\n use crate::infer::InferCtxt;\n use crate::traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext,\n              TraitEngine, Vtable};\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, TyCtxt};\n use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::fold::TypeFoldable;\n \n@@ -100,33 +98,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-// Implement DepTrackingMapConfig for `trait_cache`\n-pub struct TraitSelectionCache<'tcx> {\n-    data: PhantomData<&'tcx ()>\n-}\n-\n-impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n-    type Key = (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>);\n-    type Value = Vtable<'tcx, ()>;\n-    fn to_dep_kind() -> DepKind {\n-        DepKind::TraitSelect\n-    }\n-}\n-\n // # Global Cache\n \n-pub struct ProjectionCache<'tcx> {\n-    data: PhantomData<&'tcx ()>,\n-}\n-\n-impl<'tcx> DepTrackingMapConfig for ProjectionCache<'tcx> {\n-    type Key = Ty<'tcx>;\n-    type Value = Ty<'tcx>;\n-    fn to_dep_kind() -> DepKind {\n-        DepKind::TraitSelect\n-    }\n-}\n-\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Finishes processes any obligations that remain in the\n     /// fulfillment context, and then returns the result with all type"}, {"sha": "c2d531793372a37c141a7b5df05e2db44ec52be8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -497,7 +497,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             4\n         };\n \n-        let normalize = |candidate| self.tcx.global_tcx().infer_ctxt().enter(|ref infcx| {\n+        let normalize = |candidate| self.tcx.infer_ctxt().enter(|ref infcx| {\n             let normalized = infcx\n                 .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n                 .normalize(candidate)\n@@ -783,8 +783,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n \n                     ty::Predicate::ObjectSafe(trait_def_id) => {\n-                        let violations = self.tcx.global_tcx()\n-                            .object_safety_violations(trait_def_id);\n+                        let violations = self.tcx.object_safety_violations(trait_def_id);\n                         if let Some(err) = self.tcx.report_object_safety_error(\n                             span,\n                             trait_def_id,\n@@ -920,7 +919,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n \n             TraitNotObjectSafe(did) => {\n-                let violations = self.tcx.global_tcx().object_safety_violations(did);\n+                let violations = self.tcx.object_safety_violations(did);\n                 if let Some(err) = self.tcx.report_object_safety_error(span, did, violations) {\n                     err\n                 } else {"}, {"sha": "a981162fdc326130d8518a7b3f99595b6aa04629", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -495,7 +495,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 } else {\n                     if !substs.has_local_value() {\n                         let instance = ty::Instance::resolve(\n-                            self.selcx.tcx().global_tcx(),\n+                            self.selcx.tcx(),\n                             obligation.param_env,\n                             def_id,\n                             substs,"}, {"sha": "aa30541610e9b8e1ef9f740a8092bf09ff8e1708", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -40,12 +40,11 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n             };\n         }\n \n-        let gcx = tcx.global_tcx();\n         let mut orig_values = OriginalQueryValues::default();\n         let c_ty = self.infcx.canonicalize_query(&self.param_env.and(ty), &mut orig_values);\n         let span = self.cause.span;\n         debug!(\"c_ty = {:?}\", c_ty);\n-        if let Ok(result) = &gcx.dropck_outlives(c_ty) {\n+        if let Ok(result) = &tcx.dropck_outlives(c_ty) {\n             if result.is_proven() {\n                 if let Ok(InferOk { value, obligations }) =\n                     self.infcx.instantiate_query_response_and_region_obligations("}, {"sha": "17684df7e9b8eb79579abf8573c07f3c0a815de0", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -50,7 +50,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         // Run canonical query. If overflow occurs, rerun from scratch but this time\n         // in standard trait query mode so that overflow is handled appropriately\n         // within `SelectionContext`.\n-        self.tcx.global_tcx().evaluate_obligation(c_pred)\n+        self.tcx.evaluate_obligation(c_pred)\n     }\n \n     // Helper function that canonicalizes and runs the query. If an"}, {"sha": "ab42eab28440f91494616b347db6c6ec19ab4b64", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -141,7 +141,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // binder). It would be better to normalize in a\n                 // binding-aware fashion.\n \n-                let gcx = self.infcx.tcx.global_tcx();\n+                let tcx = self.infcx.tcx;\n \n                 let mut orig_values = OriginalQueryValues::default();\n                 // HACK(matthewjasper) `'static` is special-cased in selection,\n@@ -150,7 +150,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                     &self.param_env.and(*data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n-                match gcx.normalize_projection_ty(c_data) {\n+                match tcx.normalize_projection_ty(c_data) {\n                     Ok(result) => {\n                         // We don't expect ambiguity.\n                         if result.is_ambiguous() {"}, {"sha": "f5808b6b5faaf03b9811d488ec84c50079ce11ef", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -97,7 +97,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n         let mut orig_values = OriginalQueryValues::default();\n         let key = self.canonicalize_query(&param_env.and(ty), &mut orig_values);\n-        let result = match self.tcx.global_tcx().implied_outlives_bounds(key) {\n+        let result = match self.tcx.implied_outlives_bounds(key) {\n             Ok(r) => r,\n             Err(NoSolution) => {\n                 self.tcx.sess.delay_span_bug("}, {"sha": "34aa4ee78da30c780d6b00648923fc8f13689dca", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n use crate::hir::def_id::DefId;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n@@ -37,12 +37,6 @@ impl<'tcx> super::QueryTypeOp<'tcx> for AscribeUserType<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n         tcx.type_op_ascribe_user_type(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, ()>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n-        v\n-    }\n }\n \n BraceStructTypeFoldableImpl! {"}, {"sha": "3653f9268dcdea393fccc854894ce64bee772d99", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n@@ -34,12 +34,6 @@ impl<'tcx> super::QueryTypeOp<'tcx> for Eq<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n         tcx.type_op_eq(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, ()>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n-        v\n-    }\n }\n \n BraceStructTypeFoldableImpl! {"}, {"sha": "12a834fbda6bd46011257b1398accaa32c9a03fa", "filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::outlives_bounds::OutlivesBound;\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n@@ -38,12 +38,6 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ImpliedOutlivesBounds<'tcx> {\n \n         tcx.implied_outlives_bounds(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, Self::QueryResponse>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self::QueryResponse>> {\n-        v\n-    }\n }\n \n BraceStructTypeFoldableImpl! {"}, {"sha": "98e535234b6302b9888330976a5476f89b01a4b6", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::canonical::{\n-    Canonical, Canonicalized, CanonicalizedQueryResponse, OriginalQueryValues,\n-    QueryRegionConstraints, QueryResponse,\n+    Canonicalized, CanonicalizedQueryResponse, OriginalQueryValues,\n+    QueryRegionConstraints,\n };\n use crate::infer::{InferCtxt, InferOk};\n use std::fmt;\n@@ -66,22 +66,6 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + 'tcx {\n         canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>>;\n \n-    /// Casts a lifted query result (which is in the gcx lifetime)\n-    /// into the tcx lifetime. This is always just an identity cast,\n-    /// but the generic code doesn't realize it -- put another way, in\n-    /// the generic code, we have a `Lifted<'tcx, Self::QueryResponse>`\n-    /// and we want to convert that to a `Self::QueryResponse`. This is\n-    /// not a priori valid, so we can't do it -- but in practice, it\n-    /// is always a no-op (e.g., the lifted form of a type,\n-    /// `Ty<'tcx>`, is a subtype of `Ty<'tcx>`). So we have to push\n-    /// the operation into the impls that know more specifically what\n-    /// `QueryResponse` is. This operation would (maybe) be nicer with\n-    /// something like HKTs or GATs, since then we could make\n-    /// `QueryResponse` parametric and `'tcx` and `'tcx` etc.\n-    fn shrink_to_tcx_lifetime(\n-        lifted_query_result: &'a CanonicalizedQueryResponse<'tcx, Self::QueryResponse>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self::QueryResponse>>;\n-\n     fn fully_perform_into(\n         query_key: ParamEnvAnd<'tcx, Self>,\n         infcx: &InferCtxt<'_, 'tcx>,\n@@ -99,7 +83,6 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + 'tcx {\n         let canonical_self =\n             infcx.canonicalize_hr_query_hack(&query_key, &mut canonical_var_values);\n         let canonical_result = Self::perform_query(infcx.tcx, canonical_self)?;\n-        let canonical_result = Self::shrink_to_tcx_lifetime(&canonical_result);\n \n         let param_env = query_key.param_env;\n "}, {"sha": "2138f792d45bbd5ea07308030f61849b2e5695c9", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use std::fmt;\n use crate::traits::query::Fallible;\n use crate::ty::fold::TypeFoldable;\n@@ -38,25 +38,13 @@ where\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>> {\n         T::type_op_method(tcx, canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, T>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, T>> {\n-        T::shrink_to_tcx_lifetime(v)\n-    }\n }\n \n pub trait Normalizable<'tcx>: fmt::Debug + TypeFoldable<'tcx> + Lift<'tcx> + Copy {\n     fn type_op_method(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>>;\n-\n-    /// Converts from the `'tcx` (lifted) form of `Self` into the `tcx`\n-    /// form of `Self`.\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>>;\n }\n \n impl Normalizable<'tcx> for Ty<'tcx> {\n@@ -66,12 +54,6 @@ impl Normalizable<'tcx> for Ty<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_ty(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n-        v\n-    }\n }\n \n impl Normalizable<'tcx> for ty::Predicate<'tcx> {\n@@ -81,12 +63,6 @@ impl Normalizable<'tcx> for ty::Predicate<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_predicate(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n-        v\n-    }\n }\n \n impl Normalizable<'tcx> for ty::PolyFnSig<'tcx> {\n@@ -96,12 +72,6 @@ impl Normalizable<'tcx> for ty::PolyFnSig<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_poly_fn_sig(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n-        v\n-    }\n }\n \n impl Normalizable<'tcx> for ty::FnSig<'tcx> {\n@@ -111,12 +81,6 @@ impl Normalizable<'tcx> for ty::FnSig<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_fn_sig(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n-        v\n-    }\n }\n \n BraceStructTypeFoldableImpl! {"}, {"sha": "9b956f3e55408a9d6bd4616eab4e317833829ff7", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::dropck_outlives::trivial_dropck_outlives;\n use crate::traits::query::dropck_outlives::DropckOutlivesResult;\n use crate::traits::query::Fallible;\n@@ -53,12 +53,6 @@ impl super::QueryTypeOp<'tcx> for DropckOutlives<'tcx> {\n \n         tcx.dropck_outlives(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        lifted_query_result: &'a CanonicalizedQueryResponse<'tcx, Self::QueryResponse>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self::QueryResponse>> {\n-        lifted_query_result\n-    }\n }\n \n BraceStructTypeFoldableImpl! {"}, {"sha": "2a908d0f66e5b6e30706af011b21940250a09b8c", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Predicate, TyCtxt};\n \n@@ -43,12 +43,6 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n         tcx.type_op_prove_predicate(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, ()>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n-        v\n-    }\n }\n \n BraceStructTypeFoldableImpl! {"}, {"sha": "c89a55daa095e1763d1f43baa7aca9eeea687286", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n@@ -34,12 +34,6 @@ impl<'tcx> super::QueryTypeOp<'tcx> for Subtype<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n         tcx.type_op_subtype(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, ()>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n-        v\n-    }\n }\n \n BraceStructTypeFoldableImpl! {"}, {"sha": "e1ca9a16d965f690eb5df33c39b0d439659c1ed2", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -2491,7 +2491,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 if other.evaluation.must_apply_modulo_regions() {\n                     match victim.candidate {\n                         ImplCandidate(victim_def) => {\n-                            let tcx = self.tcx().global_tcx();\n+                            let tcx = self.tcx();\n                             return tcx.specializes((other_def, victim_def))\n                                 || tcx.impls_are_allowed_to_overlap(\n                                     other_def, victim_def).is_some();"}, {"sha": "ce0f43021378b22073f3252b7ea398e3b05d082b", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -162,7 +162,6 @@ impl<'tcx> Children {\n                 }\n             };\n \n-            let tcx = tcx.global_tcx();\n             let (le, ge) = traits::overlapping_impls(\n                 tcx,\n                 possible_sibling,"}, {"sha": "18ec2241b2df89605db8ceca1d7a78bf9ec49d49", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -661,8 +661,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 }\n             }\n             None => {\n-                self.global_tcx()\n-                    .impl_defaultness(node_item_def_id)\n+                self.impl_defaultness(node_item_def_id)\n                     .is_default()\n             }\n         }"}, {"sha": "efbc820365e2db5acbb1c391077d835b2bd84e7b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1067,14 +1067,6 @@ pub struct GlobalCtxt<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    /// Gets the global `TyCtxt`.\n-    #[inline]\n-    pub fn global_tcx(self) -> TyCtxt<'tcx> {\n-        TyCtxt {\n-            gcx: self.gcx,\n-        }\n-    }\n-\n     #[inline(always)]\n     pub fn hir(self) -> &'tcx hir_map::Map<'tcx> {\n         &self.hir_map\n@@ -1156,11 +1148,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         value.lift_to_tcx(self)\n     }\n \n-    /// Like lift, but only tries in the global tcx.\n-    pub fn lift_to_global<T: ?Sized + Lift<'tcx>>(self, value: &T) -> Option<T::Lifted> {\n-        value.lift_to_tcx(self.global_tcx())\n-    }\n-\n     /// Creates a type context and call the closure with a `TyCtxt` reference\n     /// to the context. The closure enforces that the type context and any interned\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n@@ -1432,13 +1419,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                                            -> Result<(), E::Error>\n         where E: ty::codec::TyEncoder\n     {\n-        self.queries.on_disk_cache.serialize(self.global_tcx(), encoder)\n-    }\n-\n-    /// If `true`, we should use the AST-based borrowck (we may *also* use\n-    /// the MIR-based borrowck).\n-    pub fn use_ast_borrowck(self) -> bool {\n-        self.borrowck_mode().use_ast()\n+        self.queries.on_disk_cache.serialize(self, encoder)\n     }\n \n     /// If `true`, we should use the MIR-based borrowck, but also\n@@ -1606,7 +1587,7 @@ impl<'tcx> GlobalCtxt<'tcx> {\n         let tcx = TyCtxt {\n             gcx: self,\n         };\n-        ty::tls::with_related_context(tcx.global_tcx(), |icx| {\n+        ty::tls::with_related_context(tcx, |icx| {\n             let new_icx = ty::tls::ImplicitCtxt {\n                 tcx,\n                 query: icx.query.clone(),\n@@ -2431,7 +2412,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n-        self.mk_ty(Array(ty, ty::Const::from_usize(self.global_tcx(), n)))\n+        self.mk_ty(Array(ty, ty::Const::from_usize(self, n)))\n     }\n \n     #[inline]\n@@ -2646,7 +2627,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if ts.len() == 0 {\n             List::empty()\n         } else {\n-            self.global_tcx()._intern_canonical_var_infos(ts)\n+            self._intern_canonical_var_infos(ts)\n         }\n     }\n "}, {"sha": "5851a48a8d3773edc3dc816a0506f3760475d408", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -193,7 +193,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.def_path_str(def.did)).into(),\n             ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.def_path_str(def_id)).into(),\n             ty::Array(_, n) => {\n-                let n = tcx.lift_to_global(&n).unwrap();\n+                let n = tcx.lift(&n).unwrap();\n                 match n.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n                     Some(n) => {\n                         format!(\"array of {} element{}\", n, pluralise!(n)).into()"}, {"sha": "741830f205cb0a56a83c99ac0f3326de500a9854", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -210,7 +210,7 @@ impl<'tcx> Instance<'tcx> {\n     }\n \n     pub fn mono(tcx: TyCtxt<'tcx>, def_id: DefId) -> Instance<'tcx> {\n-        Instance::new(def_id, tcx.global_tcx().empty_substs_for_def_id(def_id))\n+        Instance::new(def_id, tcx.empty_substs_for_def_id(def_id))\n     }\n \n     #[inline]"}, {"sha": "3accbdf9bcbc6314d0aa88d264dc81413095feae", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1883,7 +1883,7 @@ impl<'tcx> HasDataLayout for TyCtxt<'tcx> {\n \n impl<'tcx> HasTyCtxt<'tcx> for TyCtxt<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.global_tcx()\n+        *self\n     }\n }\n \n@@ -2003,7 +2003,7 @@ impl TyCtxt<'tcx> {\n     pub fn layout_of(self, param_env_and_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                      -> Result<TyLayout<'tcx>, LayoutError<'tcx>> {\n         let cx = LayoutCx {\n-            tcx: self.global_tcx(),\n+            tcx: self,\n             param_env: param_env_and_ty.param_env\n         };\n         cx.layout_of(param_env_and_ty.value)\n@@ -2017,7 +2017,7 @@ impl ty::query::TyCtxtAt<'tcx> {\n     pub fn layout_of(self, param_env_and_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                      -> Result<TyLayout<'tcx>, LayoutError<'tcx>> {\n         let cx = LayoutCx {\n-            tcx: self.global_tcx().at(self.span),\n+            tcx: self.at(self.span),\n             param_env: param_env_and_ty.param_env\n         };\n         cx.layout_of(param_env_and_ty.value)"}, {"sha": "0e9600449f62c7088032b8bb651eb901b08b3dc8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -2378,7 +2378,7 @@ impl<'tcx> AdtDef {\n     pub fn eval_explicit_discr(&self, tcx: TyCtxt<'tcx>, expr_did: DefId) -> Option<Discr<'tcx>> {\n         let param_env = tcx.param_env(expr_did);\n         let repr_type = self.repr.discr_type();\n-        let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), expr_did);\n+        let substs = InternalSubsts::identity_for_item(tcx, expr_did);\n         let instance = ty::Instance::new(expr_did, substs);\n         let cid = GlobalId {\n             instance,\n@@ -2387,7 +2387,7 @@ impl<'tcx> AdtDef {\n         match tcx.const_eval(param_env.and(cid)) {\n             Ok(val) => {\n                 // FIXME: Find the right type and use it instead of `val.ty` here\n-                if let Some(b) = val.try_eval_bits(tcx.global_tcx(), param_env, val.ty) {\n+                if let Some(b) = val.try_eval_bits(tcx, param_env, val.ty) {\n                     trace!(\"discriminants: {} ({:?})\", b, repr_type);\n                     Some(Discr {\n                         val: b,\n@@ -2423,7 +2423,7 @@ impl<'tcx> AdtDef {\n         tcx: TyCtxt<'tcx>,\n     ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'tcx> {\n         let repr_type = self.repr.discr_type();\n-        let initial = repr_type.initial_discriminant(tcx.global_tcx());\n+        let initial = repr_type.initial_discriminant(tcx);\n         let mut prev_discr = None::<Discr<'tcx>>;\n         self.variants.iter_enumerated().map(move |(i, v)| {\n             let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n@@ -2457,7 +2457,7 @@ impl<'tcx> AdtDef {\n         let (val, offset) = self.discriminant_def_for_variant(variant_index);\n         let explicit_value = val\n             .and_then(|expr_did| self.eval_explicit_discr(tcx, expr_did))\n-            .unwrap_or_else(|| self.repr.discr_type().initial_discriminant(tcx.global_tcx()));\n+            .unwrap_or_else(|| self.repr.discr_type().initial_discriminant(tcx));\n         explicit_value.checked_add(tcx, offset as u128).0\n     }\n "}, {"sha": "e004fa07f2c0fb421ea95d4e8f5586a01fe5215f", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -917,7 +917,7 @@ pub trait PrettyPrinter<'tcx>:\n                     let min = 1u128 << (bit_size - 1);\n                     let max = min - 1;\n \n-                    let ty = self.tcx().lift_to_global(&ct.ty).unwrap();\n+                    let ty = self.tcx().lift(&ct.ty).unwrap();\n                     let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n                         .unwrap()\n                         .size;"}, {"sha": "f559cde4b03cf90d59e027edc538a895d283d441", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -4,7 +4,6 @@ use crate::hir::def::{DefKind, Export};\n use crate::hir::{self, TraitCandidate, ItemLocalId, CodegenFnAttrs};\n use crate::infer::canonical::{self, Canonical};\n use crate::lint;\n-use crate::middle::borrowck::{BorrowCheckResult, SignalledError};\n use crate::middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary, ForeignModule};\n use crate::middle::cstore::{NativeLibraryKind, DepKind, CrateSource};\n use crate::middle::privacy::AccessLevels;"}, {"sha": "d247c0f9f69f3d4eb8d12f02da6343a4be01876f", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -265,7 +265,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         tls::with_related_context(self, move |current_icx| {\n             // Update the `ImplicitCtxt` to point to our new query job.\n             let new_icx = tls::ImplicitCtxt {\n-                tcx: self.global_tcx(),\n+                tcx: self,\n                 query: Some(job),\n                 diagnostics,\n                 layout_depth: current_icx.layout_depth,\n@@ -274,7 +274,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             // Use the `ImplicitCtxt` while we execute the query.\n             tls::enter_context(&new_icx, |_| {\n-                compute(self.global_tcx())\n+                compute(self)\n             })\n         })\n     }\n@@ -384,7 +384,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n                 self.start_query(job.job.clone(), diagnostics, |tcx| {\n                     tcx.dep_graph.with_anon_task(Q::dep_kind(), || {\n-                        Q::compute(tcx.global_tcx(), key)\n+                        Q::compute(tcx, key)\n                     })\n                 })\n             });\n@@ -445,10 +445,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         debug_assert!(self.dep_graph.is_green(dep_node));\n \n         // First we try to load the result from the on-disk cache.\n-        let result = if Q::cache_on_disk(self.global_tcx(), key.clone(), None) &&\n+        let result = if Q::cache_on_disk(self, key.clone(), None) &&\n                         self.sess.opts.debugging_opts.incremental_queries {\n             self.sess.profiler(|p| p.incremental_load_result_start(Q::NAME));\n-            let result = Q::try_load_from_disk(self.global_tcx(), prev_dep_node_index);\n+            let result = Q::try_load_from_disk(self, prev_dep_node_index);\n             self.sess.profiler(|p| p.incremental_load_result_end(Q::NAME));\n \n             // We always expect to find a cached result for things that\n@@ -643,7 +643,7 @@ impl<'tcx> TyCtxt<'tcx> {\n macro_rules! handle_cycle_error {\n     ([][$tcx: expr, $error:expr]) => {{\n         $tcx.report_cycle($error).emit();\n-        Value::from_cycle_error($tcx.global_tcx())\n+        Value::from_cycle_error($tcx)\n     }};\n     ([fatal_cycle$(, $modifiers:ident)*][$tcx:expr, $error:expr]) => {{\n         $tcx.report_cycle($error).emit();\n@@ -652,7 +652,7 @@ macro_rules! handle_cycle_error {\n     }};\n     ([cycle_delay_bug$(, $modifiers:ident)*][$tcx:expr, $error:expr]) => {{\n         $tcx.report_cycle($error).delay_as_bug();\n-        Value::from_cycle_error($tcx.global_tcx())\n+        Value::from_cycle_error($tcx)\n     }};\n     ([$other:ident$(, $modifiers:ident)*][$($args:tt)*]) => {\n         handle_cycle_error!([$($modifiers),*][$($args)*])\n@@ -999,7 +999,7 @@ macro_rules! define_queries_inner {\n                         // would be missing appropriate entries in `providers`.\n                         .unwrap_or(&tcx.queries.fallback_extern_providers)\n                         .$name;\n-                    provider(tcx.global_tcx(), key)\n+                    provider(tcx, key)\n                 })\n             }\n "}, {"sha": "0f472126695e0720cacd8138162c6d79e3707a56", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 39, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1,10 +1,9 @@\n #![allow(non_camel_case_types)]\n \n-use rustc_data_structures::{fx::FxHashMap, sync::Lock};\n+use rustc_data_structures::sync::Lock;\n \n-use std::cell::{RefCell, Cell};\n+use std::cell::Cell;\n use std::fmt::Debug;\n-use std::hash::Hash;\n use std::time::{Duration, Instant};\n \n use std::sync::mpsc::{Sender};\n@@ -279,39 +278,3 @@ pub fn indenter() -> Indenter {\n     debug!(\">>\");\n     Indenter { _cannot_construct_outside_of_this_module: () }\n }\n-\n-pub trait MemoizationMap {\n-    type Key: Clone;\n-    type Value: Clone;\n-\n-    /// If `key` is present in the map, return the value,\n-    /// otherwise invoke `op` and store the value in the map.\n-    ///\n-    /// N.B., if the receiver is a `DepTrackingMap`, special care is\n-    /// needed in the `op` to ensure that the correct edges are\n-    /// added into the dep graph. See the `DepTrackingMap` impl for\n-    /// more details!\n-    fn memoize<OP>(&self, key: Self::Key, op: OP) -> Self::Value\n-        where OP: FnOnce() -> Self::Value;\n-}\n-\n-impl<K, V> MemoizationMap for RefCell<FxHashMap<K,V>>\n-    where K: Hash+Eq+Clone, V: Clone\n-{\n-    type Key = K;\n-    type Value = V;\n-\n-    fn memoize<OP>(&self, key: K, op: OP) -> V\n-        where OP: FnOnce() -> V\n-    {\n-        let result = self.borrow().get(&key).cloned();\n-        match result {\n-            Some(result) => result,\n-            None => {\n-                let result = op();\n-                self.borrow_mut().insert(key, result.clone());\n-                result\n-            }\n-        }\n-    }\n-}"}, {"sha": "40c4c1fc3fee692ae9d3d88a206a88335b0255a0", "filename": "src/librustc_ast_borrowck/Cargo.toml", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2FCargo.toml?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,20 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rustc_ast_borrowck\"\n-version = \"0.0.0\"\n-edition = \"2018\"\n-\n-[lib]\n-name = \"rustc_ast_borrowck\"\n-path = \"lib.rs\"\n-test = false\n-doctest = false\n-\n-[dependencies]\n-log = \"0.4\"\n-syntax_pos = { path = \"../libsyntax_pos\" }\n-# for \"clarity\", rename the graphviz crate to dot; graphviz within `borrowck`\n-# refers to the borrowck-specific graphviz adapter traits.\n-dot = { path = \"../libgraphviz\", package = \"graphviz\" }\n-rustc = { path = \"../librustc\" }\n-rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "3f2175921d48c45a24f22a4a3055d8577956b214", "filename": "src/librustc_ast_borrowck/borrowck/README.md", "status": "removed", "additions": 0, "deletions": 1167, "changes": 1167, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2FREADME.md?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,1167 +0,0 @@\n-% The Borrow Checker\n-\n-> WARNING: This README is more or less obsolete, and will be removed\n-> soon! The new system is described in the [rustc guide].\n-\n-[rustc guide]: https://rust-lang.github.io/rustc-guide/borrow_check.html\n-\n-This pass has the job of enforcing memory safety. This is a subtle\n-topic. This docs aim to explain both the practice and the theory\n-behind the borrow checker. They start with a high-level overview of\n-how it works, and then proceed to dive into the theoretical\n-background. Finally, they go into detail on some of the more subtle\n-aspects.\n-\n-# Table of contents\n-\n-These docs are long. Search for the section you are interested in.\n-\n-- Overview\n-- Formal model\n-- Borrowing and loans\n-- Moves and initialization\n-- Drop flags and structural fragments\n-- Future work\n-\n-# Overview\n-\n-The borrow checker checks one function at a time. It operates in two\n-passes. The first pass, called `gather_loans`, walks over the function\n-and identifies all of the places where borrows (e.g., `&` expressions\n-and `ref` bindings) and moves (copies or captures of a linear value)\n-occur. It also tracks initialization sites. For each borrow and move,\n-it checks various basic safety conditions at this time (for example,\n-that the lifetime of the borrow doesn't exceed the lifetime of the\n-value being borrowed, or that there is no move out of an `&T`\n-referent).\n-\n-It then uses the dataflow module to propagate which of those borrows\n-may be in scope at each point in the procedure. A loan is considered\n-to come into scope at the expression that caused it and to go out of\n-scope when the lifetime of the resulting reference expires.\n-\n-Once the in-scope loans are known for each point in the program, the\n-borrow checker walks the IR again in a second pass called\n-`check_loans`. This pass examines each statement and makes sure that\n-it is safe with respect to the in-scope loans.\n-\n-# Formal model\n-\n-Throughout the docs we'll consider a simple subset of Rust in which\n-you can only borrow from places, defined like so:\n-\n-```text\n-P = x | P.f | *P\n-```\n-\n-Here `x` represents some variable, `P.f` is a field reference,\n-and `*P` is a pointer dereference. There is no auto-deref or other\n-niceties. This means that if you have a type like:\n-\n-```rust\n-struct S { f: i32 }\n-```\n-\n-and a variable `a: Box<S>`, then the rust expression `a.f` would correspond\n-to an `P` of `(*a).f`.\n-\n-Here is the formal grammar for the types we'll consider:\n-\n-```text\n-TY = i32 | bool | S<'LT...> | Box<TY> | & 'LT MQ TY\n-MQ = mut | imm\n-```\n-\n-Most of these types should be pretty self explanatory. Here `S` is a\n-struct name and we assume structs are declared like so:\n-\n-```text\n-SD = struct S<'LT...> { (f: TY)... }\n-```\n-\n-# Borrowing and loans\n-\n-## An intuitive explanation\n-\n-### Issuing loans\n-\n-Now, imagine we had a program like this:\n-\n-```rust\n-struct Foo { f: i32, g: i32 }\n-...\n-'a: {\n-    let mut x: Box<Foo> = ...;\n-    let y = &mut (*x).f;\n-    x = ...;\n-}\n-```\n-\n-This is of course dangerous because mutating `x` will free the old\n-value and hence invalidate `y`. The borrow checker aims to prevent\n-this sort of thing.\n-\n-#### Loans and restrictions\n-\n-The way the borrow checker works is that it analyzes each borrow\n-expression (in our simple model, that's stuff like `&P`, though in\n-real life there are a few other cases to consider). For each borrow\n-expression, it computes a `Loan`, which is a data structure that\n-records (1) the value being borrowed, (2) the mutability and scope of\n-the borrow, and (3) a set of restrictions. In the code, `Loan` is a\n-struct defined in `middle::borrowck`. Formally, we define `LOAN` as\n-follows:\n-\n-```text\n-LOAN = (P, LT, MQ, RESTRICTION*)\n-RESTRICTION = (P, ACTION*)\n-ACTION = MUTATE | CLAIM | FREEZE\n-```\n-\n-Here the `LOAN` tuple defines the place `P` being borrowed; the\n-lifetime `LT` of that borrow; the mutability `MQ` of the borrow; and a\n-list of restrictions. The restrictions indicate actions which, if\n-taken, could invalidate the loan and lead to type safety violations.\n-\n-Each `RESTRICTION` is a pair of a restrictive place `P` (which will\n-either be the path that was borrowed or some prefix of the path that\n-was borrowed) and a set of restricted actions.  There are three kinds\n-of actions that may be restricted for the path `P`:\n-\n-- `MUTATE` means that `P` cannot be assigned to;\n-- `CLAIM` means that the `P` cannot be borrowed mutably;\n-- `FREEZE` means that the `P` cannot be borrowed immutably;\n-\n-Finally, it is never possible to move from a place that appears in a\n-restriction. This implies that the \"empty restriction\" `(P, [])`,\n-which contains an empty set of actions, still has a purpose---it\n-prevents moves from `P`. I chose not to make `MOVE` a fourth kind of\n-action because that would imply that sometimes moves are permitted\n-from restricted values, which is not the case.\n-\n-#### Example\n-\n-To give you a better feeling for what kind of restrictions derived\n-from a loan, let's look at the loan `L` that would be issued as a\n-result of the borrow `&mut (*x).f` in the example above:\n-\n-```text\n-L = ((*x).f, 'a, mut, RS) where\n-    RS = [((*x).f, [MUTATE, CLAIM, FREEZE]),\n-          (*x, [MUTATE, CLAIM, FREEZE]),\n-          (x, [MUTATE, CLAIM, FREEZE])]\n-```\n-\n-The loan states that the expression `(*x).f` has been loaned as\n-mutable for the lifetime `'a`. Because the loan is mutable, that means\n-that the value `(*x).f` may be mutated via the newly created reference\n-(and *only* via that pointer). This is reflected in the\n-restrictions `RS` that accompany the loan.\n-\n-The first restriction `((*x).f, [MUTATE, CLAIM, FREEZE])` states that\n-the lender may not mutate, freeze, nor alias `(*x).f`. Mutation is\n-illegal because `(*x).f` is only supposed to be mutated via the new\n-reference, not by mutating the original path `(*x).f`. Freezing is\n-illegal because the path now has an `&mut` alias; so even if we the\n-lender were to consider `(*x).f` to be immutable, it might be mutated\n-via this alias. They will be enforced for the lifetime `'a` of the\n-loan. After the loan expires, the restrictions no longer apply.\n-\n-The second restriction on `*x` is interesting because it does not\n-apply to the path that was lent (`(*x).f`) but rather to a prefix of\n-the borrowed path. This is due to the rules of inherited mutability:\n-if the user were to assign to (or freeze) `*x`, they would indirectly\n-overwrite (or freeze) `(*x).f`, and thus invalidate the reference\n-that was created. In general it holds that when a path is\n-lent, restrictions are issued for all the owning prefixes of that\n-path. In this case, the path `*x` owns the path `(*x).f` and,\n-because `x` has ownership, the path `x` owns the path `*x`.\n-Therefore, borrowing `(*x).f` yields restrictions on both\n-`*x` and `x`.\n-\n-### Checking for illegal assignments, moves, and reborrows\n-\n-Once we have computed the loans introduced by each borrow, the borrow\n-checker uses a data flow propagation to compute the full set of loans\n-in scope at each expression and then uses that set to decide whether\n-that expression is legal.  Remember that the scope of loan is defined\n-by its lifetime LT.  We sometimes say that a loan which is in-scope at\n-a particular point is an \"outstanding loan\", and the set of\n-restrictions included in those loans as the \"outstanding\n-restrictions\".\n-\n-The kinds of expressions which in-scope loans can render illegal are:\n-- *assignments* (`lv = v`): illegal if there is an in-scope restriction\n-  against mutating `lv`;\n-- *moves*: illegal if there is any in-scope restriction on `lv` at all;\n-- *mutable borrows* (`&mut lv`): illegal there is an in-scope restriction\n-  against claiming `lv`;\n-- *immutable borrows* (`&lv`): illegal there is an in-scope restriction\n-  against freezing `lv`.\n-\n-## Formal rules\n-\n-Now that we hopefully have some kind of intuitive feeling for how the\n-borrow checker works, let's look a bit more closely now at the precise\n-conditions that it uses.\n-\n-I will present the rules in a modified form of standard inference\n-rules, which looks as follows:\n-\n-```text\n-PREDICATE(X, Y, Z)                  // Rule-Name\n-  Condition 1\n-  Condition 2\n-  Condition 3\n-```\n-\n-The initial line states the predicate that is to be satisfied.  The\n-indented lines indicate the conditions that must be met for the\n-predicate to be satisfied. The right-justified comment states the name\n-of this rule: there are comments in the borrowck source referencing\n-these names, so that you can cross reference to find the actual code\n-that corresponds to the formal rule.\n-\n-### Invariants\n-\n-I want to collect, at a high-level, the invariants the borrow checker\n-maintains. I will give them names and refer to them throughout the\n-text. Together these invariants are crucial for the overall soundness\n-of the system.\n-\n-**Mutability requires uniqueness.** To mutate a path\n-\n-**Unique mutability.** There is only one *usable* mutable path to any\n-given memory at any given time. This implies that when claiming memory\n-with an expression like `p = &mut x`, the compiler must guarantee that\n-the borrowed value `x` can no longer be mutated so long as `p` is\n-live. (This is done via restrictions, read on.)\n-\n-**.**\n-\n-\n-### The `gather_loans` pass\n-\n-We start with the `gather_loans` pass, which walks the AST looking for\n-borrows.  For each borrow, there are three bits of information: the\n-place `P` being borrowed and the mutability `MQ` and lifetime `LT`\n-of the resulting pointer. Given those, `gather_loans` applies four\n-validity tests:\n-\n-1. `MUTABILITY(P, MQ)`: The mutability of the reference is\n-compatible with the mutability of `P` (i.e., not borrowing immutable\n-data as mutable).\n-\n-2. `ALIASABLE(P, MQ)`: The aliasability of the reference is\n-compatible with the aliasability of `P`. The goal is to prevent\n-`&mut` borrows of aliasability data.\n-\n-3. `LIFETIME(P, LT, MQ)`: The lifetime of the borrow does not exceed\n-the lifetime of the value being borrowed.\n-\n-4. `RESTRICTIONS(P, LT, ACTIONS) = RS`: This pass checks and computes the\n-restrictions to maintain memory safety. These are the restrictions\n-that will go into the final loan. We'll discuss in more detail below.\n-\n-## Checking mutability\n-\n-Checking mutability is fairly straightforward. We just want to prevent\n-immutable data from being borrowed as mutable. Note that it is ok to borrow\n-mutable data as immutable, since that is simply a freeze. The judgement\n-`MUTABILITY(P, MQ)` means the mutability of `P` is compatible with a borrow\n-of mutability `MQ`. The Rust code corresponding to this predicate is the\n-function `check_mutability` in `middle::borrowck::gather_loans`.\n-\n-### Checking mutability of variables\n-\n-*Code pointer:* Function `check_mutability()` in `gather_loans/mod.rs`,\n-but also the code in `mem_categorization`.\n-\n-Let's begin with the rules for variables, which state that if a\n-variable is declared as mutable, it may be borrowed any which way, but\n-otherwise the variable must be borrowed as immutable:\n-\n-```text\n-MUTABILITY(X, MQ)                   // M-Var-Mut\n-  DECL(X) = mut\n-\n-MUTABILITY(X, imm)                  // M-Var-Imm\n-  DECL(X) = imm\n-```\n-\n-### Checking mutability of owned content\n-\n-Fields and boxes inherit their mutability from\n-their base expressions, so both of their rules basically\n-delegate the check to the base expression `P`:\n-\n-```text\n-MUTABILITY(P.f, MQ)                // M-Field\n-  MUTABILITY(P, MQ)\n-\n-MUTABILITY(*P, MQ)                 // M-Deref-Unique\n-  TYPE(P) = Box<Ty>\n-  MUTABILITY(P, MQ)\n-```\n-\n-### Checking mutability of immutable pointer types\n-\n-Immutable pointer types like `&T` can only\n-be borrowed if MQ is immutable:\n-\n-```text\n-MUTABILITY(*P, imm)               // M-Deref-Borrowed-Imm\n-  TYPE(P) = &Ty\n-```\n-\n-### Checking mutability of mutable pointer types\n-\n-`&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n-\n-```text\n-MUTABILITY(*P, MQ)                 // M-Deref-Borrowed-Mut\n-  TYPE(P) = &mut Ty\n-```\n-\n-## Checking aliasability\n-\n-The goal of the aliasability check is to ensure that we never permit `&mut`\n-borrows of aliasable data. The judgement `ALIASABLE(P, MQ)` means the\n-aliasability of `P` is compatible with a borrow of mutability `MQ`. The Rust\n-code corresponding to this predicate is the function `check_aliasability()` in\n-`middle::borrowck::gather_loans`.\n-\n-### Checking aliasability of variables\n-\n-Local variables are never aliasable as they are accessible only within\n-the stack frame.\n-\n-```text\n-    ALIASABLE(X, MQ)                   // M-Var-Mut\n-```\n-\n-### Checking aliasable of owned content\n-\n-Owned content is aliasable if it is found in an aliasable location:\n-\n-```text\n-ALIASABLE(P.f, MQ)                // M-Field\n-  ALIASABLE(P, MQ)\n-\n-ALIASABLE(*P, MQ)                 // M-Deref-Unique\n-  ALIASABLE(P, MQ)\n-```\n-\n-### Checking aliasability of immutable pointer types\n-\n-Immutable pointer types like `&T` are aliasable, and hence can only be\n-borrowed immutably:\n-\n-```text\n-ALIASABLE(*P, imm)                // M-Deref-Borrowed-Imm\n-  TYPE(P) = &Ty\n-```\n-\n-### Checking aliasability of mutable pointer types\n-\n-`&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n-\n-```text\n-ALIASABLE(*P, MQ)                 // M-Deref-Borrowed-Mut\n-  TYPE(P) = &mut Ty\n-```\n-\n-## Checking lifetime\n-\n-These rules aim to ensure that no data is borrowed for a scope that exceeds\n-its lifetime. These two computations wind up being intimately related.\n-Formally, we define a predicate `LIFETIME(P, LT, MQ)`, which states that\n-\"the place `P` can be safely borrowed for the lifetime `LT` with mutability\n-`MQ`\". The Rust code corresponding to this predicate is the module\n-`middle::borrowck::gather_loans::lifetime`.\n-\n-### Checking lifetime of variables\n-\n-The rule for variables states that a variable can only be borrowed a\n-lifetime `LT` that is a subregion of the variable's scope:\n-\n-```text\n-LIFETIME(X, LT, MQ)                 // L-Local\n-  LT <= block where X is declared\n-```\n-\n-### Checking lifetime for owned content\n-\n-The lifetime of a field or box is the same as the lifetime\n-of its owner:\n-\n-```text\n-LIFETIME(P.f, LT, MQ)              // L-Field\n-  LIFETIME(P, LT, MQ)\n-\n-LIFETIME(*P, LT, MQ)               // L-Deref-Send\n-  TYPE(P) = Box<Ty>\n-  LIFETIME(P, LT, MQ)\n-```\n-\n-### Checking lifetime for derefs of references\n-\n-References have a lifetime `LT'` associated with them.  The\n-data they point at has been guaranteed to be valid for at least this\n-lifetime. Therefore, the borrow is valid so long as the lifetime `LT`\n-of the borrow is shorter than the lifetime `LT'` of the pointer\n-itself:\n-\n-```text\n-LIFETIME(*P, LT, MQ)               // L-Deref-Borrowed\n-  TYPE(P) = &LT' Ty OR &LT' mut Ty\n-  LT <= LT'\n-```\n-\n-## Computing the restrictions\n-\n-The final rules govern the computation of *restrictions*, meaning that\n-we compute the set of actions that will be illegal for the life of the\n-loan. The predicate is written `RESTRICTIONS(P, LT, ACTIONS) =\n-RESTRICTION*`, which can be read \"in order to prevent `ACTIONS` from\n-occurring on `P`, the restrictions `RESTRICTION*` must be respected\n-for the lifetime of the loan\".\n-\n-Note that there is an initial set of restrictions: these restrictions\n-are computed based on the kind of borrow:\n-\n-```text\n-&mut P =>   RESTRICTIONS(P, LT, MUTATE|CLAIM|FREEZE)\n-&P =>       RESTRICTIONS(P, LT, MUTATE|CLAIM)\n-```\n-\n-The reasoning here is that a mutable borrow must be the only writer,\n-therefore it prevents other writes (`MUTATE`), mutable borrows\n-(`CLAIM`), and immutable borrows (`FREEZE`). An immutable borrow\n-permits other immutable borrows but forbids writes and mutable borrows.\n-\n-### Restrictions for loans of a local variable\n-\n-The simplest case is a borrow of a local variable `X`:\n-\n-```text\n-RESTRICTIONS(X, LT, ACTIONS) = (X, ACTIONS)            // R-Variable\n-```\n-\n-In such cases we just record the actions that are not permitted.\n-\n-### Restrictions for loans of fields\n-\n-Restricting a field is the same as restricting the owner of that\n-field:\n-\n-```text\n-RESTRICTIONS(P.f, LT, ACTIONS) = RS, (P.f, ACTIONS)  // R-Field\n-  RESTRICTIONS(P, LT, ACTIONS) = RS\n-```\n-\n-The reasoning here is as follows. If the field must not be mutated,\n-then you must not mutate the owner of the field either, since that\n-would indirectly modify the field. Similarly, if the field cannot be\n-frozen or aliased, we cannot allow the owner to be frozen or aliased,\n-since doing so indirectly freezes/aliases the field. This is the\n-origin of inherited mutability.\n-\n-### Restrictions for loans of owned referents\n-\n-Because the mutability of owned referents is inherited, restricting an\n-owned referent is similar to restricting a field, in that it implies\n-restrictions on the pointer. However, boxes have an important\n-twist: if the owner `P` is mutated, that causes the owned referent\n-`*P` to be freed! So whenever an owned referent `*P` is borrowed, we\n-must prevent the box `P` from being mutated, which means\n-that we always add `MUTATE` and `CLAIM` to the restriction set imposed\n-on `P`:\n-\n-```text\n-RESTRICTIONS(*P, LT, ACTIONS) = RS, (*P, ACTIONS)    // R-Deref-Send-Pointer\n-  TYPE(P) = Box<Ty>\n-  RESTRICTIONS(P, LT, ACTIONS|MUTATE|CLAIM) = RS\n-```\n-\n-### Restrictions for loans of immutable borrowed referents\n-\n-Immutable borrowed referents are freely aliasable, meaning that\n-the compiler does not prevent you from copying the pointer.  This\n-implies that issuing restrictions is useless. We might prevent the\n-user from acting on `*P` itself, but there could be another path\n-`*P1` that refers to the exact same memory, and we would not be\n-restricting that path. Therefore, the rule for `&Ty` pointers\n-always returns an empty set of restrictions, and it only permits\n-restricting `MUTATE` and `CLAIM` actions:\n-\n-```text\n-RESTRICTIONS(*P, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n-  TYPE(P) = &LT' Ty\n-  LT <= LT'                                            // (1)\n-  ACTIONS subset of [MUTATE, CLAIM]\n-```\n-\n-The reason that we can restrict `MUTATE` and `CLAIM` actions even\n-without a restrictions list is that it is never legal to mutate nor to\n-borrow mutably the contents of a `&Ty` pointer. In other words,\n-those restrictions are already inherent in the type.\n-\n-Clause (1) in the rule for `&Ty` deserves mention. Here I\n-specify that the lifetime of the loan must be less than the lifetime\n-of the `&Ty` pointer. In simple cases, this clause is redundant, since\n-the `LIFETIME()` function will already enforce the required rule:\n-\n-```rust\n-fn foo(point: &'a Point) -> &'static i32 {\n-    &point.x // Error\n-}\n-```\n-\n-The above example fails to compile both because of clause (1) above\n-but also by the basic `LIFETIME()` check. However, in more advanced\n-examples involving multiple nested pointers, clause (1) is needed:\n-\n-```rust\n-fn foo(point: &'a &'b mut Point) -> &'b i32 {\n-    &point.x // Error\n-}\n-```\n-\n-The `LIFETIME` rule here would accept `'b` because, in fact, the\n-*memory is* guaranteed to remain valid (i.e., not be freed) for the\n-lifetime `'b`, since the `&mut` pointer is valid for `'b`. However, we\n-are returning an immutable reference, so we need the memory to be both\n-valid and immutable. Even though `point.x` is referenced by an `&mut`\n-pointer, it can still be considered immutable so long as that `&mut`\n-pointer is found in an aliased location. That means the memory is\n-guaranteed to be *immutable* for the lifetime of the `&` pointer,\n-which is only `'a`, not `'b`. Hence this example yields an error.\n-\n-As a final twist, consider the case of two nested *immutable*\n-pointers, rather than a mutable pointer within an immutable one:\n-\n-```rust\n-fn foo(point: &'a &'b Point) -> &'b i32 {\n-    &point.x // OK\n-}\n-```\n-\n-This function is legal. The reason for this is that the inner pointer\n-(`*point : &'b Point`) is enough to guarantee the memory is immutable\n-and valid for the lifetime `'b`.  This is reflected in\n-`RESTRICTIONS()` by the fact that we do not recurse (i.e., we impose\n-no restrictions on `P`, which in this particular case is the pointer\n-`point : &'a &'b Point`).\n-\n-#### Why both `LIFETIME()` and `RESTRICTIONS()`?\n-\n-Given the previous text, it might seem that `LIFETIME` and\n-`RESTRICTIONS` should be folded together into one check, but there is\n-a reason that they are separated. They answer separate concerns.\n-The rules pertaining to `LIFETIME` exist to ensure that we don't\n-create a borrowed pointer that outlives the memory it points at. So\n-`LIFETIME` prevents a function like this:\n-\n-```rust\n-fn get_1<'a>() -> &'a i32 {\n-    let x = 1;\n-    &x\n-}\n-```\n-\n-Here we would be returning a pointer into the stack. Clearly bad.\n-\n-However, the `RESTRICTIONS` rules are more concerned with how memory\n-is used. The example above doesn't generate an error according to\n-`RESTRICTIONS` because, for local variables, we don't require that the\n-loan lifetime be a subset of the local variable lifetime. The idea\n-here is that we *can* guarantee that `x` is not (e.g.) mutated for the\n-lifetime `'a`, even though `'a` exceeds the function body and thus\n-involves unknown code in the caller -- after all, `x` ceases to exist\n-after we return and hence the remaining code in `'a` cannot possibly\n-mutate it. This distinction is important for type checking functions\n-like this one:\n-\n-```rust\n-fn inc_and_get<'a>(p: &'a mut Point) -> &'a i32 {\n-    p.x += 1;\n-    &p.x\n-}\n-```\n-\n-In this case, we take in a `&mut` and return a frozen borrowed pointer\n-with the same lifetime. So long as the lifetime of the returned value\n-doesn't exceed the lifetime of the `&mut` we receive as input, this is\n-fine, though it may seem surprising at first (it surprised me when I\n-first worked it through). After all, we're guaranteeing that `*p`\n-won't be mutated for the lifetime `'a`, even though we can't \"see\" the\n-entirety of the code during that lifetime, since some of it occurs in\n-our caller. But we *do* know that nobody can mutate `*p` except\n-through `p`. So if we don't mutate `*p` and we don't return `p`, then\n-we know that the right to mutate `*p` has been lost to our caller --\n-in terms of capability, the caller passed in the ability to mutate\n-`*p`, and we never gave it back. (Note that we can't return `p` while\n-`*p` is borrowed since that would be a move of `p`, as `&mut` pointers\n-are affine.)\n-\n-### Restrictions for loans of mutable borrowed referents\n-\n-Mutable borrowed pointers are guaranteed to be the only way to mutate\n-their referent. This permits us to take greater license with them; for\n-example, the referent can be frozen simply be ensuring that we do not\n-use the original pointer to perform mutate. Similarly, we can allow\n-the referent to be claimed, so long as the original pointer is unused\n-while the new claimant is live.\n-\n-The rule for mutable borrowed pointers is as follows:\n-\n-```text\n-RESTRICTIONS(*P, LT, ACTIONS) = RS, (*P, ACTIONS)    // R-Deref-Mut-Borrowed\n-  TYPE(P) = &LT' mut Ty\n-  LT <= LT'                                            // (1)\n-  RESTRICTIONS(P, LT, ACTIONS) = RS                   // (2)\n-```\n-\n-Let's examine the two numbered clauses:\n-\n-Clause (1) specifies that the lifetime of the loan (`LT`) cannot\n-exceed the lifetime of the `&mut` pointer (`LT'`). The reason for this\n-is that the `&mut` pointer is guaranteed to be the only legal way to\n-mutate its referent -- but only for the lifetime `LT'`.  After that\n-lifetime, the loan on the referent expires and hence the data may be\n-modified by its owner again. This implies that we are only able to\n-guarantee that the referent will not be modified or aliased for a\n-maximum of `LT'`.\n-\n-Here is a concrete example of a bug this rule prevents:\n-\n-```rust\n-// Test region-reborrow-from-shorter-mut-ref.rs:\n-fn copy_borrowed_ptr<'a,'b,T>(x: &'a mut &'b mut T) -> &'b mut T {\n-    &mut **p // ERROR due to clause (1)\n-}\n-fn main() {\n-    let mut x = 1;\n-    let mut y = &mut x; // <-'b-----------------------------+\n-    //      +-'a--------------------+                       |\n-    //      v                       v                       |\n-    let z = copy_borrowed_ptr(&mut y); // y is lent         |\n-    *y += 1; // Here y==z, so both should not be usable...  |\n-    *z += 1; // ...and yet they would be, but for clause 1. |\n-} // <------------------------------------------------------+\n-```\n-\n-Clause (2) propagates the restrictions on the referent to the pointer\n-itself. This is the same as with an box, though the\n-reasoning is mildly different. The basic goal in all cases is to\n-prevent the user from establishing another route to the same data. To\n-see what I mean, let's examine various cases of what can go wrong and\n-show how it is prevented.\n-\n-**Example danger 1: Moving the base pointer.** One of the simplest\n-ways to violate the rules is to move the base pointer to a new name\n-and access it via that new name, thus bypassing the restrictions on\n-the old name. Here is an example:\n-\n-```rust\n-// src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n-fn foo(t0: &mut i32) {\n-    let p: &i32 = &*t0; // Freezes `*t0`\n-    let t1 = t0;        //~ ERROR cannot move out of `t0`\n-    *t1 = 22;           // OK, not a write through `*t0`\n-}\n-```\n-\n-Remember that `&mut` pointers are linear, and hence `let t1 = t0` is a\n-move of `t0` -- or would be, if it were legal. Instead, we get an\n-error, because clause (2) imposes restrictions on `P` (`t0`, here),\n-and any restrictions on a path make it impossible to move from that\n-path.\n-\n-**Example danger 2: Claiming the base pointer.** Another possible\n-danger is to mutably borrow the base path. This can lead to two bad\n-scenarios. The most obvious is that the mutable borrow itself becomes\n-another path to access the same data, as shown here:\n-\n-```rust\n-// src/test/compile-fail/borrowck-mut-borrow-of-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut i32,\n-           mut t1: &'a mut i32) {\n-    let p: &i32 = &*t0;     // Freezes `*t0`\n-    let mut t2 = &mut t0;   //~ ERROR cannot borrow `t0`\n-    **t2 += 1;              // Mutates `*t0`\n-}\n-```\n-\n-In this example, `**t2` is the same memory as `*t0`. Because `t2` is\n-an `&mut` pointer, `**t2` is a unique path and hence it would be\n-possible to mutate `**t2` even though that memory was supposed to be\n-frozen by the creation of `p`. However, an error is reported -- the\n-reason is that the freeze `&*t0` will restrict claims and mutation\n-against `*t0` which, by clause 2, in turn prevents claims and mutation\n-of `t0`. Hence the claim `&mut t0` is illegal.\n-\n-Another danger with an `&mut` pointer is that we could swap the `t0`\n-value away to create a new path:\n-\n-```rust\n-// src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut i32,\n-           mut t1: &'a mut i32) {\n-    let p: &i32 = &*t0;     // Freezes `*t0`\n-    swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n-    *t1 = 22;\n-}\n-```\n-\n-This is illegal for the same reason as above. Note that if we added\n-back a swap operator -- as we used to have -- we would want to be very\n-careful to ensure this example is still illegal.\n-\n-**Example danger 3: Freeze the base pointer.** In the case where the\n-referent is claimed, even freezing the base pointer can be dangerous,\n-as shown in the following example:\n-\n-```rust\n-// src/test/compile-fail/borrowck-borrow-of-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut i32,\n-           mut t1: &'a mut i32) {\n-    let p: &mut i32 = &mut *t0; // Claims `*t0`\n-    let mut t2 = &t0;           //~ ERROR cannot borrow `t0`\n-    let q: &i32 = &*t2;         // Freezes `*t0` but not through `*p`\n-    *p += 1;                    // violates type of `*q`\n-}\n-```\n-\n-Here the problem is that `*t0` is claimed by `p`, and hence `p` wants\n-to be the controlling pointer through which mutation or freezes occur.\n-But `t2` would -- if it were legal -- have the type `& &mut i32`, and\n-hence would be a mutable pointer in an aliasable location, which is\n-considered frozen (since no one can write to `**t2` as it is not a\n-unique path). Therefore, we could reasonably create a frozen `&i32`\n-pointer pointing at `*t0` that coexists with the mutable pointer `p`,\n-which is clearly unsound.\n-\n-However, it is not always unsafe to freeze the base pointer. In\n-particular, if the referent is frozen, there is no harm in it:\n-\n-```rust\n-// src/test/ui/borrowck-borrow-of-mut-base-ptr-safe.rs\n-fn foo<'a>(mut t0: &'a mut i32,\n-           mut t1: &'a mut i32) {\n-    let p: &i32 = &*t0; // Freezes `*t0`\n-    let mut t2 = &t0;\n-    let q: &i32 = &*t2; // Freezes `*t0`, but that's ok...\n-    let r: &i32 = &*t0; // ...after all, could do same thing directly.\n-}\n-```\n-\n-In this case, creating the alias `t2` of `t0` is safe because the only\n-thing `t2` can be used for is to further freeze `*t0`, which is\n-already frozen. In particular, we cannot assign to `*t0` through the\n-new alias `t2`, as demonstrated in this test case:\n-\n-```rust\n-// src/test/ui/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs\n-fn foo(t0: & &mut i32) {\n-    let t1 = t0;\n-    let p: &i32 = &**t0;\n-    **t1 = 22; //~ ERROR cannot assign\n-}\n-```\n-\n-This distinction is reflected in the rules. When doing an `&mut`\n-borrow -- as in the first example -- the set `ACTIONS` will be\n-`CLAIM|MUTATE|FREEZE`, because claiming the referent implies that it\n-cannot be claimed, mutated, or frozen by anyone else. These\n-restrictions are propagated back to the base path and hence the base\n-path is considered unfreezable.\n-\n-In contrast, when the referent is merely frozen -- as in the second\n-example -- the set `ACTIONS` will be `CLAIM|MUTATE`, because freezing\n-the referent implies that it cannot be claimed or mutated but permits\n-others to freeze. Hence when these restrictions are propagated back to\n-the base path, it will still be considered freezable.\n-\n-\n-\n-**FIXME [RFC 1751](https://github.com/rust-lang/rfcs/issues/1751)\n-Restrictions against mutating the base pointer.**\n-When an `&mut` pointer is frozen or claimed, we currently pass along the\n-restriction against MUTATE to the base pointer. I do not believe this\n-restriction is needed. It dates from the days when we had a way to\n-mutate that preserved the value being mutated (i.e., swap). Nowadays\n-the only form of mutation is assignment, which destroys the pointer\n-being mutated -- therefore, a mutation cannot create a new path to the\n-same data. Rather, it removes an existing path. This implies that not\n-only can we permit mutation, we can have mutation kill restrictions in\n-the dataflow sense.\n-\n-**WARNING:** We do not currently have `const` borrows in the\n-language. If they are added back in, we must ensure that they are\n-consistent with all of these examples. The crucial question will be\n-what sorts of actions are permitted with a `&const &mut` pointer. I\n-would suggest that an `&mut` referent found in an `&const` location be\n-prohibited from both freezes and claims. This would avoid the need to\n-prevent `const` borrows of the base pointer when the referent is\n-borrowed.\n-\n-[ Previous revisions of this document discussed `&const` in more detail.\n-See the revision history. ]\n-\n-# Moves and initialization\n-\n-The borrow checker is also in charge of ensuring that:\n-\n-- all memory which is accessed is initialized\n-- immutable local variables are assigned at most once.\n-\n-These are two separate dataflow analyses built on the same\n-framework. Let's look at checking that memory is initialized first;\n-the checking of immutable local variable assignments works in a very\n-similar way.\n-\n-To track the initialization of memory, we actually track all the\n-points in the program that *create uninitialized memory*, meaning\n-moves and the declaration of uninitialized variables. For each of\n-these points, we create a bit in the dataflow set. Assignments to a\n-variable `x` or path `a.b.c` kill the move/uninitialization bits for\n-those paths and any subpaths (e.g., `x`, `x.y`, `a.b.c`, `*a.b.c`).\n-Bits are unioned when two control-flow paths join. Thus, the\n-presence of a bit indicates that the move may have occurred without an\n-intervening assignment to the same memory. At each use of a variable,\n-we examine the bits in scope, and check that none of them are\n-moves/uninitializations of the variable that is being used.\n-\n-Let's look at a simple example:\n-\n-```rust\n-fn foo(a: Box<i32>) {\n-    let b: Box<i32>;   // Gen bit 0.\n-\n-    if cond {          // Bits: 0\n-        use(&*a);\n-        b = a;         // Gen bit 1, kill bit 0.\n-        use(&*b);\n-    } else {\n-                       // Bits: 0\n-    }\n-                       // Bits: 0,1\n-    use(&*a);          // Error.\n-    use(&*b);          // Error.\n-}\n-\n-fn use(a: &i32) { }\n-```\n-\n-In this example, the variable `b` is created uninitialized. In one\n-branch of an `if`, we then move the variable `a` into `b`. Once we\n-exit the `if`, therefore, it is an error to use `a` or `b` since both\n-are only conditionally initialized. I have annotated the dataflow\n-state using comments. There are two dataflow bits, with bit 0\n-corresponding to the creation of `b` without an initializer, and bit 1\n-corresponding to the move of `a`. The assignment `b = a` both\n-generates bit 1, because it is a move of `a`, and kills bit 0, because\n-`b` is now initialized. On the else branch, though, `b` is never\n-initialized, and so bit 0 remains untouched. When the two flows of\n-control join, we union the bits from both sides, resulting in both\n-bits 0 and 1 being set. Thus any attempt to use `a` uncovers the bit 1\n-from the \"then\" branch, showing that `a` may be moved, and any attempt\n-to use `b` uncovers bit 0, from the \"else\" branch, showing that `b`\n-may not be initialized.\n-\n-## Initialization of immutable variables\n-\n-Initialization of immutable variables works in a very similar way,\n-except that:\n-\n-1. we generate bits for each assignment to a variable;\n-2. the bits are never killed except when the variable goes out of scope.\n-\n-Thus the presence of an assignment bit indicates that the assignment\n-may have occurred. Note that assignments are only killed when the\n-variable goes out of scope, as it is not relevant whether or not there\n-has been a move in the meantime. Using these bits, we can declare that\n-an assignment to an immutable variable is legal iff there is no other\n-assignment bit to that same variable in scope.\n-\n-## Why is the design made this way?\n-\n-It may seem surprising that we assign dataflow bits to *each move*\n-rather than *each path being moved*. This is somewhat less efficient,\n-since on each use, we must iterate through all moves and check whether\n-any of them correspond to the path in question. Similar concerns apply\n-to the analysis for double assignments to immutable variables. The\n-main reason to do it this way is that it allows us to print better\n-error messages, because when a use occurs, we can print out the\n-precise move that may be in scope, rather than simply having to say\n-\"the variable may not be initialized\".\n-\n-## Data structures used in the move analysis\n-\n-The move analysis maintains several data structures that enable it to\n-cross-reference moves and assignments to determine when they may be\n-moving/assigning the same memory. These are all collected into the\n-`MoveData` and `FlowedMoveData` structs. The former represents the set\n-of move paths, moves, and assignments, and the latter adds in the\n-results of a dataflow computation.\n-\n-### Move paths\n-\n-The `MovePath` tree tracks every path that is moved or assigned to.\n-These paths have the same form as the `LoanPath` data structure, which\n-in turn is the \"real world version of the places `P` that we\n-introduced earlier. The difference between a `MovePath` and a `LoanPath`\n-is that move paths are:\n-\n-1. Canonicalized, so that we have exactly one copy of each, and\n-   we can refer to move paths by index;\n-2. Cross-referenced with other paths into a tree, so that given a move\n-   path we can efficiently find all parent move paths and all\n-   extensions (e.g., given the `a.b` move path, we can easily find the\n-   move path `a` and also the move paths `a.b.c`)\n-3. Cross-referenced with moves and assignments, so that we can\n-   easily find all moves and assignments to a given path.\n-\n-The mechanism that we use is to create a `MovePath` record for each\n-move path. These are arranged in an array and are referenced using\n-`MovePathIndex` values, which are newtype'd indices. The `MovePath`\n-structs are arranged into a tree, representing using the standard\n-Knuth representation where each node has a child 'pointer' and a \"next\n-sibling\" 'pointer'. In addition, each `MovePath` has a parent\n-'pointer'.  In this case, the 'pointers' are just `MovePathIndex`\n-values.\n-\n-In this way, if we want to find all base paths of a given move path,\n-we can just iterate up the parent pointers (see `each_base_path()` in\n-the `move_data` module). If we want to find all extensions, we can\n-iterate through the subtree (see `each_extending_path()`).\n-\n-### Moves and assignments\n-\n-There are structs to represent moves (`Move`) and assignments\n-(`Assignment`), and these are also placed into arrays and referenced\n-by index. All moves of a particular path are arranged into a linked\n-lists, beginning with `MovePath.first_move` and continuing through\n-`Move.next_move`.\n-\n-We distinguish between \"var\" assignments, which are assignments to a\n-variable like `x = foo`, and \"path\" assignments (`x.f = foo`).  This\n-is because we need to assign dataflows to the former, but not the\n-latter, so as to check for double initialization of immutable\n-variables.\n-\n-### Gathering and checking moves\n-\n-Like loans, we distinguish two phases. The first, gathering, is where\n-we uncover all the moves and assignments. As with loans, we do some\n-basic sanity checking in this phase, so we'll report errors if you\n-attempt to move out of a borrowed pointer etc. Then we do the dataflow\n-(see `FlowedMoveData::new`). Finally, in the `check_loans.rs` code, we\n-walk back over, identify all uses, assignments, and captures, and\n-check that they are legal given the set of dataflow bits we have\n-computed for that program point.\n-\n-# Drop flags and structural fragments\n-\n-In addition to the job of enforcing memory safety, the borrow checker\n-code is also responsible for identifying the *structural fragments* of\n-data in the function, to support out-of-band dynamic drop flags\n-allocated on the stack. (For background, see [RFC PR #320].)\n-\n-[RFC PR #320]: https://github.com/rust-lang/rfcs/pull/320\n-\n-Semantically, each piece of data that has a destructor may need a\n-boolean flag to indicate whether or not its destructor has been run\n-yet. However, in many cases there is no need to actually maintain such\n-a flag: It can be apparent from the code itself that a given path is\n-always initialized (or always deinitialized) when control reaches the\n-end of its owner's scope, and thus we can unconditionally emit (or\n-not) the destructor invocation for that path.\n-\n-A simple example of this is the following:\n-\n-```rust\n-struct D { p: i32 }\n-impl D { fn new(x: i32) -> D { ... }\n-impl Drop for D { ... }\n-\n-fn foo(a: D, b: D, t: || -> bool) {\n-    let c: D;\n-    let d: D;\n-    if t() { c = b; }\n-}\n-```\n-\n-At the end of the body of `foo`, the compiler knows that `a` is\n-initialized, introducing a drop obligation (deallocating the boxed\n-integer) for the end of `a`'s scope that is run unconditionally.\n-Likewise the compiler knows that `d` is not initialized, and thus it\n-leave out the drop code for `d`.\n-\n-The compiler cannot statically know the drop-state of `b` nor `c` at\n-the end of their scope, since that depends on the value of\n-`t`. Therefore, we need to insert boolean flags to track whether we\n-need to drop `b` and `c`.\n-\n-However, the matter is not as simple as just mapping local variables\n-to their corresponding drop flags when necessary. In particular, in\n-addition to being able to move data out of local variables, Rust\n-allows one to move values in and out of structured data.\n-\n-Consider the following:\n-\n-```rust\n-struct S { x: D, y: D, z: D }\n-\n-fn foo(a: S, mut b: S, t: || -> bool) {\n-    let mut c: S;\n-    let d: S;\n-    let e: S = a.clone();\n-    if t() {\n-        c = b;\n-        b.x = e.y;\n-    }\n-    if t() { c.y = D::new(4); }\n-}\n-```\n-\n-As before, the drop obligations of `a` and `d` can be statically\n-determined, and again the state of `b` and `c` depend on dynamic\n-state. But additionally, the dynamic drop obligations introduced by\n-`b` and `c` are not just per-local boolean flags. For example, if the\n-first call to `t` returns `false` and the second call `true`, then at\n-the end of their scope, `b` will be completely initialized, but only\n-`c.y` in `c` will be initialized.  If both calls to `t` return `true`,\n-then at the end of their scope, `c` will be completely initialized,\n-but only `b.x` will be initialized in `b`, and only `e.x` and `e.z`\n-will be initialized in `e`.\n-\n-Note that we need to cover the `z` field in each case in some way,\n-since it may (or may not) need to be dropped, even though `z` is never\n-directly mentioned in the body of the `foo` function. We call a path\n-like `b.z` a *fragment sibling* of `b.x`, since the field `z` comes\n-from the same structure `S` that declared the field `x` in `b.x`.\n-\n-In general we need to maintain boolean flags that match the\n-`S`-structure of both `b` and `c`.  In addition, we need to consult\n-such a flag when doing an assignment (such as `c.y = D::new(4);`\n-above), in order to know whether or not there is a previous value that\n-needs to be dropped before we do the assignment.\n-\n-So for any given function, we need to determine what flags are needed\n-to track its drop obligations. Our strategy for determining the set of\n-flags is to represent the fragmentation of the structure explicitly:\n-by starting initially from the paths that are explicitly mentioned in\n-moves and assignments (such as `b.x` and `c.y` above), and then\n-traversing the structure of the path's type to identify leftover\n-*unmoved fragments*: assigning into `c.y` means that `c.x` and `c.z`\n-are leftover unmoved fragments. Each fragment represents a drop\n-obligation that may need to be tracked. Paths that are only moved or\n-assigned in their entirety (like `a` and `d`) are treated as a single\n-drop obligation.\n-\n-The fragment construction process works by piggy-backing on the\n-existing `move_data` module. We already have callbacks that visit each\n-direct move and assignment; these form the basis for the sets of\n-moved_leaf_paths and assigned_leaf_paths. From these leaves, we can\n-walk up their parent chain to identify all of their parent paths.\n-We need to identify the parents because of cases like the following:\n-\n-```rust\n-struct Pair<X,Y>{ x: X, y: Y }\n-fn foo(dd_d_d: Pair<Pair<Pair<D, D>, D>, D>) {\n-    other_function(dd_d_d.x.y);\n-}\n-```\n-\n-In this code, the move of the path `dd_d.x.y` leaves behind not only\n-the fragment drop-obligation `dd_d.x.x` but also `dd_d.y` as well.\n-\n-Once we have identified the directly-referenced leaves and their\n-parents, we compute the left-over fragments, in the function\n-`fragments::add_fragment_siblings`. As of this writing this works by\n-looking at each directly-moved or assigned path P, and blindly\n-gathering all sibling fields of P (as well as siblings for the parents\n-of P, etc). After accumulating all such siblings, we filter out the\n-entries added as siblings of P that turned out to be\n-directly-referenced paths (or parents of directly referenced paths)\n-themselves, thus leaving the never-referenced \"left-overs\" as the only\n-thing left from the gathering step.\n-\n-## Array structural fragments\n-\n-A special case of the structural fragments discussed above are\n-the elements of an array that has been passed by value, such as\n-the following:\n-\n-```rust\n-fn foo(a: [D; 10], i: i32) -> D {\n-    a[i]\n-}\n-```\n-\n-The above code moves a single element out of the input array `a`.\n-The remainder of the array still needs to be dropped; i.e., it\n-is a structural fragment. Note that after performing such a move,\n-it is not legal to read from the array `a`. There are a number of\n-ways to deal with this, but the important thing to note is that\n-the semantics needs to distinguish in some manner between a\n-fragment that is the *entire* array versus a fragment that represents\n-all-but-one element of the array.  A place where that distinction\n-would arise is the following:\n-\n-```rust\n-fn foo(a: [D; 10], b: [D; 10], i: i32, t: bool) -> D {\n-    if t {\n-        a[i]\n-    } else {\n-        b[i]\n-    }\n-\n-    // When control exits, we will need either to drop all of `a`\n-    // and all-but-one of `b`, or to drop all of `b` and all-but-one\n-    // of `a`.\n-}\n-```\n-\n-There are a number of ways that the codegen backend could choose to\n-compile this (e.g. a `[bool; 10]` array for each such moved array;\n-or an `Option<usize>` for each moved array).  From the viewpoint of the\n-borrow-checker, the important thing is to record what kind of fragment\n-is implied by the relevant moves.\n-\n-# Future work\n-\n-While writing up these docs, I encountered some rules I believe to be\n-stricter than necessary:\n-\n-- I think restricting the `&mut` P against moves and `ALIAS` is sufficient,\n-  `MUTATE` and `CLAIM` are overkill. `MUTATE` was necessary when swap was\n-  a built-in operator, but as it is not, it is implied by `CLAIM`,\n-  and `CLAIM` is implied by `ALIAS`. The only net effect of this is an\n-  extra error message in some cases, though.\n-- I have not described how closures interact. Current code is unsound.\n-  I am working on describing and implementing the fix.\n-- If we wish, we can easily extend the move checking to allow finer-grained\n-  tracking of what is initialized and what is not, enabling code like\n-  this:\n-\n-      a = x.f.g; // x.f.g is now uninitialized\n-      // here, x and x.f are not usable, but x.f.h *is*\n-      x.f.g = b; // x.f.g is not initialized\n-      // now x, x.f, x.f.g, x.f.h are all usable\n-\n-  What needs to change here, most likely, is that the `moves` module\n-  should record not only what paths are moved, but what expressions\n-  are actual *uses*. For example, the reference to `x` in `x.f.g = b`\n-  is not a true *use* in the sense that it requires `x` to be fully\n-  initialized. This is in fact why the above code produces an error\n-  today: the reference to `x` in `x.f.g = b` is considered illegal\n-  because `x` is not fully initialized.\n-\n-There are also some possible refactorings:\n-\n-- It might be nice to replace all loan paths with the MovePath mechanism,\n-  since they allow lightweight comparison using an integer."}, {"sha": "dd2aeb4276faacd46ac8dabee260bb6a3703adaa", "filename": "src/librustc_ast_borrowck/borrowck/check_loans.rs", "status": "removed", "additions": 0, "deletions": 680, "changes": 680, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,680 +0,0 @@\n-// ----------------------------------------------------------------------\n-// Checking loans\n-//\n-// Phase 2 of check: we walk down the tree and check that:\n-// 1. assignments are always made to mutable locations;\n-// 2. loans made in overlapping scopes do not conflict\n-// 3. assignments do not affect things loaned out as immutable\n-// 4. moves do not affect things loaned out in any way\n-\n-use crate::borrowck::*;\n-use crate::borrowck::InteriorKind::{InteriorElement, InteriorField};\n-use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::expr_use_visitor::MutateMode;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::middle::region;\n-use rustc::ty::{self, TyCtxt, RegionKind};\n-use syntax_pos::Span;\n-use rustc::hir;\n-use rustc::hir::Node;\n-use log::debug;\n-\n-use std::rc::Rc;\n-\n-// FIXME (#16118): These functions are intended to allow the borrow checker to\n-// be less precise in its handling of Box while still allowing moves out of a\n-// Box. They should be removed when Unique is removed from LoanPath.\n-\n-fn owned_ptr_base_path<'a, 'tcx>(loan_path: &'a LoanPath<'tcx>) -> &'a LoanPath<'tcx> {\n-    //! Returns the base of the leftmost dereference of an Unique in\n-    //! `loan_path`. If there is no dereference of an Unique in `loan_path`,\n-    //! then it just returns `loan_path` itself.\n-\n-    return match helper(loan_path) {\n-        Some(new_loan_path) => new_loan_path,\n-        None => loan_path,\n-    };\n-\n-    fn helper<'a, 'tcx>(loan_path: &'a LoanPath<'tcx>) -> Option<&'a LoanPath<'tcx>> {\n-        match loan_path.kind {\n-            LpVar(_) | LpUpvar(_) => None,\n-            LpExtend(ref lp_base, _, LpDeref(mc::Unique)) => {\n-                match helper(&lp_base) {\n-                    v @ Some(_) => v,\n-                    None => Some(&lp_base)\n-                }\n-            }\n-            LpDowncast(ref lp_base, _) |\n-            LpExtend(ref lp_base, ..) => helper(&lp_base)\n-        }\n-    }\n-}\n-\n-fn owned_ptr_base_path_rc<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Rc<LoanPath<'tcx>> {\n-    //! The equivalent of `owned_ptr_base_path` for an &Rc<LoanPath> rather than\n-    //! a &LoanPath.\n-\n-    return match helper(loan_path) {\n-        Some(new_loan_path) => new_loan_path,\n-        None => loan_path.clone()\n-    };\n-\n-    fn helper<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Option<Rc<LoanPath<'tcx>>> {\n-        match loan_path.kind {\n-            LpVar(_) | LpUpvar(_) => None,\n-            LpExtend(ref lp_base, _, LpDeref(mc::Unique)) => {\n-                match helper(lp_base) {\n-                    v @ Some(_) => v,\n-                    None => Some(lp_base.clone())\n-                }\n-            }\n-            LpDowncast(ref lp_base, _) |\n-            LpExtend(ref lp_base, ..) => helper(lp_base)\n-        }\n-    }\n-}\n-\n-struct CheckLoanCtxt<'a, 'tcx> {\n-    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    dfcx_loans: &'a LoanDataFlow<'tcx>,\n-    move_data: &'a move_data::FlowedMoveData<'tcx>,\n-    all_loans: &'a [Loan<'tcx>],\n-    movable_generator: bool,\n-}\n-\n-impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n-    fn consume(&mut self,\n-               consume_id: hir::HirId,\n-               _: Span,\n-               cmt: &mc::cmt_<'tcx>,\n-               mode: euv::ConsumeMode) {\n-        debug!(\"consume(consume_id={}, cmt={:?})\", consume_id, cmt);\n-\n-        self.consume_common(consume_id.local_id, cmt, mode);\n-    }\n-\n-    fn matched_pat(&mut self,\n-                   _matched_pat: &hir::Pat,\n-                   _cmt: &mc::cmt_<'_>,\n-                   _mode: euv::MatchMode) { }\n-\n-    fn consume_pat(&mut self,\n-                   consume_pat: &hir::Pat,\n-                   cmt: &mc::cmt_<'tcx>,\n-                   mode: euv::ConsumeMode) {\n-        debug!(\"consume_pat(consume_pat={:?}, cmt={:?})\", consume_pat, cmt);\n-\n-        self.consume_common(consume_pat.hir_id.local_id, cmt, mode);\n-    }\n-\n-    fn borrow(&mut self,\n-              borrow_id: hir::HirId,\n-              borrow_span: Span,\n-              cmt: &mc::cmt_<'tcx>,\n-              loan_region: ty::Region<'tcx>,\n-              bk: ty::BorrowKind,\n-              loan_cause: euv::LoanCause)\n-    {\n-        debug!(\"borrow(borrow_id={}, cmt={:?}, loan_region={:?}, \\\n-               bk={:?}, loan_cause={:?})\",\n-               borrow_id, cmt, loan_region,\n-               bk, loan_cause);\n-\n-        if let Some(lp) = opt_loan_path(cmt) {\n-            self.check_if_path_is_moved(borrow_id.local_id, &lp);\n-        }\n-\n-        self.check_for_conflicting_loans(borrow_id.local_id);\n-\n-        self.check_for_loans_across_yields(cmt, loan_region, borrow_span);\n-    }\n-\n-    fn mutate(&mut self,\n-              assignment_id: hir::HirId,\n-              _: Span,\n-              assignee_cmt: &mc::cmt_<'tcx>,\n-              mode: euv::MutateMode)\n-    {\n-        debug!(\"mutate(assignment_id={}, assignee_cmt={:?})\",\n-               assignment_id, assignee_cmt);\n-\n-        if let Some(lp) = opt_loan_path(assignee_cmt) {\n-            match mode {\n-                MutateMode::Init | MutateMode::JustWrite => {\n-                    // In a case like `path = 1`, then path does not\n-                    // have to be *FULLY* initialized, but we still\n-                    // must be careful lest it contains derefs of\n-                    // pointers.\n-                    self.check_if_assigned_path_is_moved(assignee_cmt.hir_id.local_id, &lp);\n-                }\n-                MutateMode::WriteAndRead => {\n-                    // In a case like `path += 1`, then path must be\n-                    // fully initialized, since we will read it before\n-                    // we write it.\n-                    self.check_if_path_is_moved(assignee_cmt.hir_id.local_id,\n-                                                &lp);\n-                }\n-            }\n-        }\n-        self.check_assignment(assignment_id.local_id, assignee_cmt);\n-    }\n-\n-    fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) { }\n-}\n-\n-pub fn check_loans<'a, 'tcx>(\n-    bccx: &BorrowckCtxt<'a, 'tcx>,\n-    dfcx_loans: &LoanDataFlow<'tcx>,\n-    move_data: &move_data::FlowedMoveData<'tcx>,\n-    all_loans: &[Loan<'tcx>],\n-    body: &hir::Body,\n-) {\n-    debug!(\"check_loans(body id={})\", body.value.hir_id);\n-\n-    let def_id = bccx.tcx.hir().body_owner_def_id(body.id());\n-\n-    let hir_id = bccx.tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let movable_generator = !match bccx.tcx.hir().get(hir_id) {\n-        Node::Expr(&hir::Expr {\n-            kind: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n-            ..\n-        }) => true,\n-        _ => false,\n-    };\n-\n-    let param_env = bccx.tcx.param_env(def_id);\n-    let mut clcx = CheckLoanCtxt {\n-        bccx,\n-        dfcx_loans,\n-        move_data,\n-        all_loans,\n-        movable_generator,\n-    };\n-    let rvalue_promotable_map = bccx.tcx.rvalue_promotable_map(def_id);\n-    euv::ExprUseVisitor::new(&mut clcx,\n-                             bccx.tcx,\n-                             def_id,\n-                             param_env,\n-                             &bccx.region_scope_tree,\n-                             bccx.tables,\n-                             Some(rvalue_promotable_map))\n-        .consume_body(body);\n-}\n-\n-fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n-                           borrow_kind2: ty::BorrowKind)\n-                           -> bool {\n-    borrow_kind1 == ty::ImmBorrow && borrow_kind2 == ty::ImmBorrow\n-}\n-\n-impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'tcx> { self.bccx.tcx }\n-\n-    pub fn each_issued_loan<F>(&self, node: hir::ItemLocalId, mut op: F) -> bool where\n-        F: FnMut(&Loan<'tcx>) -> bool,\n-    {\n-        //! Iterates over each loan that has been issued\n-        //! on entrance to `node`, regardless of whether it is\n-        //! actually *in scope* at that point. Sometimes loans\n-        //! are issued for future scopes and thus they may have been\n-        //! *issued* but not yet be in effect.\n-\n-        self.dfcx_loans.each_bit_on_entry(node, |loan_index| {\n-            let loan = &self.all_loans[loan_index];\n-            op(loan)\n-        })\n-    }\n-\n-    pub fn each_in_scope_loan<F>(&self, scope: region::Scope, mut op: F) -> bool where\n-        F: FnMut(&Loan<'tcx>) -> bool,\n-    {\n-        //! Like `each_issued_loan()`, but only considers loans that are\n-        //! currently in scope.\n-\n-        self.each_issued_loan(scope.item_local_id(), |loan| {\n-            if self.bccx.region_scope_tree.is_subscope_of(scope, loan.kill_scope) {\n-                op(loan)\n-            } else {\n-                true\n-            }\n-        })\n-    }\n-\n-    fn each_in_scope_loan_affecting_path<F>(&self,\n-                                            scope: region::Scope,\n-                                            loan_path: &LoanPath<'tcx>,\n-                                            mut op: F)\n-                                            -> bool where\n-        F: FnMut(&Loan<'tcx>) -> bool,\n-    {\n-        //! Iterates through all of the in-scope loans affecting `loan_path`,\n-        //! calling `op`, and ceasing iteration if `false` is returned.\n-\n-        // First, we check for a loan restricting the path P being used. This\n-        // accounts for borrows of P but also borrows of subpaths, like P.a.b.\n-        // Consider the following example:\n-        //\n-        //     let x = &mut a.b.c; // Restricts a, a.b, and a.b.c\n-        //     let y = a;          // Conflicts with restriction\n-\n-        let loan_path = owned_ptr_base_path(loan_path);\n-        let cont = self.each_in_scope_loan(scope, |loan| {\n-            let mut ret = true;\n-            for restr_path in &loan.restricted_paths {\n-                if **restr_path == *loan_path {\n-                    if !op(loan) {\n-                        ret = false;\n-                        break;\n-                    }\n-                }\n-            }\n-            ret\n-        });\n-\n-        if !cont {\n-            return false;\n-        }\n-\n-        // Next, we must check for *loans* (not restrictions) on the path P or\n-        // any base path. This rejects examples like the following:\n-        //\n-        //     let x = &mut a.b;\n-        //     let y = a.b.c;\n-        //\n-        // Limiting this search to *loans* and not *restrictions* means that\n-        // examples like the following continue to work:\n-        //\n-        //     let x = &mut a.b;\n-        //     let y = a.c;\n-\n-        let mut loan_path = loan_path;\n-        loop {\n-            match loan_path.kind {\n-                LpVar(_) | LpUpvar(_) => {\n-                    break;\n-                }\n-                LpDowncast(ref lp_base, _) |\n-                LpExtend(ref lp_base, ..) => {\n-                    loan_path = &lp_base;\n-                }\n-            }\n-\n-            let cont = self.each_in_scope_loan(scope, |loan| {\n-                if *loan.loan_path == *loan_path {\n-                    op(loan)\n-                } else {\n-                    true\n-                }\n-            });\n-\n-            if !cont {\n-                return false;\n-            }\n-        }\n-\n-        return true;\n-    }\n-\n-    pub fn loans_generated_by(&self, node: hir::ItemLocalId) -> Vec<usize> {\n-        //! Returns a vector of the loans that are generated as\n-        //! we enter `node`.\n-\n-        let mut result = Vec::new();\n-        self.dfcx_loans.each_gen_bit(node, |loan_index| {\n-            result.push(loan_index);\n-            true\n-        });\n-        return result;\n-    }\n-\n-    pub fn check_for_loans_across_yields(&self,\n-                                         cmt: &mc::cmt_<'tcx>,\n-                                         loan_region: ty::Region<'tcx>,\n-                                         borrow_span: Span) {\n-        pub fn borrow_of_local_data(cmt: &mc::cmt_<'_>) -> bool {\n-            match cmt.cat {\n-                // Borrows of static items is allowed\n-                Categorization::StaticItem => false,\n-                // Reborrow of already borrowed data is ignored\n-                // Any errors will be caught on the initial borrow\n-                Categorization::Deref(..) => false,\n-\n-                // By-ref upvars has Derefs so they will get ignored.\n-                // Generators counts as FnOnce so this leaves only\n-                // by-move upvars, which is local data for generators\n-                Categorization::Upvar(..) => true,\n-\n-                Categorization::ThreadLocal(region) |\n-                Categorization::Rvalue(region) => {\n-                    // Rvalues promoted to 'static are no longer local\n-                    if let RegionKind::ReStatic = *region {\n-                        false\n-                    } else {\n-                        true\n-                    }\n-                }\n-\n-                // Borrow of local data must be checked\n-                Categorization::Local(..) => true,\n-\n-                // For interior references and downcasts, find out if the base is local\n-                Categorization::Downcast(ref cmt_base, _) |\n-                Categorization::Interior(ref cmt_base, _) => borrow_of_local_data(&cmt_base),\n-            }\n-        }\n-\n-        if !self.movable_generator {\n-            return;\n-        }\n-\n-        if !borrow_of_local_data(cmt) {\n-            return;\n-        }\n-\n-        let scope = match *loan_region {\n-            // A concrete region in which we will look for a yield expression\n-            RegionKind::ReScope(scope) => scope,\n-\n-            // There cannot be yields inside an empty region\n-            RegionKind::ReEmpty => return,\n-\n-            // Local data cannot have these lifetimes\n-            RegionKind::ReEarlyBound(..) |\n-            RegionKind::ReLateBound(..) |\n-            RegionKind::ReFree(..) |\n-            RegionKind::ReStatic => {\n-                self.bccx\n-                    .tcx\n-                    .sess.delay_span_bug(borrow_span,\n-                                         &format!(\"unexpected region for local data {:?}\",\n-                                                  loan_region));\n-                return\n-            }\n-\n-            // These cannot exist in borrowck\n-            RegionKind::ReVar(..) |\n-            RegionKind::RePlaceholder(..) |\n-            RegionKind::ReClosureBound(..) |\n-            RegionKind::ReErased => span_bug!(borrow_span,\n-                                              \"unexpected region in borrowck {:?}\",\n-                                              loan_region),\n-        };\n-\n-        let body_id = self.bccx.body.value.hir_id.local_id;\n-\n-        if self.bccx.region_scope_tree.containing_body(scope) != Some(body_id) {\n-            // We are borrowing local data longer than its storage.\n-            // This should result in other borrowck errors.\n-            self.bccx.tcx.sess.delay_span_bug(borrow_span,\n-                                              \"borrowing local data longer than its storage\");\n-            return;\n-        }\n-\n-        if let Some(_) = self.bccx.region_scope_tree\n-            .yield_in_scope_for_expr(scope, cmt.hir_id, self.bccx.body)\n-        {\n-            self.bccx.signal_error();\n-        }\n-    }\n-\n-    pub fn check_for_conflicting_loans(&self, node: hir::ItemLocalId) {\n-        //! Checks to see whether any of the loans that are issued\n-        //! on entrance to `node` conflict with loans that have already been\n-        //! issued when we enter `node` (for example, we do not\n-        //! permit two `&mut` borrows of the same variable).\n-        //!\n-        //! (Note that some loans can be *issued* without necessarily\n-        //! taking effect yet.)\n-\n-        debug!(\"check_for_conflicting_loans(node={:?})\", node);\n-\n-        let new_loan_indices = self.loans_generated_by(node);\n-        debug!(\"new_loan_indices = {:?}\", new_loan_indices);\n-\n-        for &new_loan_index in &new_loan_indices {\n-            self.each_issued_loan(node, |issued_loan| {\n-                let new_loan = &self.all_loans[new_loan_index];\n-                // Only report an error for the first issued loan that conflicts\n-                // to avoid O(n^2) errors.\n-                self.report_error_if_loans_conflict(issued_loan, new_loan)\n-            });\n-        }\n-\n-        for (i, &x) in new_loan_indices.iter().enumerate() {\n-            let old_loan = &self.all_loans[x];\n-            for &y in &new_loan_indices[(i+1) ..] {\n-                let new_loan = &self.all_loans[y];\n-                self.report_error_if_loans_conflict(old_loan, new_loan);\n-            }\n-        }\n-    }\n-\n-    pub fn report_error_if_loans_conflict(\n-        &self,\n-        old_loan: &Loan<'tcx>,\n-        new_loan: &Loan<'tcx>,\n-    ) -> bool {\n-        //! Checks whether `old_loan` and `new_loan` can safely be issued\n-        //! simultaneously.\n-\n-        debug!(\"report_error_if_loans_conflict(old_loan={:?}, new_loan={:?})\",\n-               old_loan,\n-               new_loan);\n-\n-        // Should only be called for loans that are in scope at the same time.\n-        assert!(self.bccx.region_scope_tree.scopes_intersect(old_loan.kill_scope,\n-                                                       new_loan.kill_scope));\n-\n-        self.report_error_if_loan_conflicts_with_restriction(\n-            old_loan, new_loan)\n-        && self.report_error_if_loan_conflicts_with_restriction(\n-                new_loan, old_loan)\n-    }\n-\n-    pub fn report_error_if_loan_conflicts_with_restriction(\n-        &self,\n-        loan1: &Loan<'tcx>,\n-        loan2: &Loan<'tcx>,\n-    ) -> bool {\n-        //! Checks whether the restrictions introduced by `loan1` would\n-        //! prohibit `loan2`.\n-        debug!(\"report_error_if_loan_conflicts_with_restriction(\\\n-                loan1={:?}, loan2={:?})\",\n-               loan1,\n-               loan2);\n-\n-        if compatible_borrow_kinds(loan1.kind, loan2.kind) {\n-            return true;\n-        }\n-\n-        let loan2_base_path = owned_ptr_base_path_rc(&loan2.loan_path);\n-        for restr_path in &loan1.restricted_paths {\n-            if *restr_path != loan2_base_path { continue; }\n-\n-            self.bccx.signal_error();\n-            return false;\n-        }\n-\n-        true\n-    }\n-\n-    fn consume_common(\n-        &self,\n-        id: hir::ItemLocalId,\n-        cmt: &mc::cmt_<'tcx>,\n-        mode: euv::ConsumeMode,\n-    ) {\n-        if let Some(lp) = opt_loan_path(cmt) {\n-            match mode {\n-                euv::Copy => {\n-                    self.check_for_copy_of_frozen_path(id, &lp);\n-                }\n-                euv::Move(_) => {\n-                    // Sometimes moves aren't from a move path;\n-                    // this either means that the original move\n-                    // was from something illegal to move,\n-                    // or was moved from referent of an unsafe\n-                    // pointer or something like that.\n-                    if self.move_data.is_move_path(id, &lp) {\n-                        self.check_for_move_of_borrowed_path(id, &lp);\n-                    }\n-                }\n-            }\n-            self.check_if_path_is_moved(id, &lp);\n-        }\n-    }\n-\n-    fn check_for_copy_of_frozen_path(&self,\n-                                     id: hir::ItemLocalId,\n-                                     copy_path: &LoanPath<'tcx>) {\n-        self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow);\n-    }\n-\n-    fn check_for_move_of_borrowed_path(&self,\n-                                       id: hir::ItemLocalId,\n-                                       move_path: &LoanPath<'tcx>) {\n-        // We want to detect if there are any loans at all, so we search for\n-        // any loans incompatible with MutBorrrow, since all other kinds of\n-        // loans are incompatible with that.\n-        self.analyze_restrictions_on_use(id, move_path, ty::MutBorrow);\n-    }\n-\n-    fn analyze_restrictions_on_use(&self,\n-                                       expr_id: hir::ItemLocalId,\n-                                       use_path: &LoanPath<'tcx>,\n-                                       borrow_kind: ty::BorrowKind) {\n-        debug!(\"analyze_restrictions_on_use(expr_id={:?}, use_path={:?})\",\n-               expr_id, use_path);\n-\n-        let scope = region::Scope {\n-            id: expr_id,\n-            data: region::ScopeData::Node\n-        };\n-        self.each_in_scope_loan_affecting_path(\n-            scope, use_path, |loan| {\n-            if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n-                self.bccx.signal_error();\n-                false\n-            } else {\n-                true\n-            }\n-        });\n-    }\n-\n-    /// Reports an error if `expr` (which should be a path)\n-    /// is using a moved/uninitialized value\n-    fn check_if_path_is_moved(&self,\n-                              id: hir::ItemLocalId,\n-                              lp: &Rc<LoanPath<'tcx>>) {\n-        debug!(\"check_if_path_is_moved(id={:?}, lp={:?})\", id, lp);\n-\n-        // FIXME: if you find yourself tempted to cut and paste\n-        // the body below and then specializing the error reporting,\n-        // consider refactoring this instead!\n-\n-        let base_lp = owned_ptr_base_path_rc(lp);\n-        self.move_data.each_move_of(id, &base_lp, |_, _| {\n-            self.bccx.signal_error();\n-            false\n-        });\n-    }\n-\n-    /// Reports an error if assigning to `lp` will use a\n-    /// moved/uninitialized value. Mainly this is concerned with\n-    /// detecting derefs of uninitialized pointers.\n-    ///\n-    /// For example:\n-    ///\n-    /// ```\n-    /// let a: i32;\n-    /// a = 10; // ok, even though a is uninitialized\n-    /// ```\n-    ///\n-    /// ```\n-    /// struct Point { x: u32, y: u32 }\n-    /// let mut p: Point;\n-    /// p.x = 22; // ok, even though `p` is uninitialized\n-    /// ```\n-    ///\n-    /// ```compile_fail,E0381\n-    /// # struct Point { x: u32, y: u32 }\n-    /// let mut p: Box<Point>;\n-    /// (*p).x = 22; // not ok, p is uninitialized, can't deref\n-    /// ```\n-    fn check_if_assigned_path_is_moved(&self,\n-                                       id: hir::ItemLocalId,\n-                                       lp: &Rc<LoanPath<'tcx>>)\n-    {\n-        match lp.kind {\n-            LpVar(_) | LpUpvar(_) => {\n-                // assigning to `x` does not require that `x` is initialized\n-            }\n-            LpDowncast(ref lp_base, _) => {\n-                // assigning to `(P->Variant).f` is ok if assigning to `P` is ok\n-                self.check_if_assigned_path_is_moved(id, lp_base);\n-            }\n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorField(_))) => {\n-                match lp_base.to_type().kind {\n-                    ty::Adt(def, _) if def.has_dtor(self.tcx()) => {\n-                        // In the case where the owner implements drop, then\n-                        // the path must be initialized to prevent a case of\n-                        // partial reinitialization\n-                        //\n-                        // FIXME: could refactor via hypothetical\n-                        // generalized check_if_path_is_moved\n-                        let loan_path = owned_ptr_base_path_rc(lp_base);\n-                        self.move_data.each_move_of(id, &loan_path, |_, _| {\n-                            self.bccx\n-                                .signal_error();\n-                            false\n-                        });\n-                        return;\n-                    },\n-                    _ => {},\n-                }\n-\n-                // assigning to `P.f` is ok if assigning to `P` is ok\n-                self.check_if_assigned_path_is_moved(id, lp_base);\n-            }\n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement)) |\n-            LpExtend(ref lp_base, _, LpDeref(_)) => {\n-                // assigning to `P[i]` requires `P` is initialized\n-                // assigning to `(*P)` requires `P` is initialized\n-                self.check_if_path_is_moved(id, lp_base);\n-            }\n-        }\n-    }\n-\n-    fn check_assignment(&self,\n-                        assignment_id: hir::ItemLocalId,\n-                        assignee_cmt: &mc::cmt_<'tcx>) {\n-        debug!(\"check_assignment(assignee_cmt={:?})\", assignee_cmt);\n-\n-        // Check that we don't invalidate any outstanding loans\n-        if let Some(loan_path) = opt_loan_path(assignee_cmt) {\n-            let scope = region::Scope {\n-                id: assignment_id,\n-                data: region::ScopeData::Node\n-            };\n-            self.each_in_scope_loan_affecting_path(scope, &loan_path, |_| {\n-                self.bccx.signal_error();\n-                false\n-            });\n-        }\n-\n-        // Check for reassignments to (immutable) local variables. This\n-        // needs to be done here instead of in check_loans because we\n-        // depend on move data.\n-        if let Categorization::Local(_) = assignee_cmt.cat {\n-            let lp = opt_loan_path(assignee_cmt).unwrap();\n-            self.move_data.each_assignment_of(assignment_id, &lp, |_| {\n-                if !assignee_cmt.mutbl.is_mutable() {\n-                    self.bccx.signal_error();\n-                }\n-                false\n-            });\n-            return\n-        }\n-    }\n-}"}, {"sha": "2239bf56bbed2bd96b46cd9a1f94d8cb7fe05b1a", "filename": "src/librustc_ast_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,135 +0,0 @@\n-//! Computes moves.\n-\n-use crate::borrowck::*;\n-use crate::borrowck::move_data::*;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n-use rustc::ty::{self, Ty};\n-\n-use std::rc::Rc;\n-use syntax_pos::Span;\n-use log::debug;\n-\n-struct GatherMoveInfo<'c, 'tcx> {\n-    id: hir::ItemLocalId,\n-    cmt: &'c mc::cmt_<'tcx>,\n-}\n-\n-pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                             move_data: &MoveData<'tcx>,\n-                             var_id: hir::HirId,\n-                             var_ty: Ty<'tcx>) {\n-    let loan_path = Rc::new(LoanPath::new(LpVar(var_id), var_ty));\n-    move_data.add_move(bccx.tcx, loan_path, var_id.local_id);\n-}\n-\n-pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                       move_data: &MoveData<'tcx>,\n-                                       move_expr_id: hir::ItemLocalId,\n-                                       cmt: &mc::cmt_<'tcx>) {\n-    let move_info = GatherMoveInfo {\n-        id: move_expr_id,\n-        cmt,\n-    };\n-    gather_move(bccx, move_data, move_info);\n-}\n-\n-pub fn gather_move_from_pat<'a, 'c, 'tcx>(\n-    bccx: &BorrowckCtxt<'a, 'tcx>,\n-    move_data: &MoveData<'tcx>,\n-    move_pat: &hir::Pat,\n-    cmt: &'c mc::cmt_<'tcx>,\n-) {\n-    let move_info = GatherMoveInfo {\n-        id: move_pat.hir_id.local_id,\n-        cmt,\n-    };\n-\n-    debug!(\"gather_move_from_pat: move_pat={:?}\", move_pat);\n-\n-    gather_move(bccx, move_data, move_info);\n-}\n-\n-fn gather_move<'a, 'c, 'tcx>(\n-    bccx: &BorrowckCtxt<'a, 'tcx>,\n-    move_data: &MoveData<'tcx>,\n-    move_info: GatherMoveInfo<'c, 'tcx>,\n-) {\n-    debug!(\"gather_move(move_id={:?}, cmt={:?})\",\n-           move_info.id, move_info.cmt);\n-\n-    let potentially_illegal_move = check_and_get_illegal_move_origin(bccx, move_info.cmt);\n-    if let Some(_) = potentially_illegal_move {\n-        bccx.signal_error();\n-        return;\n-    }\n-\n-    match opt_loan_path(&move_info.cmt) {\n-        Some(loan_path) => {\n-            move_data.add_move(bccx.tcx, loan_path,\n-                               move_info.id);\n-        }\n-        None => {\n-            // move from rvalue or raw pointer, hence ok\n-        }\n-    }\n-}\n-\n-pub fn gather_assignment<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                   move_data: &MoveData<'tcx>,\n-                                   assignment_id: hir::ItemLocalId,\n-                                   assignment_span: Span,\n-                                   assignee_loan_path: Rc<LoanPath<'tcx>>) {\n-    move_data.add_assignment(bccx.tcx,\n-                             assignee_loan_path,\n-                             assignment_id,\n-                             assignment_span);\n-}\n-\n-// (keep in sync with move_error::report_cannot_move_out_of )\n-fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                               cmt: &mc::cmt_<'tcx>)\n-                                               -> Option<mc::cmt_<'tcx>> {\n-    match cmt.cat {\n-        Categorization::Deref(_, mc::BorrowedPtr(..)) |\n-        Categorization::Deref(_, mc::UnsafePtr(..)) |\n-        Categorization::ThreadLocal(..) |\n-        Categorization::StaticItem => {\n-            Some(cmt.clone())\n-        }\n-\n-        Categorization::Rvalue(..) |\n-        Categorization::Local(..) |\n-        Categorization::Upvar(..) => {\n-            None\n-        }\n-\n-        Categorization::Downcast(ref b, _) |\n-        Categorization::Interior(ref b, mc::InteriorField(_)) |\n-        Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern)) => {\n-            match b.ty.kind {\n-                ty::Adt(def, _) => {\n-                    if def.has_dtor(bccx.tcx) {\n-                        Some(cmt.clone())\n-                    } else {\n-                        check_and_get_illegal_move_origin(bccx, b)\n-                    }\n-                }\n-                ty::Slice(..) => Some(cmt.clone()),\n-                _ => {\n-                    check_and_get_illegal_move_origin(bccx, b)\n-                }\n-            }\n-        }\n-\n-        Categorization::Interior(_, mc::InteriorElement(Kind::Index)) => {\n-            // Forbid move of arr[i] for arr: [T; 3]; see RFC 533.\n-            Some(cmt.clone())\n-        }\n-\n-        Categorization::Deref(ref b, mc::Unique) => {\n-            check_and_get_illegal_move_origin(bccx, b)\n-        }\n-    }\n-}"}, {"sha": "ff7dd66793d1880d2ce321c31c950cd2ca227b3c", "filename": "src/librustc_ast_borrowck/borrowck/gather_loans/lifetime.rs", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,113 +0,0 @@\n-//! This module implements the check that the lifetime of a borrow\n-//! does not exceed the lifetime of the value being borrowed.\n-\n-use crate::borrowck::*;\n-use rustc::hir::HirId;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::middle::region;\n-use rustc::ty;\n-\n-use log::debug;\n-\n-type R = Result<(),()>;\n-\n-pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                    item_scope: region::Scope,\n-                                    cmt: &'a mc::cmt_<'tcx>,\n-                                    loan_region: ty::Region<'tcx>)\n-                                    -> Result<(),()> {\n-    //! Reports error if `loan_region` is larger than S\n-    //! where S is `item_scope` if `cmt` is an upvar,\n-    //! and is scope of `cmt` otherwise.\n-    debug!(\"guarantee_lifetime(cmt={:?}, loan_region={:?})\",\n-           cmt, loan_region);\n-    let ctxt = GuaranteeLifetimeContext { bccx, item_scope, loan_region };\n-    ctxt.check(cmt, None)\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Private\n-\n-struct GuaranteeLifetimeContext<'a, 'tcx> {\n-    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-\n-    // the scope of the function body for the enclosing item\n-    item_scope: region::Scope,\n-\n-    loan_region: ty::Region<'tcx>,\n-}\n-\n-impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n-    fn check(&self, cmt: &mc::cmt_<'tcx>, discr_scope: Option<HirId>) -> R {\n-        //! Main routine. Walks down `cmt` until we find the\n-        //! \"guarantor\". Reports an error if `self.loan_region` is\n-        //! larger than scope of `cmt`.\n-        debug!(\"guarantee_lifetime.check(cmt={:?}, loan_region={:?})\",\n-               cmt,\n-               self.loan_region);\n-\n-        match cmt.cat {\n-            Categorization::Rvalue(..) |\n-            Categorization::ThreadLocal(..) |\n-            Categorization::Local(..) |                     // L-Local\n-            Categorization::Upvar(..) |\n-            Categorization::Deref(_, mc::BorrowedPtr(..)) | // L-Deref-Borrowed\n-            Categorization::Deref(_, mc::UnsafePtr(..)) => {\n-                self.check_scope(self.scope(cmt))\n-            }\n-\n-            Categorization::StaticItem => {\n-                Ok(())\n-            }\n-\n-            Categorization::Downcast(ref base, _) |\n-            Categorization::Deref(ref base, mc::Unique) |   // L-Deref-Send\n-            Categorization::Interior(ref base, _) => {      // L-Field\n-                self.check(base, discr_scope)\n-            }\n-        }\n-    }\n-\n-    fn check_scope(&self, max_scope: ty::Region<'tcx>) -> R {\n-        //! Reports an error if `loan_region` is larger than `max_scope`\n-\n-        if !self.bccx.is_subregion_of(self.loan_region, max_scope) {\n-            Err(self.bccx.signal_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    fn scope(&self, cmt: &mc::cmt_<'tcx>) -> ty::Region<'tcx> {\n-        //! Returns the maximal region scope for the which the\n-        //! place `cmt` is guaranteed to be valid without any\n-        //! rooting etc, and presuming `cmt` is not mutated.\n-\n-        match cmt.cat {\n-            Categorization::ThreadLocal(temp_scope) |\n-            Categorization::Rvalue(temp_scope) => {\n-                temp_scope\n-            }\n-            Categorization::Upvar(..) => {\n-                self.bccx.tcx.mk_region(ty::ReScope(self.item_scope))\n-            }\n-            Categorization::Local(hir_id) => {\n-                self.bccx.tcx.mk_region(ty::ReScope(\n-                    self.bccx.region_scope_tree.var_scope(hir_id.local_id)))\n-            }\n-            Categorization::StaticItem |\n-            Categorization::Deref(_, mc::UnsafePtr(..)) => {\n-                self.bccx.tcx.lifetimes.re_static\n-            }\n-            Categorization::Deref(_, mc::BorrowedPtr(_, r)) => {\n-                r\n-            }\n-            Categorization::Downcast(ref cmt, _) |\n-            Categorization::Deref(ref cmt, mc::Unique) |\n-            Categorization::Interior(ref cmt, _) => {\n-                self.scope(cmt)\n-            }\n-        }\n-    }\n-}"}, {"sha": "16fef705ec9538ef6339b4e121e9d5738418110b", "filename": "src/librustc_ast_borrowck/borrowck/gather_loans/mod.rs", "status": "removed", "additions": 0, "deletions": 433, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,433 +0,0 @@\n-// ----------------------------------------------------------------------\n-// Gathering loans\n-//\n-// The borrow check proceeds in two phases. In phase one, we gather the full\n-// set of loans that are required at any point.  These are sorted according to\n-// their associated scopes.  In phase two, checking loans, we will then make\n-// sure that all of these loans are honored.\n-\n-use crate::borrowck::*;\n-use crate::borrowck::move_data::MoveData;\n-use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::middle::region;\n-use rustc::ty::{self, TyCtxt};\n-\n-use syntax_pos::Span;\n-use rustc::hir;\n-use log::debug;\n-\n-use restrictions::RestrictionResult;\n-\n-mod lifetime;\n-mod restrictions;\n-mod gather_moves;\n-\n-pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                    body: hir::BodyId)\n-                                    -> (Vec<Loan<'tcx>>, move_data::MoveData<'tcx>) {\n-    let def_id = bccx.tcx.hir().body_owner_def_id(body);\n-    let param_env = bccx.tcx.param_env(def_id);\n-    let mut glcx = GatherLoanCtxt {\n-        bccx,\n-        all_loans: Vec::new(),\n-        item_ub: region::Scope {\n-            id: bccx.tcx.hir().body(body).value.hir_id.local_id,\n-            data: region::ScopeData::Node\n-        },\n-        move_data: MoveData::default(),\n-    };\n-\n-    let rvalue_promotable_map = bccx.tcx.rvalue_promotable_map(def_id);\n-    euv::ExprUseVisitor::new(&mut glcx,\n-                             bccx.tcx,\n-                             def_id,\n-                             param_env,\n-                             &bccx.region_scope_tree,\n-                             bccx.tables,\n-                             Some(rvalue_promotable_map))\n-        .consume_body(bccx.body);\n-\n-    let GatherLoanCtxt { all_loans, move_data, .. } = glcx;\n-    (all_loans, move_data)\n-}\n-\n-struct GatherLoanCtxt<'a, 'tcx> {\n-    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    move_data: move_data::MoveData<'tcx>,\n-    all_loans: Vec<Loan<'tcx>>,\n-    /// `item_ub` is used as an upper-bound on the lifetime whenever we\n-    /// ask for the scope of an expression categorized as an upvar.\n-    item_ub: region::Scope,\n-}\n-\n-impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n-    fn consume(&mut self,\n-               consume_id: hir::HirId,\n-               _consume_span: Span,\n-               cmt: &mc::cmt_<'tcx>,\n-               mode: euv::ConsumeMode) {\n-        debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n-               consume_id, cmt, mode);\n-\n-        match mode {\n-            euv::Move(_) => {\n-                gather_moves::gather_move_from_expr(\n-                    self.bccx, &self.move_data,\n-                    consume_id.local_id, cmt);\n-            }\n-            euv::Copy => { }\n-        }\n-    }\n-\n-    fn matched_pat(&mut self,\n-                   matched_pat: &hir::Pat,\n-                   cmt: &mc::cmt_<'tcx>,\n-                   mode: euv::MatchMode) {\n-        debug!(\"matched_pat(matched_pat={:?}, cmt={:?}, mode={:?})\",\n-               matched_pat,\n-               cmt,\n-               mode);\n-    }\n-\n-    fn consume_pat(&mut self,\n-                   consume_pat: &hir::Pat,\n-                   cmt: &mc::cmt_<'tcx>,\n-                   mode: euv::ConsumeMode) {\n-        debug!(\"consume_pat(consume_pat={:?}, cmt={:?}, mode={:?})\",\n-               consume_pat,\n-               cmt,\n-               mode);\n-\n-        match mode {\n-            euv::Copy => { return; }\n-            euv::Move(_) => { }\n-        }\n-\n-        gather_moves::gather_move_from_pat(\n-            self.bccx, &self.move_data,\n-            consume_pat, cmt);\n-    }\n-\n-    fn borrow(&mut self,\n-              borrow_id: hir::HirId,\n-              _: Span,\n-              cmt: &mc::cmt_<'tcx>,\n-              loan_region: ty::Region<'tcx>,\n-              bk: ty::BorrowKind,\n-              loan_cause: euv::LoanCause)\n-    {\n-        debug!(\"borrow(borrow_id={}, cmt={:?}, loan_region={:?}, \\\n-               bk={:?}, loan_cause={:?})\",\n-               borrow_id, cmt, loan_region,\n-               bk, loan_cause);\n-\n-        self.guarantee_valid(borrow_id.local_id,\n-                             cmt,\n-                             bk,\n-                             loan_region);\n-    }\n-\n-    fn mutate(&mut self,\n-              assignment_id: hir::HirId,\n-              assignment_span: Span,\n-              assignee_cmt: &mc::cmt_<'tcx>,\n-              _: euv::MutateMode)\n-    {\n-        self.guarantee_assignment_valid(assignment_id,\n-                                        assignment_span,\n-                                        assignee_cmt);\n-    }\n-\n-    fn decl_without_init(&mut self, id: hir::HirId, _span: Span) {\n-        let ty = self.bccx\n-                     .tables\n-                     .node_type(id);\n-        gather_moves::gather_decl(self.bccx, &self.move_data, id, ty);\n-    }\n-\n-    fn nested_body(&mut self, body_id: hir::BodyId) {\n-        debug!(\"nested_body(body_id={:?})\", body_id);\n-        // rust-lang/rust#58776: MIR and AST borrow check disagree on where\n-        // certain closure errors are reported. As such migrate borrowck has to\n-        // operate at the level of items, rather than bodies. Check if the\n-        // contained closure had any errors and set `signalled_any_error` if it\n-        // has.\n-        let bccx = self.bccx;\n-        if bccx.tcx.migrate_borrowck() {\n-            if let SignalledError::NoErrorsSeen = bccx.signalled_any_error.get() {\n-                let closure_def_id = bccx.tcx.hir().body_owner_def_id(body_id);\n-                debug!(\"checking closure: {:?}\", closure_def_id);\n-\n-                bccx.signalled_any_error.set(bccx.tcx.borrowck(closure_def_id).signalled_any_error);\n-            }\n-        }\n-    }\n-}\n-\n-/// Implements the A-* rules in README.md.\n-fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                cmt: &mc::cmt_<'tcx>,\n-                                req_kind: ty::BorrowKind)\n-                                -> Result<(),()> {\n-\n-    let aliasability = cmt.freely_aliasable();\n-    debug!(\"check_aliasability aliasability={:?} req_kind={:?}\",\n-           aliasability, req_kind);\n-\n-    match (aliasability, req_kind) {\n-        (mc::Aliasability::NonAliasable, _) => {\n-            /* Uniquely accessible path -- OK for `&` and `&mut` */\n-            Ok(())\n-        }\n-        (mc::Aliasability::FreelyAliasable(mc::AliasableStatic), ty::ImmBorrow) => {\n-            // Borrow of an immutable static item.\n-            Ok(())\n-        }\n-        (mc::Aliasability::FreelyAliasable(mc::AliasableStaticMut), _) => {\n-            // Even touching a static mut is considered unsafe. We assume the\n-            // user knows what they're doing in these cases.\n-            Ok(())\n-        }\n-        (mc::Aliasability::FreelyAliasable(_), ty::UniqueImmBorrow) |\n-        (mc::Aliasability::FreelyAliasable(_), ty::MutBorrow) => {\n-            bccx.signal_error();\n-            Err(())\n-        }\n-        (..) => {\n-            Ok(())\n-        }\n-    }\n-}\n-\n-/// Implements the M-* rules in README.md.\n-fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                              cmt: &mc::cmt_<'tcx>,\n-                              req_kind: ty::BorrowKind)\n-                              -> Result<(),()> {\n-    debug!(\"check_mutability(cmt={:?} req_kind={:?}\", cmt, req_kind);\n-    match req_kind {\n-        ty::UniqueImmBorrow | ty::ImmBorrow => {\n-            match cmt.mutbl {\n-                // I am intentionally leaving this here to help\n-                // refactoring if, in the future, we should add new\n-                // kinds of mutability.\n-                mc::McImmutable | mc::McDeclared | mc::McInherited => {\n-                    // both imm and mut data can be lent as imm;\n-                    // for mutable data, this is a freeze\n-                    Ok(())\n-                }\n-            }\n-        }\n-\n-        ty::MutBorrow => {\n-            // Only mutable data can be lent as mutable.\n-            if !cmt.mutbl.is_mutable() {\n-                Err(bccx.signal_error())\n-            } else {\n-                Ok(())\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'tcx> { self.bccx.tcx }\n-\n-    /// Guarantees that `cmt` is assignable, or reports an error.\n-    fn guarantee_assignment_valid(&mut self,\n-                                  assignment_id: hir::HirId,\n-                                  assignment_span: Span,\n-                                  cmt: &mc::cmt_<'tcx>) {\n-\n-        let opt_lp = opt_loan_path(cmt);\n-        debug!(\"guarantee_assignment_valid(assignment_id={}, cmt={:?}) opt_lp={:?}\",\n-               assignment_id, cmt, opt_lp);\n-\n-        if let Categorization::Local(..) = cmt.cat {\n-            // Only re-assignments to locals require it to be\n-            // mutable - this is checked in check_loans.\n-        } else {\n-            // Check that we don't allow assignments to non-mutable data.\n-            if check_mutability(self.bccx, cmt, ty::MutBorrow).is_err() {\n-                return; // reported an error, no sense in reporting more.\n-            }\n-        }\n-\n-        // Check that we don't allow assignments to aliasable data\n-        if check_aliasability(self.bccx, cmt, ty::MutBorrow).is_err() {\n-            return; // reported an error, no sense in reporting more.\n-        }\n-\n-        match opt_lp {\n-            Some(lp) => {\n-                gather_moves::gather_assignment(self.bccx, &self.move_data,\n-                                                assignment_id.local_id,\n-                                                assignment_span,\n-                                                lp);\n-            }\n-            None => {\n-                // This can occur with e.g., `*foo() = 5`.  In such\n-                // cases, there is no need to check for conflicts\n-                // with moves etc, just ignore.\n-            }\n-        }\n-    }\n-\n-    /// Guarantees that `addr_of(cmt)` will be valid for the duration of `static_scope_r`, or\n-    /// reports an error. This may entail taking out loans, which will be added to the\n-    /// `req_loan_map`.\n-    fn guarantee_valid(&mut self,\n-                       borrow_id: hir::ItemLocalId,\n-                       cmt: &mc::cmt_<'tcx>,\n-                       req_kind: ty::BorrowKind,\n-                       loan_region: ty::Region<'tcx>) {\n-        debug!(\"guarantee_valid(borrow_id={:?}, cmt={:?}, \\\n-                req_mutbl={:?}, loan_region={:?})\",\n-               borrow_id,\n-               cmt,\n-               req_kind,\n-               loan_region);\n-\n-        // a loan for the empty region can never be dereferenced, so\n-        // it is always safe\n-        if *loan_region == ty::ReEmpty {\n-            return;\n-        }\n-\n-        // Check that the lifetime of the borrow does not exceed\n-        // the lifetime of the data being borrowed.\n-        if lifetime::guarantee_lifetime(self.bccx, self.item_ub, cmt, loan_region).is_err() {\n-            return; // reported an error, no sense in reporting more.\n-        }\n-\n-        // Check that we don't allow mutable borrows of non-mutable data.\n-        if check_mutability(self.bccx, cmt, req_kind).is_err() {\n-            return; // reported an error, no sense in reporting more.\n-        }\n-\n-        // Check that we don't allow mutable borrows of aliasable data.\n-        if check_aliasability(self.bccx, cmt, req_kind).is_err() {\n-            return; // reported an error, no sense in reporting more.\n-        }\n-\n-        // Compute the restrictions that are required to enforce the\n-        // loan is safe.\n-        let restr = restrictions::compute_restrictions(self.bccx, &cmt, loan_region);\n-\n-        debug!(\"guarantee_valid(): restrictions={:?}\", restr);\n-\n-        // Create the loan record (if needed).\n-        let loan = match restr {\n-            RestrictionResult::Safe => {\n-                // No restrictions---no loan record necessary\n-                return;\n-            }\n-\n-            RestrictionResult::SafeIf(loan_path, restricted_paths) => {\n-                let loan_scope = match *loan_region {\n-                    ty::ReScope(scope) => scope,\n-\n-                    ty::ReEarlyBound(ref br) => {\n-                        self.bccx.region_scope_tree.early_free_scope(self.tcx(), br)\n-                    }\n-\n-                    ty::ReFree(ref fr) => {\n-                        self.bccx.region_scope_tree.free_scope(self.tcx(), fr)\n-                    }\n-\n-                    ty::ReStatic => self.item_ub,\n-\n-                    ty::ReEmpty |\n-                    ty::ReClosureBound(..) |\n-                    ty::ReLateBound(..) |\n-                    ty::ReVar(..) |\n-                    ty::RePlaceholder(..) |\n-                    ty::ReErased => {\n-                        span_bug!(\n-                            cmt.span,\n-                            \"invalid borrow lifetime: {:?}\",\n-                            loan_region);\n-                    }\n-                };\n-                debug!(\"loan_scope = {:?}\", loan_scope);\n-\n-                let borrow_scope = region::Scope {\n-                    id: borrow_id,\n-                    data: region::ScopeData::Node\n-                };\n-                let gen_scope = self.compute_gen_scope(borrow_scope, loan_scope);\n-                debug!(\"gen_scope = {:?}\", gen_scope);\n-\n-                let kill_scope = self.compute_kill_scope(loan_scope, &loan_path);\n-                debug!(\"kill_scope = {:?}\", kill_scope);\n-\n-                Loan {\n-                    index: self.all_loans.len(),\n-                    loan_path,\n-                    kind: req_kind,\n-                    gen_scope,\n-                    kill_scope,\n-                    restricted_paths,\n-                }\n-            }\n-        };\n-\n-        debug!(\"guarantee_valid(borrow_id={:?}), loan={:?}\",\n-               borrow_id, loan);\n-\n-        // let loan_path = loan.loan_path;\n-        // let loan_gen_scope = loan.gen_scope;\n-        // let loan_kill_scope = loan.kill_scope;\n-        self.all_loans.push(loan);\n-    }\n-\n-    pub fn compute_gen_scope(&self,\n-                             borrow_scope: region::Scope,\n-                             loan_scope: region::Scope)\n-                             -> region::Scope {\n-        //! Determine when to introduce the loan. Typically the loan\n-        //! is introduced at the point of the borrow, but in some cases,\n-        //! notably method arguments, the loan may be introduced only\n-        //! later, once it comes into scope.\n-\n-        if self.bccx.region_scope_tree.is_subscope_of(borrow_scope, loan_scope) {\n-            borrow_scope\n-        } else {\n-            loan_scope\n-        }\n-    }\n-\n-    pub fn compute_kill_scope(&self, loan_scope: region::Scope, lp: &LoanPath<'tcx>)\n-                              -> region::Scope {\n-        //! Determine when the loan restrictions go out of scope.\n-        //! This is either when the lifetime expires or when the\n-        //! local variable which roots the loan-path goes out of scope,\n-        //! whichever happens faster.\n-        //!\n-        //! It may seem surprising that we might have a loan region\n-        //! larger than the variable which roots the loan-path; this can\n-        //! come about when variables of `&mut` type are re-borrowed,\n-        //! as in this example:\n-        //!\n-        //!     struct Foo { counter: u32 }\n-        //!\n-        //!     fn counter<'a>(v: &'a mut Foo) -> &'a mut u32 {\n-        //!         &mut v.counter\n-        //!     }\n-        //!\n-        //! In this case, the reference (`'a`) outlives the\n-        //! variable `v` that hosts it. Note that this doesn't come up\n-        //! with immutable `&` pointers, because borrows of such pointers\n-        //! do not require restrictions and hence do not cause a loan.\n-\n-        let lexical_scope = lp.kill_scope(self.bccx);\n-        if self.bccx.region_scope_tree.is_subscope_of(lexical_scope, loan_scope) {\n-            lexical_scope\n-        } else {\n-            assert!(self.bccx.region_scope_tree.is_subscope_of(loan_scope, lexical_scope));\n-            loan_scope\n-        }\n-    }\n-}"}, {"sha": "ee5099a97d57fcf8fc88e04d39d477bb65ad2bd8", "filename": "src/librustc_ast_borrowck/borrowck/gather_loans/restrictions.rs", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,179 +0,0 @@\n-//! Computes the restrictions that result from a borrow.\n-\n-use crate::borrowck::*;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::ty;\n-use log::debug;\n-\n-use crate::borrowck::ToInteriorKind;\n-\n-use std::rc::Rc;\n-\n-#[derive(Debug)]\n-pub enum RestrictionResult<'tcx> {\n-    Safe,\n-    SafeIf(Rc<LoanPath<'tcx>>, Vec<Rc<LoanPath<'tcx>>>)\n-}\n-\n-pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                      cmt: &mc::cmt_<'tcx>,\n-                                      loan_region: ty::Region<'tcx>)\n-                                      -> RestrictionResult<'tcx> {\n-    let ctxt = RestrictionsContext { bccx, loan_region };\n-\n-    ctxt.restrict(cmt)\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Private\n-\n-struct RestrictionsContext<'a, 'tcx> {\n-    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    loan_region: ty::Region<'tcx>,\n-}\n-\n-impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n-    fn restrict(&self,\n-                cmt: &mc::cmt_<'tcx>) -> RestrictionResult<'tcx> {\n-        debug!(\"restrict(cmt={:?})\", cmt);\n-\n-        let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n-\n-        match cmt.cat.clone() {\n-            Categorization::Rvalue(..) => {\n-                // Effectively, rvalues are stored into a\n-                // non-aliasable temporary on the stack. Since they\n-                // are inherently non-aliasable, they can only be\n-                // accessed later through the borrow itself and hence\n-                // must inherently comply with its terms.\n-                RestrictionResult::Safe\n-            }\n-\n-            Categorization::ThreadLocal(..) => {\n-                // Thread-locals are statics that have a scope, with\n-                // no underlying structure to provide restrictions.\n-                RestrictionResult::Safe\n-            }\n-\n-            Categorization::Local(local_id) => {\n-                // R-Variable, locally declared\n-                let lp = new_lp(LpVar(local_id));\n-                RestrictionResult::SafeIf(lp.clone(), vec![lp])\n-            }\n-\n-            Categorization::Upvar(mc::Upvar { id, .. }) => {\n-                // R-Variable, captured into closure\n-                let lp = new_lp(LpUpvar(id));\n-                RestrictionResult::SafeIf(lp.clone(), vec![lp])\n-            }\n-\n-            Categorization::Downcast(cmt_base, _) => {\n-                // When we borrow the interior of an enum, we have to\n-                // ensure the enum itself is not mutated, because that\n-                // could cause the type of the memory to change.\n-                self.restrict(&cmt_base)\n-            }\n-\n-            Categorization::Interior(cmt_base, interior) => {\n-                // R-Field\n-                //\n-                // Overwriting the base would not change the type of\n-                // the memory, so no additional restrictions are\n-                // needed.\n-                let opt_variant_id = match cmt_base.cat {\n-                    Categorization::Downcast(_, variant_id) => Some(variant_id),\n-                    _ => None\n-                };\n-                let interior = interior.cleaned();\n-                let base_ty = cmt_base.ty;\n-                let result = self.restrict(&cmt_base);\n-                // Borrowing one union field automatically borrows all its fields.\n-                match base_ty.kind {\n-                    ty::Adt(adt_def, _) if adt_def.is_union() => match result {\n-                        RestrictionResult::Safe => RestrictionResult::Safe,\n-                        RestrictionResult::SafeIf(base_lp, mut base_vec) => {\n-                            for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n-                                let field = InteriorKind::InteriorField(\n-                                    mc::FieldIndex(i, field.ident.name)\n-                                );\n-                                let field_ty = if field == interior {\n-                                    cmt.ty\n-                                } else {\n-                                    self.bccx.tcx.types.err // Doesn't matter\n-                                };\n-                                let sibling_lp_kind = LpExtend(base_lp.clone(), cmt.mutbl,\n-                                                               LpInterior(opt_variant_id, field));\n-                                let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, field_ty));\n-                                base_vec.push(sibling_lp);\n-                            }\n-\n-                            let lp = new_lp(LpExtend(base_lp, cmt.mutbl,\n-                                                     LpInterior(opt_variant_id, interior)));\n-                            RestrictionResult::SafeIf(lp, base_vec)\n-                        }\n-                    },\n-                    _ => self.extend(result, &cmt, LpInterior(opt_variant_id, interior))\n-                }\n-            }\n-\n-            Categorization::StaticItem => {\n-                RestrictionResult::Safe\n-            }\n-\n-            Categorization::Deref(cmt_base, pk) => {\n-                match pk {\n-                    mc::Unique => {\n-                        // R-Deref-Send-Pointer\n-                        //\n-                        // When we borrow the interior of a box, we\n-                        // cannot permit the base to be mutated, because that\n-                        // would cause the unique pointer to be freed.\n-                        //\n-                        // Eventually we should make these non-special and\n-                        // just rely on Deref<T> implementation.\n-                        let result = self.restrict(&cmt_base);\n-                        self.extend(result, &cmt, LpDeref(pk))\n-                    }\n-                    mc::BorrowedPtr(bk, lt) => {\n-                        // R-Deref-[Mut-]Borrowed\n-                        if !self.bccx.is_subregion_of(self.loan_region, lt) {\n-                            self.bccx.signal_error();\n-                            return RestrictionResult::Safe;\n-                        }\n-\n-                        match bk {\n-                            ty::ImmBorrow => RestrictionResult::Safe,\n-                            ty::MutBorrow | ty::UniqueImmBorrow => {\n-                                // R-Deref-Mut-Borrowed\n-                                //\n-                                // The referent can be aliased after the\n-                                // references lifetime ends (by a newly-unfrozen\n-                                // borrow).\n-                                let result = self.restrict(&cmt_base);\n-                                self.extend(result, &cmt, LpDeref(pk))\n-                            }\n-                        }\n-                    }\n-                    // Borrowck is not relevant for raw pointers\n-                    mc::UnsafePtr(..) => RestrictionResult::Safe\n-                }\n-            }\n-        }\n-    }\n-\n-    fn extend(&self,\n-              result: RestrictionResult<'tcx>,\n-              cmt: &mc::cmt_<'tcx>,\n-              elem: LoanPathElem<'tcx>) -> RestrictionResult<'tcx> {\n-        match result {\n-            RestrictionResult::Safe => RestrictionResult::Safe,\n-            RestrictionResult::SafeIf(base_lp, mut base_vec) => {\n-                let v = LpExtend(base_lp, cmt.mutbl, elem);\n-                let lp = Rc::new(LoanPath::new(v, cmt.ty));\n-                base_vec.push(lp.clone());\n-                RestrictionResult::SafeIf(lp, base_vec)\n-            }\n-        }\n-    }\n-}"}, {"sha": "40e28299a5c0a15eac451b9565c236298d125dc7", "filename": "src/librustc_ast_borrowck/borrowck/mod.rs", "status": "removed", "additions": 0, "deletions": 621, "changes": 621, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,621 +0,0 @@\n-//! See The Book chapter on the borrow checker for more details.\n-\n-#![allow(non_camel_case_types)]\n-\n-pub use LoanPathKind::*;\n-pub use LoanPathElem::*;\n-\n-use InteriorKind::*;\n-\n-use rustc::hir::HirId;\n-use rustc::hir::Node;\n-use rustc::middle::borrowck::{BorrowCheckResult, SignalledError};\n-use rustc::hir::def_id::{DefId, LocalDefId};\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::middle::region;\n-use rustc::middle::free_region::RegionRelations;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::query::Providers;\n-\n-use std::borrow::Cow;\n-use std::cell::{Cell};\n-use std::fmt;\n-use std::rc::Rc;\n-use std::hash::{Hash, Hasher};\n-use log::debug;\n-\n-use rustc::hir;\n-\n-use crate::cfg;\n-use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n-\n-pub mod check_loans;\n-\n-pub mod gather_loans;\n-\n-pub mod move_data;\n-\n-#[derive(Clone, Copy)]\n-pub struct LoanDataFlowOperator;\n-\n-pub type LoanDataFlow<'tcx> = DataFlowContext<'tcx, LoanDataFlowOperator>;\n-\n-pub fn check_crate(tcx: TyCtxt<'_>) {\n-    tcx.par_body_owners(|body_owner_def_id| {\n-        tcx.ensure().borrowck(body_owner_def_id);\n-    });\n-}\n-\n-pub fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers {\n-        borrowck,\n-        ..*providers\n-    };\n-}\n-\n-/// Collection of conclusions determined via borrow checker analyses.\n-pub struct AnalysisData<'tcx> {\n-    pub all_loans: Vec<Loan<'tcx>>,\n-    pub loans: DataFlowContext<'tcx, LoanDataFlowOperator>,\n-    pub move_data: move_data::FlowedMoveData<'tcx>,\n-}\n-\n-fn borrowck(tcx: TyCtxt<'_>, owner_def_id: DefId) -> &BorrowCheckResult {\n-    assert!(tcx.use_ast_borrowck() || tcx.migrate_borrowck());\n-\n-    debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n-\n-    let signalled_error = tcx.check_match(owner_def_id);\n-    if let SignalledError::SawSomeError = signalled_error {\n-        return tcx.arena.alloc(BorrowCheckResult {\n-            signalled_any_error: SignalledError::SawSomeError,\n-        })\n-    }\n-\n-    let owner_id = tcx.hir().as_local_hir_id(owner_def_id).unwrap();\n-\n-    match tcx.hir().get(owner_id) {\n-        Node::Ctor(..) => {\n-            // We get invoked with anything that has MIR, but some of\n-            // those things (notably the synthesized constructors from\n-            // tuple structs/variants) do not have an associated body\n-            // and do not need borrowchecking.\n-            return tcx.arena.alloc(BorrowCheckResult {\n-                signalled_any_error: SignalledError::NoErrorsSeen,\n-            })\n-        }\n-        _ => { }\n-    }\n-\n-    let body_id = tcx.hir().body_owned_by(owner_id);\n-    let tables = tcx.typeck_tables_of(owner_def_id);\n-    let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n-    let body = tcx.hir().body(body_id);\n-    let mut bccx = BorrowckCtxt {\n-        tcx,\n-        tables,\n-        region_scope_tree,\n-        owner_def_id,\n-        body,\n-        signalled_any_error: Cell::new(SignalledError::NoErrorsSeen),\n-    };\n-\n-    // Eventually, borrowck will always read the MIR, but at the\n-    // moment we do not. So, for now, we always force MIR to be\n-    // constructed for a given fn, since this may result in errors\n-    // being reported and we want that to happen.\n-    //\n-    // Note that `mir_validated` is a \"stealable\" result; the\n-    // thief, `optimized_mir()`, forces borrowck, so we know that\n-    // is not yet stolen.\n-    tcx.ensure().mir_validated(owner_def_id);\n-\n-    // option dance because you can't capture an uninitialized variable\n-    // by mut-ref.\n-    let mut cfg = None;\n-    if let Some(AnalysisData { all_loans,\n-                               loans: loan_dfcx,\n-                               move_data: flowed_moves }) =\n-        build_borrowck_dataflow_data(&mut bccx, false, body_id,\n-                                     |bccx| {\n-                                         cfg = Some(cfg::CFG::new(bccx.tcx, &body));\n-                                         cfg.as_mut().unwrap()\n-                                     })\n-    {\n-        check_loans::check_loans(&mut bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n-    }\n-\n-    tcx.arena.alloc(BorrowCheckResult {\n-        signalled_any_error: bccx.signalled_any_error.into_inner(),\n-    })\n-}\n-\n-fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tcx>,\n-                                                 force_analysis: bool,\n-                                                 body_id: hir::BodyId,\n-                                                 get_cfg: F)\n-                                                 -> Option<AnalysisData<'tcx>>\n-    where F: FnOnce(&mut BorrowckCtxt<'a, 'tcx>) -> &'c cfg::CFG\n-{\n-    // Check the body of fn items.\n-    let (all_loans, move_data) =\n-        gather_loans::gather_loans_in_fn(this, body_id);\n-\n-    if !force_analysis && move_data.is_empty() && all_loans.is_empty() {\n-        // large arrays of data inserted as constants can take a lot of\n-        // time and memory to borrow-check - see issue #36799. However,\n-        // they don't have places, so no borrow-check is actually needed.\n-        // Recognize that case and skip borrow-checking.\n-        debug!(\"skipping loan propagation for {:?} because of no loans\", body_id);\n-        return None;\n-    } else {\n-        debug!(\"propagating loans in {:?}\", body_id);\n-    }\n-\n-    let cfg = get_cfg(this);\n-    let mut loan_dfcx =\n-        DataFlowContext::new(this.tcx,\n-                             \"borrowck\",\n-                             Some(this.body),\n-                             cfg,\n-                             LoanDataFlowOperator,\n-                             all_loans.len());\n-    for (loan_idx, loan) in all_loans.iter().enumerate() {\n-        loan_dfcx.add_gen(loan.gen_scope.item_local_id(), loan_idx);\n-        loan_dfcx.add_kill(KillFrom::ScopeEnd,\n-                           loan.kill_scope.item_local_id(),\n-                           loan_idx);\n-    }\n-    loan_dfcx.add_kills_from_flow_exits(cfg);\n-    loan_dfcx.propagate(cfg, this.body);\n-\n-    let flowed_moves = move_data::FlowedMoveData::new(move_data,\n-                                                      this,\n-                                                      cfg,\n-                                                      this.body);\n-\n-    Some(AnalysisData { all_loans,\n-                        loans: loan_dfcx,\n-                        move_data:flowed_moves })\n-}\n-\n-/// Accessor for introspective clients inspecting `AnalysisData` and\n-/// the `BorrowckCtxt` itself , e.g., the flowgraph visualizer.\n-pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    body_id: hir::BodyId,\n-    cfg: &cfg::CFG)\n-    -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'tcx>)\n-{\n-    let owner_id = tcx.hir().body_owner(body_id);\n-    let owner_def_id = tcx.hir().local_def_id(owner_id);\n-    let tables = tcx.typeck_tables_of(owner_def_id);\n-    let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n-    let body = tcx.hir().body(body_id);\n-    let mut bccx = BorrowckCtxt {\n-        tcx,\n-        tables,\n-        region_scope_tree,\n-        owner_def_id,\n-        body,\n-        signalled_any_error: Cell::new(SignalledError::NoErrorsSeen),\n-    };\n-\n-    let dataflow_data = build_borrowck_dataflow_data(&mut bccx, true, body_id, |_| cfg);\n-    (bccx, dataflow_data.unwrap())\n-}\n-\n-// ----------------------------------------------------------------------\n-// Type definitions\n-\n-pub struct BorrowckCtxt<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-\n-    // tables for the current thing we are checking; set to\n-    // Some in `borrowck_fn` and cleared later\n-    tables: &'a ty::TypeckTables<'tcx>,\n-\n-    region_scope_tree: &'tcx region::ScopeTree,\n-\n-    owner_def_id: DefId,\n-\n-    body: &'tcx hir::Body,\n-\n-    signalled_any_error: Cell<SignalledError>,\n-}\n-\n-\n-impl<'a, 'tcx: 'a> BorrowckCtxt<'a, 'tcx> {\n-    fn signal_error(&self) {\n-        self.signalled_any_error.set(SignalledError::SawSomeError);\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Loans and loan paths\n-\n-/// Record of a loan that was issued.\n-pub struct Loan<'tcx> {\n-    index: usize,\n-    loan_path: Rc<LoanPath<'tcx>>,\n-    kind: ty::BorrowKind,\n-    restricted_paths: Vec<Rc<LoanPath<'tcx>>>,\n-\n-    /// gen_scope indicates where loan is introduced. Typically the\n-    /// loan is introduced at the point of the borrow, but in some\n-    /// cases, notably method arguments, the loan may be introduced\n-    /// only later, once it comes into scope. See also\n-    /// `GatherLoanCtxt::compute_gen_scope`.\n-    gen_scope: region::Scope,\n-\n-    /// kill_scope indicates when the loan goes out of scope. This is\n-    /// either when the lifetime expires or when the local variable\n-    /// which roots the loan-path goes out of scope, whichever happens\n-    /// faster. See also `GatherLoanCtxt::compute_kill_scope`.\n-    kill_scope: region::Scope,\n-}\n-\n-impl<'tcx> Loan<'tcx> {\n-    pub fn loan_path(&self) -> Rc<LoanPath<'tcx>> {\n-        self.loan_path.clone()\n-    }\n-}\n-\n-#[derive(Eq)]\n-pub struct LoanPath<'tcx> {\n-    kind: LoanPathKind<'tcx>,\n-    ty: Ty<'tcx>,\n-}\n-\n-impl<'tcx> PartialEq for LoanPath<'tcx> {\n-    fn eq(&self, that: &LoanPath<'tcx>) -> bool {\n-        self.kind == that.kind\n-    }\n-}\n-\n-impl<'tcx> Hash for LoanPath<'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.kind.hash(state);\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Hash, Debug)]\n-pub enum LoanPathKind<'tcx> {\n-    LpVar(hir::HirId),                          // `x` in README.md\n-    LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n-    LpDowncast(Rc<LoanPath<'tcx>>, DefId), // `x` downcast to particular enum variant\n-    LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem<'tcx>)\n-}\n-\n-impl<'tcx> LoanPath<'tcx> {\n-    fn new(kind: LoanPathKind<'tcx>, ty: Ty<'tcx>) -> LoanPath<'tcx> {\n-        LoanPath { kind: kind, ty: ty }\n-    }\n-\n-    fn to_type(&self) -> Ty<'tcx> { self.ty }\n-}\n-\n-// FIXME (pnkfelix): See discussion here\n-// https://github.com/pnkfelix/rust/commit/\n-//     b2b39e8700e37ad32b486b9a8409b50a8a53aa51#commitcomment-7892003\n-const DOWNCAST_PRINTED_OPERATOR: &'static str = \" as \";\n-\n-// A local, \"cleaned\" version of `mc::InteriorKind` that drops\n-// information that is not relevant to loan-path analysis. (In\n-// particular, the distinction between how precisely an array-element\n-// is tracked is irrelevant here.)\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum InteriorKind {\n-    InteriorField(mc::FieldIndex),\n-    InteriorElement,\n-}\n-\n-trait ToInteriorKind { fn cleaned(self) -> InteriorKind; }\n-impl ToInteriorKind for mc::InteriorKind {\n-    fn cleaned(self) -> InteriorKind {\n-        match self {\n-            mc::InteriorField(name) => InteriorField(name),\n-            mc::InteriorElement(_) => InteriorElement,\n-        }\n-    }\n-}\n-\n-// This can be:\n-// - a pointer dereference (`*P` in README.md)\n-// - a field reference, with an optional definition of the containing\n-//   enum variant (`P.f` in README.md)\n-// `DefId` is present when the field is part of struct that is in\n-// a variant of an enum. For instance in:\n-// `enum E { X { foo: u32 }, Y { foo: u32 }}`\n-// each `foo` is qualified by the definitition id of the variant (`X` or `Y`).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum LoanPathElem<'tcx> {\n-    LpDeref(mc::PointerKind<'tcx>),\n-    LpInterior(Option<DefId>, InteriorKind),\n-}\n-\n-fn closure_to_block(closure_id: LocalDefId, tcx: TyCtxt<'_>) -> HirId {\n-    let closure_id = tcx.hir().local_def_id_to_hir_id(closure_id);\n-    match tcx.hir().get(closure_id) {\n-        Node::Expr(expr) => match expr.kind {\n-            hir::ExprKind::Closure(.., body_id, _, _) => {\n-                body_id.hir_id\n-            }\n-            _ => {\n-                bug!(\"encountered non-closure id: {}\", closure_id)\n-            }\n-        },\n-        _ => bug!(\"encountered non-expr id: {}\", closure_id)\n-    }\n-}\n-\n-impl<'a, 'tcx> LoanPath<'tcx> {\n-    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::Scope {\n-        match self.kind {\n-            LpVar(hir_id) => {\n-                bccx.region_scope_tree.var_scope(hir_id.local_id)\n-            }\n-            LpUpvar(upvar_id) => {\n-                let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n-                region::Scope { id: block_id.local_id, data: region::ScopeData::Node }\n-            }\n-            LpDowncast(ref base, _) |\n-            LpExtend(ref base, ..) => base.kill_scope(bccx),\n-        }\n-    }\n-}\n-\n-// Avoid \"cannot borrow immutable field `self.x` as mutable\" as that implies that a field *can* be\n-// mutable independently of the struct it belongs to. (#35937)\n-pub fn opt_loan_path_is_field<'tcx>(cmt: &mc::cmt_<'tcx>) -> (Option<Rc<LoanPath<'tcx>>>, bool) {\n-    let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n-\n-    match cmt.cat {\n-        Categorization::Rvalue(..) |\n-        Categorization::ThreadLocal(..) |\n-        Categorization::StaticItem => {\n-            (None, false)\n-        }\n-\n-        Categorization::Local(id) => {\n-            (Some(new_lp(LpVar(id))), false)\n-        }\n-\n-        Categorization::Upvar(mc::Upvar { id, .. }) => {\n-            (Some(new_lp(LpUpvar(id))), false)\n-        }\n-\n-        Categorization::Deref(ref cmt_base, pk) => {\n-            let lp = opt_loan_path_is_field(cmt_base);\n-            (lp.0.map(|lp| {\n-                new_lp(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n-            }), lp.1)\n-        }\n-\n-        Categorization::Interior(ref cmt_base, ik) => {\n-            (opt_loan_path(cmt_base).map(|lp| {\n-                let opt_variant_id = match cmt_base.cat {\n-                    Categorization::Downcast(_, did) =>  Some(did),\n-                    _ => None\n-                };\n-                new_lp(LpExtend(lp, cmt.mutbl, LpInterior(opt_variant_id, ik.cleaned())))\n-            }), true)\n-        }\n-\n-        Categorization::Downcast(ref cmt_base, variant_def_id) => {\n-            let lp = opt_loan_path_is_field(cmt_base);\n-            (lp.0.map(|lp| {\n-                new_lp(LpDowncast(lp, variant_def_id))\n-            }), lp.1)\n-        }\n-    }\n-}\n-\n-/// Computes the `LoanPath` (if any) for a `cmt`.\n-/// Note that this logic is somewhat duplicated in\n-/// the method `compute()` found in `gather_loans::restrictions`,\n-/// which allows it to share common loan path pieces as it\n-/// traverses the CMT.\n-pub fn opt_loan_path<'tcx>(cmt: &mc::cmt_<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n-    opt_loan_path_is_field(cmt).0\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Misc\n-\n-impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n-    pub fn is_subregion_of(&self,\n-                           r_sub: ty::Region<'tcx>,\n-                           r_sup: ty::Region<'tcx>)\n-                           -> bool\n-    {\n-        let region_rels = RegionRelations::new(self.tcx,\n-                                               self.owner_def_id,\n-                                               &self.region_scope_tree,\n-                                               &self.tables.free_region_map);\n-        region_rels.is_subregion_of(r_sub, r_sup)\n-    }\n-\n-    pub fn append_loan_path_to_string(&self,\n-                                      loan_path: &LoanPath<'tcx>,\n-                                      out: &mut String) {\n-        match loan_path.kind {\n-            LpUpvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id: id }, closure_expr_id: _ }) => {\n-                out.push_str(&self.tcx.hir().name(id).as_str());\n-            }\n-            LpVar(id) => {\n-                out.push_str(&self.tcx.hir().name(id).as_str());\n-            }\n-\n-            LpDowncast(ref lp_base, variant_def_id) => {\n-                out.push('(');\n-                self.append_loan_path_to_string(&lp_base, out);\n-                out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(&self.tcx.def_path_str(variant_def_id));\n-                out.push(')');\n-            }\n-\n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorField(mc::FieldIndex(_, info)))) => {\n-                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n-                out.push('.');\n-                out.push_str(&info.as_str());\n-            }\n-\n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement)) => {\n-                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n-                out.push_str(\"[..]\");\n-            }\n-\n-            LpExtend(ref lp_base, _, LpDeref(_)) => {\n-                out.push('*');\n-                self.append_loan_path_to_string(&lp_base, out);\n-            }\n-        }\n-    }\n-\n-    pub fn append_autoderefd_loan_path_to_string(&self,\n-                                                 loan_path: &LoanPath<'tcx>,\n-                                                 out: &mut String) {\n-        match loan_path.kind {\n-            LpExtend(ref lp_base, _, LpDeref(_)) => {\n-                // For a path like `(*x).f` or `(*x)[3]`, autoderef\n-                // rules would normally allow users to omit the `*x`.\n-                // So just serialize such paths to `x.f` or x[3]` respectively.\n-                self.append_autoderefd_loan_path_to_string(&lp_base, out)\n-            }\n-\n-            LpDowncast(ref lp_base, variant_def_id) => {\n-                out.push('(');\n-                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n-                out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(&self.tcx.def_path_str(variant_def_id));\n-                out.push(')');\n-            }\n-\n-            LpVar(..) | LpUpvar(..) | LpExtend(.., LpInterior(..)) => {\n-                self.append_loan_path_to_string(loan_path, out)\n-            }\n-        }\n-    }\n-\n-    pub fn loan_path_to_string(&self, loan_path: &LoanPath<'tcx>) -> String {\n-        let mut result = String::new();\n-        self.append_loan_path_to_string(loan_path, &mut result);\n-        result\n-    }\n-\n-    pub fn cmt_to_cow_str(&self, cmt: &mc::cmt_<'tcx>) -> Cow<'static, str> {\n-        cmt.descriptive_string(self.tcx)\n-    }\n-\n-    pub fn cmt_to_path_or_string(&self, cmt: &mc::cmt_<'tcx>) -> String {\n-        match opt_loan_path(cmt) {\n-            Some(lp) => format!(\"`{}`\", self.loan_path_to_string(&lp)),\n-            None => self.cmt_to_cow_str(cmt).into_owned(),\n-        }\n-    }\n-}\n-\n-impl BitwiseOperator for LoanDataFlowOperator {\n-    #[inline]\n-    fn join(&self, succ: usize, pred: usize) -> usize {\n-        succ | pred // loans from both preds are in scope\n-    }\n-}\n-\n-impl DataFlowOperator for LoanDataFlowOperator {\n-    #[inline]\n-    fn initial_value(&self) -> bool {\n-        false // no loans in scope by default\n-    }\n-}\n-\n-impl fmt::Debug for InteriorKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            InteriorField(mc::FieldIndex(_, info)) => write!(f, \"{}\", info),\n-            InteriorElement => write!(f, \"[]\"),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for Loan<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"Loan_{}({:?}, {:?}, {:?}-{:?}, {:?})\",\n-               self.index,\n-               self.loan_path,\n-               self.kind,\n-               self.gen_scope,\n-               self.kill_scope,\n-               self.restricted_paths)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.kind {\n-            LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_string(id)))\n-            }\n-\n-            LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath {hir_id: var_id}, closure_expr_id }) => {\n-                let s = ty::tls::with(|tcx| {\n-                    tcx.hir().node_to_string(var_id)\n-                });\n-                write!(f, \"$({} captured by id={:?})\", s, closure_expr_id)\n-            }\n-\n-            LpDowncast(ref lp, variant_def_id) => {\n-                let variant_str = if variant_def_id.is_local() {\n-                    ty::tls::with(|tcx| tcx.def_path_str(variant_def_id))\n-                } else {\n-                    format!(\"{:?}\", variant_def_id)\n-                };\n-                write!(f, \"({:?}{}{})\", lp, DOWNCAST_PRINTED_OPERATOR, variant_str)\n-            }\n-\n-            LpExtend(ref lp, _, LpDeref(_)) => {\n-                write!(f, \"{:?}.*\", lp)\n-            }\n-\n-            LpExtend(ref lp, _, LpInterior(_, ref interior)) => {\n-                write!(f, \"{:?}.{:?}\", lp, interior)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for LoanPath<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.kind {\n-            LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().hir_to_user_string(id)))\n-            }\n-\n-            LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath { hir_id }, closure_expr_id: _ }) => {\n-                let s = ty::tls::with(|tcx| {\n-                    tcx.hir().node_to_string(hir_id)\n-                });\n-                write!(f, \"$({} captured by closure)\", s)\n-            }\n-\n-            LpDowncast(ref lp, variant_def_id) => {\n-                let variant_str = if variant_def_id.is_local() {\n-                    ty::tls::with(|tcx| tcx.def_path_str(variant_def_id))\n-                } else {\n-                    format!(\"{:?}\", variant_def_id)\n-                };\n-                write!(f, \"({}{}{})\", lp, DOWNCAST_PRINTED_OPERATOR, variant_str)\n-            }\n-\n-            LpExtend(ref lp, _, LpDeref(_)) => {\n-                write!(f, \"{}.*\", lp)\n-            }\n-\n-            LpExtend(ref lp, _, LpInterior(_, ref interior)) => {\n-                write!(f, \"{}.{:?}\", lp, interior)\n-            }\n-        }\n-    }\n-}"}, {"sha": "6bc42348bcf6c8db059c44a4b8d17a17f9b3a1e5", "filename": "src/librustc_ast_borrowck/borrowck/move_data.rs", "status": "removed", "additions": 0, "deletions": 730, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,730 +0,0 @@\n-//! Data structures used for tracking moves. Please see the extensive\n-//! comments in the section \"Moves and initialization\" in `README.md`.\n-\n-use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n-\n-use crate::borrowck::*;\n-use crate::cfg;\n-use rustc::ty::{self, TyCtxt};\n-use rustc::util::nodemap::FxHashMap;\n-\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-use std::usize;\n-use syntax_pos::Span;\n-use rustc::hir;\n-use log::debug;\n-\n-#[derive(Default)]\n-pub struct MoveData<'tcx> {\n-    /// Move paths. See section \"Move paths\" in `README.md`.\n-    pub paths: RefCell<Vec<MovePath<'tcx>>>,\n-\n-    /// Cache of loan path to move path index, for easy lookup.\n-    pub path_map: RefCell<FxHashMap<Rc<LoanPath<'tcx>>, MovePathIndex>>,\n-\n-    /// Each move or uninitialized variable gets an entry here.\n-    pub moves: RefCell<Vec<Move>>,\n-\n-    /// Assignments to a variable, like `x = foo`. These are assigned\n-    /// bits for dataflow, since we must track them to ensure that\n-    /// immutable variables are assigned at most once along each path.\n-    pub var_assignments: RefCell<Vec<Assignment>>,\n-\n-    /// Assignments to a path, like `x.f = foo`. These are not\n-    /// assigned dataflow bits, but we track them because they still\n-    /// kill move bits.\n-    pub path_assignments: RefCell<Vec<Assignment>>,\n-}\n-\n-pub struct FlowedMoveData<'tcx> {\n-    pub move_data: MoveData<'tcx>,\n-\n-    pub dfcx_moves: MoveDataFlow<'tcx>,\n-\n-    // We could (and maybe should, for efficiency) combine both move\n-    // and assign data flow into one, but this way it's easier to\n-    // distinguish the bits that correspond to moves and assignments.\n-    pub dfcx_assign: AssignDataFlow<'tcx>,\n-}\n-\n-/// Index into `MoveData.paths`, used like a pointer\n-#[derive(Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n-pub struct MovePathIndex(usize);\n-\n-impl MovePathIndex {\n-    fn get(&self) -> usize {\n-        let MovePathIndex(v) = *self; v\n-    }\n-}\n-\n-impl Clone for MovePathIndex {\n-    fn clone(&self) -> MovePathIndex {\n-        MovePathIndex(self.get())\n-    }\n-}\n-\n-#[allow(non_upper_case_globals)]\n-const InvalidMovePathIndex: MovePathIndex = MovePathIndex(usize::MAX);\n-\n-/// Index into `MoveData.moves`, used like a pointer\n-#[derive(Copy, Clone, PartialEq)]\n-pub struct MoveIndex(usize);\n-\n-impl MoveIndex {\n-    fn get(&self) -> usize {\n-        let MoveIndex(v) = *self; v\n-    }\n-}\n-\n-#[allow(non_upper_case_globals)]\n-const InvalidMoveIndex: MoveIndex = MoveIndex(usize::MAX);\n-\n-pub struct MovePath<'tcx> {\n-    /// Loan path corresponding to this move path\n-    pub loan_path: Rc<LoanPath<'tcx>>,\n-\n-    /// Parent pointer, `InvalidMovePathIndex` if root\n-    pub parent: MovePathIndex,\n-\n-    /// Head of linked list of moves to this path,\n-    /// `InvalidMoveIndex` if not moved\n-    pub first_move: MoveIndex,\n-\n-    /// First node in linked list of children, `InvalidMovePathIndex` if leaf\n-    pub first_child: MovePathIndex,\n-\n-    /// Next node in linked list of parent's children (siblings),\n-    /// `InvalidMovePathIndex` if none.\n-    pub next_sibling: MovePathIndex,\n-}\n-\n-\n-#[derive(Copy, Clone)]\n-pub struct Move {\n-    /// Path being moved.\n-    pub path: MovePathIndex,\n-\n-    /// ID of node that is doing the move.\n-    pub id: hir::ItemLocalId,\n-\n-    /// Next node in linked list of moves from `path`, or `InvalidMoveIndex`\n-    pub next_move: MoveIndex\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct Assignment {\n-    /// Path being assigned.\n-    pub path: MovePathIndex,\n-\n-    /// ID where assignment occurs\n-    pub id: hir::ItemLocalId,\n-\n-    /// span of node where assignment occurs\n-    pub span: Span,\n-}\n-\n-#[derive(Clone, Copy)]\n-pub struct MoveDataFlowOperator;\n-\n-pub type MoveDataFlow<'tcx> = DataFlowContext<'tcx, MoveDataFlowOperator>;\n-\n-#[derive(Clone, Copy)]\n-pub struct AssignDataFlowOperator;\n-\n-pub type AssignDataFlow<'tcx> = DataFlowContext<'tcx, AssignDataFlowOperator>;\n-\n-fn loan_path_is_precise(loan_path: &LoanPath<'_>) -> bool {\n-    match loan_path.kind {\n-        LpVar(_) | LpUpvar(_) => {\n-            true\n-        }\n-        LpExtend(.., LpInterior(_, InteriorKind::InteriorElement)) => {\n-            // Paths involving element accesses a[i] do not refer to a unique\n-            // location, as there is no accurate tracking of the indices.\n-            //\n-            // (Paths involving element accesses via slice pattern bindings\n-            // can in principle be tracked precisely, but that is future\n-            // work. For now, continue claiming that they are imprecise.)\n-            false\n-        }\n-        LpDowncast(ref lp_base, _) |\n-        LpExtend(ref lp_base, ..) => {\n-            loan_path_is_precise(&lp_base)\n-        }\n-    }\n-}\n-\n-impl MoveData<'tcx> {\n-    /// Returns `true` if there are no trackable assignments or moves\n-    /// in this move data -- that means that there is nothing that\n-    /// could cause a borrow error.\n-    pub fn is_empty(&self) -> bool {\n-        self.moves.borrow().is_empty() &&\n-            self.path_assignments.borrow().is_empty() &&\n-            self.var_assignments.borrow().is_empty()\n-    }\n-\n-    pub fn path_loan_path(&self, index: MovePathIndex) -> Rc<LoanPath<'tcx>> {\n-        (*self.paths.borrow())[index.get()].loan_path.clone()\n-    }\n-\n-    fn path_parent(&self, index: MovePathIndex) -> MovePathIndex {\n-        (*self.paths.borrow())[index.get()].parent\n-    }\n-\n-    fn path_first_move(&self, index: MovePathIndex) -> MoveIndex {\n-        (*self.paths.borrow())[index.get()].first_move\n-    }\n-\n-    /// Returns the index of first child, or `InvalidMovePathIndex` if\n-    /// `index` is leaf.\n-    fn path_first_child(&self, index: MovePathIndex) -> MovePathIndex {\n-        (*self.paths.borrow())[index.get()].first_child\n-    }\n-\n-    fn path_next_sibling(&self, index: MovePathIndex) -> MovePathIndex {\n-        (*self.paths.borrow())[index.get()].next_sibling\n-    }\n-\n-    fn set_path_first_move(&self,\n-                           index: MovePathIndex,\n-                           first_move: MoveIndex) {\n-        (*self.paths.borrow_mut())[index.get()].first_move = first_move\n-    }\n-\n-    fn set_path_first_child(&self,\n-                            index: MovePathIndex,\n-                            first_child: MovePathIndex) {\n-        (*self.paths.borrow_mut())[index.get()].first_child = first_child\n-    }\n-\n-    fn move_next_move(&self, index: MoveIndex) -> MoveIndex {\n-        //! Type safe indexing operator\n-        (*self.moves.borrow())[index.get()].next_move\n-    }\n-\n-    fn is_var_path(&self, index: MovePathIndex) -> bool {\n-        //! True if `index` refers to a variable\n-        self.path_parent(index) == InvalidMovePathIndex\n-    }\n-\n-    /// Returns the existing move path index for `lp`, if any, and otherwise adds a new index for\n-    /// `lp` and any of its base paths that do not yet have an index.\n-    pub fn move_path(&self, tcx: TyCtxt<'tcx>, lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n-        if let Some(&index) = self.path_map.borrow().get(&lp) {\n-            return index;\n-        }\n-\n-        let index = match lp.kind {\n-            LpVar(..) | LpUpvar(..) => {\n-                let index = MovePathIndex(self.paths.borrow().len());\n-\n-                self.paths.borrow_mut().push(MovePath {\n-                    loan_path: lp.clone(),\n-                    parent: InvalidMovePathIndex,\n-                    first_move: InvalidMoveIndex,\n-                    first_child: InvalidMovePathIndex,\n-                    next_sibling: InvalidMovePathIndex,\n-                });\n-\n-                index\n-            }\n-\n-            LpDowncast(ref base, _) |\n-            LpExtend(ref base, ..) => {\n-                let parent_index = self.move_path(tcx, base.clone());\n-\n-                let index = MovePathIndex(self.paths.borrow().len());\n-\n-                let next_sibling = self.path_first_child(parent_index);\n-                self.set_path_first_child(parent_index, index);\n-\n-                self.paths.borrow_mut().push(MovePath {\n-                    loan_path: lp.clone(),\n-                    parent: parent_index,\n-                    first_move: InvalidMoveIndex,\n-                    first_child: InvalidMovePathIndex,\n-                    next_sibling,\n-                });\n-\n-                index\n-            }\n-        };\n-\n-        debug!(\"move_path(lp={:?}, index={:?})\",\n-               lp,\n-               index);\n-\n-        assert_eq!(index.get(), self.paths.borrow().len() - 1);\n-        self.path_map.borrow_mut().insert(lp, index);\n-        return index;\n-    }\n-\n-    fn existing_move_path(&self, lp: &Rc<LoanPath<'tcx>>)\n-                          -> Option<MovePathIndex> {\n-        self.path_map.borrow().get(lp).cloned()\n-    }\n-\n-    fn existing_base_paths(&self, lp: &Rc<LoanPath<'tcx>>)\n-                           -> Vec<MovePathIndex> {\n-        let mut result = vec![];\n-        self.add_existing_base_paths(lp, &mut result);\n-        result\n-    }\n-\n-    /// Adds any existing move path indices for `lp` and any base paths of `lp` to `result`, but\n-    /// does not add new move paths\n-    fn add_existing_base_paths(&self, lp: &Rc<LoanPath<'tcx>>,\n-                               result: &mut Vec<MovePathIndex>) {\n-        match self.path_map.borrow().get(lp).cloned() {\n-            Some(index) => {\n-                self.each_base_path(index, |p| {\n-                    result.push(p);\n-                    true\n-                });\n-            }\n-            None => {\n-                match lp.kind {\n-                    LpVar(..) | LpUpvar(..) => { }\n-                    LpDowncast(ref b, _) |\n-                    LpExtend(ref b, ..) => {\n-                        self.add_existing_base_paths(b, result);\n-                    }\n-                }\n-            }\n-        }\n-\n-    }\n-\n-    /// Adds a new move entry for a move of `lp` that occurs at location `id` with kind `kind`.\n-    pub fn add_move(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        orig_lp: Rc<LoanPath<'tcx>>,\n-        id: hir::ItemLocalId,\n-    ) {\n-        // Moving one union field automatically moves all its fields. Also move siblings of\n-        // all parent union fields, moves do not propagate upwards automatically.\n-        let mut lp = orig_lp.clone();\n-        while let LpExtend(ref base_lp, mutbl, lp_elem) = lp.clone().kind {\n-            if let (&ty::Adt(adt_def, _), LpInterior(opt_variant_id, interior))\n-                    = (&base_lp.ty.kind, lp_elem) {\n-                if adt_def.is_union() {\n-                    for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n-                        let field =\n-                            InteriorKind::InteriorField(mc::FieldIndex(i, field.ident.name));\n-                        if field != interior {\n-                            let sibling_lp_kind =\n-                                LpExtend(base_lp.clone(), mutbl, LpInterior(opt_variant_id, field));\n-                            let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, tcx.types.err));\n-                            self.add_move_helper(tcx, sibling_lp, id);\n-                        }\n-                    }\n-                }\n-            }\n-            lp = base_lp.clone();\n-        }\n-\n-        self.add_move_helper(tcx, orig_lp, id);\n-    }\n-\n-    fn add_move_helper(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        lp: Rc<LoanPath<'tcx>>,\n-        id: hir::ItemLocalId,\n-    ) {\n-        debug!(\"add_move(lp={:?}, id={:?})\", lp, id);\n-\n-        let path_index = self.move_path(tcx, lp);\n-        let move_index = MoveIndex(self.moves.borrow().len());\n-\n-        let next_move = self.path_first_move(path_index);\n-        self.set_path_first_move(path_index, move_index);\n-\n-        self.moves.borrow_mut().push(Move {\n-            path: path_index,\n-            id,\n-            next_move,\n-        });\n-    }\n-\n-    /// Adds a new record for an assignment to `lp` that occurs at location `id` with the given\n-    /// `span`.\n-    pub fn add_assignment(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        lp: Rc<LoanPath<'tcx>>,\n-        assign_id: hir::ItemLocalId,\n-        span: Span,\n-    ) {\n-        // Assigning to one union field automatically assigns to all its fields.\n-        if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n-            if let ty::Adt(adt_def, _) = base_lp.ty.kind {\n-                if adt_def.is_union() {\n-                    for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n-                        let field =\n-                            InteriorKind::InteriorField(mc::FieldIndex(i, field.ident.name));\n-                        let field_ty = if field == interior {\n-                            lp.ty\n-                        } else {\n-                            tcx.types.err // Doesn't matter\n-                        };\n-                        let sibling_lp_kind = LpExtend(base_lp.clone(), mutbl,\n-                                                    LpInterior(opt_variant_id, field));\n-                        let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, field_ty));\n-                        self.add_assignment_helper(tcx, sibling_lp, assign_id,\n-                                                   span);\n-                    }\n-                    return;\n-                }\n-            }\n-        }\n-\n-        self.add_assignment_helper(tcx, lp, assign_id, span);\n-    }\n-\n-    fn add_assignment_helper(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        lp: Rc<LoanPath<'tcx>>,\n-        assign_id: hir::ItemLocalId,\n-        span: Span,\n-    ) {\n-        debug!(\"add_assignment(lp={:?}, assign_id={:?}\", lp, assign_id);\n-\n-        let path_index = self.move_path(tcx, lp.clone());\n-\n-        let assignment = Assignment {\n-            path: path_index,\n-            id: assign_id,\n-            span,\n-        };\n-\n-        if self.is_var_path(path_index) {\n-            debug!(\"add_assignment[var](lp={:?}, assignment={}, path_index={:?})\",\n-                   lp, self.var_assignments.borrow().len(), path_index);\n-\n-            self.var_assignments.borrow_mut().push(assignment);\n-        } else {\n-            debug!(\"add_assignment[path](lp={:?}, path_index={:?})\",\n-                   lp, path_index);\n-\n-            self.path_assignments.borrow_mut().push(assignment);\n-        }\n-    }\n-\n-    /// Adds the gen/kills for the various moves and\n-    /// assignments into the provided data flow contexts.\n-    /// Moves are generated by moves and killed by assignments and\n-    /// scoping. Assignments are generated by assignment to variables and\n-    /// killed by scoping. See `README.md` for more details.\n-    fn add_gen_kills(\n-        &self,\n-        bccx: &BorrowckCtxt<'_, 'tcx>,\n-        dfcx_moves: &mut MoveDataFlow<'_>,\n-        dfcx_assign: &mut AssignDataFlow<'_>,\n-    ) {\n-        for (i, the_move) in self.moves.borrow().iter().enumerate() {\n-            dfcx_moves.add_gen(the_move.id, i);\n-        }\n-\n-        for (i, assignment) in self.var_assignments.borrow().iter().enumerate() {\n-            dfcx_assign.add_gen(assignment.id, i);\n-            self.kill_moves(assignment.path, assignment.id,\n-                            KillFrom::Execution, dfcx_moves);\n-        }\n-\n-        for assignment in self.path_assignments.borrow().iter() {\n-            self.kill_moves(assignment.path, assignment.id,\n-                            KillFrom::Execution, dfcx_moves);\n-        }\n-\n-        // Kill all moves related to a variable `x` when\n-        // it goes out of scope:\n-        for path in self.paths.borrow().iter() {\n-            match path.loan_path.kind {\n-                LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n-                    let kill_scope = path.loan_path.kill_scope(bccx);\n-                    let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n-                    self.kill_moves(path, kill_scope.item_local_id(),\n-                                    KillFrom::ScopeEnd, dfcx_moves);\n-                }\n-                LpExtend(..) => {}\n-            }\n-        }\n-\n-        // Kill all assignments when the variable goes out of scope:\n-        for (assignment_index, assignment) in\n-                self.var_assignments.borrow().iter().enumerate() {\n-            let lp = self.path_loan_path(assignment.path);\n-            match lp.kind {\n-                LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n-                    let kill_scope = lp.kill_scope(bccx);\n-                    dfcx_assign.add_kill(KillFrom::ScopeEnd,\n-                                         kill_scope.item_local_id(),\n-                                         assignment_index);\n-                }\n-                LpExtend(..) => {\n-                    bug!(\"var assignment for non var path\");\n-                }\n-            }\n-        }\n-    }\n-\n-    fn each_base_path<F>(&self, index: MovePathIndex, mut f: F) -> bool where\n-        F: FnMut(MovePathIndex) -> bool,\n-    {\n-        let mut p = index;\n-        while p != InvalidMovePathIndex {\n-            if !f(p) {\n-                return false;\n-            }\n-            p = self.path_parent(p);\n-        }\n-        return true;\n-    }\n-\n-    // FIXME(#19596) This is a workaround, but there should be better way to do this\n-    fn each_extending_path_<F>(&self, index: MovePathIndex, f: &mut F) -> bool where\n-        F: FnMut(MovePathIndex) -> bool,\n-    {\n-        if !(*f)(index) {\n-            return false;\n-        }\n-\n-        let mut p = self.path_first_child(index);\n-        while p != InvalidMovePathIndex {\n-            if !self.each_extending_path_(p, f) {\n-                return false;\n-            }\n-            p = self.path_next_sibling(p);\n-        }\n-\n-        return true;\n-    }\n-\n-    fn each_extending_path<F>(&self, index: MovePathIndex, mut f: F) -> bool where\n-        F: FnMut(MovePathIndex) -> bool,\n-    {\n-        self.each_extending_path_(index, &mut f)\n-    }\n-\n-    fn each_applicable_move<F>(&self, index0: MovePathIndex, mut f: F) -> bool where\n-        F: FnMut(MoveIndex) -> bool,\n-    {\n-        let mut ret = true;\n-        self.each_extending_path(index0, |index| {\n-            let mut p = self.path_first_move(index);\n-            while p != InvalidMoveIndex {\n-                if !f(p) {\n-                    ret = false;\n-                    break;\n-                }\n-                p = self.move_next_move(p);\n-            }\n-            ret\n-        });\n-        ret\n-    }\n-\n-    fn kill_moves(\n-        &self,\n-        path: MovePathIndex,\n-        kill_id: hir::ItemLocalId,\n-        kill_kind: KillFrom,\n-        dfcx_moves: &mut MoveDataFlow<'_>,\n-    ) {\n-        // We can only perform kills for paths that refer to a unique location,\n-        // since otherwise we may kill a move from one location with an\n-        // assignment referring to another location.\n-\n-        let loan_path = self.path_loan_path(path);\n-        if loan_path_is_precise(&loan_path) {\n-            self.each_applicable_move(path, |move_index| {\n-                debug!(\"kill_moves add_kill {:?} kill_id={:?} move_index={}\",\n-                       kill_kind, kill_id, move_index.get());\n-                dfcx_moves.add_kill(kill_kind, kill_id, move_index.get());\n-                true\n-            });\n-        }\n-    }\n-}\n-\n-impl<'tcx> FlowedMoveData<'tcx> {\n-    pub fn new(\n-        move_data: MoveData<'tcx>,\n-        bccx: &BorrowckCtxt<'_, 'tcx>,\n-        cfg: &cfg::CFG,\n-        body: &hir::Body,\n-    ) -> FlowedMoveData<'tcx> {\n-        let tcx = bccx.tcx;\n-\n-        let mut dfcx_moves =\n-            DataFlowContext::new(tcx,\n-                                 \"flowed_move_data_moves\",\n-                                 Some(body),\n-                                 cfg,\n-                                 MoveDataFlowOperator,\n-                                 move_data.moves.borrow().len());\n-        let mut dfcx_assign =\n-            DataFlowContext::new(tcx,\n-                                 \"flowed_move_data_assigns\",\n-                                 Some(body),\n-                                 cfg,\n-                                 AssignDataFlowOperator,\n-                                 move_data.var_assignments.borrow().len());\n-\n-        move_data.add_gen_kills(bccx,\n-                                &mut dfcx_moves,\n-                                &mut dfcx_assign);\n-\n-        dfcx_moves.add_kills_from_flow_exits(cfg);\n-        dfcx_assign.add_kills_from_flow_exits(cfg);\n-\n-        dfcx_moves.propagate(cfg, body);\n-        dfcx_assign.propagate(cfg, body);\n-\n-        FlowedMoveData {\n-            move_data,\n-            dfcx_moves,\n-            dfcx_assign,\n-        }\n-    }\n-\n-    pub fn is_move_path(&self, id: hir::ItemLocalId, loan_path: &Rc<LoanPath<'tcx>>) -> bool {\n-        //! Returns the kind of a move of `loan_path` by `id`, if one exists.\n-\n-        let mut ret = false;\n-        if let Some(loan_path_index) = self.move_data.path_map.borrow().get(&*loan_path) {\n-            self.dfcx_moves.each_gen_bit(id, |move_index| {\n-                let the_move = self.move_data.moves.borrow();\n-                let the_move = (*the_move)[move_index];\n-                if the_move.path == *loan_path_index {\n-                    ret = true;\n-                    false\n-                } else {\n-                    true\n-                }\n-            });\n-        }\n-        ret\n-    }\n-\n-    /// Iterates through each move of `loan_path` (or some base path of `loan_path`) that *may*\n-    /// have occurred on entry to `id` without an intervening assignment. In other words, any moves\n-    /// that would invalidate a reference to `loan_path` at location `id`.\n-    pub fn each_move_of<F>(&self,\n-                           id: hir::ItemLocalId,\n-                           loan_path: &Rc<LoanPath<'tcx>>,\n-                           mut f: F)\n-                           -> bool where\n-        F: FnMut(&Move, &LoanPath<'tcx>) -> bool,\n-    {\n-        // Bad scenarios:\n-        //\n-        // 1. Move of `a.b.c`, use of `a.b.c`\n-        // 2. Move of `a.b.c`, use of `a.b.c.d`\n-        // 3. Move of `a.b.c`, use of `a` or `a.b`\n-        //\n-        // OK scenario:\n-        //\n-        // 4. move of `a.b.c`, use of `a.b.d`\n-\n-        let base_indices = self.move_data.existing_base_paths(loan_path);\n-        if base_indices.is_empty() {\n-            return true;\n-        }\n-\n-        let opt_loan_path_index = self.move_data.existing_move_path(loan_path);\n-\n-        let mut ret = true;\n-\n-        self.dfcx_moves.each_bit_on_entry(id, |index| {\n-            let the_move = self.move_data.moves.borrow();\n-            let the_move = &(*the_move)[index];\n-            let moved_path = the_move.path;\n-            if base_indices.iter().any(|x| x == &moved_path) {\n-                // Scenario 1 or 2: `loan_path` or some base path of\n-                // `loan_path` was moved.\n-                if !f(the_move, &self.move_data.path_loan_path(moved_path)) {\n-                    ret = false;\n-                }\n-            } else {\n-                if let Some(loan_path_index) = opt_loan_path_index {\n-                    let cont = self.move_data.each_base_path(moved_path, |p| {\n-                        if p == loan_path_index {\n-                            // Scenario 3: some extension of `loan_path`\n-                            // was moved\n-                            f(the_move,\n-                              &self.move_data.path_loan_path(moved_path))\n-                        } else {\n-                            true\n-                        }\n-                    });\n-                    if !cont { ret = false; }\n-                }\n-            }\n-            ret\n-        })\n-    }\n-\n-    /// Iterates through every assignment to `loan_path` that may have occurred on entry to `id`.\n-    /// `loan_path` must be a single variable.\n-    pub fn each_assignment_of<F>(&self,\n-                                 id: hir::ItemLocalId,\n-                                 loan_path: &Rc<LoanPath<'tcx>>,\n-                                 mut f: F)\n-                                 -> bool where\n-        F: FnMut(&Assignment) -> bool,\n-    {\n-        let loan_path_index = {\n-            match self.move_data.existing_move_path(loan_path) {\n-                Some(i) => i,\n-                None => {\n-                    // if there were any assignments, it'd have an index\n-                    return true;\n-                }\n-            }\n-        };\n-\n-        self.dfcx_assign.each_bit_on_entry(id, |index| {\n-            let assignment = self.move_data.var_assignments.borrow();\n-            let assignment = &(*assignment)[index];\n-            if assignment.path == loan_path_index && !f(assignment) {\n-                false\n-            } else {\n-                true\n-            }\n-        })\n-    }\n-}\n-\n-impl BitwiseOperator for MoveDataFlowOperator {\n-    #[inline]\n-    fn join(&self, succ: usize, pred: usize) -> usize {\n-        succ | pred // moves from both preds are in scope\n-    }\n-}\n-\n-impl DataFlowOperator for MoveDataFlowOperator {\n-    #[inline]\n-    fn initial_value(&self) -> bool {\n-        false // no loans in scope by default\n-    }\n-}\n-\n-impl BitwiseOperator for AssignDataFlowOperator {\n-    #[inline]\n-    fn join(&self, succ: usize, pred: usize) -> usize {\n-        succ | pred // moves from both preds are in scope\n-    }\n-}\n-\n-impl DataFlowOperator for AssignDataFlowOperator {\n-    #[inline]\n-    fn initial_value(&self) -> bool {\n-        false // no assignments in scope by default\n-    }\n-}"}, {"sha": "ec7f40f8c9718f1c2fc09a6e6c6eaf382da169fb", "filename": "src/librustc_ast_borrowck/cfg/construct.rs", "status": "removed", "additions": 0, "deletions": 545, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,545 +0,0 @@\n-use crate::cfg::*;\n-\n-use rustc::hir::{self, PatKind};\n-use rustc::hir::def_id::DefId;\n-use rustc::hir::ptr::P;\n-use rustc::middle::region;\n-use rustc::ty::{self, TyCtxt};\n-\n-use rustc_data_structures::graph::implementation as graph;\n-\n-struct CFGBuilder<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    owner_def_id: DefId,\n-    tables: &'a ty::TypeckTables<'tcx>,\n-    graph: CFGGraph,\n-    fn_exit: CFGIndex,\n-    loop_scopes: Vec<LoopScope>,\n-    breakable_block_scopes: Vec<BlockScope>,\n-}\n-\n-#[derive(Copy, Clone)]\n-struct BlockScope {\n-    block_expr_id: hir::ItemLocalId, // ID of breakable block expr node\n-    break_index: CFGIndex, // where to go on `break`\n-}\n-\n-#[derive(Copy, Clone)]\n-struct LoopScope {\n-    loop_id: hir::ItemLocalId, // ID of `loop`/`while` node\n-    continue_index: CFGIndex, // where to go on a `loop`\n-    break_index: CFGIndex, // where to go on a `break`\n-}\n-\n-pub(super) fn construct(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n-    let mut graph = graph::Graph::new();\n-    let entry = graph.add_node(CFGNodeData::Entry);\n-\n-    // `fn_exit` is target of return exprs, which lies somewhere\n-    // outside input `body`. (Distinguishing `fn_exit` and `body_exit`\n-    // also resolves chicken-and-egg problem that arises if you try to\n-    // have return exprs jump to `body_exit` during construction.)\n-    let fn_exit = graph.add_node(CFGNodeData::Exit);\n-    let body_exit;\n-\n-    // Find the tables for this body.\n-    let owner_def_id = tcx.hir().body_owner_def_id(body.id());\n-    let tables = tcx.typeck_tables_of(owner_def_id);\n-\n-    let mut cfg_builder = CFGBuilder {\n-        tcx,\n-        owner_def_id,\n-        tables,\n-        graph,\n-        fn_exit,\n-        loop_scopes: Vec::new(),\n-        breakable_block_scopes: Vec::new(),\n-    };\n-    body_exit = cfg_builder.expr(&body.value, entry);\n-    cfg_builder.add_contained_edge(body_exit, fn_exit);\n-    let CFGBuilder { graph, .. } = cfg_builder;\n-    CFG {\n-        owner_def_id,\n-        graph,\n-        entry,\n-        exit: fn_exit,\n-    }\n-}\n-\n-impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n-    fn block(&mut self, blk: &hir::Block, pred: CFGIndex) -> CFGIndex {\n-        if blk.targeted_by_break {\n-            let expr_exit = self.add_ast_node(blk.hir_id.local_id, &[]);\n-\n-            self.breakable_block_scopes.push(BlockScope {\n-                block_expr_id: blk.hir_id.local_id,\n-                break_index: expr_exit,\n-            });\n-\n-            let mut stmts_exit = pred;\n-            for stmt in &blk.stmts {\n-                stmts_exit = self.stmt(stmt, stmts_exit);\n-            }\n-            let blk_expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n-            self.add_contained_edge(blk_expr_exit, expr_exit);\n-\n-            self.breakable_block_scopes.pop();\n-\n-            expr_exit\n-        } else {\n-            let mut stmts_exit = pred;\n-            for stmt in &blk.stmts {\n-                stmts_exit = self.stmt(stmt, stmts_exit);\n-            }\n-\n-            let expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n-\n-            self.add_ast_node(blk.hir_id.local_id, &[expr_exit])\n-        }\n-    }\n-\n-    fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n-        let exit = match stmt.kind {\n-            hir::StmtKind::Local(ref local) => {\n-                let init_exit = self.opt_expr(&local.init, pred);\n-                self.pat(&local.pat, init_exit)\n-            }\n-            hir::StmtKind::Item(_) => pred,\n-            hir::StmtKind::Expr(ref expr) |\n-            hir::StmtKind::Semi(ref expr) => {\n-                self.expr(&expr, pred)\n-            }\n-        };\n-        self.add_ast_node(stmt.hir_id.local_id, &[exit])\n-    }\n-\n-    fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n-        match pat.kind {\n-            PatKind::Binding(.., None) |\n-            PatKind::Path(_) |\n-            PatKind::Lit(..) |\n-            PatKind::Range(..) |\n-            PatKind::Wild => self.add_ast_node(pat.hir_id.local_id, &[pred]),\n-\n-            PatKind::Box(ref subpat) |\n-            PatKind::Ref(ref subpat, _) |\n-            PatKind::Binding(.., Some(ref subpat)) => {\n-                let subpat_exit = self.pat(&subpat, pred);\n-                self.add_ast_node(pat.hir_id.local_id, &[subpat_exit])\n-            }\n-\n-            PatKind::TupleStruct(_, ref subpats, _) |\n-            PatKind::Tuple(ref subpats, _) => {\n-                let pats_exit = self.pats_all(subpats.iter(), pred);\n-                self.add_ast_node(pat.hir_id.local_id, &[pats_exit])\n-            }\n-\n-            PatKind::Struct(_, ref subpats, _) => {\n-                let pats_exit = self.pats_all(subpats.iter().map(|f| &f.pat), pred);\n-                self.add_ast_node(pat.hir_id.local_id, &[pats_exit])\n-            }\n-\n-            PatKind::Or(ref pats) => {\n-                let branches: Vec<_> = pats.iter().map(|p| self.pat(p, pred)).collect();\n-                self.add_ast_node(pat.hir_id.local_id, &branches)\n-            }\n-\n-            PatKind::Slice(ref pre, ref vec, ref post) => {\n-                let pre_exit = self.pats_all(pre.iter(), pred);\n-                let vec_exit = self.pats_all(vec.iter(), pre_exit);\n-                let post_exit = self.pats_all(post.iter(), vec_exit);\n-                self.add_ast_node(pat.hir_id.local_id, &[post_exit])\n-            }\n-        }\n-    }\n-\n-    /// Handles case where all of the patterns must match.\n-    fn pats_all<'b, I: Iterator<Item = &'b P<hir::Pat>>>(\n-        &mut self,\n-        pats: I,\n-        pred: CFGIndex,\n-    ) -> CFGIndex {\n-        pats.fold(pred, |pred, pat| self.pat(&pat, pred))\n-    }\n-\n-    fn expr(&mut self, expr: &hir::Expr, pred: CFGIndex) -> CFGIndex {\n-        match expr.kind {\n-            hir::ExprKind::Block(ref blk, _) => {\n-                let blk_exit = self.block(&blk, pred);\n-                self.add_ast_node(expr.hir_id.local_id, &[blk_exit])\n-            }\n-\n-            hir::ExprKind::Loop(ref body, _, _) => {\n-                //\n-                //     [pred]\n-                //       |\n-                //       v 1\n-                //   [loopback] <---+\n-                //       |      4   |\n-                //       v 3        |\n-                //     [body] ------+\n-                //\n-                //     [expr] 2\n-                //\n-                // Note that `break` and `loop` statements\n-                // may cause additional edges.\n-\n-                let loopback = self.add_dummy_node(&[pred]); // 1\n-                let expr_exit = self.add_ast_node(expr.hir_id.local_id, &[]); // 2\n-                self.loop_scopes.push(LoopScope {\n-                    loop_id: expr.hir_id.local_id,\n-                    continue_index: loopback,\n-                    break_index: expr_exit,\n-                });\n-                let body_exit = self.block(&body, loopback); // 3\n-                self.add_contained_edge(body_exit, loopback); // 4\n-                self.loop_scopes.pop();\n-                expr_exit\n-            }\n-\n-            hir::ExprKind::Match(ref discr, ref arms, _) => {\n-                self.match_(expr.hir_id.local_id, &discr, &arms, pred)\n-            }\n-\n-            hir::ExprKind::Binary(op, ref l, ref r) if op.node.is_lazy() => {\n-                //\n-                //     [pred]\n-                //       |\n-                //       v 1\n-                //      [l]\n-                //       |\n-                //      / \\\n-                //     /   \\\n-                //    v 2  *\n-                //   [r]   |\n-                //    |    |\n-                //    v 3  v 4\n-                //   [..exit..]\n-                //\n-                let l_exit = self.expr(&l, pred); // 1\n-                let r_exit = self.expr(&r, l_exit); // 2\n-                self.add_ast_node(expr.hir_id.local_id, &[l_exit, r_exit]) // 3,4\n-            }\n-\n-            hir::ExprKind::Ret(ref v) => {\n-                let v_exit = self.opt_expr(v, pred);\n-                let b = self.add_ast_node(expr.hir_id.local_id, &[v_exit]);\n-                self.add_returning_edge(expr, b);\n-                self.add_unreachable_node()\n-            }\n-\n-            hir::ExprKind::Break(destination, ref opt_expr) => {\n-                let v = self.opt_expr(opt_expr, pred);\n-                let (target_scope, break_dest) =\n-                    self.find_scope_edge(expr, destination, ScopeCfKind::Break);\n-                let b = self.add_ast_node(expr.hir_id.local_id, &[v]);\n-                self.add_exiting_edge(expr, b, target_scope, break_dest);\n-                self.add_unreachable_node()\n-            }\n-\n-            hir::ExprKind::Continue(destination) => {\n-                let (target_scope, cont_dest) =\n-                    self.find_scope_edge(expr, destination, ScopeCfKind::Continue);\n-                let a = self.add_ast_node(expr.hir_id.local_id, &[pred]);\n-                self.add_exiting_edge(expr, a, target_scope, cont_dest);\n-                self.add_unreachable_node()\n-            }\n-\n-            hir::ExprKind::Array(ref elems) => {\n-                self.straightline(expr, pred, elems.iter().map(|e| &*e))\n-            }\n-\n-            hir::ExprKind::Call(ref func, ref args) => {\n-                self.call(expr, pred, &func, args.iter().map(|e| &*e))\n-            }\n-\n-            hir::ExprKind::MethodCall(.., ref args) => {\n-                self.call(expr, pred, &args[0], args[1..].iter().map(|e| &*e))\n-            }\n-\n-            hir::ExprKind::Index(ref l, ref r) |\n-            hir::ExprKind::Binary(_, ref l, ref r) if self.tables.is_method_call(expr) => {\n-                self.call(expr, pred, &l, Some(&**r).into_iter())\n-            }\n-\n-            hir::ExprKind::Unary(_, ref e) if self.tables.is_method_call(expr) => {\n-                self.call(expr, pred, &e, None::<hir::Expr>.iter())\n-            }\n-\n-            hir::ExprKind::Tup(ref exprs) => {\n-                self.straightline(expr, pred, exprs.iter().map(|e| &*e))\n-            }\n-\n-            hir::ExprKind::Struct(_, ref fields, ref base) => {\n-                let field_cfg = self.straightline(expr, pred, fields.iter().map(|f| &*f.expr));\n-                self.opt_expr(base, field_cfg)\n-            }\n-\n-            hir::ExprKind::Assign(ref l, ref r) |\n-            hir::ExprKind::AssignOp(_, ref l, ref r) => {\n-                self.straightline(expr, pred, [r, l].iter().map(|&e| &**e))\n-            }\n-\n-            hir::ExprKind::Index(ref l, ref r) |\n-            hir::ExprKind::Binary(_, ref l, ref r) => { // N.B., && and || handled earlier\n-                self.straightline(expr, pred, [l, r].iter().map(|&e| &**e))\n-            }\n-\n-            hir::ExprKind::Box(ref e) |\n-            hir::ExprKind::AddrOf(_, ref e) |\n-            hir::ExprKind::Cast(ref e, _) |\n-            hir::ExprKind::Type(ref e, _) |\n-            hir::ExprKind::DropTemps(ref e) |\n-            hir::ExprKind::Unary(_, ref e) |\n-            hir::ExprKind::Field(ref e, _) |\n-            hir::ExprKind::Yield(ref e, _) |\n-            hir::ExprKind::Repeat(ref e, _) => {\n-                self.straightline(expr, pred, Some(&**e).into_iter())\n-            }\n-\n-            hir::ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n-                let post_outputs = self.exprs(outputs.iter().map(|e| &*e), pred);\n-                let post_inputs = self.exprs(inputs.iter().map(|e| &*e), post_outputs);\n-                self.add_ast_node(expr.hir_id.local_id, &[post_inputs])\n-            }\n-\n-            hir::ExprKind::Closure(..) |\n-            hir::ExprKind::Lit(..) |\n-            hir::ExprKind::Path(_) |\n-            hir::ExprKind::Err => {\n-                self.straightline(expr, pred, None::<hir::Expr>.iter())\n-            }\n-        }\n-    }\n-\n-    fn call<'b, I: Iterator<Item = &'b hir::Expr>>(\n-        &mut self,\n-        call_expr: &hir::Expr,\n-        pred: CFGIndex,\n-        func_or_rcvr: &hir::Expr,\n-        args: I,\n-    ) -> CFGIndex {\n-        let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n-        let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        let m = self.tcx.hir().get_module_parent(call_expr.hir_id);\n-        if self.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(call_expr)) {\n-            self.add_unreachable_node()\n-        } else {\n-            ret\n-        }\n-    }\n-\n-    /// Constructs graph for `exprs` evaluated in order.\n-    fn exprs<'b, I: Iterator<Item = &'b hir::Expr>>(\n-        &mut self,\n-        exprs: I,\n-        pred: CFGIndex,\n-    ) -> CFGIndex {\n-        exprs.fold(pred, |p, e| self.expr(e, p))\n-    }\n-\n-    /// Constructs graph for `opt_expr` evaluated, if `Some`.\n-    fn opt_expr(\n-        &mut self,\n-        opt_expr: &Option<P<hir::Expr>>,\n-        pred: CFGIndex,\n-    ) -> CFGIndex {\n-        opt_expr.iter().fold(pred, |p, e| self.expr(&e, p))\n-    }\n-\n-    /// Handles case of an expression that evaluates `subexprs` in order.\n-    fn straightline<'b, I: Iterator<Item = &'b hir::Expr>>(\n-        &mut self,\n-        expr: &hir::Expr,\n-        pred: CFGIndex,\n-        subexprs: I,\n-    ) -> CFGIndex {\n-        let subexprs_exit = self.exprs(subexprs, pred);\n-        self.add_ast_node(expr.hir_id.local_id, &[subexprs_exit])\n-    }\n-\n-    fn match_(&mut self, id: hir::ItemLocalId, discr: &hir::Expr,\n-              arms: &[hir::Arm], pred: CFGIndex) -> CFGIndex {\n-        // The CFG for match expressions is quite complex, so no ASCII\n-        // art for it (yet).\n-        //\n-        // The CFG generated below matches roughly what MIR contains.\n-        // Each pattern and guard is visited in parallel, with\n-        // arms containing multiple patterns generating multiple nodes\n-        // for the same guard expression. The guard expressions chain\n-        // into each other from top to bottom, with a specific\n-        // exception to allow some additional valid programs\n-        // (explained below). MIR differs slightly in that the\n-        // pattern matching may continue after a guard but the visible\n-        // behaviour should be the same.\n-        //\n-        // What is going on is explained in further comments.\n-\n-        // Visit the discriminant expression.\n-        let discr_exit = self.expr(discr, pred);\n-\n-        // Add a node for the exit of the match expression as a whole.\n-        let expr_exit = self.add_ast_node(id, &[]);\n-\n-        // Keep track of the previous guard expressions.\n-        let mut prev_guard = None;\n-        let match_scope = region::Scope { id, data: region::ScopeData::Node };\n-\n-        for arm in arms {\n-            // Add an exit node for when we've visited all the\n-            // patterns and the guard (if there is one) in the arm.\n-            let bindings_exit = self.add_dummy_node(&[]);\n-\n-            for pat in arm.top_pats_hack() {\n-                // Visit the pattern, coming from the discriminant exit\n-                let mut pat_exit = self.pat(&pat, discr_exit);\n-\n-                // If there is a guard expression, handle it here.\n-                if let Some(ref guard) = arm.guard {\n-                    // Add a dummy node for the previous guard\n-                    // expression to target.\n-                    let guard_start = self.add_dummy_node(&[pat_exit]);\n-                    // Visit the guard expression.\n-                    let guard_exit = match guard {\n-                        hir::Guard::If(ref e) => (&**e, self.expr(e, guard_start)),\n-                    };\n-                    // #47295: We used to have very special case code\n-                    // here for when a pair of arms are both formed\n-                    // solely from constants, and if so, not add these\n-                    // edges.  But this was not actually sound without\n-                    // other constraints that we stopped enforcing at\n-                    // some point.\n-                    if let Some((prev_guard, prev_index)) = prev_guard.take() {\n-                        self.add_exiting_edge(prev_guard, prev_index, match_scope, guard_start);\n-                    }\n-\n-                    // Push the guard onto the list of previous guards.\n-                    prev_guard = Some(guard_exit);\n-\n-                    // Update the exit node for the pattern.\n-                    pat_exit = guard_exit.1;\n-                }\n-\n-                // Add an edge from the exit of this pattern to the exit of the arm.\n-                self.add_contained_edge(pat_exit, bindings_exit);\n-            }\n-\n-            // Visit the body of this arm.\n-            let body_exit = self.expr(&arm.body, bindings_exit);\n-\n-            let arm_exit = self.add_ast_node(arm.hir_id.local_id, &[body_exit]);\n-\n-            // Link the body to the exit of the expression.\n-            self.add_contained_edge(arm_exit, expr_exit);\n-        }\n-\n-        expr_exit\n-    }\n-\n-    fn add_dummy_node(&mut self, preds: &[CFGIndex]) -> CFGIndex {\n-        self.add_node(CFGNodeData::Dummy, preds)\n-    }\n-\n-    fn add_ast_node(&mut self, id: hir::ItemLocalId, preds: &[CFGIndex]) -> CFGIndex {\n-        self.add_node(CFGNodeData::AST(id), preds)\n-    }\n-\n-    fn add_unreachable_node(&mut self) -> CFGIndex {\n-        self.add_node(CFGNodeData::Unreachable, &[])\n-    }\n-\n-    fn add_node(&mut self, data: CFGNodeData, preds: &[CFGIndex]) -> CFGIndex {\n-        let node = self.graph.add_node(data);\n-        for &pred in preds {\n-            self.add_contained_edge(pred, node);\n-        }\n-        node\n-    }\n-\n-    fn add_contained_edge(\n-        &mut self,\n-        source: CFGIndex,\n-        target: CFGIndex,\n-    ) {\n-        let data = CFGEdgeData {exiting_scopes: vec![] };\n-        self.graph.add_edge(source, target, data);\n-    }\n-\n-    fn add_exiting_edge(\n-        &mut self,\n-        from_expr: &hir::Expr,\n-        from_index: CFGIndex,\n-        target_scope: region::Scope,\n-        to_index: CFGIndex,\n-    ) {\n-        let mut data = CFGEdgeData { exiting_scopes: vec![] };\n-        let mut scope = region::Scope {\n-            id: from_expr.hir_id.local_id,\n-            data: region::ScopeData::Node\n-        };\n-        let region_scope_tree = self.tcx.region_scope_tree(self.owner_def_id);\n-        while scope != target_scope {\n-            data.exiting_scopes.push(scope.item_local_id());\n-            scope = region_scope_tree.encl_scope(scope);\n-        }\n-        self.graph.add_edge(from_index, to_index, data);\n-    }\n-\n-    fn add_returning_edge(\n-        &mut self,\n-        _from_expr: &hir::Expr,\n-        from_index: CFGIndex,\n-    ) {\n-        let data = CFGEdgeData {\n-            exiting_scopes: self.loop_scopes.iter()\n-                                            .rev()\n-                                            .map(|&LoopScope { loop_id: id, .. }| id)\n-                                            .collect()\n-        };\n-        self.graph.add_edge(from_index, self.fn_exit, data);\n-    }\n-\n-    fn find_scope_edge(\n-        &self,\n-        expr: &hir::Expr,\n-        destination: hir::Destination,\n-        scope_cf_kind: ScopeCfKind,\n-    ) -> (region::Scope, CFGIndex) {\n-        match destination.target_id {\n-            Ok(loop_id) => {\n-                for b in &self.breakable_block_scopes {\n-                    if b.block_expr_id == loop_id.local_id {\n-                        let scope = region::Scope {\n-                            id: loop_id.local_id,\n-                            data: region::ScopeData::Node\n-                        };\n-                        return (scope, match scope_cf_kind {\n-                            ScopeCfKind::Break => b.break_index,\n-                            ScopeCfKind::Continue => bug!(\"can't continue to block\"),\n-                        });\n-                    }\n-                }\n-                for l in &self.loop_scopes {\n-                    if l.loop_id == loop_id.local_id {\n-                        let scope = region::Scope {\n-                            id: loop_id.local_id,\n-                            data: region::ScopeData::Node\n-                        };\n-                        return (scope, match scope_cf_kind {\n-                            ScopeCfKind::Break => l.break_index,\n-                            ScopeCfKind::Continue => l.continue_index,\n-                        });\n-                    }\n-                }\n-                span_bug!(expr.span, \"no scope for ID {}\", loop_id);\n-            }\n-            Err(err) => span_bug!(expr.span, \"scope error: {}\",  err),\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Eq, PartialEq)]\n-enum ScopeCfKind {\n-    Break,\n-    Continue,\n-}"}, {"sha": "99c6b49cad5d908f9529d0a5737016a9b8e3a23f", "filename": "src/librustc_ast_borrowck/cfg/graphviz.rs", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,119 +0,0 @@\n-/// This module provides linkage between `rustc::middle::graph` and\n-/// libgraphviz traits.\n-\n-use crate::cfg;\n-use rustc::hir;\n-use rustc::ty::TyCtxt;\n-\n-pub(crate) type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n-pub(crate) type Edge<'a> = &'a cfg::CFGEdge;\n-\n-pub struct LabelledCFG<'a, 'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-    pub cfg: &'a cfg::CFG,\n-    pub name: String,\n-    /// `labelled_edges` controls whether we emit labels on the edges.\n-    pub labelled_edges: bool,\n-}\n-\n-impl<'a, 'tcx> LabelledCFG<'a, 'tcx> {\n-    fn local_id_to_string(&self, local_id: hir::ItemLocalId) -> String {\n-        assert!(self.cfg.owner_def_id.is_local());\n-        let hir_id = hir::HirId {\n-            owner: self.tcx.hir().def_index_to_hir_id(self.cfg.owner_def_id.index).owner,\n-            local_id\n-        };\n-        let s = self.tcx.hir().node_to_string(hir_id);\n-\n-        // Replacing newlines with `\\\\l` causes each line to be left-aligned,\n-        // improving presentation of (long) pretty-printed expressions.\n-        if s.contains(\"\\n\") {\n-            let mut s = s.replace(\"\\n\", \"\\\\l\");\n-            // Apparently left-alignment applies to the line that precedes\n-            // `\\l`, not the line that follows; so, add `\\l` at end of string\n-            // if not already present, ensuring last line gets left-aligned\n-            // as well.\n-            let mut last_two: Vec<_> =\n-                s.chars().rev().take(2).collect();\n-            last_two.reverse();\n-            if last_two != ['\\\\', 'l'] {\n-                s.push_str(\"\\\\l\");\n-            }\n-            s\n-        } else {\n-            s\n-        }\n-    }\n-}\n-\n-impl<'a, 'hir> dot::Labeller<'a> for LabelledCFG<'a, 'hir> {\n-    type Node = Node<'a>;\n-    type Edge = Edge<'a>;\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(&self.name[..]).unwrap() }\n-\n-    fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n-        dot::Id::new(format!(\"N{}\", i.node_id())).unwrap()\n-    }\n-\n-    fn node_label(&'a self, &(i, n): &Node<'a>) -> dot::LabelText<'a> {\n-        if i == self.cfg.entry {\n-            dot::LabelText::LabelStr(\"entry\".into())\n-        } else if i == self.cfg.exit {\n-            dot::LabelText::LabelStr(\"exit\".into())\n-        } else if n.data.id() == hir::DUMMY_ITEM_LOCAL_ID {\n-            dot::LabelText::LabelStr(\"(dummy_node)\".into())\n-        } else {\n-            let s = self.local_id_to_string(n.data.id());\n-            dot::LabelText::EscStr(s.into())\n-        }\n-    }\n-\n-    fn edge_label(&self, e: &Edge<'a>) -> dot::LabelText<'a> {\n-        let mut label = String::new();\n-        if !self.labelled_edges {\n-            return dot::LabelText::EscStr(label.into());\n-        }\n-        let mut put_one = false;\n-        for (i, &id) in e.data.exiting_scopes.iter().enumerate() {\n-            if put_one {\n-                label.push_str(\",\\\\l\");\n-            } else {\n-                put_one = true;\n-            }\n-            let s = self.local_id_to_string(id);\n-            label.push_str(&format!(\"exiting scope_{} {}\",\n-                                   i,\n-                                   &s[..]));\n-        }\n-        dot::LabelText::EscStr(label.into())\n-    }\n-}\n-\n-impl<'a> dot::GraphWalk<'a> for &'a cfg::CFG {\n-    type Node = Node<'a>;\n-    type Edge = Edge<'a>;\n-    fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> {\n-        let v: Vec<_> = self.graph.enumerated_nodes().collect();\n-        v.into()\n-    }\n-    fn edges(&'a self) -> dot::Edges<'a, Edge<'a>> {\n-        self.graph.all_edges().iter().collect()\n-    }\n-    fn source(&'a self, edge: &Edge<'a>) -> Node<'a> {\n-        let i = edge.source();\n-        (i, self.graph.node(i))\n-    }\n-    fn target(&'a self, edge: &Edge<'a>) -> Node<'a> {\n-        let i = edge.target();\n-        (i, self.graph.node(i))\n-    }\n-}\n-\n-impl<'a, 'hir> dot::GraphWalk<'a> for LabelledCFG<'a, 'hir> {\n-    type Node = Node<'a>;\n-    type Edge = Edge<'a>;\n-    fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> { self.cfg.nodes() }\n-    fn edges(&'a self) -> dot::Edges<'a, Edge<'a>> { self.cfg.edges() }\n-    fn source(&'a self, edge: &Edge<'a>) -> Node<'a> { self.cfg.source(edge) }\n-    fn target(&'a self, edge: &Edge<'a>) -> Node<'a> { self.cfg.target(edge) }\n-}"}, {"sha": "981199c91d513effe18b18fb911c4ecf593b9728", "filename": "src/librustc_ast_borrowck/cfg/mod.rs", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,55 +0,0 @@\n-//! Module that constructs a control-flow graph representing an item.\n-//! Uses `Graph` as the underlying representation.\n-\n-use rustc_data_structures::graph::implementation as graph;\n-use rustc::ty::TyCtxt;\n-use rustc::hir;\n-use rustc::hir::def_id::DefId;\n-\n-mod construct;\n-pub mod graphviz;\n-\n-pub struct CFG {\n-    owner_def_id: DefId,\n-    pub(crate) graph: CFGGraph,\n-    pub(crate) entry: CFGIndex,\n-    exit: CFGIndex,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub enum CFGNodeData {\n-    AST(hir::ItemLocalId),\n-    Entry,\n-    Exit,\n-    Dummy,\n-    Unreachable,\n-}\n-\n-impl CFGNodeData {\n-    pub(crate) fn id(&self) -> hir::ItemLocalId {\n-        if let CFGNodeData::AST(id) = *self {\n-            id\n-        } else {\n-            hir::DUMMY_ITEM_LOCAL_ID\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct CFGEdgeData {\n-    pub(crate) exiting_scopes: Vec<hir::ItemLocalId>\n-}\n-\n-pub(crate) type CFGIndex = graph::NodeIndex;\n-\n-pub(crate) type CFGGraph = graph::Graph<CFGNodeData, CFGEdgeData>;\n-\n-pub(crate) type CFGNode = graph::Node<CFGNodeData>;\n-\n-pub(crate) type CFGEdge = graph::Edge<CFGEdgeData>;\n-\n-impl CFG {\n-    pub fn new(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n-        construct::construct(tcx, body)\n-    }\n-}"}, {"sha": "a8562901d99c5f3c0443db6b6dc6980580533998", "filename": "src/librustc_ast_borrowck/dataflow.rs", "status": "removed", "additions": 0, "deletions": 672, "changes": 672, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fdataflow.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,672 +0,0 @@\n-//! A module for propagating forward dataflow information. The analysis\n-//! assumes that the items to be propagated can be represented as bits\n-//! and thus uses bitvectors. Your job is simply to specify the so-called\n-//! GEN and KILL bits for each expression.\n-\n-use crate::cfg::{self, CFGIndex};\n-use std::mem;\n-use std::usize;\n-use log::debug;\n-\n-use rustc_data_structures::graph::implementation::OUTGOING;\n-\n-use rustc::util::nodemap::FxHashMap;\n-use rustc::hir;\n-use rustc::hir::intravisit;\n-use rustc::hir::print as pprust;\n-use rustc::ty::TyCtxt;\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum EntryOrExit {\n-    Entry,\n-    Exit,\n-}\n-\n-#[derive(Clone)]\n-pub struct DataFlowContext<'tcx, O> {\n-    tcx: TyCtxt<'tcx>,\n-\n-    /// a name for the analysis using this dataflow instance\n-    analysis_name: &'static str,\n-\n-    /// the data flow operator\n-    oper: O,\n-\n-    /// number of bits to propagate per id\n-    bits_per_id: usize,\n-\n-    /// number of words we will use to store bits_per_id.\n-    /// equal to bits_per_id/usize::BITS rounded up.\n-    words_per_id: usize,\n-\n-    // mapping from node to cfg node index\n-    // FIXME (#6298): Shouldn't this go with CFG?\n-    local_id_to_index: FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n-\n-    // Bit sets per cfg node.  The following three fields (`gens`, `kills`,\n-    // and `on_entry`) all have the same structure. For each id in\n-    // `id_range`, there is a range of words equal to `words_per_id`.\n-    // So, to access the bits for any given id, you take a slice of\n-    // the full vector (see the method `compute_id_range()`).\n-    /// bits generated as we exit the cfg node. Updated by `add_gen()`.\n-    gens: Vec<usize>,\n-\n-    /// bits killed as we exit the cfg node, or non-locally jump over\n-    /// it. Updated by `add_kill(KillFrom::ScopeEnd)`.\n-    scope_kills: Vec<usize>,\n-\n-    /// bits killed as we exit the cfg node directly; if it is jumped\n-    /// over, e.g., via `break`, the kills are not reflected in the\n-    /// jump's effects. Updated by `add_kill(KillFrom::Execution)`.\n-    action_kills: Vec<usize>,\n-\n-    /// bits that are valid on entry to the cfg node. Updated by\n-    /// `propagate()`.\n-    on_entry: Vec<usize>,\n-}\n-\n-pub trait BitwiseOperator {\n-    /// Joins two predecessor bits together, typically either `|` or `&`\n-    fn join(&self, succ: usize, pred: usize) -> usize;\n-}\n-\n-/// Parameterization for the precise form of data flow that is used.\n-pub trait DataFlowOperator : BitwiseOperator {\n-    /// Specifies the initial value for each bit in the `on_entry` set\n-    fn initial_value(&self) -> bool;\n-}\n-\n-struct PropagationContext<'a, 'tcx, O> {\n-    dfcx: &'a mut DataFlowContext<'tcx, O>,\n-    changed: bool,\n-}\n-\n-fn get_cfg_indices(id: hir::ItemLocalId,\n-                   index: &FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>)\n-                   -> &[CFGIndex] {\n-    index.get(&id).map_or(&[], |v| &v[..])\n-}\n-\n-impl<'tcx, O: DataFlowOperator> DataFlowContext<'tcx, O> {\n-    fn has_bitset_for_local_id(&self, n: hir::ItemLocalId) -> bool {\n-        assert!(n != hir::DUMMY_ITEM_LOCAL_ID);\n-        self.local_id_to_index.contains_key(&n)\n-    }\n-}\n-\n-impl<'tcx, O: DataFlowOperator> pprust::PpAnn for DataFlowContext<'tcx, O> {\n-    fn nested(&self, state: &mut pprust::State<'_>, nested: pprust::Nested) {\n-        pprust::PpAnn::nested(self.tcx.hir(), state, nested)\n-    }\n-    fn pre(&self,\n-           ps: &mut pprust::State<'_>,\n-           node: pprust::AnnNode<'_>) {\n-        let id = match node {\n-            pprust::AnnNode::Name(_) => return,\n-            pprust::AnnNode::Expr(expr) => expr.hir_id.local_id,\n-            pprust::AnnNode::Block(blk) => blk.hir_id.local_id,\n-            pprust::AnnNode::Item(_) |\n-            pprust::AnnNode::SubItem(_) => return,\n-            pprust::AnnNode::Pat(pat) => pat.hir_id.local_id,\n-            pprust::AnnNode::Arm(arm) => arm.hir_id.local_id,\n-        };\n-\n-        if !self.has_bitset_for_local_id(id) {\n-            return;\n-        }\n-\n-        assert!(self.bits_per_id > 0);\n-        let indices = get_cfg_indices(id, &self.local_id_to_index);\n-        for &cfgidx in indices {\n-            let (start, end) = self.compute_id_range(cfgidx);\n-            let on_entry = &self.on_entry[start.. end];\n-            let entry_str = bits_to_string(on_entry);\n-\n-            let gens = &self.gens[start.. end];\n-            let gens_str = if gens.iter().any(|&u| u != 0) {\n-                format!(\" gen: {}\", bits_to_string(gens))\n-            } else {\n-                String::new()\n-            };\n-\n-            let action_kills = &self.action_kills[start .. end];\n-            let action_kills_str = if action_kills.iter().any(|&u| u != 0) {\n-                format!(\" action_kill: {}\", bits_to_string(action_kills))\n-            } else {\n-                String::new()\n-            };\n-\n-            let scope_kills = &self.scope_kills[start .. end];\n-            let scope_kills_str = if scope_kills.iter().any(|&u| u != 0) {\n-                format!(\" scope_kill: {}\", bits_to_string(scope_kills))\n-            } else {\n-                String::new()\n-            };\n-\n-            ps.synth_comment(\n-                format!(\"id {}: {}{}{}{}\", id.as_usize(), entry_str,\n-                        gens_str, action_kills_str, scope_kills_str));\n-            ps.s.space();\n-        }\n-    }\n-}\n-\n-fn build_local_id_to_index(body: Option<&hir::Body>,\n-                           cfg: &cfg::CFG)\n-                           -> FxHashMap<hir::ItemLocalId, Vec<CFGIndex>> {\n-    let mut index = FxHashMap::default();\n-\n-    // FIXME(#15020) Would it be better to fold formals from decl\n-    // into cfg itself?  i.e., introduce a fn-based flow-graph in\n-    // addition to the current block-based flow-graph, rather than\n-    // have to put traversals like this here?\n-    if let Some(body) = body {\n-        add_entries_from_fn_body(&mut index, body, cfg.entry);\n-    }\n-\n-    cfg.graph.each_node(|node_idx, node| {\n-        if let cfg::CFGNodeData::AST(id) = node.data {\n-            index.entry(id).or_default().push(node_idx);\n-        }\n-        true\n-    });\n-\n-    return index;\n-\n-    /// Adds mappings from the ast nodes for the formal bindings to\n-    /// the entry-node in the graph.\n-    fn add_entries_from_fn_body(index: &mut FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n-                                body: &hir::Body,\n-                                entry: CFGIndex) {\n-        use rustc::hir::intravisit::Visitor;\n-\n-        struct Formals<'a> {\n-            entry: CFGIndex,\n-            index: &'a mut FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n-        }\n-        let mut formals = Formals { entry: entry, index: index };\n-        for param in &body.params {\n-            formals.visit_pat(&param.pat);\n-        }\n-        impl<'a, 'v> Visitor<'v> for Formals<'a> {\n-            fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'v> {\n-                intravisit::NestedVisitorMap::None\n-            }\n-\n-            fn visit_pat(&mut self, p: &hir::Pat) {\n-                self.index.entry(p.hir_id.local_id).or_default().push(self.entry);\n-                intravisit::walk_pat(self, p)\n-            }\n-        }\n-    }\n-}\n-\n-/// Flag used by `add_kill` to indicate whether the provided kill\n-/// takes effect only when control flows directly through the node in\n-/// question, or if the kill's effect is associated with any\n-/// control-flow directly through or indirectly over the node.\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum KillFrom {\n-    /// A `ScopeEnd` kill is one that takes effect when any control\n-    /// flow goes over the node. A kill associated with the end of the\n-    /// scope of a variable declaration `let x;` is an example of a\n-    /// `ScopeEnd` kill.\n-    ScopeEnd,\n-\n-    /// An `Execution` kill is one that takes effect only when control\n-    /// flow goes through the node to completion. A kill associated\n-    /// with an assignment statement `x = expr;` is an example of an\n-    /// `Execution` kill.\n-    Execution,\n-}\n-\n-impl<'tcx, O: DataFlowOperator> DataFlowContext<'tcx, O> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        analysis_name: &'static str,\n-        body: Option<&hir::Body>,\n-        cfg: &cfg::CFG,\n-        oper: O,\n-        bits_per_id: usize,\n-    ) -> DataFlowContext<'tcx, O> {\n-        let usize_bits = mem::size_of::<usize>() * 8;\n-        let words_per_id = (bits_per_id + usize_bits - 1) / usize_bits;\n-        let num_nodes = cfg.graph.all_nodes().len();\n-\n-        debug!(\"DataFlowContext::new(analysis_name: {}, \\\n-                                     bits_per_id={}, words_per_id={}) \\\n-                                     num_nodes: {}\",\n-               analysis_name, bits_per_id, words_per_id,\n-               num_nodes);\n-\n-        let entry = if oper.initial_value() { usize::MAX } else {0};\n-\n-        let zeroes = vec![0; num_nodes * words_per_id];\n-        let gens = zeroes.clone();\n-        let kills1 = zeroes.clone();\n-        let kills2 = zeroes;\n-        let on_entry = vec![entry; num_nodes * words_per_id];\n-\n-        let local_id_to_index = build_local_id_to_index(body, cfg);\n-\n-        DataFlowContext {\n-            tcx,\n-            analysis_name,\n-            words_per_id,\n-            local_id_to_index,\n-            bits_per_id,\n-            oper,\n-            gens,\n-            action_kills: kills1,\n-            scope_kills: kills2,\n-            on_entry,\n-        }\n-    }\n-\n-    pub fn add_gen(&mut self, id: hir::ItemLocalId, bit: usize) {\n-        //! Indicates that `id` generates `bit`\n-        debug!(\"{} add_gen(id={:?}, bit={})\",\n-               self.analysis_name, id, bit);\n-        assert!(self.local_id_to_index.contains_key(&id));\n-        assert!(self.bits_per_id > 0);\n-\n-        let indices = get_cfg_indices(id, &self.local_id_to_index);\n-        for &cfgidx in indices {\n-            let (start, end) = self.compute_id_range(cfgidx);\n-            let gens = &mut self.gens[start.. end];\n-            set_bit(gens, bit);\n-        }\n-    }\n-\n-    pub fn add_kill(&mut self, kind: KillFrom, id: hir::ItemLocalId, bit: usize) {\n-        //! Indicates that `id` kills `bit`\n-        debug!(\"{} add_kill(id={:?}, bit={})\",\n-               self.analysis_name, id, bit);\n-        assert!(self.local_id_to_index.contains_key(&id));\n-        assert!(self.bits_per_id > 0);\n-\n-        let indices = get_cfg_indices(id, &self.local_id_to_index);\n-        for &cfgidx in indices {\n-            let (start, end) = self.compute_id_range(cfgidx);\n-            let kills = match kind {\n-                KillFrom::Execution => &mut self.action_kills[start.. end],\n-                KillFrom::ScopeEnd =>  &mut self.scope_kills[start.. end],\n-            };\n-            set_bit(kills, bit);\n-        }\n-    }\n-\n-    fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [usize]) {\n-        //! Applies the gen and kill sets for `cfgidx` to `bits`\n-        debug!(\"{} apply_gen_kill(cfgidx={:?}, bits={}) [before]\",\n-               self.analysis_name, cfgidx, mut_bits_to_string(bits));\n-        assert!(self.bits_per_id > 0);\n-\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = &self.gens[start.. end];\n-        bitwise(bits, gens, &Union);\n-        let kills = &self.action_kills[start.. end];\n-        bitwise(bits, kills, &Subtract);\n-        let kills = &self.scope_kills[start.. end];\n-        bitwise(bits, kills, &Subtract);\n-\n-        debug!(\"{} apply_gen_kill(cfgidx={:?}, bits={}) [after]\",\n-               self.analysis_name, cfgidx, mut_bits_to_string(bits));\n-    }\n-\n-    fn compute_id_range(&self, cfgidx: CFGIndex) -> (usize, usize) {\n-        let n = cfgidx.node_id();\n-        let start = n * self.words_per_id;\n-        let end = start + self.words_per_id;\n-\n-        assert!(start < self.gens.len());\n-        assert!(end <= self.gens.len());\n-        assert!(self.gens.len() == self.action_kills.len());\n-        assert!(self.gens.len() == self.scope_kills.len());\n-        assert!(self.gens.len() == self.on_entry.len());\n-\n-        (start, end)\n-    }\n-\n-\n-    pub fn each_bit_on_entry<F>(&self, id: hir::ItemLocalId, mut f: F) -> bool where\n-        F: FnMut(usize) -> bool,\n-    {\n-        //! Iterates through each bit that is set on entry to `id`.\n-        //! Only useful after `propagate()` has been called.\n-        if !self.has_bitset_for_local_id(id) {\n-            return true;\n-        }\n-        let indices = get_cfg_indices(id, &self.local_id_to_index);\n-        for &cfgidx in indices {\n-            if !self.each_bit_for_node(EntryOrExit::Entry, cfgidx, |i| f(i)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    pub fn each_bit_for_node<F>(&self, e: EntryOrExit, cfgidx: CFGIndex, f: F) -> bool where\n-        F: FnMut(usize) -> bool,\n-    {\n-        //! Iterates through each bit that is set on entry/exit to `cfgidx`.\n-        //! Only useful after `propagate()` has been called.\n-\n-        if self.bits_per_id == 0 {\n-            // Skip the surprisingly common degenerate case.  (Note\n-            // compute_id_range requires self.words_per_id > 0.)\n-            return true;\n-        }\n-\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let on_entry = &self.on_entry[start.. end];\n-        let temp_bits;\n-        let slice = match e {\n-            EntryOrExit::Entry => on_entry,\n-            EntryOrExit::Exit => {\n-                let mut t = on_entry.to_vec();\n-                self.apply_gen_kill(cfgidx, &mut t);\n-                temp_bits = t;\n-                &temp_bits[..]\n-            }\n-        };\n-        debug!(\"{} each_bit_for_node({:?}, cfgidx={:?}) bits={}\",\n-               self.analysis_name, e, cfgidx, bits_to_string(slice));\n-        self.each_bit(slice, f)\n-    }\n-\n-    pub fn each_gen_bit<F>(&self, id: hir::ItemLocalId, mut f: F) -> bool where\n-        F: FnMut(usize) -> bool,\n-    {\n-        //! Iterates through each bit in the gen set for `id`.\n-        if !self.has_bitset_for_local_id(id) {\n-            return true;\n-        }\n-\n-        if self.bits_per_id == 0 {\n-            // Skip the surprisingly common degenerate case.  (Note\n-            // compute_id_range requires self.words_per_id > 0.)\n-            return true;\n-        }\n-\n-        let indices = get_cfg_indices(id, &self.local_id_to_index);\n-        for &cfgidx in indices {\n-            let (start, end) = self.compute_id_range(cfgidx);\n-            let gens = &self.gens[start.. end];\n-            debug!(\"{} each_gen_bit(id={:?}, gens={})\",\n-                   self.analysis_name, id, bits_to_string(gens));\n-            if !self.each_bit(gens, |i| f(i)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    fn each_bit<F>(&self, words: &[usize], mut f: F) -> bool where\n-        F: FnMut(usize) -> bool,\n-    {\n-        //! Helper for iterating over the bits in a bit set.\n-        //! Returns false on the first call to `f` that returns false;\n-        //! if all calls to `f` return true, then returns true.\n-\n-        let usize_bits = mem::size_of::<usize>() * 8;\n-        for (word_index, &word) in words.iter().enumerate() {\n-            if word != 0 {\n-                let base_index = word_index * usize_bits;\n-                for offset in 0..usize_bits {\n-                    let bit = 1 << offset;\n-                    if (word & bit) != 0 {\n-                        // N.B., we round up the total number of bits\n-                        // that we store in any given bit set so that\n-                        // it is an even multiple of usize::BITS.  This\n-                        // means that there may be some stray bits at\n-                        // the end that do not correspond to any\n-                        // actual value.  So before we callback, check\n-                        // whether the bit_index is greater than the\n-                        // actual value the user specified and stop\n-                        // iterating if so.\n-                        let bit_index = base_index + offset as usize;\n-                        if bit_index >= self.bits_per_id {\n-                            return true;\n-                        } else if !f(bit_index) {\n-                            return false;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    pub fn add_kills_from_flow_exits(&mut self, cfg: &cfg::CFG) {\n-        //! Whenever you have a `break` or `continue` statement, flow\n-        //! exits through any number of enclosing scopes on its way to\n-        //! the new destination. This function infers the kill bits of\n-        //! those control operators based on the kill bits associated\n-        //! with those scopes.\n-        //!\n-        //! This is usually called (if it is called at all), after\n-        //! all add_gen and add_kill calls, but before propagate.\n-\n-        debug!(\"{} add_kills_from_flow_exits\", self.analysis_name);\n-        if self.bits_per_id == 0 {\n-            // Skip the surprisingly common degenerate case.  (Note\n-            // compute_id_range requires self.words_per_id > 0.)\n-            return;\n-        }\n-        cfg.graph.each_edge(|_edge_index, edge| {\n-            let flow_exit = edge.source();\n-            let (start, end) = self.compute_id_range(flow_exit);\n-            let mut orig_kills = self.scope_kills[start.. end].to_vec();\n-\n-            let mut changed = false;\n-            for &id in &edge.data.exiting_scopes {\n-                let opt_cfg_idx = self.local_id_to_index.get(&id);\n-                match opt_cfg_idx {\n-                    Some(indices) => {\n-                        for &cfg_idx in indices {\n-                            let (start, end) = self.compute_id_range(cfg_idx);\n-                            let kills = &self.scope_kills[start.. end];\n-                            if bitwise(&mut orig_kills, kills, &Union) {\n-                                debug!(\"scope exits: scope id={:?} \\\n-                                        (node={:?} of {:?}) added killset: {}\",\n-                                       id, cfg_idx, indices,\n-                                       bits_to_string(kills));\n-                                changed = true;\n-                            }\n-                        }\n-                    }\n-                    None => {\n-                        debug!(\"{} add_kills_from_flow_exits flow_exit={:?} \\\n-                                no cfg_idx for exiting_scope={:?}\",\n-                               self.analysis_name, flow_exit, id);\n-                    }\n-                }\n-            }\n-\n-            if changed {\n-                let bits = &mut self.scope_kills[start.. end];\n-                debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [before]\",\n-                       self.analysis_name, flow_exit, mut_bits_to_string(bits));\n-                bits.copy_from_slice(&orig_kills[..]);\n-                debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [after]\",\n-                       self.analysis_name, flow_exit, mut_bits_to_string(bits));\n-            }\n-            true\n-        });\n-    }\n-}\n-\n-// N.B. `Clone + 'static` only needed for pretty printing.\n-impl<'tcx, O: DataFlowOperator + Clone + 'static> DataFlowContext<'tcx, O> {\n-    pub fn propagate(&mut self, cfg: &cfg::CFG, body: &hir::Body) {\n-        //! Performs the data flow analysis.\n-\n-        if self.bits_per_id == 0 {\n-            // Optimize the surprisingly common degenerate case.\n-            return;\n-        }\n-\n-        {\n-            let words_per_id = self.words_per_id;\n-            let mut propcx = PropagationContext {\n-                dfcx: &mut *self,\n-                changed: true\n-            };\n-\n-            let nodes_po = cfg.graph.nodes_in_postorder(OUTGOING, cfg.entry);\n-            let mut temp = vec![0; words_per_id];\n-            let mut num_passes = 0;\n-            while propcx.changed {\n-                num_passes += 1;\n-                propcx.changed = false;\n-                propcx.reset(&mut temp);\n-                propcx.walk_cfg(cfg, &nodes_po, &mut temp);\n-            }\n-            debug!(\"finished in {} iterations\", num_passes);\n-        }\n-\n-        debug!(\"Dataflow result for {}:\", self.analysis_name);\n-        debug!(\"{}\", pprust::to_string(self, |s| {\n-            s.cbox(pprust::INDENT_UNIT);\n-            s.ibox(0);\n-            s.print_expr(&body.value)\n-        }));\n-    }\n-}\n-\n-impl<O: DataFlowOperator> PropagationContext<'_, 'tcx, O> {\n-    fn walk_cfg(&mut self,\n-                cfg: &cfg::CFG,\n-                nodes_po: &[CFGIndex],\n-                in_out: &mut [usize]) {\n-        debug!(\"DataFlowContext::walk_cfg(in_out={}) {}\",\n-               bits_to_string(in_out), self.dfcx.analysis_name);\n-        assert!(self.dfcx.bits_per_id > 0);\n-\n-        // Iterate over nodes in reverse post-order.\n-        for &node_index in nodes_po.iter().rev() {\n-            let node = cfg.graph.node(node_index);\n-            debug!(\"DataFlowContext::walk_cfg idx={:?} id={:?} begin in_out={}\",\n-                   node_index, node.data.id(), bits_to_string(in_out));\n-\n-            let (start, end) = self.dfcx.compute_id_range(node_index);\n-\n-            // Initialize local bitvector with state on-entry.\n-            in_out.copy_from_slice(&self.dfcx.on_entry[start.. end]);\n-\n-            // Compute state on-exit by applying transfer function to\n-            // state on-entry.\n-            self.dfcx.apply_gen_kill(node_index, in_out);\n-\n-            // Propagate state on-exit from node into its successors.\n-            self.propagate_bits_into_graph_successors_of(in_out, cfg, node_index);\n-        }\n-    }\n-\n-    fn reset(&mut self, bits: &mut [usize]) {\n-        let e = if self.dfcx.oper.initial_value() {usize::MAX} else {0};\n-        for b in bits {\n-            *b = e;\n-        }\n-    }\n-\n-    fn propagate_bits_into_graph_successors_of(&mut self,\n-                                               pred_bits: &[usize],\n-                                               cfg: &cfg::CFG,\n-                                               cfgidx: CFGIndex) {\n-        for (_, edge) in cfg.graph.outgoing_edges(cfgidx) {\n-            self.propagate_bits_into_entry_set_for(pred_bits, edge);\n-        }\n-    }\n-\n-    fn propagate_bits_into_entry_set_for(&mut self,\n-                                         pred_bits: &[usize],\n-                                         edge: &cfg::CFGEdge) {\n-        let source = edge.source();\n-        let cfgidx = edge.target();\n-        debug!(\"{} propagate_bits_into_entry_set_for(pred_bits={}, {:?} to {:?})\",\n-               self.dfcx.analysis_name, bits_to_string(pred_bits), source, cfgidx);\n-        assert!(self.dfcx.bits_per_id > 0);\n-\n-        let (start, end) = self.dfcx.compute_id_range(cfgidx);\n-        let changed = {\n-            // (scoping mutable borrow of self.dfcx.on_entry)\n-            let on_entry = &mut self.dfcx.on_entry[start.. end];\n-            bitwise(on_entry, pred_bits, &self.dfcx.oper)\n-        };\n-        if changed {\n-            debug!(\"{} changed entry set for {:?} to {}\",\n-                   self.dfcx.analysis_name, cfgidx,\n-                   bits_to_string(&self.dfcx.on_entry[start.. end]));\n-            self.changed = true;\n-        }\n-    }\n-}\n-\n-fn mut_bits_to_string(words: &mut [usize]) -> String {\n-    bits_to_string(words)\n-}\n-\n-fn bits_to_string(words: &[usize]) -> String {\n-    let mut result = String::new();\n-    let mut sep = '[';\n-\n-    // Note: this is a little endian printout of bytes.\n-\n-    for &word in words {\n-        let mut v = word;\n-        for _ in 0..mem::size_of::<usize>() {\n-            result.push(sep);\n-            result.push_str(&format!(\"{:02x}\", v & 0xFF));\n-            v >>= 8;\n-            sep = '-';\n-        }\n-    }\n-    result.push(']');\n-    return result\n-}\n-\n-#[inline]\n-fn bitwise<Op: BitwiseOperator>(out_vec: &mut [usize],\n-                                in_vec: &[usize],\n-                                op: &Op) -> bool {\n-    assert_eq!(out_vec.len(), in_vec.len());\n-    let mut changed = false;\n-    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {\n-        let old_val = *out_elt;\n-        let new_val = op.join(old_val, *in_elt);\n-        *out_elt = new_val;\n-        changed |= old_val != new_val;\n-    }\n-    changed\n-}\n-\n-fn set_bit(words: &mut [usize], bit: usize) -> bool {\n-    debug!(\"set_bit: words={} bit={}\",\n-           mut_bits_to_string(words), bit_str(bit));\n-    let usize_bits = mem::size_of::<usize>() * 8;\n-    let word = bit / usize_bits;\n-    let bit_in_word = bit % usize_bits;\n-    let bit_mask = 1 << bit_in_word;\n-    debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, bit_mask);\n-    let oldv = words[word];\n-    let newv = oldv | bit_mask;\n-    words[word] = newv;\n-    oldv != newv\n-}\n-\n-fn bit_str(bit: usize) -> String {\n-    let byte = bit >> 3;\n-    let lobits = 1 << (bit & 0b111);\n-    format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n-}\n-\n-struct Union;\n-impl BitwiseOperator for Union {\n-    fn join(&self, a: usize, b: usize) -> usize { a | b }\n-}\n-struct Subtract;\n-impl BitwiseOperator for Subtract {\n-    fn join(&self, a: usize, b: usize) -> usize { a & !b }\n-}"}, {"sha": "c077dc828aba22b98fe898fee4bd92039bef9832", "filename": "src/librustc_ast_borrowck/graphviz.rs", "status": "removed", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,145 +0,0 @@\n-//! This module provides linkage between rustc::middle::graph and\n-//! libgraphviz traits, specialized to attaching borrowck analysis\n-//! data to rendered labels.\n-\n-pub use Variant::*;\n-\n-pub(crate) use crate::cfg::graphviz::{Node, Edge};\n-use crate::cfg::graphviz as cfg_dot;\n-use crate::cfg::CFGIndex;\n-use crate::borrowck::{self, BorrowckCtxt, LoanPath};\n-use crate::dataflow::{DataFlowOperator, DataFlowContext, EntryOrExit};\n-use log::debug;\n-use std::rc::Rc;\n-\n-#[derive(Debug, Copy, Clone)]\n-pub enum Variant {\n-    Loans,\n-    Moves,\n-    Assigns,\n-}\n-\n-impl Variant {\n-    pub fn short_name(&self) -> &'static str {\n-        match *self {\n-            Loans   => \"loans\",\n-            Moves   => \"moves\",\n-            Assigns => \"assigns\",\n-        }\n-    }\n-}\n-\n-pub struct DataflowLabeller<'a, 'tcx> {\n-    pub inner: cfg_dot::LabelledCFG<'a, 'tcx>,\n-    pub variants: Vec<Variant>,\n-    pub borrowck_ctxt: &'a BorrowckCtxt<'a, 'tcx>,\n-    pub analysis_data: &'a borrowck::AnalysisData<'tcx>,\n-}\n-\n-impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n-    fn dataflow_for(&self, e: EntryOrExit, n: &Node<'a>) -> String {\n-        let id = n.1.data.id();\n-        debug!(\"dataflow_for({:?}, id={:?}) {:?}\", e, id, self.variants);\n-        let mut sets = String::new();\n-        let mut seen_one = false;\n-        for &variant in &self.variants {\n-            if seen_one { sets.push_str(\" \"); } else { seen_one = true; }\n-            sets.push_str(variant.short_name());\n-            sets.push_str(\": \");\n-            sets.push_str(&self.dataflow_for_variant(e, n, variant));\n-        }\n-        sets\n-    }\n-\n-    fn dataflow_for_variant(&self, e: EntryOrExit, n: &Node<'_>, v: Variant) -> String {\n-        let cfgidx = n.0;\n-        match v {\n-            Loans   => self.dataflow_loans_for(e, cfgidx),\n-            Moves   => self.dataflow_moves_for(e, cfgidx),\n-            Assigns => self.dataflow_assigns_for(e, cfgidx),\n-        }\n-    }\n-\n-    fn build_set<O: DataFlowOperator, F>(\n-        &self,\n-        e: EntryOrExit,\n-        cfgidx: CFGIndex,\n-        dfcx: &DataFlowContext<'tcx, O>,\n-        mut to_lp: F,\n-    ) -> String\n-    where\n-        F: FnMut(usize) -> Rc<LoanPath<'tcx>>,\n-    {\n-        let mut saw_some = false;\n-        let mut set = \"{\".to_string();\n-        dfcx.each_bit_for_node(e, cfgidx, |index| {\n-            let lp = to_lp(index);\n-            if saw_some {\n-                set.push_str(\", \");\n-            }\n-            let loan_str = self.borrowck_ctxt.loan_path_to_string(&lp);\n-            set.push_str(&loan_str);\n-            saw_some = true;\n-            true\n-        });\n-        set.push_str(\"}\");\n-        set\n-    }\n-\n-    fn dataflow_loans_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n-        let dfcx = &self.analysis_data.loans;\n-        let loan_index_to_path = |loan_index| {\n-            let all_loans = &self.analysis_data.all_loans;\n-            let l: &borrowck::Loan<'_> = &all_loans[loan_index];\n-            l.loan_path()\n-        };\n-        self.build_set(e, cfgidx, dfcx, loan_index_to_path)\n-    }\n-\n-    fn dataflow_moves_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n-        let dfcx = &self.analysis_data.move_data.dfcx_moves;\n-        let move_index_to_path = |move_index| {\n-            let move_data = &self.analysis_data.move_data.move_data;\n-            let moves = move_data.moves.borrow();\n-            let the_move: &borrowck::move_data::Move = &(*moves)[move_index];\n-            move_data.path_loan_path(the_move.path)\n-        };\n-        self.build_set(e, cfgidx, dfcx, move_index_to_path)\n-    }\n-\n-    fn dataflow_assigns_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n-        let dfcx = &self.analysis_data.move_data.dfcx_assign;\n-        let assign_index_to_path = |assign_index| {\n-            let move_data = &self.analysis_data.move_data.move_data;\n-            let assignments = move_data.var_assignments.borrow();\n-            let assignment: &borrowck::move_data::Assignment = &(*assignments)[assign_index];\n-            move_data.path_loan_path(assignment.path)\n-        };\n-        self.build_set(e, cfgidx, dfcx, assign_index_to_path)\n-    }\n-}\n-\n-impl<'a, 'tcx> dot::Labeller<'a> for DataflowLabeller<'a, 'tcx> {\n-    type Node = Node<'a>;\n-    type Edge = Edge<'a>;\n-    fn graph_id(&'a self) -> dot::Id<'a> { self.inner.graph_id() }\n-    fn node_id(&'a self, n: &Node<'a>) -> dot::Id<'a> { self.inner.node_id(n) }\n-    fn node_label(&'a self, n: &Node<'a>) -> dot::LabelText<'a> {\n-        let prefix = self.dataflow_for(EntryOrExit::Entry, n);\n-        let suffix = self.dataflow_for(EntryOrExit::Exit, n);\n-        let inner_label = self.inner.node_label(n);\n-        inner_label\n-            .prefix_line(dot::LabelText::LabelStr(prefix.into()))\n-            .suffix_line(dot::LabelText::LabelStr(suffix.into()))\n-    }\n-    fn edge_label(&'a self, e: &Edge<'a>) -> dot::LabelText<'a> { self.inner.edge_label(e) }\n-}\n-\n-impl<'a, 'tcx> dot::GraphWalk<'a> for DataflowLabeller<'a, 'tcx> {\n-    type Node = Node<'a>;\n-    type Edge = Edge<'a>;\n-    fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> { self.inner.nodes() }\n-    fn edges(&'a self) -> dot::Edges<'a, Edge<'a>> { self.inner.edges() }\n-    fn source(&'a self, edge: &Edge<'a>) -> Node<'a> { self.inner.source(edge) }\n-    fn target(&'a self, edge: &Edge<'a>) -> Node<'a> { self.inner.target(edge) }\n-}"}, {"sha": "aea97fea1a9fd67d5aeec911beb59e6775e17f5b", "filename": "src/librustc_ast_borrowck/lib.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Flibrustc_ast_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Flib.rs?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,23 +0,0 @@\n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-\n-#![allow(non_camel_case_types)]\n-\n-#![feature(in_band_lifetimes)]\n-#![feature(nll)]\n-\n-#![recursion_limit=\"256\"]\n-\n-#[macro_use]\n-extern crate rustc;\n-\n-pub use borrowck::check_crate;\n-pub use borrowck::build_borrowck_dataflow_data_for_fn;\n-\n-mod borrowck;\n-\n-pub mod graphviz;\n-\n-mod dataflow;\n-pub mod cfg;\n-\n-pub use borrowck::provide;"}, {"sha": "aa74966d0ab4cf65cfd6b7e07310cc76c59bbd3d", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -13,10 +13,9 @@ crate-type = [\"dylib\"]\n graphviz = { path = \"../libgraphviz\" }\n lazy_static = \"1.0\"\n log = \"0.4\"\n-env_logger = { version = \"0.6\", default-features = false }\n+env_logger = { version = \"0.7\", default-features = false }\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n-rustc_ast_borrowck = { path = \"../librustc_ast_borrowck\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_metadata = { path = \"../librustc_metadata\" }"}, {"sha": "0de5b700b4faac5c583f7f382754abb9656eba4c", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 12, "deletions": 162, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -2,29 +2,23 @@\n \n use rustc::hir;\n use rustc::hir::map as hir_map;\n-use rustc::hir::map::blocks;\n use rustc::hir::print as pprust_hir;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::session::Session;\n use rustc::session::config::Input;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::common::ErrorReported;\n use rustc_interface::util::ReplaceBodyWithLoop;\n-use rustc_ast_borrowck as borrowck;\n-use rustc_ast_borrowck::graphviz as borrowck_dot;\n-use rustc_ast_borrowck::cfg::{self, graphviz::LabelledCFG};\n use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n use syntax::ast;\n use syntax::mut_visit::MutVisitor;\n use syntax::print::{pprust};\n use syntax_pos::FileName;\n \n-use graphviz as dot;\n-\n use std::cell::Cell;\n use std::fs::File;\n-use std::io::{self, Write};\n+use std::io::Write;\n use std::option;\n use std::path::Path;\n use std::str::FromStr;\n@@ -48,21 +42,11 @@ pub enum PpSourceMode {\n     PpmTyped,\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum PpFlowGraphMode {\n-    Default,\n-    /// Drops the labels from the edges in the flowgraph output. This\n-    /// is mostly for use in the -Z unpretty flowgraph run-make tests,\n-    /// since the labels are largely uninteresting in those cases and\n-    /// have become a pain to maintain.\n-    UnlabelledEdges,\n-}\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpMode {\n     PpmSource(PpSourceMode),\n     PpmHir(PpSourceMode),\n     PpmHirTree(PpSourceMode),\n-    PpmFlowGraph(PpFlowGraphMode),\n     PpmMir,\n     PpmMirCFG,\n }\n@@ -80,15 +64,14 @@ impl PpMode {\n             PpmHir(_) |\n             PpmHirTree(_) |\n             PpmMir |\n-            PpmMirCFG |\n-            PpmFlowGraph(_) => true,\n+            PpmMirCFG => true,\n             PpmSource(PpmTyped) => panic!(\"invalid state\"),\n         }\n     }\n \n     pub fn needs_analysis(&self) -> bool {\n         match *self {\n-            PpmMir | PpmMirCFG | PpmFlowGraph(_) => true,\n+            PpmMir | PpmMirCFG => true,\n             _ => false,\n         }\n     }\n@@ -114,13 +97,11 @@ pub fn parse_pretty(sess: &Session,\n         (\"hir-tree\", true) => PpmHirTree(PpmNormal),\n         (\"mir\", true) => PpmMir,\n         (\"mir-cfg\", true) => PpmMirCFG,\n-        (\"flowgraph\", true) => PpmFlowGraph(PpFlowGraphMode::Default),\n-        (\"flowgraph,unlabelled\", true) => PpmFlowGraph(PpFlowGraphMode::UnlabelledEdges),\n         _ => {\n             if extended {\n                 sess.fatal(&format!(\"argument to `unpretty` must be one of `normal`, \\\n-                                     `expanded`, `flowgraph[,unlabelled]=<nodeid>`, \\\n-                                     `identified`, `expanded,identified`, `everybody_loops`, \\\n+                                     `expanded`, `identified`, `expanded,identified`, \\\n+                                     `expanded,hygiene`, `everybody_loops`, \\\n                                      `hir`, `hir,identified`, `hir,typed`, `hir-tree`, \\\n                                      `mir` or `mir-cfg`; got {}\",\n                                     name));\n@@ -501,24 +482,6 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n     }\n }\n \n-fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {\n-    let print_loans = sess.opts.debugging_opts.flowgraph_print_loans;\n-    let print_moves = sess.opts.debugging_opts.flowgraph_print_moves;\n-    let print_assigns = sess.opts.debugging_opts.flowgraph_print_assigns;\n-    let print_all = sess.opts.debugging_opts.flowgraph_print_all;\n-    let mut variants = Vec::new();\n-    if print_all || print_loans {\n-        variants.push(borrowck_dot::Loans);\n-    }\n-    if print_all || print_moves {\n-        variants.push(borrowck_dot::Moves);\n-    }\n-    if print_all || print_assigns {\n-        variants.push(borrowck_dot::Assigns);\n-    }\n-    variants\n-}\n-\n #[derive(Clone, Debug)]\n pub enum UserIdentifiedItem {\n     ItemViaNode(ast::NodeId),\n@@ -609,81 +572,6 @@ impl UserIdentifiedItem {\n     }\n }\n \n-fn print_flowgraph<'tcx, W: Write>(\n-    variants: Vec<borrowck_dot::Variant>,\n-    tcx: TyCtxt<'tcx>,\n-    code: blocks::Code<'tcx>,\n-    mode: PpFlowGraphMode,\n-    mut out: W,\n-) -> io::Result<()> {\n-    let body_id = match code {\n-        blocks::Code::Expr(expr) => {\n-            // Find the function this expression is from.\n-            let mut hir_id = expr.hir_id;\n-            loop {\n-                let node = tcx.hir().get(hir_id);\n-                if let Some(n) = hir::map::blocks::FnLikeNode::from_node(node) {\n-                    break n.body();\n-                }\n-                let parent = tcx.hir().get_parent_node(hir_id);\n-                assert_ne!(hir_id, parent);\n-                hir_id = parent;\n-            }\n-        }\n-        blocks::Code::FnLike(fn_like) => fn_like.body(),\n-    };\n-    let body = tcx.hir().body(body_id);\n-    let cfg = cfg::CFG::new(tcx, &body);\n-    let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n-    let hir_id = code.id();\n-    // We have to disassemble the hir_id because name must be ASCII\n-    // alphanumeric. This does not appear in the rendered graph, so it does not\n-    // have to be user friendly.\n-    let name = format!(\n-        \"hir_id_{}_{}\",\n-        hir_id.owner.index(),\n-        hir_id.local_id.index(),\n-    );\n-    let lcfg = LabelledCFG {\n-        tcx,\n-        cfg: &cfg,\n-        name,\n-        labelled_edges,\n-    };\n-\n-    match code {\n-        _ if variants.is_empty() => {\n-            let r = dot::render(&lcfg, &mut out);\n-            return expand_err_details(r);\n-        }\n-        blocks::Code::Expr(_) => {\n-            tcx.sess.err(\"--pretty flowgraph with -Z flowgraph-print annotations requires \\\n-                          fn-like node id.\");\n-            return Ok(());\n-        }\n-        blocks::Code::FnLike(fn_like) => {\n-            let (bccx, analysis_data) =\n-                borrowck::build_borrowck_dataflow_data_for_fn(tcx, fn_like.body(), &cfg);\n-\n-            let lcfg = borrowck_dot::DataflowLabeller {\n-                inner: lcfg,\n-                variants,\n-                borrowck_ctxt: &bccx,\n-                analysis_data: &analysis_data,\n-            };\n-            let r = dot::render(&lcfg, &mut out);\n-            return expand_err_details(r);\n-        }\n-    }\n-\n-    fn expand_err_details(r: io::Result<()>) -> io::Result<()> {\n-        r.map_err(|ioerr| {\n-            io::Error::new(io::ErrorKind::Other,\n-                           format!(\"graphviz::render failed: {}\", ioerr))\n-        })\n-    }\n-}\n-\n pub fn visit_crate(sess: &Session, krate: &mut ast::Crate, ppm: PpMode) {\n     if let PpmSource(PpmEveryBodyLoops) = ppm {\n         ReplaceBodyWithLoop::new(sess).visit_crate(krate);\n@@ -872,55 +760,17 @@ fn print_with_analysis(\n \n     tcx.analysis(LOCAL_CRATE)?;\n \n-    let mut print = || match ppm {\n+    match ppm {\n         PpmMir | PpmMirCFG => {\n-            if let Some(nodeid) = nodeid {\n-                let def_id = tcx.hir().local_def_id_from_node_id(nodeid);\n-                match ppm {\n-                    PpmMir => write_mir_pretty(tcx, Some(def_id), &mut out),\n-                    PpmMirCFG => write_mir_graphviz(tcx, Some(def_id), &mut out),\n-                    _ => unreachable!(),\n-                }?;\n-            } else {\n-                match ppm {\n-                    PpmMir => write_mir_pretty(tcx, None, &mut out),\n-                    PpmMirCFG => write_mir_graphviz(tcx, None, &mut out),\n-                    _ => unreachable!(),\n-                }?;\n-            }\n-            Ok(())\n-        }\n-        PpmFlowGraph(mode) => {\n-            let nodeid =\n-                nodeid.expect(\"`pretty flowgraph=..` needs NodeId (int) or unique path \\\n-                                suffix (b::c::d)\");\n-            let hir_id = tcx.hir().node_to_hir_id(nodeid);\n-            let node = tcx.hir().find(hir_id).unwrap_or_else(|| {\n-                tcx.sess.fatal(&format!(\"`--pretty=flowgraph` couldn't find ID: {}\", nodeid))\n-            });\n-\n-            match blocks::Code::from_node(&tcx.hir(), hir_id) {\n-                Some(code) => {\n-                    let variants = gather_flowgraph_variants(tcx.sess);\n-\n-                    let out: &mut dyn Write = &mut out;\n-\n-                    print_flowgraph(variants, tcx, code, mode, out)\n-                }\n-                None => {\n-                    let message = format!(\"`--pretty=flowgraph` needs block, fn, or method; \\\n-                                            got {:?}\",\n-                                            node);\n-\n-                    let hir_id = tcx.hir().node_to_hir_id(nodeid);\n-                    tcx.sess.span_fatal(tcx.hir().span(hir_id), &message)\n-                }\n+            let def_id = nodeid.map(|nid| tcx.hir().local_def_id_from_node_id(nid));\n+            match ppm {\n+                PpmMir => write_mir_pretty(tcx, def_id, &mut out),\n+                PpmMirCFG => write_mir_graphviz(tcx, def_id, &mut out),\n+                _ => unreachable!(),\n             }\n         }\n         _ => unreachable!(),\n-    };\n-\n-    print().unwrap();\n+    }.unwrap();\n \n     write_output(out, ofile);\n "}, {"sha": "780f7a7ffa9edee38e6de8ec5a4084f3b72977ed", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -18,7 +18,6 @@ syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc = { path = \"../librustc\" }\n-rustc_ast_borrowck = { path = \"../librustc_ast_borrowck\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_traits = { path = \"../librustc_traits\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "52d95a04c9a296288c5140329a1eab6c0e78224d", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -17,7 +17,6 @@ use rustc::util::common::{time, ErrorReported};\n use rustc::session::Session;\n use rustc::session::config::{self, CrateType, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n-use rustc_ast_borrowck as borrowck;\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_codegen_utils::link::filename_for_metadata;\n@@ -769,7 +768,6 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     proc_macro_decls::provide(providers);\n     plugin::build::provide(providers);\n     hir::provide(providers);\n-    borrowck::provide(providers);\n     mir::provide(providers);\n     reachable::provide(providers);\n     resolve_lifetime::provide(providers);\n@@ -937,12 +935,6 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n         });\n     });\n \n-    time(sess, \"borrow checking\", || {\n-        if tcx.use_ast_borrowck() {\n-            borrowck::check_crate(tcx);\n-        }\n-    });\n-\n     time(sess, \"MIR borrow checking\", || {\n         tcx.par_body_owners(|def_id| tcx.ensure().mir_borrowck(def_id));\n     });"}, {"sha": "9a68dd0f5e3ced95e1ee9b3fd42d7b042e8fbbf5", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -442,8 +442,8 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                                          .map(|c| c.is_green())\n                                          .unwrap_or(false));\n \n-                        let key = RecoverKey::recover(tcx.global_tcx(), self).unwrap();\n-                        if queries::#name::cache_on_disk(tcx.global_tcx(), key, None) {\n+                        let key = RecoverKey::recover(tcx, self).unwrap();\n+                        if queries::#name::cache_on_disk(tcx, key, None) {\n                             let _ = tcx.#name(key);\n                         }\n                     }"}, {"sha": "cf80a1bc6437e040ee1eb0df5344169c57183704", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 20, "deletions": 42, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -621,18 +621,18 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 target: _,\n                 unwind: _,\n             } => {\n-                let gcx = self.infcx.tcx.global_tcx();\n+                let tcx = self.infcx.tcx;\n \n                 // Compute the type with accurate region information.\n                 let drop_place_ty = drop_place.ty(self.body, self.infcx.tcx);\n \n                 // Erase the regions.\n                 let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;\n \n-                // \"Lift\" into the gcx -- once regions are erased, this type should be in the\n+                // \"Lift\" into the tcx -- once regions are erased, this type should be in the\n                 // global arenas; this \"lift\" operation basically just asserts that is true, but\n                 // that is useful later.\n-                gcx.lift_to_global(&drop_place_ty).unwrap();\n+                tcx.lift(&drop_place_ty).unwrap();\n \n                 debug!(\"visit_terminator_drop \\\n                         loc: {:?} term: {:?} drop_place: {:?} drop_place_ty: {:?} span: {:?}\",\n@@ -1932,48 +1932,26 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n \n-            Reservation(wk @ WriteKind::Move)\n-            | Write(wk @ WriteKind::Move)\n-            | Reservation(wk @ WriteKind::StorageDeadOrDrop)\n-            | Reservation(wk @ WriteKind::MutableBorrow(BorrowKind::Shared))\n-            | Reservation(wk @ WriteKind::MutableBorrow(BorrowKind::Shallow))\n-            | Write(wk @ WriteKind::StorageDeadOrDrop)\n-            | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shared))\n-            | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shallow)) => {\n-                if let (Err(place_err), true) = (\n+            Reservation(WriteKind::Move)\n+            | Write(WriteKind::Move)\n+            | Reservation(WriteKind::StorageDeadOrDrop)\n+            | Reservation(WriteKind::MutableBorrow(BorrowKind::Shared))\n+            | Reservation(WriteKind::MutableBorrow(BorrowKind::Shallow))\n+            | Write(WriteKind::StorageDeadOrDrop)\n+            | Write(WriteKind::MutableBorrow(BorrowKind::Shared))\n+            | Write(WriteKind::MutableBorrow(BorrowKind::Shallow)) => {\n+                if let (Err(_), true) = (\n                     self.is_mutable(place.as_ref(), is_local_mutation_allowed),\n                     self.errors_buffer.is_empty()\n                 ) {\n-                    if self.infcx.tcx.migrate_borrowck() {\n-                        // rust-lang/rust#46908: In pure NLL mode this\n-                        // code path should be unreachable (and thus\n-                        // we signal an ICE in the else branch\n-                        // here). But we can legitimately get here\n-                        // under borrowck=migrate mode, so instead of\n-                        // ICE'ing we instead report a legitimate\n-                        // error (which will then be downgraded to a\n-                        // warning by the migrate machinery).\n-                        error_access = match wk {\n-                            WriteKind::MutableBorrow(_) => AccessKind::MutableBorrow,\n-                            WriteKind::Move => AccessKind::Move,\n-                            WriteKind::StorageDeadOrDrop |\n-                            WriteKind::Mutate => AccessKind::Mutate,\n-                        };\n-                        self.report_mutability_error(\n-                            place,\n-                            span,\n-                            place_err,\n-                            error_access,\n-                            location,\n-                        );\n-                    } else {\n-                        span_bug!(\n-                            span,\n-                            \"Accessing `{:?}` with the kind `{:?}` shouldn't be possible\",\n-                            place,\n-                            kind,\n-                        );\n-                    }\n+                    // rust-lang/rust#46908: In pure NLL mode this code path should\n+                    // be unreachable (and thus we signal an ICE in the else branch here).\n+                    span_bug!(\n+                        span,\n+                        \"Accessing `{:?}` with the kind `{:?}` shouldn't be possible\",\n+                        place,\n+                        kind,\n+                    );\n                 }\n                 return false;\n             }"}, {"sha": "d6b91373ab8250d9bf4d51ec6972e6fabd2bd1d7", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -18,7 +18,6 @@ use rustc_errors::Applicability;\n pub(super) enum AccessKind {\n     MutableBorrow,\n     Mutate,\n-    Move,\n }\n \n impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n@@ -124,7 +123,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     if let Some(desc) = access_place_desc {\n                         item_msg = format!(\"`{}`\", desc);\n                         reason = match error_access {\n-                            AccessKind::Move |\n                             AccessKind::Mutate => format!(\" which is behind {}\", pointer_type),\n                             AccessKind::MutableBorrow => {\n                                 format!(\", as it is behind {}\", pointer_type)\n@@ -194,12 +192,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let acted_on;\n \n         let span = match error_access {\n-            AccessKind::Move => {\n-                err = self.cannot_move_out_of(span, &(item_msg + &reason));\n-                err.span_label(span, \"cannot move\");\n-                err.buffer(&mut self.errors_buffer);\n-                return;\n-            }\n             AccessKind::Mutate => {\n                 err = self.cannot_assign(span, &(item_msg + &reason));\n                 act = \"assign\";"}, {"sha": "b981c76905c14155cca84a422091541260ab4c97", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1894,9 +1894,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // Erase the regions from `ty` to get a global type.  The\n         // `Sized` bound in no way depends on precise regions, so this\n         // shouldn't affect `is_sized`.\n-        let gcx = tcx.global_tcx();\n         let erased_ty = tcx.erase_regions(&ty);\n-        if !erased_ty.is_sized(gcx.at(span), self.param_env) {\n+        if !erased_ty.is_sized(tcx.at(span), self.param_env) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return\n             // slot or local, so to find all unsized rvalues it is enough"}, {"sha": "9f9450188fa94b6794ad46fdf3ecbe8e162bcaef", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -521,9 +521,8 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         defining_ty: DefiningTy<'tcx>,\n     ) -> UniversalRegionIndices<'tcx> {\n         let tcx = self.infcx.tcx;\n-        let gcx = tcx.global_tcx();\n         let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n-        let identity_substs = InternalSubsts::identity_for_item(gcx, closure_base_def_id);\n+        let identity_substs = InternalSubsts::identity_for_item(tcx, closure_base_def_id);\n         let fr_substs = match defining_ty {\n             DefiningTy::Closure(_, ClosureSubsts { ref substs })\n             | DefiningTy::Generator(_, GeneratorSubsts { ref substs }, _) => {\n@@ -542,7 +541,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             DefiningTy::FnDef(_, substs) | DefiningTy::Const(_, substs) => substs,\n         };\n \n-        let global_mapping = iter::once((gcx.lifetimes.re_static, fr_static));\n+        let global_mapping = iter::once((tcx.lifetimes.re_static, fr_static));\n         let subst_mapping = identity_substs\n             .regions()\n             .zip(fr_substs.regions().map(|r| r.to_region_vid()));"}, {"sha": "0fe58c07b1b866bcd2742011e02195be6e1f8ec0", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -148,9 +148,8 @@ pub(crate) fn on_all_drop_children_bits<'tcx, F>(\n         let ty = place.ty(body, tcx).ty;\n         debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, place, ty);\n \n-        let gcx = tcx.global_tcx();\n         let erased_ty = tcx.erase_regions(&ty);\n-        if erased_ty.needs_drop(gcx, ctxt.param_env) {\n+        if erased_ty.needs_drop(tcx, ctxt.param_env) {\n             each_child(child);\n         } else {\n             debug!(\"on_all_drop_children_bits - skipping\")"}, {"sha": "eed51cdab8c3cf2845906b06475f7778863923df", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -543,9 +543,9 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         // Now comes the rote stuff:\n         hir::ExprKind::Repeat(ref v, ref count) => {\n             let def_id = cx.tcx.hir().local_def_id(count.hir_id);\n-            let substs = InternalSubsts::identity_for_item(cx.tcx.global_tcx(), def_id);\n+            let substs = InternalSubsts::identity_for_item(cx.tcx, def_id);\n             let instance = ty::Instance::resolve(\n-                cx.tcx.global_tcx(),\n+                cx.tcx,\n                 cx.param_env,\n                 def_id,\n                 substs,"}, {"sha": "32efbd6f011730d92a381491462f66dc22c606fc", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n             infcx,\n             root_lint_level: src_id,\n             param_env: tcx.param_env(src_def_id),\n-            identity_substs: InternalSubsts::identity_for_item(tcx.global_tcx(), src_def_id),\n+            identity_substs: InternalSubsts::identity_for_item(tcx, src_def_id),\n             region_scope_tree: tcx.region_scope_tree(src_def_id),\n             tables,\n             constness,\n@@ -154,12 +154,11 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n     }\n \n     pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pat<'tcx> {\n-        let tcx = self.tcx.global_tcx();\n-        let p = match tcx.hir().get(p.hir_id) {\n+        let p = match self.tcx.hir().get(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node)\n         };\n-        Pat::from_hir(tcx, self.param_env.and(self.identity_substs), self.tables(), p)\n+        Pat::from_hir(self.tcx, self.param_env.and(self.identity_substs), self.tables(), p)\n     }\n \n     pub fn trait_method(&mut self,\n@@ -187,7 +186,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n     }\n \n     pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n-        ty.needs_drop(self.tcx.global_tcx(), self.param_env)\n+        ty.needs_drop(self.tcx, self.param_env)\n     }\n \n     pub fn tcx(&self) -> TyCtxt<'tcx> {"}, {"sha": "c521b7352214bdf47841a5e7235179361206dd9d", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 55, "deletions": 28, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -4,7 +4,6 @@ use super::_match::WitnessPreference::*;\n \n use super::{PatCtxt, PatternError, PatKind};\n \n-use rustc::middle::borrowck::SignalledError;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n@@ -21,22 +20,19 @@ use std::slice;\n \n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n \n-crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) -> SignalledError {\n-    let body_id = if let Some(id) = tcx.hir().as_local_hir_id(def_id) {\n-        tcx.hir().body_owned_by(id)\n-    } else {\n-        return SignalledError::NoErrorsSeen;\n+crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n+    let body_id = match tcx.hir().as_local_hir_id(def_id) {\n+        None => return,\n+        Some(id) => tcx.hir().body_owned_by(id),\n     };\n \n     let mut visitor = MatchVisitor {\n         tcx,\n         tables: tcx.body_tables(body_id),\n         param_env: tcx.param_env(def_id),\n         identity_substs: InternalSubsts::identity_for_item(tcx, def_id),\n-        signalled_error: SignalledError::NoErrorsSeen,\n     };\n     visitor.visit_body(tcx.hir().body(body_id));\n-    visitor.signalled_error\n }\n \n fn create_e0004(sess: &Session, sp: Span, error_message: String) -> DiagnosticBuilder<'_> {\n@@ -48,7 +44,6 @@ struct MatchVisitor<'a, 'tcx> {\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     identity_substs: SubstsRef<'tcx>,\n-    signalled_error: SignalledError,\n }\n \n impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n@@ -136,13 +131,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             // First, check legality of move bindings.\n             self.check_patterns(arm.guard.is_some(), &arm.pat);\n \n-            // Second, if there is a guard on each arm, make sure it isn't\n-            // assigning or borrowing anything mutably.\n-            if arm.guard.is_some() {\n-                self.signalled_error = SignalledError::SawSomeError;\n-            }\n-\n-            // Third, perform some lints.\n+            // Second, perform some lints.\n             check_for_bindings_named_same_as_variants(self, &arm.pat);\n         }\n \n@@ -151,10 +140,17 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             let mut have_errors = false;\n \n             let inlined_arms : Vec<(Vec<_>, _)> = arms.iter().map(|arm| (\n-                arm.top_pats_hack().iter().map(|pat| {\n-                    let mut patcx = PatCtxt::new(self.tcx,\n-                                                        self.param_env.and(self.identity_substs),\n-                                                        self.tables);\n+                // HACK(or_patterns; Centril | dlrobertson): Remove this and\n+                // correctly handle exhaustiveness checking for nested or-patterns.\n+                match &arm.pat.kind {\n+                    hir::PatKind::Or(pats) => pats,\n+                    _ => std::slice::from_ref(&arm.pat),\n+                }.iter().map(|pat| {\n+                    let mut patcx = PatCtxt::new(\n+                        self.tcx,\n+                        self.param_env.and(self.identity_substs),\n+                        self.tables\n+                    );\n                     patcx.include_lint_checks();\n                     let pattern = expand_pattern(cx, patcx.lower_pattern(&pat));\n                     if !patcx.errors.is_empty() {\n@@ -270,20 +266,51 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 \"refutable pattern in {}: {} not covered\",\n                 origin, joined_patterns\n             );\n-            err.span_label(pat.span, match &pat.kind {\n+            match &pat.kind {\n                 hir::PatKind::Path(hir::QPath::Resolved(None, path))\n-                    if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n-                    format!(\"interpreted as {} {} pattern, not new variable\",\n-                            path.res.article(), path.res.descr())\n+                    if path.segments.len() == 1 && path.segments[0].args.is_none() =>\n+                {\n+                    const_not_var(&mut err, cx.tcx, pat, path);\n                 }\n-                _ => pattern_not_convered_label(&witnesses, &joined_patterns),\n-            });\n+                _ => {\n+                    err.span_label(\n+                        pat.span,\n+                        pattern_not_covered_label(&witnesses, &joined_patterns),\n+                    );\n+                }\n+            }\n+\n             adt_defined_here(cx, &mut err, pattern_ty, &witnesses);\n             err.emit();\n         });\n     }\n }\n \n+/// A path pattern was interpreted as a constant, not a new variable.\n+/// This caused an irrefutable match failure in e.g. `let`.\n+fn const_not_var(err: &mut DiagnosticBuilder<'_>, tcx: TyCtxt<'_>, pat: &Pat, path: &hir::Path) {\n+    let descr = path.res.descr();\n+    err.span_label(pat.span, format!(\n+        \"interpreted as {} {} pattern, not a new variable\",\n+        path.res.article(),\n+        descr,\n+    ));\n+\n+    err.span_suggestion(\n+        pat.span,\n+        \"introduce a variable instead\",\n+        format!(\"{}_var\", path.segments[0].ident).to_lowercase(),\n+        // Cannot use `MachineApplicable` as it's not really *always* correct\n+        // because there may be such an identifier in scope or the user maybe\n+        // really wanted to match against the constant. This is quite unlikely however.\n+        Applicability::MaybeIncorrect,\n+    );\n+\n+    if let Some(span) = tcx.hir().res_span(path.res) {\n+        err.span_label(span, format!(\"{} defined here\", descr));\n+    }\n+}\n+\n fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n     pat.walk(|p| {\n         if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n@@ -449,7 +476,7 @@ fn check_exhaustive<'tcx>(\n         cx.tcx.sess, sp,\n         format!(\"non-exhaustive patterns: {} not covered\", joined_patterns),\n     );\n-    err.span_label(sp, pattern_not_convered_label(&witnesses, &joined_patterns));\n+    err.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n     adt_defined_here(cx, &mut err, scrut_ty, &witnesses);\n     err.help(\n         \"ensure that all possible cases are being handled, \\\n@@ -475,7 +502,7 @@ fn joined_uncovered_patterns(witnesses: &[super::Pat<'_>]) -> String {\n     }\n }\n \n-fn pattern_not_convered_label(witnesses: &[super::Pat<'_>], joined_patterns: &str) -> String {\n+fn pattern_not_covered_label(witnesses: &[super::Pat<'_>], joined_patterns: &str) -> String {\n     format!(\"pattern{} {} not covered\", rustc_errors::pluralise!(witnesses.len()), joined_patterns)\n }\n "}, {"sha": "4fae0976ffb5a1302c9c4a05e31f4a5b08a265c9", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -79,7 +79,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n         }\n         ty::InstanceDef::ClosureOnceShim { call_once } => {\n             let fn_mut = tcx.lang_items().fn_mut_trait().unwrap();\n-            let call_mut = tcx.global_tcx()\n+            let call_mut = tcx\n                 .associated_items(fn_mut)\n                 .find(|it| it.kind == ty::AssocKind::Method)\n                 .unwrap().def_id;"}, {"sha": "d7b6810a8659afe3fced73bfde74880497d8eba2", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -28,17 +28,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n         let param_env = tcx.param_env(src.def_id()).with_reveal_all();\n         let move_data = match MoveData::gather_moves(body, tcx) {\n             Ok(move_data) => move_data,\n-            Err((move_data, _move_errors)) => {\n-                // The only way we should be allowing any move_errors\n-                // in here is if we are in the migration path for the\n-                // NLL-based MIR-borrowck.\n-                //\n-                // If we are in the migration path, we have already\n-                // reported these errors as warnings to the user. So\n-                // we will just ignore them here.\n-                assert!(tcx.migrate_borrowck());\n-                move_data\n-            }\n+            Err(_) => bug!(\"No `move_errors` should be allowed in MIR borrowck\"),\n         };\n         let elaborate_patch = {\n             let body = &*body;"}, {"sha": "0da1f3a1affd1422927ed34289f7cb219cae0f2b", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -291,10 +291,6 @@ fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n     // execute before we can steal.\n     tcx.ensure().mir_borrowck(def_id);\n \n-    if tcx.use_ast_borrowck() {\n-        tcx.ensure().borrowck(def_id);\n-    }\n-\n     let (body, _) = tcx.mir_validated(def_id);\n     let mut body = body.steal();\n     run_optimization_passes(tcx, &mut body, def_id, None);"}, {"sha": "54d580ec05d71263248e2d107f55f295f5cb062b", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -474,7 +474,7 @@ impl context::UnificationOps<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n         &self,\n         value: DelayedLiteral<ChalkArenas<'tcx>>,\n     ) -> DelayedLiteral<ChalkArenas<'tcx>> {\n-        match self.infcx.tcx.lift_to_global(&value) {\n+        match self.infcx.tcx.lift(&value) {\n             Some(literal) => literal,\n             None => bug!(\"cannot lift {:?}\", value),\n         }"}, {"sha": "5ab2ca280d5cdf742a1974b364c4419d9e52d8ac", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1269,7 +1269,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // to avoid ICEs.\n         for item in &regular_traits {\n             let object_safety_violations =\n-                tcx.global_tcx().astconv_object_safety_violations(item.trait_ref().def_id());\n+                tcx.astconv_object_safety_violations(item.trait_ref().def_id());\n             if !object_safety_violations.is_empty() {\n                 tcx.report_object_safety_error(\n                     span,\n@@ -1368,11 +1368,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     span,\n                     format!(\"associated type `{}` must be specified\", assoc_item.ident),\n                 );\n-                if item_def_id.is_local() {\n-                    err.span_label(\n-                        tcx.def_span(*item_def_id),\n-                        format!(\"`{}` defined here\", assoc_item.ident),\n-                    );\n+                if let Some(sp) = tcx.hir().span_if_local(*item_def_id) {\n+                    err.span_label(sp, format!(\"`{}` defined here\", assoc_item.ident));\n                 }\n                 if suggest {\n                     if let Ok(snippet) = tcx.sess.source_map().span_to_snippet("}, {"sha": "7e0a3e781883e43ac7a2c18914dff992c75843d3", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -351,16 +351,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     err.span_label(call_expr.span, \"call expression requires function\");\n \n-                    let def_span = match def {\n-                        Res::Err => None,\n-                        Res::Local(id) => {\n-                            Some(self.tcx.hir().span(id))\n-                        },\n-                        _ => def\n-                            .opt_def_id()\n-                            .and_then(|did| self.tcx.hir().span_if_local(did)),\n-                    };\n-                    if let Some(span) = def_span {\n+                    if let Some(span) = self.tcx.hir().res_span(def) {\n                         let label = match (unit_variant, inner_callee_path) {\n                             (Some(path), _) => format!(\"`{}` defined here\", path),\n                             (_, Some(hir::QPath::Resolved(_, path))) => format!("}, {"sha": "0cdf2fa2a5b9e7192a4ce13490416aa098cf814b", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -620,8 +620,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr\n     ) -> Ty<'tcx> {\n         if self.ret_coercion.is_none() {\n-            struct_span_err!(self.tcx.sess, expr.span, E0572,\n-                                \"return statement outside of function body\").emit();\n+            struct_span_err!(\n+                self.tcx.sess,\n+                expr.span,\n+                E0572,\n+                \"return statement outside of function body\",\n+            ).emit();\n         } else if let Some(ref e) = expr_opt {\n             if self.ret_coercion_span.borrow().is_none() {\n                 *self.ret_coercion_span.borrow_mut() = Some(e.span);\n@@ -932,9 +936,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Ok(self.to_const(count, tcx.type_of(count_def_id)))\n         } else {\n             let param_env = ty::ParamEnv::empty();\n-            let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), count_def_id);\n+            let substs = InternalSubsts::identity_for_item(tcx, count_def_id);\n             let instance = ty::Instance::resolve(\n-                tcx.global_tcx(),\n+                tcx,\n                 param_env,\n                 count_def_id,\n                 substs,"}, {"sha": "20c517d779b42c0c6057682b1c290d0d8ac7b132", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n                 // empty `param_env`.\n                 check_false_global_bounds(&fcx, span, id);\n             }\n-            let wf_tys = f(&fcx, fcx.tcx.global_tcx());\n+            let wf_tys = f(&fcx, fcx.tcx);\n             fcx.select_all_obligations_or_error();\n             fcx.regionck_item(id, span, &wf_tys);\n         });\n@@ -366,8 +366,8 @@ fn check_item_type(\n ) {\n     debug!(\"check_item_type: {:?}\", item_id);\n \n-    for_id(tcx, item_id, ty_span).with_fcx(|fcx, gcx| {\n-        let ty = gcx.type_of(gcx.hir().local_def_id(item_id));\n+    for_id(tcx, item_id, ty_span).with_fcx(|fcx, tcx| {\n+        let ty = tcx.type_of(tcx.hir().local_def_id(item_id));\n         let item_ty = fcx.normalize_associated_types_in(ty_span, &ty);\n \n         let mut forbid_unsized = true;"}, {"sha": "1e3939cbfcdf284d503ded7cd6e9bc0ff27c8f37", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -322,29 +322,29 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: DefId) {\n     }\n }\n \n-pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedInfo {\n+pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedInfo {\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n-    let coerce_unsized_trait = gcx.lang_items().coerce_unsized_trait().unwrap();\n+    let coerce_unsized_trait = tcx.lang_items().coerce_unsized_trait().unwrap();\n \n-    let unsize_trait = gcx.lang_items().require(UnsizeTraitLangItem).unwrap_or_else(|err| {\n-        gcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n+    let unsize_trait = tcx.lang_items().require(UnsizeTraitLangItem).unwrap_or_else(|err| {\n+        tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n     });\n \n     // this provider should only get invoked for local def-ids\n-    let impl_hir_id = gcx.hir().as_local_hir_id(impl_did).unwrap_or_else(|| {\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).unwrap_or_else(|| {\n         bug!(\"coerce_unsized_info: invoked for non-local def-id {:?}\", impl_did)\n     });\n \n-    let source = gcx.type_of(impl_did);\n-    let trait_ref = gcx.impl_trait_ref(impl_did).unwrap();\n+    let source = tcx.type_of(impl_did);\n+    let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n     assert_eq!(trait_ref.def_id, coerce_unsized_trait);\n     let target = trait_ref.substs.type_at(1);\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\",\n            source,\n            target);\n \n-    let span = gcx.hir().span(impl_hir_id);\n-    let param_env = gcx.param_env(impl_did);\n+    let span = tcx.hir().span(impl_hir_id);\n+    let param_env = tcx.param_env(impl_did);\n     assert!(!source.has_escaping_bound_vars());\n \n     let err_info = CoerceUnsizedInfo { custom_kind: None };\n@@ -353,7 +353,7 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n            source,\n            target);\n \n-    gcx.infer_ctxt().enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_hir_id);\n         let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                            mt_b: ty::TypeAndMut<'tcx>,\n@@ -372,24 +372,24 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                 infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n                 let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n                 let mt_b = ty::TypeAndMut { ty: ty_b, mutbl: mutbl_b };\n-                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ref(r_b, ty))\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n             }\n \n             (&ty::Ref(_, ty_a, mutbl_a), &ty::RawPtr(mt_b)) => {\n                 let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n-                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n             }\n \n             (&ty::RawPtr(mt_a), &ty::RawPtr(mt_b)) => {\n-                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n             }\n \n             (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b)) if def_a.is_struct() &&\n                                                                       def_b.is_struct() => {\n                 if def_a != def_b {\n-                    let source_path = gcx.def_path_str(def_a.did);\n-                    let target_path = gcx.def_path_str(def_b.did);\n-                    span_err!(gcx.sess,\n+                    let source_path = tcx.def_path_str(def_a.did);\n+                    let target_path = tcx.def_path_str(def_b.did);\n+                    span_err!(tcx.sess,\n                               span,\n                               E0377,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n@@ -443,9 +443,9 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                 let diff_fields = fields.iter()\n                     .enumerate()\n                     .filter_map(|(i, f)| {\n-                        let (a, b) = (f.ty(gcx, substs_a), f.ty(gcx, substs_b));\n+                        let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n \n-                        if gcx.type_of(f.did).is_phantom_data() {\n+                        if tcx.type_of(f.did).is_phantom_data() {\n                             // Ignore PhantomData fields\n                             return None;\n                         }\n@@ -472,22 +472,22 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                     .collect::<Vec<_>>();\n \n                 if diff_fields.is_empty() {\n-                    span_err!(gcx.sess,\n+                    span_err!(tcx.sess,\n                               span,\n                               E0374,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n                                for a coercion between structures with one field \\\n                                being coerced, none found\");\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n-                    let item = gcx.hir().expect_item(impl_hir_id);\n+                    let item = tcx.hir().expect_item(impl_hir_id);\n                     let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.kind {\n                         t.path.span\n                     } else {\n-                        gcx.hir().span(impl_hir_id)\n+                        tcx.hir().span(impl_hir_id)\n                     };\n \n-                    let mut err = struct_span_err!(gcx.sess,\n+                    let mut err = struct_span_err!(tcx.sess,\n                                                    span,\n                                                    E0375,\n                                                    \"implementing the trait \\\n@@ -514,7 +514,7 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n             }\n \n             _ => {\n-                span_err!(gcx.sess,\n+                span_err!(tcx.sess,\n                           span,\n                           E0376,\n                           \"the trait `CoerceUnsized` may only be implemented \\\n@@ -527,7 +527,7 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n \n         // Register an obligation for `A: Trait<B>`.\n         let cause = traits::ObligationCause::misc(span, impl_hir_id);\n-        let predicate = gcx.predicate_for_trait_def(param_env,\n+        let predicate = tcx.predicate_for_trait_def(param_env,\n                                                     cause,\n                                                     trait_def_id,\n                                                     0,"}, {"sha": "db017394cd5f163fb636879097bddbe48ebf2727", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1717,9 +1717,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     }\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let scope = tcx.hir()\n-        .get_defining_scope(hir_id)\n-        .expect(\"could not get defining scope\");\n+    let scope = tcx.hir().get_defining_scope(hir_id);\n     let mut locator = ConstraintLocator {\n         def_id,\n         tcx,"}, {"sha": "69abbde9e6eba39f77b8adfd6d3e15f4d97484b9", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -714,15 +714,14 @@ where\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(map_get_key_value)]\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.get_key_value(&1), Some((&1, &\"a\")));\n     /// assert_eq!(map.get_key_value(&2), None);\n     /// ```\n-    #[unstable(feature = \"map_get_key_value\", issue = \"49347\")]\n+    #[stable(feature = \"map_get_key_value\", since = \"1.40.0\")]\n     #[inline]\n     pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n     where"}, {"sha": "02f664760c08cee91ba55037a5b12565efe9dbc9", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -566,7 +566,9 @@ mod prim_array { }\n #[doc(alias = \"[\")]\n #[doc(alias = \"]\")]\n #[doc(alias = \"[]\")]\n-/// A dynamically-sized view into a contiguous sequence, `[T]`.\n+/// A dynamically-sized view into a contiguous sequence, `[T]`. Contiguous here\n+/// means that elements are layed out so that every element is the same\n+/// distance from its neighbors.\n ///\n /// *[See also the `std::slice` module](slice/index.html).*\n ///"}, {"sha": "7446471ae3122c2bdeb660f773c573e22d7edb69", "filename": "src/libstd/sys/vxworks/process/process_vxworks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -54,8 +54,8 @@ impl Command {\n \n             let ret = libc::rtpSpawn(\n                 self.get_argv()[0],                   // executing program\n-                self.get_argv().as_ptr() as *const _, // argv\n-                *sys::os::environ() as *const *const c_char,\n+                self.get_argv().as_ptr() as *mut *const c_char, // argv\n+                *sys::os::environ() as *mut *const c_char,\n                 100 as c_int,                         // initial priority\n                 thread::min_stack(),                  // initial stack size.\n                 0,                                    // options"}, {"sha": "bcda5384204d8de3caa0db0dc0c9d5396f5edb4f", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1546,6 +1546,7 @@ fn calc_result(desc: &TestDesc, task_result: Result<(), Box<dyn Any + Send>>) ->\n                 }\n             }\n         }\n+        (&ShouldPanic::Yes, Ok(())) => TrFailedMsg(\"test did not panic as expected\".to_string()),\n         _ if desc.allow_fail => TrAllowedFail,\n         _ => TrFailed,\n     }"}, {"sha": "38ec7bd70930c44fd77f7efb7640e6f4d51a1963", "filename": "src/libtest/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n use crate::test::{\n     filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n-    ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n+    ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailedMsg,\n     TrIgnored, TrOk,\n };\n use std::sync::mpsc::channel;\n@@ -167,7 +167,7 @@ fn test_should_panic_but_succeeds() {\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n     let (_, res, _, _) = rx.recv().unwrap();\n-    assert!(res == TrFailed);\n+    assert!(res == TrFailedMsg(\"test did not panic as expected\".to_string()));\n }\n \n fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {"}, {"sha": "ae044eb843bd95659b07f0ca3eefac9288070a20", "filename": "src/test/ui/attributes/multiple-invalid.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -0,0 +1,10 @@\n+// This test checks that all expected errors occur when there are multiple invalid attributes\n+// on an item.\n+\n+#[inline]\n+//~^ ERROR attribute should be applied to function or closure [E0518]\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+const FOO: u8 = 0;\n+\n+fn main() { }"}, {"sha": "9bd29f15dbcca9d660159e5795ee0e32deb7bcbc", "filename": "src/test/ui/attributes/multiple-invalid.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.stderr?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -0,0 +1,21 @@\n+error[E0518]: attribute should be applied to function or closure\n+  --> $DIR/multiple-invalid.rs:4:1\n+   |\n+LL | #[inline]\n+   | ^^^^^^^^^\n+...\n+LL | const FOO: u8 = 0;\n+   | ------------------ not a function or closure\n+\n+error: attribute should be applied to a function\n+  --> $DIR/multiple-invalid.rs:6:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | const FOO: u8 = 0;\n+   | ------------------ not a function\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0518`."}, {"sha": "4814aa9a5b2cadc4f76de28b051a10a8f022f67e", "filename": "src/test/ui/consts/const-pattern-irrefutable.stderr", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1,20 +1,38 @@\n error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:12:9\n    |\n+LL | const a: u8 = 2;\n+   | ---------------- constant defined here\n+...\n LL |     let a = 4;\n-   |         ^ interpreted as a constant pattern, not new variable\n+   |         ^\n+   |         |\n+   |         interpreted as a constant pattern, not a new variable\n+   |         help: introduce a variable instead: `a_var`\n \n error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:13:9\n    |\n+LL |     pub const b: u8 = 2;\n+   |     -------------------- constant defined here\n+...\n LL |     let c = 4;\n-   |         ^ interpreted as a constant pattern, not new variable\n+   |         ^\n+   |         |\n+   |         interpreted as a constant pattern, not a new variable\n+   |         help: introduce a variable instead: `c_var`\n \n error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:14:9\n    |\n+LL |     pub const d: u8 = 2;\n+   |     -------------------- constant defined here\n+...\n LL |     let d = 4;\n-   |         ^ interpreted as a constant pattern, not new variable\n+   |         ^\n+   |         |\n+   |         interpreted as a constant pattern, not a new variable\n+   |         help: introduce a variable instead: `d_var`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "6b5a557933953381296326acd8fe24b83f27ef35", "filename": "src/test/ui/generator/no-parameters-on-generators.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -2,6 +2,7 @@\n \n fn main() {\n     let gen = |start| { //~ ERROR generators cannot have explicit parameters\n+        //~^ ERROR type inside generator must be known in this context\n         yield;\n     };\n }"}, {"sha": "5e8e043a391ce280810483861084730b95dc77c9", "filename": "src/test/ui/generator/no-parameters-on-generators.stderr", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.stderr?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -4,5 +4,18 @@ error[E0628]: generators cannot have explicit parameters\n LL |     let gen = |start| {\n    |               ^^^^^^^\n \n-error: aborting due to previous error\n+error[E0698]: type inside generator must be known in this context\n+  --> $DIR/no-parameters-on-generators.rs:4:16\n+   |\n+LL |     let gen = |start| {\n+   |                ^^^^^ cannot infer type\n+   |\n+note: the type is part of the generator because of this `yield`\n+  --> $DIR/no-parameters-on-generators.rs:6:9\n+   |\n+LL |         yield;\n+   |         ^^^^^\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0698`."}, {"sha": "db0a1719922c8425f46e8be964ef9557981368d5", "filename": "src/test/ui/issues/issue-45696-scribble-on-boxed-borrow.nll.stderr", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45696-scribble-on-boxed-borrow.nll.stderr?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,33 +0,0 @@\n-error[E0713]: borrow may still be in use when destructor runs\n-  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:34:5\n-   |\n-LL | fn scribbled<'a>(s: Scribble<'a>) -> &'a mut u32 {\n-   |              -- lifetime `'a` defined here\n-LL |     &mut *s.0\n-   |     ^^^^^^^^^ returning this value requires that `*s.0` is borrowed for `'a`\n-LL | }\n-   | - here, drop of `s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n-\n-error[E0713]: borrow may still be in use when destructor runs\n-  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:39:5\n-   |\n-LL | fn boxed_scribbled<'a>(s: Box<Scribble<'a>>) -> &'a mut u32 {\n-   |                    -- lifetime `'a` defined here\n-LL |     &mut *(*s).0\n-   |     ^^^^^^^^^^^^ returning this value requires that `*s.0` is borrowed for `'a`\n-LL | }\n-   | - here, drop of `s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n-\n-error[E0713]: borrow may still be in use when destructor runs\n-  --> $DIR/issue-45696-scribble-on-boxed-borrow.rs:44:5\n-   |\n-LL | fn boxed_boxed_scribbled<'a>(s: Box<Box<Scribble<'a>>>) -> &'a mut u32 {\n-   |                          -- lifetime `'a` defined here\n-LL |     &mut *(**s).0\n-   |     ^^^^^^^^^^^^^ returning this value requires that `*s.0` is borrowed for `'a`\n-LL | }\n-   | - here, drop of `s` needs exclusive access to `*s.0`, because the type `Scribble<'_>` implements the `Drop` trait\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0713`."}, {"sha": "85cbc787bc2db5b50e5156a3d4dd075572afb02a", "filename": "src/test/ui/struct-literal-variant-in-if.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -49,9 +49,6 @@ LL |     if x == E::V { field } {}\n error[E0308]: mismatched types\n   --> $DIR/struct-literal-variant-in-if.rs:10:20\n    |\n-LL | fn test_E(x: E) {\n-   |                 - help: try adding a return type: `-> bool`\n-LL |     let field = true;\n LL |     if x == E::V { field } {}\n    |                    ^^^^^ expected (), found bool\n    |"}, {"sha": "2a11871db8e679dcf69c6387a69c83108d46d092", "filename": "src/test/ui/suggestions/const-pat-non-exaustive-let-new-var.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    let A = 3;\n+    //~^ ERROR refutable pattern in local binding: `std::i32::MIN..=1i32` and\n+    //~| interpreted as a constant pattern, not a new variable\n+    //~| HELP introduce a variable instead\n+    //~| SUGGESTION a_var\n+\n+    const A: i32 = 2;\n+    //~^ constant defined here\n+}"}, {"sha": "fc17199bf91d4ac3363ffc31410836d70a275b15", "filename": "src/test/ui/suggestions/const-pat-non-exaustive-let-new-var.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -0,0 +1,15 @@\n+error[E0005]: refutable pattern in local binding: `std::i32::MIN..=1i32` and `3i32..=std::i32::MAX` not covered\n+  --> $DIR/const-pat-non-exaustive-let-new-var.rs:2:9\n+   |\n+LL |     let A = 3;\n+   |         ^\n+   |         |\n+   |         interpreted as a constant pattern, not a new variable\n+   |         help: introduce a variable instead: `a_var`\n+...\n+LL |     const A: i32 = 2;\n+   |     ----------------- constant defined here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0005`."}, {"sha": "47ca5a5ca478c5c0a3a30604712f36a40c2c3c86", "filename": "src/test/ui/target-feature-wrong.stderr", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Ftest%2Fui%2Ftarget-feature-wrong.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d34ce2c2515a429bea325b93aea332ac8d6a7b9/src%2Ftest%2Fui%2Ftarget-feature-wrong.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-wrong.stderr?ref=4d34ce2c2515a429bea325b93aea332ac8d6a7b9", "patch": "@@ -1,50 +0,0 @@\n-error: malformed `target_feature` attribute input\n-  --> $DIR/target-feature-wrong.rs:16:1\n-   |\n-LL | #[target_feature = \"+sse2\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[target_feature(enable = \"name\")]`\n-\n-error: the feature named `foo` is not valid for this target\n-  --> $DIR/target-feature-wrong.rs:18:18\n-   |\n-LL | #[target_feature(enable = \"foo\")]\n-   |                  ^^^^^^^^^^^^^^ `foo` is not valid for this target\n-\n-error: malformed `target_feature` attribute input\n-  --> $DIR/target-feature-wrong.rs:21:18\n-   |\n-LL | #[target_feature(bar)]\n-   |                  ^^^ help: must be of the form: `enable = \"..\"`\n-\n-error: malformed `target_feature` attribute input\n-  --> $DIR/target-feature-wrong.rs:23:18\n-   |\n-LL | #[target_feature(disable = \"baz\")]\n-   |                  ^^^^^^^^^^^^^^^ help: must be of the form: `enable = \"..\"`\n-\n-error: `#[target_feature(..)]` can only be applied to `unsafe` functions\n-  --> $DIR/target-feature-wrong.rs:27:1\n-   |\n-LL | #[target_feature(enable = \"sse2\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can only be applied to `unsafe` functions\n-...\n-LL | fn bar() {}\n-   | ----------- not an `unsafe` function\n-\n-error: attribute should be applied to a function\n-  --> $DIR/target-feature-wrong.rs:33:1\n-   |\n-LL | #[target_feature(enable = \"sse2\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-LL |\n-LL | mod another {}\n-   | -------------- not a function\n-\n-error: cannot use `#[inline(always)]` with `#[target_feature]`\n-  --> $DIR/target-feature-wrong.rs:38:1\n-   |\n-LL | #[inline(always)]\n-   | ^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 7 previous errors\n-"}, {"sha": "bc7f7caa1076663e66b98ec01872da0c4e11e034", "filename": "src/test/ui/target-feature/gate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "previous_filename": "src/test/ui/target-feature-gate.rs"}, {"sha": "05dbc6e90adc8a054ed5d06133324132402632ec", "filename": "src/test/ui/target-feature/gate.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.stderr?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: the target feature `avx512bw` is currently unstable\n-  --> $DIR/target-feature-gate.rs:30:18\n+  --> $DIR/gate.rs:30:18\n    |\n LL | #[target_feature(enable = \"avx512bw\")]\n    |                  ^^^^^^^^^^^^^^^^^^^", "previous_filename": "src/test/ui/target-feature-gate.stderr"}, {"sha": "46680336632f905459f4bba3585bf55b180462a9", "filename": "src/test/ui/target-feature/invalid-attribute.rs", "status": "renamed", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.rs?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -35,6 +35,31 @@ fn bar() {}\n mod another {}\n //~^ NOTE not a function\n \n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+const FOO: usize = 7;\n+//~^ NOTE not a function\n+\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+struct Foo;\n+//~^ NOTE not a function\n+\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+enum Bar { }\n+//~^ NOTE not a function\n+\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+union Qux { f1: u16, f2: u16 }\n+//~^ NOTE not a function\n+\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+trait Baz { }\n+//~^ NOTE not a function\n+\n #[inline(always)]\n //~^ ERROR: cannot use `#[inline(always)]`\n #[target_feature(enable = \"sse2\")]", "previous_filename": "src/test/ui/target-feature-wrong.rs"}, {"sha": "abfe5dd219770c4ed7db515e1a2c0cfeec42a61a", "filename": "src/test/ui/target-feature/invalid-attribute.stderr", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -0,0 +1,95 @@\n+error: malformed `target_feature` attribute input\n+  --> $DIR/invalid-attribute.rs:16:1\n+   |\n+LL | #[target_feature = \"+sse2\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[target_feature(enable = \"name\")]`\n+\n+error: the feature named `foo` is not valid for this target\n+  --> $DIR/invalid-attribute.rs:18:18\n+   |\n+LL | #[target_feature(enable = \"foo\")]\n+   |                  ^^^^^^^^^^^^^^ `foo` is not valid for this target\n+\n+error: malformed `target_feature` attribute input\n+  --> $DIR/invalid-attribute.rs:21:18\n+   |\n+LL | #[target_feature(bar)]\n+   |                  ^^^ help: must be of the form: `enable = \"..\"`\n+\n+error: malformed `target_feature` attribute input\n+  --> $DIR/invalid-attribute.rs:23:18\n+   |\n+LL | #[target_feature(disable = \"baz\")]\n+   |                  ^^^^^^^^^^^^^^^ help: must be of the form: `enable = \"..\"`\n+\n+error: `#[target_feature(..)]` can only be applied to `unsafe` functions\n+  --> $DIR/invalid-attribute.rs:27:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can only be applied to `unsafe` functions\n+...\n+LL | fn bar() {}\n+   | ----------- not an `unsafe` function\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-attribute.rs:33:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | mod another {}\n+   | -------------- not a function\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-attribute.rs:38:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | const FOO: usize = 7;\n+   | --------------------- not a function\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-attribute.rs:43:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | struct Foo;\n+   | ----------- not a function\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-attribute.rs:48:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | enum Bar { }\n+   | ------------ not a function\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-attribute.rs:53:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | union Qux { f1: u16, f2: u16 }\n+   | ------------------------------ not a function\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-attribute.rs:58:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | trait Baz { }\n+   | ------------- not a function\n+\n+error: cannot use `#[inline(always)]` with `#[target_feature]`\n+  --> $DIR/invalid-attribute.rs:63:1\n+   |\n+LL | #[inline(always)]\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "edd90473ec5ba29b9ae1ee706c982e7046a6e63e", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -1 +1 @@\n-Subproject commit 68ff8b19bc6705724d1e77a8dc17ffb8dfbbe26b\n+Subproject commit edd90473ec5ba29b9ae1ee706c982e7046a6e63e"}, {"sha": "80ef8dd662637637e8eaf12329e7bfde19fe7c47", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c7f6df0d5a64010fc0b3612773f56245ee581247/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=c7f6df0d5a64010fc0b3612773f56245ee581247", "patch": "@@ -6,7 +6,7 @@ edition = \"2018\"\n \n [dependencies]\n diff = \"0.1.10\"\n-env_logger = { version = \"0.6\", default-features = false }\n+env_logger = { version = \"0.7\", default-features = false }\n getopts = \"0.2\"\n log = \"0.4\"\n regex = \"1.0\""}]}