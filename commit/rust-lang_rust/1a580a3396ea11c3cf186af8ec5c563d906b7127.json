{"sha": "1a580a3396ea11c3cf186af8ec5c563d906b7127", "node_id": "C_kwDOAAsO6NoAKDFhNTgwYTMzOTZlYTExYzNjZjE4NmFmOGVjNWM1NjNkOTA2YjcxMjc", "commit": {"author": {"name": "iDawer", "email": "ilnur.iskhakov.oss@outlook.com", "date": "2022-08-31T15:17:54Z"}, "committer": {"name": "iDawer", "email": "ilnur.iskhakov.oss@outlook.com", "date": "2022-08-31T15:17:54Z"}, "message": "Implement unstable RFC 1872 `exhaustive_patterns`", "tree": {"sha": "f009bb08c5508f889f262e8ee4f82095f9da21d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f009bb08c5508f889f262e8ee4f82095f9da21d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a580a3396ea11c3cf186af8ec5c563d906b7127", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a580a3396ea11c3cf186af8ec5c563d906b7127", "html_url": "https://github.com/rust-lang/rust/commit/1a580a3396ea11c3cf186af8ec5c563d906b7127", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a580a3396ea11c3cf186af8ec5c563d906b7127/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3dc5a588f07d6f1d3a0f33051d4af26190abe9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3dc5a588f07d6f1d3a0f33051d4af26190abe9e", "html_url": "https://github.com/rust-lang/rust/commit/e3dc5a588f07d6f1d3a0f33051d4af26190abe9e"}], "stats": {"total": 285, "additions": 265, "deletions": 20}, "files": [{"sha": "c8df4c796efca045f974d21e3b21a8a67e23bf28", "filename": "crates/hir-ty/src/diagnostics/expr.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1a580a3396ea11c3cf186af8ec5c563d906b7127/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a580a3396ea11c3cf186af8ec5c563d906b7127/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=1a580a3396ea11c3cf186af8ec5c563d906b7127", "patch": "@@ -159,12 +159,7 @@ impl ExprValidator {\n         }\n \n         let pattern_arena = Arena::new();\n-        let cx = MatchCheckCtx {\n-            module: self.owner.module(db.upcast()),\n-            body: self.owner,\n-            db,\n-            pattern_arena: &pattern_arena,\n-        };\n+        let cx = MatchCheckCtx::new(self.owner.module(db.upcast()), self.owner, db, &pattern_arena);\n \n         let mut m_arms = Vec::with_capacity(arms.len());\n         let mut has_lowering_errors = false;"}, {"sha": "47d60fc41e700bc2962665e48ab04f6720b3884d", "filename": "crates/hir-ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1a580a3396ea11c3cf186af8ec5c563d906b7127/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a580a3396ea11c3cf186af8ec5c563d906b7127/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=1a580a3396ea11c3cf186af8ec5c563d906b7127", "patch": "@@ -52,7 +52,10 @@ use hir_def::{EnumVariantId, HasModule, LocalFieldId, VariantId};\n use smallvec::{smallvec, SmallVec};\n use stdx::never;\n \n-use crate::{infer::normalize, AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n+use crate::{\n+    infer::normalize, inhabitedness::is_enum_variant_uninhabited_from, AdtId, Interner, Scalar, Ty,\n+    TyExt, TyKind,\n+};\n \n use super::{\n     is_box,\n@@ -557,8 +560,8 @@ impl SplitWildcard {\n             TyKind::Scalar(Scalar::Bool) => smallvec![make_range(0, 1, Scalar::Bool)],\n             // TyKind::Array(..) if ... => unhandled(),\n             TyKind::Array(..) | TyKind::Slice(..) => unhandled(),\n-            &TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ..) => {\n-                let enum_data = cx.db.enum_data(enum_id);\n+            TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), subst) => {\n+                let enum_data = cx.db.enum_data(*enum_id);\n \n                 // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n                 // additional \"unknown\" constructor.\n@@ -591,14 +594,15 @@ impl SplitWildcard {\n                 let mut ctors: SmallVec<[_; 1]> = enum_data\n                     .variants\n                     .iter()\n-                    .filter(|&(_, _v)| {\n+                    .map(|(local_id, _)| EnumVariantId { parent: *enum_id, local_id })\n+                    .filter(|&variant| {\n                         // If `exhaustive_patterns` is enabled, we exclude variants known to be\n                         // uninhabited.\n                         let is_uninhabited = is_exhaustive_pat_feature\n-                            && unimplemented!(\"after MatchCheckCtx.feature_exhaustive_patterns()\");\n+                            && is_enum_variant_uninhabited_from(variant, subst, cx.module, cx.db);\n                         !is_uninhabited\n                     })\n-                    .map(|(local_id, _)| Variant(EnumVariantId { parent: enum_id, local_id }))\n+                    .map(Variant)\n                     .collect();\n \n                 if is_secretly_empty || is_declared_nonexhaustive {"}, {"sha": "4bb4ff8f10a67d41d3acaae92389d0d7fa7b7bca", "filename": "crates/hir-ty/src/diagnostics/match_check/usefulness.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1a580a3396ea11c3cf186af8ec5c563d906b7127/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a580a3396ea11c3cf186af8ec5c563d906b7127/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs?ref=1a580a3396ea11c3cf186af8ec5c563d906b7127", "patch": "@@ -274,10 +274,11 @@\n use std::iter::once;\n \n use hir_def::{AdtId, DefWithBodyId, HasModule, ModuleId};\n+use once_cell::unsync::OnceCell;\n use smallvec::{smallvec, SmallVec};\n use typed_arena::Arena;\n \n-use crate::{db::HirDatabase, Ty, TyExt};\n+use crate::{db::HirDatabase, inhabitedness::is_ty_uninhabited_from, Ty, TyExt};\n \n use super::deconstruct_pat::{Constructor, DeconstructedPat, Fields, SplitWildcard};\n \n@@ -289,13 +290,25 @@ pub(crate) struct MatchCheckCtx<'a, 'p> {\n     pub(crate) db: &'a dyn HirDatabase,\n     /// Lowered patterns from arms plus generated by the check.\n     pub(crate) pattern_arena: &'p Arena<DeconstructedPat<'p>>,\n+    feature_exhaustive_patterns: OnceCell<bool>,\n }\n \n impl<'a, 'p> MatchCheckCtx<'a, 'p> {\n-    pub(super) fn is_uninhabited(&self, _ty: &Ty) -> bool {\n-        // FIXME(iDawer) implement exhaustive_patterns feature. More info in:\n-        // Tracking issue for RFC 1872: exhaustive_patterns feature https://github.com/rust-lang/rust/issues/51085\n-        false\n+    pub(crate) fn new(\n+        module: ModuleId,\n+        body: DefWithBodyId,\n+        db: &'a dyn HirDatabase,\n+        pattern_arena: &'p Arena<DeconstructedPat<'p>>,\n+    ) -> Self {\n+        Self { module, body, db, pattern_arena, feature_exhaustive_patterns: Default::default() }\n+    }\n+\n+    pub(super) fn is_uninhabited(&self, ty: &Ty) -> bool {\n+        if self.feature_exhaustive_patterns() {\n+            is_ty_uninhabited_from(ty, self.module, self.db)\n+        } else {\n+            false\n+        }\n     }\n \n     /// Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n@@ -311,10 +324,22 @@ impl<'a, 'p> MatchCheckCtx<'a, 'p> {\n         }\n     }\n \n-    // Rust feature described as \"Allows exhaustive pattern matching on types that contain uninhabited types.\"\n+    // Rust's unstable feature described as \"Allows exhaustive pattern matching on types that contain uninhabited types.\"\n     pub(super) fn feature_exhaustive_patterns(&self) -> bool {\n-        // FIXME see MatchCheckCtx::is_uninhabited\n-        false\n+        *self.feature_exhaustive_patterns.get_or_init(|| {\n+            let def_map = self.db.crate_def_map(self.module.krate());\n+            let root_mod = def_map.module_id(def_map.root());\n+            let rood_attrs = self.db.attrs(root_mod.into());\n+            let mut nightly_features = rood_attrs\n+                .by_key(\"feature\")\n+                .attrs()\n+                .map(|attr| attr.parse_path_comma_token_tree())\n+                .flatten()\n+                .flatten();\n+            nightly_features.any(\n+            |feat| matches!(feat.segments(), [name] if name.to_smol_str() == \"exhaustive_patterns\"),\n+        )\n+        })\n     }\n }\n "}, {"sha": "f4d822b9c709db531508b4c19cadf6a008b484e2", "filename": "crates/hir-ty/src/inhabitedness.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/1a580a3396ea11c3cf186af8ec5c563d906b7127/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a580a3396ea11c3cf186af8ec5c563d906b7127/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs?ref=1a580a3396ea11c3cf186af8ec5c563d906b7127", "patch": "@@ -0,0 +1,176 @@\n+use std::ops::ControlFlow::{self, Break, Continue};\n+\n+use chalk_ir::{\n+    visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor},\n+    DebruijnIndex,\n+};\n+use hir_def::{\n+    adt::VariantData, attr::Attrs, type_ref::ConstScalar, visibility::Visibility, AdtId,\n+    EnumVariantId, HasModule, Lookup, ModuleId, VariantId,\n+};\n+\n+use crate::{\n+    db::HirDatabase, Binders, ConcreteConst, Const, ConstValue, Interner, Substitution, Ty, TyKind,\n+};\n+\n+pub(crate) fn is_ty_uninhabited_from(ty: &Ty, target_mod: ModuleId, db: &dyn HirDatabase) -> bool {\n+    let mut uninhabited_from = UninhabitedFrom { target_mod, db };\n+    let inhabitedness = ty.visit_with(&mut uninhabited_from, DebruijnIndex::INNERMOST);\n+    inhabitedness == BREAK_VISIBLY_UNINHABITED\n+}\n+\n+pub(crate) fn is_enum_variant_uninhabited_from(\n+    variant: EnumVariantId,\n+    subst: &Substitution,\n+    target_mod: ModuleId,\n+    db: &dyn HirDatabase,\n+) -> bool {\n+    let enum_data = db.enum_data(variant.parent);\n+    let vars_attrs = db.variants_attrs(variant.parent);\n+    let is_local = variant.parent.lookup(db.upcast()).container.krate() == target_mod.krate();\n+\n+    let mut uninhabited_from = UninhabitedFrom { target_mod, db };\n+    let inhabitedness = uninhabited_from.visit_variant(\n+        variant.into(),\n+        &enum_data.variants[variant.local_id].variant_data,\n+        subst,\n+        &vars_attrs[variant.local_id],\n+        is_local,\n+    );\n+    inhabitedness == BREAK_VISIBLY_UNINHABITED\n+}\n+\n+struct UninhabitedFrom<'a> {\n+    target_mod: ModuleId,\n+    db: &'a dyn HirDatabase,\n+}\n+\n+const CONTINUE_OPAQUELY_INHABITED: ControlFlow<VisiblyUninhabited> = Continue(());\n+const BREAK_VISIBLY_UNINHABITED: ControlFlow<VisiblyUninhabited> = Break(VisiblyUninhabited);\n+#[derive(PartialEq, Eq)]\n+struct VisiblyUninhabited;\n+\n+impl TypeVisitor<Interner> for UninhabitedFrom<'_> {\n+    type BreakTy = VisiblyUninhabited;\n+\n+    fn as_dyn(&mut self) -> &mut dyn TypeVisitor<Interner, BreakTy = VisiblyUninhabited> {\n+        self\n+    }\n+\n+    fn visit_ty(\n+        &mut self,\n+        ty: &Ty,\n+        outer_binder: DebruijnIndex,\n+    ) -> ControlFlow<VisiblyUninhabited> {\n+        match ty.kind(Interner) {\n+            TyKind::Adt(adt, subst) => self.visit_adt(adt.0, subst),\n+            TyKind::Never => BREAK_VISIBLY_UNINHABITED,\n+            TyKind::Tuple(..) => ty.super_visit_with(self, outer_binder),\n+            TyKind::Array(item_ty, len) => match try_usize_const(len) {\n+                Some(0) | None => CONTINUE_OPAQUELY_INHABITED,\n+                Some(1..) => item_ty.super_visit_with(self, outer_binder),\n+            },\n+\n+            TyKind::Ref(..) | _ => CONTINUE_OPAQUELY_INHABITED,\n+        }\n+    }\n+\n+    fn interner(&self) -> Interner {\n+        Interner\n+    }\n+}\n+\n+impl UninhabitedFrom<'_> {\n+    fn visit_adt(&mut self, adt: AdtId, subst: &Substitution) -> ControlFlow<VisiblyUninhabited> {\n+        let attrs = self.db.attrs(adt.into());\n+        let adt_non_exhaustive = attrs.by_key(\"non_exhaustive\").exists();\n+        let is_local = adt.module(self.db.upcast()).krate() == self.target_mod.krate();\n+        if adt_non_exhaustive && !is_local {\n+            return CONTINUE_OPAQUELY_INHABITED;\n+        }\n+\n+        // An ADT is uninhabited iff all its variants uninhabited.\n+        match adt {\n+            // rustc: For now, `union`s are never considered uninhabited.\n+            AdtId::UnionId(_) => CONTINUE_OPAQUELY_INHABITED,\n+            AdtId::StructId(s) => {\n+                let struct_data = self.db.struct_data(s);\n+                self.visit_variant(s.into(), &struct_data.variant_data, subst, &attrs, is_local)\n+            }\n+            AdtId::EnumId(e) => {\n+                let vars_attrs = self.db.variants_attrs(e);\n+                let enum_data = self.db.enum_data(e);\n+\n+                for (local_id, enum_var) in enum_data.variants.iter() {\n+                    let variant_inhabitedness = self.visit_variant(\n+                        EnumVariantId { parent: e, local_id }.into(),\n+                        &enum_var.variant_data,\n+                        subst,\n+                        &vars_attrs[local_id],\n+                        is_local,\n+                    );\n+                    match variant_inhabitedness {\n+                        Break(VisiblyUninhabited) => continue,\n+                        Continue(()) => return CONTINUE_OPAQUELY_INHABITED,\n+                    }\n+                }\n+                BREAK_VISIBLY_UNINHABITED\n+            }\n+        }\n+    }\n+\n+    fn visit_variant(\n+        &mut self,\n+        variant: VariantId,\n+        variant_data: &VariantData,\n+        subst: &Substitution,\n+        attrs: &Attrs,\n+        is_local: bool,\n+    ) -> ControlFlow<VisiblyUninhabited> {\n+        let non_exhaustive_field_list = attrs.by_key(\"non_exhaustive\").exists();\n+        if non_exhaustive_field_list && !is_local {\n+            return CONTINUE_OPAQUELY_INHABITED;\n+        }\n+\n+        let is_enum = matches!(variant, VariantId::EnumVariantId(..));\n+        let field_tys = self.db.field_types(variant);\n+        let field_vis = self.db.field_visibilities(variant);\n+\n+        for (fid, _) in variant_data.fields().iter() {\n+            self.visit_field(field_vis[fid], &field_tys[fid], subst, is_enum)?;\n+        }\n+        CONTINUE_OPAQUELY_INHABITED\n+    }\n+\n+    fn visit_field(\n+        &mut self,\n+        vis: Visibility,\n+        ty: &Binders<Ty>,\n+        subst: &Substitution,\n+        is_enum: bool,\n+    ) -> ControlFlow<VisiblyUninhabited> {\n+        let target_mod = self.target_mod;\n+        let mut data_uninhabitedness =\n+            || ty.clone().substitute(Interner, subst).visit_with(self, DebruijnIndex::INNERMOST);\n+        if is_enum {\n+            data_uninhabitedness()\n+        } else {\n+            match vis {\n+                Visibility::Module(mod_id) if mod_id == target_mod => data_uninhabitedness(),\n+                Visibility::Module(_) => CONTINUE_OPAQUELY_INHABITED,\n+                Visibility::Public => data_uninhabitedness(),\n+            }\n+        }\n+    }\n+}\n+\n+fn try_usize_const(c: &Const) -> Option<u128> {\n+    let data = &c.data(Interner);\n+    if data.ty.kind(Interner) != &TyKind::Scalar(chalk_ir::Scalar::Uint(chalk_ir::UintTy::Usize)) {\n+        return None;\n+    }\n+    match data.value {\n+        ConstValue::Concrete(ConcreteConst { interned: ConstScalar::UInt(value) }) => Some(value),\n+        _ => None,\n+    }\n+}"}, {"sha": "a82a331d4b8750e99c5fb8f69b6b04cf8007e96e", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a580a3396ea11c3cf186af8ec5c563d906b7127/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a580a3396ea11c3cf186af8ec5c563d906b7127/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=1a580a3396ea11c3cf186af8ec5c563d906b7127", "patch": "@@ -14,6 +14,7 @@ mod chalk_db;\n mod chalk_ext;\n pub mod consteval;\n mod infer;\n+mod inhabitedness;\n mod interner;\n mod lower;\n mod mapping;"}, {"sha": "c24430ce604692de844a2cc86cea6e0e2bc24abe", "filename": "crates/ide-diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1a580a3396ea11c3cf186af8ec5c563d906b7127/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a580a3396ea11c3cf186af8ec5c563d906b7127/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=1a580a3396ea11c3cf186af8ec5c563d906b7127", "patch": "@@ -947,6 +947,50 @@ fn f() {\n         );\n     }\n \n+    mod rust_unstable {\n+        use super::*;\n+\n+        #[test]\n+        fn rfc_1872_exhaustive_patterns() {\n+            check_diagnostics_no_bails(\n+                r\"\n+//- minicore: option, result\n+#![feature(exhaustive_patterns)]\n+enum Void {}\n+fn test() {\n+    match None::<!> { None => () }\n+    match Result::<u8, !>::Ok(2) { Ok(_) => () }\n+    match Result::<u8, Void>::Ok(2) { Ok(_) => () }\n+    match (2, loop {}) {}\n+    match Result::<!, !>::Ok(loop {}) {}\n+    match (&loop {}) {} // https://github.com/rust-lang/rust/issues/50642#issuecomment-388234919\n+    //    ^^^^^^^^^^ error: missing match arm: type `&!` is non-empty\n+}\",\n+            );\n+        }\n+\n+        #[test]\n+        fn rfc_1872_private_uninhabitedness() {\n+            check_diagnostics_no_bails(\n+                r\"\n+//- minicore: option\n+//- /lib.rs crate:lib\n+#![feature(exhaustive_patterns)]\n+pub struct PrivatelyUninhabited { private_field: Void }\n+enum Void {}\n+fn test_local(x: Option<PrivatelyUninhabited>) {\n+    match x {}\n+} //      ^ error: missing match arm: `None` not covered\n+//- /main.rs crate:main deps:lib\n+#![feature(exhaustive_patterns)]\n+fn test(x: Option<lib::PrivatelyUninhabited>) {\n+    match x {}\n+    //    ^ error: missing match arm: `None` and `Some(_)` not covered\n+}\",\n+            );\n+        }\n+    }\n+\n     mod false_negatives {\n         //! The implementation of match checking here is a work in progress. As we roll this out, we\n         //! prefer false negatives to false positives (ideally there would be no false positives). This"}]}