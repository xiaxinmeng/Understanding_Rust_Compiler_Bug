{"sha": "86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ODIxZjdmYjZhZmJiZmViZDJkN2IwYTY4MWQxNGM0Y2Y2YTU3OGU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-02-18T18:40:35Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-02-27T12:16:30Z"}, "message": "add lint to detect ignored generic bounds; this subsumes the previous 'generic bounds in type aliases are ignored' warning", "tree": {"sha": "3e83776e9eb72d7f23e33d54da7d0db91a89235f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e83776e9eb72d7f23e33d54da7d0db91a89235f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e", "html_url": "https://github.com/rust-lang/rust/commit/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1ed6cce6ca875b3902f34c9979cf75afa403fed", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1ed6cce6ca875b3902f34c9979cf75afa403fed", "html_url": "https://github.com/rust-lang/rust/commit/d1ed6cce6ca875b3902f34c9979cf75afa403fed"}], "stats": {"total": 353, "additions": 277, "deletions": 76}, "files": [{"sha": "2452bda8d43723dc62508221445b7c0fd0d09dc0", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e", "patch": "@@ -1386,3 +1386,97 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnreachablePub {\n         self.perform_lint(cx, \"item\", impl_item.id, &impl_item.vis, impl_item.span, false);\n     }\n }\n+\n+/// Lint for trait and lifetime bounds that are (accidentally) accepted by the parser, but\n+/// ignored later.\n+\n+pub struct IgnoredGenericBounds;\n+\n+declare_lint! {\n+    IGNORED_GENERIC_BOUNDS,\n+    Warn,\n+    \"these generic bounds are ignored\"\n+}\n+\n+impl LintPass for IgnoredGenericBounds {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(IGNORED_GENERIC_BOUNDS)\n+    }\n+}\n+\n+impl IgnoredGenericBounds {\n+    fn ensure_no_param_bounds(\n+        cx: &EarlyContext,\n+        generics: &Vec<ast::GenericParam>,\n+        thing: &'static str,\n+    ) {\n+        for param in generics.iter() {\n+            match param {\n+                &ast::GenericParam::Lifetime(ref lifetime) => {\n+                    if !lifetime.bounds.is_empty() {\n+                        let spans : Vec<_> = lifetime.bounds.iter().map(|b| b.span).collect();\n+                        cx.span_lint(\n+                            IGNORED_GENERIC_BOUNDS,\n+                            spans,\n+                            format!(\"bounds on generic lifetime parameters are ignored in {}\",\n+                                thing).as_ref()\n+                        );\n+                    }\n+                }\n+                &ast::GenericParam::Type(ref ty) => {\n+                    if !ty.bounds.is_empty() {\n+                        let spans : Vec<_> = ty.bounds.iter().map(|b| b.span()).collect();\n+                        cx.span_lint(\n+                            IGNORED_GENERIC_BOUNDS,\n+                            spans,\n+                            format!(\"bounds on generic type parameters are ignored in {}\", thing)\n+                                .as_ref()\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl EarlyLintPass for IgnoredGenericBounds {\n+    fn check_item(&mut self, cx: &EarlyContext, item: &ast::Item) {\n+        match item.node {\n+            ast::ItemKind::Ty(_, ref generics) => {\n+                if !generics.where_clause.predicates.is_empty() {\n+                    let spans : Vec<_> = generics.where_clause.predicates.iter()\n+                        .map(|pred| pred.span()).collect();\n+                    cx.span_lint(IGNORED_GENERIC_BOUNDS, spans,\n+                        \"where clauses are ignored in type aliases\");\n+                }\n+                IgnoredGenericBounds::ensure_no_param_bounds(cx, &generics.params,\n+                    \"type aliases\");\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_where_predicate(&mut self, cx: &EarlyContext, p: &ast::WherePredicate) {\n+        if let &ast::WherePredicate::BoundPredicate(ref bound_predicate) = p {\n+            // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n+            IgnoredGenericBounds::ensure_no_param_bounds(cx,\n+                &bound_predicate.bound_generic_params, \"higher-ranked trait bounds (i.e., `for`)\");\n+        }\n+    }\n+\n+    fn check_poly_trait_ref(&mut self, cx: &EarlyContext, t: &ast::PolyTraitRef,\n+                            _: &ast::TraitBoundModifier) {\n+        IgnoredGenericBounds::ensure_no_param_bounds(cx, &t.bound_generic_params,\n+            \"higher-ranked trait bounds (i.e., `for`)\");\n+    }\n+\n+    fn check_ty(&mut self, cx: &EarlyContext, ty: &ast::Ty) {\n+        match ty.node {\n+            ast::TyKind::BareFn(ref fn_ty) => {\n+                IgnoredGenericBounds::ensure_no_param_bounds(cx, &fn_ty.generic_params,\n+                    \"higher-ranked function types (i.e., `for`)\");\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "de1b79259ddf54fb71d32da0039a53fe2d745a31", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e", "patch": "@@ -109,6 +109,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                        AnonymousParameters,\n                        IllegalFloatLiteralPattern,\n                        UnusedDocComment,\n+                       IgnoredGenericBounds,\n                        );\n \n     add_early_builtin_with_new!(sess,"}, {"sha": "d0424c520887ea1da3c093176469d37a4f239156", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e", "patch": "@@ -355,39 +355,6 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn ensure_no_param_bounds(tcx: TyCtxt,\n-                          span: Span,\n-                          generics: &hir::Generics,\n-                          thing: &'static str) {\n-    let mut warn = false;\n-\n-    for ty_param in generics.ty_params() {\n-        if !ty_param.bounds.is_empty() {\n-            warn = true;\n-        }\n-    }\n-\n-    for lft_param in generics.lifetimes() {\n-        if !lft_param.bounds.is_empty() {\n-            warn = true;\n-        }\n-    }\n-\n-    if !generics.where_clause.predicates.is_empty() {\n-        warn = true;\n-    }\n-\n-    if warn {\n-        // According to accepted RFC #XXX, we should\n-        // eventually accept these, but it will not be\n-        // part of this PR. Still, convert to warning to\n-        // make bootstrapping easier.\n-        span_warn!(tcx.sess, span, E0122,\n-                   \"generic bounds are ignored in {}\",\n-                   thing);\n-    }\n-}\n-\n fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n     let it = tcx.hir.expect_item(item_id);\n     debug!(\"convert: item {} with id {}\", it.name, it.id);\n@@ -448,13 +415,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n                 convert_variant_ctor(tcx, struct_def.id());\n             }\n         },\n-        hir::ItemTy(_, ref generics) => {\n-            ensure_no_param_bounds(tcx, it.span, generics, \"type aliases\");\n-            tcx.generics_of(def_id);\n-            tcx.type_of(def_id);\n-            tcx.predicates_of(def_id);\n-        }\n-        hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) => {\n+        hir::ItemTy(..) | hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);"}, {"sha": "617f7615fb97901000848ef1a1f0006d33a2abb5", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e", "patch": "@@ -1524,26 +1524,6 @@ static BAR: _ = \"test\"; // error, explicitly write out the type instead\n ```\n \"##,\n \n-E0122: r##\"\n-An attempt was made to add a generic constraint to a type alias. This constraint\n-is entirely ignored. For backwards compatibility, Rust still allows this with a\n-warning. Consider the example below:\n-\n-```\n-trait Foo{}\n-\n-type MyType<R: Foo> = (R, ());\n-\n-fn main() {\n-    let t: MyType<u32>;\n-}\n-```\n-\n-We're able to declare a variable of type `MyType<u32>`, despite the fact that\n-`u32` does not implement `Foo`. As a result, one should avoid using generic\n-constraints in concert with type aliases.\n-\"##,\n-\n E0124: r##\"\n You declared two fields of a struct with the same name. Erroneous code\n example:\n@@ -4758,6 +4738,7 @@ register_diagnostics! {\n //  E0086,\n //  E0103,\n //  E0104,\n+//  E0122, // bounds in type aliases are ignored, turned into proper lint\n //  E0123,\n //  E0127,\n //  E0129,"}, {"sha": "245025d3e4f7553873367c7d4b8482071d6fd988", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e", "patch": "@@ -294,6 +294,15 @@ pub enum TyParamBound {\n     RegionTyParamBound(Lifetime)\n }\n \n+impl TyParamBound {\n+    pub fn span(&self) -> Span {\n+        match self {\n+            &TraitTyParamBound(ref t, ..) => t.span,\n+            &RegionTyParamBound(ref l) => l.span,\n+        }\n+    }\n+}\n+\n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n /// modifier is `Maybe`. Negative bounds should also be handled here.\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -404,6 +413,16 @@ pub enum WherePredicate {\n     EqPredicate(WhereEqPredicate),\n }\n \n+impl WherePredicate {\n+    pub fn span(&self) -> Span {\n+        match self {\n+            &WherePredicate::BoundPredicate(ref p) => p.span,\n+            &WherePredicate::RegionPredicate(ref p) => p.span,\n+            &WherePredicate::EqPredicate(ref p) => p.span,\n+        }\n+    }\n+}\n+\n /// A type bound.\n ///\n /// E.g. `for<'c> Foo: Send+Clone+'c`"}, {"sha": "a136ec60252b4a6860c184e05b2cabe5de6dc6dc", "filename": "src/test/ui/param-bounds-ignored.rs", "status": "modified", "additions": 75, "deletions": 4, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/src%2Ftest%2Fui%2Fparam-bounds-ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/src%2Ftest%2Fui%2Fparam-bounds-ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparam-bounds-ignored.rs?ref=86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e", "patch": "@@ -9,12 +9,18 @@\n // except according to those terms.\n \n // must-compile-successfully\n+#![allow(dead_code, non_camel_case_types)]\n \n use std::rc::Rc;\n \n-type SVec<T: Send> = Vec<T>;\n-type VVec<'b, 'a: 'b> = Vec<&'a i32>;\n-type WVec<'b, T: 'b> = Vec<T>;\n+type SVec<T: Send+Send> = Vec<T>;\n+//~^ WARN bounds on generic type parameters are ignored in type aliases\n+type VVec<'b, 'a: 'b+'b> = Vec<&'a i32>;\n+//~^ WARN bounds on generic lifetime parameters are ignored in type aliases\n+type WVec<'b, T: 'b+'b> = Vec<T>;\n+//~^ WARN bounds on generic type parameters are ignored in type aliases\n+type W2Vec<'b, T> where T: 'b, T: 'b = Vec<T>;\n+//~^ WARN where clauses are ignored in type aliases\n \n fn foo<'a>(y: &'a i32) {\n     // If the bounds above would matter, the code below would be rejected.\n@@ -26,8 +32,73 @@ fn foo<'a>(y: &'a i32) {\n \n     let mut x : WVec<'static, & 'a i32> = Vec::new();\n     x.push(y);\n+\n+    let mut x : W2Vec<'static, & 'a i32> = Vec::new();\n+    x.push(y);\n+}\n+\n+fn bar1<'a, 'b>(\n+    x: &'a i32,\n+    y: &'b i32,\n+    f: for<'xa, 'xb: 'xa> fn(&'xa i32, &'xb i32) -> &'xa i32)\n+    //~^ WARN bounds on generic lifetime parameters are ignored in higher-ranked function types\n+{\n+    // If the bound in f's type would matter, the call below would (have to)\n+    // be rejected.\n+    f(x, y);\n }\n \n+fn bar2<'a, 'b, F: for<'xa, 'xb: 'xa> Fn(&'xa i32, &'xb i32) -> &'xa i32>(\n+    //~^ WARN bounds on generic lifetime parameters are ignored in higher-ranked trait bounds\n+    x: &'a i32,\n+    y: &'b i32,\n+    f: F)\n+{\n+    // If the bound in f's type would matter, the call below would (have to)\n+    // be rejected.\n+    f(x, y);\n+}\n+\n+fn bar3<'a, 'b, F>(\n+    x: &'a i32,\n+    y: &'b i32,\n+    f: F)\n+    where F: for<'xa, 'xb: 'xa> Fn(&'xa i32, &'xb i32) -> &'xa i32\n+    //~^ WARN bounds on generic lifetime parameters are ignored in higher-ranked trait bounds\n+{\n+    // If the bound in f's type would matter, the call below would (have to)\n+    // be rejected.\n+    f(x, y);\n+}\n+\n+fn bar4<'a, 'b, F>(\n+    x: &'a i32,\n+    y: &'b i32,\n+    f: F)\n+    where for<'xa, 'xb: 'xa> F: Fn(&'xa i32, &'xb i32) -> &'xa i32\n+    //~^ WARN bounds on generic lifetime parameters are ignored in higher-ranked trait bounds\n+{\n+    // If the bound in f's type would matter, the call below would (have to)\n+    // be rejected.\n+    f(x, y);\n+}\n+\n+struct S1<F: for<'xa, 'xb: 'xa> Fn(&'xa i32, &'xb i32) -> &'xa i32>(F);\n+//~^ WARN bounds on generic lifetime parameters are ignored in higher-ranked trait bounds\n+struct S2<F>(F) where F: for<'xa, 'xb: 'xa> Fn(&'xa i32, &'xb i32) -> &'xa i32;\n+//~^ WARN bounds on generic lifetime parameters are ignored in higher-ranked trait bounds\n+struct S3<F>(F) where for<'xa, 'xb: 'xa> F: Fn(&'xa i32, &'xb i32) -> &'xa i32;\n+//~^ WARN bounds on generic lifetime parameters are ignored in higher-ranked trait bounds\n+\n+struct S_fnty(for<'xa, 'xb: 'xa> fn(&'xa i32, &'xb i32) -> &'xa i32);\n+//~^ WARN bounds on generic lifetime parameters are ignored in higher-ranked function types\n+\n+type T1 = Box<for<'xa, 'xb: 'xa> Fn(&'xa i32, &'xb i32) -> &'xa i32>;\n+//~^ WARN bounds on generic lifetime parameters are ignored in higher-ranked trait bounds\n+\n fn main() {\n-    foo(&42);\n+    let _ : Option<for<'xa, 'xb: 'xa> fn(&'xa i32, &'xb i32) -> &'xa i32> = None;\n+    //~^ WARN bounds on generic lifetime parameters are ignored in higher-ranked function types\n+    let _ : Option<Box<for<'xa, 'xb: 'xa> Fn(&'xa i32, &'xb i32) -> &'xa i32>> = None;\n+    //~^ WARN bounds on generic lifetime parameters are ignored in higher-ranked trait bounds\n }"}, {"sha": "55df5d1c939410e1b6eee8dd510f3f9064c99567", "filename": "src/test/ui/param-bounds-ignored.stderr", "status": "modified", "additions": 86, "deletions": 12, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/src%2Ftest%2Fui%2Fparam-bounds-ignored.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e/src%2Ftest%2Fui%2Fparam-bounds-ignored.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparam-bounds-ignored.stderr?ref=86821f7fb6afbbfebd2d7b0a681d14c4cf6a578e", "patch": "@@ -1,18 +1,92 @@\n-warning[E0122]: generic bounds are ignored in type aliases\n-  --> $DIR/param-bounds-ignored.rs:15:1\n+warning: bounds on generic type parameters are ignored in type aliases\n+  --> $DIR/param-bounds-ignored.rs:16:14\n    |\n-LL | type SVec<T: Send> = Vec<T>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type SVec<T: Send+Send> = Vec<T>;\n+   |              ^^^^ ^^^^\n+   |\n+   = note: #[warn(ignored_generic_bounds)] on by default\n+\n+warning: bounds on generic lifetime parameters are ignored in type aliases\n+  --> $DIR/param-bounds-ignored.rs:18:19\n+   |\n+LL | type VVec<'b, 'a: 'b+'b> = Vec<&'a i32>;\n+   |                   ^^ ^^\n+\n+warning: bounds on generic type parameters are ignored in type aliases\n+  --> $DIR/param-bounds-ignored.rs:20:18\n+   |\n+LL | type WVec<'b, T: 'b+'b> = Vec<T>;\n+   |                  ^^ ^^\n+\n+warning: where clauses are ignored in type aliases\n+  --> $DIR/param-bounds-ignored.rs:22:25\n+   |\n+LL | type W2Vec<'b, T> where T: 'b, T: 'b = Vec<T>;\n+   |                         ^^^^^  ^^^^^\n+\n+warning: bounds on generic lifetime parameters are ignored in higher-ranked function types (i.e., `for`)\n+  --> $DIR/param-bounds-ignored.rs:43:22\n+   |\n+LL |     f: for<'xa, 'xb: 'xa> fn(&'xa i32, &'xb i32) -> &'xa i32)\n+   |                      ^^^\n+\n+warning: bounds on generic lifetime parameters are ignored in higher-ranked trait bounds (i.e., `for`)\n+  --> $DIR/param-bounds-ignored.rs:51:34\n+   |\n+LL | fn bar2<'a, 'b, F: for<'xa, 'xb: 'xa> Fn(&'xa i32, &'xb i32) -> &'xa i32>(\n+   |                                  ^^^\n+\n+warning: bounds on generic lifetime parameters are ignored in higher-ranked trait bounds (i.e., `for`)\n+  --> $DIR/param-bounds-ignored.rs:66:28\n+   |\n+LL |     where F: for<'xa, 'xb: 'xa> Fn(&'xa i32, &'xb i32) -> &'xa i32\n+   |                            ^^^\n+\n+warning: bounds on generic lifetime parameters are ignored in higher-ranked trait bounds (i.e., `for`)\n+  --> $DIR/param-bounds-ignored.rs:78:25\n+   |\n+LL |     where for<'xa, 'xb: 'xa> F: Fn(&'xa i32, &'xb i32) -> &'xa i32\n+   |                         ^^^\n+\n+warning: bounds on generic lifetime parameters are ignored in higher-ranked trait bounds (i.e., `for`)\n+  --> $DIR/param-bounds-ignored.rs:86:28\n+   |\n+LL | struct S1<F: for<'xa, 'xb: 'xa> Fn(&'xa i32, &'xb i32) -> &'xa i32>(F);\n+   |                            ^^^\n+\n+warning: bounds on generic lifetime parameters are ignored in higher-ranked trait bounds (i.e., `for`)\n+  --> $DIR/param-bounds-ignored.rs:88:40\n+   |\n+LL | struct S2<F>(F) where F: for<'xa, 'xb: 'xa> Fn(&'xa i32, &'xb i32) -> &'xa i32;\n+   |                                        ^^^\n+\n+warning: bounds on generic lifetime parameters are ignored in higher-ranked trait bounds (i.e., `for`)\n+  --> $DIR/param-bounds-ignored.rs:90:37\n+   |\n+LL | struct S3<F>(F) where for<'xa, 'xb: 'xa> F: Fn(&'xa i32, &'xb i32) -> &'xa i32;\n+   |                                     ^^^\n+\n+warning: bounds on generic lifetime parameters are ignored in higher-ranked function types (i.e., `for`)\n+  --> $DIR/param-bounds-ignored.rs:93:29\n+   |\n+LL | struct S_fnty(for<'xa, 'xb: 'xa> fn(&'xa i32, &'xb i32) -> &'xa i32);\n+   |                             ^^^\n+\n+warning: bounds on generic lifetime parameters are ignored in higher-ranked trait bounds (i.e., `for`)\n+  --> $DIR/param-bounds-ignored.rs:96:29\n+   |\n+LL | type T1 = Box<for<'xa, 'xb: 'xa> Fn(&'xa i32, &'xb i32) -> &'xa i32>;\n+   |                             ^^^\n \n-warning[E0122]: generic bounds are ignored in type aliases\n-  --> $DIR/param-bounds-ignored.rs:16:1\n+warning: bounds on generic lifetime parameters are ignored in higher-ranked function types (i.e., `for`)\n+  --> $DIR/param-bounds-ignored.rs:100:34\n    |\n-LL | type VVec<'b, 'a: 'b> = Vec<&'a i32>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _ : Option<for<'xa, 'xb: 'xa> fn(&'xa i32, &'xb i32) -> &'xa i32> = None;\n+   |                                  ^^^\n \n-warning[E0122]: generic bounds are ignored in type aliases\n-  --> $DIR/param-bounds-ignored.rs:17:1\n+warning: bounds on generic lifetime parameters are ignored in higher-ranked trait bounds (i.e., `for`)\n+  --> $DIR/param-bounds-ignored.rs:102:38\n    |\n-LL | type WVec<'b, T: 'b> = Vec<T>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _ : Option<Box<for<'xa, 'xb: 'xa> Fn(&'xa i32, &'xb i32) -> &'xa i32>> = None;\n+   |                                      ^^^\n "}]}