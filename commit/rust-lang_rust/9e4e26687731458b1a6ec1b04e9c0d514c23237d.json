{"sha": "9e4e26687731458b1a6ec1b04e9c0d514c23237d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllNGUyNjY4NzczMTQ1OGIxYTZlYzFiMDRlOWMwZDUxNGMyMzIzN2Q=", "commit": {"author": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-07-28T02:19:36Z"}, "committer": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-08-05T03:20:45Z"}, "message": "turn intra-doc-link collection into an early pass", "tree": {"sha": "d5f823c2131280619497602cca6436c83c0123f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5f823c2131280619497602cca6436c83c0123f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e4e26687731458b1a6ec1b04e9c0d514c23237d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e4e26687731458b1a6ec1b04e9c0d514c23237d", "html_url": "https://github.com/rust-lang/rust/commit/9e4e26687731458b1a6ec1b04e9c0d514c23237d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e4e26687731458b1a6ec1b04e9c0d514c23237d/comments", "author": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3d6f76887921d2e2ac5444790872bd030c1b669", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3d6f76887921d2e2ac5444790872bd030c1b669", "html_url": "https://github.com/rust-lang/rust/commit/d3d6f76887921d2e2ac5444790872bd030c1b669"}], "stats": {"total": 1177, "additions": 620, "deletions": 557}, "files": [{"sha": "ad774f9860264b1f035c250779ae9afb3f1fdbbe", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 13, "deletions": 551, "changes": 564, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e26687731458b1a6ec1b04e9c0d514c23237d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e26687731458b1a6ec1b04e9c0d514c23237d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9e4e26687731458b1a6ec1b04e9c0d514c23237d", "patch": "@@ -19,14 +19,12 @@ pub use self::FunctionRetTy::*;\n pub use self::Visibility::{Public, Inherited};\n \n use rustc_target::spec::abi::Abi;\n-use syntax;\n-use syntax::ast::{self, AttrStyle, Name, NodeId, Ident};\n+use syntax::ast::{self, AttrStyle, Ident};\n use syntax::attr;\n use syntax::codemap::{dummy_spanned, Spanned};\n-use syntax::feature_gate::UnstableFeatures;\n use syntax::ptr::P;\n use syntax::symbol::keywords::{self, Keyword};\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::InternedString;\n use syntax_pos::{self, DUMMY_SP, Pos, FileName};\n \n use rustc::mir::interpret::ConstValue;\n@@ -38,14 +36,12 @@ use rustc::mir::interpret::GlobalId;\n use rustc::hir::{self, GenericArg, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::hir::map::Node;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::middle::stability;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_typeck::hir_ty_to_ty;\n use rustc::infer::region_constraints::{RegionConstraintData, Constraint};\n-use rustc::lint as lint;\n \n use std::collections::hash_map::Entry;\n use std::fmt;\n@@ -59,14 +55,12 @@ use std::str::FromStr;\n use std::cell::RefCell;\n use std::sync::Arc;\n use std::u32;\n-use std::ops::Range;\n \n use core::{self, DocContext};\n use doctree;\n use visit_ast;\n use html::render::{cache, ExternalLocation};\n use html::item_type::ItemType;\n-use html::markdown::markdown_links;\n \n pub mod inline;\n pub mod cfg;\n@@ -580,32 +574,7 @@ impl Clean<Item> for doctree::Module {\n         // maintain a stack of mod ids, for doc comment path resolution\n         // but we also need to resolve the module's own docs based on whether its docs were written\n         // inside or outside the module, so check for that\n-        let attrs = if self.attrs.iter()\n-                                 .filter(|a| a.check_name(\"doc\"))\n-                                 .next()\n-                                 .map_or(true, |a| a.style == AttrStyle::Inner) {\n-            // inner doc comment, use the module's own scope for resolution\n-            if self.id != NodeId::new(0) {\n-                *cx.current_item_name.borrow_mut() = Some(cx.tcx.hir.name(self.id));\n-            } else {\n-                *cx.current_item_name.borrow_mut() = None;\n-            }\n-            cx.mod_ids.borrow_mut().push(self.id);\n-            self.attrs.clean(cx)\n-        } else {\n-            // outer doc comment, use its parent's scope\n-            match cx.mod_ids.borrow().last() {\n-                Some(parent) if *parent != NodeId::new(0) => {\n-                    *cx.current_item_name.borrow_mut() = Some(cx.tcx.hir.name(*parent));\n-                }\n-                _ => {\n-                    *cx.current_item_name.borrow_mut() = None;\n-                }\n-            }\n-            let attrs = self.attrs.clean(cx);\n-            cx.mod_ids.borrow_mut().push(self.id);\n-            attrs\n-        };\n+        let attrs = self.attrs.clean(cx);\n \n         let mut items: Vec<Item> = vec![];\n         items.extend(self.extern_crates.iter().map(|x| x.clean(cx)));\n@@ -624,8 +593,6 @@ impl Clean<Item> for doctree::Module {\n         items.extend(self.impls.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n \n-        cx.mod_ids.borrow_mut().pop();\n-\n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n         let whence = {\n@@ -785,6 +752,7 @@ pub struct Attributes {\n     pub span: Option<syntax_pos::Span>,\n     /// map from Rust paths to resolved defs and potential URL fragments\n     pub links: Vec<(String, Option<DefId>, Option<String>)>,\n+    pub inner_docs: bool,\n }\n \n impl Attributes {\n@@ -929,12 +897,18 @@ impl Attributes {\n             }\n         }\n \n+        let inner_docs = attrs.iter()\n+                              .filter(|a| a.check_name(\"doc\"))\n+                              .next()\n+                              .map_or(true, |a| a.style == AttrStyle::Inner);\n+\n         Attributes {\n             doc_strings,\n             other_attrs,\n             cfg: if cfg == Cfg::True { None } else { Some(Arc::new(cfg)) },\n             span: sp,\n             links: vec![],\n+            inner_docs,\n         }\n     }\n \n@@ -1027,487 +1001,9 @@ impl AttributesExt for Attributes {\n     }\n }\n \n-/// Given a def, returns its name and disambiguator\n-/// for a value namespace\n-///\n-/// Returns None for things which cannot be ambiguous since\n-/// they exist in both namespaces (structs and modules)\n-fn value_ns_kind(def: Def, path_str: &str) -> Option<(&'static str, String)> {\n-    match def {\n-        // structs, variants, and mods exist in both namespaces. skip them\n-        Def::StructCtor(..) | Def::Mod(..) | Def::Variant(..) | Def::VariantCtor(..) => None,\n-        Def::Fn(..)\n-            => Some((\"function\", format!(\"{}()\", path_str))),\n-        Def::Method(..)\n-            => Some((\"method\", format!(\"{}()\", path_str))),\n-        Def::Const(..)\n-            => Some((\"const\", format!(\"const@{}\", path_str))),\n-        Def::Static(..)\n-            => Some((\"static\", format!(\"static@{}\", path_str))),\n-        _ => Some((\"value\", format!(\"value@{}\", path_str))),\n-    }\n-}\n-\n-/// Given a def, returns its name, the article to be used, and a disambiguator\n-/// for the type namespace\n-fn type_ns_kind(def: Def, path_str: &str) -> (&'static str, &'static str, String) {\n-    let (kind, article) = match def {\n-        // we can still have non-tuple structs\n-        Def::Struct(..) => (\"struct\", \"a\"),\n-        Def::Enum(..) => (\"enum\", \"an\"),\n-        Def::Trait(..) => (\"trait\", \"a\"),\n-        Def::Union(..) => (\"union\", \"a\"),\n-        _ => (\"type\", \"a\"),\n-    };\n-    (kind, article, format!(\"{}@{}\", kind, path_str))\n-}\n-\n-fn span_of_attrs(attrs: &Attributes) -> syntax_pos::Span {\n-    if attrs.doc_strings.is_empty() {\n-        return DUMMY_SP;\n-    }\n-    let start = attrs.doc_strings[0].span();\n-    let end = attrs.doc_strings.last().expect(\"No doc strings provided\").span();\n-    start.to(end)\n-}\n-\n-fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n-                   path_str: &str,\n-                   article1: &str, kind1: &str, disambig1: &str,\n-                   article2: &str, kind2: &str, disambig2: &str) {\n-    let sp = span_of_attrs(attrs);\n-    cx.sess()\n-      .struct_span_warn(sp,\n-                        &format!(\"`{}` is both {} {} and {} {}\",\n-                                 path_str, article1, kind1,\n-                                 article2, kind2))\n-      .help(&format!(\"try `{}` if you want to select the {}, \\\n-                      or `{}` if you want to \\\n-                      select the {}\",\n-                      disambig1, kind1, disambig2,\n-                      kind2))\n-      .emit();\n-}\n-\n-/// Given an enum variant's def, return the def of its enum and the associated fragment\n-fn handle_variant(cx: &DocContext, def: Def) -> Result<(Def, Option<String>), ()> {\n-    use rustc::ty::DefIdTree;\n-\n-    let parent = if let Some(parent) = cx.tcx.parent(def.def_id()) {\n-        parent\n-    } else {\n-        return Err(())\n-    };\n-    let parent_def = Def::Enum(parent);\n-    let variant = cx.tcx.expect_variant_def(def);\n-    Ok((parent_def, Some(format!(\"{}.v\", variant.name))))\n-}\n-\n-const PRIMITIVES: &[(&str, Def)] = &[\n-    (\"u8\",    Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U8))),\n-    (\"u16\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U16))),\n-    (\"u32\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U32))),\n-    (\"u64\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U64))),\n-    (\"u128\",  Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U128))),\n-    (\"usize\", Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::Usize))),\n-    (\"i8\",    Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I8))),\n-    (\"i16\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I16))),\n-    (\"i32\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I32))),\n-    (\"i64\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I64))),\n-    (\"i128\",  Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I128))),\n-    (\"isize\", Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::Isize))),\n-    (\"f32\",   Def::PrimTy(hir::PrimTy::TyFloat(syntax::ast::FloatTy::F32))),\n-    (\"f64\",   Def::PrimTy(hir::PrimTy::TyFloat(syntax::ast::FloatTy::F64))),\n-    (\"str\",   Def::PrimTy(hir::PrimTy::TyStr)),\n-    (\"bool\",  Def::PrimTy(hir::PrimTy::TyBool)),\n-    (\"char\",  Def::PrimTy(hir::PrimTy::TyChar)),\n-];\n-\n-fn is_primitive(path_str: &str, is_val: bool) -> Option<Def> {\n-    if is_val {\n-        None\n-    } else {\n-        PRIMITIVES.iter().find(|x| x.0 == path_str).map(|x| x.1)\n-    }\n-}\n-\n-/// Resolve a given string as a path, along with whether or not it is\n-/// in the value namespace. Also returns an optional URL fragment in the case\n-/// of variants and methods\n-fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option<String>), ()> {\n-    // In case we're in a module, try to resolve the relative\n-    // path\n-    if let Some(id) = cx.mod_ids.borrow().last() {\n-        let result = cx.resolver.borrow_mut()\n-                                .with_scope(*id,\n-            |resolver| {\n-                resolver.resolve_str_path_error(DUMMY_SP,\n-                                                &path_str, is_val)\n-        });\n-\n-        if let Ok(result) = result {\n-            // In case this is a trait item, skip the\n-            // early return and try looking for the trait\n-            let value = match result.def {\n-                Def::Method(_) | Def::AssociatedConst(_) => true,\n-                Def::AssociatedTy(_) => false,\n-                Def::Variant(_) => return handle_variant(cx, result.def),\n-                // not a trait item, just return what we found\n-                _ => return Ok((result.def, None))\n-            };\n-\n-            if value != is_val {\n-                return Err(())\n-            }\n-        } else if let Some(prim) = is_primitive(path_str, is_val) {\n-            return Ok((prim, Some(path_str.to_owned())))\n-        } else {\n-            // If resolution failed, it may still be a method\n-            // because methods are not handled by the resolver\n-            // If so, bail when we're not looking for a value\n-            if !is_val {\n-                return Err(())\n-            }\n-        }\n-\n-        // Try looking for methods and associated items\n-        let mut split = path_str.rsplitn(2, \"::\");\n-        let item_name = if let Some(first) = split.next() {\n-            first\n-        } else {\n-            return Err(())\n-        };\n-\n-        let mut path = if let Some(second) = split.next() {\n-            second.to_owned()\n-        } else {\n-            return Err(())\n-        };\n-\n-        if path == \"self\" || path == \"Self\" {\n-            if let Some(name) = *cx.current_item_name.borrow() {\n-                path = name.to_string();\n-            }\n-        }\n-\n-        let ty = cx.resolver.borrow_mut()\n-                            .with_scope(*id,\n-            |resolver| {\n-                resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n-        })?;\n-        match ty.def {\n-            Def::Struct(did) | Def::Union(did) | Def::Enum(did) | Def::TyAlias(did) => {\n-                let item = cx.tcx.inherent_impls(did)\n-                                 .iter()\n-                                 .flat_map(|imp| cx.tcx.associated_items(*imp))\n-                                 .find(|item| item.ident.name == item_name);\n-                if let Some(item) = item {\n-                    let out = match item.kind {\n-                        ty::AssociatedKind::Method if is_val => \"method\",\n-                        ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n-                        _ => return Err(())\n-                    };\n-                    Ok((ty.def, Some(format!(\"{}.{}\", out, item_name))))\n-                } else {\n-                    match cx.tcx.type_of(did).sty {\n-                        ty::TyAdt(def, _) => {\n-                            if let Some(item) = if def.is_enum() {\n-                                def.all_fields().find(|item| item.ident.name == item_name)\n-                            } else {\n-                                def.non_enum_variant()\n-                                   .fields\n-                                   .iter()\n-                                   .find(|item| item.ident.name == item_name)\n-                            } {\n-                                Ok((ty.def,\n-                                    Some(format!(\"{}.{}\",\n-                                                 if def.is_enum() {\n-                                                     \"variant\"\n-                                                 } else {\n-                                                     \"structfield\"\n-                                                 },\n-                                                 item.ident))))\n-                            } else {\n-                                Err(())\n-                            }\n-                        }\n-                        _ => Err(()),\n-                    }\n-                }\n-            }\n-            Def::Trait(did) => {\n-                let item = cx.tcx.associated_item_def_ids(did).iter()\n-                             .map(|item| cx.tcx.associated_item(*item))\n-                             .find(|item| item.ident.name == item_name);\n-                if let Some(item) = item {\n-                    let kind = match item.kind {\n-                        ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n-                        ty::AssociatedKind::Type if !is_val => \"associatedtype\",\n-                        ty::AssociatedKind::Method if is_val => {\n-                            if item.defaultness.has_value() {\n-                                \"method\"\n-                            } else {\n-                                \"tymethod\"\n-                            }\n-                        }\n-                        _ => return Err(())\n-                    };\n-\n-                    Ok((ty.def, Some(format!(\"{}.{}\", kind, item_name))))\n-                } else {\n-                    Err(())\n-                }\n-            }\n-            _ => Err(())\n-        }\n-    } else {\n-        Err(())\n-    }\n-}\n-\n-/// Resolve a string as a macro\n-fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n-    use syntax::ext::base::{MacroKind, SyntaxExtension};\n-    use syntax::ext::hygiene::Mark;\n-    let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n-    let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n-    let mut resolver = cx.resolver.borrow_mut();\n-    let mark = Mark::root();\n-    let res = resolver\n-        .resolve_macro_to_def_inner(mark, &path, MacroKind::Bang, false);\n-    if let Ok(def) = res {\n-        if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n-            return Some(def);\n-        }\n-    }\n-    if let Some(def) = resolver.all_macros.get(&Symbol::intern(path_str)) {\n-        return Some(*def);\n-    }\n-    None\n-}\n-\n-#[derive(Debug)]\n-enum PathKind {\n-    /// can be either value or type, not a macro\n-    Unknown,\n-    /// macro\n-    Macro,\n-    /// values, functions, consts, statics, everything in the value namespace\n-    Value,\n-    /// types, traits, everything in the type namespace\n-    Type,\n-}\n-\n-fn resolution_failure(\n-    cx: &DocContext,\n-    attrs: &Attributes,\n-    path_str: &str,\n-    dox: &str,\n-    link_range: Option<Range<usize>>,\n-) {\n-    let sp = span_of_attrs(attrs);\n-    let msg = format!(\"`[{}]` cannot be resolved, ignoring it...\", path_str);\n-\n-    let code_dox = sp.to_src(cx);\n-\n-    let doc_comment_padding = 3;\n-    let mut diag = if let Some(link_range) = link_range {\n-        // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n-        //                       ^    ~~~~~~\n-        //                       |    link_range\n-        //                       last_new_line_offset\n-\n-        let mut diag;\n-        if dox.lines().count() == code_dox.lines().count() {\n-            let line_offset = dox[..link_range.start].lines().count();\n-            // The span starts in the `///`, so we don't have to account for the leading whitespace\n-            let code_dox_len = if line_offset <= 1 {\n-                doc_comment_padding\n-            } else {\n-                // The first `///`\n-                doc_comment_padding +\n-                    // Each subsequent leading whitespace and `///`\n-                    code_dox.lines().skip(1).take(line_offset - 1).fold(0, |sum, line| {\n-                        sum + doc_comment_padding + line.len() - line.trim().len()\n-                    })\n-            };\n-\n-            // Extract the specific span\n-            let sp = sp.from_inner_byte_pos(\n-                link_range.start + code_dox_len,\n-                link_range.end + code_dox_len,\n-            );\n-\n-            diag = cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-                                                NodeId::new(0),\n-                                                sp,\n-                                                &msg);\n-            diag.span_label(sp, \"cannot be resolved, ignoring\");\n-        } else {\n-            diag = cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-                                                NodeId::new(0),\n-                                                sp,\n-                                                &msg);\n-\n-            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n-            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n-\n-            // Print the line containing the `link_range` and manually mark it with '^'s\n-            diag.note(&format!(\n-                \"the link appears in this line:\\n\\n{line}\\n\\\n-                 {indicator: <before$}{indicator:^<found$}\",\n-                line=line,\n-                indicator=\"\",\n-                before=link_range.start - last_new_line_offset,\n-                found=link_range.len(),\n-            ));\n-        }\n-        diag\n-    } else {\n-        cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-                                     NodeId::new(0),\n-                                     sp,\n-                                     &msg)\n-    };\n-    diag.help(\"to escape `[` and `]` characters, just add '\\\\' before them like \\\n-               `\\\\[` or `\\\\]`\");\n-    diag.emit();\n-}\n-\n impl Clean<Attributes> for [ast::Attribute] {\n     fn clean(&self, cx: &DocContext) -> Attributes {\n-        let mut attrs = Attributes::from_ast(cx.sess().diagnostic(), self);\n-\n-        if UnstableFeatures::from_environment().is_nightly_build() {\n-            let dox = attrs.collapsed_doc_value().unwrap_or_else(String::new);\n-            for (ori_link, link_range) in markdown_links(&dox) {\n-                // bail early for real links\n-                if ori_link.contains('/') {\n-                    continue;\n-                }\n-                let link = ori_link.replace(\"`\", \"\");\n-                let (def, fragment) = {\n-                    let mut kind = PathKind::Unknown;\n-                    let path_str = if let Some(prefix) =\n-                        [\"struct@\", \"enum@\", \"type@\",\n-                         \"trait@\", \"union@\"].iter()\n-                                          .find(|p| link.starts_with(**p)) {\n-                        kind = PathKind::Type;\n-                        link.trim_left_matches(prefix)\n-                    } else if let Some(prefix) =\n-                        [\"const@\", \"static@\",\n-                         \"value@\", \"function@\", \"mod@\",\n-                         \"fn@\", \"module@\", \"method@\"]\n-                            .iter().find(|p| link.starts_with(**p)) {\n-                        kind = PathKind::Value;\n-                        link.trim_left_matches(prefix)\n-                    } else if link.ends_with(\"()\") {\n-                        kind = PathKind::Value;\n-                        link.trim_right_matches(\"()\")\n-                    } else if link.starts_with(\"macro@\") {\n-                        kind = PathKind::Macro;\n-                        link.trim_left_matches(\"macro@\")\n-                    } else if link.ends_with('!') {\n-                        kind = PathKind::Macro;\n-                        link.trim_right_matches('!')\n-                    } else {\n-                        &link[..]\n-                    }.trim();\n-\n-                    if path_str.contains(|ch: char| !(ch.is_alphanumeric() ||\n-                                                      ch == ':' || ch == '_')) {\n-                        continue;\n-                    }\n-\n-                    match kind {\n-                        PathKind::Value => {\n-                            if let Ok(def) = resolve(cx, path_str, true) {\n-                                def\n-                            } else {\n-                                resolution_failure(cx, &attrs, path_str, &dox, link_range);\n-                                // this could just be a normal link or a broken link\n-                                // we could potentially check if something is\n-                                // \"intra-doc-link-like\" and warn in that case\n-                                continue;\n-                            }\n-                        }\n-                        PathKind::Type => {\n-                            if let Ok(def) = resolve(cx, path_str, false) {\n-                                def\n-                            } else {\n-                                resolution_failure(cx, &attrs, path_str, &dox, link_range);\n-                                // this could just be a normal link\n-                                continue;\n-                            }\n-                        }\n-                        PathKind::Unknown => {\n-                            // try everything!\n-                            if let Some(macro_def) = macro_resolve(cx, path_str) {\n-                                if let Ok(type_def) = resolve(cx, path_str, false) {\n-                                    let (type_kind, article, type_disambig)\n-                                        = type_ns_kind(type_def.0, path_str);\n-                                    ambiguity_error(cx, &attrs, path_str,\n-                                                    article, type_kind, &type_disambig,\n-                                                    \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n-                                    continue;\n-                                } else if let Ok(value_def) = resolve(cx, path_str, true) {\n-                                    let (value_kind, value_disambig)\n-                                        = value_ns_kind(value_def.0, path_str)\n-                                            .expect(\"struct and mod cases should have been \\\n-                                                     caught in previous branch\");\n-                                    ambiguity_error(cx, &attrs, path_str,\n-                                                    \"a\", value_kind, &value_disambig,\n-                                                    \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n-                                }\n-                                (macro_def, None)\n-                            } else if let Ok(type_def) = resolve(cx, path_str, false) {\n-                                // It is imperative we search for not-a-value first\n-                                // Otherwise we will find struct ctors for when we are looking\n-                                // for structs, and the link won't work.\n-                                // if there is something in both namespaces\n-                                if let Ok(value_def) = resolve(cx, path_str, true) {\n-                                    let kind = value_ns_kind(value_def.0, path_str);\n-                                    if let Some((value_kind, value_disambig)) = kind {\n-                                        let (type_kind, article, type_disambig)\n-                                            = type_ns_kind(type_def.0, path_str);\n-                                        ambiguity_error(cx, &attrs, path_str,\n-                                                        article, type_kind, &type_disambig,\n-                                                        \"a\", value_kind, &value_disambig);\n-                                        continue;\n-                                    }\n-                                }\n-                                type_def\n-                            } else if let Ok(value_def) = resolve(cx, path_str, true) {\n-                                value_def\n-                            } else {\n-                                resolution_failure(cx, &attrs, path_str, &dox, link_range);\n-                                // this could just be a normal link\n-                                continue;\n-                            }\n-                        }\n-                        PathKind::Macro => {\n-                            if let Some(def) = macro_resolve(cx, path_str) {\n-                                (def, None)\n-                            } else {\n-                                resolution_failure(cx, &attrs, path_str, &dox, link_range);\n-                                continue\n-                            }\n-                        }\n-                    }\n-                };\n-\n-                if let Def::PrimTy(_) = def {\n-                    attrs.links.push((ori_link, None, fragment));\n-                } else {\n-                    let id = register_def(cx, def);\n-                    attrs.links.push((ori_link, Some(id), fragment));\n-                }\n-            }\n-\n-            cx.sess().abort_if_errors();\n-        }\n-\n-        attrs\n+        Attributes::from_ast(cx.sess().diagnostic(), self)\n     }\n }\n \n@@ -2165,7 +1661,6 @@ impl Clean<Item> for doctree::Function {\n             (self.generics.clean(cx), (&self.decl, self.body).clean(cx))\n         });\n \n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -2340,7 +1835,6 @@ pub struct Trait {\n \n impl Clean<Item> for doctree::Trait {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         let attrs = self.attrs.clean(cx);\n         let is_spotlight = attrs.has_doc_flag(\"spotlight\");\n         Item {\n@@ -2412,7 +1906,6 @@ impl Clean<Item> for hir::TraitItem {\n                 AssociatedTypeItem(bounds.clean(cx), default.clean(cx))\n             }\n         };\n-        *cx.current_item_name.borrow_mut() = Some(self.ident.name);\n         Item {\n             name: Some(self.ident.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -2445,7 +1938,6 @@ impl Clean<Item> for hir::ImplItem {\n                 generics: Generics::default(),\n             }, true),\n         };\n-        *cx.current_item_name.borrow_mut() = Some(self.ident.name);\n         Item {\n             name: Some(self.ident.name.clean(cx)),\n             source: self.span.clean(cx),\n@@ -3239,7 +2731,6 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n impl Clean<Item> for hir::StructField {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        *cx.current_item_name.borrow_mut() = Some(self.ident.name);\n         Item {\n             name: Some(self.ident.name).clean(cx),\n             attrs: self.attrs.clean(cx),\n@@ -3319,7 +2810,6 @@ impl Clean<Vec<Item>> for doctree::Struct {\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n         ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n \n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n             name: Some(name),\n             attrs: self.attrs.clean(cx),\n@@ -3346,7 +2836,6 @@ impl Clean<Vec<Item>> for doctree::Union {\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n         ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n \n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n             name: Some(name),\n             attrs: self.attrs.clean(cx),\n@@ -3400,7 +2889,6 @@ impl Clean<Vec<Item>> for doctree::Enum {\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n         ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n \n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n             name: Some(name),\n             attrs: self.attrs.clean(cx),\n@@ -3427,7 +2915,6 @@ pub struct Variant {\n \n impl Clean<Item> for doctree::Variant {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3708,7 +3195,6 @@ pub struct Typedef {\n \n impl Clean<Item> for doctree::Typedef {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3784,7 +3270,6 @@ pub struct Static {\n impl Clean<Item> for doctree::Static {\n     fn clean(&self, cx: &DocContext) -> Item {\n         debug!(\"cleaning static {}: {:?}\", self.name.clean(cx), self);\n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3810,7 +3295,6 @@ pub struct Constant {\n \n impl Clean<Item> for doctree::Constant {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3892,23 +3376,6 @@ pub fn get_blanket_impls_with_def_id(cx: &DocContext, id: DefId) -> Vec<Item> {\n     finder.get_with_def_id(id)\n }\n \n-fn get_name_if_possible(cx: &DocContext, node: NodeId) -> Option<Name> {\n-    match cx.tcx.hir.get(node) {\n-        Node::NodeItem(_) |\n-        Node::NodeForeignItem(_) |\n-        Node::NodeImplItem(_) |\n-        Node::NodeTraitItem(_) |\n-        Node::NodeVariant(_) |\n-        Node::NodeField(_) |\n-        Node::NodeLifetime(_) |\n-        Node::NodeGenericParam(_) |\n-        Node::NodeBinding(&hir::Pat { node: hir::PatKind::Binding(_,_,_,_), .. }) |\n-        Node::NodeStructCtor(_) => {}\n-        _ => return None,\n-    }\n-    Some(cx.tcx.hir.name(node))\n-}\n-\n impl Clean<Vec<Item>> for doctree::Impl {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         let mut ret = Vec::new();\n@@ -3928,7 +3395,6 @@ impl Clean<Vec<Item>> for doctree::Impl {\n                   .collect()\n         }).unwrap_or(FxHashSet());\n \n-        *cx.current_item_name.borrow_mut() = get_name_if_possible(cx, self.for_.id);\n         ret.push(Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n@@ -4016,7 +3482,6 @@ fn build_deref_target_impls(cx: &DocContext,\n \n impl Clean<Item> for doctree::ExternCrate {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n@@ -4064,7 +3529,6 @@ impl Clean<Vec<Item>> for doctree::Import {\n             Import::Simple(name.clean(cx), resolve_use_source(cx, path))\n         };\n \n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         vec![Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n@@ -4134,7 +3598,6 @@ impl Clean<Item> for hir::ForeignItem {\n             }\n         };\n \n-        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -4150,7 +3613,7 @@ impl Clean<Item> for hir::ForeignItem {\n \n // Utilities\n \n-trait ToSource {\n+pub trait ToSource {\n     fn to_src(&self, cx: &DocContext) -> String;\n }\n \n@@ -4260,7 +3723,7 @@ fn resolve_type(cx: &DocContext,\n     ResolvedPath { path: path, typarams: None, did: did, is_generic: is_generic }\n }\n \n-fn register_def(cx: &DocContext, def: Def) -> DefId {\n+pub fn register_def(cx: &DocContext, def: Def) -> DefId {\n     debug!(\"register_def({:?})\", def);\n \n     let (did, kind) = match def {\n@@ -4311,7 +3774,6 @@ pub struct Macro {\n impl Clean<Item> for doctree::Macro {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let name = self.name.clean(cx);\n-        *cx.current_item_name.borrow_mut() = None;\n         Item {\n             name: Some(name.clone()),\n             attrs: self.attrs.clean(cx),"}, {"sha": "3e5f16817a8d033cb684c25b5a4dc0e9f344387e", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e26687731458b1a6ec1b04e9c0d514c23237d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e26687731458b1a6ec1b04e9c0d514c23237d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9e4e26687731458b1a6ec1b04e9c0d514c23237d", "patch": "@@ -26,7 +26,7 @@ use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n use rustc_target::spec::TargetTriple;\n \n-use syntax::ast::{self, Ident, Name, NodeId};\n+use syntax::ast::{self, Ident};\n use syntax::codemap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n@@ -58,7 +58,6 @@ pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub resolver: &'a RefCell<resolve::Resolver<'rcx, 'cstore>>,\n     /// The stack of module NodeIds up till this point\n-    pub mod_ids: RefCell<Vec<NodeId>>,\n     pub crate_name: Option<String>,\n     pub cstore: Rc<CStore>,\n     pub populated_all_crate_impls: Cell<bool>,\n@@ -88,7 +87,6 @@ pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx> {\n     pub all_fake_def_ids: RefCell<FxHashSet<DefId>>,\n     /// Maps (type_id, trait_id) -> auto trait impl\n     pub generated_synthetics: RefCell<FxHashSet<(DefId, DefId)>>,\n-    pub current_item_name: RefCell<Option<Name>>,\n     pub all_traits: Vec<DefId>,\n }\n \n@@ -325,7 +323,8 @@ pub fn run_core(search_paths: SearchPaths,\n                 lint_cap: Option<lint::Level>,\n                 describe_lints: bool,\n                 mut manual_passes: Vec<String>,\n-                mut default_passes: passes::DefaultPassOption) -> (clean::Crate, RenderInfo, Vec<String>)\n+                mut default_passes: passes::DefaultPassOption)\n+    -> (clean::Crate, RenderInfo, Vec<String>)\n {\n     // Parse, resolve, and typecheck the given crate.\n \n@@ -520,12 +519,10 @@ pub fn run_core(search_paths: SearchPaths,\n                 ty_substs: Default::default(),\n                 lt_substs: Default::default(),\n                 impl_trait_bounds: Default::default(),\n-                mod_ids: Default::default(),\n                 send_trait: send_trait,\n                 fake_def_ids: RefCell::new(FxHashMap()),\n                 all_fake_def_ids: RefCell::new(FxHashSet()),\n                 generated_synthetics: RefCell::new(FxHashSet()),\n-                current_item_name: RefCell::new(None),\n                 all_traits: tcx.all_traits(LOCAL_CRATE).to_vec(),\n             };\n             debug!(\"crate: {:?}\", tcx.hir.krate());"}, {"sha": "981832ab9e2dc3b4ee83d0ad35237a4785ab228f", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "added", "additions": 598, "deletions": 0, "changes": 598, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e26687731458b1a6ec1b04e9c0d514c23237d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e26687731458b1a6ec1b04e9c0d514c23237d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=9e4e26687731458b1a6ec1b04e9c0d514c23237d", "patch": "@@ -0,0 +1,598 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clean::*;\n+\n+use rustc::lint as lint;\n+use rustc::hir;\n+use rustc::hir::def::Def;\n+use rustc::ty;\n+use syntax;\n+use syntax::ast::{self, Ident, NodeId};\n+use syntax::feature_gate::UnstableFeatures;\n+use syntax::symbol::Symbol;\n+use syntax_pos::{self, DUMMY_SP};\n+\n+use std::ops::Range;\n+\n+use core::DocContext;\n+use fold::DocFolder;\n+use html::markdown::markdown_links;\n+use passes::Pass;\n+\n+pub const COLLECT_INTRA_DOC_LINKS: Pass =\n+    Pass::early(\"collect-intra-doc-links\", collect_intra_doc_links,\n+                \"reads a crate's documentation to resolve intra-doc-links\");\n+\n+pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext) -> Crate {\n+    if !UnstableFeatures::from_environment().is_nightly_build() {\n+        krate\n+    } else {\n+        let mut coll = LinkCollector::new(cx);\n+\n+        coll.fold_crate(krate)\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum PathKind {\n+    /// can be either value or type, not a macro\n+    Unknown,\n+    /// macro\n+    Macro,\n+    /// values, functions, consts, statics, everything in the value namespace\n+    Value,\n+    /// types, traits, everything in the type namespace\n+    Type,\n+}\n+\n+struct LinkCollector<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx> {\n+    cx: &'a DocContext<'a, 'tcx, 'rcx, 'cstore>,\n+    mod_ids: Vec<NodeId>,\n+}\n+\n+impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n+    fn new(cx: &'a DocContext<'a, 'tcx, 'rcx, 'cstore>) -> Self {\n+        LinkCollector {\n+            cx,\n+            mod_ids: Vec::new(),\n+        }\n+    }\n+\n+    /// Resolve a given string as a path, along with whether or not it is\n+    /// in the value namespace. Also returns an optional URL fragment in the case\n+    /// of variants and methods\n+    fn resolve(&self, path_str: &str, is_val: bool, current_item: &Option<String>)\n+        -> Result<(Def, Option<String>), ()>\n+    {\n+        let cx = self.cx;\n+\n+        // In case we're in a module, try to resolve the relative\n+        // path\n+        if let Some(id) = self.mod_ids.last() {\n+            let result = cx.resolver.borrow_mut()\n+                                    .with_scope(*id,\n+                |resolver| {\n+                    resolver.resolve_str_path_error(DUMMY_SP,\n+                                                    &path_str, is_val)\n+            });\n+\n+            if let Ok(result) = result {\n+                // In case this is a trait item, skip the\n+                // early return and try looking for the trait\n+                let value = match result.def {\n+                    Def::Method(_) | Def::AssociatedConst(_) => true,\n+                    Def::AssociatedTy(_) => false,\n+                    Def::Variant(_) => return handle_variant(cx, result.def),\n+                    // not a trait item, just return what we found\n+                    _ => return Ok((result.def, None))\n+                };\n+\n+                if value != is_val {\n+                    return Err(())\n+                }\n+            } else if let Some(prim) = is_primitive(path_str, is_val) {\n+                return Ok((prim, Some(path_str.to_owned())))\n+            } else {\n+                // If resolution failed, it may still be a method\n+                // because methods are not handled by the resolver\n+                // If so, bail when we're not looking for a value\n+                if !is_val {\n+                    return Err(())\n+                }\n+            }\n+\n+            // Try looking for methods and associated items\n+            let mut split = path_str.rsplitn(2, \"::\");\n+            let item_name = if let Some(first) = split.next() {\n+                first\n+            } else {\n+                return Err(())\n+            };\n+\n+            let mut path = if let Some(second) = split.next() {\n+                second.to_owned()\n+            } else {\n+                return Err(())\n+            };\n+\n+            if path == \"self\" || path == \"Self\" {\n+                if let Some(name) = current_item.as_ref() {\n+                    path = name.clone();\n+                }\n+            }\n+\n+            let ty = cx.resolver.borrow_mut()\n+                                .with_scope(*id,\n+                |resolver| {\n+                    resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n+            })?;\n+            match ty.def {\n+                Def::Struct(did) | Def::Union(did) | Def::Enum(did) | Def::TyAlias(did) => {\n+                    let item = cx.tcx.inherent_impls(did)\n+                                     .iter()\n+                                     .flat_map(|imp| cx.tcx.associated_items(*imp))\n+                                     .find(|item| item.ident.name == item_name);\n+                    if let Some(item) = item {\n+                        let out = match item.kind {\n+                            ty::AssociatedKind::Method if is_val => \"method\",\n+                            ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n+                            _ => return Err(())\n+                        };\n+                        Ok((ty.def, Some(format!(\"{}.{}\", out, item_name))))\n+                    } else {\n+                        match cx.tcx.type_of(did).sty {\n+                            ty::TyAdt(def, _) => {\n+                                if let Some(item) = if def.is_enum() {\n+                                    def.all_fields().find(|item| item.ident.name == item_name)\n+                                } else {\n+                                    def.non_enum_variant()\n+                                       .fields\n+                                       .iter()\n+                                       .find(|item| item.ident.name == item_name)\n+                                } {\n+                                    Ok((ty.def,\n+                                        Some(format!(\"{}.{}\",\n+                                                     if def.is_enum() {\n+                                                         \"variant\"\n+                                                     } else {\n+                                                         \"structfield\"\n+                                                     },\n+                                                     item.ident))))\n+                                } else {\n+                                    Err(())\n+                                }\n+                            }\n+                            _ => Err(()),\n+                        }\n+                    }\n+                }\n+                Def::Trait(did) => {\n+                    let item = cx.tcx.associated_item_def_ids(did).iter()\n+                                 .map(|item| cx.tcx.associated_item(*item))\n+                                 .find(|item| item.ident.name == item_name);\n+                    if let Some(item) = item {\n+                        let kind = match item.kind {\n+                            ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n+                            ty::AssociatedKind::Type if !is_val => \"associatedtype\",\n+                            ty::AssociatedKind::Method if is_val => {\n+                                if item.defaultness.has_value() {\n+                                    \"method\"\n+                                } else {\n+                                    \"tymethod\"\n+                                }\n+                            }\n+                            _ => return Err(())\n+                        };\n+\n+                        Ok((ty.def, Some(format!(\"{}.{}\", kind, item_name))))\n+                    } else {\n+                        Err(())\n+                    }\n+                }\n+                _ => Err(())\n+            }\n+        } else {\n+            Err(())\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n+    fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n+        let item_node_id = if item.is_mod() {\n+            if let Some(id) = self.cx.tcx.hir.as_local_node_id(item.def_id) {\n+                Some(id)\n+            } else {\n+                debug!(\"attempting to fold on a non-local item: {:?}\", item);\n+                return self.fold_item_recur(item);\n+            }\n+        } else {\n+            None\n+        };\n+\n+        let current_item = match item.inner {\n+            ModuleItem(..) => {\n+                if item.attrs.inner_docs {\n+                    if item_node_id.unwrap() != NodeId::new(0) {\n+                        item.name.clone()\n+                    } else {\n+                        None\n+                    }\n+                } else {\n+                    match self.mod_ids.last() {\n+                        Some(parent) if *parent != NodeId::new(0) => {\n+                            //FIXME: can we pull the parent module's name from elsewhere?\n+                            Some(self.cx.tcx.hir.name(*parent).to_string())\n+                        }\n+                        _ => None,\n+                    }\n+                }\n+            }\n+            ImplItem(Impl { ref for_, .. }) => {\n+                for_.def_id().map(|did| self.cx.tcx.item_name(did).to_string())\n+            }\n+            ExternCrateItem(ref name, ..) => Some(name.clone()),\n+            ImportItem(Import::Simple(ref name, ..)) => Some(name.clone()),\n+            MacroItem(..) => None,\n+            _ => item.name.clone(),\n+        };\n+\n+        if item.is_mod() && item.attrs.inner_docs {\n+            self.mod_ids.push(item_node_id.unwrap());\n+        }\n+\n+        let cx = self.cx;\n+        let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);\n+\n+        for (ori_link, link_range) in markdown_links(&dox) {\n+            // bail early for real links\n+            if ori_link.contains('/') {\n+                continue;\n+            }\n+            let link = ori_link.replace(\"`\", \"\");\n+            let (def, fragment) = {\n+                let mut kind = PathKind::Unknown;\n+                let path_str = if let Some(prefix) =\n+                    [\"struct@\", \"enum@\", \"type@\",\n+                     \"trait@\", \"union@\"].iter()\n+                                      .find(|p| link.starts_with(**p)) {\n+                    kind = PathKind::Type;\n+                    link.trim_left_matches(prefix)\n+                } else if let Some(prefix) =\n+                    [\"const@\", \"static@\",\n+                     \"value@\", \"function@\", \"mod@\",\n+                     \"fn@\", \"module@\", \"method@\"]\n+                        .iter().find(|p| link.starts_with(**p)) {\n+                    kind = PathKind::Value;\n+                    link.trim_left_matches(prefix)\n+                } else if link.ends_with(\"()\") {\n+                    kind = PathKind::Value;\n+                    link.trim_right_matches(\"()\")\n+                } else if link.starts_with(\"macro@\") {\n+                    kind = PathKind::Macro;\n+                    link.trim_left_matches(\"macro@\")\n+                } else if link.ends_with('!') {\n+                    kind = PathKind::Macro;\n+                    link.trim_right_matches('!')\n+                } else {\n+                    &link[..]\n+                }.trim();\n+\n+                if path_str.contains(|ch: char| !(ch.is_alphanumeric() ||\n+                                                  ch == ':' || ch == '_')) {\n+                    continue;\n+                }\n+\n+                match kind {\n+                    PathKind::Value => {\n+                        if let Ok(def) = self.resolve(path_str, true, &current_item) {\n+                            def\n+                        } else {\n+                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            // this could just be a normal link or a broken link\n+                            // we could potentially check if something is\n+                            // \"intra-doc-link-like\" and warn in that case\n+                            continue;\n+                        }\n+                    }\n+                    PathKind::Type => {\n+                        if let Ok(def) = self.resolve(path_str, false, &current_item) {\n+                            def\n+                        } else {\n+                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            // this could just be a normal link\n+                            continue;\n+                        }\n+                    }\n+                    PathKind::Unknown => {\n+                        // try everything!\n+                        if let Some(macro_def) = macro_resolve(cx, path_str) {\n+                            if let Ok(type_def) = self.resolve(path_str, false, &current_item) {\n+                                let (type_kind, article, type_disambig)\n+                                    = type_ns_kind(type_def.0, path_str);\n+                                ambiguity_error(cx, &item.attrs, path_str,\n+                                                article, type_kind, &type_disambig,\n+                                                \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n+                                continue;\n+                            } else if let Ok(value_def) = self.resolve(path_str,\n+                                                                       true,\n+                                                                       &current_item) {\n+                                let (value_kind, value_disambig)\n+                                    = value_ns_kind(value_def.0, path_str)\n+                                        .expect(\"struct and mod cases should have been \\\n+                                                 caught in previous branch\");\n+                                ambiguity_error(cx, &item.attrs, path_str,\n+                                                \"a\", value_kind, &value_disambig,\n+                                                \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n+                            }\n+                            (macro_def, None)\n+                        } else if let Ok(type_def) = self.resolve(path_str, false, &current_item) {\n+                            // It is imperative we search for not-a-value first\n+                            // Otherwise we will find struct ctors for when we are looking\n+                            // for structs, and the link won't work.\n+                            // if there is something in both namespaces\n+                            if let Ok(value_def) = self.resolve(path_str, true, &current_item) {\n+                                let kind = value_ns_kind(value_def.0, path_str);\n+                                if let Some((value_kind, value_disambig)) = kind {\n+                                    let (type_kind, article, type_disambig)\n+                                        = type_ns_kind(type_def.0, path_str);\n+                                    ambiguity_error(cx, &item.attrs, path_str,\n+                                                    article, type_kind, &type_disambig,\n+                                                    \"a\", value_kind, &value_disambig);\n+                                    continue;\n+                                }\n+                            }\n+                            type_def\n+                        } else if let Ok(value_def) = self.resolve(path_str, true, &current_item) {\n+                            value_def\n+                        } else {\n+                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            // this could just be a normal link\n+                            continue;\n+                        }\n+                    }\n+                    PathKind::Macro => {\n+                        if let Some(def) = macro_resolve(cx, path_str) {\n+                            (def, None)\n+                        } else {\n+                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            continue\n+                        }\n+                    }\n+                }\n+            };\n+\n+            if let Def::PrimTy(_) = def {\n+                item.attrs.links.push((ori_link, None, fragment));\n+            } else {\n+                let id = register_def(cx, def);\n+                item.attrs.links.push((ori_link, Some(id), fragment));\n+            }\n+        }\n+\n+        cx.sess().abort_if_errors();\n+\n+        if item.is_mod() && !item.attrs.inner_docs {\n+            self.mod_ids.push(item_node_id.unwrap());\n+        }\n+\n+        if item.is_mod() {\n+            let ret = self.fold_item_recur(item);\n+\n+            self.mod_ids.pop();\n+\n+            ret\n+        } else {\n+            self.fold_item_recur(item)\n+        }\n+    }\n+}\n+\n+/// Resolve a string as a macro\n+fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n+    use syntax::ext::base::{MacroKind, SyntaxExtension};\n+    use syntax::ext::hygiene::Mark;\n+    let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n+    let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n+    let mut resolver = cx.resolver.borrow_mut();\n+    let mark = Mark::root();\n+    let res = resolver\n+        .resolve_macro_to_def_inner(mark, &path, MacroKind::Bang, false);\n+    if let Ok(def) = res {\n+        if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n+            return Some(def);\n+        }\n+    }\n+    if let Some(def) = resolver.all_macros.get(&Symbol::intern(path_str)) {\n+        return Some(*def);\n+    }\n+    None\n+}\n+\n+fn span_of_attrs(attrs: &Attributes) -> syntax_pos::Span {\n+    if attrs.doc_strings.is_empty() {\n+        return DUMMY_SP;\n+    }\n+    let start = attrs.doc_strings[0].span();\n+    let end = attrs.doc_strings.last().expect(\"No doc strings provided\").span();\n+    start.to(end)\n+}\n+\n+fn resolution_failure(\n+    cx: &DocContext,\n+    attrs: &Attributes,\n+    path_str: &str,\n+    dox: &str,\n+    link_range: Option<Range<usize>>,\n+) {\n+    let sp = span_of_attrs(attrs);\n+    let msg = format!(\"`[{}]` cannot be resolved, ignoring it...\", path_str);\n+\n+    let code_dox = sp.to_src(cx);\n+\n+    let doc_comment_padding = 3;\n+    let mut diag = if let Some(link_range) = link_range {\n+        // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n+        //                       ^    ~~~~~~\n+        //                       |    link_range\n+        //                       last_new_line_offset\n+\n+        let mut diag;\n+        if dox.lines().count() == code_dox.lines().count() {\n+            let line_offset = dox[..link_range.start].lines().count();\n+            // The span starts in the `///`, so we don't have to account for the leading whitespace\n+            let code_dox_len = if line_offset <= 1 {\n+                doc_comment_padding\n+            } else {\n+                // The first `///`\n+                doc_comment_padding +\n+                    // Each subsequent leading whitespace and `///`\n+                    code_dox.lines().skip(1).take(line_offset - 1).fold(0, |sum, line| {\n+                        sum + doc_comment_padding + line.len() - line.trim().len()\n+                    })\n+            };\n+\n+            // Extract the specific span\n+            let sp = sp.from_inner_byte_pos(\n+                link_range.start + code_dox_len,\n+                link_range.end + code_dox_len,\n+            );\n+\n+            diag = cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+                                                NodeId::new(0),\n+                                                sp,\n+                                                &msg);\n+            diag.span_label(sp, \"cannot be resolved, ignoring\");\n+        } else {\n+            diag = cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+                                                NodeId::new(0),\n+                                                sp,\n+                                                &msg);\n+\n+            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n+\n+            // Print the line containing the `link_range` and manually mark it with '^'s\n+            diag.note(&format!(\n+                \"the link appears in this line:\\n\\n{line}\\n\\\n+                 {indicator: <before$}{indicator:^<found$}\",\n+                line=line,\n+                indicator=\"\",\n+                before=link_range.start - last_new_line_offset,\n+                found=link_range.len(),\n+            ));\n+        }\n+        diag\n+    } else {\n+        cx.tcx.struct_span_lint_node(lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+                                     NodeId::new(0),\n+                                     sp,\n+                                     &msg)\n+    };\n+    diag.help(\"to escape `[` and `]` characters, just add '\\\\' before them like \\\n+               `\\\\[` or `\\\\]`\");\n+    diag.emit();\n+}\n+\n+fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n+                   path_str: &str,\n+                   article1: &str, kind1: &str, disambig1: &str,\n+                   article2: &str, kind2: &str, disambig2: &str) {\n+    let sp = span_of_attrs(attrs);\n+    cx.sess()\n+      .struct_span_warn(sp,\n+                        &format!(\"`{}` is both {} {} and {} {}\",\n+                                 path_str, article1, kind1,\n+                                 article2, kind2))\n+      .help(&format!(\"try `{}` if you want to select the {}, \\\n+                      or `{}` if you want to \\\n+                      select the {}\",\n+                      disambig1, kind1, disambig2,\n+                      kind2))\n+      .emit();\n+}\n+\n+/// Given a def, returns its name and disambiguator\n+/// for a value namespace\n+///\n+/// Returns None for things which cannot be ambiguous since\n+/// they exist in both namespaces (structs and modules)\n+fn value_ns_kind(def: Def, path_str: &str) -> Option<(&'static str, String)> {\n+    match def {\n+        // structs, variants, and mods exist in both namespaces. skip them\n+        Def::StructCtor(..) | Def::Mod(..) | Def::Variant(..) | Def::VariantCtor(..) => None,\n+        Def::Fn(..)\n+            => Some((\"function\", format!(\"{}()\", path_str))),\n+        Def::Method(..)\n+            => Some((\"method\", format!(\"{}()\", path_str))),\n+        Def::Const(..)\n+            => Some((\"const\", format!(\"const@{}\", path_str))),\n+        Def::Static(..)\n+            => Some((\"static\", format!(\"static@{}\", path_str))),\n+        _ => Some((\"value\", format!(\"value@{}\", path_str))),\n+    }\n+}\n+\n+/// Given a def, returns its name, the article to be used, and a disambiguator\n+/// for the type namespace\n+fn type_ns_kind(def: Def, path_str: &str) -> (&'static str, &'static str, String) {\n+    let (kind, article) = match def {\n+        // we can still have non-tuple structs\n+        Def::Struct(..) => (\"struct\", \"a\"),\n+        Def::Enum(..) => (\"enum\", \"an\"),\n+        Def::Trait(..) => (\"trait\", \"a\"),\n+        Def::Union(..) => (\"union\", \"a\"),\n+        _ => (\"type\", \"a\"),\n+    };\n+    (kind, article, format!(\"{}@{}\", kind, path_str))\n+}\n+\n+/// Given an enum variant's def, return the def of its enum and the associated fragment\n+fn handle_variant(cx: &DocContext, def: Def) -> Result<(Def, Option<String>), ()> {\n+    use rustc::ty::DefIdTree;\n+\n+    let parent = if let Some(parent) = cx.tcx.parent(def.def_id()) {\n+        parent\n+    } else {\n+        return Err(())\n+    };\n+    let parent_def = Def::Enum(parent);\n+    let variant = cx.tcx.expect_variant_def(def);\n+    Ok((parent_def, Some(format!(\"{}.v\", variant.name))))\n+}\n+\n+const PRIMITIVES: &[(&str, Def)] = &[\n+    (\"u8\",    Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U8))),\n+    (\"u16\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U16))),\n+    (\"u32\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U32))),\n+    (\"u64\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U64))),\n+    (\"u128\",  Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U128))),\n+    (\"usize\", Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::Usize))),\n+    (\"i8\",    Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I8))),\n+    (\"i16\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I16))),\n+    (\"i32\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I32))),\n+    (\"i64\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I64))),\n+    (\"i128\",  Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I128))),\n+    (\"isize\", Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::Isize))),\n+    (\"f32\",   Def::PrimTy(hir::PrimTy::TyFloat(syntax::ast::FloatTy::F32))),\n+    (\"f64\",   Def::PrimTy(hir::PrimTy::TyFloat(syntax::ast::FloatTy::F64))),\n+    (\"str\",   Def::PrimTy(hir::PrimTy::TyStr)),\n+    (\"bool\",  Def::PrimTy(hir::PrimTy::TyBool)),\n+    (\"char\",  Def::PrimTy(hir::PrimTy::TyChar)),\n+];\n+\n+fn is_primitive(path_str: &str, is_val: bool) -> Option<Def> {\n+    if is_val {\n+        None\n+    } else {\n+        PRIMITIVES.iter().find(|x| x.0 == path_str).map(|x| x.1)\n+    }\n+}"}, {"sha": "16251877bb10637faa7a993d5a012ea8f4e08ca4", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e4e26687731458b1a6ec1b04e9c0d514c23237d/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4e26687731458b1a6ec1b04e9c0d514c23237d/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=9e4e26687731458b1a6ec1b04e9c0d514c23237d", "patch": "@@ -40,6 +40,9 @@ pub use self::unindent_comments::UNINDENT_COMMENTS;\n mod propagate_doc_cfg;\n pub use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n \n+mod collect_intra_doc_links;\n+pub use self::collect_intra_doc_links::COLLECT_INTRA_DOC_LINKS;\n+\n /// Represents a single pass.\n #[derive(Copy, Clone)]\n pub enum Pass {\n@@ -128,12 +131,14 @@ pub const PASSES: &'static [Pass] = &[\n     STRIP_PRIVATE,\n     STRIP_PRIV_IMPORTS,\n     PROPAGATE_DOC_CFG,\n+    COLLECT_INTRA_DOC_LINKS,\n ];\n \n /// The list of passes run by default.\n pub const DEFAULT_PASSES: &'static [&'static str] = &[\n     \"strip-hidden\",\n     \"strip-private\",\n+    \"collect-intra-doc-links\",\n     \"collapse-docs\",\n     \"unindent-comments\",\n     \"propagate-doc-cfg\",\n@@ -142,6 +147,7 @@ pub const DEFAULT_PASSES: &'static [&'static str] = &[\n /// The list of default passes run with `--document-private-items` is passed to rustdoc.\n pub const DEFAULT_PRIVATE_PASSES: &'static [&'static str] = &[\n     \"strip-priv-imports\",\n+    \"collect-intra-doc-links\",\n     \"collapse-docs\",\n     \"unindent-comments\",\n     \"propagate-doc-cfg\","}]}