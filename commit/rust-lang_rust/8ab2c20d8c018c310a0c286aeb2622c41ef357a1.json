{"sha": "8ab2c20d8c018c310a0c286aeb2622c41ef357a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYjJjMjBkOGMwMThjMzEwYTBjMjg2YWViMjYyMmM0MWVmMzU3YTE=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-04-22T15:53:15Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-04-22T17:10:30Z"}, "message": "Only record the same impl once\n\nDue to inlining it is possible to visit the same module multiple times\nduring `<Cache as DocFolder>::fold_crate`, so we keep track of the\nmodules we've already visited.", "tree": {"sha": "45a3a2cfecca06483b2140a5ea1df3f81a3a3619", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45a3a2cfecca06483b2140a5ea1df3f81a3a3619"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ab2c20d8c018c310a0c286aeb2622c41ef357a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ab2c20d8c018c310a0c286aeb2622c41ef357a1", "html_url": "https://github.com/rust-lang/rust/commit/8ab2c20d8c018c310a0c286aeb2622c41ef357a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ab2c20d8c018c310a0c286aeb2622c41ef357a1/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "url": "https://api.github.com/repos/rust-lang/rust/commits/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672", "html_url": "https://github.com/rust-lang/rust/commit/a264f5b7e8df34c4bf7f10d0c6c7f9ab805ee672"}], "stats": {"total": 114, "additions": 87, "deletions": 27}, "files": [{"sha": "a930a0d083367d8a8a2982d334387748a6019fed", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8ab2c20d8c018c310a0c286aeb2622c41ef357a1/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/8ab2c20d8c018c310a0c286aeb2622c41ef357a1/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=8ab2c20d8c018c310a0c286aeb2622c41ef357a1", "patch": "@@ -342,9 +342,9 @@ def check_tree_text(tree, path, pat, regexp):\n     return ret\n \n \n-def check_tree_count(tree, path, count):\n+def get_tree_count(tree, path):\n     path = normalize_xpath(path)\n-    return len(tree.findall(path)) == count\n+    return len(tree.findall(path))\n \n def stderr(*args):\n     print(*args, file=sys.stderr)\n@@ -393,7 +393,10 @@ def check_command(c, cache):\n \n         elif c.cmd == 'count': # count test\n             if len(c.args) == 3: # @count <path> <pat> <count> = count test\n-                ret = check_tree_count(cache.get_tree(c.args[0]), c.args[1], int(c.args[2]))\n+                expected = int(c.args[2])\n+                found = get_tree_count(cache.get_tree(c.args[0]), c.args[1])\n+                cerr = \"Expected {} occurrences but found {}\".format(expected, found)\n+                ret = expected == found\n             else:\n                 raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n         elif c.cmd == 'valid-html':"}, {"sha": "824265bc3b303432c64b6c665464094d9d3d59dc", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8ab2c20d8c018c310a0c286aeb2622c41ef357a1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab2c20d8c018c310a0c286aeb2622c41ef357a1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8ab2c20d8c018c310a0c286aeb2622c41ef357a1", "patch": "@@ -258,6 +258,8 @@ pub struct Cache {\n     parent_stack: Vec<DefId>,\n     parent_is_trait_impl: bool,\n     search_index: Vec<IndexItem>,\n+    seen_modules: HashSet<DefId>,\n+    seen_mod: bool,\n     stripped_mod: bool,\n     deref_trait_did: Option<DefId>,\n \n@@ -520,6 +522,8 @@ pub fn run(mut krate: clean::Crate,\n         parent_is_trait_impl: false,\n         extern_locations: HashMap::new(),\n         primitive_locations: HashMap::new(),\n+        seen_modules: HashSet::new(),\n+        seen_mod: false,\n         stripped_mod: false,\n         access_levels: krate.access_levels.clone(),\n         orphan_methods: Vec::new(),\n@@ -976,13 +980,20 @@ impl DocFolder for Cache {\n         // we don't want it or its children in the search index.\n         let orig_stripped_mod = match item.inner {\n             clean::StrippedItem(box clean::ModuleItem(..)) => {\n-                let prev = self.stripped_mod;\n-                self.stripped_mod = true;\n-                prev\n+                mem::replace(&mut self.stripped_mod, true)\n             }\n             _ => self.stripped_mod,\n         };\n \n+        // Inlining can cause us to visit the same item multiple times.\n+        // (i.e. relevant for gathering impls and implementors)\n+        let orig_seen_mod = if item.is_mod() {\n+            let seen_this = self.seen_mod || !self.seen_modules.insert(item.def_id);\n+            mem::replace(&mut self.seen_mod, seen_this)\n+        } else {\n+            self.seen_mod\n+        };\n+\n         // Register any generics to their corresponding string. This is used\n         // when pretty-printing types\n         match item.inner {\n@@ -998,20 +1009,22 @@ impl DocFolder for Cache {\n             _ => {}\n         }\n \n-        // Propagate a trait methods' documentation to all implementors of the\n-        // trait\n-        if let clean::TraitItem(ref t) = item.inner {\n-            self.traits.insert(item.def_id, t.clone());\n-        }\n+        if !self.seen_mod {\n+            // Propagate a trait methods' documentation to all implementors of the\n+            // trait\n+            if let clean::TraitItem(ref t) = item.inner {\n+                self.traits.insert(item.def_id, t.clone());\n+            }\n \n-        // Collect all the implementors of traits.\n-        if let clean::ImplItem(ref i) = item.inner {\n-            if let Some(did) = i.trait_.def_id() {\n-                self.implementors.entry(did).or_insert(vec![]).push(Implementor {\n-                    def_id: item.def_id,\n-                    stability: item.stability.clone(),\n-                    impl_: i.clone(),\n-                });\n+            // Collect all the implementors of traits.\n+            if let clean::ImplItem(ref i) = item.inner {\n+                if let Some(did) = i.trait_.def_id() {\n+                    self.implementors.entry(did).or_insert(vec![]).push(Implementor {\n+                        def_id: item.def_id,\n+                        stability: item.stability.clone(),\n+                        impl_: i.clone(),\n+                    });\n+                }\n             }\n         }\n \n@@ -1183,7 +1196,6 @@ impl DocFolder for Cache {\n                     } => {\n                         Some(did)\n                     }\n-\n                     ref t => {\n                         t.primitive_type().and_then(|t| {\n                             self.primitive_locations.get(&t).map(|n| {\n@@ -1193,13 +1205,14 @@ impl DocFolder for Cache {\n                         })\n                     }\n                 };\n-\n-                if let Some(did) = did {\n-                    self.impls.entry(did).or_insert(vec![]).push(Impl {\n-                        impl_: i,\n-                        dox: attrs.value(\"doc\").map(|s|s.to_owned()),\n-                        stability: item.stability.clone(),\n-                    });\n+                if !self.seen_mod {\n+                    if let Some(did) = did {\n+                        self.impls.entry(did).or_insert(vec![]).push(Impl {\n+                            impl_: i,\n+                            dox: attrs.value(\"doc\").map(|s|s.to_owned()),\n+                            stability: item.stability.clone(),\n+                        });\n+                    }\n                 }\n                 None\n             } else {\n@@ -1209,6 +1222,7 @@ impl DocFolder for Cache {\n \n         if pushed { self.stack.pop().unwrap(); }\n         if parent_pushed { self.parent_stack.pop().unwrap(); }\n+        self.seen_mod = orig_seen_mod;\n         self.stripped_mod = orig_stripped_mod;\n         self.parent_is_trait_impl = orig_parent_is_trait_impl;\n         return ret;"}, {"sha": "72e54fe733cdb8f693b5a7d9719bdba5511b165f", "filename": "src/test/rustdoc/duplicate_impls/impls.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8ab2c20d8c018c310a0c286aeb2622c41ef357a1/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab2c20d8c018c310a0c286aeb2622c41ef357a1/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fimpls.rs?ref=8ab2c20d8c018c310a0c286aeb2622c41ef357a1", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Foo;\n+\n+// just so that `Foo` doesn't show up on `Bar`s sidebar\n+pub mod bar {\n+    pub trait Bar {}\n+}\n+\n+impl Foo {\n+    pub fn new() -> Foo { Foo }\n+}\n+\n+impl bar::Bar for Foo {}"}, {"sha": "df6ebcae10756851ce772464f6b94216dee0c7a5", "filename": "src/test/rustdoc/duplicate_impls/issue-33054.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8ab2c20d8c018c310a0c286aeb2622c41ef357a1/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fissue-33054.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab2c20d8c018c310a0c286aeb2622c41ef357a1/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fissue-33054.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fissue-33054.rs?ref=8ab2c20d8c018c310a0c286aeb2622c41ef357a1", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// @has issue_33054/impls/struct.Foo.html\n+// @has - '//code' 'impl Foo'\n+// @has - '//code' 'impl Bar for Foo'\n+// @count - '//*[@class=\"impl\"]' 2\n+// @has issue_33054/impls/bar/trait.Bar.html\n+// @has - '//code' 'impl Bar for Foo'\n+// @count - '//*[@class=\"struct\"]' 1\n+pub mod impls;\n+\n+#[doc(inline)]\n+pub use impls as impls2;"}]}