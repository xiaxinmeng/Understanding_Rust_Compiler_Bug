{"sha": "e158dc72465d79084184b34054239544f5bab095", "node_id": "C_kwDOAAsO6NoAKGUxNThkYzcyNDY1ZDc5MDg0MTg0YjM0MDU0MjM5NTQ0ZjViYWIwOTU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-09T14:10:26Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-09T14:10:26Z"}, "message": "Remove unnecessary special local handling in search", "tree": {"sha": "2a4de24c02f16bcd0d9413936726022f497d0ce5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a4de24c02f16bcd0d9413936726022f497d0ce5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e158dc72465d79084184b34054239544f5bab095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e158dc72465d79084184b34054239544f5bab095", "html_url": "https://github.com/rust-lang/rust/commit/e158dc72465d79084184b34054239544f5bab095", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e158dc72465d79084184b34054239544f5bab095/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38e9a110d4f136c22cb4eed9c3581d7992eade56", "url": "https://api.github.com/repos/rust-lang/rust/commits/38e9a110d4f136c22cb4eed9c3581d7992eade56", "html_url": "https://github.com/rust-lang/rust/commit/38e9a110d4f136c22cb4eed9c3581d7992eade56"}], "stats": {"total": 43, "additions": 5, "deletions": 38}, "files": [{"sha": "77d694b57f82d09bc2c95820946fabb81e92ad74", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 5, "deletions": 38, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e158dc72465d79084184b34054239544f5bab095/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e158dc72465d79084184b34054239544f5bab095/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=e158dc72465d79084184b34054239544f5bab095", "patch": "@@ -319,10 +319,6 @@ impl Definition {\n             sema,\n             scope: None,\n             include_self_kw_refs: None,\n-            local_repr: match self {\n-                Definition::Local(local) => Some(local),\n-                _ => None,\n-            },\n             search_self_mod: false,\n         }\n     }\n@@ -337,9 +333,6 @@ pub struct FindUsages<'a> {\n     assoc_item_container: Option<hir::AssocItemContainer>,\n     /// whether to search for the `Self` type of the definition\n     include_self_kw_refs: Option<hir::Type>,\n-    /// the local representative for the local definition we are searching for\n-    /// (this is required for finding all local declarations in a or-pattern)\n-    local_repr: Option<hir::Local>,\n     /// whether to search for the `self` module\n     search_self_mod: bool,\n }\n@@ -644,19 +637,6 @@ impl<'a> FindUsages<'a> {\n         sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n     ) -> bool {\n         match NameRefClass::classify(self.sema, name_ref) {\n-            Some(NameRefClass::Definition(def @ Definition::Local(local)))\n-                if matches!(\n-                    self.local_repr, Some(repr) if repr == local\n-                ) =>\n-            {\n-                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n-                let reference = FileReference {\n-                    range,\n-                    name: ast::NameLike::NameRef(name_ref.clone()),\n-                    category: ReferenceCategory::new(&def, name_ref),\n-                };\n-                sink(file_id, reference)\n-            }\n             Some(NameRefClass::Definition(def))\n                 if self.def == def\n                     // is our def a trait assoc item? then we want to find all assoc items from trait impls of our trait\n@@ -701,14 +681,16 @@ impl<'a> FindUsages<'a> {\n                 }\n             }\n             Some(NameRefClass::FieldShorthand { local_ref: local, field_ref: field }) => {\n-                let field = Definition::Field(field);\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n+\n+                let field = Definition::Field(field);\n+                let local = Definition::Local(local);\n                 let access = match self.def {\n                     Definition::Field(_) if field == self.def => {\n                         ReferenceCategory::new(&field, name_ref)\n                     }\n-                    Definition::Local(_) if matches!(self.local_repr, Some(repr) if repr == local) => {\n-                        ReferenceCategory::new(&Definition::Local(local), name_ref)\n+                    Definition::Local(_) if local == self.def => {\n+                        ReferenceCategory::new(&local, name_ref)\n                     }\n                     _ => return false,\n                 };\n@@ -752,21 +734,6 @@ impl<'a> FindUsages<'a> {\n                 };\n                 sink(file_id, reference)\n             }\n-            Some(NameClass::Definition(def @ Definition::Local(local))) if def != self.def => {\n-                if matches!(\n-                    self.local_repr,\n-                    Some(repr) if local == repr\n-                ) {\n-                    let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n-                    let reference = FileReference {\n-                        range,\n-                        name: ast::NameLike::Name(name.clone()),\n-                        category: None,\n-                    };\n-                    return sink(file_id, reference);\n-                }\n-                false\n-            }\n             Some(NameClass::Definition(def)) if def != self.def => {\n                 match (&self.assoc_item_container, self.def) {\n                     // for type aliases we always want to reference the trait def and all the trait impl counterparts"}]}