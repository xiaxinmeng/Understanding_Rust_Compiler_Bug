{"sha": "5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhZDJhNzgyNWJkOTgyMWI4ZWY1NTQwNDZjOGQ4MWViOTRhYjdkZmU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-01-01T02:09:50Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-01-11T14:40:23Z"}, "message": "Removed obsolete 'e' prefix on ty_evec and ty_estr.", "tree": {"sha": "e32969e0b4ada5b6696348cd1bc5bcadbfeea177", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e32969e0b4ada5b6696348cd1bc5bcadbfeea177"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "html_url": "https://github.com/rust-lang/rust/commit/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e19b1b129b266900f832a50f0ea50342471e414c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e19b1b129b266900f832a50f0ea50342471e414c", "html_url": "https://github.com/rust-lang/rust/commit/e19b1b129b266900f832a50f0ea50342471e414c"}], "stats": {"total": 469, "additions": 234, "deletions": 235}, "files": [{"sha": "1057340cf58511519d1914420035afeec2ce33e2", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -354,11 +354,11 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       'V' => {\n         let mt = parse_mt(st, |x,y| conv(x,y));\n         let v = parse_vstore(st, |x,y| conv(x,y));\n-        return ty::mk_evec(st.tcx, mt, v);\n+        return ty::mk_vec(st.tcx, mt, v);\n       }\n       'v' => {\n         let v = parse_vstore(st, |x,y| conv(x,y));\n-        return ty::mk_estr(st.tcx, v);\n+        return ty::mk_str(st.tcx, v);\n       }\n       'T' => {\n         assert_eq!(next(st), '[');"}, {"sha": "dc61c6d439122b7b3ce1e7632cdeed5da0abf0ae", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -299,12 +299,12 @@ fn enc_sty(w: &mut MemWriter, cx: @ctxt, st: &ty::sty) {\n             enc_region(w, cx, r);\n             enc_mt(w, cx, mt);\n         }\n-        ty::ty_evec(mt, v) => {\n+        ty::ty_vec(mt, v) => {\n             mywrite!(w, \"V\");\n             enc_mt(w, cx, mt);\n             enc_vstore(w, cx, v);\n         }\n-        ty::ty_estr(v) => {\n+        ty::ty_str(v) => {\n             mywrite!(w, \"v\");\n             enc_vstore(w, cx, v);\n         }"}, {"sha": "b1337fca0c85da8f00849dfd05d0c5cb87d7e362", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -808,7 +808,7 @@ impl<'a> GatherLoanCtxt<'a> {\n          */\n \n         match ty::get(slice_ty).sty {\n-            ty::ty_evec(slice_mt, ty::vstore_slice(slice_r)) => {\n+            ty::ty_vec(slice_mt, ty::vstore_slice(slice_r)) => {\n                 (slice_mt.mutbl, slice_r)\n             }\n "}, {"sha": "79cb1c779a02e64a264a75975e38b22804559fb7", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -195,7 +195,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n                         }\n                     }\n                 }\n-                ty::ty_unboxed_vec(..) | ty::ty_evec(..) => {\n+                ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n                     match *ctor {\n                         vec(n) => Some(format!(\"vectors of length {}\", n).to_managed()),\n                         _ => None\n@@ -274,10 +274,10 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n                 }\n                 not_useful\n               }\n-              ty::ty_evec(_, ty::vstore_fixed(n)) => {\n+              ty::ty_vec(_, ty::vstore_fixed(n)) => {\n                 is_useful_specialized(cx, m, v, vec(n), n, left_ty)\n               }\n-              ty::ty_unboxed_vec(..) | ty::ty_evec(..) => {\n+              ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n                 let max_len = m.rev_iter().fold(0, |max_len, r| {\n                   match r[0].node {\n                     PatVec(ref before, _, ref after) => {\n@@ -437,7 +437,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n         else if true_found { Some(val(const_bool(false))) }\n         else { Some(val(const_bool(true))) }\n       }\n-      ty::ty_evec(_, ty::vstore_fixed(n)) => {\n+      ty::ty_vec(_, ty::vstore_fixed(n)) => {\n         let mut missing = true;\n         let mut wrong = false;\n         for r in m.iter() {\n@@ -460,7 +460,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n           _         => None\n         }\n       }\n-      ty::ty_unboxed_vec(..) | ty::ty_evec(..) => {\n+      ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n \n         // Find the lengths and slices of all vector patterns.\n         let mut vec_pat_lens = m.iter().filter_map(|r| {\n@@ -525,7 +525,7 @@ fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n         }\n       }\n       ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n-      ty::ty_unboxed_vec(..) | ty::ty_evec(..) => {\n+      ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n         match *ctor {\n           vec(n) => n,\n           _ => 0u"}, {"sha": "e291d2595a0b2cde584098833cbdeb12605d5463", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -71,7 +71,7 @@ impl EffectCheckVisitor {\n         debug!(\"effect: checking index with base type {}\",\n                 ppaux::ty_to_str(self.tcx, base_type));\n         match ty::get(base_type).sty {\n-            ty::ty_estr(..) => {\n+            ty::ty_str(..) => {\n                 self.tcx.sess.span_err(e.span,\n                     \"modification of string types is not allowed\");\n             }"}, {"sha": "55cb9f87bcd0d446ffc61b8d9383bc8ed43e1948", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -819,13 +819,13 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n         let mut n_uniq = 0;\n         ty::fold_ty(cx.tcx, ty, |t| {\n             match ty::get(t).sty {\n-                ty::ty_box(_) | ty::ty_estr(ty::vstore_box) |\n-                ty::ty_evec(_, ty::vstore_box) |\n+                ty::ty_box(_) | ty::ty_str(ty::vstore_box) |\n+                ty::ty_vec(_, ty::vstore_box) |\n                 ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n                     n_box += 1;\n                 }\n-                ty::ty_uniq(_) | ty::ty_estr(ty::vstore_uniq) |\n-                ty::ty_evec(_, ty::vstore_uniq) |\n+                ty::ty_uniq(_) | ty::ty_str(ty::vstore_uniq) |\n+                ty::ty_vec(_, ty::vstore_uniq) |\n                 ty::ty_trait(_, _, ty::UniqTraitStore, _, _) => {\n                     n_uniq += 1;\n                 }"}, {"sha": "a00b01d54ce790d3c52b890983c5a8ca757ec324", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -157,31 +157,31 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     match ty::get(t).sty {\n         ty::ty_uniq(_) |\n         ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n-        ty::ty_evec(_, ty::vstore_uniq) |\n-        ty::ty_estr(ty::vstore_uniq) |\n+        ty::ty_vec(_, ty::vstore_uniq) |\n+        ty::ty_str(ty::vstore_uniq) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, ..}) => {\n             Some(deref_ptr(uniq_ptr))\n         }\n \n         ty::ty_rptr(r, mt) |\n-        ty::ty_evec(mt, ty::vstore_slice(r)) => {\n+        ty::ty_vec(mt, ty::vstore_slice(r)) => {\n             Some(deref_ptr(region_ptr(mt.mutbl, r)))\n         }\n \n         ty::ty_trait(_, _, ty::RegionTraitStore(r), m, _) => {\n             Some(deref_ptr(region_ptr(m, r)))\n         }\n \n-        ty::ty_estr(ty::vstore_slice(r)) |\n+        ty::ty_str(ty::vstore_slice(r)) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n                                       region: r, ..}) => {\n             Some(deref_ptr(region_ptr(ast::MutImmutable, r)))\n         }\n \n         ty::ty_box(_) |\n-        ty::ty_evec(_, ty::vstore_box) |\n+        ty::ty_vec(_, ty::vstore_box) |\n         ty::ty_trait(_, _, ty::BoxTraitStore, _, _) |\n-        ty::ty_estr(ty::vstore_box) => {\n+        ty::ty_str(ty::vstore_box) => {\n             Some(deref_ptr(gc_ptr))\n         }\n \n@@ -194,8 +194,8 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             Some(deref_interior(InteriorField(PositionalField(0))))\n         }\n \n-        ty::ty_evec(_, ty::vstore_fixed(_)) |\n-        ty::ty_estr(ty::vstore_fixed(_)) => {\n+        ty::ty_vec(_, ty::vstore_fixed(_)) |\n+        ty::ty_str(ty::vstore_fixed(_)) => {\n             Some(deref_interior(InteriorElement(element_kind(t))))\n         }\n \n@@ -1247,8 +1247,8 @@ impl Repr for InteriorKind {\n \n fn element_kind(t: ty::t) -> ElementKind {\n     match ty::get(t).sty {\n-        ty::ty_evec(..) => VecElement,\n-        ty::ty_estr(..) => StrElement,\n+        ty::ty_vec(..) => VecElement,\n+        ty::ty_str(..) => StrElement,\n         _ => OtherElement\n     }\n }"}, {"sha": "07f8bba4464f075a48f0c8d85973074c20384b8b", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -1078,7 +1078,7 @@ fn extract_vec_elems<'a>(\n         let slice_begin = tvec::pointer_add_byte(bcx, base, slice_byte_offset);\n         let slice_len_offset = C_uint(bcx.ccx(), elem_count - 1u);\n         let slice_len = Sub(bcx, len, slice_len_offset);\n-        let slice_ty = ty::mk_evec(bcx.tcx(),\n+        let slice_ty = ty::mk_vec(bcx.tcx(),\n             ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable},\n             ty::vstore_slice(ty::ReStatic)\n         );\n@@ -1312,7 +1312,7 @@ fn compare_values<'a>(\n     }\n \n     match ty::get(rhs_t).sty {\n-        ty::ty_estr(ty::vstore_uniq) => {\n+        ty::ty_str(ty::vstore_uniq) => {\n             let scratch_lhs = alloca(cx, val_ty(lhs), \"__lhs\");\n             Store(cx, lhs, scratch_lhs);\n             let scratch_rhs = alloca(cx, val_ty(rhs), \"__rhs\");\n@@ -1326,7 +1326,7 @@ fn compare_values<'a>(\n                 val: bool_to_i1(result.bcx, result.val)\n             }\n         }\n-        ty::ty_estr(_) => {\n+        ty::ty_str(_) => {\n             let did = langcall(cx, None,\n                                format!(\"comparison of `{}`\", cx.ty_to_str(rhs_t)),\n                                StrEqFnLangItem);"}, {"sha": "2b39cbf7477b2b993104db04d113ca0683c50b72", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -241,7 +241,7 @@ fn decl_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t, name: &str)\n         }\n         // `~` pointer return values never alias because ownership is transferred\n         ty::ty_uniq(..) |\n-        ty::ty_evec(_, ty::vstore_uniq) => {\n+        ty::ty_vec(_, ty::vstore_uniq) => {\n             unsafe {\n                 llvm::LLVMAddReturnAttribute(llfn, lib::llvm::NoAliasAttribute as c_uint);\n             }\n@@ -257,7 +257,7 @@ fn decl_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t, name: &str)\n         match ty::get(arg_ty).sty {\n             // `~` pointer parameters never alias because ownership is transferred\n             ty::ty_uniq(..) |\n-            ty::ty_evec(_, ty::vstore_uniq) |\n+            ty::ty_vec(_, ty::vstore_uniq) |\n             ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, ..}) => {\n                 unsafe {\n                     llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n@@ -758,8 +758,8 @@ pub fn iter_structural_ty<'r,\n               }\n           })\n       }\n-      ty::ty_estr(ty::vstore_fixed(_)) |\n-      ty::ty_evec(_, ty::vstore_fixed(_)) => {\n+      ty::ty_str(ty::vstore_fixed(_)) |\n+      ty::ty_vec(_, ty::vstore_fixed(_)) => {\n         let (base, len) = tvec::get_base_and_byte_len(cx, av, t);\n         cx = tvec::iter_vec_raw(cx, base, t, len, f);\n       }\n@@ -3120,12 +3120,12 @@ pub fn create_module_map(ccx: &CrateContext) -> (ValueRef, uint) {\n     };\n \n     for key in keys.iter() {\n-            let llestrval = C_estr_slice(ccx, *key);\n+            let llstrval = C_str_slice(ccx, *key);\n             let module_data = ccx.module_data.borrow();\n             let val = *module_data.get().find_equiv(key).unwrap();\n             let v_ptr = p2i(ccx, val);\n             let elt = C_struct([\n-                llestrval,\n+                llstrval,\n                 v_ptr\n             ], false);\n             elts.push(elt);"}, {"sha": "6ef90c57b27e32a4eae8d95c5b3269238b976856", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -704,7 +704,7 @@ pub fn trans_call_inner<'a>(\n             match ty::get(ret_ty).sty {\n                 // `~` pointer return values never alias because ownership is transferred\n                 ty::ty_uniq(..) |\n-                ty::ty_evec(_, ty::vstore_uniq) => {\n+                ty::ty_vec(_, ty::vstore_uniq) => {\n                     attrs.push((0, NoAliasAttribute));\n                 }\n                 _ => ()"}, {"sha": "8636a87819c3284bd5d4013a9af656c57dd49fc7", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -906,7 +906,7 @@ pub fn C_cstr(cx: &CrateContext, s: @str) -> ValueRef {\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_estr_slice(cx: &CrateContext, s: @str) -> ValueRef {\n+pub fn C_str_slice(cx: &CrateContext, s: @str) -> ValueRef {\n     unsafe {\n         let len = s.len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), Type::i8p().to_ref());\n@@ -1045,8 +1045,8 @@ pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n         ty::ty_float(_) => MonoFloat,\n         ty::ty_rptr(..) | ty::ty_uniq(..) |\n         ty::ty_box(..) | ty::ty_opaque_box(..) |\n-        ty::ty_estr(ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_uniq) |\n-        ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) |\n+        ty::ty_str(ty::vstore_uniq) | ty::ty_vec(_, ty::vstore_uniq) |\n+        ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) |\n         ty::ty_bare_fn(..) => MonoNonNull,\n         // Is that everything?  Would closures or slices qualify?\n         _ => MonoBits"}, {"sha": "1f8ac5b5aeb6d5bcfb09c0e0ed0ae413b7ba1427", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -71,7 +71,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n         }\n         ast::LitBool(b) => C_bool(b),\n         ast::LitNil => C_nil(),\n-        ast::LitStr(s, _) => C_estr_slice(cx, s),\n+        ast::LitStr(s, _) => C_str_slice(cx, s),\n         ast::LitBinary(data) => C_binary_slice(cx, data),\n     }\n }\n@@ -241,7 +241,7 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n                             assert_eq!(abi::slice_elt_len, 1);\n \n                             match ty::get(ty).sty {\n-                                ty::ty_evec(_, ty::vstore_fixed(len)) => {\n+                                ty::ty_vec(_, ty::vstore_fixed(len)) => {\n                                     llconst = C_struct([llptr, C_uint(cx, len)], false);\n                                 }\n                                 _ => {}\n@@ -419,7 +419,7 @@ fn const_expr_unadjusted(cx: @CrateContext,\n                                         \"index is not an integer-constant expression\")\n               };\n               let (arr, len) = match ty::get(bt).sty {\n-                  ty::ty_evec(_, vstore) | ty::ty_estr(vstore) =>\n+                  ty::ty_vec(_, vstore) | ty::ty_str(vstore) =>\n                       match vstore {\n                       ty::vstore_fixed(u) =>\n                           (bv, C_uint(cx, u)),\n@@ -437,7 +437,7 @@ fn const_expr_unadjusted(cx: @CrateContext,\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n               let len = match ty::get(bt).sty {\n-                  ty::ty_estr(..) => {assert!(len > 0); len - 1},\n+                  ty::ty_str(..) => {assert!(len > 0); len - 1},\n                   _ => len\n               };\n               if iv >= len {"}, {"sha": "4f94668ebe3bf37609ecb4e9995ad019630b87d3", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -571,7 +571,7 @@ impl Datum {\n         let (content_ty, header) = match ty::get(self.ty).sty {\n             ty::ty_box(typ) => (typ, true),\n             ty::ty_uniq(mt) => (mt.ty, false),\n-            ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n+            ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) => {\n                 let unit_ty = ty::sequence_element_type(bcx.tcx(), self.ty);\n                 let unboxed_vec_ty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n                 (unboxed_vec_ty, true)"}, {"sha": "88d41f9b1af36561076f7f69c7b8cac3f8484115", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -2115,7 +2115,7 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_float(_) => {\n             basic_type_metadata(cx, t)\n         },\n-        ty::ty_estr(ref vstore) => {\n+        ty::ty_str(ref vstore) => {\n             let i8_t = ty::mk_i8();\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n@@ -2140,7 +2140,7 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_box(typ) => {\n             create_pointer_to_box_metadata(cx, t, typ)\n         },\n-        ty::ty_evec(ref mt, ref vstore) => {\n+        ty::ty_vec(ref mt, ref vstore) => {\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n                     fixed_vec_metadata(cx, mt.ty, len, usage_site_span)"}, {"sha": "689c1ab1e057b450c6326942f310a1c1f87c22f0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -287,9 +287,9 @@ pub fn trans_to_datum<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n \n         // this type may have a different region/mutability than the\n         // real one, but it will have the same runtime representation\n-        let slice_ty = ty::mk_evec(tcx,\n-                                   ty::mt { ty: unit_ty, mutbl: ast::MutImmutable },\n-                                   ty::vstore_slice(ty::ReStatic));\n+        let slice_ty = ty::mk_vec(tcx,\n+                                  ty::mt { ty: unit_ty, mutbl: ast::MutImmutable },\n+                                  ty::vstore_slice(ty::ReStatic));\n \n         let scratch = scratch_datum(bcx, slice_ty, \"__adjust\", false);\n "}, {"sha": "5a7a2ba7ffdae70378c4d5708243ba479d32a92e", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -101,11 +101,11 @@ pub fn free_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     let _icx = push_ctxt(\"free_ty_immediate\");\n     match ty::get(t).sty {\n       ty::ty_uniq(_) |\n-      ty::ty_evec(_, ty::vstore_uniq) |\n-      ty::ty_estr(ty::vstore_uniq) |\n+      ty::ty_vec(_, ty::vstore_uniq) |\n+      ty::ty_str(ty::vstore_uniq) |\n       ty::ty_box(_) | ty::ty_opaque_box |\n-      ty::ty_evec(_, ty::vstore_box) |\n-      ty::ty_estr(ty::vstore_box) |\n+      ty::ty_vec(_, ty::vstore_box) |\n+      ty::ty_str(ty::vstore_box) |\n       ty::ty_opaque_closure_ptr(_) => {\n         let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n         Store(bcx, v, vp);\n@@ -135,8 +135,8 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n         match ty::get(t).sty {\n           ty::ty_unboxed_vec(..) |\n               ty::ty_uniq(..) |\n-              ty::ty_estr(ty::vstore_uniq) |\n-              ty::ty_evec(_, ty::vstore_uniq) => { return ty::mk_u32(); }\n+              ty::ty_str(ty::vstore_uniq) |\n+              ty::ty_vec(_, ty::vstore_uniq) => { return ty::mk_u32(); }\n           _ => ()\n         }\n     }\n@@ -153,8 +153,8 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n           ty::ty_box(..) |\n           ty::ty_opaque_box |\n           ty::ty_uniq(..) |\n-          ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n-          ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) |\n+          ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) |\n+          ty::ty_vec(_, ty::vstore_box) | ty::ty_str(ty::vstore_box) |\n           ty::ty_opaque_closure_ptr(..) => (),\n           _ => { return ty::mk_u32(); }\n         }\n@@ -167,12 +167,12 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n           if ! ty::type_needs_drop(tcx, typ) =>\n           return ty::mk_imm_box(tcx, ty::mk_u32()),\n \n-          ty::ty_evec(mt, ty::vstore_box)\n+          ty::ty_vec(mt, ty::vstore_box)\n           if ! ty::type_needs_drop(tcx, mt.ty) =>\n           return ty::mk_imm_box(tcx, ty::mk_u32()),\n \n           ty::ty_uniq(mt) |\n-          ty::ty_evec(mt, ty::vstore_uniq)\n+          ty::ty_vec(mt, ty::vstore_uniq)\n           if ! ty::type_needs_drop(tcx, mt.ty) =>\n           return ty::mk_imm_uniq(tcx, ty::mk_u32()),\n \n@@ -390,8 +390,8 @@ pub fn make_free_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n       ty::ty_uniq(..) => {\n         uniq::make_free_glue(bcx, v, t)\n       }\n-      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n-      ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n+      ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) |\n+      ty::ty_vec(_, ty::vstore_box) | ty::ty_str(ty::vstore_box) => {\n         make_free_glue(bcx, v, tvec::expand_boxed_vec_ty(bcx.tcx(), t))\n       }\n       ty::ty_closure(_) => {\n@@ -470,11 +470,11 @@ pub fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t)\n     let ccx = bcx.ccx();\n     match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n-      ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n+      ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) => {\n         decr_refcnt_maybe_free(bcx, Load(bcx, v0), Some(v0), t)\n       }\n       ty::ty_uniq(_) |\n-      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n+      ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) => {\n         free_ty(bcx, v0, t)\n       }\n       ty::ty_unboxed_vec(_) => {\n@@ -572,11 +572,11 @@ pub fn make_take_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     // NB: v is a *pointer* to type t here, not a direct value.\n     match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n-      ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n+      ty::ty_vec(_, ty::vstore_box) | ty::ty_str(ty::vstore_box) => {\n         incr_refcnt_of_boxed(bcx, Load(bcx, v)); bcx\n       }\n-      ty::ty_evec(_, ty::vstore_slice(_))\n-      | ty::ty_estr(ty::vstore_slice(_)) => {\n+      ty::ty_vec(_, ty::vstore_slice(_))\n+      | ty::ty_str(ty::vstore_slice(_)) => {\n         bcx\n       }\n       ty::ty_closure(_) => bcx,\n@@ -654,7 +654,7 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n         }\n     });\n \n-    let ty_name = C_estr_slice(ccx, ppaux::ty_to_str(ccx.tcx, t).to_managed());\n+    let ty_name = C_str_slice(ccx, ppaux::ty_to_str(ccx.tcx, t).to_managed());\n \n     let inf = @tydesc_info {\n         ty: t,"}, {"sha": "849fc18ac01945cffeb6647c6bfd11029a65aac5", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -60,7 +60,7 @@ impl<'a> Reflector<'a> {\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;\n         let str_vstore = ty::vstore_slice(ty::ReStatic);\n-        let str_ty = ty::mk_estr(bcx.tcx(), str_vstore);\n+        let str_ty = ty::mk_str(bcx.tcx(), str_vstore);\n         let scratch = scratch_datum(bcx, str_ty, \"\", false);\n         let len = C_uint(bcx.ccx(), s.len());\n         let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p());\n@@ -176,11 +176,11 @@ impl<'a> Reflector<'a> {\n               self.visit(\"vec\", values)\n           }\n \n-          ty::ty_estr(vst) => {\n+          ty::ty_str(vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n               self.visit(~\"estr_\" + name, extra)\n           }\n-          ty::ty_evec(ref mt, vst) => {\n+          ty::ty_vec(ref mt, vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n               let extra = extra + self.c_mt(mt);\n               if \"uniq\" == name && ty::type_contents(bcx.tcx(), t).owns_managed() {"}, {"sha": "e8d4381e9f7991b98f1a9c4cdf9d381a1f66a8be", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -40,10 +40,10 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let unit_ty = ty::sequence_element_type(tcx, t);\n     let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n     match ty::get(t).sty {\n-      ty::ty_estr(ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_uniq) => {\n+      ty::ty_str(ty::vstore_uniq) | ty::ty_vec(_, ty::vstore_uniq) => {\n         ty::mk_imm_uniq(tcx, unboxed_vec_ty)\n       }\n-      ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n+      ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) => {\n         ty::mk_imm_box(tcx, unboxed_vec_ty)\n       }\n       _ => tcx.sess.bug(\"non boxed-vec type \\\n@@ -239,9 +239,9 @@ pub fn trans_slice_vstore<'a>(\n     let llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n \n     // Arrange for the backing array to be cleaned up.\n-    let fixed_ty = ty::mk_evec(bcx.tcx(),\n-                               ty::mt {ty: vt.unit_ty, mutbl: ast::MutMutable},\n-                               ty::vstore_fixed(count));\n+    let fixed_ty = ty::mk_vec(bcx.tcx(),\n+                              ty::mt {ty: vt.unit_ty, mutbl: ast::MutMutable},\n+                              ty::vstore_fixed(count));\n     let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty).ptr_to();\n     let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);\n     add_clean(bcx, llfixed_casted, fixed_ty);\n@@ -323,7 +323,7 @@ pub fn trans_uniq_or_managed_vstore<'a>(\n                     let llptrval = C_cstr(bcx.ccx(), s);\n                     let llptrval = PointerCast(bcx, llptrval, Type::i8p());\n                     let llsizeval = C_uint(bcx.ccx(), s.len());\n-                    let typ = ty::mk_estr(bcx.tcx(), ty::vstore_uniq);\n+                    let typ = ty::mk_str(bcx.tcx(), ty::vstore_uniq);\n                     let lldestval = scratch_datum(bcx, typ, \"\", false);\n                     let alloc_fn = langcall(bcx, Some(span), \"\",\n                                             StrDupUniqFnLangItem);\n@@ -449,7 +449,7 @@ pub fn write_content<'a>(\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(content_expr.span,\n-                                    \"Unexpected evec content\");\n+                                    \"Unexpected vec content\");\n         }\n     }\n }\n@@ -485,7 +485,7 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n             ty::eval_repeat_count(&bcx.tcx(), count_expr)\n         }\n         _ => bcx.tcx().sess.span_bug(content_expr.span,\n-                                     \"Unexpected evec content\")\n+                                     \"Unexpected vec content\")\n     }\n }\n \n@@ -503,7 +503,7 @@ pub fn get_base_and_byte_len(bcx: &Block, llval: ValueRef, vec_ty: ty::t)\n     let vt = vec_types(bcx, vec_ty);\n \n     let vstore = match ty::get(vt.vec_ty).sty {\n-      ty::ty_estr(vst) | ty::ty_evec(_, vst) => vst,\n+      ty::ty_str(vst) | ty::ty_vec(_, vst) => vst,\n       _ => ty::vstore_uniq\n     };\n \n@@ -540,7 +540,7 @@ pub fn get_base_and_len(bcx: &Block, llval: ValueRef, vec_ty: ty::t)\n     let vt = vec_types(bcx, vec_ty);\n \n     let vstore = match ty::get(vt.vec_ty).sty {\n-      ty::ty_estr(vst) | ty::ty_evec(_, vst) => vst,\n+      ty::ty_str(vst) | ty::ty_vec(_, vst) => vst,\n       _ => ty::vstore_uniq\n     };\n "}, {"sha": "8ac35c9e04b307154e0fb41fb40bb4994de2f80c", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -117,10 +117,10 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n         ty::ty_float(t) => Type::float_from_ty(t),\n \n-        ty::ty_estr(ty::vstore_uniq) |\n-        ty::ty_estr(ty::vstore_box) |\n-        ty::ty_evec(_, ty::vstore_uniq) |\n-        ty::ty_evec(_, ty::vstore_box) |\n+        ty::ty_str(ty::vstore_uniq) |\n+        ty::ty_str(ty::vstore_box) |\n+        ty::ty_vec(_, ty::vstore_uniq) |\n+        ty::ty_vec(_, ty::vstore_box) |\n         ty::ty_box(..) |\n         ty::ty_opaque_box |\n         ty::ty_uniq(..) |\n@@ -129,17 +129,17 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_type |\n         ty::ty_opaque_closure_ptr(..) => Type::i8p(),\n \n-        ty::ty_estr(ty::vstore_slice(..)) |\n-        ty::ty_evec(_, ty::vstore_slice(..)) => {\n+        ty::ty_str(ty::vstore_slice(..)) |\n+        ty::ty_vec(_, ty::vstore_slice(..)) => {\n             Type::struct_([Type::i8p(), Type::i8p()], false)\n         }\n \n         ty::ty_bare_fn(..) => Type::i8p(),\n         ty::ty_closure(..) => Type::struct_([Type::i8p(), Type::i8p()], false),\n         ty::ty_trait(_, _, store, _, _) => Type::opaque_trait(cx, store),\n \n-        ty::ty_estr(ty::vstore_fixed(size)) => Type::array(&Type::i8(), size as u64),\n-        ty::ty_evec(mt, ty::vstore_fixed(size)) => {\n+        ty::ty_str(ty::vstore_fixed(size)) => Type::array(&Type::i8(), size as u64),\n+        ty::ty_vec(mt, ty::vstore_fixed(size)) => {\n             Type::array(&sizing_type_of(cx, mt.ty), size as u64)\n         }\n \n@@ -214,7 +214,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_int(t) => Type::int_from_ty(cx, t),\n       ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n       ty::ty_float(t) => Type::float_from_ty(t),\n-      ty::ty_estr(ty::vstore_uniq) => {\n+      ty::ty_str(ty::vstore_uniq) => {\n         Type::vec(cx.sess.targ_cfg.arch, &Type::i8()).ptr_to()\n       }\n       ty::ty_enum(did, ref substs) => {\n@@ -226,12 +226,12 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         let name = llvm_type_name(cx, an_enum, did, substs.tps);\n         adt::incomplete_type_of(cx, repr, name)\n       }\n-      ty::ty_estr(ty::vstore_box) => {\n+      ty::ty_str(ty::vstore_box) => {\n         Type::smart_ptr(cx,\n                         &Type::vec(cx.sess.targ_cfg.arch,\n                                    &Type::i8())).ptr_to()\n       }\n-      ty::ty_evec(ref mt, ty::vstore_box) => {\n+      ty::ty_vec(ref mt, ty::vstore_box) => {\n           let e_ty = type_of(cx, mt.ty);\n           let v_ty = Type::vec(cx.sess.targ_cfg.arch, &e_ty);\n           Type::smart_ptr(cx, &v_ty).ptr_to()\n@@ -249,7 +249,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n               ty.ptr_to()\n           }\n       }\n-      ty::ty_evec(ref mt, ty::vstore_uniq) => {\n+      ty::ty_vec(ref mt, ty::vstore_uniq) => {\n           let ty = type_of(cx, mt.ty);\n           let ty = Type::vec(cx.sess.targ_cfg.arch, &ty);\n           if ty::type_contents(cx.tcx, mt.ty).owns_managed() {\n@@ -265,22 +265,22 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_ptr(ref mt) => type_of(cx, mt.ty).ptr_to(),\n       ty::ty_rptr(_, ref mt) => type_of(cx, mt.ty).ptr_to(),\n \n-      ty::ty_evec(ref mt, ty::vstore_slice(_)) => {\n+      ty::ty_vec(ref mt, ty::vstore_slice(_)) => {\n           let p_ty = type_of(cx, mt.ty).ptr_to();\n           let u_ty = Type::uint_from_ty(cx, ast::TyU);\n           Type::struct_([p_ty, u_ty], false)\n       }\n \n-      ty::ty_estr(ty::vstore_slice(_)) => {\n+      ty::ty_str(ty::vstore_slice(_)) => {\n           // This means we get a nicer name in the output\n           cx.tn.find_type(\"str_slice\").unwrap()\n       }\n \n-      ty::ty_estr(ty::vstore_fixed(n)) => {\n+      ty::ty_str(ty::vstore_fixed(n)) => {\n           Type::array(&Type::i8(), (n + 1u) as u64)\n       }\n \n-      ty::ty_evec(ref mt, ty::vstore_fixed(n)) => {\n+      ty::ty_vec(ref mt, ty::vstore_fixed(n)) => {\n           Type::array(&type_of(cx, mt.ty), n as u64)\n       }\n "}, {"sha": "70abc13775f2d6844154c14074ab041649497f37", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -635,11 +635,11 @@ pub enum sty {\n     ty_int(ast::IntTy),\n     ty_uint(ast::UintTy),\n     ty_float(ast::FloatTy),\n-    ty_estr(vstore),\n+    ty_str(vstore),\n     ty_enum(DefId, substs),\n     ty_box(t),\n     ty_uniq(mt),\n-    ty_evec(mt, vstore),\n+    ty_vec(mt, vstore),\n     ty_ptr(mt),\n     ty_rptr(Region, mt),\n     ty_bare_fn(BareFnTy),\n@@ -1070,15 +1070,15 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n         return f;\n     }\n     match &st {\n-      &ty_estr(vstore_slice(r)) => {\n+      &ty_str(vstore_slice(r)) => {\n         flags |= rflags(r);\n       }\n-      &ty_evec(ref mt, vstore_slice(r)) => {\n+      &ty_vec(ref mt, vstore_slice(r)) => {\n         flags |= rflags(r);\n         flags |= get(mt.ty).flags;\n       }\n       &ty_nil | &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n-      &ty_estr(_) | &ty_type | &ty_opaque_closure_ptr(_) |\n+      &ty_str(_) | &ty_type | &ty_opaque_closure_ptr(_) |\n       &ty_opaque_box => (),\n       // You might think that we could just return ty_err for\n       // any type containing ty_err as a component, and get\n@@ -1103,7 +1103,7 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n           }\n       }\n       &ty_box(ref tt) => flags |= get(*tt).flags,\n-      &ty_uniq(ref m) | &ty_evec(ref m, _) | &ty_ptr(ref m) |\n+      &ty_uniq(ref m) | &ty_vec(ref m, _) | &ty_ptr(ref m) |\n       &ty_unboxed_vec(ref m) => {\n         flags |= get(m.ty).flags;\n       }\n@@ -1234,8 +1234,8 @@ pub fn mk_mach_float(tm: ast::FloatTy) -> t {\n #[inline]\n pub fn mk_char() -> t { mk_prim_t(&primitives::TY_CHAR) }\n \n-pub fn mk_estr(cx: ctxt, t: vstore) -> t {\n-    mk_t(cx, ty_estr(t))\n+pub fn mk_str(cx: ctxt, t: vstore) -> t {\n+    mk_t(cx, ty_str(t))\n }\n \n pub fn mk_enum(cx: ctxt, did: ast::DefId, substs: substs) -> t {\n@@ -1278,8 +1278,8 @@ pub fn mk_nil_ptr(cx: ctxt) -> t {\n     mk_ptr(cx, mt {ty: mk_nil(), mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_evec(cx: ctxt, tm: mt, t: vstore) -> t {\n-    mk_t(cx, ty_evec(tm, t))\n+pub fn mk_vec(cx: ctxt, tm: mt, t: vstore) -> t {\n+    mk_t(cx, ty_vec(tm, t))\n }\n \n pub fn mk_unboxed_vec(cx: ctxt, tm: mt) -> t {\n@@ -1366,13 +1366,13 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n     }\n     match get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_estr(_) | ty_type | ty_opaque_box | ty_self(_) |\n+      ty_str(_) | ty_type | ty_opaque_box | ty_self(_) |\n       ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) | ty_err => {\n       }\n       ty_box(ref ty) => {\n         maybe_walk_ty(*ty, f);\n       }\n-      ty_evec(ref tm, _) | ty_unboxed_vec(ref tm) | ty_ptr(ref tm) |\n+      ty_vec(ref tm, _) | ty_unboxed_vec(ref tm) | ty_ptr(ref tm) |\n       ty_rptr(_, ref tm) | ty_uniq(ref tm) => {\n         maybe_walk_ty(tm.ty, f);\n       }\n@@ -1520,16 +1520,16 @@ pub fn type_is_self(ty: t) -> bool {\n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n       ty_struct(..) | ty_tup(_) | ty_enum(..) | ty_closure(_) | ty_trait(..) |\n-      ty_evec(_, vstore_fixed(_)) | ty_estr(vstore_fixed(_)) |\n-      ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_))\n+      ty_vec(_, vstore_fixed(_)) | ty_str(vstore_fixed(_)) |\n+      ty_vec(_, vstore_slice(_)) | ty_str(vstore_slice(_))\n       => true,\n       _ => false\n     }\n }\n \n pub fn type_is_sequence(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_estr(_) | ty_evec(_, _) => true,\n+      ty_str(_) | ty_vec(_, _) => true,\n       _ => false\n     }\n }\n@@ -1543,15 +1543,15 @@ pub fn type_is_simd(cx: ctxt, ty: t) -> bool {\n \n pub fn type_is_str(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_estr(_) => true,\n+      ty_str(_) => true,\n       _ => false\n     }\n }\n \n pub fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     match get(ty).sty {\n-      ty_estr(_) => return mk_mach_uint(ast::TyU8),\n-      ty_evec(mt, _) | ty_unboxed_vec(mt) => return mt.ty,\n+      ty_str(_) => return mk_mach_uint(ast::TyU8),\n+      ty_vec(mt, _) | ty_unboxed_vec(mt) => return mt.ty,\n       _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n     }\n }\n@@ -1593,7 +1593,7 @@ pub fn type_is_box(ty: t) -> bool {\n pub fn type_is_boxed(ty: t) -> bool {\n     match get(ty).sty {\n       ty_box(_) | ty_opaque_box |\n-      ty_evec(_, vstore_box) | ty_estr(vstore_box) => true,\n+      ty_vec(_, vstore_box) | ty_str(vstore_box) => true,\n       _ => false\n     }\n }\n@@ -1607,7 +1607,7 @@ pub fn type_is_region_ptr(ty: t) -> bool {\n \n pub fn type_is_slice(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_)) => true,\n+      ty_vec(_, vstore_slice(_)) | ty_str(vstore_slice(_)) => true,\n       _ => return false\n     }\n }\n@@ -1628,17 +1628,17 @@ pub fn type_is_unsafe_ptr(ty: t) -> bool {\n \n pub fn type_is_vec(ty: t) -> bool {\n     return match get(ty).sty {\n-          ty_evec(_, _) | ty_unboxed_vec(_) => true,\n-          ty_estr(_) => true,\n+          ty_vec(_, _) | ty_unboxed_vec(_) => true,\n+          ty_str(_) => true,\n           _ => false\n         };\n }\n \n pub fn type_is_unique(ty: t) -> bool {\n     match get(ty).sty {\n         ty_uniq(_) |\n-        ty_evec(_, vstore_uniq) |\n-        ty_estr(vstore_uniq) |\n+        ty_vec(_, vstore_uniq) |\n+        ty_str(vstore_uniq) |\n         ty_opaque_closure_ptr(ast::OwnedSigil) => true,\n         _ => return false\n     }\n@@ -1719,10 +1719,10 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n             !needs_unwind_cleanup\n           }\n           ty_uniq(_) |\n-          ty_estr(vstore_uniq) |\n-          ty_estr(vstore_box) |\n-          ty_evec(_, vstore_uniq) |\n-          ty_evec(_, vstore_box)\n+          ty_str(vstore_uniq) |\n+          ty_str(vstore_box) |\n+          ty_vec(_, vstore_uniq) |\n+          ty_vec(_, vstore_box)\n           => {\n             // Once we're inside a box, the annihilator will find\n             // it and destroy it.\n@@ -2031,7 +2031,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 TC::None\n             }\n \n-            ty_estr(vstore_uniq) => {\n+            ty_str(vstore_uniq) => {\n                 TC::OwnsOwned\n             }\n \n@@ -2060,32 +2060,32 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 tc_mt(cx, mt, cache).owned_pointer()\n             }\n \n-            ty_evec(mt, vstore_uniq) => {\n+            ty_vec(mt, vstore_uniq) => {\n                 tc_mt(cx, mt, cache).owned_pointer()\n             }\n \n-            ty_evec(mt, vstore_box) => {\n+            ty_vec(mt, vstore_box) => {\n                 tc_mt(cx, mt, cache).managed_pointer()\n             }\n \n-            ty_evec(ref mt, vstore_slice(r)) => {\n+            ty_vec(ref mt, vstore_slice(r)) => {\n                 tc_ty(cx, mt.ty, cache).reference(\n                     borrowed_contents(r, mt.mutbl))\n             }\n \n-            ty_evec(mt, vstore_fixed(_)) => {\n+            ty_vec(mt, vstore_fixed(_)) => {\n                 tc_mt(cx, mt, cache)\n             }\n \n-            ty_estr(vstore_box) => {\n+            ty_str(vstore_box) => {\n                 TC::Managed\n             }\n \n-            ty_estr(vstore_slice(r)) => {\n+            ty_str(vstore_slice(r)) => {\n                 borrowed_contents(r, ast::MutImmutable)\n             }\n \n-            ty_estr(vstore_fixed(_)) => {\n+            ty_str(vstore_fixed(_)) => {\n                 TC::None\n             }\n \n@@ -2324,7 +2324,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_int(_) |\n             ty_uint(_) |\n             ty_float(_) |\n-            ty_estr(_) |\n+            ty_str(_) |\n             ty_bare_fn(_) |\n             ty_closure(_) |\n             ty_infer(_) |\n@@ -2334,7 +2334,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_type |\n             ty_opaque_box |\n             ty_opaque_closure_ptr(_) |\n-            ty_evec(_, _) |\n+            ty_vec(_, _) |\n             ty_unboxed_vec(_) => {\n                 false\n             }\n@@ -2431,7 +2431,7 @@ pub fn type_structurally_contains(cx: ctxt, ty: t, test: |x: &sty| -> bool)\n         }\n         return false;\n       }\n-      ty_evec(ref mt, vstore_fixed(_)) => {\n+      ty_vec(ref mt, vstore_fixed(_)) => {\n         return type_structurally_contains(cx, mt.ty, test);\n       }\n       _ => return false\n@@ -2442,8 +2442,8 @@ pub fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n     return type_structurally_contains(cx, ty, |sty| {\n         match *sty {\n           ty_uniq(_) |\n-          ty_evec(_, vstore_uniq) |\n-          ty_estr(vstore_uniq) => true,\n+          ty_vec(_, vstore_uniq) |\n+          ty_str(vstore_uniq) => true,\n           _ => false,\n         }\n     });\n@@ -2513,8 +2513,8 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_type | ty_ptr(_) | ty_bare_fn(_) => result = true,\n       // Boxed types\n       ty_box(_) | ty_uniq(_) | ty_closure(_) |\n-      ty_estr(vstore_uniq) | ty_estr(vstore_box) |\n-      ty_evec(_, vstore_uniq) | ty_evec(_, vstore_box) |\n+      ty_str(vstore_uniq) | ty_str(vstore_box) |\n+      ty_vec(_, vstore_uniq) | ty_vec(_, vstore_box) |\n       ty_trait(_, _, _, _, _) | ty_rptr(_,_) | ty_opaque_box => result = false,\n       // Structural types\n       ty_enum(did, ref substs) => {\n@@ -2532,8 +2532,8 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_tup(ref elts) => {\n         for elt in elts.iter() { if !type_is_pod(cx, *elt) { result = false; } }\n       }\n-      ty_estr(vstore_fixed(_)) => result = true,\n-      ty_evec(ref mt, vstore_fixed(_)) | ty_unboxed_vec(ref mt) => {\n+      ty_str(vstore_fixed(_)) => result = true,\n+      ty_vec(ref mt, vstore_fixed(_)) | ty_unboxed_vec(ref mt) => {\n         result = type_is_pod(cx, mt.ty);\n       }\n       ty_param(_) => result = false,\n@@ -2547,7 +2547,7 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n         });\n       }\n \n-      ty_estr(vstore_slice(..)) | ty_evec(_, vstore_slice(..)) => {\n+      ty_str(vstore_slice(..)) | ty_vec(_, vstore_slice(..)) => {\n         result = false;\n       }\n \n@@ -2652,8 +2652,8 @@ pub fn index(t: t) -> Option<mt> {\n \n pub fn index_sty(sty: &sty) -> Option<mt> {\n     match *sty {\n-      ty_evec(mt, _) => Some(mt),\n-      ty_estr(_) => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n+      ty_vec(mt, _) => Some(mt),\n+      ty_str(_) => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n       _ => None\n     }\n }\n@@ -2765,8 +2765,8 @@ pub fn is_fn_ty(fty: t) -> bool {\n \n pub fn ty_vstore(ty: t) -> vstore {\n     match get(ty).sty {\n-        ty_evec(_, vstore) => vstore,\n-        ty_estr(vstore) => vstore,\n+        ty_vec(_, vstore) => vstore,\n+        ty_str(vstore) => vstore,\n         ref s => fail!(\"ty_vstore() called on invalid sty: {:?}\", s)\n     }\n }\n@@ -2776,8 +2776,8 @@ pub fn ty_region(tcx: ctxt,\n                  ty: t) -> Region {\n     match get(ty).sty {\n         ty_rptr(r, _) => r,\n-        ty_evec(_, vstore_slice(r)) => r,\n-        ty_estr(vstore_slice(r)) => r,\n+        ty_vec(_, vstore_slice(r)) => r,\n+        ty_str(vstore_slice(r)) => r,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n@@ -2962,12 +2962,12 @@ pub fn adjust_ty(cx: ctxt,\n                   r: Region, m: ast::Mutability,\n                   ty: ty::t) -> ty::t {\n         match get(ty).sty {\n-            ty_evec(mt, _) => {\n-                ty::mk_evec(cx, mt {ty: mt.ty, mutbl: m}, vstore_slice(r))\n+            ty_vec(mt, _) => {\n+                ty::mk_vec(cx, mt {ty: mt.ty, mutbl: m}, vstore_slice(r))\n             }\n \n-            ty_estr(_) => {\n-                ty::mk_estr(cx, vstore_slice(r))\n+            ty_str(_) => {\n+                ty::mk_str(cx, vstore_slice(r))\n             }\n \n             ref s => {\n@@ -3344,15 +3344,15 @@ pub fn occurs_check(tcx: ctxt, sp: Span, vid: TyVid, rt: t) {\n pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n     match get(t).sty {\n       ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |\n-      ty_uint(_) | ty_float(_) | ty_estr(_) |\n+      ty_uint(_) | ty_float(_) | ty_str(_) |\n       ty_type | ty_opaque_box | ty_opaque_closure_ptr(_) => {\n         ::util::ppaux::ty_to_str(cx, t)\n       }\n \n       ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n       ty_box(_) => ~\"@-ptr\",\n       ty_uniq(_) => ~\"~-ptr\",\n-      ty_evec(_, _) => ~\"vector\",\n+      ty_vec(_, _) => ~\"vector\",\n       ty_unboxed_vec(_) => ~\"unboxed vector\",\n       ty_ptr(_) => ~\"*-ptr\",\n       ty_rptr(_, _) => ~\"&-ptr\",\n@@ -4814,7 +4814,7 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n                 hash.input([6]);\n                 iter(&mut hash, &f);\n             }\n-            ty_estr(v) => {\n+            ty_str(v) => {\n                 hash.input([7]);\n                 vstore(&mut hash, v);\n             }\n@@ -4829,7 +4829,7 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n                 hash.input([10]);\n                 mt(&mut hash, m);\n             }\n-            ty_evec(m, v) => {\n+            ty_vec(m, v) => {\n                 hash.input([11]);\n                 mt(&mut hash, m);\n                 vstore(&mut hash, v);"}, {"sha": "eb854adf4a846e4339e92503bc9b039f56fff9e0", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -152,9 +152,8 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_unboxed_vec(ref tm) => {\n             ty::ty_unboxed_vec(this.fold_mt(tm))\n         }\n-        ty::ty_evec(ref tm, vst) => {\n-            ty::ty_evec(this.fold_mt(tm),\n-                        this.fold_vstore(vst))\n+        ty::ty_vec(ref tm, vst) => {\n+            ty::ty_vec(this.fold_mt(tm), this.fold_vstore(vst))\n         }\n         ty::ty_enum(tid, ref substs) => {\n             ty::ty_enum(tid, this.fold_substs(substs))\n@@ -184,8 +183,8 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n             ty::ty_struct(did,\n                           this.fold_substs(substs))\n         }\n-        ty::ty_estr(vst) => {\n-            ty::ty_estr(this.fold_vstore(vst))\n+        ty::ty_str(vst) => {\n+            ty::ty_str(this.fold_vstore(vst))\n         }\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_char |\n         ty::ty_int(_) | ty::ty_uint(_) |"}, {"sha": "74e4c969292507f32dd8d7ea0a2adde15f2214ed", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -293,8 +293,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n         ty::mt {ty: ast_ty_to_ty(this, rscope, mt.ty), mutbl: mt.mutbl}\n     }\n \n-    // Handle @, ~, and & being able to mean estrs and evecs.\n-    // If a_seq_ty is a str or a vec, make it an estr/evec.\n+    // Handle @, ~, and & being able to mean strs and vecs.\n+    // If a_seq_ty is a str or a vec, make it an str/vec.\n     // Also handle first-class trait types.\n     fn mk_pointer<AC:AstConv,\n                   RS:RegionScope>(\n@@ -314,7 +314,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                     mt = ty::mt { ty: mt.ty, mutbl: a_seq_ty.mutbl };\n                 }\n                 debug!(\"&[]: vst={:?}\", vst);\n-                return ty::mk_evec(tcx, mt, vst);\n+                return ty::mk_vec(tcx, mt, vst);\n             }\n             ast::TyPath(ref path, ref bounds, id) => {\n                 // Note that the \"bounds must be empty if path is not a trait\"\n@@ -324,7 +324,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 match def_map.get().find(&id) {\n                     Some(&ast::DefPrimTy(ast::TyStr)) if a_seq_ty.mutbl == ast::MutImmutable => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                        return ty::mk_estr(tcx, vst);\n+                        return ty::mk_str(tcx, vst);\n                     }\n                     Some(&ast::DefTrait(trait_def_id)) => {\n                         let result = ast_path_to_trait_ref(\n@@ -415,7 +415,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n       ast::TyVec(ty) => {\n         tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n         // return /something/ so they can at least get more errors\n-        ty::mk_evec(tcx, ast_ty_to_mt(this, rscope, ty), ty::vstore_uniq)\n+        ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty), ty::vstore_uniq)\n       }\n       ast::TyPtr(ref mt) => {\n         ty::mk_ptr(tcx, ast_mt_to_mt(this, rscope, mt))\n@@ -519,7 +519,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 tcx.sess.span_err(ast_ty.span,\n                                   \"bare `str` is not a type\");\n                 // return /something/ so they can at least get more errors\n-                ty::mk_estr(tcx, ty::vstore_uniq)\n+                ty::mk_str(tcx, ty::vstore_uniq)\n               }\n             }\n           }\n@@ -552,11 +552,11 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n           Ok(ref r) => {\n             match *r {\n               const_eval::const_int(i) =>\n-                ty::mk_evec(tcx, ast_ty_to_mt(this, rscope, ty),\n-                            ty::vstore_fixed(i as uint)),\n+                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n+                           ty::vstore_fixed(i as uint)),\n               const_eval::const_uint(i) =>\n-                ty::mk_evec(tcx, ast_ty_to_mt(this, rscope, ty),\n-                            ty::vstore_fixed(i as uint)),\n+                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n+                           ty::vstore_fixed(i as uint)),\n               _ => {\n                 tcx.sess.span_fatal(\n                     ast_ty.span, \"expected constant expr for vector length\");"}, {"sha": "efd632dc80ac191380229eaea10217f02e84093c", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -602,7 +602,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         let (elt_type, region_var) = match *structure_of(fcx,\n                                                          pat.span,\n                                                          expected) {\n-          ty::ty_evec(mt, vstore) => {\n+          ty::ty_vec(mt, vstore) => {\n             let region_var = match vstore {\n                 ty::vstore_slice(r) => r,\n                 ty::vstore_box | ty::vstore_uniq | ty::vstore_fixed(_) => {\n@@ -643,7 +643,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         }\n         match slice {\n             Some(slice_pat) => {\n-                let slice_ty = ty::mk_evec(tcx,\n+                let slice_ty = ty::mk_vec(tcx,\n                     ty::mt {ty: elt_type.ty, mutbl: elt_type.mutbl},\n                     ty::vstore_slice(region_var)\n                 );"}, {"sha": "f6ee7538b5b74a91859a62d4d2d6f6c00dbc2cd7", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -648,11 +648,11 @@ impl<'a> LookupContext<'a> {\n                      autoderefs: autoderefs+1,\n                      autoref: Some(ty::AutoPtr(region, self_mt.mutbl))}))\n             }\n-            ty::ty_evec(self_mt, vstore_slice(_)) => {\n+            ty::ty_vec(self_mt, vstore_slice(_)) => {\n                 let region =\n                     self.infcx().next_region_var(\n                         infer::Autoref(self.expr.span));\n-                (ty::mk_evec(tcx, self_mt, vstore_slice(region)),\n+                (ty::mk_vec(tcx, self_mt, vstore_slice(region)),\n                  ty::AutoDerefRef(ty::AutoDerefRef {\n                      autoderefs: autoderefs,\n                      autoref: Some(ty::AutoBorrowVec(region, self_mt.mutbl))}))\n@@ -699,26 +699,26 @@ impl<'a> LookupContext<'a> {\n         let tcx = self.tcx();\n         let sty = ty::get(self_ty).sty.clone();\n         match sty {\n-            ty_evec(mt, vstore_box) |\n-            ty_evec(mt, vstore_uniq) |\n-            ty_evec(mt, vstore_slice(_)) | // NDM(#3148)\n-            ty_evec(mt, vstore_fixed(_)) => {\n+            ty_vec(mt, vstore_box) |\n+            ty_vec(mt, vstore_uniq) |\n+            ty_vec(mt, vstore_slice(_)) | // NDM(#3148)\n+            ty_vec(mt, vstore_fixed(_)) => {\n                 // First try to borrow to a slice\n                 let entry = self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVec, autoderefs, [MutImmutable, MutMutable],\n-                    |m,r| ty::mk_evec(tcx,\n-                                      ty::mt {ty:mt.ty, mutbl:m},\n-                                      vstore_slice(r)));\n+                    |m,r| ty::mk_vec(tcx,\n+                                     ty::mt {ty:mt.ty, mutbl:m},\n+                                     vstore_slice(r)));\n \n                 if entry.is_some() { return entry; }\n \n                 // Then try to borrow to a slice *and* borrow a pointer.\n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVecRef, autoderefs, [MutImmutable, MutMutable],\n                     |m,r| {\n-                        let slice_ty = ty::mk_evec(tcx,\n-                                                   ty::mt {ty:mt.ty, mutbl:m},\n-                                                   vstore_slice(r));\n+                        let slice_ty = ty::mk_vec(tcx,\n+                                                  ty::mt {ty:mt.ty, mutbl:m},\n+                                                  vstore_slice(r));\n                         // NB: we do not try to autoref to a mutable\n                         // pointer. That would be creating a pointer\n                         // to a temporary pointer (the borrowed\n@@ -728,19 +728,19 @@ impl<'a> LookupContext<'a> {\n                     })\n             }\n \n-            ty_estr(vstore_box) |\n-            ty_estr(vstore_uniq) |\n-            ty_estr(vstore_fixed(_)) => {\n+            ty_str(vstore_box) |\n+            ty_str(vstore_uniq) |\n+            ty_str(vstore_fixed(_)) => {\n                 let entry = self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVec, autoderefs, [MutImmutable],\n-                    |_m,r| ty::mk_estr(tcx, vstore_slice(r)));\n+                    |_m,r| ty::mk_str(tcx, vstore_slice(r)));\n \n                 if entry.is_some() { return entry; }\n \n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVecRef, autoderefs, [MutImmutable],\n                     |m,r| {\n-                        let slice_ty = ty::mk_estr(tcx, vstore_slice(r));\n+                        let slice_ty = ty::mk_str(tcx, vstore_slice(r));\n                         ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m})\n                     })\n             }\n@@ -782,7 +782,7 @@ impl<'a> LookupContext<'a> {\n             ty_self(_) | ty_param(..) | ty_nil | ty_bot | ty_bool |\n             ty_char | ty_int(..) | ty_uint(..) |\n             ty_float(..) | ty_enum(..) | ty_ptr(..) | ty_struct(..) | ty_tup(..) |\n-            ty_estr(..) | ty_evec(..) | ty_trait(..) | ty_closure(..) => {\n+            ty_str(..) | ty_vec(..) | ty_trait(..) | ty_closure(..) => {\n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoPtr, autoderefs, [MutImmutable, MutMutable],\n                     |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))"}, {"sha": "242fa1faf9772730ce9fd657c1bac736d525fd23", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -1386,10 +1386,10 @@ pub fn check_lit(fcx: @FnCtxt, lit: &ast::Lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-        ast::LitStr(..) => ty::mk_estr(tcx, ty::vstore_slice(ty::ReStatic)),\n+        ast::LitStr(..) => ty::mk_str(tcx, ty::vstore_slice(ty::ReStatic)),\n         ast::LitBinary(..) => {\n-            ty::mk_evec(tcx, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable },\n-                        ty::vstore_slice(ty::ReStatic))\n+            ty::mk_vec(tcx, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable },\n+                       ty::vstore_slice(ty::ReStatic))\n         }\n         ast::LitChar(_) => ty::mk_char(),\n         ast::LitInt(_, t) => ty::mk_mach_int(t),\n@@ -2629,7 +2629,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         let typ = match ev.node {\n           ast::ExprLit(@codemap::Spanned { node: ast::LitStr(..), .. }) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n-            ty::mk_estr(tcx, tt)\n+            ty::mk_str(tcx, tt)\n           }\n           ast::ExprVec(ref args, mutbl) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n@@ -2655,7 +2655,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n             } else if any_bot {\n                 ty::mk_bot()\n             } else {\n-                ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n+                ty::mk_vec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n             }\n           }\n           ast::ExprRepeat(element, count_expr, mutbl) => {\n@@ -2674,7 +2674,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n             } else if ty::type_is_bot(arg_t) {\n                 ty::mk_bot()\n             } else {\n-                ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n+                ty::mk_vec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n             }\n           }\n           _ =>\n@@ -3166,7 +3166,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n                         fn is_vec(t: ty::t) -> bool {\n                             match ty::get(t).sty {\n-                                ty::ty_evec(_,_) => true,\n+                                ty::ty_vec(..) => true,\n                                 _ => false\n                             }\n                         }\n@@ -3223,8 +3223,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         for e in args.iter() {\n             check_expr_has_type(fcx, *e, t);\n         }\n-        let typ = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n-                              ty::vstore_fixed(args.len()));\n+        let typ = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: mutbl},\n+                             ty::vstore_fixed(args.len()));\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprRepeat(element, count_expr, mutbl) => {\n@@ -3240,8 +3240,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n             fcx.write_bot(id);\n         }\n         else {\n-            let t = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n-                                ty::vstore_fixed(count));\n+            let t = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: mutbl},\n+                               ty::vstore_fixed(count));\n             fcx.write_ty(id, t);\n         }\n       }"}, {"sha": "032c8f45753929d812e53405af99505b1d5105f2", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -677,8 +677,8 @@ fn constrain_index(rcx: &mut Rcx,\n \n     let r_index_expr = ty::ReScope(index_expr.id);\n     match ty::get(indexed_ty).sty {\n-        ty::ty_estr(ty::vstore_slice(r_ptr)) |\n-        ty::ty_evec(_, ty::vstore_slice(r_ptr)) => {\n+        ty::ty_str(ty::vstore_slice(r_ptr)) |\n+        ty::ty_vec(_, ty::vstore_slice(r_ptr)) => {\n             rcx.fcx.mk_subr(true, infer::IndexSlice(index_expr.span),\n                             r_index_expr, r_ptr);\n         }\n@@ -1215,22 +1215,22 @@ pub mod guarantor {\n     fn pointer_categorize(ty: ty::t) -> PointerCategorization {\n         match ty::get(ty).sty {\n             ty::ty_rptr(r, _) |\n-            ty::ty_evec(_, ty::vstore_slice(r)) |\n+            ty::ty_vec(_, ty::vstore_slice(r)) |\n             ty::ty_trait(_, _, ty::RegionTraitStore(r), _, _) |\n-            ty::ty_estr(ty::vstore_slice(r)) => {\n+            ty::ty_str(ty::vstore_slice(r)) => {\n                 BorrowedPointer(r)\n             }\n             ty::ty_uniq(..) |\n-            ty::ty_estr(ty::vstore_uniq) |\n+            ty::ty_str(ty::vstore_uniq) |\n             ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n-            ty::ty_evec(_, ty::vstore_uniq) => {\n+            ty::ty_vec(_, ty::vstore_uniq) => {\n                 OwnedPointer\n             }\n             ty::ty_box(..) |\n             ty::ty_ptr(..) |\n-            ty::ty_evec(_, ty::vstore_box) |\n+            ty::ty_vec(_, ty::vstore_box) |\n             ty::ty_trait(_, _, ty::BoxTraitStore, _, _) |\n-            ty::ty_estr(ty::vstore_box) => {\n+            ty::ty_str(ty::vstore_box) => {\n                 OtherPointer\n             }\n             ty::ty_closure(ref closure_ty) => {"}, {"sha": "c8fde97e4d6b3915512def1344d3c0b3763e39ac", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -103,7 +103,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n         fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n             match ty::get(ty).sty {\n                 ty::ty_rptr(r, ref mt) |\n-                ty::ty_evec(ref mt, ty::vstore_slice(r)) => {\n+                ty::ty_vec(ref mt, ty::vstore_slice(r)) => {\n                     self.relate(r);\n                     self.stack.push(r);\n                     ty_fold::super_fold_ty(self, mt.ty);"}, {"sha": "342e5a1ad2a0b13538d1bddc6c561e8666c7ab62", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -20,7 +20,7 @@ use metadata::csearch;\n use middle::ty::get;\n use middle::ty::{ImplContainer, lookup_item_type, subst};\n use middle::ty::{substs, t, ty_bool, ty_char, ty_bot, ty_box, ty_enum, ty_err};\n-use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n+use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_opaque_box, ty_param, ty_param_bounds_and_ty, ty_ptr};\n use middle::ty::{ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_type, ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n@@ -82,7 +82,7 @@ pub fn get_base_type(inference_context: @InferCtxt,\n         }\n \n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n-        ty_estr(..) | ty_evec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n+        ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n         ty_infer(..) | ty_param(..) | ty_self(..) | ty_type | ty_opaque_box |\n         ty_opaque_closure_ptr(..) | ty_unboxed_vec(..) | ty_err | ty_box(_) |\n         ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {"}, {"sha": "6c4a82c628afd1ae4338852e415a3db8a1372803", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -107,13 +107,13 @@ impl Coerce {\n                 });\n             }\n \n-            ty::ty_estr(vstore_slice(_)) => {\n+            ty::ty_str(vstore_slice(_)) => {\n                 return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_string(a, sty_a, b)\n                 });\n             }\n \n-            ty::ty_evec(mt_b, vstore_slice(_)) => {\n+            ty::ty_vec(mt_b, vstore_slice(_)) => {\n                 return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_vector(a, sty_a, b, mt_b)\n                 });\n@@ -273,15 +273,15 @@ impl Coerce {\n                b.inf_str(self.get_ref().infcx));\n \n         match *sty_a {\n-            ty::ty_estr(vstore_box) |\n-            ty::ty_estr(vstore_uniq) => {}\n+            ty::ty_str(vstore_box) |\n+            ty::ty_str(vstore_uniq) => {}\n             _ => {\n                 return self.subtype(a, b);\n             }\n         };\n \n         let r_a = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n-        let a_borrowed = ty::mk_estr(self.get_ref().infcx.tcx, vstore_slice(r_a));\n+        let a_borrowed = ty::mk_str(self.get_ref().infcx.tcx, vstore_slice(r_a));\n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n@@ -302,15 +302,15 @@ impl Coerce {\n         let sub = Sub(*self.get_ref());\n         let r_borrow = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n         let ty_inner = match *sty_a {\n-            ty::ty_evec(mt, _) => mt.ty,\n+            ty::ty_vec(mt, _) => mt.ty,\n             _ => {\n                 return self.subtype(a, b);\n             }\n         };\n \n-        let a_borrowed = ty::mk_evec(self.get_ref().infcx.tcx,\n-                                     mt {ty: ty_inner, mutbl: mt_b.mutbl},\n-                                     vstore_slice(r_borrow));\n+        let a_borrowed = ty::mk_vec(self.get_ref().infcx.tcx,\n+                                    mt {ty: ty_inner, mutbl: mt_b.mutbl},\n+                                    vstore_slice(r_borrow));\n         if_ok!(sub.tys(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,"}, {"sha": "01e19f011aa61354119f3be320e37af6220a3804", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -535,17 +535,17 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n           Ok(ty::mk_rptr(tcx, r, mt))\n       }\n \n-      (&ty::ty_evec(ref a_mt, vs_a), &ty::ty_evec(ref b_mt, vs_b)) => {\n+      (&ty::ty_vec(ref a_mt, vs_a), &ty::ty_vec(ref b_mt, vs_b)) => {\n         this.mts(a_mt, b_mt).and_then(|mt| {\n             this.vstores(ty::terr_vec, vs_a, vs_b).and_then(|vs| {\n-                Ok(ty::mk_evec(tcx, mt, vs))\n+                Ok(ty::mk_vec(tcx, mt, vs))\n             })\n         })\n       }\n \n-      (&ty::ty_estr(vs_a), &ty::ty_estr(vs_b)) => {\n+      (&ty::ty_str(vs_a), &ty::ty_str(vs_b)) => {\n         let vs = if_ok!(this.vstores(ty::terr_str, vs_a, vs_b));\n-        Ok(ty::mk_estr(tcx,vs))\n+        Ok(ty::mk_str(tcx,vs))\n       }\n \n       (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {"}, {"sha": "cfad864323b1be4293d2ae1fb96caca62465a8ee", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -625,11 +625,11 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraints_from_mt(mt, variance);\n             }\n \n-            ty::ty_estr(vstore) => {\n+            ty::ty_str(vstore) => {\n                 self.add_constraints_from_vstore(vstore, variance);\n             }\n \n-            ty::ty_evec(ref mt, vstore) => {\n+            ty::ty_vec(ref mt, vstore) => {\n                 self.add_constraints_from_vstore(vstore, variance);\n                 self.add_constraints_from_mt(mt, variance);\n             }"}, {"sha": "08b38c5b50f75acdc7cd2d35a4b7addb76602d85", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -17,7 +17,7 @@ use middle::ty::{mt, t, param_ty};\n use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region,\n                  ReEmpty};\n use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n-use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_bare_fn, ty_closure};\n+use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n use middle::ty::{ty_ptr, ty_rptr, ty_self, ty_tup, ty_type, ty_uniq};\n use middle::ty::{ty_trait, ty_int};\n@@ -501,10 +501,10 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         format!(\"{}{}{}{}{}\", trait_store_to_str(cx, s), mutability_to_str(mutbl), ty,\n                            bound_sep, bound_str)\n       }\n-      ty_evec(ref mt, vs) => {\n+      ty_vec(ref mt, vs) => {\n         vstore_ty_to_str(cx, mt, vs)\n       }\n-      ty_estr(vs) => format!(\"{}{}\", vstore_to_str(cx, vs), \"str\"),\n+      ty_str(vs) => format!(\"{}{}\", vstore_to_str(cx, vs), \"str\"),\n       ty_opaque_box => ~\"@?\",\n       ty_opaque_closure_ptr(ast::BorrowedSigil) => ~\"&closure\",\n       ty_opaque_closure_ptr(ast::ManagedSigil) => ~\"@closure\","}, {"sha": "b783ea6da3c5471c7970b9d927f77cb0fc92154b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5ad2a7825bd9821b8ef554046c8d81eb94ab7dfe", "patch": "@@ -2276,7 +2276,7 @@ impl Parser {\n                 let m = self.parse_mutability();\n                 let e = self.parse_prefix_expr();\n                 hi = e.span.hi;\n-                // HACK: turn &[...] into a &-evec\n+                // HACK: turn &[...] into a &-vec\n                 ex = match e.node {\n                   ExprVec(..) | ExprLit(@codemap::Spanned {\n                     node: LitStr(..), span: _\n@@ -2297,7 +2297,7 @@ impl Parser {\n             self.bump();\n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n-            // HACK: turn @[...] into a @-evec\n+            // HACK: turn @[...] into a @-vec\n             ex = match e.node {\n               ExprVec(..) |\n               ExprLit(@codemap::Spanned { node: LitStr(..), span: _}) |\n@@ -2310,7 +2310,7 @@ impl Parser {\n \n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n-            // HACK: turn ~[...] into a ~-evec\n+            // HACK: turn ~[...] into a ~-vec\n             ex = match e.node {\n               ExprVec(..) |\n               ExprLit(@codemap::Spanned { node: LitStr(..), span: _}) |\n@@ -2337,7 +2337,7 @@ impl Parser {\n             // Otherwise, we use the unique pointer default.\n             let subexpression = self.parse_prefix_expr();\n             hi = subexpression.span.hi;\n-            // HACK: turn `box [...]` into a boxed-evec\n+            // HACK: turn `box [...]` into a boxed-vec\n             ex = match subexpression.node {\n                 ExprVec(..) |\n                 ExprLit(@codemap::Spanned {"}]}