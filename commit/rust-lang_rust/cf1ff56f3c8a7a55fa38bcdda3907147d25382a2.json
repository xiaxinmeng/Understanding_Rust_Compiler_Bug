{"sha": "cf1ff56f3c8a7a55fa38bcdda3907147d25382a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMWZmNTZmM2M4YTdhNTVmYTM4YmNkZGEzOTA3MTQ3ZDI1MzgyYTI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-27T23:10:59Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-27T23:21:15Z"}, "message": "std: Remove msvc/valgrind headers\n\nThese aren't really used for anything any more, so there doesn't seem to be much\nreason to leave them around in the `rt` directory. There was some limiting of\nthreads spawned or tests when run under valgrind, but very little is run under\nvalgrind nowadays so there's also no real use keeping these around.", "tree": {"sha": "29daf941fb2f83ac179a8700aa4d73487812ba0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29daf941fb2f83ac179a8700aa4d73487812ba0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2", "html_url": "https://github.com/rust-lang/rust/commit/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909", "html_url": "https://github.com/rust-lang/rust/commit/3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909"}], "stats": {"total": 6414, "additions": 4, "deletions": 6410}, "files": [{"sha": "0319b4d2f2a9d2d7a4140c525225f817457aae4b", "filename": ".gitattributes", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=cf1ff56f3c8a7a55fa38bcdda3907147d25382a2", "patch": "@@ -6,6 +6,4 @@\n *.rs rust\n src/etc/pkg/rust-logo.ico binary\n src/etc/pkg/rust-logo.png binary\n-src/rt/msvc/* -whitespace\n-src/rt/valgrind/* -whitespace\n *.woff binary"}, {"sha": "269a1638b0ac042af3d58ee640ca9141cac62fd2", "filename": "src/libstd/process.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=cf1ff56f3c8a7a55fa38bcdda3907147d25382a2", "patch": "@@ -591,7 +591,6 @@ mod tests {\n     use io::prelude::*;\n \n     use io::ErrorKind;\n-    use rt::running_on_valgrind;\n     use str;\n     use super::{Command, Output, Stdio};\n \n@@ -737,10 +736,7 @@ mod tests {\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_string(), \"hello\");\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(stderr, Vec::new());\n-        }\n+        assert_eq!(stderr, Vec::new());\n     }\n \n     #[cfg(not(target_os=\"android\"))]\n@@ -779,10 +775,7 @@ mod tests {\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_string(), \"hello\");\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(stderr, Vec::new());\n-        }\n+        assert_eq!(stderr, Vec::new());\n     }\n \n     #[cfg(all(unix, not(target_os=\"android\")))]\n@@ -807,7 +800,6 @@ mod tests {\n     #[test]\n     fn test_inherit_env() {\n         use std::env;\n-        if running_on_valgrind() { return; }\n \n         let result = env_cmd().output().unwrap();\n         let output = String::from_utf8(result.stdout).unwrap();\n@@ -824,7 +816,6 @@ mod tests {\n     #[test]\n     fn test_inherit_env() {\n         use std::env;\n-        if running_on_valgrind() { return; }\n \n         let mut result = env_cmd().output().unwrap();\n         let output = String::from_utf8(result.stdout).unwrap();"}, {"sha": "7e86bb775a1b0fe517107eec30c17852f687654f", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=cf1ff56f3c8a7a55fa38bcdda3907147d25382a2", "patch": "@@ -26,7 +26,7 @@ use sys;\n use usize;\n \n // Reexport some of our utilities which are expected by other crates.\n-pub use self::util::{min_stack, running_on_valgrind};\n+pub use self::util::min_stack;\n pub use self::unwind::{begin_unwind, begin_unwind_fmt};\n \n // Reexport some functionality from liballoc."}, {"sha": "0fe8d873a75c6d11ac87962f651481eb0bbfb23d", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=cf1ff56f3c8a7a55fa38bcdda3907147d25382a2", "patch": "@@ -16,38 +16,6 @@ use intrinsics;\n use sync::atomic::{self, Ordering};\n use sys::stdio::Stderr;\n \n-/// Dynamically inquire about whether we're running under V.\n-/// You should usually not use this unless your test definitely\n-/// can't run correctly un-altered. Valgrind is there to help\n-/// you notice weirdness in normal, un-doctored code paths!\n-pub fn running_on_valgrind() -> bool {\n-    return on_valgrind();\n-    #[cfg(windows)]\n-    fn on_valgrind() -> bool { false }\n-\n-    #[cfg(unix)]\n-    fn on_valgrind() -> bool {\n-        use libc::uintptr_t;\n-        extern {\n-            fn rust_running_on_valgrind() -> uintptr_t;\n-        }\n-        unsafe { rust_running_on_valgrind() != 0 }\n-    }\n-}\n-\n-/// Valgrind has a fixed-sized array (size around 2000) of segment descriptors\n-/// wired into it; this is a hard limit and requires rebuilding valgrind if you\n-/// want to go beyond it. Normally this is not a problem, but in some tests, we\n-/// produce a lot of threads casually.  Making lots of threads alone might not\n-/// be a problem _either_, except on OSX, the segments produced for new threads\n-/// _take a while_ to get reclaimed by the OS. Combined with the fact that libuv\n-/// schedulers fork off a separate thread for polling fsevents on OSX, we get a\n-/// perfect storm of creating \"too many mappings\" for valgrind to handle when\n-/// running certain stress tests in the runtime.\n-pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {\n-    (cfg!(target_os=\"macos\")) && running_on_valgrind()\n-}\n-\n pub fn min_stack() -> usize {\n     static MIN: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n     match MIN.load(Ordering::SeqCst) {"}, {"sha": "194b6c8e3e2bc4e4a48855836b1d4e3ee2fb71c2", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=cf1ff56f3c8a7a55fa38bcdda3907147d25382a2", "patch": "@@ -41,7 +41,6 @@\n #![feature(fnbox)]\n #![feature(iter_cmp)]\n #![feature(libc)]\n-#![feature(rt)]\n #![feature(rustc_private)]\n #![feature(set_stdio)]\n #![feature(staged_api)]\n@@ -879,13 +878,7 @@ fn get_concurrency() -> usize {\n                 _ => panic!(\"RUST_TEST_THREADS is `{}`, should be a positive integer.\", s)\n             }\n         }\n-        Err(..) => {\n-            if std::rt::util::limit_thread_creation_due_to_osx_and_valgrind() {\n-                1\n-            } else {\n-                num_cpus()\n-            }\n-        }\n+        Err(..) => num_cpus(),\n     };\n \n     #[cfg(windows)]"}, {"sha": "4b3828a216298df33899652a1574db70ded3f082", "filename": "src/rt/msvc/inttypes.h", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909/src%2Frt%2Fmsvc%2Finttypes.h", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909/src%2Frt%2Fmsvc%2Finttypes.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmsvc%2Finttypes.h?ref=3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909", "patch": "@@ -1,305 +0,0 @@\n-// ISO C9x  compliant inttypes.h for Microsoft Visual Studio\n-// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124 \n-// \n-//  Copyright (c) 2006 Alexander Chemeris\n-// \n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions are met:\n-// \n-//   1. Redistributions of source code must retain the above copyright notice,\n-//      this list of conditions and the following disclaimer.\n-// \n-//   2. Redistributions in binary form must reproduce the above copyright\n-//      notice, this list of conditions and the following disclaimer in the\n-//      documentation and/or other materials provided with the distribution.\n-// \n-//   3. The name of the author may be used to endorse or promote products\n-//      derived from this software without specific prior written permission.\n-// \n-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n-// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n-// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n-// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n-// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n-// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n-// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n-// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-// \n-///////////////////////////////////////////////////////////////////////////////\n-\n-#ifndef _MSC_VER // [\n-#error \"Use this header only with Microsoft Visual C++ compilers!\"\n-#endif // _MSC_VER ]\n-\n-#ifndef _MSC_INTTYPES_H_ // [\n-#define _MSC_INTTYPES_H_\n-\n-#if _MSC_VER > 1000\n-#pragma once\n-#endif\n-\n-#include \"stdint.h\"\n-\n-// 7.8 Format conversion of integer types\n-\n-typedef struct {\n-   intmax_t quot;\n-   intmax_t rem;\n-} imaxdiv_t;\n-\n-// 7.8.1 Macros for format specifiers\n-\n-#if !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS) // [   See footnote 185 at page 198\n-\n-// The fprintf macros for signed integers are:\n-#define PRId8       \"d\"\n-#define PRIi8       \"i\"\n-#define PRIdLEAST8  \"d\"\n-#define PRIiLEAST8  \"i\"\n-#define PRIdFAST8   \"d\"\n-#define PRIiFAST8   \"i\"\n-\n-#define PRId16       \"hd\"\n-#define PRIi16       \"hi\"\n-#define PRIdLEAST16  \"hd\"\n-#define PRIiLEAST16  \"hi\"\n-#define PRIdFAST16   \"hd\"\n-#define PRIiFAST16   \"hi\"\n-\n-#define PRId32       \"I32d\"\n-#define PRIi32       \"I32i\"\n-#define PRIdLEAST32  \"I32d\"\n-#define PRIiLEAST32  \"I32i\"\n-#define PRIdFAST32   \"I32d\"\n-#define PRIiFAST32   \"I32i\"\n-\n-#define PRId64       \"I64d\"\n-#define PRIi64       \"I64i\"\n-#define PRIdLEAST64  \"I64d\"\n-#define PRIiLEAST64  \"I64i\"\n-#define PRIdFAST64   \"I64d\"\n-#define PRIiFAST64   \"I64i\"\n-\n-#define PRIdMAX     \"I64d\"\n-#define PRIiMAX     \"I64i\"\n-\n-#define PRIdPTR     \"Id\"\n-#define PRIiPTR     \"Ii\"\n-\n-// The fprintf macros for unsigned integers are:\n-#define PRIo8       \"o\"\n-#define PRIu8       \"u\"\n-#define PRIx8       \"x\"\n-#define PRIX8       \"X\"\n-#define PRIoLEAST8  \"o\"\n-#define PRIuLEAST8  \"u\"\n-#define PRIxLEAST8  \"x\"\n-#define PRIXLEAST8  \"X\"\n-#define PRIoFAST8   \"o\"\n-#define PRIuFAST8   \"u\"\n-#define PRIxFAST8   \"x\"\n-#define PRIXFAST8   \"X\"\n-\n-#define PRIo16       \"ho\"\n-#define PRIu16       \"hu\"\n-#define PRIx16       \"hx\"\n-#define PRIX16       \"hX\"\n-#define PRIoLEAST16  \"ho\"\n-#define PRIuLEAST16  \"hu\"\n-#define PRIxLEAST16  \"hx\"\n-#define PRIXLEAST16  \"hX\"\n-#define PRIoFAST16   \"ho\"\n-#define PRIuFAST16   \"hu\"\n-#define PRIxFAST16   \"hx\"\n-#define PRIXFAST16   \"hX\"\n-\n-#define PRIo32       \"I32o\"\n-#define PRIu32       \"I32u\"\n-#define PRIx32       \"I32x\"\n-#define PRIX32       \"I32X\"\n-#define PRIoLEAST32  \"I32o\"\n-#define PRIuLEAST32  \"I32u\"\n-#define PRIxLEAST32  \"I32x\"\n-#define PRIXLEAST32  \"I32X\"\n-#define PRIoFAST32   \"I32o\"\n-#define PRIuFAST32   \"I32u\"\n-#define PRIxFAST32   \"I32x\"\n-#define PRIXFAST32   \"I32X\"\n-\n-#define PRIo64       \"I64o\"\n-#define PRIu64       \"I64u\"\n-#define PRIx64       \"I64x\"\n-#define PRIX64       \"I64X\"\n-#define PRIoLEAST64  \"I64o\"\n-#define PRIuLEAST64  \"I64u\"\n-#define PRIxLEAST64  \"I64x\"\n-#define PRIXLEAST64  \"I64X\"\n-#define PRIoFAST64   \"I64o\"\n-#define PRIuFAST64   \"I64u\"\n-#define PRIxFAST64   \"I64x\"\n-#define PRIXFAST64   \"I64X\"\n-\n-#define PRIoMAX     \"I64o\"\n-#define PRIuMAX     \"I64u\"\n-#define PRIxMAX     \"I64x\"\n-#define PRIXMAX     \"I64X\"\n-\n-#define PRIoPTR     \"Io\"\n-#define PRIuPTR     \"Iu\"\n-#define PRIxPTR     \"Ix\"\n-#define PRIXPTR     \"IX\"\n-\n-// The fscanf macros for signed integers are:\n-#define SCNd8       \"d\"\n-#define SCNi8       \"i\"\n-#define SCNdLEAST8  \"d\"\n-#define SCNiLEAST8  \"i\"\n-#define SCNdFAST8   \"d\"\n-#define SCNiFAST8   \"i\"\n-\n-#define SCNd16       \"hd\"\n-#define SCNi16       \"hi\"\n-#define SCNdLEAST16  \"hd\"\n-#define SCNiLEAST16  \"hi\"\n-#define SCNdFAST16   \"hd\"\n-#define SCNiFAST16   \"hi\"\n-\n-#define SCNd32       \"ld\"\n-#define SCNi32       \"li\"\n-#define SCNdLEAST32  \"ld\"\n-#define SCNiLEAST32  \"li\"\n-#define SCNdFAST32   \"ld\"\n-#define SCNiFAST32   \"li\"\n-\n-#define SCNd64       \"I64d\"\n-#define SCNi64       \"I64i\"\n-#define SCNdLEAST64  \"I64d\"\n-#define SCNiLEAST64  \"I64i\"\n-#define SCNdFAST64   \"I64d\"\n-#define SCNiFAST64   \"I64i\"\n-\n-#define SCNdMAX     \"I64d\"\n-#define SCNiMAX     \"I64i\"\n-\n-#ifdef _WIN64 // [\n-#  define SCNdPTR     \"I64d\"\n-#  define SCNiPTR     \"I64i\"\n-#else  // _WIN64 ][\n-#  define SCNdPTR     \"ld\"\n-#  define SCNiPTR     \"li\"\n-#endif  // _WIN64 ]\n-\n-// The fscanf macros for unsigned integers are:\n-#define SCNo8       \"o\"\n-#define SCNu8       \"u\"\n-#define SCNx8       \"x\"\n-#define SCNX8       \"X\"\n-#define SCNoLEAST8  \"o\"\n-#define SCNuLEAST8  \"u\"\n-#define SCNxLEAST8  \"x\"\n-#define SCNXLEAST8  \"X\"\n-#define SCNoFAST8   \"o\"\n-#define SCNuFAST8   \"u\"\n-#define SCNxFAST8   \"x\"\n-#define SCNXFAST8   \"X\"\n-\n-#define SCNo16       \"ho\"\n-#define SCNu16       \"hu\"\n-#define SCNx16       \"hx\"\n-#define SCNX16       \"hX\"\n-#define SCNoLEAST16  \"ho\"\n-#define SCNuLEAST16  \"hu\"\n-#define SCNxLEAST16  \"hx\"\n-#define SCNXLEAST16  \"hX\"\n-#define SCNoFAST16   \"ho\"\n-#define SCNuFAST16   \"hu\"\n-#define SCNxFAST16   \"hx\"\n-#define SCNXFAST16   \"hX\"\n-\n-#define SCNo32       \"lo\"\n-#define SCNu32       \"lu\"\n-#define SCNx32       \"lx\"\n-#define SCNX32       \"lX\"\n-#define SCNoLEAST32  \"lo\"\n-#define SCNuLEAST32  \"lu\"\n-#define SCNxLEAST32  \"lx\"\n-#define SCNXLEAST32  \"lX\"\n-#define SCNoFAST32   \"lo\"\n-#define SCNuFAST32   \"lu\"\n-#define SCNxFAST32   \"lx\"\n-#define SCNXFAST32   \"lX\"\n-\n-#define SCNo64       \"I64o\"\n-#define SCNu64       \"I64u\"\n-#define SCNx64       \"I64x\"\n-#define SCNX64       \"I64X\"\n-#define SCNoLEAST64  \"I64o\"\n-#define SCNuLEAST64  \"I64u\"\n-#define SCNxLEAST64  \"I64x\"\n-#define SCNXLEAST64  \"I64X\"\n-#define SCNoFAST64   \"I64o\"\n-#define SCNuFAST64   \"I64u\"\n-#define SCNxFAST64   \"I64x\"\n-#define SCNXFAST64   \"I64X\"\n-\n-#define SCNoMAX     \"I64o\"\n-#define SCNuMAX     \"I64u\"\n-#define SCNxMAX     \"I64x\"\n-#define SCNXMAX     \"I64X\"\n-\n-#ifdef _WIN64 // [\n-#  define SCNoPTR     \"I64o\"\n-#  define SCNuPTR     \"I64u\"\n-#  define SCNxPTR     \"I64x\"\n-#  define SCNXPTR     \"I64X\"\n-#else  // _WIN64 ][\n-#  define SCNoPTR     \"lo\"\n-#  define SCNuPTR     \"lu\"\n-#  define SCNxPTR     \"lx\"\n-#  define SCNXPTR     \"lX\"\n-#endif  // _WIN64 ]\n-\n-#endif // __STDC_FORMAT_MACROS ]\n-\n-// 7.8.2 Functions for greatest-width integer types\n-\n-// 7.8.2.1 The imaxabs function\n-#define imaxabs _abs64\n-\n-// 7.8.2.2 The imaxdiv function\n-\n-// This is modified version of div() function from Microsoft's div.c found\n-// in %MSVC.NET%\\crt\\src\\div.c\n-#ifdef STATIC_IMAXDIV // [\n-static\n-#else // STATIC_IMAXDIV ][\n-_inline\n-#endif // STATIC_IMAXDIV ]\n-imaxdiv_t __cdecl imaxdiv(intmax_t numer, intmax_t denom)\n-{\n-   imaxdiv_t result;\n-\n-   result.quot = numer / denom;\n-   result.rem = numer % denom;\n-\n-   if (numer < 0 && result.rem > 0) {\n-      // did division wrong; must fix up\n-      ++result.quot;\n-      result.rem -= denom;\n-   }\n-\n-   return result;\n-}\n-\n-// 7.8.2.3 The strtoimax and strtoumax functions\n-#define strtoimax _strtoi64\n-#define strtoumax _strtoui64\n-\n-// 7.8.2.4 The wcstoimax and wcstoumax functions\n-#define wcstoimax _wcstoi64\n-#define wcstoumax _wcstoui64\n-\n-\n-#endif // _MSC_INTTYPES_H_ ]"}, {"sha": "d02608a5972642c7b7a13b987f21e2502a5af3ea", "filename": "src/rt/msvc/stdint.h", "status": "removed", "additions": 0, "deletions": 247, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909/src%2Frt%2Fmsvc%2Fstdint.h", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909/src%2Frt%2Fmsvc%2Fstdint.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmsvc%2Fstdint.h?ref=3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909", "patch": "@@ -1,247 +0,0 @@\n-// ISO C9x  compliant stdint.h for Microsoft Visual Studio\n-// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124 \n-// \n-//  Copyright (c) 2006-2008 Alexander Chemeris\n-// \n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions are met:\n-// \n-//   1. Redistributions of source code must retain the above copyright notice,\n-//      this list of conditions and the following disclaimer.\n-// \n-//   2. Redistributions in binary form must reproduce the above copyright\n-//      notice, this list of conditions and the following disclaimer in the\n-//      documentation and/or other materials provided with the distribution.\n-// \n-//   3. The name of the author may be used to endorse or promote products\n-//      derived from this software without specific prior written permission.\n-// \n-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n-// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n-// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n-// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n-// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n-// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n-// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n-// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n-// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-// \n-///////////////////////////////////////////////////////////////////////////////\n-\n-#ifndef _MSC_VER // [\n-#error \"Use this header only with Microsoft Visual C++ compilers!\"\n-#endif // _MSC_VER ]\n-\n-#ifndef _MSC_STDINT_H_ // [\n-#define _MSC_STDINT_H_\n-\n-#if _MSC_VER > 1000\n-#pragma once\n-#endif\n-\n-#include <limits.h>\n-\n-// For Visual Studio 6 in C++ mode and for many Visual Studio versions when\n-// compiling for ARM we should wrap <wchar.h> include with 'extern \"C++\" {}'\n-// or compiler give many errors like this:\n-//   error C2733: second C linkage of overloaded function 'wmemchr' not allowed\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-#  include <wchar.h>\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-// Define _W64 macros to mark types changing their size, like intptr_t.\n-#ifndef _W64\n-#  if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300\n-#     define _W64 __w64\n-#  else\n-#     define _W64\n-#  endif\n-#endif\n-\n-\n-// 7.18.1 Integer types\n-\n-// 7.18.1.1 Exact-width integer types\n-\n-// Visual Studio 6 and Embedded Visual C++ 4 doesn't\n-// realize that, e.g. char has the same size as __int8\n-// so we give up on __intX for them.\n-#if (_MSC_VER < 1300)\n-   typedef signed char       int8_t;\n-   typedef signed short      int16_t;\n-   typedef signed int        int32_t;\n-   typedef unsigned char     uint8_t;\n-   typedef unsigned short    uint16_t;\n-   typedef unsigned int      uint32_t;\n-#else\n-   typedef signed __int8     int8_t;\n-   typedef signed __int16    int16_t;\n-   typedef signed __int32    int32_t;\n-   typedef unsigned __int8   uint8_t;\n-   typedef unsigned __int16  uint16_t;\n-   typedef unsigned __int32  uint32_t;\n-#endif\n-typedef signed __int64       int64_t;\n-typedef unsigned __int64     uint64_t;\n-\n-\n-// 7.18.1.2 Minimum-width integer types\n-typedef int8_t    int_least8_t;\n-typedef int16_t   int_least16_t;\n-typedef int32_t   int_least32_t;\n-typedef int64_t   int_least64_t;\n-typedef uint8_t   uint_least8_t;\n-typedef uint16_t  uint_least16_t;\n-typedef uint32_t  uint_least32_t;\n-typedef uint64_t  uint_least64_t;\n-\n-// 7.18.1.3 Fastest minimum-width integer types\n-typedef int8_t    int_fast8_t;\n-typedef int16_t   int_fast16_t;\n-typedef int32_t   int_fast32_t;\n-typedef int64_t   int_fast64_t;\n-typedef uint8_t   uint_fast8_t;\n-typedef uint16_t  uint_fast16_t;\n-typedef uint32_t  uint_fast32_t;\n-typedef uint64_t  uint_fast64_t;\n-\n-// 7.18.1.4 Integer types capable of holding object pointers\n-#ifdef _WIN64 // [\n-   typedef signed __int64    intptr_t;\n-   typedef unsigned __int64  uintptr_t;\n-#else // _WIN64 ][\n-   typedef _W64 signed int   intptr_t;\n-   typedef _W64 unsigned int uintptr_t;\n-#endif // _WIN64 ]\n-\n-// 7.18.1.5 Greatest-width integer types\n-typedef int64_t   intmax_t;\n-typedef uint64_t  uintmax_t;\n-\n-\n-// 7.18.2 Limits of specified-width integer types\n-\n-#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) // [   See footnote 220 at page 257 and footnote 221 at page 259\n-\n-// 7.18.2.1 Limits of exact-width integer types\n-#define INT8_MIN     ((int8_t)_I8_MIN)\n-#define INT8_MAX     _I8_MAX\n-#define INT16_MIN    ((int16_t)_I16_MIN)\n-#define INT16_MAX    _I16_MAX\n-#define INT32_MIN    ((int32_t)_I32_MIN)\n-#define INT32_MAX    _I32_MAX\n-#define INT64_MIN    ((int64_t)_I64_MIN)\n-#define INT64_MAX    _I64_MAX\n-#define UINT8_MAX    _UI8_MAX\n-#define UINT16_MAX   _UI16_MAX\n-#define UINT32_MAX   _UI32_MAX\n-#define UINT64_MAX   _UI64_MAX\n-\n-// 7.18.2.2 Limits of minimum-width integer types\n-#define INT_LEAST8_MIN    INT8_MIN\n-#define INT_LEAST8_MAX    INT8_MAX\n-#define INT_LEAST16_MIN   INT16_MIN\n-#define INT_LEAST16_MAX   INT16_MAX\n-#define INT_LEAST32_MIN   INT32_MIN\n-#define INT_LEAST32_MAX   INT32_MAX\n-#define INT_LEAST64_MIN   INT64_MIN\n-#define INT_LEAST64_MAX   INT64_MAX\n-#define UINT_LEAST8_MAX   UINT8_MAX\n-#define UINT_LEAST16_MAX  UINT16_MAX\n-#define UINT_LEAST32_MAX  UINT32_MAX\n-#define UINT_LEAST64_MAX  UINT64_MAX\n-\n-// 7.18.2.3 Limits of fastest minimum-width integer types\n-#define INT_FAST8_MIN    INT8_MIN\n-#define INT_FAST8_MAX    INT8_MAX\n-#define INT_FAST16_MIN   INT16_MIN\n-#define INT_FAST16_MAX   INT16_MAX\n-#define INT_FAST32_MIN   INT32_MIN\n-#define INT_FAST32_MAX   INT32_MAX\n-#define INT_FAST64_MIN   INT64_MIN\n-#define INT_FAST64_MAX   INT64_MAX\n-#define UINT_FAST8_MAX   UINT8_MAX\n-#define UINT_FAST16_MAX  UINT16_MAX\n-#define UINT_FAST32_MAX  UINT32_MAX\n-#define UINT_FAST64_MAX  UINT64_MAX\n-\n-// 7.18.2.4 Limits of integer types capable of holding object pointers\n-#ifdef _WIN64 // [\n-#  define INTPTR_MIN   INT64_MIN\n-#  define INTPTR_MAX   INT64_MAX\n-#  define UINTPTR_MAX  UINT64_MAX\n-#else // _WIN64 ][\n-#  define INTPTR_MIN   INT32_MIN\n-#  define INTPTR_MAX   INT32_MAX\n-#  define UINTPTR_MAX  UINT32_MAX\n-#endif // _WIN64 ]\n-\n-// 7.18.2.5 Limits of greatest-width integer types\n-#define INTMAX_MIN   INT64_MIN\n-#define INTMAX_MAX   INT64_MAX\n-#define UINTMAX_MAX  UINT64_MAX\n-\n-// 7.18.3 Limits of other integer types\n-\n-#ifdef _WIN64 // [\n-#  define PTRDIFF_MIN  _I64_MIN\n-#  define PTRDIFF_MAX  _I64_MAX\n-#else  // _WIN64 ][\n-#  define PTRDIFF_MIN  _I32_MIN\n-#  define PTRDIFF_MAX  _I32_MAX\n-#endif  // _WIN64 ]\n-\n-#define SIG_ATOMIC_MIN  INT_MIN\n-#define SIG_ATOMIC_MAX  INT_MAX\n-\n-#ifndef SIZE_MAX // [\n-#  ifdef _WIN64 // [\n-#     define SIZE_MAX  _UI64_MAX\n-#  else // _WIN64 ][\n-#     define SIZE_MAX  _UI32_MAX\n-#  endif // _WIN64 ]\n-#endif // SIZE_MAX ]\n-\n-// WCHAR_MIN and WCHAR_MAX are also defined in <wchar.h>\n-#ifndef WCHAR_MIN // [\n-#  define WCHAR_MIN  0\n-#endif  // WCHAR_MIN ]\n-#ifndef WCHAR_MAX // [\n-#  define WCHAR_MAX  _UI16_MAX\n-#endif  // WCHAR_MAX ]\n-\n-#define WINT_MIN  0\n-#define WINT_MAX  _UI16_MAX\n-\n-#endif // __STDC_LIMIT_MACROS ]\n-\n-\n-// 7.18.4 Limits of other integer types\n-\n-#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) // [   See footnote 224 at page 260\n-\n-// 7.18.4.1 Macros for minimum-width integer constants\n-\n-#define INT8_C(val)  val##i8\n-#define INT16_C(val) val##i16\n-#define INT32_C(val) val##i32\n-#define INT64_C(val) val##i64\n-\n-#define UINT8_C(val)  val##ui8\n-#define UINT16_C(val) val##ui16\n-#define UINT32_C(val) val##ui32\n-#define UINT64_C(val) val##ui64\n-\n-// 7.18.4.2 Macros for greatest-width integer constants\n-#define INTMAX_C   INT64_C\n-#define UINTMAX_C  UINT64_C\n-\n-#endif // __STDC_CONSTANT_MACROS ]\n-\n-\n-#endif // _MSC_STDINT_H_ ]"}, {"sha": "7de08af314a5adc14b986990b838166382feef44", "filename": "src/rt/msvc/typeof.h", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909/src%2Frt%2Fmsvc%2Ftypeof.h", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909/src%2Frt%2Fmsvc%2Ftypeof.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmsvc%2Ftypeof.h?ref=3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909", "patch": "@@ -1,96 +0,0 @@\n-// This piece of magic brought to you by:\n-//     http://www.nedproductions.biz/blog/\n-//     implementing-typeof-in-microsofts-c-compiler \n-\n-#ifndef MSVC_TYPEOF_H\n-#define MSVC_TYPEOF_H\n-\n-#if defined(_MSC_VER) && _MSC_VER>=1400\n-namespace msvc_typeof_impl {\n-\t/* This is a fusion of Igor Chesnokov's method (http://rsdn.ru/forum/src/1094305.aspx)\n-\tand Steven Watanabe's method (http://lists.boost.org/Archives/boost/2006/12/115006.php)\n-\n-\tHow it works:\n-\tC++ allows template type inference for templated function parameters but nothing else.\n-\tWhat we do is to pass the expression sent to typeof() into the templated function vartypeID()\n-\tas its parameter, thus extracting its type. The big problem traditionally now is how to get\n-\tthat type out of the vartypeID() instance, and here's how we do it:\n-\t\t1. unique_type_id() returns a monotonically increasing integer for every unique type\n-\t\t   passed to it during this compilation unit. It also specialises an instance of\n-\t\t   msvc_extract_type<unique_type_id, type>::id2type_impl<true>.\n-\t\t2. vartypeID() returns a sized<unique_type_id> for the type where\n-\t\t   sizeof(sized<unique_type_id>)==unique_type_id. We vector through sized as a means\n-\t\t   of returning the unique_type_id at compile time rather than runtime.\n-\t\t3. msvc_extract_type<unique_type_id> then extracts the type by using a bug in MSVC to\n-\t\t   reselect the specialised child type (id2type_impl<true>) from within the specialisation\n-\t\t   of itself originally performed by the above instance of unique_type_id. This bug works\n-\t\t   because when MSVC calculated the signature of the specialised\n-\t\t   msvc_extract_type<unique_type_id, type>::id2type_impl<true>, it does not include the\n-\t\t   value of type in the signature of id2type_impl<true>. Therefore when we reselect\n-\t\t   msvc_extract_type<unique_type_id>::id2type_impl<true> it erroneously returns the one\n-\t\t   already in its list of instantiated types rather than correctly generating a newly\n-\t\t   specialised msvc_extract_type<unique_type_id, msvc_extract_type_default_param>::id2type_impl<true>\n-\n-\tThis bug allows the impossible and gives us a working typeof() in MSVC. Hopefully Microsoft\n-\twon't fix this bug until they implement a native typeof.\n-\t*/\n-\n-\tstruct msvc_extract_type_default_param {};\n-\ttemplate<int ID, typename T = msvc_extract_type_default_param> struct msvc_extract_type;\n-\n-\ttemplate<int ID> struct msvc_extract_type<ID, msvc_extract_type_default_param>\n-\t{\n-\t\ttemplate<bool> struct id2type_impl; \n-\n-\t\ttypedef id2type_impl<true> id2type; \n-\t};\n-\n-\ttemplate<int ID, typename T> struct msvc_extract_type : msvc_extract_type<ID, msvc_extract_type_default_param> \n-\t{ \n-\t\ttemplate<> struct id2type_impl<true> //VC8.0 specific bugfeature \n-\t\t{ \n-\t\t\ttypedef T type; \n-\t\t}; \n-\t\ttemplate<bool> struct id2type_impl; \n-\n-\t\ttypedef id2type_impl<true> id2type; \n-\t}; \n-\n-\n-\ttemplate<int N> class CCounter;\n-\n-\t// TUnused is required to force compiler to recompile CCountOf class\n-\ttemplate<typename TUnused, int NTested = 0> struct CCountOf\n-\t{\n-\t\tenum\n-\t\t{\n-\t\t\t__if_exists(CCounter<NTested>) { count = CCountOf<TUnused, NTested + 1>::count }\n-\t\t\t__if_not_exists(CCounter<NTested>) { count = NTested }\n-\t\t};\n-\t};\n-\n-\ttemplate<class TTypeReg, class TUnused, int NValue> struct CProvideCounterValue { enum { value = NValue }; };\n-\n-\t// type_id\n-\t#define unique_type_id(type) \\\n-\t\t(CProvideCounterValue< \\\n-\t\t\t/*register TYPE--ID*/ typename msvc_extract_type<CCountOf<type >::count, type>::id2type, \\\n-\t\t\t/*increment compile-time Counter*/ CCounter<CCountOf<type >::count>, \\\n-\t\t\t/*pass value of Counter*/CCountOf<type >::count \\\n-\t\t >::value)\n-\n-\t// Lets type_id() be > than 0\n-\tclass __Increment_type_id { enum { value = unique_type_id(__Increment_type_id) }; };\n-\n-\t// vartypeID() returns a type with sizeof(type_id)\n-\ttemplate<int NSize>\tclass sized { char m_pad[NSize]; };\n-\ttemplate<typename T> typename sized<unique_type_id(T)> vartypeID(T&);\n-\ttemplate<typename T> typename sized<unique_type_id(const T)> vartypeID(const T&);\n-\ttemplate<typename T> typename sized<unique_type_id(volatile  T)> vartypeID(volatile T&);\n-\ttemplate<typename T> typename sized<unique_type_id(const volatile T)> vartypeID(const volatile T&);\n-}\n-\n-#define typeof(expression) msvc_typeof_impl::msvc_extract_type<sizeof(msvc_typeof_impl::vartypeID(expression))>::id2type::type\n-#endif\n-\n-#endif"}, {"sha": "9a5eaad42433c876348676c61e6820d2475bac3b", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/cf1ff56f3c8a7a55fa38bcdda3907147d25382a2/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=cf1ff56f3c8a7a55fa38bcdda3907147d25382a2", "patch": "@@ -34,10 +34,6 @@\n #endif\n #endif\n \n-/* Foreign builtins. */\n-//include valgrind.h after stdint.h so that uintptr_t is defined for msys2 w64\n-#include \"valgrind/valgrind.h\"\n-\n char*\n rust_list_dir_val(struct dirent* entry_ptr) {\n     return entry_ptr->d_name;\n@@ -118,11 +114,6 @@ rust_get_num_cpus() {\n     return get_num_cpus();\n }\n \n-uintptr_t\n-rust_running_on_valgrind() {\n-    return RUNNING_ON_VALGRIND;\n-}\n-\n #if defined(__DragonFly__)\n #include <errno.h>\n // In DragonFly __error() is an inline function and as such"}, {"sha": "ee72707d3194e52584d8cb7f0df5fe971a95899f", "filename": "src/rt/valgrind/memcheck.h", "status": "removed", "additions": 0, "deletions": 285, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909/src%2Frt%2Fvalgrind%2Fmemcheck.h", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909/src%2Frt%2Fvalgrind%2Fmemcheck.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fvalgrind%2Fmemcheck.h?ref=3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909", "patch": "@@ -1,285 +0,0 @@\n-/*\n-   ----------------------------------------------------------------\n-\n-   Notice that the following BSD-style license applies to this one\n-   file (memcheck.h) only.  The rest of Valgrind is licensed under the\n-   terms of the GNU General Public License, version 2, unless\n-   otherwise indicated.  See the COPYING file in the source\n-   distribution for details.\n-\n-   ----------------------------------------------------------------\n-\n-   This file is part of MemCheck, a heavyweight Valgrind tool for\n-   detecting memory errors.\n-\n-   Copyright (C) 2000-2013 Julian Seward.  All rights reserved.\n-\n-   Redistribution and use in source and binary forms, with or without\n-   modification, are permitted provided that the following conditions\n-   are met:\n-\n-   1. Redistributions of source code must retain the above copyright\n-      notice, this list of conditions and the following disclaimer.\n-\n-   2. The origin of this software must not be misrepresented; you must \n-      not claim that you wrote the original software.  If you use this \n-      software in a product, an acknowledgment in the product \n-      documentation would be appreciated but is not required.\n-\n-   3. Altered source versions must be plainly marked as such, and must\n-      not be misrepresented as being the original software.\n-\n-   4. The name of the author may not be used to endorse or promote \n-      products derived from this software without specific prior written \n-      permission.\n-\n-   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\n-   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n-   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n-   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n-   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n-   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n-   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n-   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n-   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n-   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-   ----------------------------------------------------------------\n-\n-   Notice that the above BSD-style license applies to this one file\n-   (memcheck.h) only.  The entire rest of Valgrind is licensed under\n-   the terms of the GNU General Public License, version 2.  See the\n-   COPYING file in the source distribution for details.\n-\n-   ---------------------------------------------------------------- \n-*/\n-\n-\n-#ifndef __MEMCHECK_H\n-#define __MEMCHECK_H\n-\n-\n-/* This file is for inclusion into client (your!) code.\n-\n-   You can use these macros to manipulate and query memory permissions\n-   inside your own programs.\n-\n-   See comment near the top of valgrind.h on how to use them.\n-*/\n-\n-#include \"valgrind.h\"\n-\n-/* !! ABIWARNING !! ABIWARNING !! ABIWARNING !! ABIWARNING !! \n-   This enum comprises an ABI exported by Valgrind to programs\n-   which use client requests.  DO NOT CHANGE THE ORDER OF THESE\n-   ENTRIES, NOR DELETE ANY -- add new ones at the end. */\n-typedef\n-   enum { \n-      VG_USERREQ__MAKE_MEM_NOACCESS = VG_USERREQ_TOOL_BASE('M','C'),\n-      VG_USERREQ__MAKE_MEM_UNDEFINED,\n-      VG_USERREQ__MAKE_MEM_DEFINED,\n-      VG_USERREQ__DISCARD,\n-      VG_USERREQ__CHECK_MEM_IS_ADDRESSABLE,\n-      VG_USERREQ__CHECK_MEM_IS_DEFINED,\n-      VG_USERREQ__DO_LEAK_CHECK,\n-      VG_USERREQ__COUNT_LEAKS,\n-\n-      VG_USERREQ__GET_VBITS,\n-      VG_USERREQ__SET_VBITS,\n-\n-      VG_USERREQ__CREATE_BLOCK,\n-\n-      VG_USERREQ__MAKE_MEM_DEFINED_IF_ADDRESSABLE,\n-\n-      /* Not next to VG_USERREQ__COUNT_LEAKS because it was added later. */\n-      VG_USERREQ__COUNT_LEAK_BLOCKS,\n-\n-      /* This is just for memcheck's internal use - don't use it */\n-      _VG_USERREQ__MEMCHECK_RECORD_OVERLAP_ERROR \n-         = VG_USERREQ_TOOL_BASE('M','C') + 256\n-   } Vg_MemCheckClientRequest;\n-\n-\n-\n-/* Client-code macros to manipulate the state of memory. */\n-\n-/* Mark memory at _qzz_addr as unaddressable for _qzz_len bytes. */\n-#define VALGRIND_MAKE_MEM_NOACCESS(_qzz_addr,_qzz_len)           \\\n-    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,      \\\n-                            VG_USERREQ__MAKE_MEM_NOACCESS,       \\\n-                            (_qzz_addr), (_qzz_len), 0, 0, 0)\n-      \n-/* Similarly, mark memory at _qzz_addr as addressable but undefined\n-   for _qzz_len bytes. */\n-#define VALGRIND_MAKE_MEM_UNDEFINED(_qzz_addr,_qzz_len)          \\\n-    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,      \\\n-                            VG_USERREQ__MAKE_MEM_UNDEFINED,      \\\n-                            (_qzz_addr), (_qzz_len), 0, 0, 0)\n-\n-/* Similarly, mark memory at _qzz_addr as addressable and defined\n-   for _qzz_len bytes. */\n-#define VALGRIND_MAKE_MEM_DEFINED(_qzz_addr,_qzz_len)            \\\n-    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,      \\\n-                            VG_USERREQ__MAKE_MEM_DEFINED,        \\\n-                            (_qzz_addr), (_qzz_len), 0, 0, 0)\n-\n-/* Similar to VALGRIND_MAKE_MEM_DEFINED except that addressability is\n-   not altered: bytes which are addressable are marked as defined,\n-   but those which are not addressable are left unchanged. */\n-#define VALGRIND_MAKE_MEM_DEFINED_IF_ADDRESSABLE(_qzz_addr,_qzz_len)     \\\n-    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,              \\\n-                            VG_USERREQ__MAKE_MEM_DEFINED_IF_ADDRESSABLE, \\\n-                            (_qzz_addr), (_qzz_len), 0, 0, 0)\n-\n-/* Create a block-description handle.  The description is an ascii\n-   string which is included in any messages pertaining to addresses\n-   within the specified memory range.  Has no other effect on the\n-   properties of the memory range. */\n-#define VALGRIND_CREATE_BLOCK(_qzz_addr,_qzz_len, _qzz_desc)\t   \\\n-    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,        \\\n-                            VG_USERREQ__CREATE_BLOCK,              \\\n-                            (_qzz_addr), (_qzz_len), (_qzz_desc),  \\\n-                            0, 0)\n-\n-/* Discard a block-description-handle. Returns 1 for an\n-   invalid handle, 0 for a valid handle. */\n-#define VALGRIND_DISCARD(_qzz_blkindex)                          \\\n-    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,      \\\n-                            VG_USERREQ__DISCARD,                 \\\n-                            0, (_qzz_blkindex), 0, 0, 0)\n-\n-\n-/* Client-code macros to check the state of memory. */\n-\n-/* Check that memory at _qzz_addr is addressable for _qzz_len bytes.\n-   If suitable addressibility is not established, Valgrind prints an\n-   error message and returns the address of the first offending byte.\n-   Otherwise it returns zero. */\n-#define VALGRIND_CHECK_MEM_IS_ADDRESSABLE(_qzz_addr,_qzz_len)      \\\n-    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                             \\\n-                            VG_USERREQ__CHECK_MEM_IS_ADDRESSABLE,  \\\n-                            (_qzz_addr), (_qzz_len), 0, 0, 0)\n-\n-/* Check that memory at _qzz_addr is addressable and defined for\n-   _qzz_len bytes.  If suitable addressibility and definedness are not\n-   established, Valgrind prints an error message and returns the\n-   address of the first offending byte.  Otherwise it returns zero. */\n-#define VALGRIND_CHECK_MEM_IS_DEFINED(_qzz_addr,_qzz_len)        \\\n-    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                           \\\n-                            VG_USERREQ__CHECK_MEM_IS_DEFINED,    \\\n-                            (_qzz_addr), (_qzz_len), 0, 0, 0)\n-\n-/* Use this macro to force the definedness and addressibility of an\n-   lvalue to be checked.  If suitable addressibility and definedness\n-   are not established, Valgrind prints an error message and returns\n-   the address of the first offending byte.  Otherwise it returns\n-   zero. */\n-#define VALGRIND_CHECK_VALUE_IS_DEFINED(__lvalue)                \\\n-   VALGRIND_CHECK_MEM_IS_DEFINED(                                \\\n-      (volatile unsigned char *)&(__lvalue),                     \\\n-                      (unsigned long)(sizeof (__lvalue)))\n-\n-\n-/* Do a full memory leak check (like --leak-check=full) mid-execution. */\n-#define VALGRIND_DO_LEAK_CHECK                                   \\\n-    VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__DO_LEAK_CHECK,   \\\n-                                    0, 0, 0, 0, 0)\n-\n-/* Same as VALGRIND_DO_LEAK_CHECK but only showing the entries for\n-   which there was an increase in leaked bytes or leaked nr of blocks\n-   since the previous leak search. */\n-#define VALGRIND_DO_ADDED_LEAK_CHECK                            \\\n-    VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__DO_LEAK_CHECK,  \\\n-                                    0, 1, 0, 0, 0)\n-\n-/* Same as VALGRIND_DO_ADDED_LEAK_CHECK but showing entries with\n-   increased or decreased leaked bytes/blocks since previous leak\n-   search. */\n-#define VALGRIND_DO_CHANGED_LEAK_CHECK                          \\\n-    VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__DO_LEAK_CHECK,  \\\n-                                    0, 2, 0, 0, 0)\n-\n-/* Do a summary memory leak check (like --leak-check=summary) mid-execution. */\n-#define VALGRIND_DO_QUICK_LEAK_CHECK                             \\\n-    VALGRIND_DO_CLIENT_REQUEST_STMT(VG_USERREQ__DO_LEAK_CHECK,   \\\n-                                    1, 0, 0, 0, 0)\n-\n-/* Return number of leaked, dubious, reachable and suppressed bytes found by\n-   all previous leak checks.  They must be lvalues.  */\n-#define VALGRIND_COUNT_LEAKS(leaked, dubious, reachable, suppressed)     \\\n-   /* For safety on 64-bit platforms we assign the results to private\n-      unsigned long variables, then assign these to the lvalues the user\n-      specified, which works no matter what type 'leaked', 'dubious', etc\n-      are.  We also initialise '_qzz_leaked', etc because\n-      VG_USERREQ__COUNT_LEAKS doesn't mark the values returned as\n-      defined. */                                                        \\\n-   {                                                                     \\\n-    unsigned long _qzz_leaked    = 0, _qzz_dubious    = 0;               \\\n-    unsigned long _qzz_reachable = 0, _qzz_suppressed = 0;               \\\n-    VALGRIND_DO_CLIENT_REQUEST_STMT(                                     \\\n-                               VG_USERREQ__COUNT_LEAKS,                  \\\n-                               &_qzz_leaked, &_qzz_dubious,              \\\n-                               &_qzz_reachable, &_qzz_suppressed, 0);    \\\n-    leaked     = _qzz_leaked;                                            \\\n-    dubious    = _qzz_dubious;                                           \\\n-    reachable  = _qzz_reachable;                                         \\\n-    suppressed = _qzz_suppressed;                                        \\\n-   }\n-\n-/* Return number of leaked, dubious, reachable and suppressed bytes found by\n-   all previous leak checks.  They must be lvalues.  */\n-#define VALGRIND_COUNT_LEAK_BLOCKS(leaked, dubious, reachable, suppressed) \\\n-   /* For safety on 64-bit platforms we assign the results to private\n-      unsigned long variables, then assign these to the lvalues the user\n-      specified, which works no matter what type 'leaked', 'dubious', etc\n-      are.  We also initialise '_qzz_leaked', etc because\n-      VG_USERREQ__COUNT_LEAKS doesn't mark the values returned as\n-      defined. */                                                        \\\n-   {                                                                     \\\n-    unsigned long _qzz_leaked    = 0, _qzz_dubious    = 0;               \\\n-    unsigned long _qzz_reachable = 0, _qzz_suppressed = 0;               \\\n-    VALGRIND_DO_CLIENT_REQUEST_STMT(                                     \\\n-                               VG_USERREQ__COUNT_LEAK_BLOCKS,            \\\n-                               &_qzz_leaked, &_qzz_dubious,              \\\n-                               &_qzz_reachable, &_qzz_suppressed, 0);    \\\n-    leaked     = _qzz_leaked;                                            \\\n-    dubious    = _qzz_dubious;                                           \\\n-    reachable  = _qzz_reachable;                                         \\\n-    suppressed = _qzz_suppressed;                                        \\\n-   }\n-\n-\n-/* Get the validity data for addresses [zza..zza+zznbytes-1] and copy it\n-   into the provided zzvbits array.  Return values:\n-      0   if not running on valgrind\n-      1   success\n-      2   [previously indicated unaligned arrays;  these are now allowed]\n-      3   if any parts of zzsrc/zzvbits are not addressable.\n-   The metadata is not copied in cases 0, 2 or 3 so it should be\n-   impossible to segfault your system by using this call.\n-*/\n-#define VALGRIND_GET_VBITS(zza,zzvbits,zznbytes)                \\\n-    (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                \\\n-                                    VG_USERREQ__GET_VBITS,      \\\n-                                    (const char*)(zza),         \\\n-                                    (char*)(zzvbits),           \\\n-                                    (zznbytes), 0, 0)\n-\n-/* Set the validity data for addresses [zza..zza+zznbytes-1], copying it\n-   from the provided zzvbits array.  Return values:\n-      0   if not running on valgrind\n-      1   success\n-      2   [previously indicated unaligned arrays;  these are now allowed]\n-      3   if any parts of zza/zzvbits are not addressable.\n-   The metadata is not copied in cases 0, 2 or 3 so it should be\n-   impossible to segfault your system by using this call.\n-*/\n-#define VALGRIND_SET_VBITS(zza,zzvbits,zznbytes)                \\\n-    (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                \\\n-                                    VG_USERREQ__SET_VBITS,      \\\n-                                    (const char*)(zza),         \\\n-                                    (const char*)(zzvbits),     \\\n-                                    (zznbytes), 0, 0 )\n-\n-#endif"}, {"sha": "51f9de8edf057541e005040ad6da030a998070b9", "filename": "src/rt/valgrind/valgrind.h", "status": "removed", "additions": 0, "deletions": 5414, "changes": 5414, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909/src%2Frt%2Fvalgrind%2Fvalgrind.h", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909/src%2Frt%2Fvalgrind%2Fvalgrind.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fvalgrind%2Fvalgrind.h?ref=3e6b03c2d87a1f54bfde2ea82b1f85aa4df04909"}]}