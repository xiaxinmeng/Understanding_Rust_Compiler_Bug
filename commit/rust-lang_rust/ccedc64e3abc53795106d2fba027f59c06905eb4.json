{"sha": "ccedc64e3abc53795106d2fba027f59c06905eb4", "node_id": "C_kwDOAAsO6NoAKGNjZWRjNjRlM2FiYzUzNzk1MTA2ZDJmYmEwMjdmNTljMDY5MDVlYjQ", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2022-04-15T09:37:58Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2022-04-17T22:51:28Z"}, "message": "Add `#[clippy::print_hir]` attribute for debugging", "tree": {"sha": "de54101e1e6df0fa51e0378466c8ebc4a08612a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de54101e1e6df0fa51e0378466c8ebc4a08612a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccedc64e3abc53795106d2fba027f59c06905eb4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEsfZNmu/fmIv8KDcv/Ny/Ka9k1gEFAmJcmfAACgkQ/Ny/Ka9k\n1gH2Ig/7BOhsQGNV/Rdt/GhZx70C7GXrNrlm2HHnf3lo7TpwPJF1ncV/16unZuCz\nxaA9//lZWuHRWU62Z5YN1ypmMzozHENaSqe0MjXV//b8q7rqafQsmnDGAoARBL3/\nujAHf0L/+YdF+tfa3vIFgECd6v1299r5EQ7pAxzX9CA5COitA9UfYVKHCpk6mjHG\n0/qoEpYuMiFL7s/IeP9sRzW1ZFKLfstLawI7GiApxAf/S0aEWGaNI5wElm4grX8D\n9qR6Ml9DRQ84cWt90Hy0OdOd7hIUbdPHCXrYV+/BMSukIbQ5qquaphYWrYrgxjyG\nmMQ6fCxff2ya0nat/+2odi/AYB8u58FM1ahSDWa2AxiZ8++8CGcCmRNSsPZcWKRd\nnjHWL2H3e4t+1bpy7pDAnrJiOKWnrcNwwZvDbSaJpAhlyfmHKOaMgpVMqPvY2fTT\nQRWxNaDFmlWEQ95dkayCy1eY72UjBPTkuj9fjP3ETm2US7J5wbY37DAAPW4uzc+9\nHHSwJ9XUkkKobz4RfXo0oSuMztNCM5xDaNLuMb/S+jm5W41Pj8xcj7gRcmS9MJ9q\nuCn4q0wFQEi90e5N+bX2TXzCdYnBWTcXscRRFDtLnbO5X0zUTbSuUherl8bfJ3Ks\n0myrfbEqjHFTn9oHG8wXmWWd22ko4udSD0OGO9ko3nrh+hmpEIg=\n=A7fF\n-----END PGP SIGNATURE-----", "payload": "tree de54101e1e6df0fa51e0378466c8ebc4a08612a2\nparent b6645d022e492a20da31123f8aff5b5af3eb31c9\nauthor xFrednet <xFrednet@gmail.com> 1650015478 +0200\ncommitter xFrednet <xFrednet@gmail.com> 1650235888 +0200\n\nAdd `#[clippy::print_hir]` attribute for debugging\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccedc64e3abc53795106d2fba027f59c06905eb4", "html_url": "https://github.com/rust-lang/rust/commit/ccedc64e3abc53795106d2fba027f59c06905eb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccedc64e3abc53795106d2fba027f59c06905eb4/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6645d022e492a20da31123f8aff5b5af3eb31c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6645d022e492a20da31123f8aff5b5af3eb31c9", "html_url": "https://github.com/rust-lang/rust/commit/b6645d022e492a20da31123f8aff5b5af3eb31c9"}], "stats": {"total": 630, "additions": 72, "deletions": 558}, "files": [{"sha": "c5d02ca278e94adaedc8016100cbe87a531e1d90", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccedc64e3abc53795106d2fba027f59c06905eb4/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccedc64e3abc53795106d2fba027f59c06905eb4/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ccedc64e3abc53795106d2fba027f59c06905eb4", "patch": "@@ -501,7 +501,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     {\n         store.register_early_pass(|| Box::new(utils::internal_lints::ClippyLintsInternal));\n         store.register_early_pass(|| Box::new(utils::internal_lints::ProduceIce));\n-        store.register_late_pass(|| Box::new(utils::inspector::DeepCodeInspector));\n         store.register_late_pass(|| Box::new(utils::internal_lints::CollapsibleCalls));\n         store.register_late_pass(|| Box::new(utils::internal_lints::CompilerLintFunctions::new()));\n         store.register_late_pass(|| Box::new(utils::internal_lints::IfChainStyle));\n@@ -513,6 +512,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         store.register_late_pass(|| Box::new(utils::internal_lints::MsrvAttrImpl));\n     }\n \n+    store.register_late_pass(|| Box::new(utils::dump_hir::DumpHir));\n     store.register_late_pass(|| Box::new(utils::author::Author));\n     store.register_late_pass(|| Box::new(await_holding_invalid::AwaitHolding));\n     store.register_late_pass(|| Box::new(serde_api::SerdeApi));"}, {"sha": "01efc527a8c3abaf5e49f574769657a2312d35d8", "filename": "clippy_lints/src/utils/dump_hir.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ccedc64e3abc53795106d2fba027f59c06905eb4/clippy_lints%2Fsrc%2Futils%2Fdump_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccedc64e3abc53795106d2fba027f59c06905eb4/clippy_lints%2Fsrc%2Futils%2Fdump_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fdump_hir.rs?ref=ccedc64e3abc53795106d2fba027f59c06905eb4", "patch": "@@ -0,0 +1,55 @@\n+use clippy_utils::get_attr;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// It formats the attached node with `{:#?}` and writes the result to the\n+    /// standard output. This is intended for debugging.\n+    ///\n+    /// ### Examples\n+    /// ```rs\n+    /// #[clippy::dump]\n+    /// use std::mem;\n+    ///\n+    /// #[clippy::dump]\n+    /// fn foo(input: u32) -> u64 {\n+    ///     input as u64\n+    /// }\n+    /// ```\n+    pub DUMP_HIR,\n+    internal_warn,\n+    \"helper to dump info about code\"\n+}\n+\n+declare_lint_pass!(DumpHir => [DUMP_HIR]);\n+\n+impl<'tcx> LateLintPass<'tcx> for DumpHir {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+        if has_attr(cx, item.hir_id()) {\n+            println!(\"{item:#?}\");\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if has_attr(cx, expr.hir_id) {\n+            println!(\"{expr:#?}\");\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n+        match stmt.kind {\n+            hir::StmtKind::Expr(e) | hir::StmtKind::Semi(e) if has_attr(cx, e.hir_id) => return,\n+            _ => {},\n+        }\n+        if has_attr(cx, stmt.hir_id) {\n+            println!(\"{stmt:#?}\");\n+        }\n+    }\n+}\n+\n+fn has_attr(cx: &LateContext<'_>, hir_id: hir::HirId) -> bool {\n+    let attrs = cx.tcx.hir().attrs(hir_id);\n+    get_attr(cx.sess(), attrs, \"dump\").count() > 0\n+}"}, {"sha": "dc48ea3f4f99d77612cfcb3a4e48fab6dabf8f5a", "filename": "clippy_lints/src/utils/inspector.rs", "status": "removed", "additions": 0, "deletions": 555, "changes": 555, "blob_url": "https://github.com/rust-lang/rust/blob/b6645d022e492a20da31123f8aff5b5af3eb31c9/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6645d022e492a20da31123f8aff5b5af3eb31c9/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=b6645d022e492a20da31123f8aff5b5af3eb31c9", "patch": "@@ -1,555 +0,0 @@\n-//! checks for attributes\n-\n-use clippy_utils::get_attr;\n-use rustc_ast::ast::{Attribute, InlineAsmTemplatePiece};\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_session::Session;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Dumps every ast/hir node which has the `#[clippy::dump]`\n-    /// attribute\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// #[clippy::dump]\n-    /// extern crate foo;\n-    /// ```\n-    ///\n-    /// prints\n-    ///\n-    /// ```text\n-    /// item `foo`\n-    /// visibility inherited from outer item\n-    /// extern crate dylib source: \"/path/to/foo.so\"\n-    /// ```\n-    pub DEEP_CODE_INSPECTION,\n-    internal_warn,\n-    \"helper to dump info about code\"\n-}\n-\n-declare_lint_pass!(DeepCodeInspector => [DEEP_CODE_INSPECTION]);\n-\n-impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        if !has_attr(cx.sess(), cx.tcx.hir().attrs(item.hir_id())) {\n-            return;\n-        }\n-        print_item(cx, item);\n-    }\n-\n-    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n-        if !has_attr(cx.sess(), cx.tcx.hir().attrs(item.hir_id())) {\n-            return;\n-        }\n-        println!(\"impl item `{}`\", item.ident.name);\n-        match item.vis.node {\n-            hir::VisibilityKind::Public => println!(\"public\"),\n-            hir::VisibilityKind::Crate(_) => println!(\"visible crate wide\"),\n-            hir::VisibilityKind::Restricted { path, .. } => println!(\n-                \"visible in module `{}`\",\n-                rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(path, false))\n-            ),\n-            hir::VisibilityKind::Inherited => println!(\"visibility inherited from outer item\"),\n-        }\n-        match item.kind {\n-            hir::ImplItemKind::Const(_, body_id) => {\n-                println!(\"associated constant\");\n-                print_expr(cx, &cx.tcx.hir().body(body_id).value, 1);\n-            },\n-            hir::ImplItemKind::Fn(..) => println!(\"method\"),\n-            hir::ImplItemKind::TyAlias(_) => println!(\"associated type\"),\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if !has_attr(cx.sess(), cx.tcx.hir().attrs(expr.hir_id)) {\n-            return;\n-        }\n-        print_expr(cx, expr, 0);\n-    }\n-\n-    fn check_arm(&mut self, cx: &LateContext<'tcx>, arm: &'tcx hir::Arm<'_>) {\n-        if !has_attr(cx.sess(), cx.tcx.hir().attrs(arm.hir_id)) {\n-            return;\n-        }\n-        print_pat(cx, arm.pat, 1);\n-        if let Some(ref guard) = arm.guard {\n-            println!(\"guard:\");\n-            print_guard(cx, guard, 1);\n-        }\n-        println!(\"body:\");\n-        print_expr(cx, arm.body, 1);\n-    }\n-\n-    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n-        if !has_attr(cx.sess(), cx.tcx.hir().attrs(stmt.hir_id)) {\n-            return;\n-        }\n-        match stmt.kind {\n-            hir::StmtKind::Local(local) => {\n-                println!(\"local variable of type {}\", cx.typeck_results().node_type(local.hir_id));\n-                println!(\"pattern:\");\n-                print_pat(cx, local.pat, 0);\n-                if let Some(e) = local.init {\n-                    println!(\"init expression:\");\n-                    print_expr(cx, e, 0);\n-                }\n-            },\n-            hir::StmtKind::Item(_) => println!(\"item decl\"),\n-            hir::StmtKind::Expr(e) | hir::StmtKind::Semi(e) => print_expr(cx, e, 0),\n-        }\n-    }\n-}\n-\n-fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n-    get_attr(sess, attrs, \"dump\").count() > 0\n-}\n-\n-#[allow(clippy::similar_names)]\n-#[allow(clippy::too_many_lines)]\n-fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n-    let ind = \"  \".repeat(indent);\n-    println!(\"{}+\", ind);\n-    println!(\"{}ty: {}\", ind, cx.typeck_results().expr_ty(expr));\n-    println!(\n-        \"{}adjustments: {:?}\",\n-        ind,\n-        cx.typeck_results().adjustments().get(expr.hir_id)\n-    );\n-    match expr.kind {\n-        hir::ExprKind::Box(e) => {\n-            println!(\"{}Box\", ind);\n-            print_expr(cx, e, indent + 1);\n-        },\n-        hir::ExprKind::Array(v) => {\n-            println!(\"{}Array\", ind);\n-            for e in v {\n-                print_expr(cx, e, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::Call(func, args) => {\n-            println!(\"{}Call\", ind);\n-            println!(\"{}function:\", ind);\n-            print_expr(cx, func, indent + 1);\n-            println!(\"{}arguments:\", ind);\n-            for arg in args {\n-                print_expr(cx, arg, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::Let(hir::Let { pat, init, ty, .. }) => {\n-            print_pat(cx, pat, indent + 1);\n-            if let Some(ty) = ty {\n-                println!(\"{}  type annotation: {:?}\", ind, ty);\n-            }\n-            print_expr(cx, init, indent + 1);\n-        },\n-        hir::ExprKind::MethodCall(path, args, _) => {\n-            println!(\"{}MethodCall\", ind);\n-            println!(\"{}method name: {}\", ind, path.ident.name);\n-            for arg in args {\n-                print_expr(cx, arg, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::Tup(v) => {\n-            println!(\"{}Tup\", ind);\n-            for e in v {\n-                print_expr(cx, e, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::Binary(op, lhs, rhs) => {\n-            println!(\"{}Binary\", ind);\n-            println!(\"{}op: {:?}\", ind, op.node);\n-            println!(\"{}lhs:\", ind);\n-            print_expr(cx, lhs, indent + 1);\n-            println!(\"{}rhs:\", ind);\n-            print_expr(cx, rhs, indent + 1);\n-        },\n-        hir::ExprKind::Unary(op, inner) => {\n-            println!(\"{}Unary\", ind);\n-            println!(\"{}op: {:?}\", ind, op);\n-            print_expr(cx, inner, indent + 1);\n-        },\n-        hir::ExprKind::Lit(ref lit) => {\n-            println!(\"{}Lit\", ind);\n-            println!(\"{}{:?}\", ind, lit);\n-        },\n-        hir::ExprKind::Cast(e, target) => {\n-            println!(\"{}Cast\", ind);\n-            print_expr(cx, e, indent + 1);\n-            println!(\"{}target type: {:?}\", ind, target);\n-        },\n-        hir::ExprKind::Type(e, target) => {\n-            println!(\"{}Type\", ind);\n-            print_expr(cx, e, indent + 1);\n-            println!(\"{}target type: {:?}\", ind, target);\n-        },\n-        hir::ExprKind::Loop(..) => {\n-            println!(\"{}Loop\", ind);\n-        },\n-        hir::ExprKind::If(cond, _, ref else_opt) => {\n-            println!(\"{}If\", ind);\n-            println!(\"{}condition:\", ind);\n-            print_expr(cx, cond, indent + 1);\n-            if let Some(els) = *else_opt {\n-                println!(\"{}else:\", ind);\n-                print_expr(cx, els, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::Match(cond, _, ref source) => {\n-            println!(\"{}Match\", ind);\n-            println!(\"{}condition:\", ind);\n-            print_expr(cx, cond, indent + 1);\n-            println!(\"{}source: {:?}\", ind, source);\n-        },\n-        hir::ExprKind::Closure(ref clause, _, _, _, _) => {\n-            println!(\"{}Closure\", ind);\n-            println!(\"{}clause: {:?}\", ind, clause);\n-        },\n-        hir::ExprKind::Yield(sub, _) => {\n-            println!(\"{}Yield\", ind);\n-            print_expr(cx, sub, indent + 1);\n-        },\n-        hir::ExprKind::Block(_, _) => {\n-            println!(\"{}Block\", ind);\n-        },\n-        hir::ExprKind::Assign(lhs, rhs, _) => {\n-            println!(\"{}Assign\", ind);\n-            println!(\"{}lhs:\", ind);\n-            print_expr(cx, lhs, indent + 1);\n-            println!(\"{}rhs:\", ind);\n-            print_expr(cx, rhs, indent + 1);\n-        },\n-        hir::ExprKind::AssignOp(ref binop, lhs, rhs) => {\n-            println!(\"{}AssignOp\", ind);\n-            println!(\"{}op: {:?}\", ind, binop.node);\n-            println!(\"{}lhs:\", ind);\n-            print_expr(cx, lhs, indent + 1);\n-            println!(\"{}rhs:\", ind);\n-            print_expr(cx, rhs, indent + 1);\n-        },\n-        hir::ExprKind::Field(e, ident) => {\n-            println!(\"{}Field\", ind);\n-            println!(\"{}field name: {}\", ind, ident.name);\n-            println!(\"{}struct expr:\", ind);\n-            print_expr(cx, e, indent + 1);\n-        },\n-        hir::ExprKind::Index(arr, idx) => {\n-            println!(\"{}Index\", ind);\n-            println!(\"{}array expr:\", ind);\n-            print_expr(cx, arr, indent + 1);\n-            println!(\"{}index expr:\", ind);\n-            print_expr(cx, idx, indent + 1);\n-        },\n-        hir::ExprKind::Path(hir::QPath::Resolved(ref ty, path)) => {\n-            println!(\"{}Resolved Path, {:?}\", ind, ty);\n-            println!(\"{}path: {:?}\", ind, path);\n-        },\n-        hir::ExprKind::Path(hir::QPath::TypeRelative(ty, seg)) => {\n-            println!(\"{}Relative Path, {:?}\", ind, ty);\n-            println!(\"{}seg: {:?}\", ind, seg);\n-        },\n-        hir::ExprKind::Path(hir::QPath::LangItem(lang_item, ..)) => {\n-            println!(\"{}Lang Item Path, {:?}\", ind, lang_item.name());\n-        },\n-        hir::ExprKind::AddrOf(kind, ref muta, e) => {\n-            println!(\"{}AddrOf\", ind);\n-            println!(\"kind: {:?}\", kind);\n-            println!(\"mutability: {:?}\", muta);\n-            print_expr(cx, e, indent + 1);\n-        },\n-        hir::ExprKind::Break(_, ref e) => {\n-            println!(\"{}Break\", ind);\n-            if let Some(e) = *e {\n-                print_expr(cx, e, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::Continue(_) => println!(\"{}Again\", ind),\n-        hir::ExprKind::Ret(ref e) => {\n-            println!(\"{}Ret\", ind);\n-            if let Some(e) = *e {\n-                print_expr(cx, e, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::InlineAsm(asm) => {\n-            println!(\"{}InlineAsm\", ind);\n-            println!(\"{}template: {}\", ind, InlineAsmTemplatePiece::to_string(asm.template));\n-            println!(\"{}options: {:?}\", ind, asm.options);\n-            println!(\"{}operands:\", ind);\n-            for (op, _op_sp) in asm.operands {\n-                match op {\n-                    hir::InlineAsmOperand::In { expr, .. }\n-                    | hir::InlineAsmOperand::InOut { expr, .. }\n-                    | hir::InlineAsmOperand::Sym { expr } => print_expr(cx, expr, indent + 1),\n-                    hir::InlineAsmOperand::Out { expr, .. } => {\n-                        if let Some(expr) = expr {\n-                            print_expr(cx, expr, indent + 1);\n-                        }\n-                    },\n-                    hir::InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                        print_expr(cx, in_expr, indent + 1);\n-                        if let Some(out_expr) = out_expr {\n-                            print_expr(cx, out_expr, indent + 1);\n-                        }\n-                    },\n-                    hir::InlineAsmOperand::Const { anon_const } => {\n-                        println!(\"{}anon_const:\", ind);\n-                        print_expr(cx, &cx.tcx.hir().body(anon_const.body).value, indent + 1);\n-                    },\n-                }\n-            }\n-        },\n-        hir::ExprKind::Struct(path, fields, ref base) => {\n-            println!(\"{}Struct\", ind);\n-            println!(\"{}path: {:?}\", ind, path);\n-            for field in fields {\n-                println!(\"{}field \\\"{}\\\":\", ind, field.ident.name);\n-                print_expr(cx, field.expr, indent + 1);\n-            }\n-            if let Some(base) = *base {\n-                println!(\"{}base:\", ind);\n-                print_expr(cx, base, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::ConstBlock(ref anon_const) => {\n-            println!(\"{}ConstBlock\", ind);\n-            println!(\"{}anon_const:\", ind);\n-            print_expr(cx, &cx.tcx.hir().body(anon_const.body).value, indent + 1);\n-        },\n-        hir::ExprKind::Repeat(val, length) => {\n-            println!(\"{}Repeat\", ind);\n-            println!(\"{}value:\", ind);\n-            print_expr(cx, val, indent + 1);\n-            println!(\"{}repeat count:\", ind);\n-            match length {\n-                hir::ArrayLen::Infer(_, _) => println!(\"{}repeat count: _\", ind),\n-                hir::ArrayLen::Body(anon_const) => {\n-                    print_expr(cx, &cx.tcx.hir().body(anon_const.body).value, indent + 1);\n-                },\n-            }\n-        },\n-        hir::ExprKind::Err => {\n-            println!(\"{}Err\", ind);\n-        },\n-        hir::ExprKind::DropTemps(e) => {\n-            println!(\"{}DropTemps\", ind);\n-            print_expr(cx, e, indent + 1);\n-        },\n-    }\n-}\n-\n-fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-    let did = item.def_id;\n-    println!(\"item `{}`\", item.ident.name);\n-    match item.vis.node {\n-        hir::VisibilityKind::Public => println!(\"public\"),\n-        hir::VisibilityKind::Crate(_) => println!(\"visible crate wide\"),\n-        hir::VisibilityKind::Restricted { path, .. } => println!(\n-            \"visible in module `{}`\",\n-            rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(path, false))\n-        ),\n-        hir::VisibilityKind::Inherited => println!(\"visibility inherited from outer item\"),\n-    }\n-    match item.kind {\n-        hir::ItemKind::ExternCrate(ref _renamed_from) => {\n-            if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(did) {\n-                let source = cx.tcx.used_crate_source(crate_id);\n-                if let Some(ref src) = source.dylib {\n-                    println!(\"extern crate dylib source: {:?}\", src.0);\n-                }\n-                if let Some(ref src) = source.rlib {\n-                    println!(\"extern crate rlib source: {:?}\", src.0);\n-                }\n-            } else {\n-                println!(\"weird extern crate without a crate id\");\n-            }\n-        },\n-        hir::ItemKind::Use(path, ref kind) => println!(\"{:?}, {:?}\", path, kind),\n-        hir::ItemKind::Static(..) => println!(\"static item of type {:#?}\", cx.tcx.type_of(did)),\n-        hir::ItemKind::Const(..) => println!(\"const item of type {:#?}\", cx.tcx.type_of(did)),\n-        hir::ItemKind::Fn(..) => {\n-            let item_ty = cx.tcx.type_of(did);\n-            println!(\"function of type {:#?}\", item_ty);\n-        },\n-        hir::ItemKind::Macro(ref macro_def, _) => {\n-            if macro_def.macro_rules {\n-                println!(\"macro introduced by `macro_rules!`\");\n-            } else {\n-                println!(\"macro introduced by `macro`\");\n-            }\n-        },\n-        hir::ItemKind::Mod(..) => println!(\"module\"),\n-        hir::ItemKind::ForeignMod { abi, .. } => println!(\"foreign module with abi: {}\", abi),\n-        hir::ItemKind::GlobalAsm(asm) => println!(\"global asm: {:?}\", asm),\n-        hir::ItemKind::TyAlias(..) => {\n-            println!(\"type alias for {:?}\", cx.tcx.type_of(did));\n-        },\n-        hir::ItemKind::OpaqueTy(..) => {\n-            println!(\"existential type with real type {:?}\", cx.tcx.type_of(did));\n-        },\n-        hir::ItemKind::Enum(..) => {\n-            println!(\"enum definition of type {:?}\", cx.tcx.type_of(did));\n-        },\n-        hir::ItemKind::Struct(..) => {\n-            println!(\"struct definition of type {:?}\", cx.tcx.type_of(did));\n-        },\n-        hir::ItemKind::Union(..) => {\n-            println!(\"union definition of type {:?}\", cx.tcx.type_of(did));\n-        },\n-        hir::ItemKind::Trait(..) => {\n-            println!(\"trait decl\");\n-            if cx.tcx.trait_is_auto(did.to_def_id()) {\n-                println!(\"trait is auto\");\n-            } else {\n-                println!(\"trait is not auto\");\n-            }\n-        },\n-        hir::ItemKind::TraitAlias(..) => {\n-            println!(\"trait alias\");\n-        },\n-        hir::ItemKind::Impl(hir::Impl {\n-            of_trait: Some(ref _trait_ref),\n-            ..\n-        }) => {\n-            println!(\"trait impl\");\n-        },\n-        hir::ItemKind::Impl(hir::Impl { of_trait: None, .. }) => {\n-            println!(\"impl\");\n-        },\n-    }\n-}\n-\n-#[allow(clippy::similar_names)]\n-#[allow(clippy::too_many_lines)]\n-fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n-    let ind = \"  \".repeat(indent);\n-    println!(\"{}+\", ind);\n-    match pat.kind {\n-        hir::PatKind::Wild => println!(\"{}Wild\", ind),\n-        hir::PatKind::Binding(ref mode, .., ident, ref inner) => {\n-            println!(\"{}Binding\", ind);\n-            println!(\"{}mode: {:?}\", ind, mode);\n-            println!(\"{}name: {}\", ind, ident.name);\n-            if let Some(inner) = *inner {\n-                println!(\"{}inner:\", ind);\n-                print_pat(cx, inner, indent + 1);\n-            }\n-        },\n-        hir::PatKind::Or(fields) => {\n-            println!(\"{}Or\", ind);\n-            for field in fields {\n-                print_pat(cx, field, indent + 1);\n-            }\n-        },\n-        hir::PatKind::Struct(ref path, fields, ignore) => {\n-            println!(\"{}Struct\", ind);\n-            println!(\n-                \"{}name: {}\",\n-                ind,\n-                rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false))\n-            );\n-            println!(\"{}ignore leftover fields: {}\", ind, ignore);\n-            println!(\"{}fields:\", ind);\n-            for field in fields {\n-                println!(\"{}  field name: {}\", ind, field.ident.name);\n-                if field.is_shorthand {\n-                    println!(\"{}  in shorthand notation\", ind);\n-                }\n-                print_pat(cx, field.pat, indent + 1);\n-            }\n-        },\n-        hir::PatKind::TupleStruct(ref path, fields, opt_dots_position) => {\n-            println!(\"{}TupleStruct\", ind);\n-            println!(\n-                \"{}path: {}\",\n-                ind,\n-                rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false))\n-            );\n-            if let Some(dot_position) = opt_dots_position {\n-                println!(\"{}dot position: {}\", ind, dot_position);\n-            }\n-            for field in fields {\n-                print_pat(cx, field, indent + 1);\n-            }\n-        },\n-        hir::PatKind::Path(hir::QPath::Resolved(ref ty, path)) => {\n-            println!(\"{}Resolved Path, {:?}\", ind, ty);\n-            println!(\"{}path: {:?}\", ind, path);\n-        },\n-        hir::PatKind::Path(hir::QPath::TypeRelative(ty, seg)) => {\n-            println!(\"{}Relative Path, {:?}\", ind, ty);\n-            println!(\"{}seg: {:?}\", ind, seg);\n-        },\n-        hir::PatKind::Path(hir::QPath::LangItem(lang_item, ..)) => {\n-            println!(\"{}Lang Item Path, {:?}\", ind, lang_item.name());\n-        },\n-        hir::PatKind::Tuple(pats, opt_dots_position) => {\n-            println!(\"{}Tuple\", ind);\n-            if let Some(dot_position) = opt_dots_position {\n-                println!(\"{}dot position: {}\", ind, dot_position);\n-            }\n-            for field in pats {\n-                print_pat(cx, field, indent + 1);\n-            }\n-        },\n-        hir::PatKind::Box(inner) => {\n-            println!(\"{}Box\", ind);\n-            print_pat(cx, inner, indent + 1);\n-        },\n-        hir::PatKind::Ref(inner, ref muta) => {\n-            println!(\"{}Ref\", ind);\n-            println!(\"{}mutability: {:?}\", ind, muta);\n-            print_pat(cx, inner, indent + 1);\n-        },\n-        hir::PatKind::Lit(e) => {\n-            println!(\"{}Lit\", ind);\n-            print_expr(cx, e, indent + 1);\n-        },\n-        hir::PatKind::Range(ref l, ref r, ref range_end) => {\n-            println!(\"{}Range\", ind);\n-            if let Some(expr) = l {\n-                print_expr(cx, expr, indent + 1);\n-            }\n-            if let Some(expr) = r {\n-                print_expr(cx, expr, indent + 1);\n-            }\n-            match *range_end {\n-                hir::RangeEnd::Included => println!(\"{} end included\", ind),\n-                hir::RangeEnd::Excluded => println!(\"{} end excluded\", ind),\n-            }\n-        },\n-        hir::PatKind::Slice(first_pats, ref range, last_pats) => {\n-            println!(\"{}Slice [a, b, ..i, y, z]\", ind);\n-            println!(\"[a, b]:\");\n-            for pat in first_pats {\n-                print_pat(cx, pat, indent + 1);\n-            }\n-            println!(\"i:\");\n-            if let Some(pat) = *range {\n-                print_pat(cx, pat, indent + 1);\n-            }\n-            println!(\"[y, z]:\");\n-            for pat in last_pats {\n-                print_pat(cx, pat, indent + 1);\n-            }\n-        },\n-    }\n-}\n-\n-fn print_guard(cx: &LateContext<'_>, guard: &hir::Guard<'_>, indent: usize) {\n-    let ind = \"  \".repeat(indent);\n-    println!(\"{}+\", ind);\n-    match guard {\n-        hir::Guard::If(expr) => {\n-            println!(\"{}If\", ind);\n-            print_expr(cx, expr, indent + 1);\n-        },\n-        hir::Guard::IfLet(pat, expr) => {\n-            println!(\"{}IfLet\", ind);\n-            print_pat(cx, pat, indent + 1);\n-            print_expr(cx, expr, indent + 1);\n-        },\n-    }\n-}"}, {"sha": "9c75f7864795c2eea9775029d4dc2e14129bacbe", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccedc64e3abc53795106d2fba027f59c06905eb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccedc64e3abc53795106d2fba027f59c06905eb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=ccedc64e3abc53795106d2fba027f59c06905eb4", "patch": "@@ -33,7 +33,7 @@ use std::path::Path;\n /// This is the output file of the lint collector.\n const OUTPUT_FILE: &str = \"../util/gh-pages/lints.json\";\n /// These lints are excluded from the export.\n-const BLACK_LISTED_LINTS: [&str; 3] = [\"lint_author\", \"deep_code_inspection\", \"internal_metadata_collector\"];\n+const BLACK_LISTED_LINTS: &[&str] = &[\"lint_author\", \"dump_hir\", \"internal_metadata_collector\"];\n /// These groups will be ignored by the lint group matcher. This is useful for collections like\n /// `clippy::all`\n const IGNORED_LINT_GROUPS: [&str; 1] = [\"clippy::all\"];"}, {"sha": "787e9fd982c89c40ab67b3f1f997aa643bd406e8", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccedc64e3abc53795106d2fba027f59c06905eb4/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccedc64e3abc53795106d2fba027f59c06905eb4/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=ccedc64e3abc53795106d2fba027f59c06905eb4", "patch": "@@ -1,5 +1,5 @@\n pub mod author;\n pub mod conf;\n-pub mod inspector;\n+pub mod dump_hir;\n #[cfg(feature = \"internal\")]\n pub mod internal_lints;"}, {"sha": "307cf2f3a9047896fd3912c029e95745c0b29ff2", "filename": "doc/adding_lints.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ccedc64e3abc53795106d2fba027f59c06905eb4/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/ccedc64e3abc53795106d2fba027f59c06905eb4/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=ccedc64e3abc53795106d2fba027f59c06905eb4", "patch": "@@ -22,6 +22,7 @@ because that's clearly a non-descriptive name.\n   - [Adding the lint logic](#adding-the-lint-logic)\n   - [Specifying the lint's minimum supported Rust version (MSRV)](#specifying-the-lints-minimum-supported-rust-version-msrv)\n   - [Author lint](#author-lint)\n+  - [Print HIR lint](#print-hir-lint)\n   - [Documentation](#documentation)\n   - [Running rustfmt](#running-rustfmt)\n   - [Debugging](#debugging)\n@@ -484,6 +485,19 @@ you are implementing your lint.\n \n [author_example]: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=9a12cb60e5c6ad4e3003ac6d5e63cf55\n \n+## Print HIR lint\n+\n+To implement a lint, it's helpful to first understand the internal representation\n+that rustc uses. Clippy has the `#[clippy::dump]` attribute that prints the\n+[_High-Level Intermediate Representation (HIR)_] of the item, statement, or \n+expression that the attribute is attached to. To attach the attribute to expressions\n+you often need to enable `#![feature(stmt_expr_attributes)]`.\n+\n+[Here][print_hir_example] you can find an example, just select _Tools_ and run _Clippy_.\n+\n+[_High-Level Intermediate Representation (HIR)_]: https://rustc-dev-guide.rust-lang.org/hir.html\n+[print_hir_example]: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=daf14db3a7f39ca467cd1b86c34b9afb\n+\n ## Documentation\n \n The final thing before submitting our PR is to add some documentation to our"}]}