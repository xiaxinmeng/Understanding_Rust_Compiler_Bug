{"sha": "2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjZWFhNzdhZTI2ZjM4YjU5OWI1YWIwOWVlOTI1NjMyYWQ2MTNlMWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-06T19:49:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-06T19:49:16Z"}, "message": "Auto merge of #26741 - alexcrichton:noinline-destructors, r=brson\n\nThis PR was originally going to be a \"let's start running tests on MSVC\" PR, but it didn't quite get to that point. It instead gets us ~80% of the way there! The steps taken in this PR are:\r\n\r\n* Landing pads are turned on by default for 64-bit MSVC. The LLVM support is \"good enough\" with the caveat the destructor glue is now marked noinline. This was recommended [on the associated bug](https://llvm.org/bugs/show_bug.cgi?id=23884) as a stopgap until LLVM has a better representation for exception handling in MSVC. The consequence of this is that MSVC will have a bit of a perf hit, but there are possible routes we can take if this workaround sticks around for too long.\r\n* The linker (`link.exe`) is now looked up in the Windows Registry if it's not otherwise available in the environment. This improves using the compiler outside of a VS shell (e.g. in a MSYS shell or in a vanilla cmd.exe shell). This also makes cross compiles via Cargo \"just work\" when crossing between 32 and 64 bit!\r\n* TLS destructors were fixed to start running on MSVC (they previously weren't running at all)\r\n* A few assorted `run-pass` tests were fixed.\r\n* The dependency on the `rust_builtin` library was removed entirely for MSVC to try to prevent any `cl.exe` compiled objects get into the standard library. This should help us later remove any dependence on the CRT by the standard library.\r\n* I re-added `rust_try_msvc_32.ll` for 32-bit MSVC and ensured that landing pads were turned off by default there as well.\r\n\r\nDespite landing pads being enabled, there are still *many* failing tests on MSVC. The two major classes I've identified so far are:\r\n\r\n* Spurious aborts. It appears that when optimizations are enabled that landing pads aren't always lined up properly, and sometimes an exception being thrown can't find the catch block down the stack, causing the program to abort. I've been working to reduce this test case but haven't been met with great success just yet.\r\n* Parallel codegen does not work on MSVC. Our current strategy is to take the N object files emitted by the N codegen threads and use `ld -r` to assemble them into *one* object file. The MSVC linker, however, does not have this ability, and this will need to be rearchitected to work on MSVC.\r\n\r\nI will fix parallel codegen in a future PR, and I'll also be watching LLVM closely to see if the aborts... disappear!", "tree": {"sha": "9d24a300fdbc2fa7d454ed3b9a3639258f90b0ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d24a300fdbc2fa7d454ed3b9a3639258f90b0ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "html_url": "https://github.com/rust-lang/rust/commit/2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "943b0146099af31e1982f4cbfc7422b6fa25cd12", "url": "https://api.github.com/repos/rust-lang/rust/commits/943b0146099af31e1982f4cbfc7422b6fa25cd12", "html_url": "https://github.com/rust-lang/rust/commit/943b0146099af31e1982f4cbfc7422b6fa25cd12"}, {"sha": "3e26e56a79ae33dfc8f2f4d0123b5080fd0a7853", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e26e56a79ae33dfc8f2f4d0123b5080fd0a7853", "html_url": "https://github.com/rust-lang/rust/commit/3e26e56a79ae33dfc8f2f4d0123b5080fd0a7853"}], "stats": {"total": 634, "additions": 554, "deletions": 80}, "files": [{"sha": "c2de9af39c7643397ab6370978b4d550f3503b51", "filename": "mk/target.mk", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -249,11 +249,9 @@ endef\n \n $(foreach host,$(CFG_HOST), \\\n  $(foreach target,$(CFG_TARGET), \\\n-  $(foreach stage,$(STAGES), \\\n-   $(foreach crate,$(CRATES), \\\n-    $(eval $(call SETUP_LIB_MSVC_ENV_VARS,$(stage),$(target),$(host),$(crate)))))))\n+  $(foreach crate,$(CRATES), \\\n+   $(eval $(call SETUP_LIB_MSVC_ENV_VARS,0,$(target),$(host),$(crate))))))\n $(foreach host,$(CFG_HOST), \\\n  $(foreach target,$(CFG_TARGET), \\\n-  $(foreach stage,$(STAGES), \\\n-   $(foreach tool,$(TOOLS), \\\n-    $(eval $(call SETUP_TOOL_MSVC_ENV_VARS,$(stage),$(target),$(host),$(tool)))))))\n+  $(foreach tool,$(TOOLS), \\\n+   $(eval $(call SETUP_TOOL_MSVC_ENV_VARS,0,$(target),$(host),$(tool))))))"}, {"sha": "e0495226d90613388d93cf3a373e2594e9b3f4c8", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -12,6 +12,7 @@ use super::archive::{Archive, ArchiveBuilder, ArchiveConfig, METADATA_FILENAME};\n use super::linker::{Linker, GnuLinker, MsvcLinker};\n use super::rpath::RPathConfig;\n use super::rpath;\n+use super::msvc;\n use super::svh::Svh;\n use session::config;\n use session::config::NoDebugInfo;\n@@ -358,10 +359,14 @@ pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> Stri\n     mangle(path.chain(Some(gensym_name(flav))), None)\n }\n \n-pub fn get_cc_prog(sess: &Session) -> String {\n-    match sess.opts.cg.linker {\n-        Some(ref linker) => return linker.to_string(),\n-        None => sess.target.target.options.linker.clone(),\n+pub fn get_linker(sess: &Session) -> (String, Command) {\n+    if let Some(ref linker) = sess.opts.cg.linker {\n+        (linker.clone(), Command::new(linker))\n+    } else if sess.target.target.options.is_like_msvc {\n+        (\"link.exe\".to_string(), msvc::link_exe_cmd(sess))\n+    } else {\n+        (sess.target.target.options.linker.clone(),\n+         Command::new(&sess.target.target.options.linker))\n     }\n }\n \n@@ -807,8 +812,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n \n     // The invocations of cc share some flags across platforms\n-    let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(&pname);\n+    let (pname, mut cmd) = get_linker(sess);\n     cmd.env(\"PATH\", command_path(sess));\n \n     let root = sess.target_filesearch(PathKind::Native).get_lib_path();"}, {"sha": "0077e7eed52d02e49e34bed0e301aa357b1f1f6c", "filename": "src/librustc_trans/back/msvc/mod.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -0,0 +1,239 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! MSVC-specific logic for linkers and such.\n+//!\n+//! This module contains a cross-platform interface but has a blank unix\n+//! implementation. The Windows implementation builds on top of Windows native\n+//! libraries (reading registry keys), so it otherwise wouldn't link on unix.\n+//!\n+//! Note that we don't have much special logic for finding the system linker on\n+//! any other platforms, so it may seem a little odd to single out MSVC to have\n+//! a good deal of code just to find the linker. Unlike Unix systems, however,\n+//! the MSVC linker is not in the system PATH by default. It also additionally\n+//! needs a few environment variables or command line flags to be able to link\n+//! against system libraries.\n+//!\n+//! In order to have a nice smooth experience on Windows, the logic in this file\n+//! is here to find the MSVC linker and set it up in the default configuration\n+//! one would need to set up anyway. This means that the Rust compiler can be\n+//! run not only in the developer shells of MSVC but also the standard cmd.exe\n+//! shell or MSYS shells.\n+//!\n+//! As a high-level note, all logic in this module for looking up various\n+//! paths/files is copied over from Clang in its MSVCToolChain.cpp file, but\n+//! comments can also be found below leading through the various code paths.\n+\n+use std::process::Command;\n+use session::Session;\n+\n+#[cfg(windows)]\n+mod registry;\n+\n+#[cfg(windows)]\n+pub fn link_exe_cmd(sess: &Session) -> Command {\n+    use std::env;\n+    use std::ffi::OsString;\n+    use std::fs;\n+    use std::path::PathBuf;\n+    use self::registry::{RegistryKey, LOCAL_MACHINE};\n+\n+    // When finding the link.exe binary the 32-bit version is at the top level\n+    // but the versions to cross to other architectures are stored in\n+    // sub-folders. Unknown architectures also just bail out early to return the\n+    // standard `link.exe` command.\n+    let extra = match &sess.target.target.arch[..] {\n+        \"x86\" => \"\",\n+        \"x86_64\" => \"amd64\",\n+        \"arm\" => \"arm\",\n+        _ => return Command::new(\"link.exe\"),\n+    };\n+\n+    let vs_install_dir = get_vs_install_dir();\n+\n+    // First up, we need to find the `link.exe` binary itself, and there's a few\n+    // locations that we can look. First up is the standard VCINSTALLDIR\n+    // environment variable which is normally set by the vcvarsall.bat file. If\n+    // an environment is set up manually by whomever's driving the compiler then\n+    // we shouldn't muck with that decision and should instead respect that.\n+    //\n+    // Next up is looking in PATH itself. Here we look for `cl.exe` and then\n+    // assume that `link.exe` is next to it if we find it. Note that we look for\n+    // `cl.exe` because MinGW ships /usr/bin/link.exe which is normally found in\n+    // PATH but we're not interested in finding that.\n+    //\n+    // Finally we read the Windows registry to discover the VS install root.\n+    // From here we probe for `link.exe` just to make sure that it exists.\n+    let mut cmd = env::var_os(\"VCINSTALLDIR\").and_then(|dir| {\n+        let mut p = PathBuf::from(dir);\n+        p.push(\"bin\");\n+        p.push(extra);\n+        p.push(\"link.exe\");\n+        if fs::metadata(&p).is_ok() {Some(p)} else {None}\n+    }).or_else(|| {\n+        env::var_os(\"PATH\").and_then(|path| {\n+            env::split_paths(&path).find(|path| {\n+                fs::metadata(&path.join(\"cl.exe\")).is_ok()\n+            }).map(|p| {\n+                p.join(\"link.exe\")\n+            })\n+        })\n+    }).or_else(|| {\n+        vs_install_dir.as_ref().and_then(|p| {\n+            let mut p = p.join(\"VC/bin\");\n+            p.push(extra);\n+            p.push(\"link.exe\");\n+            if fs::metadata(&p).is_ok() {Some(p)} else {None}\n+        })\n+    }).map(|linker| {\n+        Command::new(linker)\n+    }).unwrap_or_else(|| {\n+        Command::new(\"link.exe\")\n+    });\n+\n+    // The MSVC linker uses the LIB environment variable as the default lookup\n+    // path for libraries. This environment variable is normally set up by the\n+    // VS shells, so we only want to start adding our own pieces if it's not\n+    // set.\n+    //\n+    // If we're adding our own pieces, then we need to add two primary\n+    // directories to the default search path for the linker. The first is in\n+    // the VS install direcotry and the next is the Windows SDK directory.\n+    if env::var_os(\"LIB\").is_none() {\n+        if let Some(mut vs_install_dir) = vs_install_dir {\n+            vs_install_dir.push(\"VC/lib\");\n+            vs_install_dir.push(extra);\n+            let mut arg = OsString::from(\"/LIBPATH:\");\n+            arg.push(&vs_install_dir);\n+            cmd.arg(arg);\n+        }\n+        if let Some(path) = get_windows_sdk_lib_path(sess) {\n+            let mut arg = OsString::from(\"/LIBPATH:\");\n+            arg.push(&path);\n+            cmd.arg(arg);\n+        }\n+    }\n+\n+    return cmd;\n+\n+    // When looking for the Visual Studio installation directory we look in a\n+    // number of locations in varying degrees of precedence:\n+    //\n+    // 1. The Visual Studio registry keys\n+    // 2. The Visual Studio Express registry keys\n+    // 3. A number of somewhat standard environment variables\n+    //\n+    // If we find a hit from any of these keys then we strip off the IDE/Tools\n+    // folders which are typically found at the end.\n+    //\n+    // As a final note, when we take a look at the registry keys they're\n+    // typically found underneath the version of what's installed, but we don't\n+    // quite know what's installed. As a result we probe all sub-keys of the two\n+    // keys we're looking at to find out the maximum version of what's installed\n+    // and we use that root directory.\n+    fn get_vs_install_dir() -> Option<PathBuf> {\n+        LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\VisualStudio\".as_ref()).or_else(|_| {\n+            LOCAL_MACHINE.open(r\"SOFTWARE\\Microsoft\\VCExpress\".as_ref())\n+        }).ok().and_then(|key| {\n+            max_version(&key).and_then(|(_vers, key)| {\n+                key.query_str(\"InstallDir\").ok()\n+            })\n+        }).or_else(|| {\n+            env::var_os(\"VS120COMNTOOLS\")\n+        }).or_else(|| {\n+            env::var_os(\"VS100COMNTOOLS\")\n+        }).or_else(|| {\n+            env::var_os(\"VS90COMNTOOLS\")\n+        }).or_else(|| {\n+            env::var_os(\"VS80COMNTOOLS\")\n+        }).map(PathBuf::from).and_then(|mut dir| {\n+            if dir.ends_with(\"Common7/IDE\") || dir.ends_with(\"Common7/Tools\") {\n+                dir.pop();\n+                dir.pop();\n+                Some(dir)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    // Given a registry key, look at all the sub keys and find the one which has\n+    // the maximal numeric value.\n+    //\n+    // Returns the name of the maximal key as well as the opened maximal key.\n+    fn max_version(key: &RegistryKey) -> Option<(OsString, RegistryKey)> {\n+        let mut max_vers = 0;\n+        let mut max_key = None;\n+        for subkey in key.iter().filter_map(|k| k.ok()) {\n+            let val = subkey.to_str().and_then(|s| {\n+                s.trim_left_matches(\"v\").replace(\".\", \"\").parse().ok()\n+            });\n+            let val = match val {\n+                Some(s) => s,\n+                None => continue,\n+            };\n+            if val > max_vers {\n+                if let Ok(k) = key.open(&subkey) {\n+                    max_vers = val;\n+                    max_key = Some((subkey, k));\n+                }\n+            }\n+        }\n+        return max_key\n+    }\n+\n+    fn get_windows_sdk_lib_path(sess: &Session) -> Option<PathBuf> {\n+        let key = r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\";\n+        let key = LOCAL_MACHINE.open(key.as_ref());\n+        let (n, k) = match key.ok().as_ref().and_then(max_version) {\n+            Some(p) => p,\n+            None => return None,\n+        };\n+        let mut parts = n.to_str().unwrap().trim_left_matches(\"v\").splitn(2, \".\");\n+        let major = parts.next().unwrap().parse::<usize>().unwrap();\n+        let _minor = parts.next().unwrap().parse::<usize>().unwrap();\n+        let path = match k.query_str(\"InstallationFolder\") {\n+            Ok(p) => PathBuf::from(p).join(\"Lib\"),\n+            Err(..) => return None,\n+        };\n+        if major <= 7 {\n+            // In Windows SDK 7.x, x86 libraries are directly in the Lib folder,\n+            // x64 libraries are inside, and it's not necessary to link agains\n+            // the SDK 7.x when targeting ARM or other architectures.\n+            let x86 = match &sess.target.target.arch[..] {\n+                \"x86\" => true,\n+                \"x86_64\" => false,\n+                _ => return None,\n+            };\n+            Some(if x86 {path} else {path.join(\"x64\")})\n+        } else {\n+            // Windows SDK 8.x installes libraries in a folder whose names\n+            // depend on the version of the OS you're targeting. By default\n+            // choose the newest, which usually corresponds to the version of\n+            // the OS you've installed the SDK on.\n+            let extra = match &sess.target.target.arch[..] {\n+                \"x86\" => \"x86\",\n+                \"x86_64\" => \"x64\",\n+                \"arm\" => \"arm\",\n+                _ => return None,\n+            };\n+            [\"winv6.3\", \"win8\", \"win7\"].iter().map(|p| path.join(p)).find(|part| {\n+                fs::metadata(part).is_ok()\n+            }).map(|path| {\n+                path.join(\"um\").join(extra)\n+            })\n+        }\n+    }\n+}\n+\n+#[cfg(not(windows))]\n+pub fn link_exe_cmd(_sess: &Session) -> Command {\n+    Command::new(\"link.exe\")\n+}"}, {"sha": "97fd7f99d197e4714f3f08ad5466020a12bb4486", "filename": "src/librustc_trans/back/msvc/registry.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -0,0 +1,170 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io;\n+use std::ffi::{OsString, OsStr};\n+use std::os::windows::prelude::*;\n+use std::ops::RangeFrom;\n+use libc::{DWORD, LPCWSTR, LONG, LPDWORD, LPBYTE, ERROR_SUCCESS};\n+\n+const HKEY_LOCAL_MACHINE: HKEY = 0x80000002 as HKEY;\n+const KEY_WOW64_32KEY: REGSAM = 0x0200;\n+const KEY_READ: REGSAM = (STANDARD_RIGTS_READ | KEY_QUERY_VALUE |\n+                          KEY_ENUMERATE_SUB_KEYS | KEY_NOTIFY) & !SYNCHRONIZE;\n+const STANDARD_RIGTS_READ: REGSAM = READ_CONTROL;\n+const READ_CONTROL: REGSAM = 0x00020000;\n+const KEY_QUERY_VALUE: REGSAM = 0x0001;\n+const KEY_ENUMERATE_SUB_KEYS: REGSAM = 0x0008;\n+const KEY_NOTIFY: REGSAM = 0x0010;\n+const SYNCHRONIZE: REGSAM = 0x00100000;\n+const REG_SZ: DWORD = 1;\n+const ERROR_NO_MORE_ITEMS: DWORD = 259;\n+\n+enum __HKEY__ {}\n+pub type HKEY = *mut __HKEY__;\n+pub type PHKEY = *mut HKEY;\n+pub type REGSAM = DWORD;\n+pub type LPWSTR = *mut u16;\n+pub type PFILETIME = *mut ();\n+\n+#[link(name = \"advapi32\")]\n+extern \"system\" {\n+    fn RegOpenKeyExW(hKey: HKEY,\n+                     lpSubKey: LPCWSTR,\n+                     ulOptions: DWORD,\n+                     samDesired: REGSAM,\n+                     phkResult: PHKEY) -> LONG;\n+    fn RegQueryValueExW(hKey: HKEY,\n+                        lpValueName: LPCWSTR,\n+                        lpReserved: LPDWORD,\n+                        lpType: LPDWORD,\n+                        lpData: LPBYTE,\n+                        lpcbData: LPDWORD) -> LONG;\n+    fn RegEnumKeyExW(hKey: HKEY,\n+                     dwIndex: DWORD,\n+                     lpName: LPWSTR,\n+                     lpcName: LPDWORD,\n+                     lpReserved: LPDWORD,\n+                     lpClass: LPWSTR,\n+                     lpcClass: LPDWORD,\n+                     lpftLastWriteTime: PFILETIME) -> LONG;\n+    fn RegCloseKey(hKey: HKEY) -> LONG;\n+}\n+\n+pub struct RegistryKey(Repr);\n+\n+struct OwnedKey(HKEY);\n+\n+enum Repr {\n+    Const(HKEY),\n+    Owned(OwnedKey),\n+}\n+\n+pub struct Iter<'a> {\n+    idx: RangeFrom<DWORD>,\n+    key: &'a RegistryKey,\n+}\n+\n+unsafe impl Sync for RegistryKey {}\n+unsafe impl Send for RegistryKey {}\n+\n+pub static LOCAL_MACHINE: RegistryKey = RegistryKey(Repr::Const(HKEY_LOCAL_MACHINE));\n+\n+impl RegistryKey {\n+    fn raw(&self) -> HKEY {\n+        match self.0 {\n+            Repr::Const(val) => val,\n+            Repr::Owned(ref val) => val.0,\n+        }\n+    }\n+\n+    pub fn open(&self, key: &OsStr) -> io::Result<RegistryKey> {\n+        let key = key.encode_wide().chain(Some(0)).collect::<Vec<_>>();\n+        let mut ret = 0 as *mut _;\n+        let err = unsafe {\n+            RegOpenKeyExW(self.raw(), key.as_ptr(), 0,\n+                          KEY_READ | KEY_WOW64_32KEY, &mut ret)\n+        };\n+        if err == ERROR_SUCCESS {\n+            Ok(RegistryKey(Repr::Owned(OwnedKey(ret))))\n+        } else {\n+            Err(io::Error::from_raw_os_error(err as i32))\n+        }\n+    }\n+\n+    pub fn iter(&self) -> Iter {\n+        Iter { idx: 0.., key: self }\n+    }\n+\n+    pub fn query_str(&self, name: &str) -> io::Result<OsString> {\n+        let name: &OsStr = name.as_ref();\n+        let name = name.encode_wide().chain(Some(0)).collect::<Vec<_>>();\n+        let mut len = 0;\n+        let mut kind = 0;\n+        unsafe {\n+            let err = RegQueryValueExW(self.raw(), name.as_ptr(), 0 as *mut _,\n+                                       &mut kind, 0 as *mut _, &mut len);\n+            if err != ERROR_SUCCESS {\n+                return Err(io::Error::from_raw_os_error(err as i32))\n+            }\n+            if kind != REG_SZ {\n+                return Err(io::Error::new(io::ErrorKind::Other,\n+                                          \"registry key wasn't a string\"))\n+            }\n+\n+            // The length here is the length in bytes, but we're using wide\n+            // characters so we need to be sure to halve it for the capacity\n+            // passed in.\n+            let mut v = Vec::with_capacity(len as usize / 2);\n+            let err = RegQueryValueExW(self.raw(), name.as_ptr(), 0 as *mut _,\n+                                       0 as *mut _, v.as_mut_ptr() as *mut _,\n+                                       &mut len);\n+            if err != ERROR_SUCCESS {\n+                return Err(io::Error::from_raw_os_error(err as i32))\n+            }\n+            v.set_len(len as usize / 2);\n+\n+            // Some registry keys may have a terminating nul character, but\n+            // we're not interested in that, so chop it off if it's there.\n+            if v[v.len() - 1] == 0 {\n+                v.pop();\n+            }\n+            Ok(OsString::from_wide(&v))\n+        }\n+    }\n+}\n+\n+impl Drop for OwnedKey {\n+    fn drop(&mut self) {\n+        unsafe { RegCloseKey(self.0); }\n+    }\n+}\n+\n+impl<'a> Iterator for Iter<'a> {\n+    type Item = io::Result<OsString>;\n+\n+    fn next(&mut self) -> Option<io::Result<OsString>> {\n+        self.idx.next().and_then(|i| unsafe {\n+            let mut v = Vec::with_capacity(256);\n+            let mut len = v.capacity() as DWORD;\n+            let ret = RegEnumKeyExW(self.key.raw(), i, v.as_mut_ptr(), &mut len,\n+                                    0 as *mut _, 0 as *mut _, 0 as *mut _,\n+                                    0 as *mut _);\n+            if ret == ERROR_NO_MORE_ITEMS as LONG {\n+                None\n+            } else if ret != ERROR_SUCCESS {\n+                Some(Err(io::Error::from_raw_os_error(ret as i32)))\n+            } else {\n+                v.set_len(len as usize);\n+                Some(Ok(OsString::from_wide(&v)))\n+            }\n+        })\n+    }\n+}"}, {"sha": "90ddba4e09c58b43ad61b4d6e81790b229265137", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use back::lto;\n-use back::link::{get_cc_prog, remove};\n+use back::link::{get_linker, remove};\n use session::config::{OutputFilenames, Passes, SomePasses, AllPasses};\n use session::Session;\n use session::config;\n@@ -27,7 +27,7 @@ use std::ffi::{CStr, CString};\n use std::fs;\n use std::mem;\n use std::path::Path;\n-use std::process::{Command, Stdio};\n+use std::process::Stdio;\n use std::ptr;\n use std::str;\n use std::sync::{Arc, Mutex};\n@@ -737,8 +737,7 @@ pub fn run_passes(sess: &Session,\n                 None\n             };\n \n-        let pname = get_cc_prog(sess);\n-        let mut cmd = Command::new(&pname[..]);\n+        let (pname, mut cmd) = get_linker(sess);\n \n         cmd.args(&sess.target.target.options.pre_link_args);\n         cmd.arg(\"-nostdlib\");\n@@ -767,8 +766,7 @@ pub fn run_passes(sess: &Session,\n             },\n             Err(e) => {\n                 sess.err(&format!(\"could not exec the linker `{}`: {}\",\n-                                 pname,\n-                                 e));\n+                                 pname, e));\n                 sess.abort_if_errors();\n             },\n         }\n@@ -986,8 +984,7 @@ fn run_work_multithreaded(sess: &Session,\n }\n \n pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n-    let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(&pname[..]);\n+    let (pname, mut cmd) = get_linker(sess);\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(&outputs.path(config::OutputTypeObject))\n                            .arg(&outputs.temp_path(config::OutputTypeAssembly));\n@@ -1007,9 +1004,7 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n             }\n         },\n         Err(e) => {\n-            sess.err(&format!(\"could not exec the linker `{}`: {}\",\n-                             pname,\n-                             e));\n+            sess.err(&format!(\"could not exec the linker `{}`: {}\", pname, e));\n             sess.abort_if_errors();\n         }\n     }"}, {"sha": "cd2e597db1333c70848548dc6f2763971ea0613b", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -82,7 +82,7 @@ pub mod back {\n     pub mod link;\n     pub mod lto;\n     pub mod write;\n-\n+    pub mod msvc;\n }\n \n pub mod trans;"}, {"sha": "08b8fab1fd7075ea3bf27d85172fa0ac7e223e44", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -753,13 +753,15 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn need_invoke(bcx: Block) -> bool {\n-    // FIXME(#25869) currently unwinding is not implemented for MSVC and our\n-    //               normal unwinding infrastructure ends up just causing linker\n-    //               errors with the current LLVM implementation, so landing\n-    //               pads are disabled entirely for MSVC targets\n-    if bcx.sess().no_landing_pads() ||\n-       bcx.sess().target.target.options.is_like_msvc {\n-        return false;\n+    if bcx.sess().no_landing_pads() {\n+        return false\n+    }\n+\n+    // Currently 32-bit MSVC unwinding is not super well implemented in LLVM, so\n+    // we avoid it entirely.\n+    if bcx.sess().target.target.options.is_like_msvc &&\n+       bcx.sess().target.target.arch == \"x86\" {\n+        return false\n     }\n \n     // Avoid using invoke if we are already inside a landing pad."}, {"sha": "1891320313a851f562a8ffb89e21083cdebfa786", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -851,8 +851,8 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         // an \"exception\", but for MSVC we want to force SEH. This means that we\n         // can't actually have the personality function be our standard\n         // `rust_eh_personality` function, but rather we wired it up to the\n-        // CRT's custom `__C_specific_handler` personality funciton, which\n-        // forces LLVM to consider landing pads as \"landing pads for SEH\".\n+        // CRT's custom personality function, which forces LLVM to consider\n+        // landing pads as \"landing pads for SEH\".\n         let target = &self.ccx.sess().target.target;\n         let llpersonality = match pad_bcx.tcx().lang_items.eh_personality() {\n             Some(def_id) if !target.options.is_like_msvc => {\n@@ -864,10 +864,12 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 match *personality {\n                     Some(llpersonality) => llpersonality,\n                     None => {\n-                        let name = if target.options.is_like_msvc {\n-                            \"__C_specific_handler\"\n-                        } else {\n+                        let name = if !target.options.is_like_msvc {\n                             \"rust_eh_personality\"\n+                        } else if target.arch == \"x86\" {\n+                            \"_except_handler3\"\n+                        } else {\n+                            \"__C_specific_handler\"\n                         };\n                         let fty = Type::variadic_func(&[], &Type::i32(self.ccx));\n                         let f = declare::declare_cfn(self.ccx, name, fty,"}, {"sha": "541a9ab466e566159bf75e765bbaa77bbd854e76", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -22,8 +22,9 @@ use middle::lang_items::ExchangeFreeFnLangItem;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n use middle::ty::{self, Ty};\n-use trans::adt;\n use trans::adt::GetDtorType; // for tcx.dtor_type()\n+use trans::adt;\n+use trans::attributes;\n use trans::base::*;\n use trans::build::*;\n use trans::callee;\n@@ -43,6 +44,7 @@ use trans::type_::Type;\n use arena::TypedArena;\n use libc::c_uint;\n use syntax::ast;\n+use syntax::attr::InlineAttr;\n \n pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                            v: ValueRef,\n@@ -250,6 +252,25 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     update_linkage(ccx, llfn, None, OriginalTranslation);\n \n+    // FIXME: Currently LLVM has a bug where if an SSA value is created in one\n+    //        landing pad and then used in another it will abort during\n+    //        compilation. The compiler never actually generates nested landing\n+    //        pads, but this often arises when destructors are inlined into\n+    //        other functions. To prevent this inlining from happening (and thus\n+    //        preventing the LLVM abort) we mark all drop glue as inline(never)\n+    //        on MSVC.\n+    //\n+    //        For more information about the bug, see:\n+    //\n+    //            https://llvm.org/bugs/show_bug.cgi?id=23884\n+    //\n+    //        This is clearly not the ideal solution to the problem (due to the\n+    //        perf hits), so this should be removed once the upstream bug is\n+    //        fixed.\n+    if ccx.sess().target.target.options.is_like_msvc {\n+        attributes::inline(llfn, InlineAttr::Never);\n+    }\n+\n     ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n     // All glue functions take values passed *by alias*; this is a\n     // requirement since in many contexts glue is invoked indirectly and"}, {"sha": "73e45619774d7f99bc3d25e1809c146fc08542f4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -151,6 +151,7 @@\n #![cfg_attr(windows, feature(str_utf16))]\n #![cfg_attr(test, feature(float_from_str_radix, range_inclusive, float_extras))]\n #![cfg_attr(test, feature(test, rustc_private, float_consts))]\n+#![cfg_attr(target_env = \"msvc\", feature(link_args))]\n \n // Don't link to std. We are std.\n #![no_std]"}, {"sha": "031fda089c84c7e5a8e6d382ccdca13351276a73", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -13,7 +13,6 @@ use io::prelude::*;\n use env;\n use fmt;\n use intrinsics;\n-use libc::uintptr_t;\n use sync::atomic::{self, Ordering};\n use sys::stdio::Stderr;\n \n@@ -22,10 +21,18 @@ use sys::stdio::Stderr;\n /// can't run correctly un-altered. Valgrind is there to help\n /// you notice weirdness in normal, un-doctored code paths!\n pub fn running_on_valgrind() -> bool {\n-    extern {\n-        fn rust_running_on_valgrind() -> uintptr_t;\n+    return on_valgrind();\n+    #[cfg(windows)]\n+    fn on_valgrind() -> bool { false }\n+\n+    #[cfg(unix)]\n+    fn on_valgrind() -> bool {\n+        use libc::uintptr_t;\n+        extern {\n+            fn rust_running_on_valgrind() -> uintptr_t;\n+        }\n+        unsafe { rust_running_on_valgrind() != 0 }\n     }\n-    unsafe { rust_running_on_valgrind() != 0 }\n }\n \n /// Valgrind has a fixed-sized array (size around 2000) of segment descriptors"}, {"sha": "a3b2ab7705eaf1e967a56e6e1a0e4e155795a8e3", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -12,8 +12,8 @@\n //! the standard library This varies per-platform, but these libraries are\n //! necessary for running libstd.\n \n-// All platforms need to link to rustrt\n-#[cfg(not(test))]\n+// A few small shims in C that haven't been translated to Rust yet\n+#[cfg(all(not(test), not(windows)))]\n #[link(name = \"rust_builtin\", kind = \"static\")]\n extern {}\n "}, {"sha": "a2dbb0f8342433524f6937daede9689abfc16768", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -221,8 +221,8 @@ unsafe fn unregister_dtor(key: Key) -> bool {\n //\n // # The article mentions crazy stuff about \"/INCLUDE\"?\n //\n-// It sure does! This seems to work for now, so maybe we'll just run into\n-// that if we start linking with msvc?\n+// It sure does! We include it below for MSVC targets, but it look like for GNU\n+// targets we don't require it.\n \n #[link_section = \".CRT$XLB\"]\n #[linkage = \"external\"]\n@@ -231,6 +231,10 @@ pub static p_thread_callback: unsafe extern \"system\" fn(LPVOID, DWORD,\n                                                         LPVOID) =\n         on_tls_callback;\n \n+#[cfg(target_env = \"msvc\")]\n+#[link_args = \"/INCLUDE:_tls_used\"]\n+extern {}\n+\n #[allow(warnings)]\n unsafe extern \"system\" fn on_tls_callback(h: LPVOID,\n                                           dwReason: DWORD,"}, {"sha": "724c0b2a8927f9af7f5eaad48069b348e97828cf", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -872,7 +872,7 @@ fn run_tests<F>(opts: &TestOpts,\n \n #[allow(deprecated)]\n fn get_concurrency() -> usize {\n-    match env::var(\"RUST_TEST_THREADS\") {\n+    return match env::var(\"RUST_TEST_THREADS\") {\n         Ok(s) => {\n             let opt_n: Option<usize> = s.parse().ok();\n             match opt_n {\n@@ -884,10 +884,24 @@ fn get_concurrency() -> usize {\n             if std::rt::util::limit_thread_creation_due_to_osx_and_valgrind() {\n                 1\n             } else {\n-                extern { fn rust_get_num_cpus() -> libc::uintptr_t; }\n-                unsafe { rust_get_num_cpus() as usize }\n+                num_cpus()\n             }\n         }\n+    };\n+\n+    #[cfg(windows)]\n+    fn num_cpus() -> usize {\n+        unsafe {\n+            let mut sysinfo = std::mem::zeroed();\n+            libc::GetSystemInfo(&mut sysinfo);\n+            sysinfo.dwNumberOfProcessors as usize\n+        }\n+    }\n+\n+    #[cfg(unix)]\n+    fn num_cpus() -> usize {\n+        extern { fn rust_get_num_cpus() -> libc::uintptr_t; }\n+        unsafe { rust_get_num_cpus() as usize }\n     }\n }\n "}, {"sha": "76a3debef59a4163f87e24774a435216cc2c583c", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 5, "deletions": 31, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -8,27 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#if !defined(_WIN32)\n+\n #include <stdint.h>\n #include <time.h>\n #include <string.h>\n #include <assert.h>\n #include <stdlib.h>\n \n \n-#if !defined(_WIN32)\n #include <dirent.h>\n #include <pthread.h>\n #include <signal.h>\n #include <sys/stat.h>\n #include <sys/time.h>\n #include <sys/types.h>\n #include <unistd.h>\n-#else\n-#include <windows.h>\n-#include <wincrypt.h>\n-#include <stdio.h>\n-#include <tchar.h>\n-#endif\n \n #ifdef __APPLE__\n #include <TargetConditionals.h>\n@@ -41,17 +36,8 @@\n \n /* Foreign builtins. */\n //include valgrind.h after stdint.h so that uintptr_t is defined for msys2 w64\n-#ifndef _WIN32\n #include \"valgrind/valgrind.h\"\n-#endif\n-\n-#if defined(_MSC_VER)\n-# define RUST_BUILTIN_API __declspec(dllexport)\n-#else\n-# define RUST_BUILTIN_API\n-#endif\n \n-#ifndef _WIN32\n char*\n rust_list_dir_val(struct dirent* entry_ptr) {\n     return entry_ptr->d_name;\n@@ -92,17 +78,8 @@ int\n rust_dirent_t_size() {\n     return sizeof(struct dirent);\n }\n-#endif\n-\n-#if defined(_WIN32)\n-int\n-get_num_cpus() {\n-    SYSTEM_INFO sysinfo;\n-    GetSystemInfo(&sysinfo);\n \n-    return (int) sysinfo.dwNumberOfProcessors;\n-}\n-#elif defined(__BSD__)\n+#if defined(__BSD__)\n int\n get_num_cpus() {\n     /* swiped from http://stackoverflow.com/questions/150355/\n@@ -136,19 +113,14 @@ get_num_cpus() {\n }\n #endif\n \n-RUST_BUILTIN_API\n uintptr_t\n rust_get_num_cpus() {\n     return get_num_cpus();\n }\n \n uintptr_t\n rust_running_on_valgrind() {\n-#ifdef _WIN32\n-    return 0;\n-#else\n     return RUNNING_ON_VALGRIND;\n-#endif\n }\n \n #if defined(__DragonFly__)\n@@ -484,6 +456,8 @@ const char * rust_current_exe() {\n \n #endif\n \n+#endif // !defined(_WIN32)\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "bdee53b136e103b5f91050ccc79ab1a01c0c42e1", "filename": "src/rt/rust_try_msvc_32.ll", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Frt%2Frust_try_msvc_32.ll", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Frt%2Frust_try_msvc_32.ll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_try_msvc_32.ll?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -0,0 +1,42 @@\n+; Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+; file at the top-level directory of this distribution and at\n+; http://rust-lang.org/COPYRIGHT.\n+;\n+; Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+; http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+; <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+; option. This file may not be copied, modified, or distributed\n+; except according to those terms.\n+\n+; For more comments about what's going on here see rust_try_msvc_64.ll. The only\n+; difference between that and this file is the personality function used as it's\n+; different for 32-bit MSVC than it is for 64-bit.\n+\n+define i8* @rust_try(void (i8*)* %f, i8* %env)\n+    personality i8* bitcast (i32 (...)* @_except_handler3 to i8*)\n+{\n+    invoke void %f(i8* %env)\n+        to label %normal\n+        unwind label %catch\n+\n+normal:\n+    ret i8* null\n+catch:\n+    %vals = landingpad { i8*, i32 }\n+              catch i8* bitcast (i32 (i8*, i8*)* @__rust_try_filter to i8*)\n+    %ehptr = extractvalue { i8*, i32 } %vals, 0\n+    %sel = extractvalue { i8*, i32 } %vals, 1\n+    %filter_sel = call i32 @llvm.eh.typeid.for(i8* bitcast (i32 (i8*, i8*)* @__rust_try_filter to i8*))\n+    %is_filter = icmp eq i32 %sel, %filter_sel\n+    br i1 %is_filter, label %catch-return, label %catch-resume\n+\n+catch-return:\n+    ret i8* %ehptr\n+\n+catch-resume:\n+    resume { i8*, i32 } %vals\n+}\n+\n+declare i32 @_except_handler3(...)\n+declare i32 @__rust_try_filter(i8*, i8*)\n+declare i32 @llvm.eh.typeid.for(i8*) readnone nounwind"}, {"sha": "21948d2e5ad23c04bf3dad6312652456f48ea5bb", "filename": "src/test/run-pass/extern-pass-empty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Ftest%2Frun-pass%2Fextern-pass-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Ftest%2Frun-pass%2Fextern-pass-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-empty.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -11,6 +11,7 @@\n // Test a foreign function that accepts empty struct.\n \n // pretty-expanded FIXME #23616\n+// ignore-msvc\n \n struct TwoU8s {\n     one: u8,"}, {"sha": "316e379e664ae5bec94db7f69dfa97fcc2eb1809", "filename": "src/test/run-pass/issue-2214.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ceaa77ae26f38b599b5ab09ee925632ad613e1b/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2214.rs?ref=2ceaa77ae26f38b599b5ab09ee925632ad613e1b", "patch": "@@ -37,7 +37,7 @@ mod m {\n         #[link_name=\"lgamma_r\"]\n         pub fn lgamma(n: c_double, sign: &mut c_int) -> c_double;\n         #[cfg(windows)]\n-        #[link_name=\"__lgamma_r\"]\n+        #[link_name=\"lgamma\"]\n         pub fn lgamma(n: c_double, sign: &mut c_int) -> c_double;\n     }\n }"}]}