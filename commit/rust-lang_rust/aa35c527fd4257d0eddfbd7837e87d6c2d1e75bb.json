{"sha": "aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMzVjNTI3ZmQ0MjU3ZDBlZGRmYmQ3ODM3ZTg3ZDZjMmQxZTc1YmI=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-09-26T23:53:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-26T23:53:27Z"}, "message": "Rollup merge of #77231 - oli-obk:clippy_const_fn, r=Manishearth\n\nMove helper function for `missing_const_for_fn` out of rustc to clippy\n\ncc @rust-lang/clippy @ecstatic-morse #76618\n\nr? @Manishearth\n\nI also removed all support for suggesting a function could be `const fn` when that would require feature gates to actually work.\n\nThis means we'll now have to maintain this ourselves in clippy, but that's how most lints work anyway, so...", "tree": {"sha": "1fcdeeee4cede423a0c7ba97fb563c8a738ac638", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fcdeeee4cede423a0c7ba97fb563c8a738ac638"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfb9R3CRBK7hj4Ov3rIwAAdHIIAJrfjPGhEuV9iOcgO7VimZSn\nY0a5rcqEptArf5bj4ky6pe1KqnSgeybkpl4EW7bm57ttfjyde6B2j3/AsdvKKKDu\n+o0BLBhRe+qwNSjh0/LAh99RIBx5y4ZC6zsCzVFgKg/uDSd/0QlH8bpfUZrYUS40\noFYRAlilRlzAOpPEDgyKIsOvgciR2yYa74ejzEDTYjmzmaGybDKf4nZ9qHAAWSyn\nSmNTpCOLcD7xYw2xfBz6I1Ix7L3EPzAr4z6JOW5HcMSdFT0p88cbJKc4mN6EBJx1\n3AMZvGz704bx5rLOtAiqDE4J2y/2P8+cpvYFTyAacrYmbJhJZnq6NrWvfb8t5Co=\n=XmcF\n-----END PGP SIGNATURE-----\n", "payload": "tree 1fcdeeee4cede423a0c7ba97fb563c8a738ac638\nparent 593b38be6a1cb3a800c3241786df5abe2df2cfa4\nparent 5d359db9cf003ac05e989460e202137a0afa5cce\nauthor Jonas Schievink <jonasschievink@gmail.com> 1601164407 +0200\ncommitter GitHub <noreply@github.com> 1601164407 +0200\n\nRollup merge of #77231 - oli-obk:clippy_const_fn, r=Manishearth\n\nMove helper function for `missing_const_for_fn` out of rustc to clippy\n\ncc @rust-lang/clippy @ecstatic-morse #76618\n\nr? @Manishearth\n\nI also removed all support for suggesting a function could be `const fn` when that would require feature gates to actually work.\n\nThis means we'll now have to maintain this ourselves in clippy, but that's how most lints work anyway, so...\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb", "html_url": "https://github.com/rust-lang/rust/commit/aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "593b38be6a1cb3a800c3241786df5abe2df2cfa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/593b38be6a1cb3a800c3241786df5abe2df2cfa4", "html_url": "https://github.com/rust-lang/rust/commit/593b38be6a1cb3a800c3241786df5abe2df2cfa4"}, {"sha": "5d359db9cf003ac05e989460e202137a0afa5cce", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d359db9cf003ac05e989460e202137a0afa5cce", "html_url": "https://github.com/rust-lang/rust/commit/5d359db9cf003ac05e989460e202137a0afa5cce"}], "stats": {"total": 135, "additions": 32, "deletions": 103}, "files": [{"sha": "850cafcf89811c32091393e7dba612fc2b0784b1", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb", "patch": "@@ -36,7 +36,6 @@ pub mod match_branches;\n pub mod no_landing_pads;\n pub mod nrvo;\n pub mod promote_consts;\n-pub mod qualify_min_const_fn;\n pub mod remove_noop_landing_pads;\n pub mod remove_unneeded_drops;\n pub mod required_consts;"}, {"sha": "c3ff34e6e1eedd86002c0fc3151c5208c1ff471b", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb", "patch": "@@ -6,6 +6,7 @@\n #![feature(concat_idents)]\n #![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n+#![feature(in_band_lifetimes)]\n #![feature(or_patterns)]\n #![feature(rustc_private)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "e5f7cc51111203756298c993bc47be8e4bc4ff3f", "filename": "src/tools/clippy/clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, Constness, FnDecl, GenericParamKind, HirId};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n-use rustc_mir::transform::qualify_min_const_fn::is_min_const_fn;\n+use crate::utils::qualify_min_const_fn::is_min_const_fn;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n use rustc_typeck::hir_ty_to_ty;"}, {"sha": "96d9905027b628e2f2c14ba8f0d20f2b2d77869f", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb", "patch": "@@ -20,6 +20,7 @@ pub mod paths;\n pub mod ptr;\n pub mod sugg;\n pub mod usage;\n+pub mod qualify_min_const_fn;\n \n pub use self::attrs::*;\n pub use self::diagnostics::*;"}, {"sha": "6809b1fa88d35fa68f6e82597f18e64ba40c1cc3", "filename": "src/tools/clippy/clippy_lints/src/utils/qualify_min_const_fn.rs", "status": "renamed", "additions": 29, "deletions": 101, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs?ref=aa35c527fd4257d0eddfbd7837e87d6c2d1e75bb", "patch": "@@ -3,22 +3,14 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi::RustIntrinsic;\n use std::borrow::Cow;\n \n type McfResult = Result<(), (Span, Cow<'static, str>)>;\n \n pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -> McfResult {\n-    // Prevent const trait methods from being annotated as `stable`.\n-    if tcx.features().staged_api {\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-        if crate::const_eval::is_parent_const_impl_raw(tcx, hir_id) {\n-            return Err((body.span, \"trait methods cannot be stable const fn\".into()));\n-        }\n-    }\n-\n     let mut current = def_id;\n     loop {\n         let predicates = tcx.predicates_of(current);\n@@ -32,27 +24,20 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n                 | ty::PredicateAtom::ConstEquate(..)\n                 | ty::PredicateAtom::TypeWellFormedFromEnv(..) => continue,\n                 ty::PredicateAtom::ObjectSafe(_) => {\n-                    bug!(\"object safe predicate on function: {:#?}\", predicate)\n+                    panic!(\"object safe predicate on function: {:#?}\", predicate)\n                 }\n                 ty::PredicateAtom::ClosureKind(..) => {\n-                    bug!(\"closure kind predicate on function: {:#?}\", predicate)\n+                    panic!(\"closure kind predicate on function: {:#?}\", predicate)\n                 }\n                 ty::PredicateAtom::Subtype(_) => {\n-                    bug!(\"subtype predicate on function: {:#?}\", predicate)\n+                    panic!(\"subtype predicate on function: {:#?}\", predicate)\n                 }\n-                ty::PredicateAtom::Trait(pred, constness) => {\n+                ty::PredicateAtom::Trait(pred, _) => {\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;\n                     }\n                     match pred.self_ty().kind() {\n                         ty::Param(ref p) => {\n-                            // Allow `T: ?const Trait`\n-                            if constness == hir::Constness::NotConst\n-                                && feature_allowed(tcx, def_id, sym::const_trait_bound_opt_out)\n-                            {\n-                                continue;\n-                            }\n-\n                             let generics = tcx.generics_of(current);\n                             let def = generics.type_param(p, tcx);\n                             let span = tcx.def_span(def.def_id);\n@@ -77,26 +62,25 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n     }\n \n     for local in &body.local_decls {\n-        check_ty(tcx, local.ty, local.source_info.span, def_id)?;\n+        check_ty(tcx, local.ty, local.source_info.span)?;\n     }\n     // impl trait is gone in MIR, so check the return type manually\n     check_ty(\n         tcx,\n         tcx.fn_sig(def_id).output().skip_binder(),\n         body.local_decls.iter().next().unwrap().source_info.span,\n-        def_id,\n     )?;\n \n     for bb in body.basic_blocks() {\n-        check_terminator(tcx, body, def_id, bb.terminator())?;\n+        check_terminator(tcx, body, bb.terminator())?;\n         for stmt in &bb.statements {\n             check_statement(tcx, body, def_id, stmt)?;\n         }\n     }\n     Ok(())\n }\n \n-fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n+fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n     for arg in ty.walk() {\n         let ty = match arg.unpack() {\n             GenericArgKind::Type(ty) => ty,\n@@ -108,15 +92,11 @@ fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> Mc\n \n         match ty.kind() {\n             ty::Ref(_, _, hir::Mutability::Mut) => {\n-                if !feature_allowed(tcx, fn_def_id, sym::const_mut_refs) {\n                     return Err((span, \"mutable references in const fn are unstable\".into()));\n-                }\n             }\n             ty::Opaque(..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n             ty::FnPtr(..) => {\n-                if !tcx.const_fn_is_allowed_fn_ptr(fn_def_id) {\n                     return Err((span, \"function pointers in const fn are unstable\".into()));\n-                }\n             }\n             ty::Dynamic(preds, _) => {\n                 for pred in preds.iter() {\n@@ -161,12 +141,12 @@ fn check_rvalue(\n             Err((span, \"cannot access thread local storage in const fn\".into()))\n         }\n         Rvalue::Repeat(operand, _) | Rvalue::Use(operand) => {\n-            check_operand(tcx, operand, span, def_id, body)\n+            check_operand(tcx, operand, span, body)\n         }\n         Rvalue::Len(place)\n         | Rvalue::Discriminant(place)\n         | Rvalue::Ref(_, _, place)\n-        | Rvalue::AddressOf(_, place) => check_place(tcx, *place, span, def_id, body),\n+        | Rvalue::AddressOf(_, place) => check_place(tcx, *place, span,  body),\n         Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n             use rustc_middle::ty::cast::CastTy;\n             let cast_in = CastTy::from_ty(operand.ty(body, tcx)).expect(\"bad input type for cast\");\n@@ -175,14 +155,14 @@ fn check_rvalue(\n                 (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) => {\n                     Err((span, \"casting pointers to ints is unstable in const fn\".into()))\n                 }\n-                _ => check_operand(tcx, operand, span, def_id, body),\n+                _ => check_operand(tcx, operand, span, body),\n             }\n         }\n         Rvalue::Cast(\n             CastKind::Pointer(PointerCast::MutToConstPointer | PointerCast::ArrayToPointer),\n             operand,\n             _,\n-        ) => check_operand(tcx, operand, span, def_id, body),\n+        ) => check_operand(tcx, operand, span, body),\n         Rvalue::Cast(\n             CastKind::Pointer(\n                 PointerCast::UnsafeFnPointer\n@@ -204,7 +184,7 @@ fn check_rvalue(\n             };\n             let unsized_ty = tcx.struct_tail_erasing_lifetimes(pointee_ty, tcx.param_env(def_id));\n             if let ty::Slice(_) | ty::Str = unsized_ty.kind() {\n-                check_operand(tcx, op, span, def_id, body)?;\n+                check_operand(tcx, op, span, body)?;\n                 // Casting/coercing things to slices is fine.\n                 Ok(())\n             } else {\n@@ -214,8 +194,8 @@ fn check_rvalue(\n         }\n         // binops are fine on integers\n         Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n-            check_operand(tcx, lhs, span, def_id, body)?;\n-            check_operand(tcx, rhs, span, def_id, body)?;\n+            check_operand(tcx, lhs, span, body)?;\n+            check_operand(tcx, rhs, span, body)?;\n             let ty = lhs.ty(body, tcx);\n             if ty.is_integral() || ty.is_bool() || ty.is_char() {\n                 Ok(())\n@@ -230,14 +210,14 @@ fn check_rvalue(\n         Rvalue::UnaryOp(_, operand) => {\n             let ty = operand.ty(body, tcx);\n             if ty.is_integral() || ty.is_bool() {\n-                check_operand(tcx, operand, span, def_id, body)\n+                check_operand(tcx, operand, span, body)\n             } else {\n                 Err((span, \"only int and `bool` operations are stable in const fn\".into()))\n             }\n         }\n         Rvalue::Aggregate(_, operands) => {\n             for operand in operands {\n-                check_operand(tcx, operand, span, def_id, body)?;\n+                check_operand(tcx, operand, span, body)?;\n             }\n             Ok(())\n         }\n@@ -253,15 +233,15 @@ fn check_statement(\n     let span = statement.source_info.span;\n     match &statement.kind {\n         StatementKind::Assign(box (place, rval)) => {\n-            check_place(tcx, *place, span, def_id, body)?;\n+            check_place(tcx, *place, span,  body)?;\n             check_rvalue(tcx, body, def_id, rval, span)\n         }\n \n-        StatementKind::FakeRead(_, place) => check_place(tcx, **place, span, def_id, body),\n+        StatementKind::FakeRead(_, place) => check_place(tcx, **place, span, body),\n \n         // just an assignment\n         StatementKind::SetDiscriminant { place, .. } => {\n-            check_place(tcx, **place, span, def_id, body)\n+            check_place(tcx, **place, span,  body)\n         }\n \n         StatementKind::LlvmInlineAsm { .. } => {\n@@ -282,11 +262,10 @@ fn check_operand(\n     tcx: TyCtxt<'tcx>,\n     operand: &Operand<'tcx>,\n     span: Span,\n-    def_id: DefId,\n     body: &Body<'tcx>,\n ) -> McfResult {\n     match operand {\n-        Operand::Move(place) | Operand::Copy(place) => check_place(tcx, *place, span, def_id, body),\n+        Operand::Move(place) | Operand::Copy(place) => check_place(tcx, *place, span, body),\n         Operand::Constant(c) => match c.check_static_ptr(tcx) {\n             Some(_) => Err((span, \"cannot access `static` items in const fn\".into())),\n             None => Ok(()),\n@@ -298,7 +277,6 @@ fn check_place(\n     tcx: TyCtxt<'tcx>,\n     place: Place<'tcx>,\n     span: Span,\n-    def_id: DefId,\n     body: &Body<'tcx>,\n ) -> McfResult {\n     let mut cursor = place.projection.as_ref();\n@@ -310,9 +288,7 @@ fn check_place(\n                 if let Some(def) = base_ty.ty_adt_def() {\n                     // No union field accesses in `const fn`\n                     if def.is_union() {\n-                        if !feature_allowed(tcx, def_id, sym::const_fn_union) {\n                             return Err((span, \"accessing union fields is unstable\".into()));\n-                        }\n                     }\n                 }\n             }\n@@ -327,48 +303,9 @@ fn check_place(\n     Ok(())\n }\n \n-/// Returns `true` if the given feature gate is allowed within the function with the given `DefId`.\n-fn feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bool {\n-    // All features require that the corresponding gate be enabled,\n-    // even if the function has `#[allow_internal_unstable(the_gate)]`.\n-    if !tcx.features().enabled(feature_gate) {\n-        return false;\n-    }\n-\n-    // If this crate is not using stability attributes, or this function is not claiming to be a\n-    // stable `const fn`, that is all that is required.\n-    if !tcx.features().staged_api || tcx.has_attr(def_id, sym::rustc_const_unstable) {\n-        return true;\n-    }\n-\n-    // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n-    // opt-in via `allow_internal_unstable`.\n-    super::check_consts::allow_internal_unstable(tcx, def_id, feature_gate)\n-}\n-\n-/// Returns `true` if the given library feature gate is allowed within the function with the given `DefId`.\n-pub fn lib_feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bool {\n-    // All features require that the corresponding gate be enabled,\n-    // even if the function has `#[allow_internal_unstable(the_gate)]`.\n-    if !tcx.features().declared_lib_features.iter().any(|&(sym, _)| sym == feature_gate) {\n-        return false;\n-    }\n-\n-    // If this crate is not using stability attributes, or this function is not claiming to be a\n-    // stable `const fn`, that is all that is required.\n-    if !tcx.features().staged_api || tcx.has_attr(def_id, sym::rustc_const_unstable) {\n-        return true;\n-    }\n-\n-    // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n-    // opt-in via `allow_internal_unstable`.\n-    super::check_consts::allow_internal_unstable(tcx, def_id, feature_gate)\n-}\n-\n fn check_terminator(\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n-    def_id: DefId,\n     terminator: &Terminator<'tcx>,\n ) -> McfResult {\n     let span = terminator.source_info.span;\n@@ -380,14 +317,14 @@ fn check_terminator(\n         | TerminatorKind::Resume\n         | TerminatorKind::Unreachable => Ok(()),\n \n-        TerminatorKind::Drop { place, .. } => check_place(tcx, *place, span, def_id, body),\n+        TerminatorKind::Drop { place, .. } => check_place(tcx, *place, span,  body),\n         TerminatorKind::DropAndReplace { place, value, .. } => {\n-            check_place(tcx, *place, span, def_id, body)?;\n-            check_operand(tcx, value, span, def_id, body)\n+            check_place(tcx, *place, span,  body)?;\n+            check_operand(tcx, value, span, body)\n         }\n \n         TerminatorKind::SwitchInt { discr, switch_ty: _, values: _, targets: _ } => {\n-            check_operand(tcx, discr, span, def_id, body)\n+            check_operand(tcx, discr, span, body)\n         }\n \n         TerminatorKind::Abort => Err((span, \"abort is not stable in const fn\".into())),\n@@ -405,15 +342,7 @@ fn check_terminator(\n         } => {\n             let fn_ty = func.ty(body, tcx);\n             if let ty::FnDef(fn_def_id, _) = *fn_ty.kind() {\n-                // Allow unstable const if we opt in by using #[allow_internal_unstable]\n-                // on function or macro declaration.\n-                if !crate::const_eval::is_min_const_fn(tcx, fn_def_id)\n-                    && !crate::const_eval::is_unstable_const_fn(tcx, fn_def_id)\n-                        .map(|feature| {\n-                            span.allows_unstable(feature)\n-                                || lib_feature_allowed(tcx, def_id, feature)\n-                        })\n-                        .unwrap_or(false)\n+                if !rustc_mir::const_eval::is_min_const_fn(tcx, fn_def_id)\n                 {\n                     return Err((\n                         span,\n@@ -432,18 +361,17 @@ fn check_terminator(\n                 // transmutes in const fn before we add more hacks to this.\n                 if tcx.fn_sig(fn_def_id).abi() == RustIntrinsic\n                     && tcx.item_name(fn_def_id) == sym::transmute\n-                    && !feature_allowed(tcx, def_id, sym::const_fn_transmute)\n                 {\n                     return Err((\n                         span,\n                         \"can only call `transmute` from const items, not `const fn`\".into(),\n                     ));\n                 }\n \n-                check_operand(tcx, func, span, fn_def_id, body)?;\n+                check_operand(tcx, func, span, body)?;\n \n                 for arg in args {\n-                    check_operand(tcx, arg, span, fn_def_id, body)?;\n+                    check_operand(tcx, arg, span, body)?;\n                 }\n                 Ok(())\n             } else {\n@@ -452,7 +380,7 @@ fn check_terminator(\n         }\n \n         TerminatorKind::Assert { cond, expected: _, msg: _, target: _, cleanup: _ } => {\n-            check_operand(tcx, cond, span, def_id, body)\n+            check_operand(tcx, cond, span, body)\n         }\n \n         TerminatorKind::InlineAsm { .. } => {", "previous_filename": "compiler/rustc_mir/src/transform/qualify_min_const_fn.rs"}]}