{"sha": "2992b19c82c0c5f96327b3be037777bf42862230", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5OTJiMTljODJjMGM1Zjk2MzI3YjNiZTAzNzc3N2JmNDI4NjIyMzA=", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-04-13T20:55:47Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-04-14T18:06:26Z"}, "message": "Added inferred local type comparion to SpanlessEq", "tree": {"sha": "7f085e8a5cf9bb20621db1a0a4ad1d6a5fcced56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f085e8a5cf9bb20621db1a0a4ad1d6a5fcced56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2992b19c82c0c5f96327b3be037777bf42862230", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2992b19c82c0c5f96327b3be037777bf42862230", "html_url": "https://github.com/rust-lang/rust/commit/2992b19c82c0c5f96327b3be037777bf42862230", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2992b19c82c0c5f96327b3be037777bf42862230/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e90bb671a73a5b9de08133605ef3db93b62b50c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e90bb671a73a5b9de08133605ef3db93b62b50c", "html_url": "https://github.com/rust-lang/rust/commit/7e90bb671a73a5b9de08133605ef3db93b62b50c"}], "stats": {"total": 70, "additions": 65, "deletions": 5}, "files": [{"sha": "34ea014dd6786d4f510d319b00b03abffd768dd0", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2992b19c82c0c5f96327b3be037777bf42862230/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2992b19c82c0c5f96327b3be037777bf42862230/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=2992b19c82c0c5f96327b3be037777bf42862230", "patch": "@@ -293,10 +293,11 @@ fn lint_same_then_else<'tcx>(\n /// The return tuple is structured as follows:\n /// 1. The amount of equal statements from the start\n /// 2. The amount of equal statements from the end\n-/// 3. An indication if the block expressions are the same. This will also be true if both are `None`\n+/// 3. An indication if the block expressions are the same. This will also be true if both are\n+/// `None`\n ///\n-/// This function can also trigger the `IF_SAME_THEN_ELSE` in which case it'll return `(0, 0, false)`\n-/// to aboard any further processing and avoid duplicate lint triggers.\n+/// This function can also trigger the `IF_SAME_THEN_ELSE` in which case it'll return `(0, 0,\n+/// false)` to aboard any further processing and avoid duplicate lint triggers.\n fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> (usize, usize, bool) {\n     let mut start_eq = usize::MAX;\n     let mut end_eq = usize::MAX;\n@@ -307,7 +308,7 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> (usize,\n \n         // `SpanlessEq` now keeps track of the locals and is therefore context sensitive clippy#6752.\n         // The comparison therefore needs to be done in a way that builds the correct context.\n-        let mut evaluator = SpanlessEq::new(cx);\n+        let mut evaluator = SpanlessEq::new(cx).enable_check_inferred_local_types();\n         let mut evaluator = evaluator.inter_expr();\n \n         let current_start_eq = count_eq(&mut l_stmts.iter(), &mut r_stmts.iter(), |l, r| evaluator.eq_stmt(l, r));"}, {"sha": "97db58ae12b9a6114ec521ad48330027d317f25d", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2992b19c82c0c5f96327b3be037777bf42862230/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2992b19c82c0c5f96327b3be037777bf42862230/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=2992b19c82c0c5f96327b3be037777bf42862230", "patch": "@@ -1,6 +1,7 @@\n use crate::consts::{constant_context, constant_simple};\n use crate::differing_macro_contexts;\n use crate::source::snippet_opt;\n+use if_chain::if_chain;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def::Res;\n@@ -29,6 +30,30 @@ pub struct SpanlessEq<'a, 'tcx> {\n     maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n     allow_side_effects: bool,\n     expr_fallback: Option<Box<dyn FnMut(&Expr<'_>, &Expr<'_>) -> bool + 'a>>,\n+    /// This adds an additional type comparison to locals that insures that even the\n+    /// inferred of the value is the same.\n+    ///\n+    /// **Example**\n+    /// * Context 1\n+    /// ```ignore\n+    /// let vec = Vec::new();\n+    /// vec.push(\"A string\");\n+    /// ```\n+    ///\n+    /// * Context 2\n+    /// ```ignore\n+    /// let vec = Vec::new();\n+    /// vec.push(0); // An integer\n+    /// ```\n+    ///\n+    /// Only comparing the first local definition would usually return that they are\n+    /// equal, since they are identical. However, they are different due to the context\n+    /// as they have different inferred types.\n+    ///\n+    /// This option enables or disables the specific check of the inferred type.\n+    ///\n+    /// Note: This check will only be done if `self.maybe_typeck_results` is `Some()`.\n+    check_inferred_local_types: bool,\n }\n \n impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n@@ -38,6 +63,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             maybe_typeck_results: cx.maybe_typeck_results(),\n             allow_side_effects: true,\n             expr_fallback: None,\n+            check_inferred_local_types: false,\n         }\n     }\n \n@@ -56,6 +82,13 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n+    pub fn enable_check_inferred_local_types(self) -> Self {\n+        Self {\n+            check_inferred_local_types: true,\n+            ..self\n+        }\n+    }\n+\n     /// Use this method to wrap comparisons that may involve inter-expression context.\n     /// See `self.locals`.\n     pub fn inter_expr(&mut self) -> HirEqInterExpr<'_, 'a, 'tcx> {\n@@ -96,6 +129,21 @@ impl HirEqInterExpr<'_, '_, '_> {\n     pub fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&StmtKind::Local(ref l), &StmtKind::Local(ref r)) => {\n+                // See `SpanlessEq::check_inferred_local_types` for an explication of this check\n+                if_chain! {\n+                    if l.ty.is_none() && r.ty.is_none();\n+                    if self.inner.check_inferred_local_types;\n+                    if let Some(tcx) = self.inner.maybe_typeck_results;\n+\n+                    // Check the inferred types\n+                    let l_ty = tcx.pat_ty(&l.pat);\n+                    let r_ty = tcx.pat_ty(&r.pat);\n+                    if l_ty != r_ty;\n+                    then {\n+                        return false;\n+                    }\n+                }\n+\n                 // eq_pat adds the HirIds to the locals map. We therefor call it last to make sure that\n                 // these only get added if the init and type is equal.\n                 both(&l.init, &r.init, |l, r| self.eq_expr(l, r))"}, {"sha": "280bde73ed713879371ae1e8f2440d0a74ff5db0", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2992b19c82c0c5f96327b3be037777bf42862230/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2992b19c82c0c5f96327b3be037777bf42862230/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=2992b19c82c0c5f96327b3be037777bf42862230", "patch": "@@ -1212,7 +1212,7 @@ pub fn parent_node_is_if_expr(expr: &Expr<'_>, cx: &LateContext<'_>) -> bool {\n     let map = cx.tcx.hir();\n     let parent_id = map.get_parent_node(expr.hir_id);\n     let parent_node = map.get(parent_id);\n-    \n+\n     // Check for `if`\n     if_chain! {\n         if let Node::Expr(expr) = parent_node;"}, {"sha": "51a46481399b4e6a5b6af13ec2384fbe46eb263e", "filename": "tests/ui/branches_sharing_code/shared_at_top.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2992b19c82c0c5f96327b3be037777bf42862230/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2992b19c82c0c5f96327b3be037777bf42862230/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.rs?ref=2992b19c82c0c5f96327b3be037777bf42862230", "patch": "@@ -100,4 +100,15 @@ fn check_if_same_than_else_mask() {\n     }\n }\n \n+#[allow(clippy::vec_init_then_push)]\n+fn pf_local_with_inferred_type_issue7053() {\n+    if true {\n+        let mut v = Vec::new();\n+        v.push(0);\n+    } else {\n+        let mut v = Vec::new();\n+        v.push(\"\");\n+    };\n+}\n+\n fn main() {}"}]}