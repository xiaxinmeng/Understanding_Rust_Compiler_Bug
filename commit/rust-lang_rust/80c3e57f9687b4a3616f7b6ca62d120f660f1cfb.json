{"sha": "80c3e57f9687b4a3616f7b6ca62d120f660f1cfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYzNlNTdmOTY4N2I0YTM2MTZmN2I2Y2E2MmQxMjBmNjYwZjFjZmI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2017-12-22T15:55:46Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2017-12-22T15:55:46Z"}, "message": "Finish the bulk of RFC text", "tree": {"sha": "d5d0d0f43e42287c5e9c1bc8e13efb140bd1511b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5d0d0f43e42287c5e9c1bc8e13efb140bd1511b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80c3e57f9687b4a3616f7b6ca62d120f660f1cfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80c3e57f9687b4a3616f7b6ca62d120f660f1cfb", "html_url": "https://github.com/rust-lang/rust/commit/80c3e57f9687b4a3616f7b6ca62d120f660f1cfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80c3e57f9687b4a3616f7b6ca62d120f660f1cfb/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a6361b219a4ff53aa0d0ffc402921eaa67230c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a6361b219a4ff53aa0d0ffc402921eaa67230c8", "html_url": "https://github.com/rust-lang/rust/commit/7a6361b219a4ff53aa0d0ffc402921eaa67230c8"}], "stats": {"total": 217, "additions": 209, "deletions": 8}, "files": [{"sha": "46bec624d60b7cc153abe9bc7290dbc9a99dbf5e", "filename": "rfc.md", "status": "modified", "additions": 209, "deletions": 8, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/80c3e57f9687b4a3616f7b6ca62d120f660f1cfb/rfc.md", "raw_url": "https://github.com/rust-lang/rust/raw/80c3e57f9687b4a3616f7b6ca62d120f660f1cfb/rfc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rfc.md?ref=80c3e57f9687b4a3616f7b6ca62d120f660f1cfb", "patch": "@@ -1,4 +1,4 @@\n-- Feature Name: libsyntax2\n+- Feature Name: libsyntax2.0\n - Start Date: 2017-12-30\n - RFC PR: (leave this empty)\n - Rust Issue: (leave this empty)\n@@ -111,6 +111,8 @@ compiler.\n [Kotlin]: https://kotlinlang.org/\n \n \n+## Untyped Tree\n+\n The main idea is to store the minimal amount of information in the\n tree itself, and instead lean heavily on the source code string for\n the actual data about identifier names, constant values etc.\n@@ -123,6 +125,90 @@ syntactic categories\n \n \n ```rust\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct NodeKind(u16);\n+\n+pub struct File {\n+    text: String,\n+    nodes: Vec<NodeData>,\n+}\n+\n+struct NodeData {\n+    kind: NodeKind,\n+    range: (u32, u32),\n+    parent: Option<u32>,\n+    first_child: Option<u32>,\n+    next_sibling: Option<u32>,\n+}\n+\n+#[derive(Clone, Copy)]\n+pub struct Node<'f> {\n+    file: &'f File,\n+    idx: u32,\n+}\n+\n+pub struct Children<'f> {\n+    next: Option<Node<'f>>,\n+}\n+\n+impl File {\n+    pub fn root<'f>(&'f self) -> Node<'f> {\n+        assert!(!self.nodes.is_empty());\n+        Node { file: self, idx: 0 }\n+    }\n+}\n+\n+impl<'f> Node<'f> {\n+    pub fn kind(&self) -> NodeKind {\n+        self.data().kind\n+    }\n+\n+    pub fn text(&self) -> &'f str {\n+        let (start, end) = self.data().range;\n+        &self.file.text[start as usize..end as usize]\n+    }\n+\n+    pub fn parent(&self) -> Option<Node<'f>> {\n+        self.as_node(self.data().parent)\n+    }\n+\n+    pub fn children(&self) -> Children<'f> {\n+        Children { next: self.as_node(self.data().first_child) }\n+    }\n+\n+    fn data(&self) -> &'f NodeData {\n+        &self.file.nodes[self.idx as usize]\n+    }\n+\n+    fn as_node(&self, idx: Option<u32>) -> Option<Node<'f>> {\n+        idx.map(|idx| Node { file: self.file, idx })\n+    }\n+}\n+\n+impl<'f> Iterator for Children<'f> {\n+    type Item = Node<'f>;\n+\n+    fn next(&mut self) -> Option<Node<'f>> {\n+        let next = self.next;\n+        self.next = next.and_then(|node| node.as_node(node.data().next_sibling));\n+        next\n+    }\n+}\n+\n+pub const ERROR: NodeKind = NodeKind(0);\n+pub const WHITESPACE: NodeKind = NodeKind(1);\n+pub const STRUCT_KW: NodeKind = NodeKind(2);\n+pub const IDENT: NodeKind = NodeKind(3);\n+pub const L_CURLY: NodeKind = NodeKind(4);\n+pub const R_CURLY: NodeKind = NodeKind(5);\n+pub const COLON: NodeKind = NodeKind(6);\n+pub const COMMA: NodeKind = NodeKind(7);\n+pub const AMP: NodeKind = NodeKind(8);\n+pub const LINE_COMMENT: NodeKind = NodeKind(9);\n+pub const FILE: NodeKind = NodeKind(10);\n+pub const STRUCT_DEF: NodeKind = NodeKind(11);\n+pub const FIELD_DEF: NodeKind = NodeKind(12);\n+pub const TYPE_REF: NodeKind = NodeKind(13);\n ```\n \n Here is a rust snippet and the corresponding parse tree:\n@@ -182,22 +268,137 @@ Note several features of the tree:\n   field.\n   \n \n+## Typed Tree\n+  \n+It's hard to work with this raw parse tree, because it is untyped:\n+node containing a struct definition has the same API as the node for\n+the struct field. But it's possible to add a strongly typed layer on\n+top of this raw tree, and get a zero-cost typed AST. Here is an\n+example which adds type-safe wrappers for structs and fields:\n+\n+```rust\n+pub trait AstNode<'f>: Copy + 'f {\n+    fn new(node: Node<'f>) -> Option<Self>;\n+    fn node(&self) -> Node<'f>;\n+}\n+\n+pub fn child_of_kind<'f>(node: Node<'f>, kind: NodeKind) -> Option<Node<'f>> {\n+    node.children().find(|child| child.kind() == kind)\n+}\n+\n+pub fn ast_children<'f, A: AstNode<'f>>(node: Node<'f>) -> Box<Iterator<Item=A> + 'f> {\n+    Box::new(node.children().filter_map(A::new))\n+}\n+\n+#[derive(Clone, Copy)]\n+pub struct StructDef<'f>(Node<'f>);\n+\n+#[derive(Clone, Copy)]\n+pub struct FieldDef<'f>(Node<'f>);\n+\n+#[derive(Clone, Copy)]\n+pub struct TypeRef<'f>(Node<'f>);\n+\n+pub trait NameOwner<'f>: AstNode<'f> {\n+    fn name_ident(&self) -> Node<'f> {\n+        child_of_kind(self.node(), IDENT).unwrap()\n+    }\n+\n+    fn name(&self) -> &'f str { self.name_ident().text() }\n+}\n+\n+\n+impl<'f> AstNode<'f> for StructDef<'f> {\n+    fn new(node: Node<'f>) -> Option<Self> {\n+        if node.kind() == STRUCT_DEF { Some(StructDef(node)) } else { None }\n+    }\n+    fn node(&self) -> Node<'f> { self.0 }\n+}\n+\n+impl<'f> AstNode<'f> for FieldDef<'f> {\n+    fn new(node: Node<'f>) -> Option<Self> {\n+        if node.kind() == FIELD_DEF { Some(FieldDef(node)) } else { None }\n+    }\n+    fn node(&self) -> Node<'f> { self.0 }\n+}\n+\n+impl<'f> AstNode<'f> for TypeRef<'f> {\n+    fn new(node: Node<'f>) -> Option<Self> {\n+        if node.kind() == TYPE_REF { Some(TypeRef(node)) } else { None }\n+    }\n+    fn node(&self) -> Node<'f> { self.0 }\n+}\n+\n+impl<'f> NameOwner<'f> for StructDef<'f> {}\n+impl<'f> NameOwner<'f> for FieldDef<'f> {}\n+\n+impl<'f> StructDef<'f> {\n+    pub fn fields(&self) -> Box<Iterator<Item=FieldDef<'f>> + 'f> {\n+        ast_children(self.node())\n+    }\n+}\n+\n+impl<'f> FieldDef<'f> {\n+    pub fn type_ref(&self) -> Option<TypeRef<'f>> {\n+        ast_children(self.node()).next()\n+    }\n+}\n+```\n+\n+\n+## Missing Source Code\n+\n+The crucial feature of this syntax tree is that it is just a view into\n+the original source code. And this poses a problem for the Rust\n+language, because not all compiled Rust code is represented in the\n+form of source code! Specifically, Rust has a powerful macro system,\n+which effectively allows to create and parse additional source code at\n+compile time. It is not entirely clear that the proposed parsing\n+framework is able to handle this use case, and it's the main purpose\n+of this RFC to figure it out. The current idea for handling macros is\n+to make each macro expansion produce a triple of (expansion text,\n+syntax tree, hygiene information), where hygiene information is a side\n+table, which colors different ranges of the expansion text according\n+to the original syntactic context.\n+\n+\n+## Implementation plan\n+\n+This RFC proposes huge changes to the internals of the compiler, so\n+it's important to proceed carefully and incrementally. The following\n+plan is suggested:\n+\n+* RFC discussion about the theoretical feasibility of the proposal.\n+\n+* Implementation of the proposal as a completely separate crates.io\n+  crate.\n+  \n+* A prototype implementation of the macro expansion on top of the new sytnax tree.\n+\n+* Additional round of discussion/RFC about merging with the mainline\n+  compiler.\n+\n \n # Drawbacks\n [drawbacks]: #drawbacks\n \n-Why should we *not* do this?\n+- No harm will be done as long as the new libsyntax exists as an\n+  experiemt on crates.io. However, actually using it in the compiler\n+  and other tools would require massive refactorings.\n \n # Rationale and alternatives\n [alternatives]: #alternatives\n \n-- Why is this design the best in the space of possible designs?\n-- What other designs have been considered and what is the rationale for not choosing them?\n-- What is the impact of not doing this?\n+- Incrementally add more information about source code to the current AST.\n+- Move the current libsyntax to crates.io as is. \n+- Explore alternative representations for the parse tree.\n \n # Unresolved questions\n [unresolved]: #unresolved-questions\n \n-- What parts of the design do you expect to resolve through the RFC process before this gets merged?\n-- What parts of the design do you expect to resolve through the implementation of this feature before stabilization?\n-- What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?\n+- Is it at all possible to represent Rust parser as a pure function of\n+  the source code?\n+- Is it possible to implement macro expansion using the proposed\n+  framework?\n+- How to actually phase out current libsyntax, if libsyntax2.0 turns\n+  out to be a success?"}]}