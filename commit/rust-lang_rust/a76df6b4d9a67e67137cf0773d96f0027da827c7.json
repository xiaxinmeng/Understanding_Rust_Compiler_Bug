{"sha": "a76df6b4d9a67e67137cf0773d96f0027da827c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3NmRmNmI0ZDlhNjdlNjcxMzdjZjA3NzNkOTZmMDAyN2RhODI3Yzc=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-10-04T18:20:15Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-10-04T18:40:14Z"}, "message": "Make listItem contain option", "tree": {"sha": "c0fa9eb72cfd757a4eed9ece057dfb177d4df28b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0fa9eb72cfd757a4eed9ece057dfb177d4df28b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a76df6b4d9a67e67137cf0773d96f0027da827c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a76df6b4d9a67e67137cf0773d96f0027da827c7", "html_url": "https://github.com/rust-lang/rust/commit/a76df6b4d9a67e67137cf0773d96f0027da827c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a76df6b4d9a67e67137cf0773d96f0027da827c7/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "965ea09664c1649ac9bfbd128eda631a41d73dee", "url": "https://api.github.com/repos/rust-lang/rust/commits/965ea09664c1649ac9bfbd128eda631a41d73dee", "html_url": "https://github.com/rust-lang/rust/commit/965ea09664c1649ac9bfbd128eda631a41d73dee"}], "stats": {"total": 208, "additions": 92, "deletions": 116}, "files": [{"sha": "1688b4b363ea8f7e3c75c7cb62f07ef9fe8c5ec3", "filename": "src/config.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a76df6b4d9a67e67137cf0773d96f0027da827c7/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a76df6b4d9a67e67137cf0773d96f0027da827c7/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=a76df6b4d9a67e67137cf0773d96f0027da827c7", "patch": "@@ -90,7 +90,6 @@ configuration_option_enum! { LicensePolicy:\n     FileLicense,\n }\n \n-// TODO: this is not necessary any more\n configuration_option_enum! { MultilineStyle:\n     // Use horizontal layout if it fits in one line, fall back to vertical\n     PreferSingle,"}, {"sha": "53e24b70984eb806d156269db9f9bdff242fc800", "filename": "src/expr.rs", "status": "modified", "additions": 12, "deletions": 32, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a76df6b4d9a67e67137cf0773d96f0027da827c7/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a76df6b4d9a67e67137cf0773d96f0027da827c7/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=a76df6b4d9a67e67137cf0773d96f0027da827c7", "patch": "@@ -218,18 +218,16 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n                              |item| item.span.lo,\n                              |item| item.span.hi,\n                              // 1 = [\n-                             // FIXME(#133): itemize_list doesn't support\n-                             // rewrite failure. This may not be its\n-                             // responsibility, but that of write_list.\n-                             |item| {\n-                                 item.rewrite(context, max_item_width, offset + 1)\n-                                     .unwrap_or_else(|| context.snippet(item.span))\n-                             },\n+                             |item| item.rewrite(context, max_item_width, offset + 1),\n                              span_after(span, \"[\", context.codemap),\n                              span.hi)\n                     .collect::<Vec<_>>();\n \n-    let tactic = if items.iter().any(|li| li.item.len() > 10 || li.is_multiline()) {\n+    let has_long_item = try_opt!(items.iter()\n+                                      .map(|li| li.item.as_ref().map(|s| s.len() > 10))\n+                                      .fold(Some(false),\n+                                            |acc, x| acc.and_then(|y| x.map(|x| (x || y)))));\n+    let tactic = if has_long_item || items.iter().any(|li| li.is_multiline()) {\n         definitive_tactic(&items, ListTactic::HorizontalVertical, max_item_width)\n     } else {\n         DefinitiveListTactic::Mixed\n@@ -280,15 +278,7 @@ fn rewrite_closure(capture: ast::CaptureClause,\n                                  \"|\",\n                                  |arg| span_lo_for_arg(arg),\n                                  |arg| span_hi_for_arg(arg),\n-                                 |arg| {\n-                                     // FIXME: we should just escalate failure\n-                                     // here, but itemize_list doesn't allow it.\n-                                     arg.rewrite(context, budget, argument_offset)\n-                                        .unwrap_or_else(|| {\n-                                            context.snippet(mk_sp(span_lo_for_arg(arg),\n-                                                                  span_hi_for_arg(arg)))\n-                                        })\n-                                 },\n+                                 |arg| arg.rewrite(context, budget, argument_offset),\n                                  span_after(span, \"|\", context.codemap),\n                                  body.span.lo);\n     let item_vec = arg_items.collect::<Vec<_>>();\n@@ -1151,11 +1141,7 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n                              \")\",\n                              |item| item.span.lo,\n                              |item| item.span.hi,\n-                             // Take old span when rewrite fails.\n-                             |item| {\n-                                 item.rewrite(&inner_context, remaining_width, offset)\n-                                     .unwrap_or(context.snippet(item.span))\n-                             },\n+                             |item| item.rewrite(&inner_context, remaining_width, offset),\n                              span.lo,\n                              span.hi);\n \n@@ -1251,18 +1237,13 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                                  match *item {\n                                      StructLitField::Regular(ref field) => {\n                                          rewrite_field(inner_context, &field, v_budget, indent)\n-                                             .unwrap_or(context.snippet(field.span))\n                                      }\n                                      StructLitField::Base(ref expr) => {\n                                          // 2 = ..\n-                                         format!(\"..{}\",\n-                                                 v_budget.checked_sub(2)\n-                                                         .and_then(|v_budget| {\n-                                                             expr.rewrite(inner_context,\n-                                                                          v_budget,\n-                                                                          indent + 2)\n-                                                         })\n-                                                         .unwrap_or(context.snippet(expr.span)))\n+                                         expr.rewrite(inner_context,\n+                                                      try_opt!(v_budget.checked_sub(2)),\n+                                                      indent + 2)\n+                                             .map(|s| format!(\"..{}\", s))\n                                      }\n                                  }\n                              },\n@@ -1365,7 +1346,6 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n                              |item| {\n                                  let inner_width = context.config.max_width - indent.width() - 1;\n                                  item.rewrite(context, inner_width, indent)\n-                                     .unwrap_or(context.snippet(item.span))\n                              },\n                              span.lo + BytePos(1), // Remove parens\n                              span.hi - BytePos(1));"}, {"sha": "2c518378b36a52f223137dd619fcb5a537af4367", "filename": "src/imports.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a76df6b4d9a67e67137cf0773d96f0027da827c7/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a76df6b4d9a67e67137cf0773d96f0027da827c7/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=a76df6b4d9a67e67137cf0773d96f0027da827c7", "patch": "@@ -71,7 +71,7 @@ fn rewrite_single_use_list(path_str: String, vpi: &ast::PathListItem) -> String\n     append_alias(path_item_str, vpi)\n }\n \n-fn rewrite_path_item(vpi: &&ast::PathListItem) -> String {\n+fn rewrite_path_item(vpi: &&ast::PathListItem) -> Option<String> {\n     let path_item_str = match vpi.node {\n         ast::PathListItem_::PathListIdent{ name, .. } => {\n             name.to_string()\n@@ -81,7 +81,7 @@ fn rewrite_path_item(vpi: &&ast::PathListItem) -> String {\n         }\n     };\n \n-    append_alias(path_item_str, vpi)\n+    Some(append_alias(path_item_str, vpi))\n }\n \n fn append_alias(path_item_str: String, vpi: &ast::PathListItem) -> String {\n@@ -142,8 +142,6 @@ pub fn rewrite_use_list(width: usize,\n     // We prefixed the item list with a dummy value so that we can\n     // potentially move \"self\" to the front of the vector without touching\n     // the rest of the items.\n-    // FIXME: Make more efficient by using a linked list? That would require\n-    // changes to the signatures of write_list.\n     let has_self = move_self_to_front(&mut items);\n     let first_index = if has_self {\n         0\n@@ -181,7 +179,7 @@ pub fn rewrite_use_list(width: usize,\n \n // Returns true when self item was found.\n fn move_self_to_front(items: &mut Vec<ListItem>) -> bool {\n-    match items.iter().position(|item| item.item == \"self\") {\n+    match items.iter().position(|item| item.item.as_ref().map(|x| &x[..]) == Some(\"self\")) {\n         Some(pos) => {\n             items[0] = items.remove(pos);\n             true"}, {"sha": "e2f59f0fb6a3b197b45133c46f2daa9dcc533d0c", "filename": "src/items.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a76df6b4d9a67e67137cf0773d96f0027da827c7/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a76df6b4d9a67e67137cf0773d96f0027da827c7/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=a76df6b4d9a67e67137cf0773d96f0027da827c7", "patch": "@@ -481,7 +481,7 @@ impl<'a> FmtVisitor<'a> {\n                                           \")\",\n                                           |arg| span_lo_for_arg(arg),\n                                           |arg| arg.ty.span.hi,\n-                                          |_| String::new(),\n+                                          |_| None,\n                                           comment_span_start,\n                                           span.hi);\n \n@@ -491,7 +491,7 @@ impl<'a> FmtVisitor<'a> {\n         assert_eq!(arg_item_strs.len(), arg_items.len());\n \n         for (item, arg) in arg_items.iter_mut().zip(arg_item_strs) {\n-            item.item = arg;\n+            item.item = Some(arg);\n         }\n \n         let indent = match self.config.fn_arg_indent {\n@@ -630,11 +630,9 @@ impl<'a> FmtVisitor<'a> {\n                                              |arg| arg.ty.span.hi,\n                                              |arg| {\n                                                  // FIXME silly width, indent\n-                                                 arg.ty\n-                                                    .rewrite(&self.get_context(),\n-                                                             1000,\n-                                                             Indent::empty())\n-                                                    .unwrap()\n+                                                 arg.ty.rewrite(&self.get_context(),\n+                                                                1000,\n+                                                                Indent::empty())\n                                              },\n                                              span_after(field.span, \"(\", self.codemap),\n                                              next_span_start);\n@@ -863,9 +861,14 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     // Field of a struct\n-    fn format_field(&self, field: &ast::StructField) -> String {\n+    fn format_field(&self, field: &ast::StructField) -> Option<String> {\n         if contains_skip(&field.node.attrs) {\n-            return self.snippet(codemap::mk_sp(field.node.attrs[0].span.lo, field.span.hi));\n+            // FIXME: silly width, indent\n+            return wrap_str(self.snippet(codemap::mk_sp(field.node.attrs[0].span.lo,\n+                                                        field.span.hi)),\n+                            self.config.max_width,\n+                            1000,\n+                            Indent::empty());\n         }\n \n         let name = match field.node.kind {\n@@ -877,24 +880,23 @@ impl<'a> FmtVisitor<'a> {\n             ast::StructFieldKind::UnnamedField(vis) => format_visibility(vis),\n         };\n         // FIXME silly width, indent\n-        let typ = field.node.ty.rewrite(&self.get_context(), 1000, Indent::empty()).unwrap();\n+        let typ = try_opt!(field.node.ty.rewrite(&self.get_context(), 1000, Indent::empty()));\n \n         let indent = self.block_indent.block_indent(self.config);\n-        let mut attr_str = field.node\n-                                .attrs\n-                                .rewrite(&self.get_context(),\n-                                         self.config.max_width - indent.width(),\n-                                         indent)\n-                                .unwrap();\n+        let mut attr_str = try_opt!(field.node\n+                                         .attrs\n+                                         .rewrite(&self.get_context(),\n+                                                  self.config.max_width - indent.width(),\n+                                                  indent));\n         if !attr_str.is_empty() {\n             attr_str.push('\\n');\n             attr_str.push_str(&indent.to_string(self.config));\n         }\n \n-        match name {\n+        Some(match name {\n             Some(name) => format!(\"{}{}{}: {}\", attr_str, vis, name, typ),\n             None => format!(\"{}{}{}\", attr_str, vis, typ),\n-        }\n+        })\n     }\n \n     fn rewrite_generics(&self,\n@@ -923,10 +925,8 @@ impl<'a> FmtVisitor<'a> {\n \n         // Strings for the generics.\n         let context = self.get_context();\n-        // FIXME: don't unwrap\n-        let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(&context, h_budget, offset).unwrap());\n-        let ty_strs = tys.iter()\n-                         .map(|ty_param| ty_param.rewrite(&context, h_budget, offset).unwrap());\n+        let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(&context, h_budget, offset));\n+        let ty_strs = tys.iter().map(|ty_param| ty_param.rewrite(&context, h_budget, offset));\n \n         // Extract comments between generics.\n         let lt_spans = lifetimes.iter().map(|l| {\n@@ -988,10 +988,7 @@ impl<'a> FmtVisitor<'a> {\n                                  \"{\",\n                                  |pred| span_for_where_pred(pred).lo,\n                                  |pred| span_for_where_pred(pred).hi,\n-                                 // FIXME: we should handle failure better\n-                                 // this will be taken care of when write_list\n-                                 // takes Rewrite object: see issue #133\n-                                 |pred| pred.rewrite(&context, budget, offset).unwrap(),\n+                                 |pred| pred.rewrite(&context, budget, offset),\n                                  span_start,\n                                  span_end);\n         let item_vec = items.collect::<Vec<_>>();"}, {"sha": "514acd13f538d6633164ae33ea1ff1f7db2e6b5d", "filename": "src/lists.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a76df6b4d9a67e67137cf0773d96f0027da827c7/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a76df6b4d9a67e67137cf0773d96f0027da827c7/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=a76df6b4d9a67e67137cf0773d96f0027da827c7", "patch": "@@ -43,8 +43,6 @@ pub enum SeparatorTactic {\n \n impl_enum_decodable!(SeparatorTactic, Always, Never, Vertical);\n \n-// TODO having some helpful ctors for ListFormatting would be nice.\n-// FIXME: this should have only 1 width param\n pub struct ListFormatting<'a> {\n     pub tactic: DefinitiveListTactic,\n     pub separator: &'a str,\n@@ -111,17 +109,21 @@ impl AsRef<ListItem> for ListItem {\n }\n \n pub struct ListItem {\n+    // None for comments mean that they are not present.\n     pub pre_comment: Option<String>,\n-    // Item should include attributes and doc comments.\n-    pub item: String,\n+    // Item should include attributes and doc comments. None indicates failed\n+    // rewrite.\n+    pub item: Option<String>,\n     pub post_comment: Option<String>,\n     // Whether there is extra whitespace before this item.\n     pub new_lines: bool,\n }\n \n impl ListItem {\n     pub fn is_multiline(&self) -> bool {\n-        self.item.contains('\\n') || self.pre_comment.is_some() ||\n+        // FIXME: fail earlier!\n+        self.item.as_ref().map(|s| s.contains('\\n')).unwrap_or(false) ||\n+        self.pre_comment.is_some() ||\n         self.post_comment.as_ref().map(|s| s.contains('\\n')).unwrap_or(false)\n     }\n \n@@ -132,7 +134,7 @@ impl ListItem {\n     pub fn from_str<S: Into<String>>(s: S) -> ListItem {\n         ListItem {\n             pre_comment: None,\n-            item: s.into(),\n+            item: Some(s.into()),\n             post_comment: None,\n             new_lines: false,\n         }\n@@ -198,6 +200,7 @@ pub fn write_list<'b, I, T>(items: I, formatting: &ListFormatting<'b>) -> Option\n     let indent_str = &formatting.indent.to_string(formatting.config);\n     while let Some((i, item)) = iter.next() {\n         let item = item.as_ref();\n+        let inner_item = try_opt!(item.item.as_ref());\n         let first = i == 0;\n         let last = iter.peek().is_none();\n         let separate = !last || trailing_separator;\n@@ -206,7 +209,7 @@ pub fn write_list<'b, I, T>(items: I, formatting: &ListFormatting<'b>) -> Option\n         } else {\n             0\n         };\n-        let item_width = item.item.len() + item_sep_len;\n+        let item_width = inner_item.len() + item_sep_len;\n \n         match tactic {\n             DefinitiveListTactic::Horizontal if !first => {\n@@ -256,7 +259,8 @@ pub fn write_list<'b, I, T>(items: I, formatting: &ListFormatting<'b>) -> Option\n             }\n         }\n \n-        let item_str = try_opt!(wrap_str(&item.item[..],\n+        // Make sure that string actually fits.\n+        let item_str = try_opt!(wrap_str(&inner_item[..],\n                                          formatting.config.max_width,\n                                          formatting.width,\n                                          formatting.indent));\n@@ -325,7 +329,7 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n     where I: Iterator<Item = T>,\n           F1: Fn(&T) -> BytePos,\n           F2: Fn(&T) -> BytePos,\n-          F3: Fn(&T) -> String\n+          F3: Fn(&T) -> Option<String>\n {\n     type Item = ListItem;\n \n@@ -449,7 +453,7 @@ pub fn itemize_list<'a, T, I, F1, F2, F3>(codemap: &'a CodeMap,\n     where I: Iterator<Item = T>,\n           F1: Fn(&T) -> BytePos,\n           F2: Fn(&T) -> BytePos,\n-          F3: Fn(&T) -> String\n+          F3: Fn(&T) -> Option<String>\n {\n     ListItems {\n         codemap: codemap,\n@@ -484,8 +488,11 @@ fn calculate_width<'li, I, T>(items: I) -> (usize, usize)\n }\n \n fn total_item_width(item: &ListItem) -> usize {\n+    // FIXME: If the item has a `None` item, it may be better to fail earlier\n+    // rather than later.\n     comment_len(item.pre_comment.as_ref().map(|x| &(*x)[..])) +\n-    comment_len(item.post_comment.as_ref().map(|x| &(*x)[..])) + item.item.len()\n+    comment_len(item.post_comment.as_ref().map(|x| &(*x)[..])) +\n+    item.item.as_ref().map(|str| str.len()).unwrap_or(0)\n }\n \n fn comment_len(comment: Option<&str>) -> usize {"}, {"sha": "6f6afbfc42ed43f05edba0b1c1be9781c04f7bb9", "filename": "src/types.rs", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a76df6b4d9a67e67137cf0773d96f0027da827c7/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a76df6b4d9a67e67137cf0773d96f0027da827c7/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=a76df6b4d9a67e67137cf0773d96f0027da827c7", "patch": "@@ -219,14 +219,10 @@ fn rewrite_segment(segment: &ast::PathSegment,\n                                      \">\",\n                                      |param| param.get_span().lo,\n                                      |param| param.get_span().hi,\n-                                     // FIXME(#133): write_list should call\n-                                     // rewrite itself, because it has a better\n-                                     // context.\n                                      |seg| {\n                                          seg.rewrite(context,\n                                                      context.config.max_width,\n                                                      offset + extra_offset)\n-                                            .unwrap()\n                                      },\n                                      list_lo,\n                                      span_hi);\n@@ -259,7 +255,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n                                      \")\",\n                                      |ty| ty.span.lo,\n                                      |ty| ty.span.hi,\n-                                     |ty| ty.rewrite(context, budget, offset).unwrap(),\n+                                     |ty| ty.rewrite(context, budget, offset),\n                                      list_lo,\n                                      span_hi);\n             let list_str = try_opt!(::lists::format_fn_args(items, budget, offset, context.config));\n@@ -284,40 +280,39 @@ impl Rewrite for ast::WherePredicate {\n                 let type_str = try_opt!(bounded_ty.rewrite(context, width, offset));\n \n                 if !bound_lifetimes.is_empty() {\n-                    let lifetime_str = bound_lifetimes.iter()\n-                                                      .map(|lt| {\n-                                                          lt.rewrite(context, width, offset)\n-                                                            .unwrap()\n-                                                      })\n-                                                      .collect::<Vec<_>>()\n-                                                      .join(\", \");\n+                    let lifetime_str = try_opt!(bound_lifetimes.iter()\n+                                                               .map(|lt| {\n+                                                                   lt.rewrite(context,\n+                                                                              width,\n+                                                                              offset)\n+                                                               })\n+                                                               .collect::<Option<Vec<_>>>())\n+                                           .join(\", \");\n                     // 8 = \"for<> : \".len()\n                     let used_width = lifetime_str.len() + type_str.len() + 8;\n                     let budget = try_opt!(width.checked_sub(used_width));\n-                    let bounds_str = bounds.iter()\n-                                           .map(|ty_bound| {\n-                                               ty_bound.rewrite(context,\n-                                                                budget,\n-                                                                offset + used_width)\n-                                                       .unwrap()\n-                                           })\n-                                           .collect::<Vec<_>>()\n-                                           .join(\" + \");\n+                    let bounds_str = try_opt!(bounds.iter()\n+                                                    .map(|ty_bound| {\n+                                                        ty_bound.rewrite(context,\n+                                                                         budget,\n+                                                                         offset + used_width)\n+                                                    })\n+                                                    .collect::<Option<Vec<_>>>())\n+                                         .join(\" + \");\n \n                     format!(\"for<{}> {}: {}\", lifetime_str, type_str, bounds_str)\n                 } else {\n                     // 2 = \": \".len()\n                     let used_width = type_str.len() + 2;\n                     let budget = try_opt!(width.checked_sub(used_width));\n-                    let bounds_str = bounds.iter()\n-                                           .map(|ty_bound| {\n-                                               ty_bound.rewrite(context,\n-                                                                budget,\n-                                                                offset + used_width)\n-                                                       .unwrap()\n-                                           })\n-                                           .collect::<Vec<_>>()\n-                                           .join(\" + \");\n+                    let bounds_str = try_opt!(bounds.iter()\n+                                                    .map(|ty_bound| {\n+                                                        ty_bound.rewrite(context,\n+                                                                         budget,\n+                                                                         offset + used_width)\n+                                                    })\n+                                                    .collect::<Option<Vec<_>>>())\n+                                         .join(\" + \");\n \n                     format!(\"{}: {}\", type_str, bounds_str)\n                 }\n@@ -380,9 +375,9 @@ impl Rewrite for ast::TyParamBound {\n \n impl Rewrite for ast::TyParamBounds {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        let strs: Vec<_> = self.iter()\n-                               .map(|b| b.rewrite(context, width, offset).unwrap())\n-                               .collect();\n+        let strs: Vec<_> = try_opt!(self.iter()\n+                                        .map(|b| b.rewrite(context, width, offset))\n+                                        .collect());\n         Some(strs.join(\" + \"))\n     }\n }\n@@ -395,10 +390,10 @@ impl Rewrite for ast::TyParam {\n         if !self.bounds.is_empty() {\n             result.push_str(\": \");\n \n-            let bounds = self.bounds\n-                             .iter()\n-                             .map(|ty_bound| ty_bound.rewrite(context, width, offset).unwrap())\n-                             .collect::<Vec<_>>()\n+            let bounds = try_opt!(self.bounds\n+                                      .iter()\n+                                      .map(|ty_bound| ty_bound.rewrite(context, width, offset))\n+                                      .collect::<Option<Vec<_>>>())\n                              .join(\" + \");\n \n             result.push_str(&bounds);\n@@ -418,10 +413,10 @@ impl Rewrite for ast::TyParam {\n impl Rewrite for ast::PolyTraitRef {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         if !self.bound_lifetimes.is_empty() {\n-            let lifetime_str = self.bound_lifetimes\n-                                   .iter()\n-                                   .map(|lt| lt.rewrite(context, width, offset).unwrap())\n-                                   .collect::<Vec<_>>()\n+            let lifetime_str = try_opt!(self.bound_lifetimes\n+                                            .iter()\n+                                            .map(|lt| lt.rewrite(context, width, offset))\n+                                            .collect::<Option<Vec<_>>>())\n                                    .join(\", \");\n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;"}]}