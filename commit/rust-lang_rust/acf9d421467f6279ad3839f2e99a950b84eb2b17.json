{"sha": "acf9d421467f6279ad3839f2e99a950b84eb2b17", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjZjlkNDIxNDY3ZjYyNzlhZDM4MzlmMmU5OWE5NTBiODRlYjJiMTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-06T01:31:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-06T01:31:33Z"}, "message": "auto merge of #13940 : edwardw/rust/refutable-match, r=pcwalton\n\nBy carefully distinguishing falling back to the default arm from moving\r\non to the next pattern, this patch adjusts the codegen logic for range\r\nand guarded arms of pattern matching expression. It is a more\r\nappropriate way of fixing #12582 and #13027 without causing regressions\r\nsuch as #13867.\r\n    \r\nCloses #13867", "tree": {"sha": "b42710c3bef02f49a4bd741220345942c65c3b52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b42710c3bef02f49a4bd741220345942c65c3b52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acf9d421467f6279ad3839f2e99a950b84eb2b17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acf9d421467f6279ad3839f2e99a950b84eb2b17", "html_url": "https://github.com/rust-lang/rust/commit/acf9d421467f6279ad3839f2e99a950b84eb2b17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acf9d421467f6279ad3839f2e99a950b84eb2b17/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd3fb81e5e7cd19fe3a2812efffc750007d43852", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd3fb81e5e7cd19fe3a2812efffc750007d43852", "html_url": "https://github.com/rust-lang/rust/commit/bd3fb81e5e7cd19fe3a2812efffc750007d43852"}, {"sha": "90449abcb30ed8b0fd1bab84f45630769f668247", "url": "https://api.github.com/repos/rust-lang/rust/commits/90449abcb30ed8b0fd1bab84f45630769f668247", "html_url": "https://github.com/rust-lang/rust/commit/90449abcb30ed8b0fd1bab84f45630769f668247"}], "stats": {"total": 267, "additions": 162, "deletions": 105}, "files": [{"sha": "7206f3f03f5e6e3c6303d41e767818efe96d72b8", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 89, "deletions": 105, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/acf9d421467f6279ad3839f2e99a950b84eb2b17/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf9d421467f6279ad3839f2e99a950b84eb2b17/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=acf9d421467f6279ad3839f2e99a950b84eb2b17", "patch": "@@ -289,42 +289,6 @@ fn opt_eq(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     }\n }\n \n-fn opt_overlap(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n-    match (a, b) {\n-        (&lit(a), &lit(b)) => {\n-            let a_expr = lit_to_expr(tcx, &a);\n-            let b_expr = lit_to_expr(tcx, &b);\n-            match const_eval::compare_lit_exprs(tcx, a_expr, b_expr) {\n-                Some(val1) => val1 == 0,\n-                None => fail!(\"opt_overlap: type mismatch\"),\n-            }\n-        }\n-\n-        (&range(a1, a2), &range(b1, b2)) => {\n-            let m1 = const_eval::compare_lit_exprs(tcx, a1, b2);\n-            let m2 = const_eval::compare_lit_exprs(tcx, b1, a2);\n-            match (m1, m2) {\n-                // two ranges [a1, a2] and [b1, b2] overlap iff:\n-                //      a1 <= b2 && b1 <= a2\n-                (Some(val1), Some(val2)) => (val1 <= 0 && val2 <= 0),\n-                _ => fail!(\"opt_overlap: type mismatch\"),\n-            }\n-        }\n-\n-        (&range(a1, a2), &lit(b)) | (&lit(b), &range(a1, a2)) => {\n-            let b_expr = lit_to_expr(tcx, &b);\n-            let m1 = const_eval::compare_lit_exprs(tcx, a1, b_expr);\n-            let m2 = const_eval::compare_lit_exprs(tcx, a2, b_expr);\n-            match (m1, m2) {\n-                // b is in range [a1, a2] iff a1 <= b and b <= a2\n-                (Some(val1), Some(val2)) => (val1 <= 0 && 0 <= val2),\n-                _ => fail!(\"opt_overlap: type mismatch\"),\n-            }\n-        }\n-        _ => fail!(\"opt_overlap: expect lit or range\")\n-    }\n-}\n-\n pub enum opt_result<'a> {\n     single_result(Result<'a>),\n     lower_bound(Result<'a>),\n@@ -562,7 +526,7 @@ fn enter_default<'a, 'b>(\n     // Collect all of the matches that can match against anything.\n     let matches = enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n-          ast::PatWild | ast::PatWildMulti | ast::PatTup(_) => Some(Vec::new()),\n+          ast::PatWild | ast::PatWildMulti => Some(Vec::new()),\n           ast::PatIdent(_, _, None) if pat_is_binding(dm, p) => Some(Vec::new()),\n           _ => None\n         }\n@@ -634,30 +598,16 @@ fn enter_opt<'a, 'b>(\n     let tcx = bcx.tcx();\n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     let mut i = 0;\n-    // By the virtue of fact that we are in `trans` already, `enter_opt` is able\n-    // to prune sub-match tree aggressively based on exact equality. But when it\n-    // comes to literal or range, that strategy may lead to wrong result if there\n-    // are guard function or multiple patterns inside tuple; in that case, pruning\n-    // based on the overlap of patterns is required.\n-    //\n-    // Ideally, when constructing the sub-match tree for certain arm, only those\n-    // arms beneath it matter. But that isn't how algorithm works right now and\n-    // all other arms are taken into consideration when computing `guarded` below.\n-    // That is ok since each round of `compile_submatch` guarantees to trim one\n-    // \"column\" of arm patterns and the algorithm will converge.\n-    let guarded = m.iter().any(|x| x.data.arm.guard.is_some());\n-    let multi_pats = m.len() > 0 && m[0].pats.len() > 1;\n     enter_match(bcx, &tcx.def_map, m, col, val, |p| {\n         let answer = match p.node {\n             ast::PatEnum(..) |\n             ast::PatIdent(_, _, None) if pat_is_const(&tcx.def_map, p) => {\n                 let const_def = tcx.def_map.borrow().get_copy(&p.id);\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n-                let konst = lit(ConstLit(const_def_id));\n-                match guarded || multi_pats {\n-                    false if opt_eq(tcx, &konst, opt) => Some(Vec::new()),\n-                    true if opt_overlap(tcx, &konst, opt) => Some(Vec::new()),\n-                    _ => None,\n+                if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n+                    Some(Vec::new())\n+                } else {\n+                    None\n                 }\n             }\n             ast::PatEnum(_, ref subpats) => {\n@@ -682,20 +632,12 @@ fn enter_opt<'a, 'b>(\n                 }\n             }\n             ast::PatLit(l) => {\n-                let lit_expr = lit(ExprLit(l));\n-                match guarded || multi_pats {\n-                    false if opt_eq(tcx, &lit_expr, opt) => Some(Vec::new()),\n-                    true if opt_overlap(tcx, &lit_expr, opt) => Some(Vec::new()),\n-                    _ => None,\n-                }\n+                if opt_eq(tcx, &lit(ExprLit(l)), opt) { Some(Vec::new()) }\n+                else { None }\n             }\n             ast::PatRange(l1, l2) => {\n-                let rng = range(l1, l2);\n-                match guarded || multi_pats {\n-                    false if opt_eq(tcx, &rng, opt) => Some(Vec::new()),\n-                    true if opt_overlap(tcx, &rng, opt) => Some(Vec::new()),\n-                    _ => None,\n-                }\n+                if opt_eq(tcx, &range(l1, l2), opt) { Some(Vec::new()) }\n+                else { None }\n             }\n             ast::PatStruct(_, ref field_pats, _) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n@@ -770,18 +712,7 @@ fn enter_opt<'a, 'b>(\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n-                // In most cases, a binding/wildcard match be\n-                // considered to match against any Opt. However, when\n-                // doing vector pattern matching, submatches are\n-                // considered even if the eventual match might be from\n-                // a different submatch. Thus, when a submatch fails\n-                // when doing a vector match, we proceed to the next\n-                // submatch. Thus, including a default match would\n-                // cause the default match to fire spuriously.\n-                match *opt {\n-                    vec_len(..) => None,\n-                    _ => Some(Vec::from_elem(variant_size, dummy))\n-                }\n+                Some(Vec::from_elem(variant_size, dummy))\n             }\n         };\n         i += 1;\n@@ -1421,7 +1352,8 @@ fn compile_guard<'a, 'b>(\n                  data: &ArmData,\n                  m: &'a [Match<'a, 'b>],\n                  vals: &[ValueRef],\n-                 chk: &FailureHandler)\n+                 chk: &FailureHandler,\n+                 has_genuine_default: bool)\n                  -> &'b Block<'b> {\n     debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n            bcx.to_str(),\n@@ -1452,7 +1384,17 @@ fn compile_guard<'a, 'b>(\n         // Guard does not match: free the values we copied,\n         // and remove all bindings from the lllocals table\n         let bcx = drop_bindings(bcx, data);\n-        compile_submatch(bcx, m, vals, chk);\n+        match chk {\n+            // If the default arm is the only one left, move on to the next\n+            // condition explicitly rather than (possibly) falling back to\n+            // the default arm.\n+            &JumpToBasicBlock(_) if m.len() == 1 && has_genuine_default => {\n+                Br(bcx, chk.handle_fail());\n+            }\n+            _ => {\n+                compile_submatch(bcx, m, vals, chk, has_genuine_default);\n+            }\n+        };\n         bcx\n     });\n \n@@ -1476,7 +1418,8 @@ fn compile_submatch<'a, 'b>(\n                     bcx: &'b Block<'b>,\n                     m: &'a [Match<'a, 'b>],\n                     vals: &[ValueRef],\n-                    chk: &FailureHandler) {\n+                    chk: &FailureHandler,\n+                    has_genuine_default: bool) {\n     debug!(\"compile_submatch(bcx={}, m={}, vals={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -1506,7 +1449,8 @@ fn compile_submatch<'a, 'b>(\n                                     m[0].data,\n                                     m.slice(1, m.len()),\n                                     vals,\n-                                    chk);\n+                                    chk,\n+                                    has_genuine_default);\n             }\n             _ => ()\n         }\n@@ -1524,9 +1468,10 @@ fn compile_submatch<'a, 'b>(\n                                   vals,\n                                   chk,\n                                   col,\n-                                  val)\n+                                  val,\n+                                  has_genuine_default)\n     } else {\n-        compile_submatch_continue(bcx, m, vals, chk, col, val)\n+        compile_submatch_continue(bcx, m, vals, chk, col, val, has_genuine_default)\n     }\n }\n \n@@ -1536,7 +1481,8 @@ fn compile_submatch_continue<'a, 'b>(\n                              vals: &[ValueRef],\n                              chk: &FailureHandler,\n                              col: uint,\n-                             val: ValueRef) {\n+                             val: ValueRef,\n+                             has_genuine_default: bool) {\n     let fcx = bcx.fcx;\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n@@ -1570,7 +1516,7 @@ fn compile_submatch_continue<'a, 'b>(\n                                             rec_fields.as_slice(),\n                                             val).as_slice(),\n                         rec_vals.append(vals_left.as_slice()).as_slice(),\n-                        chk);\n+                        chk, has_genuine_default);\n             });\n             return;\n         }\n@@ -1595,7 +1541,7 @@ fn compile_submatch_continue<'a, 'b>(\n                                    val,\n                                    n_tup_elts).as_slice(),\n                          tup_vals.append(vals_left.as_slice()).as_slice(),\n-                         chk);\n+                         chk, has_genuine_default);\n         return;\n     }\n \n@@ -1620,7 +1566,7 @@ fn compile_submatch_continue<'a, 'b>(\n                          enter_tuple_struct(bcx, dm, m, col, val,\n                                             struct_element_count).as_slice(),\n                          llstructvals.append(vals_left.as_slice()).as_slice(),\n-                         chk);\n+                         chk, has_genuine_default);\n         return;\n     }\n \n@@ -1629,7 +1575,7 @@ fn compile_submatch_continue<'a, 'b>(\n         compile_submatch(bcx,\n                          enter_uniq(bcx, dm, m, col, val).as_slice(),\n                          (vec!(llbox)).append(vals_left.as_slice()).as_slice(),\n-                         chk);\n+                         chk, has_genuine_default);\n         return;\n     }\n \n@@ -1638,7 +1584,7 @@ fn compile_submatch_continue<'a, 'b>(\n         compile_submatch(bcx,\n                          enter_region(bcx, dm, m, col, val).as_slice(),\n                          (vec!(loaded_val)).append(vals_left.as_slice()).as_slice(),\n-                         chk);\n+                         chk, has_genuine_default);\n         return;\n     }\n \n@@ -1695,9 +1641,9 @@ fn compile_submatch_continue<'a, 'b>(\n \n     // Compile subtrees for each option\n     for (i, opt) in opts.iter().enumerate() {\n-        // In some cases in vector pattern matching, we need to override\n-        // the failure case so that instead of failing, it proceeds to\n-        // try more matching. branch_chk, then, is the proper failure case\n+        // In some cases of range and vector pattern matching, we need to\n+        // override the failure case so that instead of failing, it proceeds\n+        // to try more matching. branch_chk, then, is the proper failure case\n         // for the current conditional branch.\n         let mut branch_chk = None;\n         let mut opt_cx = else_cx;\n@@ -1747,6 +1693,16 @@ fn compile_submatch_continue<'a, 'b>(\n                       }\n                   };\n                   bcx = fcx.new_temp_block(\"compare_next\");\n+\n+                  // If none of the sub-cases match, and the current condition\n+                  // is guarded or has multiple patterns, move on to the next\n+                  // condition, if there is any, rather than falling back to\n+                  // the default.\n+                  let guarded = m[i].data.arm.guard.is_some();\n+                  let multi_pats = m[i].pats.len() > 1;\n+                  if i+1 < len && (guarded || multi_pats) {\n+                      branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n+                  }\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n               compare_vec_len => {\n@@ -1784,8 +1740,10 @@ fn compile_submatch_continue<'a, 'b>(\n                   bcx = fcx.new_temp_block(\"compare_vec_len_next\");\n \n                   // If none of these subcases match, move on to the\n-                  // next condition.\n-                  branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n+                  // next condition if there is any.\n+                  if i+1 < len {\n+                      branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n+                  }\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n               _ => ()\n@@ -1825,27 +1783,38 @@ fn compile_submatch_continue<'a, 'b>(\n                 compile_submatch(opt_cx,\n                                  opt_ms.as_slice(),\n                                  opt_vals.as_slice(),\n-                                 chk)\n+                                 chk,\n+                                 has_genuine_default)\n             }\n             Some(branch_chk) => {\n                 compile_submatch(opt_cx,\n                                  opt_ms.as_slice(),\n                                  opt_vals.as_slice(),\n-                                 &branch_chk)\n+                                 &branch_chk,\n+                                 has_genuine_default)\n             }\n         }\n     }\n \n     // Compile the fall-through case, if any\n-    if !exhaustive {\n+    if !exhaustive && kind != single {\n         if kind == compare || kind == compare_vec_len {\n             Br(bcx, else_cx.llbb);\n         }\n-        if kind != single {\n-            compile_submatch(else_cx,\n-                             defaults.as_slice(),\n-                             vals_left.as_slice(),\n-                             chk);\n+        match chk {\n+            // If there is only one default arm left, move on to the next\n+            // condition explicitly rather than (eventually) falling back to\n+            // the last default arm.\n+            &JumpToBasicBlock(_) if defaults.len() == 1 && has_genuine_default => {\n+                Br(else_cx, chk.handle_fail());\n+            }\n+            _ => {\n+                compile_submatch(else_cx,\n+                                 defaults.as_slice(),\n+                                 vals_left.as_slice(),\n+                                 chk,\n+                                 has_genuine_default);\n+            }\n         }\n     }\n }\n@@ -1950,7 +1919,22 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         }));\n     }\n \n-    compile_submatch(bcx, matches.as_slice(), [discr_datum.val], &chk);\n+    // `compile_submatch` works one column of arm patterns a time and\n+    // then peels that column off. So as we progress, it may become\n+    // impossible to know whether we have a genuine default arm, i.e.\n+    // `_ => foo` or not. Sometimes it is important to know that in order\n+    // to decide whether moving on to the next condition or falling back\n+    // to the default arm.\n+    let has_default = arms.len() > 0 && {\n+        let ref pats = arms.last().unwrap().pats;\n+\n+        pats.len() == 1\n+        && match pats.last().unwrap().node {\n+            ast::PatWild => true, _ => false\n+        }\n+    };\n+\n+    compile_submatch(bcx, matches.as_slice(), [discr_datum.val], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in arm_datas.iter() {"}, {"sha": "fc3b1c7cb1ab24d620c683c8c42cbc8cd53aad16", "filename": "src/test/run-pass/issue-13027.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/acf9d421467f6279ad3839f2e99a950b84eb2b17/src%2Ftest%2Frun-pass%2Fissue-13027.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf9d421467f6279ad3839f2e99a950b84eb2b17/src%2Ftest%2Frun-pass%2Fissue-13027.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13027.rs?ref=acf9d421467f6279ad3839f2e99a950b84eb2b17", "patch": "@@ -23,6 +23,7 @@ pub fn main() {\n     multi_pats_shadow_range();\n     lit_shadow_multi_pats();\n     range_shadow_multi_pats();\n+    misc();\n }\n \n fn lit_shadow_range() {\n@@ -168,3 +169,18 @@ fn range_shadow_multi_pats() {\n         _ => 3,\n     });\n }\n+\n+fn misc() {\n+    enum Foo {\n+        Bar(uint, bool)\n+    }\n+    // This test basically mimics how trace_macros! macro is implemented,\n+    // which is a rare combination of vector patterns, multiple wild-card\n+    // patterns and guard functions.\n+    let r = match [Bar(0, false)].as_slice() {\n+        [Bar(_, pred)] if pred => 1,\n+        [Bar(_, pred)] if !pred => 2,\n+        _ => 0,\n+    };\n+    assert_eq!(2, r);\n+}"}, {"sha": "fb76dbf2f6905af0dfd5aa111b63ef6ccb6236a1", "filename": "src/test/run-pass/issue-13867.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/acf9d421467f6279ad3839f2e99a950b84eb2b17/src%2Ftest%2Frun-pass%2Fissue-13867.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf9d421467f6279ad3839f2e99a950b84eb2b17/src%2Ftest%2Frun-pass%2Fissue-13867.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13867.rs?ref=acf9d421467f6279ad3839f2e99a950b84eb2b17", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that codegen works correctly when there are multiple refutable\n+// patterns in match expression.\n+\n+enum Foo {\n+    FooUint(uint),\n+    FooNullary,\n+}\n+\n+fn main() {\n+    let r = match (FooNullary, 'a') {\n+        (FooUint(..), 'a'..'z') => 1,\n+        (FooNullary, 'x') => 2,\n+        _ => 0\n+    };\n+    assert_eq!(r, 0);\n+\n+    let r = match (FooUint(0), 'a') {\n+        (FooUint(1), 'a'..'z') => 1,\n+        (FooUint(..), 'x') => 2,\n+        (FooNullary, 'a') => 3,\n+        _ => 0\n+    };\n+    assert_eq!(r, 0);\n+\n+    let r = match ('a', FooUint(0)) {\n+        ('a'..'z', FooUint(1)) => 1,\n+        ('x', FooUint(..)) => 2,\n+        ('a', FooNullary) => 3,\n+        _ => 0\n+    };\n+    assert_eq!(r, 0);\n+\n+    let r = match ('a', 'a') {\n+        ('a'..'z', 'b') => 1,\n+        ('x', 'a'..'z') => 2,\n+        _ => 0\n+    };\n+    assert_eq!(r, 0);\n+\n+    let r = match ('a', 'a') {\n+        ('a'..'z', 'b') => 1,\n+        ('x', 'a'..'z') => 2,\n+        ('a', 'a') => 3,\n+        _ => 0\n+    };\n+    assert_eq!(r, 3);\n+}"}]}