{"sha": "8f552181895921a377ab8c235340ea3d80ec7fc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNTUyMTgxODk1OTIxYTM3N2FiOGMyMzUzNDBlYTNkODBlYzdmYzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-26T21:54:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-26T21:54:37Z"}, "message": "Auto merge of #31414 - durka:clone-copy, r=alexcrichton\n\nspecial-case #[derive(Copy, Clone)] with a shallow clone\n\nIf a type is Copy then its Clone implementation can be a no-op. Currently `#[derive(Clone)]` generates a deep clone anyway. This can lead to lots of code bloat.\n\nThis PR detects the case where Copy and Clone are both being derived (the general case of \"is this type Copy\" can't be determined by a syntax extension) and generates the shallow Clone impl. Right now this can only be done if there are no type parameters (see https://github.com/rust-lang/rust/issues/31085#issuecomment-178988663), but this restriction can be removed after specialization.\n\nFixes #31085.", "tree": {"sha": "92395c4d4b72986babdc2b9e53646229c39cccc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92395c4d4b72986babdc2b9e53646229c39cccc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f552181895921a377ab8c235340ea3d80ec7fc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f552181895921a377ab8c235340ea3d80ec7fc0", "html_url": "https://github.com/rust-lang/rust/commit/8f552181895921a377ab8c235340ea3d80ec7fc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f552181895921a377ab8c235340ea3d80ec7fc0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "897199a0fbe01ab6f7e7f8096656603e238e85a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/897199a0fbe01ab6f7e7f8096656603e238e85a2", "html_url": "https://github.com/rust-lang/rust/commit/897199a0fbe01ab6f7e7f8096656603e238e85a2"}, {"sha": "9249e6a1e2ef57bb6e329e6477beed31647236b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9249e6a1e2ef57bb6e329e6477beed31647236b1", "html_url": "https://github.com/rust-lang/rust/commit/9249e6a1e2ef57bb6e329e6477beed31647236b1"}], "stats": {"total": 243, "additions": 203, "deletions": 40}, "files": [{"sha": "ad2a205a82376c7471460168d33043327bc0bda4", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=8f552181895921a377ab8c235340ea3d80ec7fc0", "patch": "@@ -75,6 +75,17 @@ pub trait Clone : Sized {\n     }\n }\n \n+// FIXME(aburka): this method is used solely by #[derive] to\n+// assert that every component of a type implements Clone.\n+//\n+// This should never be called by user code.\n+#[doc(hidden)]\n+#[inline(always)]\n+#[unstable(feature = \"derive_clone_copy\",\n+           reason = \"deriving hack, should not be public\",\n+           issue = \"0\")]\n+pub fn assert_receiver_is_clone<T: Clone + ?Sized>(_: &T) {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Clone for &'a T {\n     /// Returns a shallow copy of the reference."}, {"sha": "c81198d4729fb55e5949793b5be7c9f9039a66cb", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 92, "deletions": 30, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=8f552181895921a377ab8c235340ea3d80ec7fc0", "patch": "@@ -11,26 +11,68 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr, VariantData};\n+use syntax::ast::{Expr, ItemKind, Generics, MetaItem, VariantData};\n+use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n \n+#[derive(PartialEq)]\n+enum Mode { Deep, Shallow }\n+\n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              span: Span,\n                              mitem: &MetaItem,\n                              item: &Annotatable,\n                              push: &mut FnMut(Annotatable))\n {\n+    // check if we can use a short form\n+    //\n+    // the short form is `fn clone(&self) -> Self { *self }`\n+    //\n+    // we can use the short form if:\n+    // - the item is Copy (unfortunately, all we can check is whether it's also deriving Copy)\n+    // - there are no generic parameters (after specialization this limitation can be removed)\n+    //      if we used the short form with generics, we'd have to bound the generics with\n+    //      Clone + Copy, and then there'd be no Clone impl at all if the user fills in something\n+    //      that is Clone but not Copy. and until specialization we can't write both impls.\n+    let bounds;\n+    let substructure;\n+    match *item {\n+        Annotatable::Item(ref annitem) => {\n+            match annitem.node {\n+                ItemKind::Struct(_, Generics { ref ty_params, .. }) |\n+                ItemKind::Enum(_, Generics { ref ty_params, .. })\n+                    if ty_params.is_empty()\n+                        && attr::contains_name(&annitem.attrs, \"derive_Copy\") => {\n+\n+                    bounds = vec![Literal(path_std!(cx, core::marker::Copy))];\n+                    substructure = combine_substructure(Box::new(|c, s, sub| {\n+                        cs_clone(\"Clone\", c, s, sub, Mode::Shallow)\n+                    }));\n+                }\n+\n+                _ => {\n+                    bounds = vec![];\n+                    substructure = combine_substructure(Box::new(|c, s, sub| {\n+                        cs_clone(\"Clone\", c, s, sub, Mode::Deep)\n+                    }));\n+                }\n+            }\n+        }\n+\n+        _ => cx.span_bug(span, \"#[derive(Clone)] on trait item or impl item\")\n+    }\n+\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n         path: path_std!(cx, core::clone::Clone),\n-        additional_bounds: Vec::new(),\n+        additional_bounds: bounds,\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n         methods: vec!(\n@@ -42,9 +84,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                 ret_ty: Self_,\n                 attributes: attrs,\n                 is_unsafe: false,\n-                combine_substructure: combine_substructure(Box::new(|c, s, sub| {\n-                    cs_clone(\"Clone\", c, s, sub)\n-                })),\n+                combine_substructure: substructure,\n             }\n         ),\n         associated_types: Vec::new(),\n@@ -56,14 +96,24 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n fn cs_clone(\n     name: &str,\n     cx: &mut ExtCtxt, trait_span: Span,\n-    substr: &Substructure) -> P<Expr> {\n+    substr: &Substructure,\n+    mode: Mode) -> P<Expr> {\n     let ctor_path;\n     let all_fields;\n-    let fn_path = cx.std_path(&[\"clone\", \"Clone\", \"clone\"]);\n+    let fn_path = match mode {\n+        Mode::Shallow => cx.std_path(&[\"clone\", \"assert_receiver_is_clone\"]),\n+        Mode::Deep  => cx.std_path(&[\"clone\", \"Clone\", \"clone\"]),\n+    };\n     let subcall = |field: &FieldInfo| {\n         let args = vec![cx.expr_addr_of(field.span, field.self_.clone())];\n \n-        cx.expr_call_global(field.span, fn_path.clone(), args)\n+        let span = if mode == Mode::Shallow {\n+            // set the expn ID so we can call the unstable method\n+            Span { expn_id: cx.backtrace(), .. trait_span }\n+        } else {\n+            field.span\n+        };\n+        cx.expr_call_global(span, fn_path.clone(), args)\n     };\n \n     let vdata;\n@@ -89,29 +139,41 @@ fn cs_clone(\n         }\n     }\n \n-    match *vdata {\n-        VariantData::Struct(..) => {\n-            let fields = all_fields.iter().map(|field| {\n-                let ident = match field.name {\n-                    Some(i) => i,\n-                    None => {\n-                        cx.span_bug(trait_span,\n-                                    &format!(\"unnamed field in normal struct in \\\n-                                             `derive({})`\", name))\n-                    }\n-                };\n-                cx.field_imm(field.span, ident, subcall(field))\n-            }).collect::<Vec<_>>();\n-\n-            cx.expr_struct(trait_span, ctor_path, fields)\n+    match mode {\n+        Mode::Shallow => {\n+            cx.expr_block(cx.block(trait_span,\n+                                   all_fields.iter()\n+                                             .map(subcall)\n+                                             .map(|e| cx.stmt_expr(e))\n+                                             .collect(),\n+                                   Some(cx.expr_deref(trait_span, cx.expr_self(trait_span)))))\n         }\n-        VariantData::Tuple(..) => {\n-            let subcalls = all_fields.iter().map(subcall).collect();\n-            let path = cx.expr_path(ctor_path);\n-            cx.expr_call(trait_span, path, subcalls)\n-        }\n-        VariantData::Unit(..) => {\n-            cx.expr_path(ctor_path)\n+        Mode::Deep => {\n+            match *vdata {\n+                VariantData::Struct(..) => {\n+                    let fields = all_fields.iter().map(|field| {\n+                        let ident = match field.name {\n+                            Some(i) => i,\n+                            None => {\n+                                cx.span_bug(trait_span,\n+                                            &format!(\"unnamed field in normal struct in \\\n+                                                     `derive({})`\", name))\n+                            }\n+                        };\n+                        cx.field_imm(field.span, ident, subcall(field))\n+                    }).collect::<Vec<_>>();\n+\n+                    cx.expr_struct(trait_span, ctor_path, fields)\n+                }\n+                VariantData::Tuple(..) => {\n+                    let subcalls = all_fields.iter().map(subcall).collect();\n+                    let path = cx.expr_path(ctor_path);\n+                    cx.expr_call(trait_span, path, subcalls)\n+                }\n+                VariantData::Unit(..) => {\n+                    cx.expr_path(ctor_path)\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "9387cf05ac7d142c8d0eebc3319a20c0bba94a91", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=8f552181895921a377ab8c235340ea3d80ec7fc0", "patch": "@@ -74,7 +74,7 @@ fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n                 },\n                 explicit_self: None,\n                 args: vec!(Ptr(Box::new(Literal(Path::new_local(typaram))),\n-                            Borrowed(None, Mutability::Mutable))),\n+                           Borrowed(None, Mutability::Mutable))),\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, core::result::Result),\n                     None,"}, {"sha": "5b47d8da8b6421a551ecd6e66ec033bd7087a012", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=8f552181895921a377ab8c235340ea3d80ec7fc0", "patch": "@@ -150,7 +150,7 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n                 },\n                 explicit_self: borrowed_explicit_self(),\n                 args: vec!(Ptr(Box::new(Literal(Path::new_local(typaram))),\n-                            Borrowed(None, Mutability::Mutable))),\n+                           Borrowed(None, Mutability::Mutable))),\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, core::result::Result),\n                     None,"}, {"sha": "1d5fc13c72008c1c25c510655374b9cfb33d4056", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=8f552181895921a377ab8c235340ea3d80ec7fc0", "patch": "@@ -857,6 +857,7 @@ impl<'a> MethodDef<'a> {\n                      explicit_self: ast::ExplicitSelf,\n                      arg_types: Vec<(Ident, P<ast::Ty>)> ,\n                      body: P<Expr>) -> ast::ImplItem {\n+\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n@@ -990,6 +991,7 @@ impl<'a> MethodDef<'a> {\n             body = cx.expr_match(trait_.span, arg_expr.clone(),\n                                      vec!( cx.arm(trait_.span, vec!(pat.clone()), body) ))\n         }\n+\n         body\n     }\n "}, {"sha": "92fb7c5737a929a245a79f7eb32a8230147660aa", "filename": "src/test/compile-fail/deriving-copyclone.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Ftest%2Fcompile-fail%2Fderiving-copyclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Ftest%2Fcompile-fail%2Fderiving-copyclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-copyclone.rs?ref=8f552181895921a377ab8c235340ea3d80ec7fc0", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// this will get a no-op Clone impl\n+#[derive(Copy, Clone)]\n+struct A {\n+    a: i32,\n+    b: i64\n+}\n+\n+// this will get a deep Clone impl\n+#[derive(Copy, Clone)]\n+struct B<T> {\n+    a: i32,\n+    b: T\n+}\n+\n+struct C; // not Copy or Clone\n+#[derive(Clone)] struct D; // Clone but not Copy\n+\n+fn is_copy<T: Copy>(_: T) {}\n+fn is_clone<T: Clone>(_: T) {}\n+\n+fn main() {\n+    // A can be copied and cloned\n+    is_copy(A { a: 1, b: 2 });\n+    is_clone(A { a: 1, b: 2 });\n+\n+    // B<i32> can be copied and cloned\n+    is_copy(B { a: 1, b: 2 });\n+    is_clone(B { a: 1, b: 2 });\n+\n+    // B<C> cannot be copied or cloned\n+    is_copy(B { a: 1, b: C }); //~ERROR Copy\n+    is_clone(B { a: 1, b: C }); //~ERROR Clone\n+\n+    // B<D> can be cloned but not copied\n+    is_copy(B { a: 1, b: D }); //~ERROR Copy\n+    is_clone(B { a: 1, b: D });\n+}\n+"}, {"sha": "54147c73ff0ff014d02576be5600f261fe8423d4", "filename": "src/test/run-pass/copy-out-of-array-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Ftest%2Frun-pass%2Fcopy-out-of-array-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Ftest%2Frun-pass%2Fcopy-out-of-array-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcopy-out-of-array-1.rs?ref=8f552181895921a377ab8c235340ea3d80ec7fc0", "patch": "@@ -12,8 +12,6 @@\n //\n // (Compare with compile-fail/move-out-of-array-1.rs)\n \n-// pretty-expanded FIXME #23616\n-\n #[derive(Copy, Clone)]\n struct C { _x: u8 }\n "}, {"sha": "96d0406d9eb280a9be7ad88b20f59851d187c68a", "filename": "src/test/run-pass/deriving-copyclone.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Ftest%2Frun-pass%2Fderiving-copyclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Ftest%2Frun-pass%2Fderiving-copyclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-copyclone.rs?ref=8f552181895921a377ab8c235340ea3d80ec7fc0", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Test that #[derive(Copy, Clone)] produces a shallow copy\n+//! even when a member violates RFC 1521\n+\n+use std::sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n+\n+/// A struct that pretends to be Copy, but actually does something\n+/// in its Clone impl\n+#[derive(Copy)]\n+struct Liar;\n+\n+/// Static cooperating with the rogue Clone impl\n+static CLONED: AtomicBool = ATOMIC_BOOL_INIT;\n+\n+impl Clone for Liar {\n+    fn clone(&self) -> Self {\n+        // this makes Clone vs Copy observable\n+        CLONED.store(true, Ordering::SeqCst);\n+\n+        *self\n+    }\n+}\n+\n+/// This struct is actually Copy... at least, it thinks it is!\n+#[derive(Copy, Clone)]\n+struct Innocent(Liar);\n+\n+impl Innocent {\n+    fn new() -> Self {\n+        Innocent(Liar)\n+    }\n+}\n+\n+fn main() {\n+    let _ = Innocent::new().clone();\n+    // if Innocent was byte-for-byte copied, CLONED will still be false\n+    assert!(!CLONED.load(Ordering::SeqCst));\n+}\n+"}, {"sha": "f0214d3f37b6f2f152924848e881e199989f9a19", "filename": "src/test/run-pass/hrtb-opt-in-copy.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Ftest%2Frun-pass%2Fhrtb-opt-in-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Ftest%2Frun-pass%2Fhrtb-opt-in-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-opt-in-copy.rs?ref=8f552181895921a377ab8c235340ea3d80ec7fc0", "patch": "@@ -16,8 +16,6 @@\n // did not consider that a match (something I would like to revise in\n // a later PR).\n \n-// pretty-expanded FIXME #23616\n-\n #![allow(dead_code)]\n \n use std::marker::PhantomData;"}, {"sha": "383c1aef23459e2e4716871a1709593ba132968a", "filename": "src/test/run-pass/issue-13264.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Ftest%2Frun-pass%2Fissue-13264.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Ftest%2Frun-pass%2Fissue-13264.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13264.rs?ref=8f552181895921a377ab8c235340ea3d80ec7fc0", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n use std::ops::Deref;\n \n struct Root {"}, {"sha": "6e9ee7fb15c34620e6445dfe9f3463f89e6551fa", "filename": "src/test/run-pass/issue-3121.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Ftest%2Frun-pass%2Fissue-3121.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f552181895921a377ab8c235340ea3d80ec7fc0/src%2Ftest%2Frun-pass%2Fissue-3121.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3121.rs?ref=8f552181895921a377ab8c235340ea3d80ec7fc0", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n "}]}