{"sha": "d538b80ad77949e46989cd355cdec193b574f052", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MzhiODBhZDc3OTQ5ZTQ2OTg5Y2QzNTVjZGVjMTkzYjU3NGYwNTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-13T12:53:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-13T12:53:43Z"}, "message": "Auto merge of #68969 - RalfJung:dont-panic, r=oli-obk\n\nremove Panic variant from InterpError\n\nThe interpreter engine itself does not raise `Panic` errors any more, so remove them from the error enum. Instead, const-prop and const-eval have to do their own handling of panics.\n\nI used the opportunity to refactor the const-eval error handling a bit to use the `MachineStop` variant.\n\nAlso, in const-prop I could do some cleanup as now, no more lints are being reported in `use_ecx`. However, I am quite puzzled by why exactly the linting there works the way it does -- the code can certainly be cleaned up more, but I don't know enough of the intent to do that. I left some questions for the most confusing parts, but for now behavior should be unchanged by this PR (so, all that weirdness I am asking about is pre-existing and merely maintained here). Cc @wesleywiser\n\nFixes https://github.com/rust-lang/rust/issues/66902\n\nr? @oli-obk", "tree": {"sha": "2bc1fe9b6da415b4ee049ae12e1a9f43ef4d987d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bc1fe9b6da415b4ee049ae12e1a9f43ef4d987d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d538b80ad77949e46989cd355cdec193b574f052", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d538b80ad77949e46989cd355cdec193b574f052", "html_url": "https://github.com/rust-lang/rust/commit/d538b80ad77949e46989cd355cdec193b574f052", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d538b80ad77949e46989cd355cdec193b574f052/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be493fe8cc40c3d3f6030a1313c1ff747fce770d", "url": "https://api.github.com/repos/rust-lang/rust/commits/be493fe8cc40c3d3f6030a1313c1ff747fce770d", "html_url": "https://github.com/rust-lang/rust/commit/be493fe8cc40c3d3f6030a1313c1ff747fce770d"}, {"sha": "33ba83c3a0905c86a6b5182b3b3d35f2f6086e5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/33ba83c3a0905c86a6b5182b3b3d35f2f6086e5b", "html_url": "https://github.com/rust-lang/rust/commit/33ba83c3a0905c86a6b5182b3b3d35f2f6086e5b"}], "stats": {"total": 545, "additions": 271, "deletions": 274}, "files": [{"sha": "e747eee30f90d2715a6b32c886a2a5bfe0725a1b", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 51, "deletions": 95, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -7,11 +7,9 @@ use crate::ty::query::TyCtxtAt;\n use crate::ty::{self, layout, Ty};\n \n use backtrace::Backtrace;\n-use hir::GeneratorKind;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_macros::HashStable;\n-use rustc_span::symbol::Symbol;\n use rustc_span::{Pos, Span};\n use rustc_target::spec::abi::Abi;\n use std::{any::Any, env, fmt};\n@@ -128,9 +126,15 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         }\n     }\n \n-    /// Sets the message passed in via `message` and adds span labels before handing control back\n-    /// to `emit` to do any final processing. It's the caller's responsibility to call emit(),\n-    /// stash(), etc. within the `emit` function to dispose of the diagnostic properly.\n+    /// Create a diagnostic for this const eval error.\n+    ///\n+    /// Sets the message passed in via `message` and adds span labels with detailed error\n+    /// information before handing control back to `emit` to do any final processing.\n+    /// It's the caller's responsibility to call emit(), stash(), etc. within the `emit`\n+    /// function to dispose of the diagnostic properly.\n+    ///\n+    /// If `lint_root.is_some()` report it as a lint, else report it as a hard error.\n+    /// (Except that for some errors, we ignore all that -- see `must_error` below.)\n     fn struct_generic(\n         &self,\n         tcx: TyCtxtAt<'tcx>,\n@@ -139,20 +143,30 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         lint_root: Option<hir::HirId>,\n     ) -> Result<(), ErrorHandled> {\n         let must_error = match self.error {\n-            InterpError::MachineStop(_) => bug!(\"CTFE does not stop\"),\n             err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n                 return Err(ErrorHandled::TooGeneric);\n             }\n             err_inval!(TypeckError) => return Err(ErrorHandled::Reported),\n+            // We must *always* hard error on these, even if the caller wants just a lint.\n             err_inval!(Layout(LayoutError::SizeOverflow(_))) => true,\n             _ => false,\n         };\n         trace!(\"reporting const eval failure at {:?}\", self.span);\n \n-        let add_span_labels = |err: &mut DiagnosticBuilder<'_>| {\n-            if !must_error {\n-                err.span_label(self.span, self.error.to_string());\n+        let err_msg = match &self.error {\n+            InterpError::MachineStop(msg) => {\n+                // A custom error (`ConstEvalErrKind` in `librustc_mir/interp/const_eval/error.rs`).\n+                // Should be turned into a string by now.\n+                msg.downcast_ref::<String>().expect(\"invalid MachineStop payload\").clone()\n             }\n+            err => err.to_string(),\n+        };\n+\n+        let finish = |mut err: DiagnosticBuilder<'_>, span_msg: Option<String>| {\n+            if let Some(span_msg) = span_msg {\n+                err.span_label(self.span, span_msg);\n+            }\n+            // Add spans for the stacktrace.\n             // Skip the last, which is just the environment of the constant.  The stacktrace\n             // is sometimes empty because we create \"fake\" eval contexts in CTFE to do work\n             // on constant values.\n@@ -161,35 +175,37 @@ impl<'tcx> ConstEvalErr<'tcx> {\n                     err.span_label(frame_info.call_site, frame_info.to_string());\n                 }\n             }\n+            // Let the caller finish the job.\n+            emit(err)\n         };\n \n-        if let (Some(lint_root), false) = (lint_root, must_error) {\n-            let hir_id = self\n-                .stacktrace\n-                .iter()\n-                .rev()\n-                .filter_map(|frame| frame.lint_root)\n-                .next()\n-                .unwrap_or(lint_root);\n-            tcx.struct_span_lint_hir(\n-                rustc_session::lint::builtin::CONST_ERR,\n-                hir_id,\n-                tcx.span,\n-                |lint| {\n-                    let mut err = lint.build(message);\n-                    add_span_labels(&mut err);\n-                    emit(err);\n-                },\n-            );\n+        if must_error {\n+            // The `message` makes little sense here, this is a more serious error than the\n+            // caller thinks anyway.\n+            // See <https://github.com/rust-lang/rust/pull/63152>.\n+            finish(struct_error(tcx, &err_msg), None);\n         } else {\n-            let mut err = if must_error {\n-                struct_error(tcx, &self.error.to_string())\n+            // Regular case.\n+            if let Some(lint_root) = lint_root {\n+                // Report as lint.\n+                let hir_id = self\n+                    .stacktrace\n+                    .iter()\n+                    .rev()\n+                    .filter_map(|frame| frame.lint_root)\n+                    .next()\n+                    .unwrap_or(lint_root);\n+                tcx.struct_span_lint_hir(\n+                    rustc_session::lint::builtin::CONST_ERR,\n+                    hir_id,\n+                    tcx.span,\n+                    |lint| finish(lint.build(message), Some(err_msg)),\n+                );\n             } else {\n-                struct_error(tcx, message)\n-            };\n-            add_span_labels(&mut err);\n-            emit(err);\n-        };\n+                // Report as hard error.\n+                finish(struct_error(tcx, message), Some(err_msg));\n+            }\n+        }\n         Ok(())\n     }\n }\n@@ -259,63 +275,6 @@ impl<'tcx> From<InterpError<'tcx>> for InterpErrorInfo<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n-pub enum PanicInfo<O> {\n-    Panic { msg: Symbol, line: u32, col: u32, file: Symbol },\n-    BoundsCheck { len: O, index: O },\n-    Overflow(mir::BinOp),\n-    OverflowNeg,\n-    DivisionByZero,\n-    RemainderByZero,\n-    ResumedAfterReturn(GeneratorKind),\n-    ResumedAfterPanic(GeneratorKind),\n-}\n-\n-/// Type for MIR `Assert` terminator error messages.\n-pub type AssertMessage<'tcx> = PanicInfo<mir::Operand<'tcx>>;\n-\n-impl<O> PanicInfo<O> {\n-    /// Getting a description does not require `O` to be printable, and does not\n-    /// require allocation.\n-    /// The caller is expected to handle `Panic` and `BoundsCheck` separately.\n-    pub fn description(&self) -> &'static str {\n-        use PanicInfo::*;\n-        match self {\n-            Overflow(mir::BinOp::Add) => \"attempt to add with overflow\",\n-            Overflow(mir::BinOp::Sub) => \"attempt to subtract with overflow\",\n-            Overflow(mir::BinOp::Mul) => \"attempt to multiply with overflow\",\n-            Overflow(mir::BinOp::Div) => \"attempt to divide with overflow\",\n-            Overflow(mir::BinOp::Rem) => \"attempt to calculate the remainder with overflow\",\n-            OverflowNeg => \"attempt to negate with overflow\",\n-            Overflow(mir::BinOp::Shr) => \"attempt to shift right with overflow\",\n-            Overflow(mir::BinOp::Shl) => \"attempt to shift left with overflow\",\n-            Overflow(op) => bug!(\"{:?} cannot overflow\", op),\n-            DivisionByZero => \"attempt to divide by zero\",\n-            RemainderByZero => \"attempt to calculate the remainder with a divisor of zero\",\n-            ResumedAfterReturn(GeneratorKind::Gen) => \"generator resumed after completion\",\n-            ResumedAfterReturn(GeneratorKind::Async(_)) => \"`async fn` resumed after completion\",\n-            ResumedAfterPanic(GeneratorKind::Gen) => \"generator resumed after panicking\",\n-            ResumedAfterPanic(GeneratorKind::Async(_)) => \"`async fn` resumed after panicking\",\n-            Panic { .. } | BoundsCheck { .. } => bug!(\"Unexpected PanicInfo\"),\n-        }\n-    }\n-}\n-\n-impl<O: fmt::Debug> fmt::Debug for PanicInfo<O> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use PanicInfo::*;\n-        match self {\n-            Panic { ref msg, line, col, ref file } => {\n-                write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col)\n-            }\n-            BoundsCheck { ref len, ref index } => {\n-                write!(f, \"index out of bounds: the len is {:?} but the index is {:?}\", len, index)\n-            }\n-            _ => write!(f, \"{}\", self.description()),\n-        }\n-    }\n-}\n-\n /// Error information for when the program we executed turned out not to actually be a valid\n /// program. This cannot happen in stand-alone Miri, but it can happen during CTFE/ConstProp\n /// where we work on generic code or execution does not have all information available.\n@@ -616,8 +575,6 @@ impl fmt::Debug for ResourceExhaustionInfo {\n }\n \n pub enum InterpError<'tcx> {\n-    /// The program panicked.\n-    Panic(PanicInfo<u64>),\n     /// The program caused undefined behavior.\n     UndefinedBehavior(UndefinedBehaviorInfo),\n     /// The program did something the interpreter does not support (some of these *might* be UB\n@@ -650,8 +607,7 @@ impl fmt::Debug for InterpError<'_> {\n             InvalidProgram(ref msg) => write!(f, \"{:?}\", msg),\n             UndefinedBehavior(ref msg) => write!(f, \"{:?}\", msg),\n             ResourceExhaustion(ref msg) => write!(f, \"{:?}\", msg),\n-            Panic(ref msg) => write!(f, \"{:?}\", msg),\n-            MachineStop(_) => write!(f, \"machine caused execution to stop\"),\n+            MachineStop(_) => bug!(\"unhandled MachineStop\"),\n         }\n     }\n }"}, {"sha": "f0879bdd8ae9b6482a1362f016db198cd6a027ab", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -37,15 +37,6 @@ macro_rules! err_ub_format {\n     ($($tt:tt)*) => { err_ub!(Ub(format!($($tt)*))) };\n }\n \n-#[macro_export]\n-macro_rules! err_panic {\n-    ($($tt:tt)*) => {\n-        $crate::mir::interpret::InterpError::Panic(\n-            $crate::mir::interpret::PanicInfo::$($tt)*\n-        )\n-    };\n-}\n-\n #[macro_export]\n macro_rules! err_exhaust {\n     ($($tt:tt)*) => {\n@@ -80,11 +71,6 @@ macro_rules! throw_ub_format {\n     ($($tt:tt)*) => { throw_ub!(Ub(format!($($tt)*))) };\n }\n \n-#[macro_export]\n-macro_rules! throw_panic {\n-    ($($tt:tt)*) => { return Err(err_panic!($($tt)*).into()) };\n-}\n-\n #[macro_export]\n macro_rules! throw_exhaust {\n     ($($tt:tt)*) => { return Err(err_exhaust!($($tt)*).into()) };\n@@ -104,9 +90,9 @@ mod queries;\n mod value;\n \n pub use self::error::{\n-    struct_error, AssertMessage, ConstEvalErr, ConstEvalRawResult, ConstEvalResult, ErrorHandled,\n-    FrameInfo, InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, PanicInfo,\n-    ResourceExhaustionInfo, UndefinedBehaviorInfo, UnsupportedOpInfo,\n+    struct_error, ConstEvalErr, ConstEvalRawResult, ConstEvalResult, ErrorHandled, FrameInfo,\n+    InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, ResourceExhaustionInfo,\n+    UndefinedBehaviorInfo, UnsupportedOpInfo,\n };\n \n pub use self::value::{get_slice_bytes, ConstValue, RawConst, Scalar, ScalarMaybeUndef};"}, {"sha": "4520d3a333316599fec2759e519e51fb002c6ba8", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -2,7 +2,7 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/index.html\n \n-use crate::mir::interpret::{GlobalAlloc, PanicInfo, Scalar};\n+use crate::mir::interpret::{GlobalAlloc, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -36,7 +36,6 @@ pub use syntax::ast::Mutability;\n use syntax::ast::Name;\n \n pub use self::cache::{BodyAndCache, ReadOnlyBodyAndCache};\n-pub use self::interpret::AssertMessage;\n pub use self::query::*;\n pub use crate::read_only;\n \n@@ -1154,6 +1153,21 @@ pub enum TerminatorKind<'tcx> {\n     },\n }\n \n+/// Information about an assertion failure.\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n+pub enum AssertKind<O> {\n+    BoundsCheck { len: O, index: O },\n+    Overflow(BinOp),\n+    OverflowNeg,\n+    DivisionByZero,\n+    RemainderByZero,\n+    ResumedAfterReturn(GeneratorKind),\n+    ResumedAfterPanic(GeneratorKind),\n+}\n+\n+/// Type for MIR `Assert` terminator error messages.\n+pub type AssertMessage<'tcx> = AssertKind<Operand<'tcx>>;\n+\n pub type Successors<'a> =\n     iter::Chain<option::IntoIter<&'a BasicBlock>, slice::Iter<'a, BasicBlock>>;\n pub type SuccessorsMut<'a> =\n@@ -1383,6 +1397,45 @@ impl<'tcx> BasicBlockData<'tcx> {\n     }\n }\n \n+impl<O> AssertKind<O> {\n+    /// Getting a description does not require `O` to be printable, and does not\n+    /// require allocation.\n+    /// The caller is expected to handle `BoundsCheck` separately.\n+    pub fn description(&self) -> &'static str {\n+        use AssertKind::*;\n+        match self {\n+            Overflow(BinOp::Add) => \"attempt to add with overflow\",\n+            Overflow(BinOp::Sub) => \"attempt to subtract with overflow\",\n+            Overflow(BinOp::Mul) => \"attempt to multiply with overflow\",\n+            Overflow(BinOp::Div) => \"attempt to divide with overflow\",\n+            Overflow(BinOp::Rem) => \"attempt to calculate the remainder with overflow\",\n+            OverflowNeg => \"attempt to negate with overflow\",\n+            Overflow(BinOp::Shr) => \"attempt to shift right with overflow\",\n+            Overflow(BinOp::Shl) => \"attempt to shift left with overflow\",\n+            Overflow(op) => bug!(\"{:?} cannot overflow\", op),\n+            DivisionByZero => \"attempt to divide by zero\",\n+            RemainderByZero => \"attempt to calculate the remainder with a divisor of zero\",\n+            ResumedAfterReturn(GeneratorKind::Gen) => \"generator resumed after completion\",\n+            ResumedAfterReturn(GeneratorKind::Async(_)) => \"`async fn` resumed after completion\",\n+            ResumedAfterPanic(GeneratorKind::Gen) => \"generator resumed after panicking\",\n+            ResumedAfterPanic(GeneratorKind::Async(_)) => \"`async fn` resumed after panicking\",\n+            BoundsCheck { .. } => bug!(\"Unexpected AssertKind\"),\n+        }\n+    }\n+}\n+\n+impl<O: fmt::Debug> fmt::Debug for AssertKind<O> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use AssertKind::*;\n+        match self {\n+            BoundsCheck { ref len, ref index } => {\n+                write!(f, \"index out of bounds: the len is {:?} but the index is {:?}\", len, index)\n+            }\n+            _ => write!(f, \"{}\", self.description()),\n+        }\n+    }\n+}\n+\n impl<'tcx> Debug for TerminatorKind<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         self.fmt_head(fmt)?;\n@@ -2666,13 +2719,12 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 }\n             }\n             Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                use PanicInfo::*;\n+                use AssertKind::*;\n                 let msg = match msg {\n                     BoundsCheck { ref len, ref index } => {\n                         BoundsCheck { len: len.fold_with(folder), index: index.fold_with(folder) }\n                     }\n-                    Panic { .. }\n-                    | Overflow(_)\n+                    Overflow(_)\n                     | OverflowNeg\n                     | DivisionByZero\n                     | RemainderByZero\n@@ -2716,13 +2768,12 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             }\n             Assert { ref cond, ref msg, .. } => {\n                 if cond.visit_with(visitor) {\n-                    use PanicInfo::*;\n+                    use AssertKind::*;\n                     match msg {\n                         BoundsCheck { ref len, ref index } => {\n                             len.visit_with(visitor) || index.visit_with(visitor)\n                         }\n-                        Panic { .. }\n-                        | Overflow(_)\n+                        Overflow(_)\n                         | OverflowNeg\n                         | DivisionByZero\n                         | RemainderByZero"}, {"sha": "8330bbe0834326b2844d49aec5dbf5509e86cf16", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -533,13 +533,13 @@ macro_rules! make_mir_visitor {\n             fn super_assert_message(&mut self,\n                                     msg: & $($mutability)? AssertMessage<'tcx>,\n                                     location: Location) {\n-                use crate::mir::interpret::PanicInfo::*;\n+                use crate::mir::AssertKind::*;\n                 match msg {\n                     BoundsCheck { len, index } => {\n                         self.visit_operand(len, location);\n                         self.visit_operand(index, location);\n                     }\n-                    Panic { .. } | Overflow(_) | OverflowNeg | DivisionByZero | RemainderByZero |\n+                    Overflow(_) | OverflowNeg | DivisionByZero | RemainderByZero |\n                     ResumedAfterReturn(_) | ResumedAfterPanic(_) => {\n                         // Nothing to visit\n                     }"}, {"sha": "916c15eb1b6eaa6446d373ff3bf9cb8d1101b107", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -11,7 +11,7 @@ use crate::MemFlags;\n \n use rustc::middle::lang_items;\n use rustc::mir;\n-use rustc::mir::interpret::PanicInfo;\n+use rustc::mir::AssertKind;\n use rustc::ty::layout::{self, FnAbiExt, HasTyCtxt, LayoutOf};\n use rustc::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_index::vec::Idx;\n@@ -378,7 +378,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // checked operation, just a comparison with the minimum\n         // value, so we have to check for the assert message.\n         if !bx.check_overflow() {\n-            if let PanicInfo::OverflowNeg = *msg {\n+            if let AssertKind::OverflowNeg = *msg {\n                 const_cond = Some(expected);\n             }\n         }\n@@ -412,7 +412,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Put together the arguments to the panic entry point.\n         let (lang_item, args) = match msg {\n-            PanicInfo::BoundsCheck { ref len, ref index } => {\n+            AssertKind::BoundsCheck { ref len, ref index } => {\n                 let len = self.codegen_operand(&mut bx, len).immediate();\n                 let index = self.codegen_operand(&mut bx, index).immediate();\n                 (lang_items::PanicBoundsCheckFnLangItem, vec![location, index, len])"}, {"sha": "0bead27050ce642cb6830199f7e8e41db7a5fee4", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -153,8 +153,8 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n             TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n                 self.consume_operand(location, cond);\n-                use rustc::mir::interpret::PanicInfo;\n-                if let PanicInfo::BoundsCheck { ref len, ref index } = *msg {\n+                use rustc::mir::AssertKind;\n+                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n                     self.consume_operand(location, len);\n                     self.consume_operand(location, index);\n                 }"}, {"sha": "941534e68fcad75c5a4cf4decdf36e27004f149b", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -654,8 +654,8 @@ impl<'cx, 'tcx> dataflow::generic::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt\n             }\n             TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n                 self.consume_operand(loc, (cond, span), flow_state);\n-                use rustc::mir::interpret::PanicInfo;\n-                if let PanicInfo::BoundsCheck { ref len, ref index } = *msg {\n+                use rustc::mir::AssertKind;\n+                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n                     self.consume_operand(loc, (len, span), flow_state);\n                     self.consume_operand(loc, (index, span), flow_state);\n                 }"}, {"sha": "5dab064c7b7fc2b781b2acab44b63c8b0ff3e838", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -9,9 +9,9 @@ use rustc::infer::canonical::QueryRegionConstraints;\n use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n-use rustc::mir::interpret::PanicInfo;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n+use rustc::mir::AssertKind;\n use rustc::mir::*;\n use rustc::traits::query::type_op;\n use rustc::traits::query::type_op::custom::CustomTypeOp;\n@@ -1562,7 +1562,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n                 }\n \n-                if let PanicInfo::BoundsCheck { ref len, ref index } = *msg {\n+                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n                     if len.ty(body, tcx) != tcx.types.usize {\n                         span_mirbug!(self, len, \"bounds-check length non-usize {:?}\", len)\n                     }"}, {"sha": "63ad9ec8cae9eec3481de3ef66ae11488dec4f92", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -1,33 +1,47 @@\n use std::error::Error;\n use std::fmt;\n \n+use rustc::mir::AssertKind;\n+use rustc_span::Symbol;\n+\n use super::InterpCx;\n-use crate::interpret::{ConstEvalErr, InterpErrorInfo, Machine};\n+use crate::interpret::{ConstEvalErr, InterpError, InterpErrorInfo, Machine};\n+\n+/// The CTFE machine has some custom error kinds.\n #[derive(Clone, Debug)]\n-pub enum ConstEvalError {\n+pub enum ConstEvalErrKind {\n     NeedsRfc(String),\n     ConstAccessesStatic,\n+    AssertFailure(AssertKind<u64>),\n+    Panic { msg: Symbol, line: u32, col: u32, file: Symbol },\n }\n \n-impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalError {\n+// The errors become `MachineStop` with plain strings when being raised.\n+// `ConstEvalErr` (in `librustc/mir/interpret/error.rs`) knows to\n+// handle these.\n+impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalErrKind {\n     fn into(self) -> InterpErrorInfo<'tcx> {\n-        err_unsup!(Unsupported(self.to_string())).into()\n+        InterpError::MachineStop(Box::new(self.to_string())).into()\n     }\n }\n \n-impl fmt::Display for ConstEvalError {\n+impl fmt::Display for ConstEvalErrKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use self::ConstEvalError::*;\n+        use self::ConstEvalErrKind::*;\n         match *self {\n             NeedsRfc(ref msg) => {\n                 write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg)\n             }\n             ConstAccessesStatic => write!(f, \"constant accesses static\"),\n+            AssertFailure(ref msg) => write!(f, \"{:?}\", msg),\n+            Panic { msg, line, col, file } => {\n+                write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col)\n+            }\n         }\n     }\n }\n \n-impl Error for ConstEvalError {}\n+impl Error for ConstEvalErrKind {}\n \n /// Turn an interpreter error into something to report to the user.\n /// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace."}, {"sha": "e40436ccf0b4b546e37a8ae616b0774df8ecbe99", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -8,11 +8,13 @@ use std::hash::Hash;\n \n use rustc_data_structures::fx::FxHashMap;\n \n+use rustc::mir::AssertMessage;\n use rustc_span::source_map::Span;\n+use rustc_span::symbol::Symbol;\n \n use crate::interpret::{\n-    self, snapshot, AllocId, Allocation, AssertMessage, GlobalId, ImmTy, InterpCx, InterpResult,\n-    Memory, MemoryKind, OpTy, PlaceTy, Pointer, Scalar,\n+    self, snapshot, AllocId, Allocation, GlobalId, ImmTy, InterpCx, InterpResult, Memory,\n+    MemoryKind, OpTy, PlaceTy, Pointer, Scalar,\n };\n \n use super::error::*;\n@@ -56,6 +58,32 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n         self.dump_place(*dest);\n         return Ok(true);\n     }\n+\n+    /// \"Intercept\" a function call to a panic-related function\n+    /// because we have something special to do for it.\n+    /// If this returns successfully (`Ok`), the function should just be evaluated normally.\n+    fn hook_panic_fn(\n+        &mut self,\n+        span: Span,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx>],\n+    ) -> InterpResult<'tcx> {\n+        let def_id = instance.def_id();\n+        if Some(def_id) == self.tcx.lang_items().panic_fn()\n+            || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+        {\n+            // &'static str\n+            assert!(args.len() == 1);\n+\n+            let msg_place = self.deref_operand(args[0])?;\n+            let msg = Symbol::intern(self.read_str(msg_place)?);\n+            let span = self.find_closest_untracked_caller_location().unwrap_or(span);\n+            let (file, line, col) = self.location_triple_for_span(span);\n+            Err(ConstEvalErrKind::Panic { msg, file, line, col }.into())\n+        } else {\n+            Ok(())\n+        }\n+    }\n }\n \n /// Number of steps until the detector even starts doing anything.\n@@ -198,21 +226,19 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 }\n             } else {\n                 // Some functions we support even if they are non-const -- but avoid testing\n-                // that for const fn!  We certainly do *not* want to actually call the fn\n+                // that for const fn!\n+                ecx.hook_panic_fn(span, instance, args)?;\n+                // We certainly do *not* want to actually call the fn\n                 // though, so be sure we return here.\n-                return if ecx.hook_panic_fn(span, instance, args)? {\n-                    Ok(None)\n-                } else {\n-                    throw_unsup_format!(\"calling non-const function `{}`\", instance)\n-                };\n+                throw_unsup_format!(\"calling non-const function `{}`\", instance)\n             }\n         }\n         // This is a const fn. Call it.\n         Ok(Some(match ecx.load_mir(instance.def, None) {\n             Ok(body) => *body,\n             Err(err) => {\n                 if let err_unsup!(NoMirFor(ref path)) = err.kind {\n-                    return Err(ConstEvalError::NeedsRfc(format!(\n+                    return Err(ConstEvalErrKind::NeedsRfc(format!(\n                         \"calling extern function `{}`\",\n                         path\n                     ))\n@@ -246,7 +272,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         }\n         // An intrinsic that we do not support\n         let intrinsic_name = ecx.tcx.item_name(instance.def_id());\n-        Err(ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", intrinsic_name)).into())\n+        Err(ConstEvalErrKind::NeedsRfc(format!(\"calling intrinsic `{}`\", intrinsic_name)).into())\n     }\n \n     fn assert_panic(\n@@ -255,8 +281,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         msg: &AssertMessage<'tcx>,\n         _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n-        use rustc::mir::interpret::PanicInfo::*;\n-        Err(match msg {\n+        use rustc::mir::AssertKind::*;\n+        // Convert `AssertKind<Operand>` to `AssertKind<u64>`.\n+        let err = match msg {\n             BoundsCheck { ref len, ref index } => {\n                 let len = ecx\n                     .read_immediate(ecx.eval_operand(len, None)?)\n@@ -268,21 +295,20 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     .expect(\"can't eval index\")\n                     .to_scalar()?\n                     .to_machine_usize(&*ecx)?;\n-                err_panic!(BoundsCheck { len, index })\n+                BoundsCheck { len, index }\n             }\n-            Overflow(op) => err_panic!(Overflow(*op)),\n-            OverflowNeg => err_panic!(OverflowNeg),\n-            DivisionByZero => err_panic!(DivisionByZero),\n-            RemainderByZero => err_panic!(RemainderByZero),\n-            ResumedAfterReturn(generator_kind) => err_panic!(ResumedAfterReturn(*generator_kind)),\n-            ResumedAfterPanic(generator_kind) => err_panic!(ResumedAfterPanic(*generator_kind)),\n-            Panic { .. } => bug!(\"`Panic` variant cannot occur in MIR\"),\n-        }\n-        .into())\n+            Overflow(op) => Overflow(*op),\n+            OverflowNeg => OverflowNeg,\n+            DivisionByZero => DivisionByZero,\n+            RemainderByZero => RemainderByZero,\n+            ResumedAfterReturn(generator_kind) => ResumedAfterReturn(*generator_kind),\n+            ResumedAfterPanic(generator_kind) => ResumedAfterPanic(*generator_kind),\n+        };\n+        Err(ConstEvalErrKind::AssertFailure(err).into())\n     }\n \n     fn ptr_to_int(_mem: &Memory<'mir, 'tcx, Self>, _ptr: Pointer) -> InterpResult<'tcx, u64> {\n-        Err(ConstEvalError::NeedsRfc(\"pointer-to-integer cast\".to_string()).into())\n+        Err(ConstEvalErrKind::NeedsRfc(\"pointer-to-integer cast\".to_string()).into())\n     }\n \n     fn binary_ptr_op(\n@@ -291,7 +317,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n-        Err(ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n+        Err(ConstEvalErrKind::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n     }\n \n     fn find_foreign_static(\n@@ -321,7 +347,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n-        Err(ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into())\n+        Err(ConstEvalErrKind::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into())\n     }\n \n     fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n@@ -355,7 +381,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         if memory_extra.can_access_statics {\n             Ok(())\n         } else {\n-            Err(ConstEvalError::ConstAccessesStatic.into())\n+            Err(ConstEvalErrKind::ConstAccessesStatic.into())\n         }\n     }\n }"}, {"sha": "a83b541279061fca017ea96fa5d6975079bd23a0", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -376,32 +376,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(true)\n     }\n \n-    /// \"Intercept\" a function call to a panic-related function\n-    /// because we have something special to do for it.\n-    /// Returns `true` if an intercept happened.\n-    pub fn hook_panic_fn(\n-        &mut self,\n-        span: Span,\n-        instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, M::PointerTag>],\n-    ) -> InterpResult<'tcx, bool> {\n-        let def_id = instance.def_id();\n-        if Some(def_id) == self.tcx.lang_items().panic_fn()\n-            || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n-        {\n-            // &'static str\n-            assert!(args.len() == 1);\n-\n-            let msg_place = self.deref_operand(args[0])?;\n-            let msg = Symbol::intern(self.read_str(msg_place)?);\n-            let span = self.find_closest_untracked_caller_location().unwrap_or(span);\n-            let (file, line, col) = self.location_triple_for_span(span);\n-            throw_panic!(Panic { msg, file, line, col })\n-        } else {\n-            return Ok(false);\n-        }\n-    }\n-\n     pub fn exact_div(\n         &mut self,\n         a: ImmTy<'tcx, M::PointerTag>,"}, {"sha": "566601f0cae28b67d588a745f3d89460948ff3b8", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -54,12 +54,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         location\n     }\n \n-    pub fn alloc_caller_location_for_span(&mut self, span: Span) -> MPlaceTy<'tcx, M::PointerTag> {\n-        let (file, line, column) = self.location_triple_for_span(span);\n-        self.alloc_caller_location(file, line, column)\n-    }\n-\n-    pub(super) fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n+    crate fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n         (\n@@ -68,4 +63,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             caller.col_display as u32 + 1,\n         )\n     }\n+\n+    pub fn alloc_caller_location_for_span(&mut self, span: Span) -> MPlaceTy<'tcx, M::PointerTag> {\n+        let (file, line, column) = self.location_triple_for_span(span);\n+        self.alloc_caller_location(file, line, column)\n+    }\n }"}, {"sha": "5291000d10b3fa775d18135084d1b3d727ac41e8", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -11,8 +11,8 @@ use rustc_hir::def_id::DefId;\n use rustc_span::Span;\n \n use super::{\n-    AllocId, Allocation, AllocationExtra, AssertMessage, Frame, ImmTy, InterpCx, InterpResult,\n-    Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Scalar,\n+    AllocId, Allocation, AllocationExtra, Frame, ImmTy, InterpCx, InterpResult, Memory, MemoryKind,\n+    OpTy, Operand, PlaceTy, Pointer, Scalar,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -171,7 +171,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn assert_panic(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         span: Span,\n-        msg: &AssertMessage<'tcx>,\n+        msg: &mir::AssertMessage<'tcx>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx>;\n "}, {"sha": "5729cda64f7ae9c051d24ac9c0ad424aba700136", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 57, "deletions": 67, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -4,13 +4,13 @@\n use std::borrow::Cow;\n use std::cell::Cell;\n \n-use rustc::mir::interpret::{InterpResult, PanicInfo, Scalar};\n+use rustc::mir::interpret::{InterpError, InterpResult, Scalar};\n use rustc::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n use rustc::mir::{\n-    read_only, AggregateKind, BasicBlock, BinOp, Body, BodyAndCache, ClearCrossCrate, Constant,\n-    Local, LocalDecl, LocalKind, Location, Operand, Place, ReadOnlyBodyAndCache, Rvalue,\n+    read_only, AggregateKind, AssertKind, BasicBlock, BinOp, Body, BodyAndCache, ClearCrossCrate,\n+    Constant, Local, LocalDecl, LocalKind, Location, Operand, Place, ReadOnlyBodyAndCache, Rvalue,\n     SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator, TerminatorKind,\n     UnOp, RETURN_PLACE,\n };\n@@ -25,7 +25,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use syntax::ast::Mutability;\n \n use crate::const_eval::error_to_const_error;\n@@ -198,7 +198,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     fn assert_panic(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _span: Span,\n-        _msg: &rustc::mir::interpret::AssertMessage<'tcx>,\n+        _msg: &rustc::mir::AssertMessage<'tcx>,\n         _unwind: Option<rustc::mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         bug!(\"panics terminators are not evaluated in ConstProp\");\n@@ -410,15 +410,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn use_ecx<F, T>(&mut self, source_info: SourceInfo, f: F) -> Option<T>\n+    fn use_ecx<F, T>(&mut self, f: F) -> Option<T>\n     where\n         F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n     {\n-        self.ecx.tcx.span = source_info.span;\n-        // FIXME(eddyb) move this to the `Panic(_)` error case, so that\n-        // `f(self)` is always called, and that the only difference when the\n-        // scope's `local_data` is missing, is that the lint isn't emitted.\n-        let lint_root = self.lint_root(source_info)?;\n         let r = match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n@@ -447,20 +442,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     | ResourceExhaustion(_) => {\n                         // Ignore these errors.\n                     }\n-                    Panic(_) => {\n-                        let diagnostic = error_to_const_error(&self.ecx, error);\n-                        diagnostic.report_as_lint(\n-                            self.ecx.tcx,\n-                            \"this expression will panic at runtime\",\n-                            lint_root,\n-                            None,\n-                        );\n-                    }\n                 }\n                 None\n             }\n         };\n-        self.ecx.tcx.span = DUMMY_SP;\n         r\n     }\n \n@@ -504,37 +489,49 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn eval_place(&mut self, place: &Place<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+    fn eval_place(&mut self, place: &Place<'tcx>) -> Option<OpTy<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        self.use_ecx(source_info, |this| this.ecx.eval_place_to_op(place, None))\n+        self.use_ecx(|this| this.ecx.eval_place_to_op(place, None))\n     }\n \n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n         match *op {\n             Operand::Constant(ref c) => self.eval_constant(c, source_info),\n-            Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                self.eval_place(place, source_info)\n-            }\n+            Operand::Move(ref place) | Operand::Copy(ref place) => self.eval_place(place),\n         }\n     }\n \n+    fn report_panic_as_lint(&self, source_info: SourceInfo, panic: AssertKind<u64>) -> Option<()> {\n+        // Somewhat convoluted way to re-use the CTFE error reporting code.\n+        let lint_root = self.lint_root(source_info)?;\n+        let error = InterpError::MachineStop(Box::new(format!(\"{:?}\", panic)));\n+        let mut diagnostic = error_to_const_error(&self.ecx, error.into());\n+        diagnostic.span = source_info.span; // fix the span\n+        diagnostic.report_as_lint(\n+            self.tcx.at(source_info.span),\n+            \"this expression will panic at runtime\",\n+            lint_root,\n+            None,\n+        );\n+        None\n+    }\n+\n     fn check_unary_op(\n         &mut self,\n         op: UnOp,\n         arg: &Operand<'tcx>,\n         source_info: SourceInfo,\n     ) -> Option<()> {\n-        self.use_ecx(source_info, |this| {\n+        if self.use_ecx(|this| {\n             let val = this.ecx.read_immediate(this.ecx.eval_operand(arg, None)?)?;\n             let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, val)?;\n-\n-            if overflow {\n-                assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n-                throw_panic!(OverflowNeg);\n-            }\n-\n-            Ok(())\n-        })?;\n+            Ok(overflow)\n+        })? {\n+            // `AssertKind` only has an `OverflowNeg` variant, so make sure that is\n+            // appropriate to use.\n+            assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n+            self.report_panic_as_lint(source_info, AssertKind::OverflowNeg)?;\n+        }\n \n         Some(())\n     }\n@@ -546,11 +543,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         right: &Operand<'tcx>,\n         source_info: SourceInfo,\n         place_layout: TyLayout<'tcx>,\n-        overflow_check: bool,\n     ) -> Option<()> {\n-        let r = self.use_ecx(source_info, |this| {\n-            this.ecx.read_immediate(this.ecx.eval_operand(right, None)?)\n-        })?;\n+        let r =\n+            self.use_ecx(|this| this.ecx.read_immediate(this.ecx.eval_operand(right, None)?))?;\n+        // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n         if op == BinOp::Shr || op == BinOp::Shl {\n             let left_bits = place_layout.size.bits();\n             let right_size = r.layout.size;\n@@ -570,21 +566,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             }\n         }\n \n-        // If overflow checking is enabled (like in debug mode by default),\n-        // then we'll already catch overflow when we evaluate the `Assert` statement\n-        // in MIR. However, if overflow checking is disabled, then there won't be any\n-        // `Assert` statement and so we have to do additional checking here.\n-        if !overflow_check {\n-            self.use_ecx(source_info, |this| {\n-                let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n-                let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n-\n-                if overflow {\n-                    throw_panic!(Overflow(op));\n-                }\n-\n-                Ok(())\n-            })?;\n+        // The remaining operators are handled through `overflowing_binary_op`.\n+        if self.use_ecx(|this| {\n+            let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n+            let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n+            Ok(overflow)\n+        })? {\n+            self.report_panic_as_lint(source_info, AssertKind::Overflow(op))?;\n         }\n \n         Some(())\n@@ -617,19 +605,21 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         //   2. Working around bugs in other parts of the compiler\n         //        - In this case, we'll return `None` from this function to stop evaluation.\n         match rvalue {\n-            // Additional checking: if overflow checks are disabled (which is usually the case in\n-            // release mode), then we need to do additional checking here to give lints to the user\n-            // if an overflow would occur.\n+            // Additional checking: give lints to the user if an overflow would occur.\n+            // If `overflow_check` is set, running const-prop on the `Assert` terminators\n+            // will already generate the appropriate messages.\n             Rvalue::UnaryOp(op, arg) if !overflow_check => {\n                 trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n                 self.check_unary_op(*op, arg, source_info)?;\n             }\n \n             // Additional checking: check for overflows on integer binary operations and report\n             // them to the user as lints.\n-            Rvalue::BinaryOp(op, left, right) => {\n+            // If `overflow_check` is set, running const-prop on the `Assert` terminators\n+            // will already generate the appropriate messages.\n+            Rvalue::BinaryOp(op, left, right) if !overflow_check => {\n                 trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n-                self.check_binary_op(*op, left, right, source_info, place_layout, overflow_check)?;\n+                self.check_binary_op(*op, left, right, source_info, place_layout)?;\n             }\n \n             // Do not try creating references (#67862)\n@@ -642,7 +632,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             _ => {}\n         }\n \n-        self.use_ecx(source_info, |this| {\n+        self.use_ecx(|this| {\n             trace!(\"calling eval_rvalue_into_place(rvalue = {:?}, place = {:?})\", rvalue, place);\n             this.ecx.eval_rvalue_into_place(rvalue, place)?;\n             Ok(())\n@@ -675,7 +665,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n \n         // FIXME> figure out what tho do when try_read_immediate fails\n-        let imm = self.use_ecx(source_info, |this| this.ecx.try_read_immediate(value));\n+        let imm = self.use_ecx(|this| this.ecx.try_read_immediate(value));\n \n         if let Some(Ok(imm)) = imm {\n             match *imm {\n@@ -698,7 +688,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     if let ty::Tuple(substs) = ty {\n                         // Only do it if tuple is also a pair with two scalars\n                         if substs.len() == 2 {\n-                            let opt_ty1_ty2 = self.use_ecx(source_info, |this| {\n+                            let opt_ty1_ty2 = self.use_ecx(|this| {\n                                 let ty1 = substs[0].expect_ty();\n                                 let ty2 = substs[1].expect_ty();\n                                 let ty_is_scalar = |ty| {\n@@ -920,11 +910,11 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                             span,\n                             |lint| {\n                                 let msg = match msg {\n-                                    PanicInfo::Overflow(_)\n-                                    | PanicInfo::OverflowNeg\n-                                    | PanicInfo::DivisionByZero\n-                                    | PanicInfo::RemainderByZero => msg.description().to_owned(),\n-                                    PanicInfo::BoundsCheck { ref len, ref index } => {\n+                                    AssertKind::Overflow(_)\n+                                    | AssertKind::OverflowNeg\n+                                    | AssertKind::DivisionByZero\n+                                    | AssertKind::RemainderByZero => msg.description().to_owned(),\n+                                    AssertKind::BoundsCheck { ref len, ref index } => {\n                                         let len = self\n                                             .eval_operand(len, source_info)\n                                             .expect(\"len must be const\");"}, {"sha": "d5d9a8c83cd37a79467713e1a13e68f34fa61991", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -1022,7 +1022,7 @@ fn create_generator_resume_function<'tcx>(\n \n     let mut cases = create_cases(body, &transform, Operation::Resume);\n \n-    use rustc::mir::interpret::PanicInfo::{ResumedAfterPanic, ResumedAfterReturn};\n+    use rustc::mir::AssertKind::{ResumedAfterPanic, ResumedAfterReturn};\n \n     // Jump to the entry point on the unresumed\n     cases.insert(0, (UNRESUMED, BasicBlock::new(0)));"}, {"sha": "d77cc49c94f6732cc3a2d7397c6b1b8d8407eae5", "filename": "src/librustc_mir_build/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -5,7 +5,7 @@ use crate::build::ForGuard::{OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::hair::*;\n use rustc::middle::region;\n-use rustc::mir::interpret::PanicInfo::BoundsCheck;\n+use rustc::mir::AssertKind::BoundsCheck;\n use rustc::mir::*;\n use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n use rustc_span::Span;"}, {"sha": "dc97f321a36ad66eef7407c108b0f82e663a6dc5", "filename": "src/librustc_mir_build/build/expr/as_rvalue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d538b80ad77949e46989cd355cdec193b574f052/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=d538b80ad77949e46989cd355cdec193b574f052", "patch": "@@ -6,7 +6,7 @@ use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::hair::*;\n use rustc::middle::region;\n-use rustc::mir::interpret::PanicInfo;\n+use rustc::mir::AssertKind;\n use rustc::mir::*;\n use rustc::ty::{self, Ty, UpvarSubsts};\n use rustc_span::Span;\n@@ -86,7 +86,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         block,\n                         Operand::Move(is_min),\n                         false,\n-                        PanicInfo::OverflowNeg,\n+                        AssertKind::OverflowNeg,\n                         expr_span,\n                     );\n                 }\n@@ -294,7 +294,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let val = tcx.mk_place_field(result_value.clone(), val_fld, ty);\n             let of = tcx.mk_place_field(result_value, of_fld, bool_ty);\n \n-            let err = PanicInfo::Overflow(op);\n+            let err = AssertKind::Overflow(op);\n \n             block = self.assert(block, Operand::Move(of), false, err, span);\n \n@@ -305,11 +305,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // and 2. there are two possible failure cases, divide-by-zero and overflow.\n \n                 let zero_err = if op == BinOp::Div {\n-                    PanicInfo::DivisionByZero\n+                    AssertKind::DivisionByZero\n                 } else {\n-                    PanicInfo::RemainderByZero\n+                    AssertKind::RemainderByZero\n                 };\n-                let overflow_err = PanicInfo::Overflow(op);\n+                let overflow_err = AssertKind::Overflow(op);\n \n                 // Check for / 0\n                 let is_zero = self.temp(bool_ty, span);"}]}