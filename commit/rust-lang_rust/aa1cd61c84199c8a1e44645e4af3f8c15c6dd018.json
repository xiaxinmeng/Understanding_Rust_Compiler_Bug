{"sha": "aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMWNkNjFjODQxOTljOGExZTQ0NjQ1ZTRhZjNmOGMxNWM2ZGQwMTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-10T00:56:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-14T22:32:18Z"}, "message": "push changes through to get things compiling, if not running.", "tree": {"sha": "96473fff23d43ceb7527e4bad10ef81e631e429f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96473fff23d43ceb7527e4bad10ef81e631e429f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "html_url": "https://github.com/rust-lang/rust/commit/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c28ada0368de78034e0930e01406f5e03a70d610", "url": "https://api.github.com/repos/rust-lang/rust/commits/c28ada0368de78034e0930e01406f5e03a70d610", "html_url": "https://github.com/rust-lang/rust/commit/c28ada0368de78034e0930e01406f5e03a70d610"}], "stats": {"total": 163, "additions": 103, "deletions": 60}, "files": [{"sha": "c2ca656192e8e611b4e83d6049fa171c471fccea", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "patch": "@@ -347,9 +347,18 @@ fn mk_test_wrapper(cx: test_ctxt,\n         body: wrapper_body\n     };\n \n+    let wrapper_capture: @ast::capture = @{\n+        node: {\n+            is_send: false,\n+            copies: [],\n+            moves: []\n+        },\n+        span: span\n+    };\n+\n     let wrapper_expr: ast::expr = {\n         id: cx.sess.next_node_id(),\n-        node: ast::expr_fn(wrapper_fn),\n+        node: ast::expr_fn(wrapper_fn, wrapper_capture),\n         span: span\n     };\n "}, {"sha": "434564f9c0d1d667ebe19830a2ad2dc969480cd3", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "patch": "@@ -164,6 +164,13 @@ fn parse_constr<copy T>(st: @pstate, sd: str_def, pser: arg_parser<T>) ->\n     ret @respan(sp, {path: pth, args: args, id: def});\n }\n \n+fn parse_ty_rust_fn(st: @pstate, sd: str_def, p: ast::proto) -> ty::t {\n+    let func = parse_ty_fn(st, sd);\n+    ret ty::mk_fn(st.tcx, p,\n+                  func.args, func.ty, func.cf,\n+                  func.cs);\n+}\n+\n fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n     alt next(st) as char {\n       'n' { ret ty::mk_nil(st.tcx); }\n@@ -235,21 +242,17 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         st.pos = st.pos + 1u;\n         ret ty::mk_tup(st.tcx, params);\n       }\n+      's' {\n+        ret parse_ty_rust_fn(st, sd, ast::proto_send);\n+      }\n       'F' {\n-        let func = parse_ty_fn(st, sd);\n-        ret ty::mk_fn(st.tcx, ast::proto_shared(ast::sugar_normal),\n-                      func.args, func.ty, func.cf,\n-                      func.cs);\n+        ret parse_ty_rust_fn(st, sd, ast::proto_shared(ast::sugar_normal));\n       }\n       'f' {\n-        let func = parse_ty_fn(st, sd);\n-        ret ty::mk_fn(st.tcx, ast::proto_bare, func.args, func.ty, func.cf,\n-                      func.cs);\n+        ret parse_ty_rust_fn(st, sd, ast::proto_bare);\n       }\n       'B' {\n-        let func = parse_ty_fn(st, sd);\n-        ret ty::mk_fn(st.tcx, ast::proto_block, func.args, func.ty, func.cf,\n-                      func.cs);\n+        ret parse_ty_rust_fn(st, sd, ast::proto_block);\n       }\n       'N' {\n         let func = parse_ty_fn(st, sd);"}, {"sha": "18ab46d7ef310d3f2dc66aef4450383c40cfc0fd", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "patch": "@@ -193,6 +193,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n }\n fn enc_proto(w: io::writer, proto: proto) {\n     alt proto {\n+      proto_send. { w.write_char('s'); }\n       proto_shared(_) { w.write_char('F'); }\n       proto_block. { w.write_char('B'); }\n       proto_bare. { w.write_char('f'); }"}, {"sha": "8055f49f5d873c0d4c1b95a95d05bcf37d7decd2", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "patch": "@@ -34,9 +34,7 @@ fn collect_freevars(def_map: resolve::def_map, walker: fn@(visit::vt<int>)) ->\n         lambda (expr: @ast::expr, &&depth: int, v: visit::vt<int>) {\n             alt expr.node {\n               ast::expr_fn(f, captures) {\n-                if f.proto == ast::proto_block ||\n-                    f.proto == ast::proto_shared(ast::sugar_normal) ||\n-                    f.proto == ast::proto_shared(ast::sugar_sexy) {\n+                if f.proto != ast::proto_bare {\n                     visit::visit_expr(expr, depth + 1, v);\n                 }\n               }"}, {"sha": "8e577484303b6c13a3e8eb7bd7f80d3e621e458a", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "patch": "@@ -48,6 +48,17 @@ fn check_crate(tcx: ty::ctxt, last_uses: last_use::last_uses,\n }\n \n fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n+\n+    fn check_free_vars(e: @expr,\n+                       cx: ctx,\n+                       check_fn: fn(ctx, ty::t, sp: span)) {\n+        for free in *freevars::get_freevars(cx.tcx, e.id) {\n+            let id = ast_util::def_id_of_def(free).node;\n+            let ty = ty::node_id_to_type(cx.tcx, id);\n+            check_fn(cx, ty, e.span);\n+        }\n+    }\n+\n     alt e.node {\n       expr_assign(_, ex) | expr_assign_op(_, _, ex) |\n       expr_block({node: {expr: some(ex), _}, _}) |\n@@ -65,7 +76,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n             let ty_fields = alt ty::struct(cx.tcx, t) { ty::ty_rec(f) { f } };\n             for tf in ty_fields {\n                 if !vec::any({|f| f.node.ident == tf.ident}, fields) &&\n-                   ty::type_kind(cx.tcx, tf.mt.ty) == kind_noncopyable {\n+                    !kind_can_be_copied(ty::type_kind(cx.tcx, tf.mt.ty)) {\n                     cx.tcx.sess.span_err(ex.span,\n                                          \"copying a noncopyable value\");\n                 }\n@@ -107,19 +118,11 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n           none. {}\n         }\n       }\n-      expr_fn({proto: proto_send, _}, captures) {\n-        for free in *freevars::get_freevars(cx.tcx, e.id) {\n-            let id = ast_util::def_id_of_def(free).node;\n-            let ty = ty::node_id_to_type(cx.tcx, id);\n-            check_copy(cx, ty, e.span);\n-        }\n+      expr_fn({proto: proto_send., _}, captures) { // NDM captures\n+        check_free_vars(e, cx, check_send);\n       }\n-      expr_fn({proto: proto_shared(_), _}, captures) {\n-        for free in *freevars::get_freevars(cx.tcx, e.id) {\n-            let id = ast_util::def_id_of_def(free).node;\n-            let ty = ty::node_id_to_type(cx.tcx, id);\n-            check_copy(cx, ty, e.span);\n-        }\n+      expr_fn({proto: proto_shared(_), _}, captures) { // NDM captures\n+        check_free_vars(e, cx, check_copy);\n       }\n       expr_ternary(_, a, b) { maybe_copy(cx, a); maybe_copy(cx, b); }\n       _ { }\n@@ -159,11 +162,17 @@ fn check_copy_ex(cx: ctx, ex: @expr, _warn: bool) {\n }\n \n fn check_copy(cx: ctx, ty: ty::t, sp: span) {\n-    if ty::type_kind(cx.tcx, ty) == kind_noncopyable {\n+    if !kind_can_be_copied(ty::type_kind(cx.tcx, ty)) {\n         cx.tcx.sess.span_err(sp, \"copying a noncopyable value\");\n     }\n }\n \n+fn check_send(cx: ctx, ty: ty::t, sp: span) {\n+    if !kind_can_be_sent(ty::type_kind(cx.tcx, ty)) {\n+        cx.tcx.sess.span_err(sp, \"not a sendable value\");\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "c9f27e3681043f51aa3eaf159a521b86f3576ff7", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "patch": "@@ -49,8 +49,9 @@ fn comma_str(args: [@constr_arg_use]) -> str {\n \n fn constraint_to_str(tcx: ty::ctxt, c: sp_constr) -> str {\n     alt c.node {\n-      ninit(_, i) {\n-        ret \"init(\" + i + \" [\" + tcx.sess.span_str(c.span) + \"])\";\n+      ninit(id, i) {\n+        ret #fmt(\"init(%s id=%d [%s])\",\n+                 i, id, tcx.sess.span_str(c.span));\n       }\n       npred(p, _, args) {\n         ret path_to_str(p) + \"(\" + comma_str(args) + \")\" + \"[\" +"}, {"sha": "ce759abf74d7c15cc07eecf38278741f9e0f4e01", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "patch": "@@ -278,6 +278,7 @@ fn handle_var(fcx: fn_ctxt, rslt: pre_and_post, id: node_id, name: ident) {\n }\n \n fn handle_var_def(fcx: fn_ctxt, rslt: pre_and_post, def: def, name: ident) {\n+    log (\"handle_var_def: \", def, name);\n     alt def {\n       def_local(d_id, _) | def_arg(d_id, _) {\n         use_var(fcx, d_id.node);\n@@ -345,6 +346,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         let rslt = expr_pp(fcx.ccx, e);\n         clear_pp(rslt);\n         for def in *freevars::get_freevars(fcx.ccx.tcx, e.id) {\n+            log (\"handle_var_def: def=\", def);\n             handle_var_def(fcx, rslt, def, \"upvar\");\n         }\n       }"}, {"sha": "d35d2038190fdac968243ea3e32df361c576b8dc", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "patch": "@@ -1971,29 +1971,23 @@ mod unify {\n     }\n     fn unify_fn_proto(e_proto: ast::proto, a_proto: ast::proto,\n                       variance: variance) -> option::t<result> {\n+        fn rank(proto: ast::proto) -> int {\n+            ret alt proto {\n+              ast::proto_block. { 0 }\n+              ast::proto_shared(_) { 1 }\n+              ast::proto_send. { 2 }\n+              ast::proto_bare. { 3 }\n+            };\n+        }\n+\n         fn gt(e_proto: ast::proto, a_proto: ast::proto) -> bool {\n-            alt e_proto {\n-              ast::proto_block. {\n-                // Every function type is a subtype of block\n-                false\n-              }\n-              ast::proto_shared(_) {\n-                a_proto == ast::proto_block\n-              }\n-              ast::proto_bare. {\n-                a_proto != ast::proto_bare\n-              }\n-            }\n+            ret rank(e_proto) > rank(a_proto);\n         }\n \n         ret if e_proto == a_proto {\n             none\n         } else if variance == invariant {\n-            if e_proto != a_proto {\n-                some(ures_err(terr_mismatch))\n-            } else {\n-                fail\n-            }\n+            some(ures_err(terr_mismatch))\n         } else if variance == covariant {\n             if gt(e_proto, a_proto) {\n                 some(ures_err(terr_mismatch))"}, {"sha": "0034eede2f2acc6bf57d78b00fc6c7a4044770a1", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "patch": "@@ -106,6 +106,25 @@ tag mutability { mut; imm; maybe_mut; }\n \n tag kind { kind_sendable; kind_copyable; kind_noncopyable; }\n \n+// Using these query functons is preferable to direct comparison or matching\n+// against the kind constants, as we may modify the kind hierarchy in the\n+// future.\n+pure fn kind_can_be_copied(k: kind) -> bool {\n+    ret alt k {\n+      kind_sendable. { true }\n+      kind_copyable. { true }\n+      kind_noncopyable. { false }\n+    };\n+}\n+\n+pure fn kind_can_be_sent(k: kind) -> bool {\n+    ret alt k {\n+      kind_sendable. { true }\n+      kind_copyable. { false }\n+      kind_noncopyable. { false }\n+    };\n+}\n+\n tag proto_sugar {\n     sugar_normal;\n     sugar_sexy;"}, {"sha": "c8b94616ab9e3b669cea3aca4b1be3637926f2d0", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "patch": "@@ -16,6 +16,7 @@ tag file_type { CRATE_FILE; SOURCE_FILE; }\n \n tag fn_kw {\n     fn_kw_fn;\n+    fn_kw_fn_at;\n     fn_kw_lambda;\n     fn_kw_block;\n }\n@@ -542,10 +543,9 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n     } else if eat_word(p, \"block\") {\n         t = parse_ty_fn(ast::proto_block, p);\n     } else if eat_word(p, \"lambda\") {\n-        if p.peek() == token::LBRACE { // lambda[send](...)\n-            expect(p, token::LBRACE);\n+        if eat(p, token::LBRACKET) { // lambda[send](...)\n             expect_word(p, \"send\");\n-            expect(p, token::RBRACE);\n+            expect(p, token::RBRACKET);\n             t = parse_ty_fn(ast::proto_send, p);\n         } else { // lambda(...)\n             t = parse_ty_fn(ast::proto_shared(ast::sugar_sexy), p);\n@@ -843,8 +843,8 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n                 ret parse_spawn_expr(p);\n         */\n     } else if eat_word(p, \"fn\") {\n-        let proto = parse_fn_anon_proto(p);\n-        ret parse_fn_expr(p, fn_kw_fn);\n+        let kw = parse_fn_anon_kw(p);\n+        ret parse_fn_expr(p, kw);\n     } else if eat_word(p, \"block\") {\n         ret parse_fn_expr(p, fn_kw_block);\n     } else if eat_word(p, \"lambda\") {\n@@ -1295,7 +1295,7 @@ fn parse_if_expr(p: parser) -> @ast::expr {\n fn parse_capture_clause(p: parser) -> @ast::capture {\n     fn expect_opt_trailing_semi(p: parser) {\n         if !eat(p, token::SEMI) {\n-            if p.peek() != token::RBRACE {\n+            if p.peek() != token::RBRACKET {\n                 p.fatal(\"expecting ; or ]\");\n             }\n         }\n@@ -1306,7 +1306,9 @@ fn parse_capture_clause(p: parser) -> @ast::capture {\n         while true {\n             alt p.peek() {\n               token::IDENT(_, _) {\n-                let i = spanned(p.get_lo_pos(), p.get_hi_pos(), parse_ident(p));\n+                let i = spanned(p.get_lo_pos(),\n+                                p.get_hi_pos(),\n+                                parse_ident(p));\n                 res += [i];\n                 if !eat(p, token::COMMA) {\n                     ret res;\n@@ -1316,15 +1318,16 @@ fn parse_capture_clause(p: parser) -> @ast::capture {\n               _ { ret res; }\n             }\n         }\n+        std::util::unreachable();\n     }\n \n     let is_send = false;\n     let copies = [];\n     let moves = [];\n \n     let lo = p.get_lo_pos();\n-    if eat(p, token::LBRACE) {\n-        while !eat(p, token::RBRACE) {\n+    if eat(p, token::LBRACKET) {\n+        while !eat(p, token::RBRACKET) {\n             if eat_word(p, \"send\") {\n                 is_send = true;\n                 expect_opt_trailing_semi(p);\n@@ -1352,10 +1355,13 @@ fn parse_fn_expr(p: parser, kw: fn_kw) -> @ast::expr {\n     let body = parse_block(p);\n     let proto = alt (kw, captures.node.is_send) {\n       (fn_kw_fn., true) { ast::proto_bare }\n+      (fn_kw_fn_at., true) { ast::proto_send }\n       (fn_kw_lambda., true) { ast::proto_send }\n+      (fn_kw_block., true) { p.fatal(\"block cannot be declared sendable\"); }\n+      (fn_kw_fn., false) { ast::proto_bare }\n+      (fn_kw_fn_at., false) { ast::proto_shared(ast::sugar_normal) }\n       (fn_kw_lambda., false) { ast::proto_shared(ast::sugar_sexy) }\n       (fn_kw_block., false) { ast::proto_block }\n-      (_, true) { p.fatal(\"only lambda can be declared sendable\"); }\n     };\n     let _fn = {decl: decl, proto: proto, body: body};\n     ret mk_expr(p, lo, body.span.hi, ast::expr_fn(_fn, captures));\n@@ -2151,12 +2157,12 @@ fn parse_fn_ty_proto(p: parser) -> ast::proto {\n     }\n }\n \n-fn parse_fn_anon_proto(p: parser) -> ast::proto {\n+fn parse_fn_anon_kw(p: parser) -> fn_kw {\n     if p.peek() == token::AT {\n         p.bump();\n-        ast::proto_shared(ast::sugar_normal)\n+        fn_kw_fn_at\n     } else {\n-        ast::proto_bare\n+        fn_kw_fn\n     }\n }\n "}, {"sha": "5899cf95d7ea7e52fcaf6bf573e56a002fda8abf", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1cd61c84199c8a1e44645e4af3f8c15c6dd018/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=aa1cd61c84199c8a1e44645e4af3f8c15c6dd018", "patch": "@@ -1600,6 +1600,7 @@ fn proto_to_str(p: ast::proto) -> str {\n     ret alt p {\n           ast::proto_bare. { \"fn\" }\n           ast::proto_block. { \"block\" }\n+          ast::proto_send. { \"lambda[send]\" }\n           ast::proto_shared(ast::sugar_normal.) { \"fn@\" }\n           ast::proto_shared(ast::sugar_sexy.) { \"lambda\" }\n         };"}]}