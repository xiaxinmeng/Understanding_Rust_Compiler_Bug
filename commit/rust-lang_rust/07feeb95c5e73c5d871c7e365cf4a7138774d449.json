{"sha": "07feeb95c5e73c5d871c7e365cf4a7138774d449", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZmVlYjk1YzVlNzNjNWQ4NzFjN2UzNjVjZjRhNzEzODc3NGQ0NDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-01T04:14:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-01T04:14:13Z"}, "message": "auto merge of #7487 : huonw/rust/vec-kill, r=cmr\n\nContinuation of #7430.\r\n\r\nI haven't removed the `map` method, since the replacement `v.iter().transform(f).collect::<~[SomeType]>()` is a little ridiculous at the moment.", "tree": {"sha": "8b7f2a06b1a86a57dc3bc00bb53da5e96b1a243b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b7f2a06b1a86a57dc3bc00bb53da5e96b1a243b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07feeb95c5e73c5d871c7e365cf4a7138774d449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07feeb95c5e73c5d871c7e365cf4a7138774d449", "html_url": "https://github.com/rust-lang/rust/commit/07feeb95c5e73c5d871c7e365cf4a7138774d449", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07feeb95c5e73c5d871c7e365cf4a7138774d449/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5c5ce3f8d07ba7f9059727a790ce19f7a1599b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c5ce3f8d07ba7f9059727a790ce19f7a1599b7", "html_url": "https://github.com/rust-lang/rust/commit/d5c5ce3f8d07ba7f9059727a790ce19f7a1599b7"}, {"sha": "c0a20d2929a7c0d6af0de899198df4f26453d877", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a20d2929a7c0d6af0de899198df4f26453d877", "html_url": "https://github.com/rust-lang/rust/commit/c0a20d2929a7c0d6af0de899198df4f26453d877"}], "stats": {"total": 1417, "additions": 518, "deletions": 899}, "files": [{"sha": "715f6d91e09dd7e36cf58970729757c2cb0fffa2", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -345,9 +345,9 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         fatal(~\"process did not return an error status\");\n     }\n \n-    let prefixes = vec::map(expected_errors, |ee| {\n+    let prefixes = expected_errors.iter().transform(|ee| {\n         fmt!(\"%s:%u:\", testfile.to_str(), ee.line)\n-    });\n+    }).collect::<~[~str]>();\n \n     // Scan and extract our error/warning messages,\n     // which look like:"}, {"sha": "2a252f3f1f39486ce8c48d3a72ab06799ea029e1", "filename": "src/etc/unicode.py", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -122,14 +122,14 @@ def ch_prefix(ix):\n \n def emit_bsearch_range_table(f):\n     f.write(\"\"\"\n-    pure fn bsearch_range_table(c: char, r: &[(char,char)]) -> bool {\n-        use cmp::{EQ, LT, GT};\n-        use vec::bsearch;\n+    fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n+        use cmp::{Equal, Less, Greater};\n+        use vec::ImmutableVector;\n         use option::None;\n-        (do bsearch(r) |&(lo,hi)| {\n-            if lo <= c && c <= hi { EQ }\n-            else if hi < c { LT }\n-            else { GT }\n+        (do r.bsearch |&(lo,hi)| {\n+            if lo <= c && c <= hi { Equal }\n+            else if hi < c { Less }\n+            else { Greater }\n         }) != None\n     }\\n\\n\n \"\"\");\n@@ -140,15 +140,15 @@ def emit_property_module(f, mod, tbl):\n     keys.sort()\n     emit_bsearch_range_table(f);\n     for cat in keys:\n-        f.write(\"    const %s_table : &[(char,char)] = &[\\n\" % cat)\n+        f.write(\"    static %s_table : &'static [(char,char)] = &[\\n\" % cat)\n         ix = 0\n         for pair in tbl[cat]:\n             f.write(ch_prefix(ix))\n             f.write(\"(%s, %s)\" % (escape_char(pair[0]), escape_char(pair[1])))\n             ix += 1\n         f.write(\"\\n    ];\\n\\n\")\n \n-        f.write(\"    pub pure fn %s(c: char) -> bool {\\n\" % cat)\n+        f.write(\"    pub fn %s(c: char) -> bool {\\n\" % cat)\n         f.write(\"        bsearch_range_table(c, %s_table)\\n\" % cat)\n         f.write(\"    }\\n\\n\")\n     f.write(\"}\\n\")\n@@ -159,7 +159,7 @@ def emit_property_module_old(f, mod, tbl):\n     keys = tbl.keys()\n     keys.sort()\n     for cat in keys:\n-        f.write(\"    pure fn %s(c: char) -> bool {\\n\" % cat)\n+        f.write(\"    fn %s(c: char) -> bool {\\n\" % cat)\n         f.write(\"        ret alt c {\\n\")\n         prefix = ' '\n         for pair in tbl[cat]:\n@@ -236,8 +236,22 @@ def emit_decomp_module(f, canon, compat):\n \n (canon_decomp, compat_decomp, gencats) = load_unicode_data(\"UnicodeData.txt\")\n \n-# Explain that the source code was generated by this script.\n-rf.write('// The following code was generated by \"src/etc/unicode.py\"\\n\\n')\n+# Preamble\n+rf.write('''// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The following code was generated by \"src/etc/unicode.py\"\n+\n+#[allow(missing_doc)];\n+\n+''')\n \n emit_property_module(rf, \"general_category\", gencats)\n "}, {"sha": "f91260f475288539af5a7a6395bbe697ab3ac64a", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -100,7 +100,6 @@ total line count).\n use std::io::ReaderUtil;\n use std::io;\n use std::os;\n-use std::vec;\n \n /**\n A summary of the internal state of a `FileInput` object. `line_num`\n@@ -353,13 +352,13 @@ a literal `-`.\n */\n // XXX: stupid, unclear name\n pub fn pathify(vec: &[~str], stdin_hyphen : bool) -> ~[Option<Path>] {\n-    vec::map(vec, |&str : & ~str| {\n-        if stdin_hyphen && str == ~\"-\" {\n+    vec.iter().transform(|str| {\n+        if stdin_hyphen && \"-\" == *str {\n             None\n         } else {\n-            Some(Path(str))\n+            Some(Path(*str))\n         }\n-    })\n+    }).collect()\n }\n \n /**"}, {"sha": "1a494f36c646960789294fa80b2594a7f995a35e", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -592,9 +592,9 @@ pub mod groups {\n      */\n     pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n \n-        let desc_sep = ~\"\\n\" + \" \".repeat(24);\n+        let desc_sep = \"\\n\" + \" \".repeat(24);\n \n-        let rows = vec::map(opts, |optref| {\n+        let mut rows = opts.iter().transform(|optref| {\n             let OptGroup{short_name: short_name,\n                          long_name: long_name,\n                          hint: hint,\n@@ -669,7 +669,7 @@ pub mod groups {\n \n         return str::to_owned(brief) +\n                \"\\n\\nOptions:\\n\" +\n-               rows.connect(\"\\n\") +\n+               rows.collect::<~[~str]>().connect(\"\\n\") +\n                \"\\n\\n\";\n     }\n } // end groups module"}, {"sha": "9422ad0c9f2e0043b37f70f1223617f7c4df8a5a", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -283,13 +283,13 @@ impl Mul<BigUint, BigUint> for BigUint {\n             if n == 1 { return copy *a; }\n \n             let mut carry = 0;\n-            let prod = do vec::map(a.data) |ai| {\n+            let prod = do a.data.iter().transform |ai| {\n                 let (hi, lo) = BigDigit::from_uint(\n                     (*ai as uint) * (n as uint) + (carry as uint)\n                 );\n                 carry = hi;\n                 lo\n-            };\n+            }.collect::<~[BigDigit]>();\n             if carry == 0 { return BigUint::new(prod) };\n             return BigUint::new(prod + [carry]);\n         }\n@@ -618,13 +618,13 @@ impl BigUint {\n         if n_bits == 0 || self.is_zero() { return copy *self; }\n \n         let mut carry = 0;\n-        let shifted = do vec::map(self.data) |elem| {\n+        let shifted = do self.data.iter().transform |elem| {\n             let (hi, lo) = BigDigit::from_uint(\n                 (*elem as uint) << n_bits | (carry as uint)\n             );\n             carry = hi;\n             lo\n-        };\n+        }.collect::<~[BigDigit]>();\n         if carry == 0 { return BigUint::new(shifted); }\n         return BigUint::new(shifted + [carry]);\n     }\n@@ -1172,7 +1172,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_cmp() {\n-        let data = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n+        let data: ~[BigUint] = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n             .map(|v| BigUint::from_slice(*v));\n         for data.iter().enumerate().advance |(i, ni)| {\n             for data.slice(i, data.len()).iter().enumerate().advance |(j0, nj)| {"}, {"sha": "2878a3ee12215c48f718cda16db559a98d4bfe23", "filename": "src/libextra/par.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -92,7 +92,7 @@ pub fn map<A:Copy + Send,B:Copy + Send>(\n     vec::concat(map_slices(xs, || {\n         let f = fn_factory();\n         let result: ~fn(uint, &[A]) -> ~[B] =\n-            |_, slice| vec::map(slice, |x| f(x));\n+            |_, slice| slice.iter().transform(|x| f(x)).collect();\n         result\n     }))\n }\n@@ -104,9 +104,9 @@ pub fn mapi<A:Copy + Send,B:Copy + Send>(\n     let slices = map_slices(xs, || {\n         let f = fn_factory();\n         let result: ~fn(uint, &[A]) -> ~[B] = |base, slice| {\n-            vec::mapi(slice, |i, x| {\n+            slice.iter().enumerate().transform(|(i, x)| {\n                 f(i + base, x)\n-            })\n+            }).collect()\n         };\n         result\n     });"}, {"sha": "3d1ca4a9818b61572568b195464f9b104cec37e9", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -107,7 +107,7 @@ impl<T:Ord> PriorityQueue<T> {\n         let mut end = q.len();\n         while end > 1 {\n             end -= 1;\n-            vec::swap(q.data, 0, end);\n+            q.data.swap(0, end);\n             q.siftdown_range(0, end)\n         }\n         q.to_vec()"}, {"sha": "6c9453a5a3ba1140067c1286bc46c39ddfd342ae", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -78,12 +78,12 @@ impl ToStr for Version {\n         let s = if self.pre.is_empty() {\n             s\n         } else {\n-            s + \"-\" + self.pre.map(|i| i.to_str()).connect(\".\")\n+            fmt!(\"%s-%s\", s, self.pre.map(|i| i.to_str()).connect(\".\"))\n         };\n         if self.build.is_empty() {\n             s\n         } else {\n-            s + \"+\" + self.build.map(|i| i.to_str()).connect(\".\")\n+            fmt!(\"%s+%s\", s, self.build.map(|i| i.to_str()).connect(\".\"))\n         }\n     }\n }"}, {"sha": "9cfe7cf5e4a1b302a09cf529ee5ba849dada74b4", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -20,7 +20,6 @@ use std::cmp;\n use std::container::{Container, Mutable, Map, Set};\n use std::uint;\n use std::util::replace;\n-use std::vec;\n \n #[allow(missing_doc)]\n pub struct SmallIntMap<T> {\n@@ -86,7 +85,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         let exists = self.contains_key(&key);\n         let len = self.v.len();\n         if len <= key {\n-            vec::grow_fn(&mut self.v, key - len + 1, |_| None);\n+            self.v.grow_fn(key - len + 1, |_| None);\n         }\n         self.v[key] = Some(value);\n         !exists\n@@ -383,8 +382,6 @@ mod test_set {\n \n     use super::SmallIntSet;\n \n-    use std::vec;\n-\n     #[test]\n     fn test_disjoint() {\n         let mut xs = SmallIntSet::new();\n@@ -456,7 +453,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n         for a.intersection(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -479,7 +476,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [1, 5, 11];\n         for a.difference(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -504,7 +501,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [1, 5, 11, 14, 22];\n         for a.symmetric_difference(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -533,7 +530,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [1, 3, 5, 9, 11, 13, 16, 19, 24];\n         for a.union(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());"}, {"sha": "f59a2414aaeb7b40b33c3545aeea42875992a3c8", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -65,17 +65,17 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n \n fn part<T>(arr: &mut [T], left: uint,\n            right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n-    vec::swap(arr, pivot, right);\n+    arr.swap(pivot, right);\n     let mut storage_index: uint = left;\n     let mut i: uint = left;\n     while i < right {\n         if compare_func(&arr[i], &arr[right]) {\n-            vec::swap(arr, i, storage_index);\n+            arr.swap(i, storage_index);\n             storage_index += 1;\n         }\n         i += 1;\n     }\n-    vec::swap(arr, storage_index, right);\n+    arr.swap(storage_index, right);\n     return storage_index;\n }\n \n@@ -120,29 +120,29 @@ fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n             j -= 1;\n         }\n         if i >= j { break; }\n-        vec::swap(arr, i as uint, j as uint);\n+        arr.swap(i as uint, j as uint);\n         if arr[i] == v {\n             p += 1;\n-            vec::swap(arr, p as uint, i as uint);\n+            arr.swap(p as uint, i as uint);\n         }\n         if v == arr[j] {\n             q -= 1;\n-            vec::swap(arr, j as uint, q as uint);\n+            arr.swap(j as uint, q as uint);\n         }\n     }\n-    vec::swap(arr, i as uint, right as uint);\n+    arr.swap(i as uint, right as uint);\n     j = i - 1;\n     i += 1;\n     let mut k: int = left;\n     while k < p {\n-        vec::swap(arr, k as uint, j as uint);\n+        arr.swap(k as uint, j as uint);\n         k += 1;\n         j -= 1;\n         if k == arr.len() as int { break; }\n     }\n     k = right - 1;\n     while k > q {\n-        vec::swap(arr, i as uint, k as uint);\n+        arr.swap(i as uint, k as uint);\n         k -= 1;\n         i += 1;\n         if k == 0 { break; }\n@@ -259,7 +259,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n     let mut i = start;\n     while i < end / 2 {\n-        vec::swap(v, i, end - i - 1);\n+        v.swap(i, end - i - 1);\n         i += 1;\n     }\n }\n@@ -479,7 +479,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         let mut len1 = len1;\n         let mut len2 = len2;\n \n-        vec::swap(array, dest, c2);\n+        array.swap(dest, c2);\n         dest += 1; c2 += 1; len2 -= 1;\n \n         if len2 == 0 {\n@@ -501,7 +501,7 @@ impl<T:Copy + Ord> MergeState<T> {\n             loop {\n                 assert!(len1 > 1 && len2 != 0);\n                 if array[c2] < tmp[c1] {\n-                    vec::swap(array, dest, c2);\n+                    array.swap(dest, c2);\n                     dest += 1; c2 += 1; len2 -= 1;\n                     count2 += 1; count1 = 0;\n                     if len2 == 0 {\n@@ -534,7 +534,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                     dest += count1; c1 += count1; len1 -= count1;\n                     if len1 <= 1 { break_outer = true; break; }\n                 }\n-                vec::swap(array, dest, c2);\n+                array.swap(dest, c2);\n                 dest += 1; c2 += 1; len2 -= 1;\n                 if len2 == 0 { break_outer = true; break; }\n \n@@ -589,7 +589,7 @@ impl<T:Copy + Ord> MergeState<T> {\n         let mut len1 = len1;\n         let mut len2 = len2;\n \n-        vec::swap(array, dest, c1);\n+        array.swap(dest, c1);\n         dest -= 1; c1 -= 1; len1 -= 1;\n \n         if len1 == 0 {\n@@ -613,7 +613,7 @@ impl<T:Copy + Ord> MergeState<T> {\n             loop {\n                 assert!(len1 != 0 && len2 > 1);\n                 if tmp[c2] < array[c1] {\n-                    vec::swap(array, dest, c1);\n+                    array.swap(dest, c1);\n                     dest -= 1; c1 -= 1; len1 -= 1;\n                     count1 += 1; count2 = 0;\n                     if len1 == 0 {\n@@ -666,7 +666,7 @@ impl<T:Copy + Ord> MergeState<T> {\n                     copy_vec(array, dest+1, tmp.slice(c2+1, c2+1+count2));\n                     if len2 <= 1 { break_outer = true; break; }\n                 }\n-                vec::swap(array, dest, c1);\n+                array.swap(dest, c1);\n                 dest -= 1; c1 -= 1; len1 -= 1;\n                 if len1 == 0 { break_outer = true; break; }\n                 min_gallop -= 1;\n@@ -1049,7 +1049,7 @@ mod big_tests {\n     fn makeRange(n: uint) -> ~[uint] {\n         let one = do vec::from_fn(n) |i| { i };\n         let mut two = copy one;\n-        vec::reverse(two);\n+        two.reverse();\n         vec::append(two, one)\n     }\n \n@@ -1073,7 +1073,7 @@ mod big_tests {\n             tim_sort(arr); // *sort\n             isSorted(arr);\n \n-            vec::reverse(arr);\n+            arr.reverse();\n             tim_sort(arr); // \\sort\n             isSorted(arr);\n \n@@ -1083,7 +1083,7 @@ mod big_tests {\n             for 3.times {\n                 let i1 = rng.gen_uint_range(0, n);\n                 let i2 = rng.gen_uint_range(0, n);\n-                vec::swap(arr, i1, i2);\n+                arr.swap(i1, i2);\n             }\n             tim_sort(arr); // 3sort\n             isSorted(arr);\n@@ -1145,7 +1145,7 @@ mod big_tests {\n             tim_sort(arr); // *sort\n             isSorted(arr);\n \n-            vec::reverse(arr);\n+            arr.reverse();\n             tim_sort(arr); // \\sort\n             isSorted(arr);\n \n@@ -1155,7 +1155,7 @@ mod big_tests {\n             for 3.times {\n                 let i1 = rng.gen_uint_range(0, n);\n                 let i2 = rng.gen_uint_range(0, n);\n-                vec::swap(arr, i1, i2);\n+                arr.swap(i1, i2);\n             }\n             tim_sort(arr); // 3sort\n             isSorted(arr);"}, {"sha": "063d26d1424b758b75f8eed61cd53626a67fcbb7", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -291,12 +291,13 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n \n \n             // Find the offset of the NUL we want to go to\n-            let nulpos = vec::position_between(string_table, offset as uint,\n-                                               string_table_bytes as uint, |&b| b == 0);\n+            let nulpos = string_table.slice(offset as uint, string_table_bytes as uint)\n+                .iter().position_(|&b| b == 0);\n             match nulpos {\n-                Some(x) => {\n+                Some(len) => {\n                     string_map.insert(name.to_owned(),\n-                                      string_table.slice(offset as uint, x).to_owned())\n+                                      string_table.slice(offset as uint,\n+                                                         offset as uint + len).to_owned())\n                 },\n                 None => {\n                     return Err(~\"invalid file: missing NUL in string_table\");"}, {"sha": "1e1e53de9e896002176d1c0fe7cf8f76dbfa9586", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -449,7 +449,7 @@ fn run_tests(opts: &TestOpts,\n     debug!(\"using %u test tasks\", concurrency);\n \n     let mut remaining = filtered_tests;\n-    vec::reverse(remaining);\n+    remaining.reverse();\n     let mut pending = 0;\n \n     let (p, ch) = stream();"}, {"sha": "19dbb941e556669f76022b301922fadef4d143a0", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -52,7 +52,7 @@ fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n }\n \n pub fn rpaths_to_flags(rpaths: &[Path]) -> ~[~str] {\n-    vec::map(rpaths, |rpath| fmt!(\"-Wl,-rpath,%s\",rpath.to_str()))\n+    rpaths.iter().transform(|rpath| fmt!(\"-Wl,-rpath,%s\",rpath.to_str())).collect()\n }\n \n fn get_rpaths(os: session::os,\n@@ -103,9 +103,7 @@ fn get_rpaths(os: session::os,\n fn get_rpaths_relative_to_output(os: session::os,\n                                  output: &Path,\n                                  libs: &[Path]) -> ~[Path] {\n-    vec::map(libs, |a| {\n-        get_rpath_relative_to_output(os, output, a)\n-    })\n+    libs.iter().transform(|a| get_rpath_relative_to_output(os, output, a)).collect()\n }\n \n pub fn get_rpath_relative_to_output(os: session::os,\n@@ -163,7 +161,7 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n }\n \n fn get_absolute_rpaths(libs: &[Path]) -> ~[Path] {\n-    vec::map(libs, |a| get_absolute_rpath(a) )\n+    libs.iter().transform(|a| get_absolute_rpath(a)).collect()\n }\n \n pub fn get_absolute_rpath(lib: &Path) -> Path {"}, {"sha": "b1d4820f062eb797bd57d4d21c52460f0424c0bd", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -90,7 +90,7 @@ fn fold_foreign_mod(\n     ast::foreign_mod {\n         sort: nm.sort,\n         abis: nm.abis,\n-        view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(*x)),\n+        view_items: filtered_view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n         items: filtered_items\n     }\n }"}, {"sha": "41c70c4c5b417a4f636eaee58c68e48781f9658d", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -117,7 +117,7 @@ fn fold_mod(cx: @mut TestCtxt,\n \n     let mod_nomain = ast::_mod {\n         view_items: /*bad*/copy m.view_items,\n-        items: vec::map(m.items, |i| nomain(cx, *i)),\n+        items: m.items.iter().transform(|i| nomain(cx, *i)).collect(),\n     };\n \n     fold::noop_fold_mod(&mod_nomain, fld)"}, {"sha": "3413cd341ba42f6eb94bd534a82191df62d5c056", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -17,7 +17,6 @@ use metadata::cstore;\n use metadata::decoder;\n \n use std::hashmap::HashMap;\n-use std::vec;\n use extra;\n use syntax::ast;\n use syntax::parse::token::ident_interner;\n@@ -91,7 +90,7 @@ pub fn iter_crate_data(cstore: &CStore,\n }\n \n pub fn add_used_crate_file(cstore: &mut CStore, lib: &Path) {\n-    if !vec::contains(cstore.used_crate_files, lib) {\n+    if !cstore.used_crate_files.contains(lib) {\n         cstore.used_crate_files.push(copy *lib);\n     }\n }"}, {"sha": "77a8d1792dbc8f667ba7e8fa97c95092bbc492a4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -1441,8 +1441,7 @@ fn encode_crate_deps(ecx: &EncodeContext,\n             expected_cnum += 1;\n         }\n \n-        // mut -> immutable hack for vec::map\n-        deps.slice(0, deps.len()).to_owned()\n+        deps\n     }\n \n     // We're just going to write a list of crate 'name-hash-version's, with"}, {"sha": "72896258b2d326052e20bfc8e56369fc652b5bc7", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -363,7 +363,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n         for m.iter().advance |r| {\n             let r = pat_ctor_id(cx, r[0]);\n             for r.iter().advance |id| {\n-                if !vec::contains(found, id) {\n+                if !found.contains(id) {\n                     found.push(/*bad*/copy *id);\n                 }\n             }\n@@ -417,7 +417,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n                 }\n             }\n         );\n-        vec::dedup(&mut sorted_vec_lens);\n+        sorted_vec_lens.dedup();\n \n         let mut found_slice = false;\n         let mut next = 0;\n@@ -642,13 +642,13 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                                          ty_to_str(cx.tcx, left_ty)));\n                             }\n                         }\n-                        let args = vec::map(class_fields, |class_field| {\n+                        let args = class_fields.iter().transform(|class_field| {\n                             match flds.iter().find_(|f|\n                                             f.ident == class_field.ident) {\n                                 Some(f) => f.pat,\n                                 _ => wild()\n                             }\n-                        });\n+                        }).collect();\n                         Some(vec::append(args, vec::to_owned(r.tail())))\n                     }\n                 }"}, {"sha": "bf91b6771dcd8110cf452d4704d35cdee20dbdd5", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -19,7 +19,6 @@ use syntax::ast::*;\n \n use std::float;\n use std::hashmap::{HashMap, HashSet};\n-use std::vec;\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -70,8 +69,8 @@ pub fn join(a: constness, b: constness) -> constness {\n     }\n }\n \n-pub fn join_all(cs: &[constness]) -> constness {\n-    cs.iter().fold(integral_const, |a, b| join(a, *b))\n+pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n+    cs.fold(integral_const, |a, b| join(a, b))\n }\n \n pub fn classify(e: &expr,\n@@ -104,7 +103,7 @@ pub fn classify(e: &expr,\n \n               ast::expr_tup(ref es) |\n               ast::expr_vec(ref es, ast::m_imm) => {\n-                join_all(vec::map(*es, |e| classify(*e, tcx)))\n+                join_all(es.iter().transform(|e| classify(*e, tcx)))\n               }\n \n               ast::expr_vstore(e, vstore) => {\n@@ -118,7 +117,7 @@ pub fn classify(e: &expr,\n               }\n \n               ast::expr_struct(_, ref fs, None) => {\n-                let cs = do vec::map((*fs)) |f| {\n+                let cs = do fs.iter().transform |f| {\n                     classify(f.node.expr, tcx)\n                 };\n                 join_all(cs)"}, {"sha": "ce09f790ef45f4c2b626666328c18cb717f4c0b9", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -740,11 +740,10 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n     }\n \n     fn check_foreign_fn(cx: &Context, decl: &ast::fn_decl) {\n-        let tys = vec::map(decl.inputs, |a| a.ty );\n-        let r = vec::append_one(tys, decl.output);\n-        for r.iter().advance |ty| {\n-            check_ty(cx, *ty);\n+        for decl.inputs.iter().advance |in| {\n+            check_ty(cx, in.ty);\n         }\n+        check_ty(cx, decl.output)\n     }\n \n     match it.node {"}, {"sha": "ab813c0ffc546cf410829db6defc079f8e7bd2b4", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -519,10 +519,10 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: int,\n                 C_struct(build_const_struct(ccx, nonnull, vals))\n             } else {\n                 assert_eq!(vals.len(), 0);\n-                let vals = do nonnull.fields.mapi |i, &ty| {\n+                let vals = do nonnull.fields.iter().enumerate().transform |(i, &ty)| {\n                     let llty = type_of::sizing_type_of(ccx, ty);\n                     if i == ptrfield { C_null(llty) } else { C_undef(llty) }\n-                };\n+                }.collect::<~[ValueRef]>();\n                 C_struct(build_const_struct(ccx, nonnull, vals))\n             }\n         }"}, {"sha": "bba2b206b31ed2bc4808593767657fecbba86512", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -1266,7 +1266,7 @@ pub fn cleanup_and_leave(bcx: block,\n                     let mut skip = 0;\n                     let mut dest = None;\n                     {\n-                        let r = vec::rfind((*inf).cleanup_paths, |cp| cp.target == leave);\n+                        let r = (*inf).cleanup_paths.rev_iter().find_(|cp| cp.target == leave);\n                         for r.iter().advance |cp| {\n                             if cp.size == inf.cleanups.len() {\n                                 Br(bcx, cp.dest);"}, {"sha": "8535c84c5cb5e30d4e839dab3bc4216b860671dd", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -615,12 +615,12 @@ pub fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     // we care about.\n     if ixs.len() < 16 {\n         let mut small_vec = [ C_i32(0), ..16 ];\n-        for ixs.iter().enumerate().advance |(i, &ix)| {\n-            small_vec[i] = C_i32(ix as i32)\n+        for small_vec.mut_iter().zip(ixs.iter()).advance |(small_vec_e, &ix)| {\n+            *small_vec_e = C_i32(ix as i32);\n         }\n         InBoundsGEP(cx, base, small_vec.slice(0, ixs.len()))\n     } else {\n-        let v = do vec::map(ixs) |i| { C_i32(*i as i32) };\n+        let v = do ixs.iter().transform |i| { C_i32(*i as i32) }.collect::<~[ValueRef]>();\n         count_insn(cx, \"gepi\");\n         InBoundsGEP(cx, base, v)\n     }"}, {"sha": "d00479194308b5f8475d66f54a1c7d9631a21325", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -17,7 +17,6 @@ use middle::trans::type_::Type;\n \n use std::libc::c_uint;\n use std::option;\n-use std::vec;\n \n pub trait ABIInfo {\n     fn compute_info(&self, atys: &[Type], rty: Type, ret_def: bool) -> FnType;\n@@ -37,7 +36,7 @@ pub struct FnType {\n \n impl FnType {\n     pub fn decl_fn(&self, decl: &fn(fnty: Type) -> ValueRef) -> ValueRef {\n-        let atys = vec::map(self.arg_tys, |t| t.ty);\n+        let atys = self.arg_tys.iter().transform(|t| t.ty).collect::<~[Type]>();\n         let rty = self.ret_ty.ty;\n         let fnty = Type::func(atys, &rty);\n         let llfn = decl(fnty);"}, {"sha": "5b3052a1e1f4c47d632bafe17b72c79136f50dbf", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -981,9 +981,9 @@ pub fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n \n     match bcx.fcx.param_substs {\n       Some(substs) => {\n-        do vec::map(params) |t| {\n+        do params.iter().transform |t| {\n             ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n-        }\n+        }.collect()\n       }\n       _ => params\n     }\n@@ -1007,9 +1007,11 @@ pub fn resolve_vtables_under_param_substs(tcx: ty::ctxt,\n                                           param_substs: Option<@param_substs>,\n                                           vts: typeck::vtable_res)\n     -> typeck::vtable_res {\n-    @vec::map(*vts, |ds|\n-      @vec::map(**ds, |d|\n-                resolve_vtable_under_param_substs(tcx, param_substs, copy *d)))\n+    @vts.iter().transform(|ds|\n+      @ds.iter().transform(\n+          |d| resolve_vtable_under_param_substs(tcx, param_substs, copy *d))\n+                          .collect::<~[typeck::vtable_origin]>())\n+        .collect::<~[typeck::vtable_param_res]>()\n }\n \n \n@@ -1030,9 +1032,9 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n         typeck::vtable_static(trait_id, tys, sub) => {\n             let tys = match param_substs {\n                 Some(substs) => {\n-                    do vec::map(tys) |t| {\n+                    do tys.iter().transform |t| {\n                         ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n-                    }\n+                    }.collect()\n                 }\n                 _ => tys\n             };"}, {"sha": "df197ded629ea6210c62e0dc6637a9a219388d08", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -588,8 +588,9 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         }\n         ast::expr_tup(ref args) => {\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n-            return trans_adt(bcx, repr, 0, args.mapi(|i, arg| (i, *arg)),\n-                             None, dest);\n+            let numbered_fields: ~[(uint, @ast::expr)] =\n+                args.iter().enumerate().transform(|(i, arg)| (i, *arg)).collect();\n+            return trans_adt(bcx, repr, 0, numbered_fields, None, dest);\n         }\n         ast::expr_lit(@codemap::spanned {node: ast::lit_str(s), _}) => {\n             return tvec::trans_lit_str(bcx, expr, s, dest);"}, {"sha": "ad48c30747edcc2dc1b68882817719b3ad74335b", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -30,7 +30,6 @@ use middle::ty::{FnSig};\n use middle::typeck;\n use util::ppaux::{Repr,ty_to_str};\n \n-use std::vec;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_map::path_name;\n@@ -62,12 +61,12 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     assert!(real_substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n     let _icx = push_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n-    let substs = vec::map(real_substs.tps, |t| {\n+    let substs = real_substs.tps.iter().transform(|t| {\n         match normalize_for_monomorphization(ccx.tcx, *t) {\n           Some(t) => { must_cast = true; t }\n           None => *t\n         }\n-    });\n+    }).collect::<~[ty::t]>();\n \n     for real_substs.tps.iter().advance |s| { assert!(!ty::type_has_params(*s)); }\n     for substs.iter().advance |s| { assert!(!ty::type_has_params(*s)); }\n@@ -325,22 +324,22 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n                     vtables: Option<typeck::vtable_res>,\n                     impl_did_opt: Option<ast::def_id>,\n                     param_uses: Option<@~[type_use::type_uses]>) -> mono_id {\n-    let precise_param_ids = match vtables {\n+    // FIXME (possibly #5801): Need a lot of type hints to get\n+    // .collect() to work.\n+    let precise_param_ids: ~[(ty::t, Option<@~[mono_id]>)] = match vtables {\n       Some(vts) => {\n         debug!(\"make_mono_id vtables=%s substs=%s\",\n                vts.repr(ccx.tcx), substs.repr(ccx.tcx));\n-        vec::map_zip(*vts, substs, |vtable, subst| {\n+        vts.iter().zip(substs.iter()).transform(|(vtable, subst)| {\n             let v = vtable.map(|vt| meth::vtable_id(ccx, vt));\n             (*subst, if !v.is_empty() { Some(@v) } else { None })\n-        })\n-      }\n-      None => {\n-        vec::map(substs, |subst| (*subst, None))\n+        }).collect()\n       }\n+      None => substs.iter().transform(|subst| (*subst, None::<@~[mono_id]>)).collect()\n     };\n     let param_ids = match param_uses {\n       Some(ref uses) => {\n-        vec::map_zip(precise_param_ids, **uses, |id, uses| {\n+        precise_param_ids.iter().zip(uses.iter()).transform(|(id, uses)| {\n             if ccx.sess.no_monomorphic_collapse() {\n                 match copy *id {\n                     (a, b) => mono_precise(a, b)\n@@ -377,13 +376,13 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n                     }\n                 }\n             }\n-        })\n+        }).collect()\n       }\n       None => {\n-          precise_param_ids.map(|x| {\n+          precise_param_ids.iter().transform(|x| {\n               let (a, b) = copy *x;\n               mono_precise(a, b)\n-          })\n+          }).collect()\n       }\n     };\n     @mono_id_ {def: item, params: param_ids, impl_did_opt: impl_did_opt}"}, {"sha": "bbf548d2659a1e77c2e501be71ce07f305fd0ffa", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -2323,7 +2323,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 false\n             }\n \n-            ty_struct(ref did, _) if vec::contains(*seen, did) => {\n+            ty_struct(ref did, _) if seen.contains(did) => {\n                 false\n             }\n \n@@ -2339,7 +2339,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 ts.iter().any_(|t| type_requires(cx, seen, r_ty, *t))\n             }\n \n-            ty_enum(ref did, _) if vec::contains(*seen, did) => {\n+            ty_enum(ref did, _) if seen.contains(did) => {\n                 false\n             }\n \n@@ -3266,7 +3266,7 @@ pub fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n     if !type_needs_infer(rt) { return; }\n \n     // Occurs check!\n-    if vec::contains(vars_in_type(rt), &vid) {\n+    if vars_in_type(rt).contains(&vid) {\n             // Maybe this should be span_err -- however, there's an\n             // assertion later on that the type doesn't contain\n             // variables, so in this case we have to be sure to die.\n@@ -3674,15 +3674,15 @@ pub fn substd_enum_variants(cx: ctxt,\n                             id: ast::def_id,\n                             substs: &substs)\n                          -> ~[VariantInfo] {\n-    do vec::map(*enum_variants(cx, id)) |variant_info| {\n-        let substd_args = vec::map(variant_info.args,\n-                                   |aty| subst(cx, substs, *aty));\n+    do enum_variants(cx, id).iter().transform |variant_info| {\n+        let substd_args = variant_info.args.iter()\n+            .transform(|aty| subst(cx, substs, *aty)).collect();\n \n         let substd_ctor_ty = subst(cx, substs, variant_info.ctor_ty);\n \n         @VariantInfo_{args: substd_args, ctor_ty: substd_ctor_ty,\n                       ../*bad*/copy **variant_info}\n-    }\n+    }.collect()\n }\n \n pub fn item_path_str(cx: ctxt, id: ast::def_id) -> ~str {\n@@ -3815,7 +3815,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n                     _\n                 }, _) => {\n             let mut disr_val = -1;\n-            @vec::map(enum_definition.variants, |variant| {\n+            @enum_definition.variants.iter().transform(|variant| {\n                 match variant.node.kind {\n                     ast::tuple_variant_kind(ref args) => {\n                         let ctor_ty = node_id_to_type(cx, variant.node.id);\n@@ -3848,7 +3848,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n                         fail!(\"struct variant kinds unimpl in enum_variants\")\n                     }\n                 }\n-            })\n+            }).collect()\n           }\n           _ => cx.sess.bug(\"tag_variants: id not bound to an enum\")\n         }"}, {"sha": "4d2849c521058a42faa3a3da503036256e0b21dc", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -718,14 +718,14 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n     let bound_lifetime_names = bound_lifetimes(this, lifetimes);\n     let rb = in_binding_rscope(rscope, RegionParamNames(copy bound_lifetime_names));\n \n-    let input_tys = do decl.inputs.mapi |i, a| {\n+    let input_tys = do decl.inputs.iter().enumerate().transform |(i, a)| {\n         let expected_arg_ty = do expected_sig.chain_ref |e| {\n             // no guarantee that the correct number of expected args\n             // were supplied\n             if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n         };\n         ty_of_arg(this, &rb, *a, expected_arg_ty)\n-    };\n+    }.collect();\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n     let output_ty = match decl.output.node {"}, {"sha": "a6bc335bcdbc78607b4a2d03fd9da6e7523790dd", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -985,7 +985,7 @@ pub fn do_autoderef(fcx: @mut FnCtxt, sp: span, t: ty::t) -> (ty::t, uint) {\n                 // concerned with this, as an error will be reported\n                 // on the enum definition as well because the enum is\n                 // not instantiable.\n-                if vec::contains(enum_dids, did) {\n+                if enum_dids.contains(did) {\n                     return (t1, autoderefs);\n                 }\n                 enum_dids.push(*did);\n@@ -1781,7 +1781,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             _ => ()\n         }\n \n-        let tps = vec::map(tys, |ty| fcx.to_ty(*ty));\n+        let tps = tys.iter().transform(|ty| fcx.to_ty(*ty)).collect::<~[ty::t]>();\n         match method::lookup(fcx,\n                              expr,\n                              base,\n@@ -2766,7 +2766,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let mut bot_field = false;\n         let mut err_field = false;\n \n-        let elt_ts = do elts.mapi |i, e| {\n+        let elt_ts = do elts.iter().enumerate().transform |(i, e)| {\n             let opt_hint = match flds {\n                 Some(ref fs) if i < fs.len() => Some(fs[i]),\n                 _ => None\n@@ -2776,7 +2776,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             err_field = err_field || ty::type_is_error(t);\n             bot_field = bot_field || ty::type_is_bot(t);\n             t\n-        };\n+        }.collect();\n         if bot_field {\n             fcx.write_bot(id);\n         } else if err_field {\n@@ -3156,7 +3156,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                   }\n                 }\n             }\n-            if vec::contains(*disr_vals, &*disr_val) {\n+            if disr_vals.contains(&*disr_val) {\n                 ccx.tcx.sess.span_err(v.span,\n                                       \"discriminator value already exists\");\n             }"}, {"sha": "85bd2bc2d75ea28c1f5436cac7c8ce12693a43a0", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -712,7 +712,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n                     -> ~[ConvertedMethod]\n {\n     let tcx = ccx.tcx;\n-    return vec::map(ms, |m| {\n+    return ms.iter().transform(|m| {\n         let num_rcvr_ty_params = rcvr_ty_generics.type_param_defs.len();\n         let m_ty_generics =\n             ty_generics(ccx, rcvr_ty_generics.region_param, &m.generics,\n@@ -742,7 +742,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n         tcx.methods.insert(mty.def_id, mty);\n         ConvertedMethod {mty: mty, id: m.id,\n                          span: m.span, body_id: m.body.node.id}\n-    });\n+    }).collect();\n \n     fn ty_of_method(ccx: &CrateCtxt,\n                     m: &ast::method,"}, {"sha": "db17405fc26639cc70f082f75ec478bcbbbd8f30", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -1478,7 +1478,7 @@ impl RegionVarBindings {\n         // overlapping locations.\n         let mut dup_vec = graph.nodes.map(|_| uint::max_value);\n \n-        graph.nodes.mapi(|idx, node| {\n+        graph.nodes.iter().enumerate().transform(|(idx, node)| {\n             match node.value {\n                 Value(_) => {\n                     /* Inference successful */\n@@ -1528,7 +1528,7 @@ impl RegionVarBindings {\n             }\n \n             node.value\n-        })\n+        }).collect()\n     }\n \n     pub fn report_error_for_expanding_node(&mut self,"}, {"sha": "941431ce0e3d11742c5310bfa604a558d271b202", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -57,7 +57,6 @@ use middle::typeck::infer::unify::{Root, UnifyInferCtxtMethods};\n use util::common::{indent, indenter};\n use util::ppaux::ty_to_str;\n \n-use std::vec;\n use syntax::ast;\n \n pub static resolve_nested_tvar: uint = 0b0000000001;\n@@ -204,7 +203,7 @@ impl ResolveState {\n     }\n \n     pub fn resolve_ty_var(&mut self, vid: TyVid) -> ty::t {\n-        if vec::contains(self.v_seen, &vid) {\n+        if self.v_seen.contains(&vid) {\n             self.err = Some(cyclic_ty(vid));\n             return ty::mk_var(self.infcx.tcx, vid);\n         } else {"}, {"sha": "2a9442fbe525b51812c155c09b45e87457f47341", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -26,7 +26,6 @@ use fold::Fold;\n use fold;\n use pass::Pass;\n \n-use std::vec;\n use syntax::ast;\n use syntax::ast_map;\n \n@@ -124,7 +123,7 @@ fn fold_enum(\n     let doc = fold::default_seq_fold_enum(fold, doc);\n \n     doc::EnumDoc {\n-        variants: do vec::map(doc.variants) |variant| {\n+        variants: do doc.variants.iter().transform |variant| {\n             let variant = copy *variant;\n             let desc = {\n                 let variant = copy variant;\n@@ -153,7 +152,7 @@ fn fold_enum(\n                 desc: desc,\n                 .. variant\n             }\n-        },\n+        }.collect(),\n         .. doc\n     }\n }\n@@ -183,7 +182,7 @@ fn merge_method_attrs(\n             ast_map::node_item(@ast::item {\n                 node: ast::item_trait(_, _, ref methods), _\n             }, _) => {\n-                vec::map(*methods, |method| {\n+                methods.iter().transform(|method| {\n                     match copy *method {\n                         ast::required(ty_m) => {\n                             (to_str(ty_m.ident),\n@@ -193,29 +192,29 @@ fn merge_method_attrs(\n                             (to_str(m.ident), attr_parser::parse_desc(copy m.attrs))\n                         }\n                     }\n-                })\n+                }).collect()\n             }\n             ast_map::node_item(@ast::item {\n                 node: ast::item_impl(_, _, _, ref methods), _\n             }, _) => {\n-                vec::map(*methods, |method| {\n+                methods.iter().transform(|method| {\n                     (to_str(method.ident),\n                      attr_parser::parse_desc(copy method.attrs))\n-                })\n+                }).collect()\n             }\n             _ => fail!(\"unexpected item\")\n         }\n     };\n \n-    do vec::map_zip(docs, attrs) |doc, attrs| {\n+    do docs.iter().zip(attrs.iter()).transform |(doc, attrs)| {\n         assert!(doc.name == attrs.first());\n         let desc = attrs.second();\n \n         doc::MethodDoc {\n             desc: desc,\n             .. copy *doc\n         }\n-    }\n+    }.collect()\n }\n \n "}, {"sha": "d5d2b4ce6286cea90f1480af57b35880ad05be5d", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -186,7 +186,7 @@ fn enumdoc_from_enum(\n fn variantdocs_from_variants(\n     variants: ~[ast::variant]\n ) -> ~[doc::VariantDoc] {\n-    vec::map(variants, variantdoc_from_variant)\n+    variants.iter().transform(variantdoc_from_variant).collect()\n }\n \n fn variantdoc_from_variant(variant: &ast::variant) -> doc::VariantDoc {\n@@ -203,7 +203,7 @@ fn traitdoc_from_trait(\n ) -> doc::TraitDoc {\n     doc::TraitDoc {\n         item: itemdoc,\n-        methods: do vec::map(methods) |method| {\n+        methods: do methods.iter().transform |method| {\n             match copy *method {\n               ast::required(ty_m) => {\n                 doc::MethodDoc {\n@@ -226,7 +226,7 @@ fn traitdoc_from_trait(\n                 }\n               }\n             }\n-        }\n+        }.collect()\n     }\n }\n \n@@ -239,7 +239,7 @@ fn impldoc_from_impl(\n         bounds_str: None,\n         trait_types: ~[],\n         self_ty: None,\n-        methods: do vec::map(methods) |method| {\n+        methods: do methods.iter().transform |method| {\n             doc::MethodDoc {\n                 name: to_str(method.ident),\n                 brief: None,\n@@ -248,7 +248,7 @@ fn impldoc_from_impl(\n                 sig: None,\n                 implementation: doc::Provided,\n             }\n-        }\n+        }.collect()\n     }\n }\n "}, {"sha": "6510384ef01dd8877aaa58274ab2b898b8e53d37", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -13,8 +13,6 @@ use doc;\n #[cfg(test)] use extract;\n #[cfg(test)] use parse;\n \n-use std::vec;\n-\n pub struct Fold<T> {\n     ctxt: T,\n     fold_doc: FoldDoc<T>,\n@@ -155,7 +153,7 @@ pub fn default_par_fold<T:Clone>(ctxt: T) -> Fold<T> {\n \n pub fn default_seq_fold_doc<T>(fold: &Fold<T>, doc: doc::Doc) -> doc::Doc {\n     doc::Doc {\n-        pages: do vec::map(doc.pages) |page| {\n+        pages: do doc.pages.iter().transform |page| {\n             match copy *page {\n               doc::CratePage(doc) => {\n                 doc::CratePage((fold.fold_crate)(fold, doc))\n@@ -164,7 +162,7 @@ pub fn default_seq_fold_doc<T>(fold: &Fold<T>, doc: doc::Doc) -> doc::Doc {\n                 doc::ItemPage(fold_ItemTag(fold, doc))\n               }\n             }\n-        },\n+        }.collect(),\n         .. doc\n     }\n }\n@@ -191,9 +189,9 @@ pub fn default_any_fold_mod<T:Clone>(\n ) -> doc::ModDoc {\n     doc::ModDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        items: vec::map(doc.items, |ItemTag| {\n+        items: doc.items.iter().transform(|ItemTag| {\n             fold_ItemTag(fold, copy *ItemTag)\n-        }),\n+        }).collect(),\n         .. doc\n     }\n }\n@@ -204,9 +202,9 @@ pub fn default_seq_fold_mod<T>(\n ) -> doc::ModDoc {\n     doc::ModDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        items: vec::map(doc.items, |ItemTag| {\n+        items: doc.items.iter().transform(|ItemTag| {\n             fold_ItemTag(fold, copy *ItemTag)\n-        }),\n+        }).collect(),\n         .. doc\n     }\n }\n@@ -217,9 +215,9 @@ pub fn default_par_fold_mod<T:Clone>(\n ) -> doc::ModDoc {\n     doc::ModDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        items: vec::map(doc.items, |ItemTag| {\n+        items: doc.items.iter().transform(|ItemTag| {\n             fold_ItemTag(fold, copy *ItemTag)\n-        }),\n+        }).collect(),\n         .. doc\n     }\n }\n@@ -230,9 +228,9 @@ pub fn default_any_fold_nmod<T:Clone>(\n ) -> doc::NmodDoc {\n     doc::NmodDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        fns: vec::map(doc.fns, |FnDoc| {\n+        fns: doc.fns.iter().transform(|FnDoc| {\n             (fold.fold_fn)(fold, copy *FnDoc)\n-        }),\n+        }).collect(),\n         .. doc\n     }\n }\n@@ -243,9 +241,9 @@ pub fn default_seq_fold_nmod<T>(\n ) -> doc::NmodDoc {\n     doc::NmodDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        fns: vec::map(doc.fns, |FnDoc| {\n+        fns: doc.fns.iter().transform(|FnDoc| {\n             (fold.fold_fn)(fold, copy *FnDoc)\n-        }),\n+        }).collect(),\n         .. doc\n     }\n }\n@@ -256,9 +254,9 @@ pub fn default_par_fold_nmod<T:Clone>(\n ) -> doc::NmodDoc {\n     doc::NmodDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        fns: vec::map(doc.fns, |FnDoc| {\n+        fns: doc.fns.iter().transform(|FnDoc| {\n             (fold.fold_fn)(fold, copy *FnDoc)\n-        }),\n+        }).collect(),\n         .. doc\n     }\n }"}, {"sha": "e40bdb532da932e8fc228b9a6e5bbf910cee7c92", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -20,7 +20,6 @@ use fold::Fold;\n use fold;\n use pass::Pass;\n \n-use std::vec;\n use syntax::ast;\n use syntax::print::pprust;\n use syntax::parse::token;\n@@ -114,7 +113,7 @@ fn fold_enum(\n     let srv = fold.ctxt.clone();\n \n     doc::EnumDoc {\n-        variants: do vec::map(doc.variants) |variant| {\n+        variants: do doc.variants.iter().transform |variant| {\n             let sig = {\n                 let variant = copy *variant;\n                 do astsrv::exec(srv.clone()) |ctxt| {\n@@ -139,7 +138,7 @@ fn fold_enum(\n                 sig: Some(sig),\n                 .. copy *variant\n             }\n-        },\n+        }.collect(),\n         .. doc\n     }\n }\n@@ -159,12 +158,12 @@ fn merge_methods(\n     item_id: doc::AstId,\n     docs: ~[doc::MethodDoc]\n ) -> ~[doc::MethodDoc] {\n-    do vec::map(docs) |doc| {\n+    do docs.iter().transform |doc| {\n         doc::MethodDoc {\n             sig: get_method_sig(srv.clone(), item_id, copy doc.name),\n             .. copy *doc\n         }\n-    }\n+    }.collect()\n }\n \n fn get_method_sig("}, {"sha": "b29aefdd5340acfae207c229cabf60420d01cb5f", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -597,9 +597,9 @@ fn rust_path_contents() {\n         let cwd = os::getcwd().push(\".rust\");\n         let parent = cwd.pop().pop().push(\".rust\");\n         let grandparent = cwd.pop().pop().pop().push(\".rust\");\n-        assert!(vec::contains(p, &cwd));\n-        assert!(vec::contains(p, &parent));\n-        assert!(vec::contains(p, &grandparent));\n+        assert!(p.contains(&cwd));\n+        assert!(p.contains(&parent));\n+        assert!(p.contains(&grandparent));\n         for p.iter().advance() |a_path| {\n             assert!(!a_path.components.is_empty());\n         }\n@@ -610,9 +610,9 @@ fn rust_path_contents() {\n fn rust_path_parse() {\n     os::setenv(\"RUST_PATH\", \"/a/b/c:/d/e/f:/g/h/i\");\n     let paths = rust_path();\n-    assert!(vec::contains(paths, &Path(\"/g/h/i\")));\n-    assert!(vec::contains(paths, &Path(\"/d/e/f\")));\n-    assert!(vec::contains(paths, &Path(\"/a/b/c\")));\n+    assert!(paths.contains(&Path(\"/g/h/i\")));\n+    assert!(paths.contains(&Path(\"/d/e/f\")));\n+    assert!(paths.contains(&Path(\"/a/b/c\")));\n     os::unsetenv(\"RUST_PATH\");\n }\n "}, {"sha": "85dca1154bc09330484fbcd34d58f975073b2846", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -939,7 +939,7 @@ mod test_map {\n mod test_set {\n     use super::*;\n     use container::{Container, Map, Set};\n-    use vec;\n+    use vec::ImmutableEqVector;\n     use uint;\n \n     #[test]\n@@ -1030,7 +1030,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n         for a.intersection(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -1053,7 +1053,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [1, 5, 11];\n         for a.difference(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -1079,7 +1079,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [-2, 1, 5, 11, 14, 22];\n         for a.symmetric_difference(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n@@ -1109,7 +1109,7 @@ mod test_set {\n         let mut i = 0;\n         let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n         for a.union(&b) |x| {\n-            assert!(vec::contains(expected, x));\n+            assert!(expected.contains(x));\n             i += 1\n         }\n         assert_eq!(i, expected.len());"}, {"sha": "bdcad15f45c444fd9ad8bc70dbab1ec7fc869b6c", "filename": "src/libstd/io.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -1912,7 +1912,9 @@ mod tests {\n                 if len <= ivals.len() {\n                     assert_eq!(res.len(), len);\n                 }\n-                assert!(ivals.slice(0u, res.len()) == vec::map(res, |x| *x as int));\n+                for ivals.iter().zip(res.iter()).advance |(iv, c)| {\n+                    assert!(*iv == *c as int)\n+                }\n             }\n         }\n         let mut i = 0;"}, {"sha": "77befbf19aa92f9afb5fe3dc5782bb5f37b6d60a", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -85,8 +85,7 @@ pub trait IteratorUtil<A> {\n \n     // FIXME: #5898: should be called map\n     /// Creates a new iterator which will apply the specified function to each\n-    /// element returned by the first, yielding the mapped element instead. This\n-    /// similar to the `vec::map` function.\n+    /// element returned by the first, yielding the mapped element instead.\n     ///\n     /// # Example\n     ///"}, {"sha": "f6dff4267b7a8f859261cc741e913862c02e2793", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -18,8 +18,7 @@ use char;\n use str;\n use str::StrSlice;\n use kinds::Copy;\n-use vec;\n-use vec::{CopyableVector, ImmutableVector};\n+use vec::{CopyableVector, ImmutableVector, MutableVector};\n use vec::OwnedVector;\n use num::{NumCast, Zero, One, cast, pow_with_uint, Integer};\n use num::{Round, Float, FPNaN, FPInfinite};\n@@ -292,7 +291,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n         _ => ()\n     }\n \n-    vec::reverse(buf);\n+    buf.reverse();\n \n     // Remember start of the fractional digits.\n     // Points one beyond end of buf if none get generated,"}, {"sha": "39041b483697af857c255d905ad21c28e372cad5", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -1544,10 +1544,10 @@ mod tests {\n \n         let mut e = env();\n         setenv(n, \"VALUE\");\n-        assert!(!vec::contains(e, &(copy n, ~\"VALUE\")));\n+        assert!(!e.contains(&(copy n, ~\"VALUE\")));\n \n         e = env();\n-        assert!(vec::contains(e, &(n, ~\"VALUE\")));\n+        assert!(e.contains(&(n, ~\"VALUE\")));\n     }\n \n     #[test]"}, {"sha": "d560ce621eac969d695a3aa09cb5d7c6e9cae3f0", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -73,8 +73,8 @@ pub use tuple::{ImmutableTuple2, ImmutableTuple3, ImmutableTuple4, ImmutableTupl\n pub use tuple::{ImmutableTuple6, ImmutableTuple7, ImmutableTuple8, ImmutableTuple9};\n pub use tuple::{ImmutableTuple10, ImmutableTuple11, ImmutableTuple12};\n pub use vec::{VectorVector, CopyableVector, ImmutableVector};\n-pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n-pub use vec::{OwnedVector, OwnedCopyableVector, MutableVector};\n+pub use vec::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCopyableVector};\n+pub use vec::{OwnedVector, OwnedCopyableVector,OwnedEqVector, MutableVector};\n pub use io::{Reader, ReaderUtil, Writer, WriterUtil};\n \n // Reexported runtime types"}, {"sha": "5f96e38a55af498f4cadf801a85f64fbd18709f0", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -590,7 +590,7 @@ impl<R: Rng> RngUtil for R {\n             // invariant: elements with index >= i have been locked in place.\n             i -= 1u;\n             // lock element i in place.\n-            vec::swap(values, i, self.gen_uint_range(0u, i + 1u));\n+            values.swap(i, self.gen_uint_range(0u, i + 1u));\n         }\n     }\n }"}, {"sha": "4570254627833a795cd49eeb9d9a296f17e6ec6b", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -14,6 +14,8 @@\n \n use kinds::Copy;\n use vec;\n+use vec::ImmutableVector;\n+use iterator::IteratorUtil;\n \n pub use self::inner::*;\n \n@@ -96,7 +98,7 @@ impl<'self,A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&'self [A], &'self [B]) {\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n         match *self {\n             (ref a, ref b) => {\n-                vec::map_zip(*a, *b, f)\n+                a.iter().zip(b.iter()).transform(|(aa, bb)| f(aa, bb)).collect()\n             }\n         }\n     }\n@@ -116,7 +118,7 @@ impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n         match *self {\n             (ref a, ref b) => {\n-                vec::map_zip(*a, *b, f)\n+                a.iter().zip(b.iter()).transform(|(aa, bb)| f(aa, bb)).collect()\n             }\n         }\n     }"}, {"sha": "1e2d5c76feaa0d6f7731fb00c5cc5a89b9e3da5b", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -16,9 +16,9 @@ pub mod general_category {\n \n     fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n         use cmp::{Equal, Less, Greater};\n-        use vec::bsearch;\n+        use vec::ImmutableVector;\n         use option::None;\n-        (do bsearch(r) |&(lo,hi)| {\n+        (do r.bsearch |&(lo,hi)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n@@ -1447,15 +1447,13 @@ pub mod general_category {\n     }\n \n }\n-\n pub mod derived_property {\n \n-\n     fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n         use cmp::{Equal, Less, Greater};\n-        use vec::bsearch;\n+        use vec::ImmutableVector;\n         use option::None;\n-        (do bsearch(r) |&(lo,hi)| {\n+        (do r.bsearch |&(lo,hi)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n@@ -2641,4 +2639,5 @@ pub mod derived_property {\n     pub fn XID_Start(c: char) -> bool {\n         bsearch_range_table(c, XID_Start_table)\n     }\n+\n }"}, {"sha": "b3717adc57701cb2878227c0ba44cdc047642f22", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 251, "deletions": 590, "changes": 841, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -193,11 +193,11 @@ pub fn split<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let mut start = 0u;\n     let mut result = ~[];\n     while start < ln {\n-        match position_between(v, start, ln, |t| f(t)) {\n+        match v.slice(start, ln).iter().position_(|t| f(t)) {\n             None => break,\n             Some(i) => {\n-                result.push(v.slice(start, i).to_owned());\n-                start = i + 1u;\n+                result.push(v.slice(start, start + i).to_owned());\n+                start += i + 1u;\n             }\n         }\n     }\n@@ -217,12 +217,12 @@ pub fn splitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let mut count = n;\n     let mut result = ~[];\n     while start < ln && count > 0u {\n-        match position_between(v, start, ln, |t| f(t)) {\n+        match v.slice(start, ln).iter().position_(|t| f(t)) {\n             None => break,\n             Some(i) => {\n-                result.push(v.slice(start, i).to_owned());\n+                result.push(v.slice(start, start + i).to_owned());\n                 // Make sure to skip the separator.\n-                start = i + 1u;\n+                start += i + 1u;\n                 count -= 1u;\n             }\n         }\n@@ -242,7 +242,7 @@ pub fn rsplit<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let mut end = ln;\n     let mut result = ~[];\n     while end > 0 {\n-        match rposition_between(v, 0, end, |t| f(t)) {\n+        match v.slice(0, end).rposition(|t| f(t)) {\n             None => break,\n             Some(i) => {\n                 result.push(v.slice(i + 1, end).to_owned());\n@@ -251,7 +251,7 @@ pub fn rsplit<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         }\n     }\n     result.push(v.slice(0u, end).to_owned());\n-    reverse(result);\n+    result.reverse();\n     result\n }\n \n@@ -267,7 +267,7 @@ pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let mut count = n;\n     let mut result = ~[];\n     while end > 0u && count > 0u {\n-        match rposition_between(v, 0u, end, |t| f(t)) {\n+        match v.slice(0, end).rposition(|t| f(t)) {\n             None => break,\n             Some(i) => {\n                 result.push(v.slice(i + 1u, end).to_owned());\n@@ -278,7 +278,7 @@ pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         }\n     }\n     result.push(v.slice(0u, end).to_owned());\n-    reverse(result);\n+    result.reverse();\n     result\n }\n \n@@ -343,41 +343,6 @@ pub fn consume_reverse<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n     }\n }\n \n-/**\n- * Remove consecutive repeated elements from a vector; if the vector is\n- * sorted, this removes all duplicates.\n- */\n-pub fn dedup<T:Eq>(v: &mut ~[T]) {\n-    unsafe {\n-        if v.len() < 1 { return; }\n-        let mut last_written = 0;\n-        let mut next_to_read = 1;\n-        do as_mut_buf(*v) |p, ln| {\n-            // last_written < next_to_read <= ln\n-            while next_to_read < ln {\n-                // last_written < next_to_read < ln\n-                if *ptr::mut_offset(p, next_to_read) ==\n-                    *ptr::mut_offset(p, last_written) {\n-                    ptr::replace_ptr(ptr::mut_offset(p, next_to_read),\n-                                     intrinsics::uninit());\n-                } else {\n-                    last_written += 1;\n-                    // last_written <= next_to_read < ln\n-                    if next_to_read != last_written {\n-                        ptr::swap_ptr(ptr::mut_offset(p, last_written),\n-                                      ptr::mut_offset(p, next_to_read));\n-                    }\n-                }\n-                // last_written <= next_to_read < ln\n-                next_to_read += 1;\n-                // last_written < next_to_read <= ln\n-            }\n-        }\n-        // last_written < next_to_read == ln\n-        raw::set_len(v, last_written + 1);\n-    }\n-}\n-\n // Appending\n \n /// Iterates over the `rhs` vector, copying each element and appending it to the\n@@ -398,74 +363,8 @@ pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n     v\n }\n \n-/**\n- * Expands a vector in place, initializing the new elements to a given value\n- *\n- * # Arguments\n- *\n- * * v - The vector to grow\n- * * n - The number of elements to add\n- * * initval - The value for the new elements\n- */\n-pub fn grow<T:Copy>(v: &mut ~[T], n: uint, initval: &T) {\n-    let new_len = v.len() + n;\n-    v.reserve_at_least(new_len);\n-    let mut i: uint = 0u;\n-\n-    while i < n {\n-        v.push(copy *initval);\n-        i += 1u;\n-    }\n-}\n-\n-/**\n- * Expands a vector in place, initializing the new elements to the result of\n- * a function\n- *\n- * Function `init_op` is called `n` times with the values [0..`n`)\n- *\n- * # Arguments\n- *\n- * * v - The vector to grow\n- * * n - The number of elements to add\n- * * init_op - A function to call to retreive each appended element's\n- *             value\n- */\n-pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: &fn(uint) -> T) {\n-    let new_len = v.len() + n;\n-    v.reserve_at_least(new_len);\n-    let mut i: uint = 0u;\n-    while i < n {\n-        v.push(op(i));\n-        i += 1u;\n-    }\n-}\n-\n-/**\n- * Sets the value of a vector element at a given index, growing the vector as\n- * needed\n- *\n- * Sets the element at position `index` to `val`. If `index` is past the end\n- * of the vector, expands the vector by replicating `initval` to fill the\n- * intervening space.\n- */\n-pub fn grow_set<T:Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n-    let l = v.len();\n-    if index >= l { grow(&mut *v, index - l + 1u, initval); }\n-    v[index] = val;\n-}\n-\n // Functional utilities\n \n-/// Apply a function to each element of a vector and return the results\n-pub fn map<T, U>(v: &[T], f: &fn(t: &T) -> U) -> ~[U] {\n-    let mut result = with_capacity(v.len());\n-    for v.iter().advance |elem| {\n-        result.push(f(elem));\n-    }\n-    result\n-}\n-\n /// Consumes a vector, mapping it into a different vector. This function takes\n /// ownership of the supplied vector `v`, moving each element into the closure\n /// provided to generate a new element. The vector of new elements is then\n@@ -480,16 +379,6 @@ pub fn map_consume<T, U>(v: ~[T], f: &fn(v: T) -> U) -> ~[U] {\n     }\n     result\n }\n-\n-/// Apply a function to each element of a vector and return the results\n-pub fn mapi<T, U>(v: &[T], f: &fn(uint, t: &T) -> U) -> ~[U] {\n-    let mut i = 0;\n-    do map(v) |e| {\n-        i += 1;\n-        f(i - 1, e)\n-    }\n-}\n-\n /**\n  * Apply a function to each element of a vector and return a concatenation\n  * of each result vector\n@@ -500,23 +389,6 @@ pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n     result\n }\n \n-/**\n- * Apply a function to each pair of elements and return the results.\n- * Equivalent to `map(zip(v0, v1), f)`.\n- */\n-pub fn map_zip<T:Copy,U:Copy,V>(v0: &[T], v1: &[U],\n-                                  f: &fn(t: &T, v: &U) -> V) -> ~[V] {\n-    let v0_len = v0.len();\n-    if v0_len != v1.len() { fail!(); }\n-    let mut u: ~[V] = ~[];\n-    let mut i = 0u;\n-    while i < v0_len {\n-        u.push(f(&v0[i], &v1[i]));\n-        i += 1u;\n-    }\n-    u\n-}\n-\n pub fn filter_map<T, U>(\n     v: ~[T],\n     f: &fn(t: T) -> Option<U>) -> ~[U]\n@@ -646,150 +518,6 @@ impl<'self, T:Copy> VectorVector<T> for &'self [&'self [T]] {\n     }\n }\n \n-/// Return true if a vector contains an element with the given value\n-pub fn contains<T:Eq>(v: &[T], x: &T) -> bool {\n-    for v.iter().advance |elt| { if *x == *elt { return true; } }\n-    false\n-}\n-\n-/**\n- * Search for the first element that matches a given predicate within a range\n- *\n- * Apply function `f` to each element of `v` within the range\n- * [`start`, `end`). When function `f` returns true then an option containing\n- * the element is returned. If `f` matches no elements then none is returned.\n- */\n-pub fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n-                      f: &fn(t: &T) -> bool) -> Option<T> {\n-    position_between(v, start, end, f).map(|i| copy v[*i])\n-}\n-\n-/**\n- * Search for the last element that matches a given predicate\n- *\n- * Apply function `f` to each element of `v` in reverse order. When function\n- * `f` returns true then an option containing the element is returned. If `f`\n- * matches no elements then none is returned.\n- */\n-pub fn rfind<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n-    rfind_between(v, 0u, v.len(), f)\n-}\n-\n-/**\n- * Search for the last element that matches a given predicate within a range\n- *\n- * Apply function `f` to each element of `v` in reverse order within the range\n- * [`start`, `end`). When function `f` returns true then an option containing\n- * the element is returned. If `f` matches no elements then none is return.\n- */\n-pub fn rfind_between<T:Copy>(v: &[T],\n-                             start: uint,\n-                             end: uint,\n-                             f: &fn(t: &T) -> bool)\n-                          -> Option<T> {\n-    rposition_between(v, start, end, f).map(|i| copy v[*i])\n-}\n-\n-/// Find the first index containing a matching value\n-pub fn position_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n-    v.iter().position_(|y| *x == *y)\n-}\n-\n-/**\n- * Find the first index matching some predicate within a range\n- *\n- * Apply function `f` to each element of `v` between the range\n- * [`start`, `end`). When function `f` returns true then an option containing\n- * the index is returned. If `f` matches no elements then none is returned.\n- */\n-pub fn position_between<T>(v: &[T],\n-                           start: uint,\n-                           end: uint,\n-                           f: &fn(t: &T) -> bool)\n-                        -> Option<uint> {\n-    assert!(start <= end);\n-    assert!(end <= v.len());\n-    let mut i = start;\n-    while i < end { if f(&v[i]) { return Some::<uint>(i); } i += 1u; }\n-    None\n-}\n-\n-/// Find the last index containing a matching value\n-pub fn rposition_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n-    rposition(v, |y| *x == *y)\n-}\n-\n-/**\n- * Find the last index matching some predicate\n- *\n- * Apply function `f` to each element of `v` in reverse order.  When function\n- * `f` returns true then an option containing the index is returned. If `f`\n- * matches no elements then none is returned.\n- */\n-pub fn rposition<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n-    rposition_between(v, 0u, v.len(), f)\n-}\n-\n-/**\n- * Find the last index matching some predicate within a range\n- *\n- * Apply function `f` to each element of `v` in reverse order between the\n- * range [`start`, `end`). When function `f` returns true then an option\n- * containing the index is returned. If `f` matches no elements then none is\n- * returned.\n- */\n-pub fn rposition_between<T>(v: &[T], start: uint, end: uint,\n-                             f: &fn(t: &T) -> bool) -> Option<uint> {\n-    assert!(start <= end);\n-    assert!(end <= v.len());\n-    let mut i = end;\n-    while i > start {\n-        if f(&v[i - 1u]) { return Some::<uint>(i - 1u); }\n-        i -= 1u;\n-    }\n-    None\n-}\n-\n-\n-\n-/**\n- * Binary search a sorted vector with a comparator function.\n- *\n- * The comparator should implement an order consistent with the sort\n- * order of the underlying vector, returning an order code that indicates\n- * whether its argument is `Less`, `Equal` or `Greater` the desired target.\n- *\n- * Returns the index where the comparator returned `Equal`, or `None` if\n- * not found.\n- */\n-pub fn bsearch<T>(v: &[T], f: &fn(&T) -> Ordering) -> Option<uint> {\n-    let mut base : uint = 0;\n-    let mut lim : uint = v.len();\n-\n-    while lim != 0 {\n-        let ix = base + (lim >> 1);\n-        match f(&v[ix]) {\n-            Equal => return Some(ix),\n-            Less => {\n-                base = ix + 1;\n-                lim -= 1;\n-            }\n-            Greater => ()\n-        }\n-        lim >>= 1;\n-    }\n-    return None;\n-}\n-\n-/**\n- * Binary search a sorted vector for a given element.\n- *\n- * Returns the index of the element or None if not found.\n- */\n-pub fn bsearch_elem<T:TotalOrd>(v: &[T], x: &T) -> Option<uint> {\n-    bsearch(v, |p| p.cmp(x))\n-}\n-\n // FIXME: if issue #586 gets implemented, could have a postcondition\n // saying the two result lists have the same length -- or, could\n // return a nominal record with a constraint saying that, instead of\n@@ -857,40 +585,10 @@ pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n         w.push((v.pop(),u.pop()));\n         i -= 1;\n     }\n-    reverse(w);\n+    w.reverse();\n     w\n }\n \n-/**\n- * Swaps two elements in a vector\n- *\n- * # Arguments\n- *\n- * * v  The input vector\n- * * a - The index of the first element\n- * * b - The index of the second element\n- */\n-#[inline]\n-pub fn swap<T>(v: &mut [T], a: uint, b: uint) {\n-    unsafe {\n-        // Can't take two mutable loans from one vector, so instead just cast\n-        // them to their raw pointers to do the swap\n-        let pa: *mut T = &mut v[a];\n-        let pb: *mut T = &mut v[b];\n-        ptr::swap_ptr(pa, pb);\n-    }\n-}\n-\n-/// Reverse the order of elements in a vector, in place\n-pub fn reverse<T>(v: &mut [T]) {\n-    let mut i: uint = 0;\n-    let ln = v.len();\n-    while i < ln / 2 {\n-        swap(v, i, ln - i - 1);\n-        i += 1;\n-    }\n-}\n-\n /// Returns a vector with the order of elements reversed\n pub fn reversed<T:Copy>(v: &[T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n@@ -946,8 +644,8 @@ pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) ->\n         }\n         // swap indices[k] and indices[l]; sort indices[k+1..]\n         // (they're just reversed)\n-        vec::swap(indices, k, l);\n-        reverse(indices.mut_slice(k+1, length));\n+        indices.swap(k, l);\n+        indices.mut_slice(k+1, length).reverse();\n         // fixup permutation based on indices\n         for uint::range(k, length) |i| {\n             permutation[i] = copy values[indices[i]];\n@@ -1249,12 +947,13 @@ pub trait ImmutableVector<'self, T> {\n     fn last(&self) -> &'self T;\n     fn last_opt(&self) -> Option<&'self T>;\n     fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n-    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n-    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n-    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U];\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n     fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n     unsafe fn unsafe_ref(&self, index: uint) -> *T;\n+\n+    fn bsearch(&self, f: &fn(&T) -> Ordering) -> Option<uint>;\n+\n+    fn map<U>(&self, &fn(t: &T) -> U) -> ~[U];\n }\n \n /// Extension methods for vectors\n@@ -1341,34 +1040,14 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      *\n      * Apply function `f` to each element of `v` in reverse order.  When\n      * function `f` returns true then an option containing the index is\n-     * returned. If `f` matches no elements then none is returned.\n+     * returned. If `f` matches no elements then None is returned.\n      */\n     #[inline]\n     fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n-        rposition(*self, f)\n-    }\n-\n-    /// Apply a function to each element of a vector and return the results\n-    #[inline]\n-    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n-\n-    /**\n-     * Apply a function to the index and value of each element in the vector\n-     * and return the results\n-     */\n-    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U] {\n-        mapi(*self, f)\n-    }\n-\n-    #[inline]\n-    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U] {\n-        let mut r = ~[];\n-        let mut i = 0;\n-        while i < self.len() {\n-            r.push(f(&self[i]));\n-            i += 1;\n+        for self.rev_iter().enumerate().advance |(i, t)| {\n+            if f(t) { return Some(self.len() - i - 1); }\n         }\n-        r\n+        None\n     }\n \n     /**\n@@ -1397,32 +1076,90 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         let (ptr, _): (*T, uint) = transmute(*self);\n         ptr.offset(index)\n     }\n+\n+    /**\n+     * Binary search a sorted vector with a comparator function.\n+     *\n+     * The comparator should implement an order consistent with the sort\n+     * order of the underlying vector, returning an order code that indicates\n+     * whether its argument is `Less`, `Equal` or `Greater` the desired target.\n+     *\n+     * Returns the index where the comparator returned `Equal`, or `None` if\n+     * not found.\n+     */\n+    fn bsearch(&self, f: &fn(&T) -> Ordering) -> Option<uint> {\n+        let mut base : uint = 0;\n+        let mut lim : uint = self.len();\n+\n+        while lim != 0 {\n+            let ix = base + (lim >> 1);\n+            match f(&self[ix]) {\n+                Equal => return Some(ix),\n+                Less => {\n+                    base = ix + 1;\n+                    lim -= 1;\n+                }\n+                Greater => ()\n+            }\n+            lim >>= 1;\n+        }\n+        return None;\n+    }\n+\n+    /// Deprecated, use iterators where possible\n+    /// (`self.iter().transform(f)`). Apply a function to each element\n+    /// of a vector and return the results.\n+    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] {\n+        self.iter().transform(f).collect()\n+    }\n }\n \n #[allow(missing_doc)]\n pub trait ImmutableEqVector<T:Eq> {\n     fn position_elem(&self, t: &T) -> Option<uint>;\n     fn rposition_elem(&self, t: &T) -> Option<uint>;\n+    fn contains(&self, x: &T) -> bool;\n }\n \n impl<'self,T:Eq> ImmutableEqVector<T> for &'self [T] {\n     /// Find the first index containing a matching value\n     #[inline]\n     fn position_elem(&self, x: &T) -> Option<uint> {\n-        position_elem(*self, x)\n+        self.iter().position_(|y| *x == *y)\n     }\n \n     /// Find the last index containing a matching value\n     #[inline]\n     fn rposition_elem(&self, t: &T) -> Option<uint> {\n-        rposition_elem(*self, t)\n+        self.rposition(|x| *x == *t)\n+    }\n+\n+    /// Return true if a vector contains an element with the given value\n+    fn contains(&self, x: &T) -> bool {\n+        for self.iter().advance |elt| { if *x == *elt { return true; } }\n+        false\n+    }\n+}\n+\n+#[allow(missing_doc)]\n+pub trait ImmutableTotalOrdVector<T: TotalOrd> {\n+    fn bsearch_elem(&self, x: &T) -> Option<uint>;\n+}\n+\n+impl<'self, T: TotalOrd> ImmutableTotalOrdVector<T> for &'self [T] {\n+    /**\n+     * Binary search a sorted vector for a given element.\n+     *\n+     * Returns the index of the element or None if not found.\n+     */\n+    fn bsearch_elem(&self, x: &T) -> Option<uint> {\n+        self.bsearch(|p| p.cmp(x))\n     }\n }\n \n #[allow(missing_doc)]\n pub trait ImmutableCopyableVector<T> {\n     fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n-    fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T>;\n     fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n     unsafe fn unsafe_get(&self, elem: uint) -> T;\n }\n@@ -1441,18 +1178,6 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n         filtered(*self, f)\n     }\n \n-    /**\n-     * Search for the last element that matches a given predicate\n-     *\n-     * Apply function `f` to each element of `v` in reverse order. When\n-     * function `f` returns true then an option containing the element is\n-     * returned. If `f` matches no elements then none is returned.\n-     */\n-    #[inline]\n-    fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T> {\n-        rfind(*self, f)\n-    }\n-\n     /**\n      * Partitions the vector into those that satisfies the predicate, and\n      * those that do not.\n@@ -1735,7 +1460,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         self.push(x);\n         let mut j = len;\n         while j > i {\n-            swap(*self, j, j - 1);\n+            self.swap(j, j - 1);\n             j -= 1;\n         }\n     }\n@@ -1748,7 +1473,7 @@ impl<T> OwnedVector<T> for ~[T] {\n \n         let mut j = i;\n         while j < len - 1 {\n-            swap(*self, j, j + 1);\n+            self.swap(j, j + 1);\n             j += 1;\n         }\n         self.pop()\n@@ -1766,7 +1491,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             fail!(\"vec::swap_remove - index %u >= length %u\", index, ln);\n         }\n         if index < ln - 1 {\n-            swap(*self, index, ln - 1);\n+            self.swap(index, ln - 1);\n         }\n         self.pop()\n     }\n@@ -1797,7 +1522,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             if !f(&self[i]) {\n                 deleted += 1;\n             } else if deleted > 0 {\n-                swap(*self, i - deleted, i);\n+                self.swap(i - deleted, i);\n             }\n         }\n \n@@ -1841,9 +1566,26 @@ impl<T> OwnedVector<T> for ~[T] {\n         (lefts, rights)\n     }\n \n-    #[inline]\n+    /**\n+     * Expands a vector in place, initializing the new elements to the result of\n+     * a function\n+     *\n+     * Function `init_op` is called `n` times with the values [0..`n`)\n+     *\n+     * # Arguments\n+     *\n+     * * n - The number of elements to add\n+     * * init_op - A function to call to retreive each appended element's\n+     *             value\n+     */\n     fn grow_fn(&mut self, n: uint, op: &fn(uint) -> T) {\n-        grow_fn(self, n, op);\n+        let new_len = self.len() + n;\n+        self.reserve_at_least(new_len);\n+        let mut i: uint = 0u;\n+        while i < n {\n+            self.push(op(i));\n+            i += 1u;\n+        }\n     }\n }\n \n@@ -1880,26 +1622,79 @@ impl<T:Copy> OwnedCopyableVector<T> for ~[T] {\n         }\n     }\n \n-    #[inline]\n+    /**\n+     * Expands a vector in place, initializing the new elements to a given value\n+     *\n+     * # Arguments\n+     *\n+     * * n - The number of elements to add\n+     * * initval - The value for the new elements\n+     */\n     fn grow(&mut self, n: uint, initval: &T) {\n-        grow(self, n, initval);\n+        let new_len = self.len() + n;\n+        self.reserve_at_least(new_len);\n+        let mut i: uint = 0u;\n+\n+        while i < n {\n+            self.push(copy *initval);\n+            i += 1u;\n+        }\n     }\n \n-    #[inline]\n+    /**\n+     * Sets the value of a vector element at a given index, growing the vector as\n+     * needed\n+     *\n+     * Sets the element at position `index` to `val`. If `index` is past the end\n+     * of the vector, expands the vector by replicating `initval` to fill the\n+     * intervening space.\n+     */\n     fn grow_set(&mut self, index: uint, initval: &T, val: T) {\n-        grow_set(self, index, initval, val);\n+        let l = self.len();\n+        if index >= l { self.grow(index - l + 1u, initval); }\n+        self[index] = val;\n     }\n }\n \n #[allow(missing_doc)]\n-trait OwnedEqVector<T:Eq> {\n+pub trait OwnedEqVector<T:Eq> {\n     fn dedup(&mut self);\n }\n \n impl<T:Eq> OwnedEqVector<T> for ~[T] {\n-    #[inline]\n-    fn dedup(&mut self) {\n-        dedup(self)\n+    /**\n+     * Remove consecutive repeated elements from a vector; if the vector is\n+     * sorted, this removes all duplicates.\n+     */\n+    pub fn dedup(&mut self) {\n+        unsafe {\n+            if self.len() == 0 { return; }\n+            let mut last_written = 0;\n+            let mut next_to_read = 1;\n+            do as_mut_buf(*self) |p, ln| {\n+                // last_written < next_to_read <= ln\n+                while next_to_read < ln {\n+                    // last_written < next_to_read < ln\n+                    if *ptr::mut_offset(p, next_to_read) ==\n+                        *ptr::mut_offset(p, last_written) {\n+                        ptr::replace_ptr(ptr::mut_offset(p, next_to_read),\n+                                         intrinsics::uninit());\n+                    } else {\n+                        last_written += 1;\n+                        // last_written <= next_to_read < ln\n+                        if next_to_read != last_written {\n+                            ptr::swap_ptr(ptr::mut_offset(p, last_written),\n+                                          ptr::mut_offset(p, next_to_read));\n+                        }\n+                    }\n+                    // last_written <= next_to_read < ln\n+                    next_to_read += 1;\n+                    // last_written < next_to_read <= ln\n+                }\n+            }\n+            // last_written < next_to_read == ln\n+            raw::set_len(self, last_written + 1);\n+        }\n     }\n }\n \n@@ -1909,6 +1704,10 @@ pub trait MutableVector<'self, T> {\n     fn mut_iter(self) -> VecMutIterator<'self, T>;\n     fn mut_rev_iter(self) -> VecMutRevIterator<'self, T>;\n \n+    fn swap(self, a: uint, b: uint);\n+\n+    fn reverse(self);\n+\n     /**\n      * Consumes `src` and moves as many elements as it can into `self`\n      * from the range [start,end).\n@@ -1960,6 +1759,34 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         }\n     }\n \n+    /**\n+     * Swaps two elements in a vector\n+     *\n+     * # Arguments\n+     *\n+     * * a - The index of the first element\n+     * * b - The index of the second element\n+     */\n+    fn swap(self, a: uint, b: uint) {\n+        unsafe {\n+            // Can't take two mutable loans from one vector, so instead just cast\n+            // them to their raw pointers to do the swap\n+            let pa: *mut T = &mut self[a];\n+            let pb: *mut T = &mut self[b];\n+            ptr::swap_ptr(pa, pb);\n+        }\n+    }\n+\n+    /// Reverse the order of elements in a vector, in place\n+    fn reverse(self) {\n+        let mut i: uint = 0;\n+        let ln = self.len();\n+        while i < ln / 2 {\n+            self.swap(i, ln - i - 1);\n+            i += 1;\n+        }\n+    }\n+\n     #[inline]\n     fn move_from(self, mut src: ~[T], start: uint, end: uint) -> uint {\n         for self.mut_iter().zip(src.mut_slice(start, end).mut_iter()).advance |(a, b)| {\n@@ -2249,7 +2076,7 @@ pub mod bytes {\n impl<A:Clone> Clone for ~[A] {\n     #[inline]\n     fn clone(&self) -> ~[A] {\n-        self.map(|item| item.clone())\n+        self.iter().transform(|item| item.clone()).collect()\n     }\n }\n \n@@ -2796,16 +2623,16 @@ mod tests {\n     #[test]\n     fn test_map() {\n         // Test on-stack map.\n-        let mut v = ~[1u, 2u, 3u];\n-        let mut w = map(v, square_ref);\n+        let v = &[1u, 2u, 3u];\n+        let mut w = v.map(square_ref);\n         assert_eq!(w.len(), 3u);\n         assert_eq!(w[0], 1u);\n         assert_eq!(w[1], 4u);\n         assert_eq!(w[2], 9u);\n \n         // Test on-heap map.\n-        v = ~[1u, 2u, 3u, 4u, 5u];\n-        w = map(v, square_ref);\n+        let v = ~[1u, 2u, 3u, 4u, 5u];\n+        w = v.map(square_ref);\n         assert_eq!(w.len(), 5u);\n         assert_eq!(w[0], 1u);\n         assert_eq!(w[1], 4u);\n@@ -2814,17 +2641,6 @@ mod tests {\n         assert_eq!(w[4], 25u);\n     }\n \n-    #[test]\n-    fn test_map_zip() {\n-        fn times(x: &int, y: &int) -> int { *x * *y }\n-        let f = times;\n-        let v0 = ~[1, 2, 3, 4, 5];\n-        let v1 = ~[5, 4, 3, 2, 1];\n-        let u = map_zip::<int, int, int>(v0, v1, f);\n-        let mut i = 0;\n-        while i < 5 { assert!(v0[i] * v1[i] == u[i]); i += 1; }\n-    }\n-\n     #[test]\n     fn test_filter_mapped() {\n         // Test on-stack filter-map.\n@@ -2856,7 +2672,7 @@ mod tests {\n         let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n         assert!(filter_mapped(all_even, halve) ==\n-                     map(all_even, halve_for_sure));\n+                     all_even.map(halve_for_sure));\n         assert_eq!(filter_mapped(all_odd1, halve), ~[]);\n         assert_eq!(filter_mapped(all_odd2, halve), ~[]);\n         assert_eq!(filter_mapped(mix, halve), mix_dest);\n@@ -2894,7 +2710,7 @@ mod tests {\n         let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n         assert!(filter_map(all_even, halve) ==\n-                     map(all_even0, halve_for_sure));\n+                     all_even0.map(halve_for_sure));\n         assert_eq!(filter_map(all_odd1, halve), ~[]);\n         assert_eq!(filter_map(all_odd2, halve), ~[]);\n         assert_eq!(filter_map(mix, halve), mix_dest);\n@@ -2955,69 +2771,13 @@ mod tests {\n \n     #[test]\n     fn test_position_elem() {\n-        assert!(position_elem([], &1).is_none());\n+        assert!([].position_elem(&1).is_none());\n \n         let v1 = ~[1, 2, 3, 3, 2, 5];\n-        assert_eq!(position_elem(v1, &1), Some(0u));\n-        assert_eq!(position_elem(v1, &2), Some(1u));\n-        assert_eq!(position_elem(v1, &5), Some(5u));\n-        assert!(position_elem(v1, &4).is_none());\n-    }\n-\n-    #[test]\n-    fn test_position_between() {\n-        assert!(position_between([], 0u, 0u, f).is_none());\n-\n-        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n-        let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n-\n-        assert!(position_between(v, 0u, 0u, f).is_none());\n-        assert!(position_between(v, 0u, 1u, f).is_none());\n-        assert_eq!(position_between(v, 0u, 2u, f), Some(1u));\n-        assert_eq!(position_between(v, 0u, 3u, f), Some(1u));\n-        assert_eq!(position_between(v, 0u, 4u, f), Some(1u));\n-\n-        assert!(position_between(v, 1u, 1u, f).is_none());\n-        assert_eq!(position_between(v, 1u, 2u, f), Some(1u));\n-        assert_eq!(position_between(v, 1u, 3u, f), Some(1u));\n-        assert_eq!(position_between(v, 1u, 4u, f), Some(1u));\n-\n-        assert!(position_between(v, 2u, 2u, f).is_none());\n-        assert!(position_between(v, 2u, 3u, f).is_none());\n-        assert_eq!(position_between(v, 2u, 4u, f), Some(3u));\n-\n-        assert!(position_between(v, 3u, 3u, f).is_none());\n-        assert_eq!(position_between(v, 3u, 4u, f), Some(3u));\n-\n-        assert!(position_between(v, 4u, 4u, f).is_none());\n-    }\n-\n-    #[test]\n-    fn test_find_between() {\n-        assert!(find_between([], 0u, 0u, f).is_none());\n-\n-        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n-        let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n-\n-        assert!(find_between(v, 0u, 0u, f).is_none());\n-        assert!(find_between(v, 0u, 1u, f).is_none());\n-        assert_eq!(find_between(v, 0u, 2u, f), Some((1, 'b')));\n-        assert_eq!(find_between(v, 0u, 3u, f), Some((1, 'b')));\n-        assert_eq!(find_between(v, 0u, 4u, f), Some((1, 'b')));\n-\n-        assert!(find_between(v, 1u, 1u, f).is_none());\n-        assert_eq!(find_between(v, 1u, 2u, f), Some((1, 'b')));\n-        assert_eq!(find_between(v, 1u, 3u, f), Some((1, 'b')));\n-        assert_eq!(find_between(v, 1u, 4u, f), Some((1, 'b')));\n-\n-        assert!(find_between(v, 2u, 2u, f).is_none());\n-        assert!(find_between(v, 2u, 3u, f).is_none());\n-        assert_eq!(find_between(v, 2u, 4u, f), Some((3, 'b')));\n-\n-        assert!(find_between(v, 3u, 3u, f).is_none());\n-        assert_eq!(find_between(v, 3u, 4u, f), Some((3, 'b')));\n-\n-        assert!(find_between(v, 4u, 4u, f).is_none());\n+        assert_eq!(v1.position_elem(&1), Some(0u));\n+        assert_eq!(v1.position_elem(&2), Some(1u));\n+        assert_eq!(v1.position_elem(&5), Some(5u));\n+        assert!(v1.position_elem(&4).is_none());\n     }\n \n     #[test]\n@@ -3026,129 +2786,61 @@ mod tests {\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert_eq!(rposition(v, f), Some(3u));\n-        assert!(rposition(v, g).is_none());\n-    }\n-\n-    #[test]\n-    fn test_rposition_between() {\n-        assert!(rposition_between([], 0u, 0u, f).is_none());\n-\n-        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n-        let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n-\n-        assert!(rposition_between(v, 0u, 0u, f).is_none());\n-        assert!(rposition_between(v, 0u, 1u, f).is_none());\n-        assert_eq!(rposition_between(v, 0u, 2u, f), Some(1u));\n-        assert_eq!(rposition_between(v, 0u, 3u, f), Some(1u));\n-        assert_eq!(rposition_between(v, 0u, 4u, f), Some(3u));\n-\n-        assert!(rposition_between(v, 1u, 1u, f).is_none());\n-        assert_eq!(rposition_between(v, 1u, 2u, f), Some(1u));\n-        assert_eq!(rposition_between(v, 1u, 3u, f), Some(1u));\n-        assert_eq!(rposition_between(v, 1u, 4u, f), Some(3u));\n-\n-        assert!(rposition_between(v, 2u, 2u, f).is_none());\n-        assert!(rposition_between(v, 2u, 3u, f).is_none());\n-        assert_eq!(rposition_between(v, 2u, 4u, f), Some(3u));\n-\n-        assert!(rposition_between(v, 3u, 3u, f).is_none());\n-        assert_eq!(rposition_between(v, 3u, 4u, f), Some(3u));\n-\n-        assert!(rposition_between(v, 4u, 4u, f).is_none());\n-    }\n-\n-    #[test]\n-    fn test_rfind() {\n-        assert!(rfind([], f).is_none());\n-\n-        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n-        fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n-        let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n-\n-        assert_eq!(rfind(v, f), Some((3, 'b')));\n-        assert!(rfind(v, g).is_none());\n-    }\n-\n-    #[test]\n-    fn test_rfind_between() {\n-        assert!(rfind_between([], 0u, 0u, f).is_none());\n-\n-        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n-        let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n-\n-        assert!(rfind_between(v, 0u, 0u, f).is_none());\n-        assert!(rfind_between(v, 0u, 1u, f).is_none());\n-        assert_eq!(rfind_between(v, 0u, 2u, f), Some((1, 'b')));\n-        assert_eq!(rfind_between(v, 0u, 3u, f), Some((1, 'b')));\n-        assert_eq!(rfind_between(v, 0u, 4u, f), Some((3, 'b')));\n-\n-        assert!(rfind_between(v, 1u, 1u, f).is_none());\n-        assert_eq!(rfind_between(v, 1u, 2u, f), Some((1, 'b')));\n-        assert_eq!(rfind_between(v, 1u, 3u, f), Some((1, 'b')));\n-        assert_eq!(rfind_between(v, 1u, 4u, f), Some((3, 'b')));\n-\n-        assert!(rfind_between(v, 2u, 2u, f).is_none());\n-        assert!(rfind_between(v, 2u, 3u, f).is_none());\n-        assert_eq!(rfind_between(v, 2u, 4u, f), Some((3, 'b')));\n-\n-        assert!(rfind_between(v, 3u, 3u, f).is_none());\n-        assert_eq!(rfind_between(v, 3u, 4u, f), Some((3, 'b')));\n-\n-        assert!(rfind_between(v, 4u, 4u, f).is_none());\n+        assert_eq!(v.rposition(f), Some(3u));\n+        assert!(v.rposition(g).is_none());\n     }\n \n     #[test]\n     fn test_bsearch_elem() {\n-        assert_eq!(bsearch_elem([1,2,3,4,5], &5), Some(4));\n-        assert_eq!(bsearch_elem([1,2,3,4,5], &4), Some(3));\n-        assert_eq!(bsearch_elem([1,2,3,4,5], &3), Some(2));\n-        assert_eq!(bsearch_elem([1,2,3,4,5], &2), Some(1));\n-        assert_eq!(bsearch_elem([1,2,3,4,5], &1), Some(0));\n+        assert_eq!([1,2,3,4,5].bsearch_elem(&5), Some(4));\n+        assert_eq!([1,2,3,4,5].bsearch_elem(&4), Some(3));\n+        assert_eq!([1,2,3,4,5].bsearch_elem(&3), Some(2));\n+        assert_eq!([1,2,3,4,5].bsearch_elem(&2), Some(1));\n+        assert_eq!([1,2,3,4,5].bsearch_elem(&1), Some(0));\n \n-        assert_eq!(bsearch_elem([2,4,6,8,10], &1), None);\n-        assert_eq!(bsearch_elem([2,4,6,8,10], &5), None);\n-        assert_eq!(bsearch_elem([2,4,6,8,10], &4), Some(1));\n-        assert_eq!(bsearch_elem([2,4,6,8,10], &10), Some(4));\n+        assert_eq!([2,4,6,8,10].bsearch_elem(&1), None);\n+        assert_eq!([2,4,6,8,10].bsearch_elem(&5), None);\n+        assert_eq!([2,4,6,8,10].bsearch_elem(&4), Some(1));\n+        assert_eq!([2,4,6,8,10].bsearch_elem(&10), Some(4));\n \n-        assert_eq!(bsearch_elem([2,4,6,8], &1), None);\n-        assert_eq!(bsearch_elem([2,4,6,8], &5), None);\n-        assert_eq!(bsearch_elem([2,4,6,8], &4), Some(1));\n-        assert_eq!(bsearch_elem([2,4,6,8], &8), Some(3));\n+        assert_eq!([2,4,6,8].bsearch_elem(&1), None);\n+        assert_eq!([2,4,6,8].bsearch_elem(&5), None);\n+        assert_eq!([2,4,6,8].bsearch_elem(&4), Some(1));\n+        assert_eq!([2,4,6,8].bsearch_elem(&8), Some(3));\n \n-        assert_eq!(bsearch_elem([2,4,6], &1), None);\n-        assert_eq!(bsearch_elem([2,4,6], &5), None);\n-        assert_eq!(bsearch_elem([2,4,6], &4), Some(1));\n-        assert_eq!(bsearch_elem([2,4,6], &6), Some(2));\n+        assert_eq!([2,4,6].bsearch_elem(&1), None);\n+        assert_eq!([2,4,6].bsearch_elem(&5), None);\n+        assert_eq!([2,4,6].bsearch_elem(&4), Some(1));\n+        assert_eq!([2,4,6].bsearch_elem(&6), Some(2));\n \n-        assert_eq!(bsearch_elem([2,4], &1), None);\n-        assert_eq!(bsearch_elem([2,4], &5), None);\n-        assert_eq!(bsearch_elem([2,4], &2), Some(0));\n-        assert_eq!(bsearch_elem([2,4], &4), Some(1));\n+        assert_eq!([2,4].bsearch_elem(&1), None);\n+        assert_eq!([2,4].bsearch_elem(&5), None);\n+        assert_eq!([2,4].bsearch_elem(&2), Some(0));\n+        assert_eq!([2,4].bsearch_elem(&4), Some(1));\n \n-        assert_eq!(bsearch_elem([2], &1), None);\n-        assert_eq!(bsearch_elem([2], &5), None);\n-        assert_eq!(bsearch_elem([2], &2), Some(0));\n+        assert_eq!([2].bsearch_elem(&1), None);\n+        assert_eq!([2].bsearch_elem(&5), None);\n+        assert_eq!([2].bsearch_elem(&2), Some(0));\n \n-        assert_eq!(bsearch_elem([], &1), None);\n-        assert_eq!(bsearch_elem([], &5), None);\n+        assert_eq!([].bsearch_elem(&1), None);\n+        assert_eq!([].bsearch_elem(&5), None);\n \n-        assert!(bsearch_elem([1,1,1,1,1], &1) != None);\n-        assert!(bsearch_elem([1,1,1,1,2], &1) != None);\n-        assert!(bsearch_elem([1,1,1,2,2], &1) != None);\n-        assert!(bsearch_elem([1,1,2,2,2], &1) != None);\n-        assert_eq!(bsearch_elem([1,2,2,2,2], &1), Some(0));\n+        assert!([1,1,1,1,1].bsearch_elem(&1) != None);\n+        assert!([1,1,1,1,2].bsearch_elem(&1) != None);\n+        assert!([1,1,1,2,2].bsearch_elem(&1) != None);\n+        assert!([1,1,2,2,2].bsearch_elem(&1) != None);\n+        assert_eq!([1,2,2,2,2].bsearch_elem(&1), Some(0));\n \n-        assert_eq!(bsearch_elem([1,2,3,4,5], &6), None);\n-        assert_eq!(bsearch_elem([1,2,3,4,5], &0), None);\n+        assert_eq!([1,2,3,4,5].bsearch_elem(&6), None);\n+        assert_eq!([1,2,3,4,5].bsearch_elem(&0), None);\n     }\n \n     #[test]\n     fn reverse_and_reversed() {\n         let mut v: ~[int] = ~[10, 20];\n         assert_eq!(v[0], 10);\n         assert_eq!(v[1], 20);\n-        reverse(v);\n+        v.reverse();\n         assert_eq!(v[0], 20);\n         assert_eq!(v[1], 10);\n         let v2 = reversed::<int>([10, 20]);\n@@ -3161,7 +2853,7 @@ mod tests {\n         let v4 = reversed::<int>([]);\n         assert_eq!(v4, ~[]);\n         let mut v3: ~[int] = ~[];\n-        reverse::<int>(v3);\n+        v3.reverse();\n     }\n \n     #[test]\n@@ -3550,7 +3242,7 @@ mod tests {\n     fn test_map_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do map(v) |_elt| {\n+        do v.map |_elt| {\n             if i == 2 {\n                 fail!()\n             }\n@@ -3574,44 +3266,13 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_mapi_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do mapi(v) |_i, _elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            ~[(~0, @0)]\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]\n     fn test_flat_map_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do map(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            ~[(~0, @0)]\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_map_zip_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do map_zip(v, v) |_elt1, _elt2| {\n+        do flat_map(v) |_elt| {\n             if i == 2 {\n                 fail!()\n             }\n@@ -3658,7 +3319,7 @@ mod tests {\n     fn test_rposition_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do rposition(v) |_elt| {\n+        do v.rposition |_elt| {\n             if i == 2 {\n                 fail!()\n             }\n@@ -3810,7 +3471,7 @@ mod tests {\n     #[test]\n     fn test_reverse_part() {\n         let mut values = [1,2,3,4,5];\n-        reverse(values.mut_slice(1, 4));\n+        values.mut_slice(1, 4).reverse();\n         assert_eq!(values, [1,4,3,2,5]);\n     }\n "}, {"sha": "529d5bfe70b49f8a6c975024e209ba9433eb0b8a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -814,7 +814,7 @@ mod test {\n     // convert a list of uints to an @[ident]\n     // (ignores the interner completely)\n     fn uints_to_idents (uints: &~[uint]) -> @~[ident] {\n-        @uints.map(|u|{ ident {name:*u, ctxt: empty_ctxt} })\n+        @uints.map(|u| ident {name:*u, ctxt: empty_ctxt})\n     }\n \n     fn id (u : uint, s: SyntaxContext) -> ident {"}, {"sha": "405f9e3438beb1b23706c7089107577c1bcb0ba8", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -91,9 +91,9 @@ fn decodable_substructure(cx: @ExtCtxt, span: span,\n                     }\n                 }\n                 Right(ref fields) => {\n-                    let fields = do fields.mapi |i, f| {\n+                    let fields = do fields.iter().enumerate().transform |(i, f)| {\n                         cx.field_imm(span, *f, getarg(cx.str_of(*f), i))\n-                    };\n+                    }.collect();\n                     cx.expr_struct_ident(span, substr.type_ident, fields)\n                 }\n             };\n@@ -133,9 +133,9 @@ fn decodable_substructure(cx: @ExtCtxt, span: span,\n                         }\n                     }\n                     Right(ref fields) => {\n-                        let fields = do fields.mapi |i, f| {\n+                        let fields = do fields.iter().enumerate().transform |(i, f)| {\n                             cx.field_imm(span, *f, getarg(i))\n-                        };\n+                        }.collect();\n                         cx.expr_struct_ident(span, name, fields)\n                     }\n                 };"}, {"sha": "0e4fc9d96fa875cad58d3e626875b6aea3e6915e", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -591,14 +591,14 @@ impl<'self> MethodDef<'self> {\n         // transpose raw_fields\n         let fields = match raw_fields {\n             [self_arg, .. rest] => {\n-                do self_arg.mapi |i, &(opt_id, field)| {\n+                do self_arg.iter().enumerate().transform |(i, &(opt_id, field))| {\n                     let other_fields = do rest.map |l| {\n                         match &l[i] {\n                             &(_, ex) => ex\n                         }\n                     };\n                     (opt_id, field, other_fields)\n-                }\n+                }.collect()\n             }\n             [] => { cx.span_bug(span, \"No self arguments to non-static \\\n                                        method in generic `deriving`\") }\n@@ -745,10 +745,11 @@ impl<'self> MethodDef<'self> {\n                         }\n                     }\n                     let field_tuples =\n-                        do vec::map_zip(*self_vec,\n-                                        enum_matching_fields) |&(id, self_f), &other| {\n+                        do self_vec.iter()\n+                           .zip(enum_matching_fields.iter())\n+                           .transform |(&(id, self_f), &other)| {\n                         (id, self_f, other)\n-                    };\n+                    }.collect();\n                     substructure = EnumMatching(variant_index, variant, field_tuples);\n                 }\n                 None => {"}, {"sha": "cc2050d9bd7a0a31bc4ad4c2a5f23258af7de010", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -91,7 +91,7 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n             let rand_variant = cx.expr_binary(span, ast::rem,\n                                               rv_call, variant_count);\n \n-            let mut arms = do variants.mapi |i, id_sum| {\n+            let mut arms = do variants.iter().enumerate().transform |(i, id_sum)| {\n                 let i_expr = cx.expr_uint(span, i);\n                 let pat = cx.pat_lit(span, i_expr);\n \n@@ -102,7 +102,7 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n                                rand_thing(cx, span, ident, summary, || rand_call()))\n                     }\n                 }\n-            };\n+            }.collect::<~[ast::arm]>();\n \n             // _ => {} at the end. Should never occur\n             arms.push(cx.arm_unreachable(span));"}, {"sha": "0e24725ea990ce86e109e2c1a2f8c186c7280fe7", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -54,8 +54,9 @@ impl gen_send for message {\n             let next = this.proto.get_state(next_state.state);\n             assert!(next_state.tys.len() ==\n                 next.generics.ty_params.len());\n-            let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n-            let args_ast = vec::map_zip(arg_names, *tys, |n, t| cx.arg(span, *n, *t));\n+            let arg_names = vec::from_fn(tys.len(), |i| cx.ident_of(\"x_\"+i.to_str()));\n+            let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n+                .transform(|(n, t)| cx.arg(span, *n, *t)).collect();\n \n             let pipe_ty = cx.ty_path(\n                 path(~[this.data_name()], span)\n@@ -133,11 +134,10 @@ impl gen_send for message {\n \n             message(ref _id, span, ref tys, this, None) => {\n                 debug!(\"pipec: no next state\");\n-                let arg_names = tys.mapi(|i, _ty| (~\"x_\" + i.to_str()));\n+                let arg_names = vec::from_fn(tys.len(), |i| \"x_\" + i.to_str());\n \n-                let args_ast = do vec::map_zip(arg_names, *tys) |n, t| {\n-                    cx.arg(span, cx.ident_of(*n), *t)\n-                };\n+                let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n+                    .transform(|(n, t)| cx.arg(span, cx.ident_of(*n), *t)).collect();\n \n                 let args_ast = vec::append(\n                     ~[cx.arg(span,"}, {"sha": "f6325c2eb2c123819e826be1997dde393edcded9", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -21,7 +21,6 @@ use print::pprust;\n \n use std::io;\n use std::result;\n-use std::vec;\n \n // These macros all relate to the file system; they either return\n // the column/row/filename of the expression, or they include\n@@ -106,9 +105,7 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n       result::Ok(src) => {\n-        let u8_exprs = vec::map(src, |char| {\n-            cx.expr_u8(sp, *char)\n-        });\n+        let u8_exprs: ~[@ast::expr] = src.iter().transform(|char| cx.expr_u8(sp, *char)).collect();\n         base::MRExpr(cx.expr_vec(sp, u8_exprs))\n       }\n       result::Err(ref e) => {"}, {"sha": "cddba3583734d9e1003b4eba8070e6d7224f7872", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -326,8 +326,7 @@ pub fn parse(\n                         cur_eis.push(new_ei);\n                     }\n \n-                    let matches = vec::map(ei.matches, // fresh, same size:\n-                                           |_m| ~[]);\n+                    let matches = vec::from_elem(ei.matches.len(), ~[]);\n                     let ei_t = ei;\n                     cur_eis.push(~MatcherPos {\n                         elts: copy *matchers,"}, {"sha": "4e1451239962f5937fe1069928f5f63ee4e11201", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -699,7 +699,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n // ...nor do modules\n pub fn noop_fold_mod(m: &_mod, fld: @ast_fold) -> _mod {\n     ast::_mod {\n-        view_items: vec::map(m.view_items, |x| fld.fold_view_item(*x)),\n+        view_items: m.view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n         items: vec::filter_mapped(m.items, |x| fld.fold_item(*x)),\n     }\n }\n@@ -708,8 +708,8 @@ fn noop_fold_foreign_mod(nm: &foreign_mod, fld: @ast_fold) -> foreign_mod {\n     ast::foreign_mod {\n         sort: nm.sort,\n         abis: nm.abis,\n-        view_items: vec::map(nm.view_items, |x| fld.fold_view_item(*x)),\n-        items: vec::map(nm.items, |x| fld.fold_foreign_item(*x)),\n+        view_items: nm.view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n+        items: nm.items.iter().transform(|x| fld.fold_foreign_item(*x)).collect(),\n     }\n }\n \n@@ -728,8 +728,8 @@ fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n         }\n         struct_variant_kind(struct_def) => {\n             kind = struct_variant_kind(@ast::struct_def {\n-                fields: vec::map(struct_def.fields,\n-                                 |f| fld.fold_struct_field(*f)),\n+                fields: struct_def.fields.iter()\n+                    .transform(|f| fld.fold_struct_field(*f)).collect(),\n                 ctor_id: struct_def.ctor_id.map(|c| fld.new_id(*c))\n             })\n         }\n@@ -824,8 +824,7 @@ impl ast_fold for AstFoldFns {\n        @view_item {\n         @ast::view_item {\n             node: (self.fold_view_item)(&x.node, self as @ast_fold),\n-            attrs: vec::map(x.attrs, |a|\n-                  fold_attribute_(*a, self as @ast_fold)),\n+            attrs: x.attrs.iter().transform(|a| fold_attribute_(*a, self as @ast_fold)).collect(),\n             vis: x.vis,\n             span: (self.new_span)(x.span),\n         }"}, {"sha": "bc5efc5fca1f0ad26156a01c5e9f33d513a8fe23", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -191,13 +191,13 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n         // Do the BFS.\n         info!(\"PBFS iteration %?\", i);\n         i += 1;\n-        colors = do colors.mapi() |i, c| {\n+        colors = do colors.iter().enumerate().transform |(i, c)| {\n             let c : color = *c;\n             match c {\n               white => {\n                 let i = i as node_id;\n \n-                let neighbors = copy graph[i];\n+                let neighbors = &graph[i];\n \n                 let mut color = white;\n \n@@ -214,17 +214,17 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n               gray(parent) => { black(parent) }\n               black(parent) => { black(parent) }\n             }\n-        }\n+        }.collect()\n     }\n \n     // Convert the results.\n-    do vec::map(colors) |c| {\n+    do colors.iter().transform |c| {\n         match *c {\n           white => { -1i64 }\n           black(parent) => { parent }\n           _ => { fail!(\"Found remaining gray nodes in BFS\") }\n         }\n-    }\n+    }.collect()\n }\n \n /// A parallel version of the bfs function.\n@@ -341,7 +341,7 @@ fn validate(edges: ~[(node_id, node_id)],\n         }\n         else {\n             while parent != root {\n-                if vec::contains(path, &parent) {\n+                if path.contains(&parent) {\n                     status = false;\n                 }\n "}, {"sha": "deb2d4b300bc625114bae1df65fe3aaef9eedbf8", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -152,7 +152,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n \n     // these channels will allow us to talk to each creature by 'name'/index\n     let to_creature: ~[Chan<Option<CreatureInfo>>] =\n-        vec::mapi(set, |ii, col| {\n+        set.iter().enumerate().transform(|(ii, col)| {\n             // create each creature as a listener with a port, and\n             // give us a channel to talk to each\n             let ii = ii;\n@@ -166,7 +166,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n                          to_rendezvous_log.clone());\n             }\n             to_creature\n-        });\n+        }).collect();\n \n     let mut creatures_met = 0;\n "}, {"sha": "974cdb0a0ef6320c7e6782e0ea74c9884fb32b3d", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-pretty (extra blank line is inserted in vec::mapi call)\n+// xfail-pretty the `let to_child` line gets an extra newline\n // multi tasking k-nucleotide\n \n extern mod extra;\n@@ -163,14 +163,13 @@ fn main() {\n \n \n \n-   // initialize each sequence sorter\n-   let sizes = ~[1,2,3,4,6,12,18];\n-    let streams = vec::map(sizes, |_sz| Some(stream()));\n-    let mut streams = streams;\n+    // initialize each sequence sorter\n+    let sizes = ~[1u,2,3,4,6,12,18];\n+    let mut streams = vec::from_fn(sizes.len(), |_| Some(stream::<~str>()));\n     let mut from_child = ~[];\n-    let to_child   = vec::mapi(sizes, |ii, sz| {\n+    let to_child   = do sizes.iter().zip(streams.mut_iter()).transform |(sz, stream_ref)| {\n         let sz = *sz;\n-        let stream = util::replace(&mut streams[ii], None);\n+        let stream = util::replace(stream_ref, None);\n         let (from_child_, to_parent_) = stream.unwrap();\n \n         from_child.push(from_child_);\n@@ -182,7 +181,7 @@ fn main() {\n         };\n \n         to_child\n-    });\n+    }.collect::<~[Chan<~[u8]>]>();\n \n \n    // latch stores true after we've started"}, {"sha": "e61de0ac11f4c45ad1e490a8bbff0d97b441c50b", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -30,7 +30,7 @@ use std::io::WriterUtil;\n \n // Make sure this import is warned about when at least one of its imported names\n // is unused\n-use std::vec::{filter, map};   //~ ERROR unused import\n+use std::vec::{filter, from_elem};   //~ ERROR unused import\n \n mod foo {\n     pub struct Point{x: int, y: int}\n@@ -58,7 +58,5 @@ fn main() {\n     let a = 3;\n     ignore(a);\n     io::stdout().write_str(\"a\");\n-    let _a = do map([2]) |&x| {\n-      x + 2\n-    };\n+    let _a = from_elem(0, 0);\n }"}, {"sha": "fec0f89adbaf8a89f8bd08165619a3a2d918d7f8", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -1,8 +1,6 @@\n // Tests that references to move-by-default values trigger moves when\n // they occur as part of various kinds of expressions.\n \n-use std::vec;\n-\n struct Foo<A> { f: A }\n fn guard(_s: ~str) -> bool {fail!()}\n fn touch<A>(_a: &A) {}\n@@ -92,7 +90,7 @@ fn f110() {\n \n fn f120() {\n     let mut x = ~[~\"hi\", ~\"ho\"];\n-    vec::swap(x, 0, 1);\n+    x.swap(0, 1);\n     touch(&x[0]);\n     touch(&x[1]);\n }"}, {"sha": "8ea2a88fa09a793319e26f9b25b6742f41d1413f", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -28,7 +28,7 @@ pub fn main() {\n     assert!(any_negative);\n \n     // Higher precedence than unary operations:\n-    let abs_v = do vec::map(v) |e| { e.abs() };\n+    let abs_v = do v.iter().transform |e| { e.abs() }.collect::<~[float]>();\n     assert!(do abs_v.iter().all |e| { e.is_positive() });\n     assert!(!do abs_v.iter().any_ |e| { e.is_negative() });\n "}, {"sha": "739dbab4d3af4f25e7e7d3abfc0f118df07c3bcd", "filename": "src/test/run-pass/block-vec-map_zip.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d5c5ce3f8d07ba7f9059727a790ce19f7a1599b7/src%2Ftest%2Frun-pass%2Fblock-vec-map_zip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5c5ce3f8d07ba7f9059727a790ce19f7a1599b7/src%2Ftest%2Frun-pass%2Fblock-vec-map_zip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-vec-map_zip.rs?ref=d5c5ce3f8d07ba7f9059727a790ce19f7a1599b7", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::vec;\n-\n-pub fn main() {\n-    let v =\n-        vec::map_zip(~[1, 2, 3, 4, 5],\n-                  ~[true, false, false, true, true],\n-                  |i, b| if *b { -(*i) } else { *i } );\n-    error!(v.clone());\n-    assert_eq!(v, ~[-1, 2, 3, -4, -5]);\n-}"}, {"sha": "356c1596186966693da74c9bb66199d6c189fc07", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-arg.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -1,13 +1,11 @@\n-use std::vec;\n-\n-trait Reverser {\n-    fn reverse(&self);\n+fn reverse(v: &mut [uint]) {\n+    v.reverse();\n }\n \n fn bar(v: &mut [uint]) {\n-    vec::reverse(v);\n-    vec::reverse(v);\n-    vec::reverse(v);\n+    reverse(v);\n+    reverse(v);\n+    reverse(v);\n }\n \n pub fn main() {"}, {"sha": "556d70f3c88a28cae38d89e20956e3d1e3e6e8cf", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-rcvr.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -1,15 +1,3 @@\n-use std::vec;\n-\n-trait Reverser {\n-    fn reverse(self);\n-}\n-\n-impl<'self> Reverser for &'self mut [uint] {\n-    fn reverse(self) {\n-        vec::reverse(self);\n-    }\n-}\n-\n fn bar(v: &mut [uint]) {\n     v.reverse();\n     v.reverse();"}, {"sha": "a24800e4dbb25ec619356f69f8e378a876537134", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -69,9 +69,7 @@ fn AsciiArt(width: uint, height: uint, fill: char) -> AsciiArt {\n     // blank characters for each position in our canvas.\n     let mut lines = do vec::build_sized(height) |push| {\n             for height.times {\n-                let mut line = ~[];\n-                vec::grow_set(&mut line, width-1, &'.', '.');\n-                push(line);\n+                push(vec::from_elem(width, '.'));\n             }\n         };\n "}, {"sha": "2ec2eb3c45b573e51db7ad95c2b943aafb7b67ca", "filename": "src/test/run-pass/swap-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Frun-pass%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Frun-pass%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-2.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n use std::util;\n-use std::vec;\n \n pub fn main() {\n     let mut a: ~[int] = ~[0, 1, 2, 3, 4, 5, 6];\n-    vec::swap(a, 2, 4);\n+    a.swap(2, 4);\n     assert_eq!(a[2], 4);\n     assert_eq!(a[4], 2);\n     let mut n = 42;"}, {"sha": "3e4cfdc105cadb966debf83ebfc0cae52902e073", "filename": "src/test/run-pass/trait-to-str.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07feeb95c5e73c5d871c7e365cf4a7138774d449/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs?ref=07feeb95c5e73c5d871c7e365cf4a7138774d449", "patch": "@@ -15,7 +15,9 @@\n extern mod std;\n \n use std::str::StrVector;\n-use std::{int, vec};\n+use std::vec::ImmutableVector;\n+use std::iterator::IteratorUtil;\n+use std::int;\n \n trait to_str {\n     fn to_str(&self) -> ~str;\n@@ -27,7 +29,7 @@ impl to_str for int {\n \n impl<T:to_str> to_str for ~[T] {\n     fn to_str(&self) -> ~str {\n-        ~\"[\" + vec::map(*self, |e| e.to_str()).connect(\", \") + \"]\"\n+        fmt!(\"[%s]\", self.iter().transform(|e| e.to_str()).collect::<~[~str]>().connect(\", \"))\n     }\n }\n "}]}