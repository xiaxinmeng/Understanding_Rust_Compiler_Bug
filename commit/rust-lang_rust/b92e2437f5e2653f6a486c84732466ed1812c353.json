{"sha": "b92e2437f5e2653f6a486c84732466ed1812c353", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MmUyNDM3ZjVlMjY1M2Y2YTQ4NmM4NDczMjQ2NmVkMTgxMmMzNTM=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-31T17:17:15Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-02-23T09:43:52Z"}, "message": "[MIR] Change SimplifyCfg pass to use bitvec\n\nBitVector is much more space efficient.", "tree": {"sha": "939540804264df6ce175378399fac6bbcc8de8e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/939540804264df6ce175378399fac6bbcc8de8e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b92e2437f5e2653f6a486c84732466ed1812c353", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b92e2437f5e2653f6a486c84732466ed1812c353", "html_url": "https://github.com/rust-lang/rust/commit/b92e2437f5e2653f6a486c84732466ed1812c353", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b92e2437f5e2653f6a486c84732466ed1812c353/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be7196a793a185355efb7ec8801102ddec95483d", "url": "https://api.github.com/repos/rust-lang/rust/commits/be7196a793a185355efb7ec8801102ddec95483d", "html_url": "https://github.com/rust-lang/rust/commit/be7196a793a185355efb7ec8801102ddec95483d"}], "stats": {"total": 176, "additions": 113, "deletions": 63}, "files": [{"sha": "7b5dacece8c203b275d42f99f162c2067a3c6dc1", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b92e2437f5e2653f6a486c84732466ed1812c353/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92e2437f5e2653f6a486c84732466ed1812c353/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=b92e2437f5e2653f6a486c84732466ed1812c353", "patch": "@@ -50,6 +50,45 @@ impl BitVector {\n         let extra_words = self.data.len() - num_words;\n         self.data.extend((0..extra_words).map(|_| 0));\n     }\n+\n+    /// Iterates over indexes of set bits in a sorted order\n+    pub fn iter<'a>(&'a self) -> BitVectorIter<'a> {\n+        BitVectorIter {\n+            iter: self.data.iter(),\n+            current: 0,\n+            idx: 0\n+        }\n+    }\n+}\n+\n+pub struct BitVectorIter<'a> {\n+    iter: ::std::slice::Iter<'a, u64>,\n+    current: u64,\n+    idx: usize\n+}\n+\n+impl<'a> Iterator for BitVectorIter<'a> {\n+    type Item = usize;\n+    fn next(&mut self) -> Option<usize> {\n+        while self.current == 0 {\n+            self.current = if let Some(&i) = self.iter.next() {\n+                if i == 0 {\n+                    self.idx += 64;\n+                    continue;\n+                } else {\n+                    self.idx = u64s(self.idx) * 64;\n+                    i\n+                }\n+            } else {\n+                return None;\n+            }\n+        }\n+        let offset = self.current.trailing_zeros() as usize;\n+        self.current >>= offset;\n+        self.current >>= 1; // shift otherwise overflows for 0b1000_0000_\u2026_0000\n+        self.idx += offset + 1;\n+        return Some(self.idx - 1);\n+    }\n }\n \n /// A \"bit matrix\" is basically a square matrix of booleans\n@@ -153,6 +192,46 @@ fn word_mask(index: usize) -> (usize, u64) {\n     (word, mask)\n }\n \n+#[test]\n+fn bitvec_iter_works() {\n+    let mut bitvec = BitVector::new(100);\n+    bitvec.insert(1);\n+    bitvec.insert(10);\n+    bitvec.insert(19);\n+    bitvec.insert(62);\n+    bitvec.insert(63);\n+    bitvec.insert(64);\n+    bitvec.insert(65);\n+    bitvec.insert(66);\n+    bitvec.insert(99);\n+    assert_eq!(bitvec.iter().collect::<Vec<_>>(), [1, 10, 19, 62, 63, 64, 65, 66, 99]);\n+}\n+\n+#[test]\n+fn bitvec_iter_works_2() {\n+    let mut bitvec = BitVector::new(300);\n+    bitvec.insert(1);\n+    bitvec.insert(10);\n+    bitvec.insert(19);\n+    bitvec.insert(62);\n+    bitvec.insert(66);\n+    bitvec.insert(99);\n+    bitvec.insert(299);\n+    assert_eq!(bitvec.iter().collect::<Vec<_>>(), [1, 10, 19, 62, 66, 99, 299]);\n+\n+}\n+\n+#[test]\n+fn bitvec_iter_works_3() {\n+    let mut bitvec = BitVector::new(319);\n+    bitvec.insert(0);\n+    bitvec.insert(127);\n+    bitvec.insert(191);\n+    bitvec.insert(255);\n+    bitvec.insert(319);\n+    assert_eq!(bitvec.iter().collect::<Vec<_>>(), [0, 127, 191, 255, 319]);\n+}\n+\n #[test]\n fn union_two_vecs() {\n     let mut vec1 = BitVector::new(65);"}, {"sha": "adca68114fd0152e929c8719ab5077fd064f95df", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b92e2437f5e2653f6a486c84732466ed1812c353/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92e2437f5e2653f6a486c84732466ed1812c353/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=b92e2437f5e2653f6a486c84732466ed1812c353", "patch": "@@ -13,4 +13,3 @@ pub mod simplify_cfg;\n pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;\n-mod util;"}, {"sha": "785e6db57a53843f8089deecb23414064beac26d", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b92e2437f5e2653f6a486c84732466ed1812c353/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92e2437f5e2653f6a486c84732466ed1812c353/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=b92e2437f5e2653f6a486c84732466ed1812c353", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc_data_structures::bitvec::BitVector;\n use rustc::middle::const_eval::ConstVal;\n use rustc::middle::infer;\n use rustc::mir::repr::*;\n-use transform::util;\n use rustc::mir::transform::MirPass;\n \n pub struct SimplifyCfg;\n@@ -22,23 +22,21 @@ impl SimplifyCfg {\n     }\n \n     fn remove_dead_blocks(&self, mir: &mut Mir) {\n-        let mut seen = vec![false; mir.basic_blocks.len()];\n-\n+        let mut seen = BitVector::new(mir.basic_blocks.len());\n         // These blocks are always required.\n-        seen[START_BLOCK.index()] = true;\n-        seen[END_BLOCK.index()] = true;\n+        seen.insert(START_BLOCK.index());\n+        seen.insert(END_BLOCK.index());\n \n-        let mut worklist = vec![START_BLOCK];\n+        let mut worklist = Vec::with_capacity(4);\n+        worklist.push(START_BLOCK);\n         while let Some(bb) = worklist.pop() {\n             for succ in mir.basic_block_data(bb).terminator().successors().iter() {\n-                if !seen[succ.index()] {\n-                    seen[succ.index()] = true;\n+                if seen.insert(succ.index()) {\n                     worklist.push(*succ);\n                 }\n             }\n         }\n-\n-        util::retain_basic_blocks(mir, &seen);\n+        retain_basic_blocks(mir, &seen);\n     }\n \n     fn remove_goto_chains(&self, mir: &mut Mir) -> bool {\n@@ -90,12 +88,12 @@ impl SimplifyCfg {\n         for bb in mir.all_basic_blocks() {\n             let basic_block = mir.basic_block_data_mut(bb);\n             let mut terminator = basic_block.terminator_mut();\n-\n             *terminator = match *terminator {\n                 Terminator::If { ref targets, .. } if targets.0 == targets.1 => {\n                     changed = true;\n                     Terminator::Goto { target: targets.0 }\n                 }\n+\n                 Terminator::If { ref targets, cond: Operand::Constant(Constant {\n                     literal: Literal::Value {\n                         value: ConstVal::Bool(cond)\n@@ -108,6 +106,7 @@ impl SimplifyCfg {\n                         Terminator::Goto { target: targets.1 }\n                     }\n                 }\n+\n                 Terminator::SwitchInt { ref targets, .. }  if targets.len() == 1 => {\n                     Terminator::Goto { target: targets[0] }\n                 }\n@@ -131,3 +130,27 @@ impl MirPass for SimplifyCfg {\n         mir.basic_blocks.shrink_to_fit();\n     }\n }\n+\n+/// Mass removal of basic blocks to keep the ID-remapping cheap.\n+fn retain_basic_blocks(mir: &mut Mir, keep: &BitVector) {\n+    let num_blocks = mir.basic_blocks.len();\n+\n+    let mut replacements: Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n+    let mut used_blocks = 0;\n+    for alive_index in keep.iter() {\n+        replacements[alive_index] = BasicBlock::new(used_blocks);\n+        if alive_index != used_blocks {\n+            // Swap the next alive block data with the current available slot. Since alive_index is\n+            // non-decreasing this is a valid operation.\n+            mir.basic_blocks.swap(alive_index, used_blocks);\n+        }\n+        used_blocks += 1;\n+    }\n+    mir.basic_blocks.truncate(used_blocks);\n+\n+    for bb in mir.all_basic_blocks() {\n+        for target in mir.basic_block_data_mut(bb).terminator_mut().successors_mut() {\n+            *target = replacements[target.index()];\n+        }\n+    }\n+}"}, {"sha": "7e44beb18a2e96c8029a5bf61974308ba0fa383f", "filename": "src/librustc_mir/transform/util.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/be7196a793a185355efb7ec8801102ddec95483d/src%2Flibrustc_mir%2Ftransform%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7196a793a185355efb7ec8801102ddec95483d/src%2Flibrustc_mir%2Ftransform%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Futil.rs?ref=be7196a793a185355efb7ec8801102ddec95483d", "patch": "@@ -1,51 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::mir::repr::*;\n-\n-/// Update basic block ids in all terminators using the given replacements,\n-/// useful e.g. after removal of several basic blocks to update all terminators\n-/// in a single pass\n-pub fn update_basic_block_ids(mir: &mut Mir, replacements: &[BasicBlock]) {\n-    for bb in mir.all_basic_blocks() {\n-        for target in mir.basic_block_data_mut(bb).terminator_mut().successors_mut() {\n-            *target = replacements[target.index()];\n-        }\n-    }\n-}\n-\n-/// Mass removal of basic blocks to keep the ID-remapping cheap.\n-pub fn retain_basic_blocks(mir: &mut Mir, keep: &[bool]) {\n-    let num_blocks = mir.basic_blocks.len();\n-\n-    // Check that we have a usage flag for every block\n-    assert_eq!(num_blocks, keep.len());\n-\n-    let first_dead = match keep.iter().position(|&k| !k) {\n-        None => return,\n-        Some(first_dead) => first_dead,\n-    };\n-\n-    // `replacements` maps the old block ids to the new ones\n-    let mut replacements: Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n-\n-    let mut dead = 0;\n-    for i in first_dead..num_blocks {\n-        if keep[i] {\n-            replacements[i] = BasicBlock::new(i - dead);\n-            mir.basic_blocks.swap(i, i - dead);\n-        } else {\n-            dead += 1;\n-        }\n-    }\n-    mir.basic_blocks.truncate(num_blocks - dead);\n-\n-    update_basic_block_ids(mir, &replacements);\n-}"}]}