{"sha": "47d5196a00e25ef5683fd58f472ce44c82f8ae06", "node_id": "C_kwDOAAsO6NoAKDQ3ZDUxOTZhMDBlMjVlZjU2ODNmZDU4ZjQ3MmNlNDRjODJmOGFlMDY", "commit": {"author": {"name": "Arthur Lafrance", "email": "lafrancearthur@gmail.com", "date": "2022-02-16T02:58:42Z"}, "committer": {"name": "Arthur Lafrance", "email": "lafrancearthur@gmail.com", "date": "2022-02-16T22:26:39Z"}, "message": "Add a `try_collect()` helper method to `Iterator`\n\nTweaked `try_collect()` to accept more `Try` types\n\nUpdated feature attribute for tracking issue", "tree": {"sha": "2536cd46a571fd021dc583124a1fa0bc036bb5b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2536cd46a571fd021dc583124a1fa0bc036bb5b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47d5196a00e25ef5683fd58f472ce44c82f8ae06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47d5196a00e25ef5683fd58f472ce44c82f8ae06", "html_url": "https://github.com/rust-lang/rust/commit/47d5196a00e25ef5683fd58f472ce44c82f8ae06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47d5196a00e25ef5683fd58f472ce44c82f8ae06/comments", "author": {"login": "a-lafrance", "id": 38890624, "node_id": "MDQ6VXNlcjM4ODkwNjI0", "avatar_url": "https://avatars.githubusercontent.com/u/38890624?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a-lafrance", "html_url": "https://github.com/a-lafrance", "followers_url": "https://api.github.com/users/a-lafrance/followers", "following_url": "https://api.github.com/users/a-lafrance/following{/other_user}", "gists_url": "https://api.github.com/users/a-lafrance/gists{/gist_id}", "starred_url": "https://api.github.com/users/a-lafrance/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a-lafrance/subscriptions", "organizations_url": "https://api.github.com/users/a-lafrance/orgs", "repos_url": "https://api.github.com/users/a-lafrance/repos", "events_url": "https://api.github.com/users/a-lafrance/events{/privacy}", "received_events_url": "https://api.github.com/users/a-lafrance/received_events", "type": "User", "site_admin": false}, "committer": {"login": "a-lafrance", "id": 38890624, "node_id": "MDQ6VXNlcjM4ODkwNjI0", "avatar_url": "https://avatars.githubusercontent.com/u/38890624?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a-lafrance", "html_url": "https://github.com/a-lafrance", "followers_url": "https://api.github.com/users/a-lafrance/followers", "following_url": "https://api.github.com/users/a-lafrance/following{/other_user}", "gists_url": "https://api.github.com/users/a-lafrance/gists{/gist_id}", "starred_url": "https://api.github.com/users/a-lafrance/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a-lafrance/subscriptions", "organizations_url": "https://api.github.com/users/a-lafrance/orgs", "repos_url": "https://api.github.com/users/a-lafrance/repos", "events_url": "https://api.github.com/users/a-lafrance/events{/privacy}", "received_events_url": "https://api.github.com/users/a-lafrance/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f90b06d7fb00470177516c5881bcec0432cb4f24", "url": "https://api.github.com/repos/rust-lang/rust/commits/f90b06d7fb00470177516c5881bcec0432cb4f24", "html_url": "https://github.com/rust-lang/rust/commit/f90b06d7fb00470177516c5881bcec0432cb4f24"}], "stats": {"total": 129, "additions": 129, "deletions": 0}, "files": [{"sha": "5a361edecd9c00298e95a3d91446d73a241a8f4d", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/47d5196a00e25ef5683fd58f472ce44c82f8ae06/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d5196a00e25ef5683fd58f472ce44c82f8ae06/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=47d5196a00e25ef5683fd58f472ce44c82f8ae06", "patch": "@@ -1,6 +1,7 @@\n use crate::cmp::{self, Ordering};\n use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, Residual, Try};\n \n+use super::super::try_process;\n use super::super::TrustedRandomAccessNoCoerce;\n use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n@@ -1777,6 +1778,87 @@ pub trait Iterator {\n         FromIterator::from_iter(self)\n     }\n \n+    /// Fallibly transforms an iterator into a collection, short circuiting if\n+    /// a failure is encountered.\n+    ///\n+    /// `try_collect()` is a variation of [`collect()`][`collect`] that allows fallible\n+    /// conversions during collection. Its main use case is simplifying conversions from\n+    /// iterators yielding [`Option<T>`][`Option`] into `Option<Collection<T>>`, or similarly for other [`Try`]\n+    /// types (e.g. [`Result`]).\n+    ///\n+    /// Importantly, `try_collect()` doesn't require that the outer [`Try`] type also implements [`FromIterator`];\n+    /// only the inner type produced on `Try::Output` must implement it. Concretely,\n+    /// this means that collecting into `ControlFlow<_, Vec<i32>>` is valid because `Vec<i32>` implements\n+    /// [`FromIterator`], even though [`ControlFlow`] doesn't.\n+    ///\n+    /// Also, if a failure is encountered during `try_collect()`, the iterator is still valid and\n+    /// may continue to be used, in which case it will continue iterating starting after the element that\n+    /// triggered the failure. See the last example below for an example of how this works.\n+    ///\n+    /// # Examples\n+    /// Successfully collecting an iterator of `Option<i32>` into `Option<Vec<i32>>`:\n+    /// ```\n+    /// #![feature(iterator_try_collect)]\n+    ///\n+    /// let u = vec![Some(1), Some(2), Some(3)];\n+    /// let v = u.into_iter().try_collect::<Vec<i32>>();\n+    /// assert_eq!(v, Some(vec![1, 2, 3]));\n+    /// ```\n+    ///\n+    /// Failing to collect in the same way:\n+    /// ```\n+    /// #![feature(iterator_try_collect)]\n+    ///\n+    /// let u = vec![Some(1), Some(2), None, Some(3)];\n+    /// let v = u.into_iter().try_collect::<Vec<i32>>();\n+    /// assert_eq!(v, None);\n+    /// ```\n+    ///\n+    /// A similar example, but with `Result`:\n+    /// ```\n+    /// #![feature(iterator_try_collect)]\n+    ///\n+    /// let u: Vec<Result<i32, ()>> = vec![Ok(1), Ok(2), Ok(3)];\n+    /// let v = u.into_iter().try_collect::<Vec<i32>>();\n+    /// assert_eq!(v, Ok(vec![1, 2, 3]));\n+    ///\n+    /// let u = vec![Ok(1), Ok(2), Err(()), Ok(3)];\n+    /// let v = u.into_iter().try_collect::<Vec<i32>>();\n+    /// assert_eq!(v, Err(()));\n+    /// ```\n+    ///\n+    /// Finally, even [`ControlFlow`] works, despite the fact that it\n+    /// doesn't implement [`FromIterator`]. Note also that the iterator can\n+    /// continue to be used, even if a failure is encountered:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_collect)]\n+    ///\n+    /// use core::ops::ControlFlow::{Break, Continue};\n+    ///\n+    /// let u = [Continue(1), Continue(2), Break(3), Continue(4), Continue(5)];\n+    /// let mut it = u.into_iter();\n+    ///\n+    /// let v = it.try_collect::<Vec<_>>();\n+    /// assert_eq!(v, Break(3));\n+    ///\n+    /// let v = it.try_collect::<Vec<_>>();\n+    /// assert_eq!(v, Continue(vec![4, 5]));\n+    /// ```\n+    ///\n+    /// [`collect`]: Iterator::collect\n+    #[inline]\n+    #[unstable(feature = \"iterator_try_collect\", issue = \"94047\")]\n+    fn try_collect<B>(&mut self) -> ChangeOutputType<Self::Item, B>\n+    where\n+        Self: Sized,\n+        <Self as Iterator>::Item: Try,\n+        <<Self as Iterator>::Item as Try>::Residual: Residual<B>,\n+        B: FromIterator<<Self::Item as Try>::Output>,\n+    {\n+        try_process(self, |i| i.collect())\n+    }\n+\n     /// Consumes an iterator, creating two collections from it.\n     ///\n     /// The predicate passed to `partition()` can return `true`, or `false`."}, {"sha": "cf69f0a7a4d7e7e687bf781a33f4b050554a3c87", "filename": "library/core/tests/iter/traits/iterator.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/47d5196a00e25ef5683fd58f472ce44c82f8ae06/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d5196a00e25ef5683fd58f472ce44c82f8ae06/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs?ref=47d5196a00e25ef5683fd58f472ce44c82f8ae06", "patch": "@@ -497,6 +497,52 @@ fn test_collect() {\n     assert!(a == b);\n }\n \n+#[test]\n+fn test_try_collect() {\n+    use core::ops::ControlFlow::{Break, Continue};\n+\n+    let u = vec![Some(1), Some(2), Some(3)];\n+    let v = u.into_iter().try_collect::<Vec<i32>>();\n+    assert_eq!(v, Some(vec![1, 2, 3]));\n+\n+    let u = vec![Some(1), Some(2), None, Some(3)];\n+    let mut it = u.into_iter();\n+    let v = it.try_collect::<Vec<i32>>();\n+    assert_eq!(v, None);\n+    let v = it.try_collect::<Vec<i32>>();\n+    assert_eq!(v, Some(vec![3]));\n+\n+    let u: Vec<Result<i32, ()>> = vec![Ok(1), Ok(2), Ok(3)];\n+    let v = u.into_iter().try_collect::<Vec<i32>>();\n+    assert_eq!(v, Ok(vec![1, 2, 3]));\n+\n+    let u = vec![Ok(1), Ok(2), Err(()), Ok(3)];\n+    let v = u.into_iter().try_collect::<Vec<i32>>();\n+    assert_eq!(v, Err(()));\n+\n+    let numbers = vec![1, 2, 3, 4, 5];\n+    let all_positive = numbers\n+        .iter()\n+        .cloned()\n+        .map(|n| if n > 0 { Some(n) } else { None })\n+        .try_collect::<Vec<i32>>();\n+    assert_eq!(all_positive, Some(numbers));\n+\n+    let numbers = vec![-2, -1, 0, 1, 2];\n+    let all_positive =\n+        numbers.into_iter().map(|n| if n > 0 { Some(n) } else { None }).try_collect::<Vec<i32>>();\n+    assert_eq!(all_positive, None);\n+\n+    let u = [Continue(1), Continue(2), Break(3), Continue(4), Continue(5)];\n+    let mut it = u.into_iter();\n+\n+    let v = it.try_collect::<Vec<_>>();\n+    assert_eq!(v, Break(3));\n+\n+    let v = it.try_collect::<Vec<_>>();\n+    assert_eq!(v, Continue(vec![4, 5]));\n+}\n+\n // just tests by whether or not this compiles\n fn _empty_impl_all_auto_traits<T>() {\n     use std::panic::{RefUnwindSafe, UnwindSafe};"}, {"sha": "32f3405243ceaa6d8cfff8ab074ddc5f22bff116", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47d5196a00e25ef5683fd58f472ce44c82f8ae06/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d5196a00e25ef5683fd58f472ce44c82f8ae06/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=47d5196a00e25ef5683fd58f472ce44c82f8ae06", "patch": "@@ -67,6 +67,7 @@\n #![feature(iter_intersperse)]\n #![feature(iter_is_partitioned)]\n #![feature(iter_order_by)]\n+#![feature(iterator_try_collect)]\n #![feature(iterator_try_reduce)]\n #![feature(const_mut_refs)]\n #![feature(const_pin)]"}]}