{"sha": "ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjOTE5ZmNkOWQ0YTk1OGJhZjk5YjJmMmVkNWMzZDM4YTJlYmY5ZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-03T05:58:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-03T05:58:01Z"}, "message": "Auto merge of #37541 - nikomatsakis:issue-37291, r=brson\n\nUse impl obligations as initial environment for specialization\n\nThis corrects a small regression in specialization that crept in, I think as part of the refactoring to introduce arenas. I also made an experiment (in the last commit) to cleanup the code to be more aggressive about normalization. As the commit log notes, I am not 100% sure that this is correct, but it feels safer, and I think that at worst it yields *more* ICEs (as opposed to admitting faulty code). I'll schedule a crater run to check beyond the testbase.\n\nFixes #37291.\n\nr? @aturon", "tree": {"sha": "88e3435d49f2f1e670cf8eba613210b4ddb495e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88e3435d49f2f1e670cf8eba613210b4ddb495e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0", "html_url": "https://github.com/rust-lang/rust/commit/ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9f45c6dacd0f0d0a44473931291a4fa6bbb4ddc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f45c6dacd0f0d0a44473931291a4fa6bbb4ddc", "html_url": "https://github.com/rust-lang/rust/commit/f9f45c6dacd0f0d0a44473931291a4fa6bbb4ddc"}, {"sha": "b4f910d9004f09620ef5b1aff5d676c1dab7d42f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4f910d9004f09620ef5b1aff5d676c1dab7d42f", "html_url": "https://github.com/rust-lang/rust/commit/b4f910d9004f09620ef5b1aff5d676c1dab7d42f"}], "stats": {"total": 118, "additions": 97, "deletions": 21}, "files": [{"sha": "24cafa7f7253a494736da22cd3e4a94ad4f01913", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0", "patch": "@@ -25,7 +25,7 @@ use hir::def_id::DefId;\n use infer::{InferCtxt, TypeOrigin};\n use middle::region;\n use ty::subst::{Subst, Substs};\n-use traits::{self, Reveal, ObligationCause, Normalized};\n+use traits::{self, Reveal, ObligationCause};\n use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n \n@@ -148,6 +148,8 @@ pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              impl1_def_id: DefId,\n                              impl2_def_id: DefId) -> bool {\n+    debug!(\"specializes({:?}, {:?})\", impl1_def_id, impl2_def_id);\n+\n     if let Some(r) = tcx.specializes_cache.borrow().check(impl1_def_id, impl2_def_id) {\n         return r;\n     }\n@@ -177,31 +179,24 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n-    let mut penv = tcx.construct_parameter_environment(DUMMY_SP,\n-                                                       impl1_def_id,\n-                                                       region::DUMMY_CODE_EXTENT);\n+    let penv = tcx.construct_parameter_environment(DUMMY_SP,\n+                                                   impl1_def_id,\n+                                                   region::DUMMY_CODE_EXTENT);\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id)\n                              .unwrap()\n                              .subst(tcx, &penv.free_substs);\n \n-    let result = tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|mut infcx| {\n-        // Normalize the trait reference, adding any obligations\n-        // that arise into the impl1 assumptions.\n-        let Normalized { value: impl1_trait_ref, obligations: normalization_obligations } = {\n-            let selcx = &mut SelectionContext::new(&infcx);\n-            traits::normalize(selcx, ObligationCause::dummy(), &impl1_trait_ref)\n-        };\n-        penv.caller_bounds.extend(normalization_obligations.into_iter().map(|o| {\n-            match tcx.lift_to_global(&o.predicate) {\n-                Some(predicate) => predicate,\n-                None => {\n-                    bug!(\"specializes: obligation `{:?}` has inference types/regions\", o);\n+    // Create a infcx, taking the predicates of impl1 as assumptions:\n+    let result = tcx.infer_ctxt(None, Some(penv), Reveal::ExactMatch).enter(|infcx| {\n+        // Normalize the trait reference. The WF rules ought to ensure\n+        // that this always succeeds.\n+        let impl1_trait_ref =\n+            match traits::fully_normalize(&infcx, ObligationCause::dummy(), &impl1_trait_ref) {\n+                Ok(impl1_trait_ref) => impl1_trait_ref,\n+                Err(err) => {\n+                    bug!(\"failed to fully normalize {:?}: {:?}\", impl1_trait_ref, err);\n                 }\n-            }\n-        }));\n-\n-        // Install the parameter environment, taking the predicates of impl1 as assumptions:\n-        infcx.parameter_environment = penv;\n+            };\n \n         // Attempt to prove that impl2 applies, given all of the above.\n         fulfill_implication(&infcx, impl1_trait_ref, impl2_def_id).is_ok()"}, {"sha": "67cdea807beebd65ed5e133cc6fea5b68fa0b6da", "filename": "src/test/run-pass/issue-37291/auxiliary/lib.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0/src%2Ftest%2Frun-pass%2Fissue-37291%2Fauxiliary%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0/src%2Ftest%2Frun-pass%2Fissue-37291%2Fauxiliary%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-37291%2Fauxiliary%2Flib.rs?ref=ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+use std::ops::Mul;\n+\n+pub trait A {}\n+pub trait B {\n+    type AT: A;\n+}\n+pub trait C {\n+    type BT: B;\n+}\n+\n+pub struct AV;\n+impl A for AV {}\n+\n+pub struct BV;\n+impl B for BV {\n+    type AT = AV;\n+}\n+\n+pub struct CV;\n+impl C for CV {\n+    type BT = BV;\n+}\n+\n+pub struct WrapperB<T>(pub T);\n+pub struct WrapperC<T>(pub T);\n+\n+impl<C1> Mul<WrapperB<<C1::BT as B>::AT>> for WrapperC<C1>\n+    where C1: C\n+{\n+    type Output = u8;\n+    fn mul(self, _: WrapperB<<C1::BT as B>::AT>) -> Self::Output {\n+        loop {}\n+    }\n+}\n+impl<C1> Mul<WrapperC<C1>> for WrapperC<C1> {\n+    type Output = u8;\n+    fn mul(self, _: WrapperC<C1>) -> Self::Output {\n+        loop {}\n+    }\n+}"}, {"sha": "2461f7485f26feb93dfc5528779ed16ffd6a9b97", "filename": "src/test/run-pass/issue-37291/main.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0/src%2Ftest%2Frun-pass%2Fissue-37291%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0/src%2Ftest%2Frun-pass%2Fissue-37291%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-37291%2Fmain.rs?ref=ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lib.rs\n+\n+// Regression test for #37291. The problem was that the starting\n+// environment for a specialization check was not including the\n+// where-clauses from the impl when attempting to normalize the impl's\n+// trait-ref, so things like `<C as Foo>::Item` could not resolve,\n+// since the `C: Foo` trait bound was not included in the environment.\n+\n+extern crate lib;\n+\n+use lib::{CV, WrapperB, WrapperC};\n+\n+fn main() {\n+    let a = WrapperC(CV);\n+    let b = WrapperC(CV);\n+    if false {\n+        let _ = a * b;\n+    }\n+}"}]}