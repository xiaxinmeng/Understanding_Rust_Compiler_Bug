{"sha": "b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "node_id": "C_kwDOAAsO6NoAKGI2OThhMTUxYjNlYjFjNmNkNmE3MGQzZTlkOWQwYWFiMjcxMWY2NzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-24T20:21:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-24T20:21:08Z"}, "message": "Auto merge of #8437 - est31:let_else_lint, r=flip1995\n\nAdd lint to tell about let else pattern\n\nAdds a lint to tell the user if the let_else pattern should be used.\n\n~~The PR is blocked probably on rustfmt support, as clippy shouldn't suggest features that aren't yet fully supported by all tools.~~ Edit: I guess adding it as a restriction lint for now is the best option, it can be turned into a style lint later.\n\n---\n\nchangelog: addition of a new lint to check for manual `let else`", "tree": {"sha": "ee779d6e190d7fcad34fdf7f5d07123905cd1441", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee779d6e190d7fcad34fdf7f5d07123905cd1441"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "html_url": "https://github.com/rust-lang/rust/commit/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b09d4e1f7082aff024faf27263f78e7fc7190a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b09d4e1f7082aff024faf27263f78e7fc7190a2", "html_url": "https://github.com/rust-lang/rust/commit/5b09d4e1f7082aff024faf27263f78e7fc7190a2"}, {"sha": "dcde480a667f24923c9895e3eb6e9a030d271299", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcde480a667f24923c9895e3eb6e9a030d271299", "html_url": "https://github.com/rust-lang/rust/commit/dcde480a667f24923c9895e3eb6e9a030d271299"}], "stats": {"total": 1032, "additions": 1016, "deletions": 16}, "files": [{"sha": "b5a1d194794ca0acbb4792f41fed97b8b429f81d", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -3997,6 +3997,7 @@ Released 2018-09-13\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map\n [`manual_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_flatten\n [`manual_instant_elapsed`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_instant_elapsed\n+[`manual_let_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_let_else\n [`manual_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_map\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive"}, {"sha": "2bb8dfee152517c9214040ac3fb8f2f71130e8cb", "filename": "clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -251,6 +251,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::manual_bits::MANUAL_BITS_INFO,\n     crate::manual_clamp::MANUAL_CLAMP_INFO,\n     crate::manual_instant_elapsed::MANUAL_INSTANT_ELAPSED_INFO,\n+    crate::manual_let_else::MANUAL_LET_ELSE_INFO,\n     crate::manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE_INFO,\n     crate::manual_rem_euclid::MANUAL_REM_EUCLID_INFO,\n     crate::manual_retain::MANUAL_RETAIN_INFO,"}, {"sha": "7b5c10db4e1be253329765aec74ede937da6f7f0", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -274,9 +274,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing<'tcx> {\n         }\n \n         let typeck = cx.typeck_results();\n-        let (kind, sub_expr) = if let Some(x) = try_parse_ref_op(cx.tcx, typeck, expr) {\n-            x\n-        } else {\n+        let Some((kind, sub_expr)) = try_parse_ref_op(cx.tcx, typeck, expr) else {\n             // The whole chain of reference operations has been seen\n             if let Some((state, data)) = self.state.take() {\n                 report(cx, expr, state, data);"}, {"sha": "5716ef71641cc588af1df05bf17cf6e35d80c79f", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -170,6 +170,7 @@ mod manual_async_fn;\n mod manual_bits;\n mod manual_clamp;\n mod manual_instant_elapsed;\n+mod manual_let_else;\n mod manual_non_exhaustive;\n mod manual_rem_euclid;\n mod manual_retain;\n@@ -603,6 +604,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         ))\n     });\n     store.register_late_pass(move |_| Box::new(matches::Matches::new(msrv)));\n+    let matches_for_let_else = conf.matches_for_let_else;\n+    store.register_late_pass(move |_| Box::new(manual_let_else::ManualLetElse::new(msrv, matches_for_let_else)));\n     store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveStruct::new(msrv)));\n     store.register_late_pass(move |_| Box::new(manual_non_exhaustive::ManualNonExhaustiveEnum::new(msrv)));\n     store.register_late_pass(move |_| Box::new(manual_strip::ManualStrip::new(msrv)));"}, {"sha": "1846596fa4c8e259ab6f0ffb580807a47de5381b", "filename": "clippy_lints/src/manual_let_else.rs", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_lints%2Fsrc%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_lints%2Fsrc%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_let_else.rs?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -0,0 +1,297 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher::IfLetOrMatch;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::{for_each_expr, Descend};\n+use clippy_utils::{meets_msrv, msrvs, peel_blocks};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, MatchSource, Pat, PatKind, QPath, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+use serde::Deserialize;\n+use std::ops::ControlFlow;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Warn of cases where `let...else` could be used\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// `let...else` provides a standard construct for this pattern\n+    /// that people can easily recognize. It's also more compact.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # let w = Some(0);\n+    /// let v = if let Some(v) = w { v } else { return };\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// # #![feature(let_else)]\n+    /// # fn main () {\n+    /// # let w = Some(0);\n+    /// let Some(v) = w else { return };\n+    /// # }\n+    /// ```\n+    #[clippy::version = \"1.67.0\"]\n+    pub MANUAL_LET_ELSE,\n+    pedantic,\n+    \"manual implementation of a let...else statement\"\n+}\n+\n+pub struct ManualLetElse {\n+    msrv: Option<RustcVersion>,\n+    matches_behaviour: MatchLintBehaviour,\n+}\n+\n+impl ManualLetElse {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>, matches_behaviour: MatchLintBehaviour) -> Self {\n+        Self {\n+            msrv,\n+            matches_behaviour,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(ManualLetElse => [MANUAL_LET_ELSE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for ManualLetElse {\n+    fn check_stmt(&mut self, cx: &LateContext<'_>, stmt: &'tcx Stmt<'tcx>) {\n+        let if_let_or_match = if_chain! {\n+            if meets_msrv(self.msrv, msrvs::LET_ELSE);\n+            if !in_external_macro(cx.sess(), stmt.span);\n+            if let StmtKind::Local(local) = stmt.kind;\n+            if let Some(init) = local.init;\n+            if local.els.is_none();\n+            if local.ty.is_none();\n+            if init.span.ctxt() == stmt.span.ctxt();\n+            if let Some(if_let_or_match) = IfLetOrMatch::parse(cx, init);\n+            then {\n+                if_let_or_match\n+            } else {\n+                return;\n+            }\n+        };\n+\n+        match if_let_or_match {\n+            IfLetOrMatch::IfLet(if_let_expr, let_pat, if_then, if_else) => if_chain! {\n+                if expr_is_simple_identity(let_pat, if_then);\n+                if let Some(if_else) = if_else;\n+                if expr_diverges(cx, if_else);\n+                then {\n+                    emit_manual_let_else(cx, stmt.span, if_let_expr, let_pat, if_else);\n+                }\n+            },\n+            IfLetOrMatch::Match(match_expr, arms, source) => {\n+                if self.matches_behaviour == MatchLintBehaviour::Never {\n+                    return;\n+                }\n+                if source != MatchSource::Normal {\n+                    return;\n+                }\n+                // Any other number than two arms doesn't (neccessarily)\n+                // have a trivial mapping to let else.\n+                if arms.len() != 2 {\n+                    return;\n+                }\n+                // Guards don't give us an easy mapping either\n+                if arms.iter().any(|arm| arm.guard.is_some()) {\n+                    return;\n+                }\n+                let check_types = self.matches_behaviour == MatchLintBehaviour::WellKnownTypes;\n+                let diverging_arm_opt = arms\n+                    .iter()\n+                    .enumerate()\n+                    .find(|(_, arm)| expr_diverges(cx, arm.body) && pat_allowed_for_else(cx, arm.pat, check_types));\n+                let Some((idx, diverging_arm)) = diverging_arm_opt else { return; };\n+                let pat_arm = &arms[1 - idx];\n+                if !expr_is_simple_identity(pat_arm.pat, pat_arm.body) {\n+                    return;\n+                }\n+\n+                emit_manual_let_else(cx, stmt.span, match_expr, pat_arm.pat, diverging_arm.body);\n+            },\n+        }\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn emit_manual_let_else(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, pat: &Pat<'_>, else_body: &Expr<'_>) {\n+    span_lint_and_then(\n+        cx,\n+        MANUAL_LET_ELSE,\n+        span,\n+        \"this could be rewritten as `let...else`\",\n+        |diag| {\n+            // This is far from perfect, for example there needs to be:\n+            // * mut additions for the bindings\n+            // * renamings of the bindings\n+            // * unused binding collision detection with existing ones\n+            // * putting patterns with at the top level | inside ()\n+            // for this to be machine applicable.\n+            let app = Applicability::HasPlaceholders;\n+\n+            if let Some(sn_pat) = snippet_opt(cx, pat.span) &&\n+                let Some(sn_expr) = snippet_opt(cx, expr.span) &&\n+                let Some(sn_else) = snippet_opt(cx, else_body.span)\n+            {\n+                let else_bl = if matches!(else_body.kind, ExprKind::Block(..)) {\n+                    sn_else\n+                } else {\n+                    format!(\"{{ {sn_else} }}\")\n+                };\n+                let sugg = format!(\"let {sn_pat} = {sn_expr} else {else_bl};\");\n+                diag.span_suggestion(span, \"consider writing\", sugg, app);\n+            }\n+        },\n+    );\n+}\n+\n+fn expr_diverges(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n+    fn is_never(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n+        if let Some(ty) = cx.typeck_results().expr_ty_opt(expr) {\n+            return ty.is_never();\n+        }\n+        false\n+    }\n+    // We can't just call is_never on expr and be done, because the type system\n+    // sometimes coerces the ! type to something different before we can get\n+    // our hands on it. So instead, we do a manual search. We do fall back to\n+    // is_never in some places when there is no better alternative.\n+    for_each_expr(expr, |ex| {\n+        match ex.kind {\n+            ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => ControlFlow::Break(()),\n+            ExprKind::Call(call, _) => {\n+                if is_never(cx, ex) || is_never(cx, call) {\n+                    return ControlFlow::Break(());\n+                }\n+                ControlFlow::Continue(Descend::Yes)\n+            },\n+            ExprKind::MethodCall(..) => {\n+                if is_never(cx, ex) {\n+                    return ControlFlow::Break(());\n+                }\n+                ControlFlow::Continue(Descend::Yes)\n+            },\n+            ExprKind::If(if_expr, if_then, if_else) => {\n+                let else_diverges = if_else.map_or(false, |ex| expr_diverges(cx, ex));\n+                let diverges = expr_diverges(cx, if_expr) || (else_diverges && expr_diverges(cx, if_then));\n+                if diverges {\n+                    return ControlFlow::Break(());\n+                }\n+                ControlFlow::Continue(Descend::No)\n+            },\n+            ExprKind::Match(match_expr, match_arms, _) => {\n+                let diverges = expr_diverges(cx, match_expr)\n+                    || match_arms.iter().all(|arm| {\n+                        let guard_diverges = arm.guard.as_ref().map_or(false, |g| expr_diverges(cx, g.body()));\n+                        guard_diverges || expr_diverges(cx, arm.body)\n+                    });\n+                if diverges {\n+                    return ControlFlow::Break(());\n+                }\n+                ControlFlow::Continue(Descend::No)\n+            },\n+\n+            // Don't continue into loops or labeled blocks, as they are breakable,\n+            // and we'd have to start checking labels.\n+            ExprKind::Block(_, Some(_)) | ExprKind::Loop(..) => ControlFlow::Continue(Descend::No),\n+\n+            // Default: descend\n+            _ => ControlFlow::Continue(Descend::Yes),\n+        }\n+    })\n+    .is_some()\n+}\n+\n+fn pat_allowed_for_else(cx: &LateContext<'_>, pat: &'_ Pat<'_>, check_types: bool) -> bool {\n+    // Check whether the pattern contains any bindings, as the\n+    // binding might potentially be used in the body.\n+    // TODO: only look for *used* bindings.\n+    let mut has_bindings = false;\n+    pat.each_binding_or_first(&mut |_, _, _, _| has_bindings = true);\n+    if has_bindings {\n+        return false;\n+    }\n+\n+    // If we shouldn't check the types, exit early.\n+    if !check_types {\n+        return true;\n+    }\n+\n+    // Check whether any possibly \"unknown\" patterns are included,\n+    // because users might not know which values some enum has.\n+    // Well-known enums are excepted, as we assume people know them.\n+    // We do a deep check, to be able to disallow Err(En::Foo(_))\n+    // for usage of the En::Foo variant, as we disallow En::Foo(_),\n+    // but we allow Err(_).\n+    let typeck_results = cx.typeck_results();\n+    let mut has_disallowed = false;\n+    pat.walk_always(|pat| {\n+        // Only do the check if the type is \"spelled out\" in the pattern\n+        if !matches!(\n+            pat.kind,\n+            PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..)\n+        ) {\n+            return;\n+        };\n+        let ty = typeck_results.pat_ty(pat);\n+        // Option and Result are allowed, everything else isn't.\n+        if !(is_type_diagnostic_item(cx, ty, sym::Option) || is_type_diagnostic_item(cx, ty, sym::Result)) {\n+            has_disallowed = true;\n+        }\n+    });\n+    !has_disallowed\n+}\n+\n+/// Checks if the passed block is a simple identity referring to bindings created by the pattern\n+fn expr_is_simple_identity(pat: &'_ Pat<'_>, expr: &'_ Expr<'_>) -> bool {\n+    // We support patterns with multiple bindings and tuples, like:\n+    //   let ... = if let (Some(foo), bar) = g() { (foo, bar) } else { ... }\n+    let peeled = peel_blocks(expr);\n+    let paths = match peeled.kind {\n+        ExprKind::Tup(exprs) | ExprKind::Array(exprs) => exprs,\n+        ExprKind::Path(_) => std::slice::from_ref(peeled),\n+        _ => return false,\n+    };\n+    let mut pat_bindings = FxHashSet::default();\n+    pat.each_binding_or_first(&mut |_ann, _hir_id, _sp, ident| {\n+        pat_bindings.insert(ident);\n+    });\n+    if pat_bindings.len() < paths.len() {\n+        return false;\n+    }\n+    for path in paths {\n+        if_chain! {\n+            if let ExprKind::Path(QPath::Resolved(_ty, path)) = path.kind;\n+            if let [path_seg] = path.segments;\n+            then {\n+                if !pat_bindings.remove(&path_seg.ident) {\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+    true\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Deserialize)]\n+pub enum MatchLintBehaviour {\n+    AllTypes,\n+    WellKnownTypes,\n+    Never,\n+}"}, {"sha": "ef6de7d333d340402a2dbca676e37670a11fb61a", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -213,7 +213,7 @@ define_Conf! {\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE, MAP_CLONE, BORROW_AS_PTR, MANUAL_BITS, ERR_EXPECT, CAST_ABS_TO_UNSIGNED, UNINLINED_FORMAT_ARGS, MANUAL_CLAMP.\n+    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE, MAP_CLONE, BORROW_AS_PTR, MANUAL_BITS, ERR_EXPECT, CAST_ABS_TO_UNSIGNED, UNINLINED_FORMAT_ARGS, MANUAL_CLAMP, MANUAL_LET_ELSE.\n     ///\n     /// The minimum rust version that the project supports\n     (msrv: Option<String> = None),\n@@ -335,6 +335,12 @@ define_Conf! {\n     ///\n     /// Enables verbose mode. Triggers if there is more than one uppercase char next to each other\n     (upper_case_acronyms_aggressive: bool = false),\n+    /// Lint: MANUAL_LET_ELSE.\n+    ///\n+    /// Whether the matches should be considered by the lint, and whether there should\n+    /// be filtering for common types.\n+    (matches_for_let_else: crate::manual_let_else::MatchLintBehaviour =\n+        crate::manual_let_else::MatchLintBehaviour::WellKnownTypes),\n     /// Lint: _CARGO_COMMON_METADATA.\n     ///\n     /// For internal testing only, ignores the current `publish` settings in the Cargo manifest."}, {"sha": "f01afda72b2c865e52f7dfe3b759b3a1a4f73352", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -147,9 +147,8 @@ impl Constant {\n                 _ => None,\n             },\n             (&Self::Vec(ref l), &Self::Vec(ref r)) => {\n-                let cmp_type = match *cmp_type.kind() {\n-                    ty::Array(ty, _) | ty::Slice(ty) => ty,\n-                    _ => return None,\n+                let (ty::Array(cmp_type, _) | ty::Slice(cmp_type)) = *cmp_type.kind() else {\n+                    return None\n                 };\n                 iter::zip(l, r)\n                     .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n@@ -401,10 +400,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         use self::Constant::{Int, F32, F64};\n         match *o {\n             Int(value) => {\n-                let ity = match *ty.kind() {\n-                    ty::Int(ity) => ity,\n-                    _ => return None,\n-                };\n+                let ty::Int(ity) = *ty.kind() else { return None };\n                 // sign extend\n                 let value = sext(self.lcx.tcx, value, ity);\n                 let value = value.checked_neg()?;"}, {"sha": "02b973e5b2785c51ffd442b83c5c98684dd8aa6f", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -131,13 +131,10 @@ impl HirEqInterExpr<'_, '_, '_> {\n             ([], None, [], None) => {\n                 // For empty blocks, check to see if the tokens are equal. This will catch the case where a macro\n                 // expanded to nothing, or the cfg attribute was used.\n-                let (left, right) = match (\n+                let (Some(left), Some(right)) = (\n                     snippet_opt(self.inner.cx, left.span),\n                     snippet_opt(self.inner.cx, right.span),\n-                ) {\n-                    (Some(left), Some(right)) => (left, right),\n-                    _ => return true,\n-                };\n+                ) else { return true };\n                 let mut left_pos = 0;\n                 let left = tokenize(&left)\n                     .map(|t| {"}, {"sha": "9780794fa99cad538dcf4ab93c35aee3aab29df6", "filename": "clippy_utils/src/msrvs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/clippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmsrvs.rs?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -12,6 +12,7 @@ macro_rules! msrv_aliases {\n \n // names may refer to stabilized feature flags or library items\n msrv_aliases! {\n+    1,65,0 { LET_ELSE }\n     1,62,0 { BOOL_THEN_SOME }\n     1,58,0 { FORMAT_ARGS_CAPTURE }\n     1,53,0 { OR_PATTERNS, MANUAL_BITS, BTREE_MAP_RETAIN, BTREE_SET_RETAIN, ARRAY_INTO_ITERATOR }"}, {"sha": "14166709f7fd6f67fe907bdcebdd267ad722f6b9", "filename": "src/docs/manual_let_else.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/src%2Fdocs%2Fmanual_let_else.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/src%2Fdocs%2Fmanual_let_else.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_let_else.txt?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+\n+Warn of cases where `let...else` could be used\n+\n+### Why is this bad?\n+\n+`let...else` provides a standard construct for this pattern\n+that people can easily recognize. It's also more compact.\n+\n+### Example\n+\n+```\n+let v = if let Some(v) = w { v } else { return };\n+```\n+\n+Could be written:\n+\n+```\n+let Some(v) = w else { return };\n+```\n\\ No newline at end of file"}, {"sha": "7db2e11225bd8e1eb788b8b688799fc25c2fcbf5", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -22,6 +22,7 @@ error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown fie\n            enum-variant-size-threshold\n            large-error-threshold\n            literal-representation-threshold\n+           matches-for-let-else\n            max-fn-params-bools\n            max-include-file-size\n            max-struct-bools"}, {"sha": "2ef40e5911af46d077b302bcb78e787bce50b5d4", "filename": "tests/ui/manual_let_else.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/tests%2Fui%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/tests%2Fui%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else.rs?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -0,0 +1,237 @@\n+#![allow(unused_braces, unused_variables, dead_code)]\n+#![allow(\n+    clippy::collapsible_else_if,\n+    clippy::unused_unit,\n+    clippy::let_unit_value,\n+    clippy::match_single_binding,\n+    clippy::never_loop\n+)]\n+#![warn(clippy::manual_let_else)]\n+\n+fn g() -> Option<()> {\n+    None\n+}\n+\n+fn main() {}\n+\n+fn fire() {\n+    let v = if let Some(v_some) = g() { v_some } else { return };\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        return;\n+    };\n+\n+    let v = if let Some(v) = g() {\n+        // Blocks around the identity should have no impact\n+        {\n+            { v }\n+        }\n+    } else {\n+        // Some computation should still make it fire\n+        g();\n+        return;\n+    };\n+\n+    // continue and break diverge\n+    loop {\n+        let v = if let Some(v_some) = g() { v_some } else { continue };\n+        let v = if let Some(v_some) = g() { v_some } else { break };\n+    }\n+\n+    // panic also diverges\n+    let v = if let Some(v_some) = g() { v_some } else { panic!() };\n+\n+    // abort also diverges\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        std::process::abort()\n+    };\n+\n+    // If whose two branches diverge also diverges\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        if true { return } else { panic!() }\n+    };\n+\n+    // Diverging after an if still makes the block diverge:\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        if true {}\n+        panic!();\n+    };\n+\n+    // A match diverges if all branches diverge:\n+    // Note: the corresponding let-else requires a ; at the end of the match\n+    // as otherwise the type checker does not turn it into a ! type.\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        match () {\n+            _ if panic!() => {},\n+            _ => panic!(),\n+        }\n+    };\n+\n+    // An if's expression can cause divergence:\n+    let v = if let Some(v_some) = g() { v_some } else { if panic!() {} };\n+\n+    // An expression of a match can cause divergence:\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        match panic!() {\n+            _ => {},\n+        }\n+    };\n+\n+    // Top level else if\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else if true {\n+        return;\n+    } else {\n+        panic!(\"diverge\");\n+    };\n+\n+    // All match arms diverge\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        match (g(), g()) {\n+            (Some(_), None) => return,\n+            (None, Some(_)) => {\n+                if true {\n+                    return;\n+                } else {\n+                    panic!();\n+                }\n+            },\n+            _ => return,\n+        }\n+    };\n+\n+    // Tuples supported for the declared variables\n+    let (v, w) = if let Some(v_some) = g().map(|v| (v, 42)) {\n+        v_some\n+    } else {\n+        return;\n+    };\n+\n+    // Tuples supported for the identity block and pattern\n+    let v = if let (Some(v_some), w_some) = (g(), 0) {\n+        (w_some, v_some)\n+    } else {\n+        return;\n+    };\n+\n+    // entirely inside macro lints\n+    macro_rules! create_binding_if_some {\n+        ($n:ident, $e:expr) => {\n+            let $n = if let Some(v) = $e { v } else { return };\n+        };\n+    }\n+    create_binding_if_some!(w, g());\n+}\n+\n+fn not_fire() {\n+    let v = if let Some(v_some) = g() {\n+        // Nothing returned. Should not fire.\n+    } else {\n+        return;\n+    };\n+\n+    let w = 0;\n+    let v = if let Some(v_some) = g() {\n+        // Different variable than v_some. Should not fire.\n+        w\n+    } else {\n+        return;\n+    };\n+\n+    let v = if let Some(v_some) = g() {\n+        // Computation in then clause. Should not fire.\n+        g();\n+        v_some\n+    } else {\n+        return;\n+    };\n+\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        if false {\n+            return;\n+        }\n+        // This doesn't diverge. Should not fire.\n+        ()\n+    };\n+\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        // There is one match arm that doesn't diverge. Should not fire.\n+        match (g(), g()) {\n+            (Some(_), None) => return,\n+            (None, Some(_)) => return,\n+            (Some(_), Some(_)) => (),\n+            _ => return,\n+        }\n+    };\n+\n+    let v = if let Some(v_some) = g() {\n+        v_some\n+    } else {\n+        // loop with a break statement inside does not diverge.\n+        loop {\n+            break;\n+        }\n+    };\n+\n+    enum Uninhabited {}\n+    fn un() -> Uninhabited {\n+        panic!()\n+    }\n+    let v = if let Some(v_some) = None {\n+        v_some\n+    } else {\n+        // Don't lint if the type is uninhabited but not !\n+        un()\n+    };\n+\n+    fn question_mark() -> Option<()> {\n+        let v = if let Some(v) = g() {\n+            v\n+        } else {\n+            // Question mark does not diverge\n+            g()?\n+        };\n+        Some(v)\n+    }\n+\n+    // Macro boundary inside let\n+    macro_rules! some_or_return {\n+        ($e:expr) => {\n+            if let Some(v) = $e { v } else { return }\n+        };\n+    }\n+    let v = some_or_return!(g());\n+\n+    // Also macro boundary inside let, but inside a macro\n+    macro_rules! create_binding_if_some_nf {\n+        ($n:ident, $e:expr) => {\n+            let $n = some_or_return!($e);\n+        };\n+    }\n+    create_binding_if_some_nf!(v, g());\n+\n+    // Already a let-else\n+    let Some(a) = (if let Some(b) = Some(Some(())) { b } else { return }) else { panic!() };\n+\n+    // If a type annotation is present, don't lint as\n+    // expressing the type might be too hard\n+    let v: () = if let Some(v_some) = g() { v_some } else { panic!() };\n+}"}, {"sha": "453b68b8bd003c8f43cadd240412ff0a146ad07b", "filename": "tests/ui/manual_let_else.stderr", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/tests%2Fui%2Fmanual_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/tests%2Fui%2Fmanual_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else.stderr?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -0,0 +1,263 @@\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:18:5\n+   |\n+LL |     let v = if let Some(v_some) = g() { v_some } else { return };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v_some) = g() else { return };`\n+   |\n+   = note: `-D clippy::manual-let-else` implied by `-D warnings`\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:19:5\n+   |\n+LL | /     let v = if let Some(v_some) = g() {\n+LL | |         v_some\n+LL | |     } else {\n+LL | |         return;\n+LL | |     };\n+   | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g() else {\n+LL +         return;\n+LL +     };\n+   |\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:25:5\n+   |\n+LL | /     let v = if let Some(v) = g() {\n+LL | |         // Blocks around the identity should have no impact\n+LL | |         {\n+LL | |             { v }\n+...  |\n+LL | |         return;\n+LL | |     };\n+   | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v) = g() else {\n+LL +         // Some computation should still make it fire\n+LL +         g();\n+LL +         return;\n+LL +     };\n+   |\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:38:9\n+   |\n+LL |         let v = if let Some(v_some) = g() { v_some } else { continue };\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v_some) = g() else { continue };`\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:39:9\n+   |\n+LL |         let v = if let Some(v_some) = g() { v_some } else { break };\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v_some) = g() else { break };`\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:43:5\n+   |\n+LL |     let v = if let Some(v_some) = g() { v_some } else { panic!() };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v_some) = g() else { panic!() };`\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:46:5\n+   |\n+LL | /     let v = if let Some(v_some) = g() {\n+LL | |         v_some\n+LL | |     } else {\n+LL | |         std::process::abort()\n+LL | |     };\n+   | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g() else {\n+LL +         std::process::abort()\n+LL +     };\n+   |\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:53:5\n+   |\n+LL | /     let v = if let Some(v_some) = g() {\n+LL | |         v_some\n+LL | |     } else {\n+LL | |         if true { return } else { panic!() }\n+LL | |     };\n+   | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g() else {\n+LL +         if true { return } else { panic!() }\n+LL +     };\n+   |\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:60:5\n+   |\n+LL | /     let v = if let Some(v_some) = g() {\n+LL | |         v_some\n+LL | |     } else {\n+LL | |         if true {}\n+LL | |         panic!();\n+LL | |     };\n+   | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g() else {\n+LL +         if true {}\n+LL +         panic!();\n+LL +     };\n+   |\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:70:5\n+   |\n+LL | /     let v = if let Some(v_some) = g() {\n+LL | |         v_some\n+LL | |     } else {\n+LL | |         match () {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g() else {\n+LL +         match () {\n+LL +             _ if panic!() => {},\n+LL +             _ => panic!(),\n+LL +         }\n+LL +     };\n+   |\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:80:5\n+   |\n+LL |     let v = if let Some(v_some) = g() { v_some } else { if panic!() {} };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v_some) = g() else { if panic!() {} };`\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:83:5\n+   |\n+LL | /     let v = if let Some(v_some) = g() {\n+LL | |         v_some\n+LL | |     } else {\n+LL | |         match panic!() {\n+LL | |             _ => {},\n+LL | |         }\n+LL | |     };\n+   | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g() else {\n+LL +         match panic!() {\n+LL +             _ => {},\n+LL +         }\n+LL +     };\n+   |\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:92:5\n+   |\n+LL | /     let v = if let Some(v_some) = g() {\n+LL | |         v_some\n+LL | |     } else if true {\n+LL | |         return;\n+LL | |     } else {\n+LL | |         panic!(\"diverge\");\n+LL | |     };\n+   | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g() else { if true {\n+LL +         return;\n+LL +     } else {\n+LL +         panic!(\"diverge\");\n+LL +     } };\n+   |\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:101:5\n+   |\n+LL | /     let v = if let Some(v_some) = g() {\n+LL | |         v_some\n+LL | |     } else {\n+LL | |         match (g(), g()) {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g() else {\n+LL +         match (g(), g()) {\n+LL +             (Some(_), None) => return,\n+LL +             (None, Some(_)) => {\n+LL +                 if true {\n+LL +                     return;\n+LL +                 } else {\n+LL +                     panic!();\n+LL +                 }\n+LL +             },\n+LL +             _ => return,\n+LL +         }\n+LL +     };\n+   |\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:118:5\n+   |\n+LL | /     let (v, w) = if let Some(v_some) = g().map(|v| (v, 42)) {\n+LL | |         v_some\n+LL | |     } else {\n+LL | |         return;\n+LL | |     };\n+   | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let Some(v_some) = g().map(|v| (v, 42)) else {\n+LL +         return;\n+LL +     };\n+   |\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:125:5\n+   |\n+LL | /     let v = if let (Some(v_some), w_some) = (g(), 0) {\n+LL | |         (w_some, v_some)\n+LL | |     } else {\n+LL | |         return;\n+LL | |     };\n+   | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let (Some(v_some), w_some) = (g(), 0) else {\n+LL +         return;\n+LL +     };\n+   |\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:134:13\n+   |\n+LL |             let $n = if let Some(v) = $e { v } else { return };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Some(v) = g() else { return };`\n+...\n+LL |     create_binding_if_some!(w, g());\n+   |     ------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `create_binding_if_some` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 17 previous errors\n+"}, {"sha": "93c86ca24fea3a079c80c8ae7bb32204b29f6be3", "filename": "tests/ui/manual_let_else_match.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/tests%2Fui%2Fmanual_let_else_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/tests%2Fui%2Fmanual_let_else_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else_match.rs?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -0,0 +1,121 @@\n+#![allow(unused_braces, unused_variables, dead_code)]\n+#![allow(clippy::collapsible_else_if, clippy::let_unit_value)]\n+#![warn(clippy::manual_let_else)]\n+// Ensure that we don't conflict with match -> if let lints\n+#![warn(clippy::single_match_else, clippy::single_match)]\n+\n+fn f() -> Result<u32, u32> {\n+    Ok(0)\n+}\n+\n+fn g() -> Option<()> {\n+    None\n+}\n+\n+fn h() -> (Option<()>, Option<()>) {\n+    (None, None)\n+}\n+\n+enum Variant {\n+    Foo,\n+    Bar(u32),\n+    Baz(u32),\n+}\n+\n+fn build_enum() -> Variant {\n+    Variant::Foo\n+}\n+\n+fn main() {}\n+\n+fn fire() {\n+    let v = match g() {\n+        Some(v_some) => v_some,\n+        None => return,\n+    };\n+\n+    let v = match g() {\n+        Some(v_some) => v_some,\n+        _ => return,\n+    };\n+\n+    loop {\n+        // More complex pattern for the identity arm and diverging arm\n+        let v = match h() {\n+            (Some(_), Some(_)) | (None, None) => continue,\n+            (Some(v), None) | (None, Some(v)) => v,\n+        };\n+        // Custom enums are supported as long as the \"else\" arm is a simple _\n+        let v = match build_enum() {\n+            _ => continue,\n+            Variant::Bar(v) | Variant::Baz(v) => v,\n+        };\n+    }\n+\n+    // There is a _ in the diverging arm\n+    // TODO also support unused bindings aka _v\n+    let v = match f() {\n+        Ok(v) => v,\n+        Err(_) => return,\n+    };\n+\n+    // Err(()) is an allowed pattern\n+    let v = match f().map_err(|_| ()) {\n+        Ok(v) => v,\n+        Err(()) => return,\n+    };\n+}\n+\n+fn not_fire() {\n+    // Multiple diverging arms\n+    let v = match h() {\n+        _ => panic!(),\n+        (None, Some(_v)) => return,\n+        (Some(v), None) => v,\n+    };\n+\n+    // Multiple identity arms\n+    let v = match h() {\n+        _ => panic!(),\n+        (None, Some(v)) => v,\n+        (Some(v), None) => v,\n+    };\n+\n+    // No diverging arm at all, only identity arms.\n+    // This is no case for let else, but destructuring assignment.\n+    let v = match f() {\n+        Ok(v) => v,\n+        Err(e) => e,\n+    };\n+\n+    // The identity arm has a guard\n+    let v = match g() {\n+        Some(v) if g().is_none() => v,\n+        _ => return,\n+    };\n+\n+    // The diverging arm has a guard\n+    let v = match f() {\n+        Err(v) if v > 0 => panic!(),\n+        Ok(v) | Err(v) => v,\n+    };\n+\n+    // The diverging arm creates a binding\n+    let v = match f() {\n+        Ok(v) => v,\n+        Err(e) => panic!(\"error: {e}\"),\n+    };\n+\n+    // Custom enum where the diverging arm\n+    // explicitly mentions the variant\n+    let v = match build_enum() {\n+        Variant::Foo => return,\n+        Variant::Bar(v) | Variant::Baz(v) => v,\n+    };\n+\n+    // The custom enum is surrounded by an Err()\n+    let v = match Err(build_enum()) {\n+        Ok(v) | Err(Variant::Bar(v) | Variant::Baz(v)) => v,\n+        Err(Variant::Foo) => return,\n+    };\n+}"}, {"sha": "38be5ac54547368b7fe98d336a1da5acc2e85db7", "filename": "tests/ui/manual_let_else_match.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/tests%2Fui%2Fmanual_let_else_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672/tests%2Fui%2Fmanual_let_else_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else_match.stderr?ref=b698a151b3eb1c6cd6a70d3e9d9d0aab2711f672", "patch": "@@ -0,0 +1,58 @@\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else_match.rs:32:5\n+   |\n+LL | /     let v = match g() {\n+LL | |         Some(v_some) => v_some,\n+LL | |         None => return,\n+LL | |     };\n+   | |______^ help: consider writing: `let Some(v_some) = g() else { return };`\n+   |\n+   = note: `-D clippy::manual-let-else` implied by `-D warnings`\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else_match.rs:37:5\n+   |\n+LL | /     let v = match g() {\n+LL | |         Some(v_some) => v_some,\n+LL | |         _ => return,\n+LL | |     };\n+   | |______^ help: consider writing: `let Some(v_some) = g() else { return };`\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else_match.rs:44:9\n+   |\n+LL | /         let v = match h() {\n+LL | |             (Some(_), Some(_)) | (None, None) => continue,\n+LL | |             (Some(v), None) | (None, Some(v)) => v,\n+LL | |         };\n+   | |__________^ help: consider writing: `let (Some(v), None) | (None, Some(v)) = h() else { continue };`\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else_match.rs:49:9\n+   |\n+LL | /         let v = match build_enum() {\n+LL | |             _ => continue,\n+LL | |             Variant::Bar(v) | Variant::Baz(v) => v,\n+LL | |         };\n+   | |__________^ help: consider writing: `let Variant::Bar(v) | Variant::Baz(v) = build_enum() else { continue };`\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else_match.rs:57:5\n+   |\n+LL | /     let v = match f() {\n+LL | |         Ok(v) => v,\n+LL | |         Err(_) => return,\n+LL | |     };\n+   | |______^ help: consider writing: `let Ok(v) = f() else { return };`\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else_match.rs:63:5\n+   |\n+LL | /     let v = match f().map_err(|_| ()) {\n+LL | |         Ok(v) => v,\n+LL | |         Err(()) => return,\n+LL | |     };\n+   | |______^ help: consider writing: `let Ok(v) = f().map_err(|_| ()) else { return };`\n+\n+error: aborting due to 6 previous errors\n+"}]}