{"sha": "26a413e015b7fef4c0edb51bda0d39ab499f4950", "node_id": "C_kwDOAAsO6NoAKDI2YTQxM2UwMTViN2ZlZjRjMGVkYjUxYmRhMGQzOWFiNDk5ZjQ5NTA", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-21T08:18:54Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-21T08:18:54Z"}, "message": "merge rustc history", "tree": {"sha": "26184df803344b52f3cd9d012f00847511179ebf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26184df803344b52f3cd9d012f00847511179ebf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26a413e015b7fef4c0edb51bda0d39ab499f4950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26a413e015b7fef4c0edb51bda0d39ab499f4950", "html_url": "https://github.com/rust-lang/rust/commit/26a413e015b7fef4c0edb51bda0d39ab499f4950", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26a413e015b7fef4c0edb51bda0d39ab499f4950/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b61e5ecc8d08b617a666e506b34b92398d42ce1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b61e5ecc8d08b617a666e506b34b92398d42ce1", "html_url": "https://github.com/rust-lang/rust/commit/4b61e5ecc8d08b617a666e506b34b92398d42ce1"}, {"sha": "a99a48e78600b5dfd39dec730d7fedfae8f48ff6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a99a48e78600b5dfd39dec730d7fedfae8f48ff6", "html_url": "https://github.com/rust-lang/rust/commit/a99a48e78600b5dfd39dec730d7fedfae8f48ff6"}], "stats": {"total": 8734, "additions": 6011, "deletions": 2723}, "files": [{"sha": "bb77324378a40ae6a7844503553661a3e22a8d93", "filename": ".github/workflows/ci.yaml", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/.github%2Fworkflows%2Fci.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/.github%2Fworkflows%2Fci.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yaml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -43,14 +43,31 @@ jobs:\n           rustup component add rustfmt rust-src\n \n       - name: Cache Dependencies\n-        uses: Swatinem/rust-cache@ce325b60658c1b38465c06cc965b79baf32c1e72\n+        uses: Swatinem/rust-cache@76686c56f2b581d1bb5bda44b51f7e24bd9b8b8e\n \n-      - name: Compile\n+      - name: Bump opt-level\n+        if: matrix.os == 'ubuntu-latest'\n+        run: sed -i '/\\[profile.dev]/a opt-level=1' Cargo.toml\n+\n+      - name: Compile (tests)\n         run: cargo test --no-run --locked\n \n+      # It's faster to `test` before `build` \u00af\\_(\u30c4)_/\u00af\n+      - name: Compile (rust-analyzer)\n+        if: matrix.os == 'ubuntu-latest'\n+        run: cargo build --quiet\n+\n       - name: Test\n         run: cargo test -- --nocapture --quiet\n \n+      - name: Run analysis-stats on rust-analyzer\n+        if: matrix.os == 'ubuntu-latest'\n+        run: target/${{ matrix.target }}/debug/rust-analyzer analysis-stats .\n+\n+      - name: Run analysis-stats on rust std library\n+        if: matrix.os == 'ubuntu-latest'\n+        run: target/${{ matrix.target }}/debug/rust-analyzer analysis-stats --with-deps $(rustc --print sysroot)/lib/rustlib/src/rust/library/std\n+\n   # Weird targets to catch non-portable code\n   rust-cross:\n     if: github.repository == 'rust-lang/rust-analyzer'\n@@ -73,7 +90,7 @@ jobs:\n           rustup target add ${{ env.targets }} ${{ env.targets_ide }}\n \n       - name: Cache Dependencies\n-        uses: Swatinem/rust-cache@ce325b60658c1b38465c06cc965b79baf32c1e72\n+        uses: Swatinem/rust-cache@76686c56f2b581d1bb5bda44b51f7e24bd9b8b8e\n \n       - name: Check\n         run: |\n@@ -99,9 +116,9 @@ jobs:\n         uses: actions/checkout@v3\n \n       - name: Install Nodejs\n-        uses: actions/setup-node@v1\n+        uses: actions/setup-node@v3\n         with:\n-          node-version: 16.x\n+          node-version: 16\n \n       - name: Install xvfb\n         if: matrix.os == 'ubuntu-latest'"}, {"sha": "422fe29f9d5c37576060b0698aaa0c6c60aab603", "filename": ".github/workflows/release.yaml", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Frelease.yaml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -76,9 +76,9 @@ jobs:\n           rustup component add rust-src\n \n       - name: Install Node.js\n-        uses: actions/setup-node@v1\n+        uses: actions/setup-node@v3\n         with:\n-          node-version: 16.x\n+          node-version: 16\n \n       - name: Update apt repositories\n         if: matrix.target == 'aarch64-unknown-linux-gnu' || matrix.target == 'arm-unknown-linux-gnueabihf'\n@@ -184,9 +184,9 @@ jobs:\n     needs: [\"dist\", \"dist-x86_64-unknown-linux-musl\"]\n     steps:\n       - name: Install Nodejs\n-        uses: actions/setup-node@v1\n+        uses: actions/setup-node@v3\n         with:\n-          node-version: 16.x\n+          node-version: 16\n \n       - run: echo \"TAG=$(date --iso -u)\" >> $GITHUB_ENV\n         if: github.ref == 'refs/heads/release'\n@@ -259,6 +259,7 @@ jobs:\n         working-directory: ./editors/code\n         # token from https://dev.azure.com/rust-analyzer/\n         run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix || true\n+        timeout-minutes: 2\n \n       - name: Publish Extension (Code Marketplace, nightly)\n         if: github.ref != 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n@@ -269,3 +270,4 @@ jobs:\n         if: github.ref != 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n         working-directory: ./editors/code\n         run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix || true\n+        timeout-minutes: 2"}, {"sha": "0ddea2f728d7806bb5d363b95a6214de6c88c5b4", "filename": "Cargo.lock", "status": "modified", "additions": 97, "deletions": 106, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -37,9 +37,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.62\"\n+version = \"1.0.65\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1485d4d2cc45e7b201ee3767015c96faa5904387c9d87c6efdd0fb511f12d305\"\n+checksum = \"98161a4e3e2184da77bb14f02184cdd111e83bbbcc9979dfee3c44b9a85f5602\"\n \n [[package]]\n name = \"anymap\"\n@@ -49,9 +49,9 @@ checksum = \"8f1f8f5a6f3d50d89e3797d7593a50f96bb2aaa20ca0cc7be1fb673232c91d72\"\n \n [[package]]\n name = \"arbitrary\"\n-version = \"1.1.3\"\n+version = \"1.1.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5a7924531f38b1970ff630f03eb20a2fde69db5c590c93b0f3482e95dcc5fd60\"\n+checksum = \"d86fd10d912cab78764cc44307d9cd5f164e09abbeb87fb19fb6d95937e8da5f\"\n \n [[package]]\n name = \"arrayvec\"\n@@ -171,9 +171,9 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.84.0\"\n+version = \"0.86.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf29c109d57f8d57b0e7675391be37a9285d86dd93278bd5f14a0ad3c447a6c2\"\n+checksum = \"5499d415d855b5094366a824815341893ad3de0ecb6048c430118bdae6d27402\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -183,9 +183,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.84.0\"\n+version = \"0.86.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d391763027b5e50a5e15caf6d2857ec585fd68160367bbeac9e1804209620918\"\n+checksum = \"3800118c76a48507b0eece3a01f3a429b5c478d203c493096e6040c67ab960e1\"\n dependencies = [\n  \"bitflags\",\n  \"chalk-derive\",\n@@ -194,9 +194,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-recursive\"\n-version = \"0.84.0\"\n+version = \"0.86.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"afafd92dcdc7fe0ea940ee94bdd8cc5bd18f4a4a84c593d6d7025fe16c150478\"\n+checksum = \"1baf60628fd73104d1f8562586a52d48f37f1e84435aab2e62674b1fd935b8c8\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -207,9 +207,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.84.0\"\n+version = \"0.86.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3af1d111f11c91c48ace02e93e470c5bae6d2631bd112e4545317da53660d7fc\"\n+checksum = \"0e9c3c068f9358786348e58a1b94ef0a5cf90a9810fc1f10fda896f0b5d80185\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -270,45 +270,44 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-epoch\"\n-version = \"0.9.10\"\n+version = \"0.9.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"045ebe27666471bb549370b4b0b3e51b07f56325befa4284db65fc89c02511b1\"\n+checksum = \"f916dfc5d356b0ed9dae65f1db9fc9770aa2851d2662b988ccf4fe3516e86348\"\n dependencies = [\n  \"autocfg\",\n  \"cfg-if\",\n  \"crossbeam-utils\",\n  \"memoffset\",\n- \"once_cell\",\n  \"scopeguard\",\n ]\n \n [[package]]\n name = \"crossbeam-utils\"\n-version = \"0.8.11\"\n+version = \"0.8.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"51887d4adc7b564537b15adcfb307936f8075dfcd5f00dde9a9f1d29383682bc\"\n+checksum = \"edbafec5fa1f196ca66527c1b12c2ec4745ca14b50f1ad8f9f6f720b55d11fac\"\n dependencies = [\n  \"cfg-if\",\n- \"once_cell\",\n ]\n \n [[package]]\n name = \"dashmap\"\n-version = \"5.3.4\"\n+version = \"5.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3495912c9c1ccf2e18976439f4443f3fee0fd61f424ff99fde6a66b15ecb448f\"\n+checksum = \"907076dfda823b0b36d2a1bb5f90c96660a5bbcd7729e10727f07858f22c4edc\"\n dependencies = [\n  \"cfg-if\",\n  \"hashbrown\",\n  \"lock_api\",\n+ \"once_cell\",\n  \"parking_lot_core 0.9.3\",\n ]\n \n [[package]]\n name = \"derive_arbitrary\"\n-version = \"1.1.3\"\n+version = \"1.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c9a577516173adb681466d517d39bd468293bc2c2a16439375ef0f35bba45f3d\"\n+checksum = \"226ad66541d865d7a7173ad6a9e691c33fdb910ac723f4bc734b3e5294a1f931\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -404,11 +403,10 @@ dependencies = [\n \n [[package]]\n name = \"form_urlencoded\"\n-version = \"1.0.1\"\n+version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5fc25a87fa4fd2094bffb06925852034d90a17f0d1e05197d4956d3555752191\"\n+checksum = \"a9c384f161156f5260c24a097c56119f9be8c798586aecc13afbcbe7b7e26bf8\"\n dependencies = [\n- \"matches\",\n  \"percent-encoding\",\n ]\n \n@@ -546,6 +544,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arrayvec\",\n  \"base-db\",\n+ \"chalk-derive\",\n  \"chalk-ir\",\n  \"chalk-recursive\",\n  \"chalk-solve\",\n@@ -573,9 +572,9 @@ dependencies = [\n \n [[package]]\n name = \"home\"\n-version = \"0.5.3\"\n+version = \"0.5.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2456aef2e6b6a9784192ae780c0f15bc57df0e918585282325e8c8ac27737654\"\n+checksum = \"747309b4b440c06d57b0b25f2aee03ee9b5e5397d288c60e21fc709bb98a7408\"\n dependencies = [\n  \"winapi\",\n ]\n@@ -714,11 +713,10 @@ dependencies = [\n \n [[package]]\n name = \"idna\"\n-version = \"0.2.3\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"418a0a6fab821475f634efe3ccc45c013f742efe03d853e8d3355d5cb850ecf8\"\n+checksum = \"e14ddfc70884202db2244c223200c204c2bda1bc6e0998d11b5e024d657209e6\"\n dependencies = [\n- \"matches\",\n  \"unicode-bidi\",\n  \"unicode-normalization\",\n ]\n@@ -764,18 +762,18 @@ dependencies = [\n \n [[package]]\n name = \"itertools\"\n-version = \"0.10.3\"\n+version = \"0.10.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a9a9d19fa1e79b6215ff29b9d6880b706147f16e9b1dbb1e4e5947b5b02bc5e3\"\n+checksum = \"b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473\"\n dependencies = [\n  \"either\",\n ]\n \n [[package]]\n name = \"itoa\"\n-version = \"1.0.3\"\n+version = \"1.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6c8af84674fe1f223a982c933a0ee1086ac4d4052aa0fb8060c12c6ad838e754\"\n+checksum = \"4217ad341ebadf8d8e724e264f13e593e0648f5b3e94b3896a5df283be015ecc\"\n \n [[package]]\n name = \"jod-thread\"\n@@ -815,9 +813,9 @@ checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.132\"\n+version = \"0.2.135\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8371e4e5341c3a96db127eb2465ac681ced4c433e01dd0e938adbef26ba93ba5\"\n+checksum = \"68783febc7782c6c5cb401fbda4de5a9898be1762314da0bb2c10ced61f18b0c\"\n \n [[package]]\n name = \"libloading\"\n@@ -831,9 +829,9 @@ dependencies = [\n \n [[package]]\n name = \"libmimalloc-sys\"\n-version = \"0.1.25\"\n+version = \"0.1.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"11ca136052550448f55df7898c6dbe651c6b574fe38a0d9ea687a9f8088a2e2c\"\n+checksum = \"8fc093ab289b0bfda3aa1bdfab9c9542be29c7ef385cfcbe77f8c9813588eb48\"\n dependencies = [\n  \"cc\",\n ]\n@@ -844,9 +842,9 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"lock_api\"\n-version = \"0.4.7\"\n+version = \"0.4.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"327fa5b6a6940e4699ec49a9beae1ea4845c6bab9314e4f84ac68742139d8c53\"\n+checksum = \"435011366fe56583b16cf956f9df0095b405b82d76425bc8981c0e22e60ec4df\"\n dependencies = [\n  \"autocfg\",\n  \"scopeguard\",\n@@ -863,7 +861,7 @@ dependencies = [\n \n [[package]]\n name = \"lsp-server\"\n-version = \"0.6.0\"\n+version = \"0.7.0\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"log\",\n@@ -894,12 +892,6 @@ dependencies = [\n  \"regex-automata\",\n ]\n \n-[[package]]\n-name = \"matches\"\n-version = \"0.1.9\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a3e378b66a060d48947b590737b30a1be76706c8dd7b8ba0f2fe3989c68a853f\"\n-\n [[package]]\n name = \"mbe\"\n version = \"0.0.0\"\n@@ -941,18 +933,18 @@ dependencies = [\n \n [[package]]\n name = \"mimalloc\"\n-version = \"0.1.29\"\n+version = \"0.1.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2f64ad83c969af2e732e907564deb0d0ed393cec4af80776f77dd77a1a427698\"\n+checksum = \"76ce6a4b40d3bff9eb3ce9881ca0737a85072f9f975886082640cd46a75cdb35\"\n dependencies = [\n  \"libmimalloc-sys\",\n ]\n \n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.5.3\"\n+version = \"0.5.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6f5c75688da582b8ffc1f1799e9db273f32133c49e048f614d22ec3256773ccc\"\n+checksum = \"96590ba8f175222643a85693f33d26e9c8a015f599c216509b1a6894af675d34\"\n dependencies = [\n  \"adler\",\n ]\n@@ -980,9 +972,9 @@ dependencies = [\n \n [[package]]\n name = \"notify\"\n-version = \"5.0.0-pre.16\"\n+version = \"5.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"530f6314d6904508082f4ea424a0275cf62d341e118b313663f266429cb19693\"\n+checksum = \"ed2c66da08abae1c024c01d635253e402341b4060a12e99b31c7594063bf490a\"\n dependencies = [\n  \"bitflags\",\n  \"crossbeam-channel\",\n@@ -1017,9 +1009,9 @@ dependencies = [\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.13.1\"\n+version = \"1.15.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"074864da206b4973b84eb91683020dbefd6a8c3f0f38e054d93954e891935e4e\"\n+checksum = \"e82dad04139b71a90c080c8463fe0dc7902db5192d939bd0950f074d014339e1\"\n \n [[package]]\n name = \"oorandom\"\n@@ -1088,19 +1080,19 @@ dependencies = [\n \n [[package]]\n name = \"paste\"\n-version = \"1.0.8\"\n+version = \"1.0.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9423e2b32f7a043629287a536f21951e8c6a82482d0acb1eeebfc90bc2225b22\"\n+checksum = \"b1de2e551fb905ac83f73f7aedf2f0cb4a0da7e35efa24a202a936269f1f18e1\"\n \n [[package]]\n name = \"paths\"\n version = \"0.0.0\"\n \n [[package]]\n name = \"percent-encoding\"\n-version = \"2.1.0\"\n+version = \"2.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e\"\n+checksum = \"478c572c3d73181ff3c2539045f6eb99e5491218eae919370993b890cdbdd98e\"\n \n [[package]]\n name = \"perf-event\"\n@@ -1190,9 +1182,9 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.43\"\n+version = \"1.0.47\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0a2ca2c61bc9f3d74d2886294ab7b9853abd9c1ad903a3ac7815c58989bb7bab\"\n+checksum = \"5ea3d908b0e36316caf9e9e2c4625cdde190a7e6f440d794667ed17a1855e725\"\n dependencies = [\n  \"unicode-ident\",\n ]\n@@ -1265,9 +1257,9 @@ dependencies = [\n \n [[package]]\n name = \"pulldown-cmark-to-cmark\"\n-version = \"10.0.2\"\n+version = \"10.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c1353ac408192fa925228d3e60ff746167d03f4f7e54835d78ef79e08225d913\"\n+checksum = \"0194e6e1966c23cc5fd988714f85b18d548d773e81965413555d96569931833d\"\n dependencies = [\n  \"pulldown-cmark\",\n ]\n@@ -1340,9 +1332,9 @@ checksum = \"a3f87b73ce11b1619a3c6332f45341e0047173771e8b8b73f87bfeefb7b56244\"\n \n [[package]]\n name = \"rowan\"\n-version = \"0.15.8\"\n+version = \"0.15.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e88acf7b001007e9e8c989fe7449f6601d909e5dd2c56399fc158977ad6c56e8\"\n+checksum = \"5811547e7ba31e903fe48c8ceab10d40d70a101f3d15523c847cce91aa71f332\"\n dependencies = [\n  \"countme\",\n  \"hashbrown\",\n@@ -1493,27 +1485,27 @@ checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n \n [[package]]\n name = \"semver\"\n-version = \"1.0.13\"\n+version = \"1.0.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"93f6841e709003d68bb2deee8c343572bf446003ec20a583e76f7b15cebf3711\"\n+checksum = \"e25dfac463d778e353db5be2449d1cce89bd6fd23c9f1ea21310ce6e5a1b29c4\"\n dependencies = [\n  \"serde\",\n ]\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.143\"\n+version = \"1.0.145\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53e8e5d5b70924f74ff5c6d64d9a5acd91422117c60f48c4e07855238a254553\"\n+checksum = \"728eb6351430bccb993660dfffc5a72f91ccc1295abaa8ce19b27ebe4f75568b\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.143\"\n+version = \"1.0.145\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d3d8e8de557aee63c26b85b947f5e59b690d0454c753f3adeb5cd7835ab88391\"\n+checksum = \"81fa1584d3d1bcacd84c277a0dfe21f5b0f6accf4a23d04d4c6d61f1af522b4c\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1522,9 +1514,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.83\"\n+version = \"1.0.86\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"38dd04e3c8279e75b31ef29dbdceebfe5ad89f4d0937213c53f7d49d01b3d5a7\"\n+checksum = \"41feea4228a6f1cd09ec7a3593a682276702cd67b5273544757dae23c096f074\"\n dependencies = [\n  \"indexmap\",\n  \"itoa\",\n@@ -1554,9 +1546,9 @@ dependencies = [\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.9.0\"\n+version = \"1.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fd0db749597d91ff862fd1d55ea87f7855a744a8425a64695b6fca237d1dad1\"\n+checksum = \"a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0\"\n \n [[package]]\n name = \"smol_str\"\n@@ -1593,9 +1585,9 @@ dependencies = [\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.99\"\n+version = \"1.0.102\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"58dbef6ec655055e20b86b15a8cc6d439cca19b667537ac6a1369572d151ab13\"\n+checksum = \"3fcd952facd492f9be3ef0d0b7032a6e442ee9b361d4acc2b1d0c4aaa5f613a1\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1666,18 +1658,18 @@ checksum = \"288cb548dbe72b652243ea797201f3d481a0609a967980fcc5b2315ea811560a\"\n \n [[package]]\n name = \"thiserror\"\n-version = \"1.0.31\"\n+version = \"1.0.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bd829fe32373d27f76265620b5309d0340cb8550f523c1dda251d6298069069a\"\n+checksum = \"10deb33631e3c9018b9baf9dcbbc4f737320d2b576bac10f6aefa048fa407e3e\"\n dependencies = [\n  \"thiserror-impl\",\n ]\n \n [[package]]\n name = \"thiserror-impl\"\n-version = \"1.0.31\"\n+version = \"1.0.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0396bc89e626244658bef819e22d0cc459e795a5ebe878e6ec336d1674a8d79a\"\n+checksum = \"982d17546b47146b28f7c22e3d08465f6b8903d0ea13c1660d9d84a6e7adcdbb\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1715,9 +1707,9 @@ dependencies = [\n \n [[package]]\n name = \"tikv-jemalloc-sys\"\n-version = \"0.5.1+5.3.0-patched\"\n+version = \"0.5.2+5.3.0-patched\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"931e876f91fed0827f863a2d153897790da0b24d882c721a79cb3beb0b903261\"\n+checksum = \"ec45c14da997d0925c7835883e4d5c181f196fa142f8c19d7643d1e9af2592c3\"\n dependencies = [\n  \"cc\",\n  \"fs_extra\",\n@@ -1758,9 +1750,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing\"\n-version = \"0.1.36\"\n+version = \"0.1.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fce9567bd60a67d08a16488756721ba392f24f29006402881e43b19aac64307\"\n+checksum = \"8ce8c33a8d48bd45d624a6e523445fd21ec13d3653cd51f681abf67418f54eb8\"\n dependencies = [\n  \"cfg-if\",\n  \"pin-project-lite\",\n@@ -1770,9 +1762,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-attributes\"\n-version = \"0.1.22\"\n+version = \"0.1.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"11c75893af559bc8e10716548bdef5cb2b983f8e637db9d0e15126b61b484ee2\"\n+checksum = \"4017f8f45139870ca7e672686113917c71c7a6e02d4924eda67186083c03081a\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1781,9 +1773,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-core\"\n-version = \"0.1.29\"\n+version = \"0.1.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5aeea4303076558a00714b823f9ad67d58a3bbda1df83d8827d21193156e22f7\"\n+checksum = \"24eb03ba0eab1fd845050058ce5e616558e8f8d8fca633e6b163fe25c797213a\"\n dependencies = [\n  \"once_cell\",\n  \"valuable\",\n@@ -1802,9 +1794,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-subscriber\"\n-version = \"0.3.15\"\n+version = \"0.3.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"60db860322da191b40952ad9affe65ea23e7dd6a5c442c2c42865810c6ab8e6b\"\n+checksum = \"a6176eae26dd70d0c919749377897b54a9276bd7061339665dd68777926b5a70\"\n dependencies = [\n  \"matchers\",\n  \"once_cell\",\n@@ -1866,40 +1858,39 @@ checksum = \"099b7128301d285f79ddd55b9a83d5e6b9e97c92e0ea0daebee7263e932de992\"\n \n [[package]]\n name = \"unicode-ident\"\n-version = \"1.0.1\"\n+version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5bd2fe26506023ed7b5e1e315add59d6f584c621d037f9368fea9cfb988f368c\"\n+checksum = \"6ceab39d59e4c9499d4e5a8ee0e2735b891bb7308ac83dfb4e80cad195c9f6f3\"\n \n [[package]]\n name = \"unicode-normalization\"\n-version = \"0.1.21\"\n+version = \"0.1.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"854cbdc4f7bc6ae19c820d44abdc3277ac3e1b2b93db20a636825d9322fb60e6\"\n+checksum = \"5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921\"\n dependencies = [\n  \"tinyvec\",\n ]\n \n [[package]]\n name = \"unicode-segmentation\"\n-version = \"1.9.0\"\n+version = \"1.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7e8820f5d777f6224dc4be3632222971ac30164d4a258d595640799554ebfd99\"\n+checksum = \"0fdbf052a0783de01e944a6ce7a8cb939e295b1e7be835a1112c3b9a7f047a5a\"\n \n [[package]]\n name = \"unicode-xid\"\n-version = \"0.2.3\"\n+version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"957e51f3646910546462e67d5f7599b9e4fb8acdd304b087a6494730f9eebf04\"\n+checksum = \"f962df74c8c05a667b5ee8bcf162993134c104e96440b663c8daa176dc772d8c\"\n \n [[package]]\n name = \"url\"\n-version = \"2.2.2\"\n+version = \"2.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a507c383b2d33b5fc35d1861e77e6b383d158b2da5e14fe51b83dfedf6fd578c\"\n+checksum = \"0d68c799ae75762b8c3fe375feb6600ef5602c883c5d21eb51c09f22b83c4643\"\n dependencies = [\n  \"form_urlencoded\",\n  \"idna\",\n- \"matches\",\n  \"percent-encoding\",\n  \"serde\",\n ]\n@@ -2082,18 +2073,18 @@ checksum = \"06069a848f95fceae3e5e03c0ddc8cb78452b56654ee0c8e68f938cf790fb9e3\"\n \n [[package]]\n name = \"xflags\"\n-version = \"0.2.4\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f14fe1ed41a5a2b5ef3f565586c4a8a559ee55d3953faab360a771135bdee00\"\n+checksum = \"cbf19f5031a1a812e96fede16f8161218883079946cea87619d3613db1efd268\"\n dependencies = [\n  \"xflags-macros\",\n ]\n \n [[package]]\n name = \"xflags-macros\"\n-version = \"0.2.4\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"45d11d5fc2a97287eded8b170ca80533b3c42646dd7fa386a5eb045817921022\"\n+checksum = \"2afbd7f2039bb6cad2dd45f0c5dff49c0d4e26118398768b7a605524d4251809\"\n \n [[package]]\n name = \"xshell\""}, {"sha": "286ef1e7dcb4dfde854c8ee20ab38575fed61264", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -27,6 +27,7 @@ debug = 0\n # chalk-solve = { path = \"../chalk/chalk-solve\" }\n # chalk-ir = { path = \"../chalk/chalk-ir\" }\n # chalk-recursive = { path = \"../chalk/chalk-recursive\" }\n+# chalk-derive = { path = \"../chalk/chalk-derive\" }\n \n # ungrammar = { path = \"../ungrammar\" }\n "}, {"sha": "5b7828a26996eaaacd6df0f758834f2ed8c8673d", "filename": "crates/base-db/src/fixture.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fbase-db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fbase-db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Ffixture.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -196,7 +196,7 @@ impl ChangeFixture {\n                 Env::default(),\n                 Ok(Vec::new()),\n                 false,\n-                CrateOrigin::CratesIo { repo: None },\n+                CrateOrigin::CratesIo { repo: None, name: None },\n             );\n         } else {\n             for (from, to, prelude) in crate_deps {\n@@ -270,7 +270,7 @@ impl ChangeFixture {\n                 Env::default(),\n                 Ok(proc_macro),\n                 true,\n-                CrateOrigin::CratesIo { repo: None },\n+                CrateOrigin::CratesIo { repo: None, name: None },\n             );\n \n             for krate in all_crates {\n@@ -398,7 +398,7 @@ fn parse_crate(crate_str: String) -> (String, CrateOrigin, Option<String>) {\n         let (version, origin) = match b.split_once(':') {\n             Some((\"CratesIo\", data)) => match data.split_once(',') {\n                 Some((version, url)) => {\n-                    (version, CrateOrigin::CratesIo { repo: Some(url.to_owned()) })\n+                    (version, CrateOrigin::CratesIo { repo: Some(url.to_owned()), name: None })\n                 }\n                 _ => panic!(\"Bad crates.io parameter: {}\", data),\n             },\n@@ -409,7 +409,7 @@ fn parse_crate(crate_str: String) -> (String, CrateOrigin, Option<String>) {\n         let crate_origin = match &*crate_str {\n             \"std\" => CrateOrigin::Lang(LangCrateOrigin::Std),\n             \"core\" => CrateOrigin::Lang(LangCrateOrigin::Core),\n-            _ => CrateOrigin::CratesIo { repo: None },\n+            _ => CrateOrigin::CratesIo { repo: None, name: None },\n         };\n         (crate_str, crate_origin, None)\n     }"}, {"sha": "e7f0c4ec29bf4e9bcfca1cd98df06c457ca033b9", "filename": "crates/base-db/src/input.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fbase-db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fbase-db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Finput.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -136,7 +136,7 @@ impl ops::Deref for CrateName {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum CrateOrigin {\n     /// Crates that are from crates.io official registry,\n-    CratesIo { repo: Option<String> },\n+    CratesIo { repo: Option<String>, name: Option<String> },\n     /// Crates that are provided by the language, like std, core, proc-macro, ...\n     Lang(LangCrateOrigin),\n }\n@@ -648,7 +648,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -660,7 +660,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         let crate3 = graph.add_crate_root(\n             FileId(3u32),\n@@ -672,7 +672,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -698,7 +698,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -710,7 +710,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -733,7 +733,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -745,7 +745,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         let crate3 = graph.add_crate_root(\n             FileId(3u32),\n@@ -757,7 +757,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -780,7 +780,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -792,7 +792,7 @@ mod tests {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         assert!(graph\n             .add_dep("}, {"sha": "ee1ad677a95f27ad3ff5a7d0049fb66e2c97f6a7", "filename": "crates/cfg/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fcfg%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fcfg%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -22,5 +22,5 @@ oorandom = \"11.1.3\"\n # We depend on both individually instead of using `features = [\"derive\"]` to microoptimize the\n # build graph: if the feature was enabled, syn would be built early on in the graph if `smolstr`\n # supports `arbitrary`. This way, we avoid feature unification.\n-arbitrary = \"1.1.0\"\n-derive_arbitrary = \"1.1.0\"\n+arbitrary = \"1.1.7\"\n+derive_arbitrary = \"1.1.6\""}, {"sha": "2ad32d24837d7771f0126ac6052c5965308cccae", "filename": "crates/flycheck/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -11,11 +11,11 @@ doctest = false\n \n [dependencies]\n crossbeam-channel = \"0.5.5\"\n-tracing = \"0.1.35\"\n+tracing = \"0.1.37\"\n cargo_metadata = \"0.15.0\"\n rustc-hash = \"1.1.0\"\n serde = { version = \"1.0.137\", features = [\"derive\"] }\n-serde_json = \"1.0.81\"\n+serde_json = \"1.0.86\"\n jod-thread = \"0.1.2\"\n \n toolchain = { path = \"../toolchain\", version = \"0.0.0\" }"}, {"sha": "e8c63d410aa754dd428aee664c771253caa30806", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -169,21 +169,30 @@ impl FlycheckActor {\n     }\n     fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n         let check_chan = self.cargo_handle.as_ref().map(|cargo| &cargo.receiver);\n+        if let Ok(msg) = inbox.try_recv() {\n+            // give restarts a preference so check outputs don't block a restart or stop\n+            return Some(Event::Restart(msg));\n+        }\n         select! {\n             recv(inbox) -> msg => msg.ok().map(Event::Restart),\n             recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n         }\n     }\n     fn run(mut self, inbox: Receiver<Restart>) {\n-        while let Some(event) = self.next_event(&inbox) {\n+        'event: while let Some(event) = self.next_event(&inbox) {\n             match event {\n                 Event::Restart(Restart::No) => {\n                     self.cancel_check_process();\n                 }\n                 Event::Restart(Restart::Yes) => {\n                     // Cancel the previously spawned process\n                     self.cancel_check_process();\n-                    while let Ok(_) = inbox.recv_timeout(Duration::from_millis(50)) {}\n+                    while let Ok(restart) = inbox.recv_timeout(Duration::from_millis(50)) {\n+                        // restart chained with a stop, so just cancel\n+                        if let Restart::No = restart {\n+                            continue 'event;\n+                        }\n+                    }\n \n                     let command = self.check_command();\n                     tracing::debug!(?command, \"will restart flycheck\");"}, {"sha": "4ad8e75970b5995909bea43cb6157b13c321b850", "filename": "crates/hir-def/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -15,17 +15,17 @@ arrayvec = \"0.7.2\"\n bitflags = \"1.3.2\"\n cov-mark = \"2.0.0-pre.1\"\n # We need to freeze the version of the crate, as the raw-api feature is considered unstable\n-dashmap = { version = \"=5.3.4\", features = [\"raw-api\"] }\n+dashmap = { version = \"=5.4.0\", features = [\"raw-api\"] }\n drop_bomb = \"0.1.5\"\n either = \"1.7.0\"\n fst = { version = \"0.4.7\", default-features = false }\n hashbrown = { version = \"0.12.1\", default-features = false }\n indexmap = \"1.9.1\"\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n-once_cell = \"1.12.0\"\n+once_cell = \"1.15.0\"\n rustc-hash = \"1.1.0\"\n-smallvec = \"1.9.0\"\n+smallvec = \"1.10.0\"\n tracing = \"0.1.35\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "938db032fbc8b6a79b130030750b1e48898857bd", "filename": "crates/hir-def/src/adt.rs", "status": "modified", "additions": 199, "deletions": 45, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fadt.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -1,28 +1,31 @@\n //! Defines hir-level representation of structs, enums and unions\n \n-use std::sync::Arc;\n+use std::{num::NonZeroU32, sync::Arc};\n \n use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n     name::{AsName, Name},\n-    InFile,\n+    HirFileId, InFile,\n };\n use la_arena::{Arena, ArenaMap};\n use syntax::ast::{self, HasName, HasVisibility};\n use tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n \n use crate::{\n     body::{CfgExpander, LowerCtx},\n+    builtin_type::{BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     intern::Interned,\n-    item_tree::{AttrOwner, Field, Fields, ItemTree, ModItem, RawVisibilityId},\n+    item_tree::{AttrOwner, Field, FieldAstId, Fields, ItemTree, ModItem, RawVisibilityId},\n+    nameres::diagnostics::DefDiagnostic,\n     src::HasChildSource,\n     src::HasSource,\n     trace::Trace,\n     type_ref::TypeRef,\n     visibility::RawVisibility,\n-    EnumId, LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StructId, UnionId, VariantId,\n+    EnumId, LocalEnumVariantId, LocalFieldId, LocalModuleId, Lookup, ModuleId, StructId, UnionId,\n+    VariantId,\n };\n use cfg::CfgOptions;\n \n@@ -31,14 +34,15 @@ use cfg::CfgOptions;\n pub struct StructData {\n     pub name: Name,\n     pub variant_data: Arc<VariantData>,\n-    pub repr: Option<ReprKind>,\n+    pub repr: Option<ReprData>,\n     pub visibility: RawVisibility,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumData {\n     pub name: Name,\n     pub variants: Arena<EnumVariantData>,\n+    pub repr: Option<ReprData>,\n     pub visibility: RawVisibility,\n }\n \n@@ -63,109 +67,226 @@ pub struct FieldData {\n     pub visibility: RawVisibility,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Copy, Debug, Clone, PartialEq, Eq)]\n pub enum ReprKind {\n-    Packed,\n-    Other,\n+    C,\n+    BuiltinInt { builtin: Either<BuiltinInt, BuiltinUint>, is_c: bool },\n+    Transparent,\n+    Default,\n+}\n+\n+#[derive(Copy, Debug, Clone, PartialEq, Eq)]\n+pub struct ReprData {\n+    pub kind: ReprKind,\n+    pub packed: bool,\n+    pub align: Option<NonZeroU32>,\n }\n \n fn repr_from_value(\n     db: &dyn DefDatabase,\n     krate: CrateId,\n     item_tree: &ItemTree,\n     of: AttrOwner,\n-) -> Option<ReprKind> {\n+) -> Option<ReprData> {\n     item_tree.attrs(db, krate, of).by_key(\"repr\").tt_values().find_map(parse_repr_tt)\n }\n \n-fn parse_repr_tt(tt: &Subtree) -> Option<ReprKind> {\n+fn parse_repr_tt(tt: &Subtree) -> Option<ReprData> {\n     match tt.delimiter {\n         Some(Delimiter { kind: DelimiterKind::Parenthesis, .. }) => {}\n         _ => return None,\n     }\n \n-    let mut it = tt.token_trees.iter();\n-    match it.next()? {\n-        TokenTree::Leaf(Leaf::Ident(ident)) if ident.text == \"packed\" => Some(ReprKind::Packed),\n-        _ => Some(ReprKind::Other),\n+    let mut data = ReprData { kind: ReprKind::Default, packed: false, align: None };\n+\n+    let mut tts = tt.token_trees.iter().peekable();\n+    while let Some(tt) = tts.next() {\n+        if let TokenTree::Leaf(Leaf::Ident(ident)) = tt {\n+            match &*ident.text {\n+                \"packed\" => {\n+                    data.packed = true;\n+                    if let Some(TokenTree::Subtree(_)) = tts.peek() {\n+                        tts.next();\n+                    }\n+                }\n+                \"align\" => {\n+                    if let Some(TokenTree::Subtree(tt)) = tts.peek() {\n+                        tts.next();\n+                        if let Some(TokenTree::Leaf(Leaf::Literal(lit))) = tt.token_trees.first() {\n+                            if let Ok(align) = lit.text.parse() {\n+                                data.align = Some(align);\n+                            }\n+                        }\n+                    }\n+                }\n+                \"C\" => {\n+                    if let ReprKind::BuiltinInt { is_c, .. } = &mut data.kind {\n+                        *is_c = true;\n+                    } else {\n+                        data.kind = ReprKind::C;\n+                    }\n+                }\n+                \"transparent\" => data.kind = ReprKind::Transparent,\n+                repr => {\n+                    let is_c = matches!(data.kind, ReprKind::C);\n+                    if let Some(builtin) = BuiltinInt::from_suffix(repr)\n+                        .map(Either::Left)\n+                        .or_else(|| BuiltinUint::from_suffix(repr).map(Either::Right))\n+                    {\n+                        data.kind = ReprKind::BuiltinInt { builtin, is_c };\n+                    }\n+                }\n+            }\n+        }\n     }\n+\n+    Some(data)\n }\n \n impl StructData {\n     pub(crate) fn struct_data_query(db: &dyn DefDatabase, id: StructId) -> Arc<StructData> {\n+        db.struct_data_with_diagnostics(id).0\n+    }\n+\n+    pub(crate) fn struct_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        id: StructId,\n+    ) -> (Arc<StructData>, Arc<[DefDiagnostic]>) {\n         let loc = id.lookup(db);\n         let krate = loc.container.krate;\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n         let strukt = &item_tree[loc.id.value];\n-        let variant_data = lower_fields(db, krate, &item_tree, &cfg_options, &strukt.fields, None);\n-        Arc::new(StructData {\n-            name: strukt.name.clone(),\n-            variant_data: Arc::new(variant_data),\n-            repr,\n-            visibility: item_tree[strukt.visibility].clone(),\n-        })\n+        let (variant_data, diagnostics) = lower_fields(\n+            db,\n+            krate,\n+            loc.id.file_id(),\n+            loc.container.local_id,\n+            &item_tree,\n+            &cfg_options,\n+            &strukt.fields,\n+            None,\n+        );\n+        (\n+            Arc::new(StructData {\n+                name: strukt.name.clone(),\n+                variant_data: Arc::new(variant_data),\n+                repr,\n+                visibility: item_tree[strukt.visibility].clone(),\n+            }),\n+            diagnostics.into(),\n+        )\n     }\n+\n     pub(crate) fn union_data_query(db: &dyn DefDatabase, id: UnionId) -> Arc<StructData> {\n+        db.union_data_with_diagnostics(id).0\n+    }\n+\n+    pub(crate) fn union_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        id: UnionId,\n+    ) -> (Arc<StructData>, Arc<[DefDiagnostic]>) {\n         let loc = id.lookup(db);\n         let krate = loc.container.krate;\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n         let union = &item_tree[loc.id.value];\n-        let variant_data = lower_fields(db, krate, &item_tree, &cfg_options, &union.fields, None);\n-\n-        Arc::new(StructData {\n-            name: union.name.clone(),\n-            variant_data: Arc::new(variant_data),\n-            repr,\n-            visibility: item_tree[union.visibility].clone(),\n-        })\n+        let (variant_data, diagnostics) = lower_fields(\n+            db,\n+            krate,\n+            loc.id.file_id(),\n+            loc.container.local_id,\n+            &item_tree,\n+            &cfg_options,\n+            &union.fields,\n+            None,\n+        );\n+        (\n+            Arc::new(StructData {\n+                name: union.name.clone(),\n+                variant_data: Arc::new(variant_data),\n+                repr,\n+                visibility: item_tree[union.visibility].clone(),\n+            }),\n+            diagnostics.into(),\n+        )\n     }\n }\n \n impl EnumData {\n     pub(crate) fn enum_data_query(db: &dyn DefDatabase, e: EnumId) -> Arc<EnumData> {\n+        db.enum_data_with_diagnostics(e).0\n+    }\n+\n+    pub(crate) fn enum_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        e: EnumId,\n+    ) -> (Arc<EnumData>, Arc<[DefDiagnostic]>) {\n         let loc = e.lookup(db);\n         let krate = loc.container.krate;\n         let item_tree = loc.id.item_tree(db);\n         let cfg_options = db.crate_graph()[krate].cfg_options.clone();\n+        let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n \n         let enum_ = &item_tree[loc.id.value];\n         let mut variants = Arena::new();\n+        let mut diagnostics = Vec::new();\n         for tree_id in enum_.variants.clone() {\n-            if item_tree.attrs(db, krate, tree_id.into()).is_cfg_enabled(&cfg_options) {\n-                let var = &item_tree[tree_id];\n-                let var_data = lower_fields(\n+            let attrs = item_tree.attrs(db, krate, tree_id.into());\n+            let var = &item_tree[tree_id];\n+            if attrs.is_cfg_enabled(&cfg_options) {\n+                let (var_data, field_diagnostics) = lower_fields(\n                     db,\n                     krate,\n+                    loc.id.file_id(),\n+                    loc.container.local_id,\n                     &item_tree,\n                     &cfg_options,\n                     &var.fields,\n                     Some(enum_.visibility),\n                 );\n+                diagnostics.extend(field_diagnostics);\n \n                 variants.alloc(EnumVariantData {\n                     name: var.name.clone(),\n                     variant_data: Arc::new(var_data),\n                 });\n+            } else {\n+                diagnostics.push(DefDiagnostic::unconfigured_code(\n+                    loc.container.local_id,\n+                    InFile::new(loc.id.file_id(), var.ast_id.upcast()),\n+                    attrs.cfg().unwrap(),\n+                    cfg_options.clone(),\n+                ))\n             }\n         }\n \n-        Arc::new(EnumData {\n-            name: enum_.name.clone(),\n-            variants,\n-            visibility: item_tree[enum_.visibility].clone(),\n-        })\n+        (\n+            Arc::new(EnumData {\n+                name: enum_.name.clone(),\n+                variants,\n+                repr,\n+                visibility: item_tree[enum_.visibility].clone(),\n+            }),\n+            diagnostics.into(),\n+        )\n     }\n \n     pub fn variant(&self, name: &Name) -> Option<LocalEnumVariantId> {\n         let (id, _) = self.variants.iter().find(|(_id, data)| &data.name == name)?;\n         Some(id)\n     }\n+\n+    pub fn variant_body_type(&self) -> Either<BuiltinInt, BuiltinUint> {\n+        match self.repr {\n+            Some(ReprData { kind: ReprKind::BuiltinInt { builtin, .. }, .. }) => builtin,\n+            _ => Either::Left(BuiltinInt::Isize),\n+        }\n+    }\n }\n \n impl HasChildSource<LocalEnumVariantId> for EnumId {\n@@ -324,31 +445,64 @@ fn lower_struct(\n fn lower_fields(\n     db: &dyn DefDatabase,\n     krate: CrateId,\n+    current_file_id: HirFileId,\n+    container: LocalModuleId,\n     item_tree: &ItemTree,\n     cfg_options: &CfgOptions,\n     fields: &Fields,\n     override_visibility: Option<RawVisibilityId>,\n-) -> VariantData {\n+) -> (VariantData, Vec<DefDiagnostic>) {\n+    let mut diagnostics = Vec::new();\n     match fields {\n         Fields::Record(flds) => {\n             let mut arena = Arena::new();\n             for field_id in flds.clone() {\n-                if item_tree.attrs(db, krate, field_id.into()).is_cfg_enabled(cfg_options) {\n-                    arena.alloc(lower_field(item_tree, &item_tree[field_id], override_visibility));\n+                let attrs = item_tree.attrs(db, krate, field_id.into());\n+                let field = &item_tree[field_id];\n+                if attrs.is_cfg_enabled(cfg_options) {\n+                    arena.alloc(lower_field(item_tree, field, override_visibility));\n+                } else {\n+                    diagnostics.push(DefDiagnostic::unconfigured_code(\n+                        container,\n+                        InFile::new(\n+                            current_file_id,\n+                            match field.ast_id {\n+                                FieldAstId::Record(it) => it.upcast(),\n+                                FieldAstId::Tuple(it) => it.upcast(),\n+                            },\n+                        ),\n+                        attrs.cfg().unwrap(),\n+                        cfg_options.clone(),\n+                    ))\n                 }\n             }\n-            VariantData::Record(arena)\n+            (VariantData::Record(arena), diagnostics)\n         }\n         Fields::Tuple(flds) => {\n             let mut arena = Arena::new();\n             for field_id in flds.clone() {\n-                if item_tree.attrs(db, krate, field_id.into()).is_cfg_enabled(cfg_options) {\n-                    arena.alloc(lower_field(item_tree, &item_tree[field_id], override_visibility));\n+                let attrs = item_tree.attrs(db, krate, field_id.into());\n+                let field = &item_tree[field_id];\n+                if attrs.is_cfg_enabled(cfg_options) {\n+                    arena.alloc(lower_field(item_tree, field, override_visibility));\n+                } else {\n+                    diagnostics.push(DefDiagnostic::unconfigured_code(\n+                        container,\n+                        InFile::new(\n+                            current_file_id,\n+                            match field.ast_id {\n+                                FieldAstId::Record(it) => it.upcast(),\n+                                FieldAstId::Tuple(it) => it.upcast(),\n+                            },\n+                        ),\n+                        attrs.cfg().unwrap(),\n+                        cfg_options.clone(),\n+                    ))\n                 }\n             }\n-            VariantData::Tuple(arena)\n+            (VariantData::Tuple(arena), diagnostics)\n         }\n-        Fields::Unit => VariantData::Unit,\n+        Fields::Unit => (VariantData::Unit, diagnostics),\n     }\n }\n "}, {"sha": "759f3b8c04b6cdb1e2ea7cd02cc52b2df7f4b894", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -27,7 +27,7 @@ use crate::{\n     macro_id_to_def_id,\n     nameres::DefMap,\n     path::{ModPath, Path},\n-    src::HasSource,\n+    src::{HasChildSource, HasSource},\n     AsMacroCall, BlockId, DefWithBodyId, HasModule, LocalModuleId, Lookup, MacroId, ModuleId,\n     UnresolvedMacro,\n };\n@@ -311,7 +311,20 @@ impl Body {\n             DefWithBodyId::FunctionId(f) => {\n                 let f = f.lookup(db);\n                 let src = f.source(db);\n-                params = src.value.param_list();\n+                params = src.value.param_list().map(|param_list| {\n+                    let item_tree = f.id.item_tree(db);\n+                    let func = &item_tree[f.id.value];\n+                    let krate = f.container.module(db).krate;\n+                    let crate_graph = db.crate_graph();\n+                    (\n+                        param_list,\n+                        func.params.clone().map(move |param| {\n+                            item_tree\n+                                .attrs(db, krate, param.into())\n+                                .is_cfg_enabled(&crate_graph[krate].cfg_options)\n+                        }),\n+                    )\n+                });\n                 (src.file_id, f.module(db), src.value.body().map(ast::Expr::from))\n             }\n             DefWithBodyId::ConstId(c) => {\n@@ -324,10 +337,17 @@ impl Body {\n                 let src = s.source(db);\n                 (src.file_id, s.module(db), src.value.body())\n             }\n+            DefWithBodyId::VariantId(v) => {\n+                let e = v.parent.lookup(db);\n+                let src = v.parent.child_source(db);\n+                let variant = &src.value[v.local_id];\n+                (src.file_id, e.container, variant.expr())\n+            }\n         };\n         let expander = Expander::new(db, file_id, module);\n         let (mut body, source_map) = Body::new(db, expander, params, body);\n         body.shrink_to_fit();\n+\n         (Arc::new(body), Arc::new(source_map))\n     }\n \n@@ -364,7 +384,7 @@ impl Body {\n     fn new(\n         db: &dyn DefDatabase,\n         expander: Expander,\n-        params: Option<ast::ParamList>,\n+        params: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n         body: Option<ast::Expr>,\n     ) -> (Body, BodySourceMap) {\n         lower::lower(db, expander, params, body)"}, {"sha": "ccc01c3efca51468eb320a664128bba7d61473e7", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -29,8 +29,9 @@ use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     expr::{\n-        dummy_expr_id, Array, BindingAnnotation, Expr, ExprId, FloatTypeWrapper, Label, LabelId,\n-        Literal, MatchArm, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n+        dummy_expr_id, Array, BindingAnnotation, ClosureKind, Expr, ExprId, FloatTypeWrapper,\n+        Label, LabelId, Literal, MatchArm, Movability, Pat, PatId, RecordFieldPat, RecordLitField,\n+        Statement,\n     },\n     intern::Interned,\n     item_scope::BuiltinShadowMode,\n@@ -76,7 +77,7 @@ impl<'a> LowerCtx<'a> {\n pub(super) fn lower(\n     db: &dyn DefDatabase,\n     expander: Expander,\n-    params: Option<ast::ParamList>,\n+    params: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n     body: Option<ast::Expr>,\n ) -> (Body, BodySourceMap) {\n     ExprCollector {\n@@ -97,6 +98,7 @@ pub(super) fn lower(\n         name_to_pat_grouping: Default::default(),\n         is_lowering_inside_or_pat: false,\n         is_lowering_assignee_expr: false,\n+        is_lowering_generator: false,\n     }\n     .collect(params, body)\n }\n@@ -111,16 +113,19 @@ struct ExprCollector<'a> {\n     name_to_pat_grouping: FxHashMap<Name, Vec<PatId>>,\n     is_lowering_inside_or_pat: bool,\n     is_lowering_assignee_expr: bool,\n+    is_lowering_generator: bool,\n }\n \n impl ExprCollector<'_> {\n     fn collect(\n         mut self,\n-        param_list: Option<ast::ParamList>,\n+        param_list: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n         body: Option<ast::Expr>,\n     ) -> (Body, BodySourceMap) {\n-        if let Some(param_list) = param_list {\n-            if let Some(self_param) = param_list.self_param() {\n+        if let Some((param_list, mut attr_enabled)) = param_list {\n+            if let Some(self_param) =\n+                param_list.self_param().filter(|_| attr_enabled.next().unwrap_or(false))\n+            {\n                 let ptr = AstPtr::new(&self_param);\n                 let param_pat = self.alloc_pat(\n                     Pat::Bind {\n@@ -136,7 +141,11 @@ impl ExprCollector<'_> {\n                 self.body.params.push(param_pat);\n             }\n \n-            for pat in param_list.params().filter_map(|param| param.pat()) {\n+            for pat in param_list\n+                .params()\n+                .zip(attr_enabled)\n+                .filter_map(|(param, enabled)| param.pat().filter(|_| enabled))\n+            {\n                 let param_pat = self.collect_pat(pat);\n                 self.body.params.push(param_pat);\n             }\n@@ -358,6 +367,7 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n             ast::Expr::YieldExpr(e) => {\n+                self.is_lowering_generator = true;\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Yield { expr }, syntax_ptr)\n             }\n@@ -459,13 +469,31 @@ impl ExprCollector<'_> {\n                     .ret_type()\n                     .and_then(|r| r.ty())\n                     .map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n+\n+                let prev_is_lowering_generator = self.is_lowering_generator;\n+                self.is_lowering_generator = false;\n+\n                 let body = self.collect_expr_opt(e.body());\n+\n+                let closure_kind = if self.is_lowering_generator {\n+                    let movability = if e.static_token().is_some() {\n+                        Movability::Static\n+                    } else {\n+                        Movability::Movable\n+                    };\n+                    ClosureKind::Generator(movability)\n+                } else {\n+                    ClosureKind::Closure\n+                };\n+                self.is_lowering_generator = prev_is_lowering_generator;\n+\n                 self.alloc_expr(\n                     Expr::Closure {\n                         args: args.into(),\n                         arg_types: arg_types.into(),\n                         ret_type,\n                         body,\n+                        closure_kind,\n                     },\n                     syntax_ptr,\n                 )"}, {"sha": "162d173d52404d9adcc05c3eae3dde82c461a855", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -2,8 +2,10 @@\n \n use std::fmt::{self, Write};\n \n+use syntax::ast::HasName;\n+\n use crate::{\n-    expr::{Array, BindingAnnotation, Literal, Statement},\n+    expr::{Array, BindingAnnotation, ClosureKind, Literal, Movability, Statement},\n     pretty::{print_generic_args, print_path, print_type_ref},\n     type_ref::TypeRef,\n };\n@@ -32,6 +34,16 @@ pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBo\n             };\n             format!(\"const {} = \", name)\n         }\n+        DefWithBodyId::VariantId(it) => {\n+            needs_semi = false;\n+            let src = it.parent.child_source(db);\n+            let variant = &src.value[it.local_id];\n+            let name = match &variant.name() {\n+                Some(name) => name.to_string(),\n+                None => \"_\".to_string(),\n+            };\n+            format!(\"{}\", name)\n+        }\n     };\n \n     let mut p = Printer { body, buf: header, indent_level: 0, needs_indent: false };\n@@ -350,7 +362,10 @@ impl<'a> Printer<'a> {\n                 self.print_expr(*index);\n                 w!(self, \"]\");\n             }\n-            Expr::Closure { args, arg_types, ret_type, body } => {\n+            Expr::Closure { args, arg_types, ret_type, body, closure_kind } => {\n+                if let ClosureKind::Generator(Movability::Static) = closure_kind {\n+                    w!(self, \"static \");\n+                }\n                 w!(self, \"|\");\n                 for (i, (pat, ty)) in args.iter().zip(arg_types.iter()).enumerate() {\n                     if i != 0 {"}, {"sha": "39581b33a8da2b7a3b5387de6ee50333d7b0e634", "filename": "crates/hir-def/src/builtin_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -379,7 +379,7 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ==========================================================================\n \n     rustc_attr!(rustc_allocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n-    rustc_attr!(rustc_allocator_nounwind, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n+    rustc_attr!(rustc_nounwind, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n     gated!(\n         alloc_error_handler, Normal, template!(Word), WarnFollowing,\n         experimental!(alloc_error_handler)"}, {"sha": "bb13165257ba416c0d32e909c67750c1e99b6fa2", "filename": "crates/hir-def/src/child_by_source.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -198,6 +198,10 @@ impl ChildBySource for EnumId {\n impl ChildBySource for DefWithBodyId {\n     fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n         let body = db.body(*self);\n+        if let &DefWithBodyId::VariantId(v) = self {\n+            VariantId::EnumVariantId(v).child_by_source_to(db, res, file_id)\n+        }\n+\n         for (_, def_map) in body.blocks(db) {\n             // All block expressions are merged into the same map, because they logically all add\n             // inner items to the containing `DefWithBodyId`."}, {"sha": "2dc69b00ace00d12659f844b1ceafee85a2b4957", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -219,7 +219,7 @@ impl TraitData {\n     pub(crate) fn trait_data_with_diagnostics_query(\n         db: &dyn DefDatabase,\n         tr: TraitId,\n-    ) -> (Arc<TraitData>, Arc<Vec<DefDiagnostic>>) {\n+    ) -> (Arc<TraitData>, Arc<[DefDiagnostic]>) {\n         let tr_loc @ ItemLoc { container: module_id, id: tree_id } = tr.lookup(db);\n         let item_tree = tree_id.item_tree(db);\n         let tr_def = &item_tree[tree_id.value];\n@@ -251,7 +251,7 @@ impl TraitData {\n                 visibility,\n                 skip_array_during_method_dispatch,\n             }),\n-            Arc::new(diagnostics),\n+            diagnostics.into(),\n         )\n     }\n \n@@ -299,7 +299,7 @@ impl ImplData {\n     pub(crate) fn impl_data_with_diagnostics_query(\n         db: &dyn DefDatabase,\n         id: ImplId,\n-    ) -> (Arc<ImplData>, Arc<Vec<DefDiagnostic>>) {\n+    ) -> (Arc<ImplData>, Arc<[DefDiagnostic]>) {\n         let _p = profile::span(\"impl_data_with_diagnostics_query\");\n         let ItemLoc { container: module_id, id: tree_id } = id.lookup(db);\n \n@@ -318,7 +318,7 @@ impl ImplData {\n \n         (\n             Arc::new(ImplData { target_trait, self_ty, items, is_negative, attribute_calls }),\n-            Arc::new(diagnostics),\n+            diagnostics.into(),\n         )\n     }\n "}, {"sha": "431c8255497b62e17741350c424f069f23b04f11", "filename": "crates/hir-def/src/db.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdb.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -97,24 +97,33 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(StructData::struct_data_query)]\n     fn struct_data(&self, id: StructId) -> Arc<StructData>;\n \n+    #[salsa::invoke(StructData::struct_data_with_diagnostics_query)]\n+    fn struct_data_with_diagnostics(&self, id: StructId)\n+        -> (Arc<StructData>, Arc<[DefDiagnostic]>);\n+\n     #[salsa::invoke(StructData::union_data_query)]\n     fn union_data(&self, id: UnionId) -> Arc<StructData>;\n \n+    #[salsa::invoke(StructData::union_data_with_diagnostics_query)]\n+    fn union_data_with_diagnostics(&self, id: UnionId) -> (Arc<StructData>, Arc<[DefDiagnostic]>);\n+\n     #[salsa::invoke(EnumData::enum_data_query)]\n     fn enum_data(&self, e: EnumId) -> Arc<EnumData>;\n \n+    #[salsa::invoke(EnumData::enum_data_with_diagnostics_query)]\n+    fn enum_data_with_diagnostics(&self, e: EnumId) -> (Arc<EnumData>, Arc<[DefDiagnostic]>);\n+\n     #[salsa::invoke(ImplData::impl_data_query)]\n     fn impl_data(&self, e: ImplId) -> Arc<ImplData>;\n \n     #[salsa::invoke(ImplData::impl_data_with_diagnostics_query)]\n-    fn impl_data_with_diagnostics(&self, e: ImplId) -> (Arc<ImplData>, Arc<Vec<DefDiagnostic>>);\n+    fn impl_data_with_diagnostics(&self, e: ImplId) -> (Arc<ImplData>, Arc<[DefDiagnostic]>);\n \n     #[salsa::invoke(TraitData::trait_data_query)]\n     fn trait_data(&self, e: TraitId) -> Arc<TraitData>;\n \n     #[salsa::invoke(TraitData::trait_data_with_diagnostics_query)]\n-    fn trait_data_with_diagnostics(&self, tr: TraitId)\n-        -> (Arc<TraitData>, Arc<Vec<DefDiagnostic>>);\n+    fn trait_data_with_diagnostics(&self, tr: TraitId) -> (Arc<TraitData>, Arc<[DefDiagnostic]>);\n \n     #[salsa::invoke(TypeAliasData::type_alias_data_query)]\n     fn type_alias_data(&self, e: TypeAliasId) -> Arc<TypeAliasData>;"}, {"sha": "16264655020712fe2caa3afcc1563c960cdbfc09", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -198,6 +198,7 @@ pub enum Expr {\n         arg_types: Box<[Option<Interned<TypeRef>>]>,\n         ret_type: Option<Interned<TypeRef>>,\n         body: ExprId,\n+        closure_kind: ClosureKind,\n     },\n     Tuple {\n         exprs: Box<[ExprId]>,\n@@ -211,6 +212,18 @@ pub enum Expr {\n     Underscore,\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ClosureKind {\n+    Closure,\n+    Generator(Movability),\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum Movability {\n+    Static,\n+    Movable,\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Array {\n     ElementList { elements: Box<[ExprId]>, is_assignee_expr: bool },"}, {"sha": "c70e6fdccdcde56c5d6a18ba4fe5c5c235c65cdb", "filename": "crates/hir-def/src/find_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ffind_path.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -333,8 +333,8 @@ fn calculate_best_path(\n                     db,\n                     def_map,\n                     visited_modules,\n-                    from,\n                     crate_root,\n+                    from,\n                     info.container,\n                     max_len - 1,\n                     prefixed,"}, {"sha": "570344596def80a2c62711c72ba2b1fa11358dbf", "filename": "crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -943,6 +943,7 @@ impl AssocItem {\n pub struct Variant {\n     pub name: Name,\n     pub fields: Fields,\n+    pub ast_id: FileAstId<ast::Variant>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -952,10 +953,17 @@ pub enum Fields {\n     Unit,\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum FieldAstId {\n+    Record(FileAstId<ast::RecordField>),\n+    Tuple(FileAstId<ast::TupleField>),\n+}\n+\n /// A single field of an enum variant or struct\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Field {\n     pub name: Name,\n     pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibilityId,\n+    pub ast_id: FieldAstId,\n }"}, {"sha": "077a1b619dd5a056cd89c79a14e260b32aafc7ed", "filename": "crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -184,7 +184,8 @@ impl<'a> Ctx<'a> {\n         let name = field.name()?.as_name();\n         let visibility = self.lower_visibility(field);\n         let type_ref = self.lower_type_ref_opt(field.ty());\n-        let res = Field { name, type_ref, visibility };\n+        let ast_id = FieldAstId::Record(self.source_ast_id_map.ast_id(field));\n+        let res = Field { name, type_ref, visibility, ast_id };\n         Some(res)\n     }\n \n@@ -203,7 +204,8 @@ impl<'a> Ctx<'a> {\n         let name = Name::new_tuple_field(idx);\n         let visibility = self.lower_visibility(field);\n         let type_ref = self.lower_type_ref_opt(field.ty());\n-        Field { name, type_ref, visibility }\n+        let ast_id = FieldAstId::Tuple(self.source_ast_id_map.ast_id(field));\n+        Field { name, type_ref, visibility, ast_id }\n     }\n \n     fn lower_union(&mut self, union: &ast::Union) -> Option<FileItemTreeId<Union>> {\n@@ -247,7 +249,8 @@ impl<'a> Ctx<'a> {\n     fn lower_variant(&mut self, variant: &ast::Variant) -> Option<Variant> {\n         let name = variant.name()?.as_name();\n         let fields = self.lower_fields(&variant.kind());\n-        let res = Variant { name, fields };\n+        let ast_id = self.source_ast_id_map.ast_id(variant);\n+        let res = Variant { name, fields, ast_id };\n         Some(res)\n     }\n "}, {"sha": "da1643152c2fe09f3683aeb495b67f3371e3c4ff", "filename": "crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -115,7 +115,7 @@ impl<'a> Printer<'a> {\n                 w!(self, \"{{\");\n                 self.indented(|this| {\n                     for field in fields.clone() {\n-                        let Field { visibility, name, type_ref } = &this.tree[field];\n+                        let Field { visibility, name, type_ref, ast_id: _ } = &this.tree[field];\n                         this.print_attrs_of(field);\n                         this.print_visibility(*visibility);\n                         w!(this, \"{}: \", name);\n@@ -129,7 +129,7 @@ impl<'a> Printer<'a> {\n                 w!(self, \"(\");\n                 self.indented(|this| {\n                     for field in fields.clone() {\n-                        let Field { visibility, name, type_ref } = &this.tree[field];\n+                        let Field { visibility, name, type_ref, ast_id: _ } = &this.tree[field];\n                         this.print_attrs_of(field);\n                         this.print_visibility(*visibility);\n                         w!(this, \"{}: \", name);\n@@ -323,7 +323,7 @@ impl<'a> Printer<'a> {\n                 self.print_where_clause_and_opening_brace(generic_params);\n                 self.indented(|this| {\n                     for variant in variants.clone() {\n-                        let Variant { name, fields } = &this.tree[variant];\n+                        let Variant { name, fields, ast_id: _ } = &this.tree[variant];\n                         this.print_attrs_of(variant);\n                         w!(this, \"{}\", name);\n                         this.print_fields(fields);"}, {"sha": "5c7aa72349f6e1c89be036ed2a539610926cc8c5", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -474,16 +474,24 @@ pub enum DefWithBodyId {\n     FunctionId(FunctionId),\n     StaticId(StaticId),\n     ConstId(ConstId),\n+    VariantId(EnumVariantId),\n }\n \n impl_from!(FunctionId, ConstId, StaticId for DefWithBodyId);\n \n+impl From<EnumVariantId> for DefWithBodyId {\n+    fn from(id: EnumVariantId) -> Self {\n+        DefWithBodyId::VariantId(id)\n+    }\n+}\n+\n impl DefWithBodyId {\n     pub fn as_generic_def_id(self) -> Option<GenericDefId> {\n         match self {\n             DefWithBodyId::FunctionId(f) => Some(f.into()),\n             DefWithBodyId::StaticId(_) => None,\n             DefWithBodyId::ConstId(c) => Some(c.into()),\n+            DefWithBodyId::VariantId(c) => Some(c.into()),\n         }\n     }\n }\n@@ -681,6 +689,7 @@ impl HasModule for DefWithBodyId {\n             DefWithBodyId::FunctionId(it) => it.lookup(db).module(db),\n             DefWithBodyId::StaticId(it) => it.lookup(db).module(db),\n             DefWithBodyId::ConstId(it) => it.lookup(db).module(db),\n+            DefWithBodyId::VariantId(it) => it.parent.lookup(db).container,\n         }\n     }\n }\n@@ -691,6 +700,7 @@ impl DefWithBodyId {\n             DefWithBodyId::FunctionId(it) => it.lookup(db).id.value.into(),\n             DefWithBodyId::StaticId(it) => it.lookup(db).id.value.into(),\n             DefWithBodyId::ConstId(it) => it.lookup(db).id.value.into(),\n+            DefWithBodyId::VariantId(it) => it.parent.lookup(db).id.value.into(),\n         }\n     }\n }"}, {"sha": "c04cd1651926dfb86d412835c2c343e219a40e7f", "filename": "crates/hir-def/src/macro_expansion_tests/builtin_fn_macro.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -93,12 +93,12 @@ macro_rules! option_env {() => {}}\n \n fn main() { option_env!(\"TEST_ENV_VAR\"); }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[rustc_builtin_macro]\n macro_rules! option_env {() => {}}\n \n-fn main() { std::option::Option::None:: < &str>; }\n-\"##]],\n+fn main() { $crate::option::Option::None:: < &str>; }\n+\"#]],\n     );\n }\n \n@@ -191,17 +191,17 @@ fn main() {\n     format_args!(\"{} {:?}\", arg1(a, b, c), arg2);\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n     ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n }\n \n fn main() {\n-    std::fmt::Arguments::new_v1(&[], &[std::fmt::ArgumentV1::new(&(arg1(a, b, c)), std::fmt::Display::fmt), std::fmt::ArgumentV1::new(&(arg2), std::fmt::Display::fmt), ]);\n+    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(arg1(a, b, c)), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(arg2), $crate::fmt::Display::fmt), ]);\n }\n-\"##]],\n+\"#]],\n     );\n }\n \n@@ -219,17 +219,17 @@ fn main() {\n     format_args!(\"{} {:?}\", a::<A,B>(), b);\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n     ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n }\n \n fn main() {\n-    std::fmt::Arguments::new_v1(&[], &[std::fmt::ArgumentV1::new(&(a::<A, B>()), std::fmt::Display::fmt), std::fmt::ArgumentV1::new(&(b), std::fmt::Display::fmt), ]);\n+    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(a::<A, B>()), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(b), $crate::fmt::Display::fmt), ]);\n }\n-\"##]],\n+\"#]],\n     );\n }\n \n@@ -248,7 +248,7 @@ fn main() {\n         format_args!/*+errors*/(\"{} {:?}\", a.);\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n@@ -258,9 +258,9 @@ macro_rules! format_args {\n fn main() {\n     let _ =\n         /* parse error: expected field name or number */\n-std::fmt::Arguments::new_v1(&[], &[std::fmt::ArgumentV1::new(&(a.), std::fmt::Display::fmt), ]);\n+$crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(a.), $crate::fmt::Display::fmt), ]);\n }\n-\"##]],\n+\"#]],\n     );\n }\n "}, {"sha": "9ffc218818ca164cd91f0609941b3a7f5e80d8a2", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -2122,7 +2122,7 @@ impl ModCollector<'_, '_> {\n     fn emit_unconfigured_diagnostic(&mut self, item: ModItem, cfg: &CfgExpr) {\n         let ast_id = item.ast_id(self.item_tree);\n \n-        let ast_id = InFile::new(self.file_id(), ast_id);\n+        let ast_id = InFile::new(self.file_id(), ast_id.upcast());\n         self.def_collector.def_map.diagnostics.push(DefDiagnostic::unconfigured_code(\n             self.module_id,\n             ast_id,"}, {"sha": "066142291981dd9debf879d8a1ece627f2292a32", "filename": "crates/hir-def/src/nameres/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -4,7 +4,7 @@ use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use hir_expand::MacroCallKind;\n use la_arena::Idx;\n-use syntax::ast;\n+use syntax::ast::{self, AnyHasAttrs};\n \n use crate::{\n     attr::AttrId,\n@@ -22,7 +22,7 @@ pub enum DefDiagnosticKind {\n \n     UnresolvedImport { id: ItemTreeId<item_tree::Import>, index: Idx<ast::UseTree> },\n \n-    UnconfiguredCode { ast: AstId<ast::Item>, cfg: CfgExpr, opts: CfgOptions },\n+    UnconfiguredCode { ast: AstId<AnyHasAttrs>, cfg: CfgExpr, opts: CfgOptions },\n \n     UnresolvedProcMacro { ast: MacroCallKind, krate: CrateId },\n \n@@ -75,7 +75,7 @@ impl DefDiagnostic {\n \n     pub fn unconfigured_code(\n         container: LocalModuleId,\n-        ast: AstId<ast::Item>,\n+        ast: AstId<ast::AnyHasAttrs>,\n         cfg: CfgExpr,\n         opts: CfgOptions,\n     ) -> Self {"}, {"sha": "070f6837133a3b645eb16bb37282d13515d9e798", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -839,6 +839,7 @@ impl HasResolver for DefWithBodyId {\n             DefWithBodyId::ConstId(c) => c.resolver(db),\n             DefWithBodyId::FunctionId(f) => f.resolver(db),\n             DefWithBodyId::StaticId(s) => s.resolver(db),\n+            DefWithBodyId::VariantId(v) => v.parent.resolver(db),\n         }\n     }\n }"}, {"sha": "3359c99b3961c098ef788b2ec02086160a1e9d98", "filename": "crates/hir-expand/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -15,11 +15,11 @@ tracing = \"0.1.35\"\n either = \"1.7.0\"\n rustc-hash = \"1.1.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n hashbrown = { version = \"0.12.1\", features = [\n     \"inline-more\",\n ], default-features = false }\n-smallvec = { version = \"1.9.0\", features = [\"const_new\"] }\n+smallvec = { version = \"1.10.0\", features = [\"const_new\"] }\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n base-db = { path = \"../base-db\", version = \"0.0.0\" }"}, {"sha": "2b27db0e950630e34601f19640d691f27bad5835", "filename": "crates/hir-expand/src/ast_id_map.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -93,7 +93,12 @@ impl AstIdMap {\n         // trait does not change ids of top-level items, which helps caching.\n         bdfs(node, |it| {\n             let kind = it.kind();\n-            if ast::Item::can_cast(kind) || ast::BlockExpr::can_cast(kind) {\n+            if ast::Item::can_cast(kind)\n+                || ast::BlockExpr::can_cast(kind)\n+                || ast::Variant::can_cast(kind)\n+                || ast::RecordField::can_cast(kind)\n+                || ast::TupleField::can_cast(kind)\n+            {\n                 res.alloc(&it);\n                 true\n             } else {"}, {"sha": "7b19518e25a8437a16c302dcb8f9399a2faebd34", "filename": "crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -238,9 +238,9 @@ fn format_args_expand(\n ) -> ExpandResult<tt::Subtree> {\n     // We expand `format_args!(\"\", a1, a2)` to\n     // ```\n-    // std::fmt::Arguments::new_v1(&[], &[\n-    //   std::fmt::ArgumentV1::new(&arg1,std::fmt::Display::fmt),\n-    //   std::fmt::ArgumentV1::new(&arg2,std::fmt::Display::fmt),\n+    // $crate::fmt::Arguments::new_v1(&[], &[\n+    //   $crate::fmt::ArgumentV1::new(&arg1,$crate::fmt::Display::fmt),\n+    //   $crate::fmt::ArgumentV1::new(&arg2,$crate::fmt::Display::fmt),\n     // ])\n     // ```,\n     // which is still not really correct, but close enough for now\n@@ -262,10 +262,10 @@ fn format_args_expand(\n     }\n     let _format_string = args.remove(0);\n     let arg_tts = args.into_iter().flat_map(|arg| {\n-        quote! { std::fmt::ArgumentV1::new(&(#arg), std::fmt::Display::fmt), }\n+        quote! { #DOLLAR_CRATE::fmt::ArgumentV1::new(&(#arg), #DOLLAR_CRATE::fmt::Display::fmt), }\n     }.token_trees);\n     let expanded = quote! {\n-        std::fmt::Arguments::new_v1(&[], &[##arg_tts])\n+        #DOLLAR_CRATE::fmt::Arguments::new_v1(&[], &[##arg_tts])\n     };\n     ExpandResult::ok(expanded)\n }\n@@ -675,8 +675,8 @@ fn option_env_expand(\n     };\n \n     let expanded = match get_env_inner(db, arg_id, &key) {\n-        None => quote! { std::option::Option::None::<&str> },\n-        Some(s) => quote! { std::option::Some(#s) },\n+        None => quote! { #DOLLAR_CRATE::option::Option::None::<&str> },\n+        Some(s) => quote! { #DOLLAR_CRATE::option::Some(#s) },\n     };\n \n     ExpandResult::ok(ExpandedEager::new(expanded))"}, {"sha": "87e4db03984ab9dbecf555e67e36046b7c7da5c3", "filename": "crates/hir-expand/src/db.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -221,8 +221,16 @@ pub fn expand_speculative(\n     fixup::reverse_fixups(&mut speculative_expansion.value, &spec_args_tmap, &fixups.undo_info);\n     let (node, rev_tmap) = token_tree_to_syntax_node(&speculative_expansion.value, expand_to);\n \n-    let range = rev_tmap.first_range_by_token(token_id, token_to_map.kind())?;\n-    let token = node.syntax_node().covering_element(range).into_token()?;\n+    let syntax_node = node.syntax_node();\n+    let token = rev_tmap\n+        .ranges_by_token(token_id, token_to_map.kind())\n+        .filter_map(|range| syntax_node.covering_element(range).into_token())\n+        .min_by_key(|t| {\n+            // prefer tokens of the same kind and text\n+            // Note the inversion of the score here, as we want to prefer the first token in case\n+            // of all tokens having the same score\n+            (t.kind() != token_to_map.kind()) as u8 + (t.text() != token_to_map.text()) as u8\n+        })?;\n     Some((node.syntax_node(), token))\n }\n "}, {"sha": "a5b499fe8d9d44809e0fcbd8847e61ce3ffd5c7e", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -811,6 +811,31 @@ impl<'a> InFile<&'a SyntaxNode> {\n             _ => None,\n         }\n     }\n+\n+    pub fn original_syntax_node(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxNode>> {\n+        // This kind of upmapping can only be achieved in attribute expanded files,\n+        // as we don't have node inputs otherwise and  therefor can't find an `N` node in the input\n+        if !self.file_id.is_macro() {\n+            return Some(self.map(Clone::clone));\n+        } else if !self.file_id.is_attr_macro(db) {\n+            return None;\n+        }\n+\n+        if let Some(InFile { file_id, value: (first, last) }) = ascend_node_border_tokens(db, self)\n+        {\n+            if file_id.is_macro() {\n+                let range = first.text_range().cover(last.text_range());\n+                tracing::error!(\"Failed mapping out of macro file for {:?}\", range);\n+                return None;\n+            }\n+            // FIXME: This heuristic is brittle and with the right macro may select completely unrelated nodes\n+            let anc = algo::least_common_ancestor(&first.parent()?, &last.parent()?)?;\n+            let kind = self.value.kind();\n+            let value = anc.ancestors().find(|it| it.kind() == kind)?;\n+            return Some(InFile::new(file_id, value));\n+        }\n+        None\n+    }\n }\n \n impl InFile<SyntaxToken> {"}, {"sha": "68413df420c7d7053c1f707f31fb5cc21d7affa0", "filename": "crates/hir-expand/src/mod_path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -259,6 +259,7 @@ macro_rules! __known_path {\n     (core::future::Future) => {};\n     (core::future::IntoFuture) => {};\n     (core::ops::Try) => {};\n+    (core::ops::FromResidual) => {};\n     ($path:path) => {\n         compile_error!(\"Please register your known path in the path module\")\n     };"}, {"sha": "8a735b965ab8460a49003399a12b25e13cb9830b", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -263,6 +263,7 @@ pub mod known {\n         Iterator,\n         IntoIterator,\n         Item,\n+        IntoIter,\n         Try,\n         Ok,\n         Future,\n@@ -278,6 +279,8 @@ pub mod known {\n         RangeToInclusive,\n         RangeTo,\n         Range,\n+        Residual,\n+        FromResidual,\n         Neg,\n         Not,\n         None,"}, {"sha": "ed13275bab8fecd36b516048b8c8d17188123805", "filename": "crates/hir-ty/Cargo.toml", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -11,18 +11,19 @@ doctest = false\n \n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n arrayvec = \"0.7.2\"\n-smallvec = \"1.9.0\"\n+smallvec = \"1.10.0\"\n ena = \"0.14.0\"\n tracing = \"0.1.35\"\n rustc-hash = \"1.1.0\"\n scoped-tls = \"1.0.0\"\n-chalk-solve = { version = \"0.84.0\", default-features = false }\n-chalk-ir = \"0.84.0\"\n-chalk-recursive = { version = \"0.84.0\", default-features = false }\n+chalk-solve = { version = \"0.86.0\", default-features = false }\n+chalk-ir = \"0.86.0\"\n+chalk-recursive = { version = \"0.86.0\", default-features = false }\n+chalk-derive = \"0.86.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n-once_cell = \"1.12.0\"\n+once_cell = \"1.15.0\"\n typed-arena = \"2.0.1\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n@@ -37,7 +38,7 @@ limit = { path = \"../limit\", version = \"0.0.0\" }\n test-utils = { path = \"../test-utils\" }\n expect-test = \"1.4.0\"\n tracing = \"0.1.35\"\n-tracing-subscriber = { version = \"0.3.14\", default-features = false, features = [\n+tracing-subscriber = { version = \"0.3.16\", default-features = false, features = [\n     \"env-filter\",\n     \"registry\",\n ] }"}, {"sha": "78911d8dc0772be48ebec328c43bf0e082663c04", "filename": "crates/hir-ty/src/autoderef.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -1,7 +1,7 @@\n //! In certain situations, rust automatically inserts derefs as necessary: for\n //! example, field accesses `foo.bar` still work when `foo` is actually a\n //! reference to a type with the field `bar`. This is an approximation of the\n-//! logic in rustc (which lives in librustc_typeck/check/autoderef.rs).\n+//! logic in rustc (which lives in rustc_hir_analysis/check/autoderef.rs).\n \n use std::sync::Arc;\n \n@@ -123,13 +123,14 @@ fn deref_by_trait(table: &mut InferenceTable<'_>, ty: Ty) -> Option<Ty> {\n     let target = db.trait_data(deref_trait).associated_type_by_name(&name![Target])?;\n \n     let projection = {\n-        let b = TyBuilder::assoc_type_projection(db, target);\n+        let b = TyBuilder::subst_for_def(db, deref_trait, None);\n         if b.remaining() != 1 {\n             // the Target type + Deref trait should only have one generic parameter,\n             // namely Deref's Self type\n             return None;\n         }\n-        b.push(ty).build()\n+        let deref_subst = b.push(ty).build();\n+        TyBuilder::assoc_type_projection(db, target, Some(deref_subst)).build()\n     };\n \n     // Check that the type implements Deref at all"}, {"sha": "9ae752556d890df8161c55ea7f937f2fec581aa1", "filename": "crates/hir-ty/src/builder.rs", "status": "modified", "additions": 132, "deletions": 85, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -6,19 +6,19 @@ use chalk_ir::{\n     cast::{Cast, CastTo, Caster},\n     fold::TypeFoldable,\n     interner::HasInterner,\n-    AdtId, BoundVar, DebruijnIndex, Scalar,\n+    AdtId, DebruijnIndex, Scalar,\n };\n use hir_def::{\n-    builtin_type::BuiltinType, generics::TypeOrConstParamData, ConstParamId, GenericDefId, TraitId,\n-    TypeAliasId,\n+    builtin_type::BuiltinType, generics::TypeOrConstParamData, ConstParamId, DefWithBodyId,\n+    GenericDefId, TraitId, TypeAliasId,\n };\n use smallvec::SmallVec;\n \n use crate::{\n     consteval::unknown_const_as_generic, db::HirDatabase, infer::unify::InferenceTable, primitive,\n-    to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders, CallableSig, ConstData,\n-    ConstValue, GenericArg, GenericArgData, Interner, ProjectionTy, Substitution, TraitRef, Ty,\n-    TyDefId, TyExt, TyKind, ValueTyDefId,\n+    to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders, BoundVar, CallableSig,\n+    GenericArg, Interner, ProjectionTy, Substitution, TraitRef, Ty, TyDefId, TyExt, TyKind,\n+    ValueTyDefId,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -34,31 +34,51 @@ pub struct TyBuilder<D> {\n     data: D,\n     vec: SmallVec<[GenericArg; 2]>,\n     param_kinds: SmallVec<[ParamKind; 2]>,\n+    parent_subst: Substitution,\n }\n \n impl<A> TyBuilder<A> {\n     fn with_data<B>(self, data: B) -> TyBuilder<B> {\n-        TyBuilder { data, param_kinds: self.param_kinds, vec: self.vec }\n+        TyBuilder {\n+            data,\n+            vec: self.vec,\n+            param_kinds: self.param_kinds,\n+            parent_subst: self.parent_subst,\n+        }\n     }\n }\n \n impl<D> TyBuilder<D> {\n-    fn new(data: D, param_kinds: SmallVec<[ParamKind; 2]>) -> TyBuilder<D> {\n-        TyBuilder { data, vec: SmallVec::with_capacity(param_kinds.len()), param_kinds }\n+    fn new(\n+        data: D,\n+        param_kinds: SmallVec<[ParamKind; 2]>,\n+        parent_subst: Option<Substitution>,\n+    ) -> Self {\n+        let parent_subst = parent_subst.unwrap_or_else(|| Substitution::empty(Interner));\n+        Self { data, vec: SmallVec::with_capacity(param_kinds.len()), param_kinds, parent_subst }\n+    }\n+\n+    fn new_empty(data: D) -> Self {\n+        TyBuilder::new(data, SmallVec::new(), None)\n     }\n \n     fn build_internal(self) -> (D, Substitution) {\n         assert_eq!(self.vec.len(), self.param_kinds.len());\n         for (a, e) in self.vec.iter().zip(self.param_kinds.iter()) {\n             self.assert_match_kind(a, e);\n         }\n-        let subst = Substitution::from_iter(Interner, self.vec);\n+        let subst = Substitution::from_iter(\n+            Interner,\n+            self.vec.into_iter().chain(self.parent_subst.iter(Interner).cloned()),\n+        );\n         (self.data, subst)\n     }\n \n     pub fn push(mut self, arg: impl CastTo<GenericArg>) -> Self {\n+        assert!(self.remaining() > 0);\n         let arg = arg.cast(Interner);\n         let expected_kind = &self.param_kinds[self.vec.len()];\n+\n         let arg_kind = match arg.data(Interner) {\n             chalk_ir::GenericArgData::Ty(_) => ParamKind::Type,\n             chalk_ir::GenericArgData::Lifetime(_) => panic!(\"Got lifetime in TyBuilder::push\"),\n@@ -68,7 +88,9 @@ impl<D> TyBuilder<D> {\n             }\n         };\n         assert_eq!(*expected_kind, arg_kind);\n+\n         self.vec.push(arg);\n+\n         self\n     }\n \n@@ -79,20 +101,12 @@ impl<D> TyBuilder<D> {\n     pub fn fill_with_bound_vars(self, debruijn: DebruijnIndex, starting_from: usize) -> Self {\n         // self.fill is inlined to make borrow checker happy\n         let mut this = self;\n-        let other = this.param_kinds.iter().skip(this.vec.len());\n+        let other = &this.param_kinds[this.vec.len()..];\n         let filler = (starting_from..).zip(other).map(|(idx, kind)| match kind {\n-            ParamKind::Type => {\n-                GenericArgData::Ty(TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(Interner))\n-                    .intern(Interner)\n+            ParamKind::Type => BoundVar::new(debruijn, idx).to_ty(Interner).cast(Interner),\n+            ParamKind::Const(ty) => {\n+                BoundVar::new(debruijn, idx).to_const(Interner, ty.clone()).cast(Interner)\n             }\n-            ParamKind::Const(ty) => GenericArgData::Const(\n-                ConstData {\n-                    value: ConstValue::BoundVar(BoundVar::new(debruijn, idx)),\n-                    ty: ty.clone(),\n-                }\n-                .intern(Interner),\n-            )\n-            .intern(Interner),\n         });\n         this.vec.extend(filler.take(this.remaining()).casted(Interner));\n         assert_eq!(this.remaining(), 0);\n@@ -102,8 +116,8 @@ impl<D> TyBuilder<D> {\n     pub fn fill_with_unknown(self) -> Self {\n         // self.fill is inlined to make borrow checker happy\n         let mut this = self;\n-        let filler = this.param_kinds.iter().skip(this.vec.len()).map(|x| match x {\n-            ParamKind::Type => GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner),\n+        let filler = this.param_kinds[this.vec.len()..].iter().map(|x| match x {\n+            ParamKind::Type => TyKind::Error.intern(Interner).cast(Interner),\n             ParamKind::Const(ty) => unknown_const_as_generic(ty.clone()),\n         });\n         this.vec.extend(filler.casted(Interner));\n@@ -113,33 +127,17 @@ impl<D> TyBuilder<D> {\n \n     pub(crate) fn fill_with_inference_vars(self, table: &mut InferenceTable<'_>) -> Self {\n         self.fill(|x| match x {\n-            ParamKind::Type => GenericArgData::Ty(table.new_type_var()).intern(Interner),\n-            ParamKind::Const(ty) => {\n-                GenericArgData::Const(table.new_const_var(ty.clone())).intern(Interner)\n-            }\n+            ParamKind::Type => table.new_type_var().cast(Interner),\n+            ParamKind::Const(ty) => table.new_const_var(ty.clone()).cast(Interner),\n         })\n     }\n \n     pub fn fill(mut self, filler: impl FnMut(&ParamKind) -> GenericArg) -> Self {\n-        self.vec.extend(self.param_kinds.iter().skip(self.vec.len()).map(filler));\n+        self.vec.extend(self.param_kinds[self.vec.len()..].iter().map(filler));\n         assert_eq!(self.remaining(), 0);\n         self\n     }\n \n-    pub fn use_parent_substs(mut self, parent_substs: &Substitution) -> Self {\n-        assert!(self.vec.is_empty());\n-        assert!(parent_substs.len(Interner) <= self.param_kinds.len());\n-        self.extend(parent_substs.iter(Interner).cloned());\n-        self\n-    }\n-\n-    fn extend(&mut self, it: impl Iterator<Item = GenericArg> + Clone) {\n-        for x in it.clone().zip(self.param_kinds.iter().skip(self.vec.len())) {\n-            self.assert_match_kind(&x.0, &x.1);\n-        }\n-        self.vec.extend(it);\n-    }\n-\n     fn assert_match_kind(&self, a: &chalk_ir::GenericArg<Interner>, e: &ParamKind) {\n         match (a.data(Interner), e) {\n             (chalk_ir::GenericArgData::Ty(_), ParamKind::Type)\n@@ -188,21 +186,42 @@ impl TyBuilder<()> {\n         params.placeholder_subst(db)\n     }\n \n-    pub fn subst_for_def(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> TyBuilder<()> {\n-        let def = def.into();\n-        let params = generics(db.upcast(), def);\n-        TyBuilder::new(\n-            (),\n-            params\n-                .iter()\n-                .map(|(id, data)| match data {\n-                    TypeOrConstParamData::TypeParamData(_) => ParamKind::Type,\n-                    TypeOrConstParamData::ConstParamData(_) => {\n-                        ParamKind::Const(db.const_param_ty(ConstParamId::from_unchecked(id)))\n-                    }\n-                })\n-                .collect(),\n-        )\n+    pub fn subst_for_def(\n+        db: &dyn HirDatabase,\n+        def: impl Into<GenericDefId>,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<()> {\n+        let generics = generics(db.upcast(), def.into());\n+        assert!(generics.parent_generics().is_some() == parent_subst.is_some());\n+        let params = generics\n+            .iter_self()\n+            .map(|(id, data)| match data {\n+                TypeOrConstParamData::TypeParamData(_) => ParamKind::Type,\n+                TypeOrConstParamData::ConstParamData(_) => {\n+                    ParamKind::Const(db.const_param_ty(ConstParamId::from_unchecked(id)))\n+                }\n+            })\n+            .collect();\n+        TyBuilder::new((), params, parent_subst)\n+    }\n+\n+    /// Creates a `TyBuilder` to build `Substitution` for a generator defined in `parent`.\n+    ///\n+    /// A generator's substitution consists of:\n+    /// - resume type of generator\n+    /// - yield type of generator ([`Generator::Yield`](std::ops::Generator::Yield))\n+    /// - return type of generator ([`Generator::Return`](std::ops::Generator::Return))\n+    /// - generic parameters in scope on `parent`\n+    /// in this order.\n+    ///\n+    /// This method prepopulates the builder with placeholder substitution of `parent`, so you\n+    /// should only push exactly 3 `GenericArg`s before building.\n+    pub fn subst_for_generator(db: &dyn HirDatabase, parent: DefWithBodyId) -> TyBuilder<()> {\n+        let parent_subst =\n+            parent.as_generic_def_id().map(|p| generics(db.upcast(), p).placeholder_subst(db));\n+        // These represent resume type, yield type, and return type of generator.\n+        let params = std::iter::repeat(ParamKind::Type).take(3).collect();\n+        TyBuilder::new((), params, parent_subst)\n     }\n \n     pub fn build(self) -> Substitution {\n@@ -213,24 +232,35 @@ impl TyBuilder<()> {\n \n impl TyBuilder<hir_def::AdtId> {\n     pub fn adt(db: &dyn HirDatabase, def: hir_def::AdtId) -> TyBuilder<hir_def::AdtId> {\n-        TyBuilder::subst_for_def(db, def).with_data(def)\n+        TyBuilder::subst_for_def(db, def, None).with_data(def)\n     }\n \n     pub fn fill_with_defaults(\n         mut self,\n         db: &dyn HirDatabase,\n         mut fallback: impl FnMut() -> Ty,\n     ) -> Self {\n+        // Note that we're building ADT, so we never have parent generic parameters.\n         let defaults = db.generic_defaults(self.data.into());\n+        let dummy_ty = TyKind::Error.intern(Interner).cast(Interner);\n         for default_ty in defaults.iter().skip(self.vec.len()) {\n-            if let GenericArgData::Ty(x) = default_ty.skip_binders().data(Interner) {\n+            // NOTE(skip_binders): we only check if the arg type is error type.\n+            if let Some(x) = default_ty.skip_binders().ty(Interner) {\n                 if x.is_unknown() {\n                     self.vec.push(fallback().cast(Interner));\n                     continue;\n                 }\n-            };\n-            // each default can depend on the previous parameters\n-            let subst_so_far = Substitution::from_iter(Interner, self.vec.clone());\n+            }\n+            // Each default can only depend on the previous parameters.\n+            // FIXME: we don't handle const generics here.\n+            let subst_so_far = Substitution::from_iter(\n+                Interner,\n+                self.vec\n+                    .iter()\n+                    .cloned()\n+                    .chain(iter::repeat(dummy_ty.clone()))\n+                    .take(self.param_kinds.len()),\n+            );\n             self.vec.push(default_ty.clone().substitute(Interner, &subst_so_far).cast(Interner));\n         }\n         self\n@@ -245,7 +275,7 @@ impl TyBuilder<hir_def::AdtId> {\n pub struct Tuple(usize);\n impl TyBuilder<Tuple> {\n     pub fn tuple(size: usize) -> TyBuilder<Tuple> {\n-        TyBuilder::new(Tuple(size), iter::repeat(ParamKind::Type).take(size).collect())\n+        TyBuilder::new(Tuple(size), iter::repeat(ParamKind::Type).take(size).collect(), None)\n     }\n \n     pub fn build(self) -> Ty {\n@@ -256,7 +286,7 @@ impl TyBuilder<Tuple> {\n \n impl TyBuilder<TraitId> {\n     pub fn trait_ref(db: &dyn HirDatabase, def: TraitId) -> TyBuilder<TraitId> {\n-        TyBuilder::subst_for_def(db, def).with_data(def)\n+        TyBuilder::subst_for_def(db, def, None).with_data(def)\n     }\n \n     pub fn build(self) -> TraitRef {\n@@ -266,8 +296,12 @@ impl TyBuilder<TraitId> {\n }\n \n impl TyBuilder<TypeAliasId> {\n-    pub fn assoc_type_projection(db: &dyn HirDatabase, def: TypeAliasId) -> TyBuilder<TypeAliasId> {\n-        TyBuilder::subst_for_def(db, def).with_data(def)\n+    pub fn assoc_type_projection(\n+        db: &dyn HirDatabase,\n+        def: TypeAliasId,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<TypeAliasId> {\n+        TyBuilder::subst_for_def(db, def, parent_subst).with_data(def)\n     }\n \n     pub fn build(self) -> ProjectionTy {\n@@ -277,35 +311,48 @@ impl TyBuilder<TypeAliasId> {\n }\n \n impl<T: HasInterner<Interner = Interner> + TypeFoldable<Interner>> TyBuilder<Binders<T>> {\n-    fn subst_binders(b: Binders<T>) -> Self {\n-        let param_kinds = b\n-            .binders\n-            .iter(Interner)\n-            .map(|x| match x {\n-                chalk_ir::VariableKind::Ty(_) => ParamKind::Type,\n-                chalk_ir::VariableKind::Lifetime => panic!(\"Got lifetime parameter\"),\n-                chalk_ir::VariableKind::Const(ty) => ParamKind::Const(ty.clone()),\n-            })\n-            .collect();\n-        TyBuilder::new(b, param_kinds)\n-    }\n-\n     pub fn build(self) -> T {\n         let (b, subst) = self.build_internal();\n         b.substitute(Interner, &subst)\n     }\n }\n \n impl TyBuilder<Binders<Ty>> {\n-    pub fn def_ty(db: &dyn HirDatabase, def: TyDefId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.ty(def))\n+    pub fn def_ty(\n+        db: &dyn HirDatabase,\n+        def: TyDefId,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<Binders<Ty>> {\n+        let poly_ty = db.ty(def);\n+        let id: GenericDefId = match def {\n+            TyDefId::BuiltinType(_) => {\n+                assert!(parent_subst.is_none());\n+                return TyBuilder::new_empty(poly_ty);\n+            }\n+            TyDefId::AdtId(id) => id.into(),\n+            TyDefId::TypeAliasId(id) => id.into(),\n+        };\n+        TyBuilder::subst_for_def(db, id, parent_subst).with_data(poly_ty)\n     }\n \n     pub fn impl_self_ty(db: &dyn HirDatabase, def: hir_def::ImplId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.impl_self_ty(def))\n+        TyBuilder::subst_for_def(db, def, None).with_data(db.impl_self_ty(def))\n     }\n \n-    pub fn value_ty(db: &dyn HirDatabase, def: ValueTyDefId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.value_ty(def))\n+    pub fn value_ty(\n+        db: &dyn HirDatabase,\n+        def: ValueTyDefId,\n+        parent_subst: Option<Substitution>,\n+    ) -> TyBuilder<Binders<Ty>> {\n+        let poly_value_ty = db.value_ty(def);\n+        let id = match def.to_generic_def_id() {\n+            Some(id) => id,\n+            None => {\n+                // static items\n+                assert!(parent_subst.is_none());\n+                return TyBuilder::new_empty(poly_value_ty);\n+            }\n+        };\n+        TyBuilder::subst_for_def(db, id, parent_subst).with_data(poly_value_ty)\n     }\n }"}, {"sha": "43c3451cab37bb865c74e65b0cf39027f0354892", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 63, "deletions": 12, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -11,6 +11,7 @@ use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n \n use base_db::CrateId;\n use hir_def::{\n+    expr::Movability,\n     lang_item::{lang_attr, LangItemTarget},\n     AssocItemId, GenericDefId, HasModule, ItemContainerId, Lookup, ModuleId, TypeAliasId,\n };\n@@ -26,9 +27,9 @@ use crate::{\n     to_assoc_type_id, to_chalk_trait_id,\n     traits::ChalkContext,\n     utils::generics,\n-    AliasEq, AliasTy, BoundVar, CallableDefId, DebruijnIndex, FnDefId, Interner, ProjectionTy,\n-    ProjectionTyExt, QuantifiedWhereClause, Substitution, TraitRef, TraitRefExt, Ty, TyBuilder,\n-    TyExt, TyKind, WhereClause,\n+    wrap_empty_binders, AliasEq, AliasTy, BoundVar, CallableDefId, DebruijnIndex, FnDefId,\n+    Interner, ProjectionTy, ProjectionTyExt, QuantifiedWhereClause, Substitution, TraitRef,\n+    TraitRefExt, Ty, TyBuilder, TyExt, TyKind, WhereClause,\n };\n \n pub(crate) type AssociatedTyDatum = chalk_solve::rust_ir::AssociatedTyDatum<Interner>;\n@@ -372,17 +373,62 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     }\n     fn generator_datum(\n         &self,\n-        _: chalk_ir::GeneratorId<Interner>,\n+        id: chalk_ir::GeneratorId<Interner>,\n     ) -> std::sync::Arc<chalk_solve::rust_ir::GeneratorDatum<Interner>> {\n-        // FIXME\n-        unimplemented!()\n+        let (parent, expr) = self.db.lookup_intern_generator(id.into());\n+\n+        // We fill substitution with unknown type, because we only need to know whether the generic\n+        // params are types or consts to build `Binders` and those being filled up are for\n+        // `resume_type`, `yield_type`, and `return_type` of the generator in question.\n+        let subst = TyBuilder::subst_for_generator(self.db, parent).fill_with_unknown().build();\n+\n+        let input_output = rust_ir::GeneratorInputOutputDatum {\n+            resume_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n+                .intern(Interner),\n+            yield_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 1))\n+                .intern(Interner),\n+            return_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 2))\n+                .intern(Interner),\n+            // FIXME: calculate upvars\n+            upvars: vec![],\n+        };\n+\n+        let it = subst\n+            .iter(Interner)\n+            .map(|it| it.constant(Interner).map(|c| c.data(Interner).ty.clone()));\n+        let input_output = crate::make_type_and_const_binders(it, input_output);\n+\n+        let movability = match self.db.body(parent)[expr] {\n+            hir_def::expr::Expr::Closure {\n+                closure_kind: hir_def::expr::ClosureKind::Generator(movability),\n+                ..\n+            } => movability,\n+            _ => unreachable!(\"non generator expression interned as generator\"),\n+        };\n+        let movability = match movability {\n+            Movability::Static => rust_ir::Movability::Static,\n+            Movability::Movable => rust_ir::Movability::Movable,\n+        };\n+\n+        Arc::new(rust_ir::GeneratorDatum { movability, input_output })\n     }\n     fn generator_witness_datum(\n         &self,\n-        _: chalk_ir::GeneratorId<Interner>,\n+        id: chalk_ir::GeneratorId<Interner>,\n     ) -> std::sync::Arc<chalk_solve::rust_ir::GeneratorWitnessDatum<Interner>> {\n-        // FIXME\n-        unimplemented!()\n+        // FIXME: calculate inner types\n+        let inner_types =\n+            rust_ir::GeneratorWitnessExistential { types: wrap_empty_binders(vec![]) };\n+\n+        let (parent, _) = self.db.lookup_intern_generator(id.into());\n+        // See the comment in `generator_datum()` for unknown types.\n+        let subst = TyBuilder::subst_for_generator(self.db, parent).fill_with_unknown().build();\n+        let it = subst\n+            .iter(Interner)\n+            .map(|it| it.constant(Interner).map(|c| c.data(Interner).ty.clone()));\n+        let inner_types = crate::make_type_and_const_binders(it, inner_types);\n+\n+        Arc::new(rust_ir::GeneratorWitnessDatum { inner_types })\n     }\n \n     fn unification_database(&self) -> &dyn chalk_ir::UnificationDatabase<Interner> {\n@@ -429,10 +475,15 @@ pub(crate) fn associated_ty_data_query(\n     let resolver = hir_def::resolver::HasResolver::resolver(type_alias, db.upcast());\n     let ctx = crate::TyLoweringContext::new(db, &resolver)\n         .with_type_param_mode(crate::lower::ParamLoweringMode::Variable);\n-    let pro_ty = TyBuilder::assoc_type_projection(db, type_alias)\n+\n+    let trait_subst = TyBuilder::subst_for_def(db, trait_, None)\n+        .fill_with_bound_vars(crate::DebruijnIndex::INNERMOST, generic_params.len_self())\n+        .build();\n+    let pro_ty = TyBuilder::assoc_type_projection(db, type_alias, Some(trait_subst))\n         .fill_with_bound_vars(crate::DebruijnIndex::INNERMOST, 0)\n         .build();\n     let self_ty = TyKind::Alias(AliasTy::Projection(pro_ty)).intern(Interner);\n+\n     let mut bounds: Vec<_> = type_alias_data\n         .bounds\n         .iter()\n@@ -772,10 +823,10 @@ pub(super) fn generic_predicate_to_inline_bound(\n             Some(chalk_ir::Binders::new(binders, rust_ir::InlineBound::TraitBound(trait_bound)))\n         }\n         WhereClause::AliasEq(AliasEq { alias: AliasTy::Projection(projection_ty), ty }) => {\n-            if projection_ty.self_type_parameter(Interner) != self_ty_shifted_in {\n+            let trait_ = projection_ty.trait_(db);\n+            if projection_ty.self_type_parameter(db) != self_ty_shifted_in {\n                 return None;\n             }\n-            let trait_ = projection_ty.trait_(db);\n             let args_no_self = projection_ty.substitution.as_slice(Interner)[1..]\n                 .iter()\n                 .map(|ty| ty.clone().cast(Interner))"}, {"sha": "e2099d7e509278b9b8ce8cb031c89d107f6c0972", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -152,7 +152,7 @@ impl TyExt for Ty {\n             TyKind::FnDef(def, parameters) => {\n                 let callable_def = db.lookup_intern_callable_def((*def).into());\n                 let sig = db.callable_item_signature(callable_def);\n-                Some(sig.substitute(Interner, &parameters))\n+                Some(sig.substitute(Interner, parameters))\n             }\n             TyKind::Closure(.., substs) => {\n                 let sig_param = substs.at(Interner, 0).assert_ty_ref(Interner);\n@@ -166,6 +166,8 @@ impl TyExt for Ty {\n         let trait_ref = match self.kind(Interner) {\n             // The principal trait bound should be the first element of the bounds. This is an\n             // invariant ensured by `TyLoweringContext::lower_dyn_trait()`.\n+            // FIXME: dyn types may not have principal trait and we don't want to return auto trait\n+            // here.\n             TyKind::Dyn(dyn_ty) => dyn_ty.bounds.skip_binders().interned().get(0).and_then(|b| {\n                 match b.skip_binders() {\n                     WhereClause::Implemented(trait_ref) => Some(trait_ref),\n@@ -260,7 +262,7 @@ impl TyExt for Ty {\n                                     WhereClause::AliasEq(AliasEq {\n                                         alias: AliasTy::Projection(proj),\n                                         ty: _,\n-                                    }) => &proj.self_type_parameter(Interner) == self,\n+                                    }) => &proj.self_type_parameter(db) == self,\n                                     _ => false,\n                                 })\n                                 .collect::<Vec<_>>();\n@@ -331,6 +333,7 @@ impl TyExt for Ty {\n pub trait ProjectionTyExt {\n     fn trait_ref(&self, db: &dyn HirDatabase) -> TraitRef;\n     fn trait_(&self, db: &dyn HirDatabase) -> TraitId;\n+    fn self_type_parameter(&self, db: &dyn HirDatabase) -> Ty;\n }\n \n impl ProjectionTyExt for ProjectionTy {\n@@ -347,6 +350,10 @@ impl ProjectionTyExt for ProjectionTy {\n             _ => panic!(\"projection ty without parent trait\"),\n         }\n     }\n+\n+    fn self_type_parameter(&self, db: &dyn HirDatabase) -> Ty {\n+        self.trait_ref(db).self_type_parameter(Interner)\n+    }\n }\n \n pub trait TraitRefExt {"}, {"sha": "2c0c6e0b8394fb14e8e819bc6fa6ea99eef71a1b", "filename": "crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 92, "deletions": 16, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -7,14 +7,17 @@ use std::{\n \n use chalk_ir::{BoundVar, DebruijnIndex, GenericArgData, IntTy, Scalar};\n use hir_def::{\n+    builtin_type::BuiltinInt,\n     expr::{ArithOp, BinaryOp, Expr, ExprId, Literal, Pat, PatId},\n     path::ModPath,\n     resolver::{resolver_for_expr, ResolveValueResult, Resolver, ValueNs},\n+    src::HasChildSource,\n     type_ref::ConstScalar,\n-    ConstId, DefWithBodyId,\n+    ConstId, DefWithBodyId, EnumVariantId, Lookup,\n };\n-use la_arena::{Arena, Idx};\n+use la_arena::{Arena, Idx, RawIdx};\n use stdx::never;\n+use syntax::ast::HasName;\n \n use crate::{\n     db::HirDatabase, infer::InferenceContext, lower::ParamLoweringMode, to_placeholder_idx,\n@@ -77,6 +80,7 @@ pub enum ConstEvalError {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ComputedExpr {\n     Literal(Literal),\n+    Enum(String, EnumVariantId, Literal),\n     Tuple(Box<[ComputedExpr]>),\n }\n \n@@ -104,6 +108,7 @@ impl Display for ComputedExpr {\n                 Literal::String(x) => std::fmt::Debug::fmt(x, f),\n                 Literal::ByteString(x) => std::fmt::Debug::fmt(x, f),\n             },\n+            ComputedExpr::Enum(name, _, _) => name.fmt(f),\n             ComputedExpr::Tuple(t) => {\n                 f.write_char('(')?;\n                 for x in &**t {\n@@ -148,13 +153,51 @@ fn is_valid(scalar: &Scalar, value: i128) -> bool {\n     }\n }\n \n+fn get_name(ctx: &mut ConstEvalCtx<'_>, variant: EnumVariantId) -> String {\n+    let loc = variant.parent.lookup(ctx.db.upcast());\n+    let children = variant.parent.child_source(ctx.db.upcast());\n+    let item_tree = loc.id.item_tree(ctx.db.upcast());\n+\n+    let variant_name = children.value[variant.local_id].name();\n+    let enum_name = item_tree[loc.id.value].name.to_string();\n+    enum_name + \"::\" + &variant_name.unwrap().to_string()\n+}\n+\n pub fn eval_const(\n     expr_id: ExprId,\n     ctx: &mut ConstEvalCtx<'_>,\n ) -> Result<ComputedExpr, ConstEvalError> {\n+    let u128_to_i128 = |it: u128| -> Result<i128, ConstEvalError> {\n+        it.try_into().map_err(|_| ConstEvalError::NotSupported(\"u128 is too big\"))\n+    };\n+\n     let expr = &ctx.exprs[expr_id];\n     match expr {\n-        Expr::Missing => Err(ConstEvalError::IncompleteExpr),\n+        Expr::Missing => match ctx.owner {\n+            // evaluate the implicit variant index of an enum variant without expression\n+            // FIXME: This should return the type of the enum representation\n+            DefWithBodyId::VariantId(variant) => {\n+                let prev_idx: u32 = variant.local_id.into_raw().into();\n+                let prev_idx = prev_idx.checked_sub(1).map(RawIdx::from).map(Idx::from_raw);\n+                let value = match prev_idx {\n+                    Some(local_id) => {\n+                        let prev_variant = EnumVariantId { local_id, parent: variant.parent };\n+                        1 + match ctx.db.const_eval_variant(prev_variant)? {\n+                            ComputedExpr::Literal(Literal::Int(v, _)) => v,\n+                            ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n+                            _ => {\n+                                return Err(ConstEvalError::NotSupported(\n+                                    \"Enum can't contain this kind of value\",\n+                                ))\n+                            }\n+                        }\n+                    }\n+                    _ => 0,\n+                };\n+                Ok(ComputedExpr::Literal(Literal::Int(value, Some(BuiltinInt::I128))))\n+            }\n+            _ => Err(ConstEvalError::IncompleteExpr),\n+        },\n         Expr::Literal(l) => Ok(ComputedExpr::Literal(l.clone())),\n         &Expr::UnaryOp { expr, op } => {\n             let ty = &ctx.expr_ty(expr);\n@@ -167,9 +210,7 @@ pub fn eval_const(\n                             return Ok(ComputedExpr::Literal(Literal::Bool(!b)))\n                         }\n                         ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                        ComputedExpr::Literal(Literal::Uint(v, _)) => v\n-                            .try_into()\n-                            .map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?,\n+                        ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n                         _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n                     };\n                     let r = match ty.kind(Interner) {\n@@ -198,9 +239,7 @@ pub fn eval_const(\n                 hir_def::expr::UnaryOp::Neg => {\n                     let v = match ev {\n                         ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                        ComputedExpr::Literal(Literal::Uint(v, _)) => v\n-                            .try_into()\n-                            .map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?,\n+                        ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n                         _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n                     };\n                     Ok(ComputedExpr::Literal(Literal::Int(\n@@ -219,16 +258,12 @@ pub fn eval_const(\n             let op = op.ok_or(ConstEvalError::IncompleteExpr)?;\n             let v1 = match lhs {\n                 ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                ComputedExpr::Literal(Literal::Uint(v, _)) => {\n-                    v.try_into().map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?\n-                }\n+                ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n                 _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n             };\n             let v2 = match rhs {\n                 ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                ComputedExpr::Literal(Literal::Uint(v, _)) => {\n-                    v.try_into().map_err(|_| ConstEvalError::NotSupported(\"too big u128\"))?\n-                }\n+                ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n                 _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n             };\n             match op {\n@@ -339,9 +374,22 @@ pub fn eval_const(\n                 ValueNs::GenericParam(_) => {\n                     Err(ConstEvalError::NotSupported(\"const generic without substitution\"))\n                 }\n+                ValueNs::EnumVariantId(id) => match ctx.db.const_eval_variant(id)? {\n+                    ComputedExpr::Literal(lit) => {\n+                        Ok(ComputedExpr::Enum(get_name(ctx, id), id, lit))\n+                    }\n+                    _ => Err(ConstEvalError::NotSupported(\n+                        \"Enums can't evalute to anything but numbers\",\n+                    )),\n+                },\n                 _ => Err(ConstEvalError::NotSupported(\"path that are not const or local\")),\n             }\n         }\n+        // FIXME: Handle the cast target\n+        &Expr::Cast { expr, .. } => match eval_const(expr, ctx)? {\n+            ComputedExpr::Enum(_, _, lit) => Ok(ComputedExpr::Literal(lit)),\n+            _ => Err(ConstEvalError::NotSupported(\"Can't cast these types\")),\n+        },\n         _ => Err(ConstEvalError::NotSupported(\"This kind of expression\")),\n     }\n }\n@@ -412,7 +460,15 @@ pub(crate) fn const_eval_recover(\n     Err(ConstEvalError::Loop)\n }\n \n-pub(crate) fn const_eval_query(\n+pub(crate) fn const_eval_variant_recover(\n+    _: &dyn HirDatabase,\n+    _: &[String],\n+    _: &EnumVariantId,\n+) -> Result<ComputedExpr, ConstEvalError> {\n+    Err(ConstEvalError::Loop)\n+}\n+\n+pub(crate) fn const_eval_variant_query(\n     db: &dyn HirDatabase,\n     const_id: ConstId,\n ) -> Result<ComputedExpr, ConstEvalError> {\n@@ -433,6 +489,26 @@ pub(crate) fn const_eval_query(\n     result\n }\n \n+pub(crate) fn const_eval_query_variant(\n+    db: &dyn HirDatabase,\n+    variant_id: EnumVariantId,\n+) -> Result<ComputedExpr, ConstEvalError> {\n+    let def = variant_id.into();\n+    let body = db.body(def);\n+    let infer = &db.infer(def);\n+    eval_const(\n+        body.body_expr,\n+        &mut ConstEvalCtx {\n+            db,\n+            owner: def,\n+            exprs: &body.exprs,\n+            pats: &body.pats,\n+            local_data: HashMap::default(),\n+            infer,\n+        },\n+    )\n+}\n+\n pub(crate) fn eval_to_const<'a>(\n     expr: Idx<Expr>,\n     mode: ParamLoweringMode,"}, {"sha": "b76506f6ebc2c867f3b19dcdfcaf31886f60527e", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -87,6 +87,49 @@ fn consts() {\n     );\n }\n \n+#[test]\n+fn enums() {\n+    check_number(\n+        r#\"\n+    enum E {\n+        F1 = 1,\n+        F2 = 2 * E::F1 as u8,\n+        F3 = 3 * E::F2 as u8,\n+    }\n+    const GOAL: i32 = E::F3 as u8;\n+    \"#,\n+        6,\n+    );\n+    check_number(\n+        r#\"\n+    enum E { F1 = 1, F2, }\n+    const GOAL: i32 = E::F2 as u8;\n+    \"#,\n+        2,\n+    );\n+    check_number(\n+        r#\"\n+    enum E { F1, }\n+    const GOAL: i32 = E::F1 as u8;\n+    \"#,\n+        0,\n+    );\n+    let r = eval_goal(\n+        r#\"\n+        enum E { A = 1, }\n+        const GOAL: E = E::A;\n+        \"#,\n+    )\n+    .unwrap();\n+    match r {\n+        ComputedExpr::Enum(name, _, Literal::Uint(val, _)) => {\n+            assert_eq!(name, \"E::A\");\n+            assert_eq!(val, 1);\n+        }\n+        x => panic!(\"Expected enum but found {:?}\", x),\n+    }\n+}\n+\n #[test]\n fn const_loop() {\n     check_fail("}, {"sha": "932fce83563d7ea22d0904fbc7038eebd91d6cbf", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -6,8 +6,8 @@ use std::sync::Arc;\n use arrayvec::ArrayVec;\n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n-    db::DefDatabase, expr::ExprId, BlockId, ConstId, ConstParamId, DefWithBodyId, FunctionId,\n-    GenericDefId, ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n+    db::DefDatabase, expr::ExprId, BlockId, ConstId, ConstParamId, DefWithBodyId, EnumVariantId,\n+    FunctionId, GenericDefId, ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n };\n use la_arena::ArenaMap;\n \n@@ -43,10 +43,14 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::lower::const_param_ty_query)]\n     fn const_param_ty(&self, def: ConstParamId) -> Ty;\n \n-    #[salsa::invoke(crate::consteval::const_eval_query)]\n+    #[salsa::invoke(crate::consteval::const_eval_variant_query)]\n     #[salsa::cycle(crate::consteval::const_eval_recover)]\n     fn const_eval(&self, def: ConstId) -> Result<ComputedExpr, ConstEvalError>;\n \n+    #[salsa::invoke(crate::consteval::const_eval_query_variant)]\n+    #[salsa::cycle(crate::consteval::const_eval_variant_recover)]\n+    fn const_eval_variant(&self, def: EnumVariantId) -> Result<ComputedExpr, ConstEvalError>;\n+\n     #[salsa::invoke(crate::lower::impl_trait_query)]\n     fn impl_trait(&self, def: ImplId) -> Option<Binders<TraitRef>>;\n \n@@ -116,6 +120,8 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn intern_impl_trait_id(&self, id: ImplTraitId) -> InternedOpaqueTyId;\n     #[salsa::interned]\n     fn intern_closure(&self, id: (DefWithBodyId, ExprId)) -> InternedClosureId;\n+    #[salsa::interned]\n+    fn intern_generator(&self, id: (DefWithBodyId, ExprId)) -> InternedGeneratorId;\n \n     #[salsa::invoke(chalk_db::associated_ty_data_query)]\n     fn associated_ty_data(&self, id: chalk_db::AssocTypeId) -> Arc<chalk_db::AssociatedTyDatum>;\n@@ -188,6 +194,9 @@ fn infer_wait(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult>\n         DefWithBodyId::ConstId(it) => {\n             db.const_data(it).name.clone().unwrap_or_else(Name::missing).to_string()\n         }\n+        DefWithBodyId::VariantId(it) => {\n+            db.enum_data(it.parent).variants[it.local_id].name.to_string()\n+        }\n     });\n     db.infer_query(def)\n }\n@@ -226,6 +235,10 @@ impl_intern_key!(InternedOpaqueTyId);\n pub struct InternedClosureId(salsa::InternId);\n impl_intern_key!(InternedClosureId);\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct InternedGeneratorId(salsa::InternId);\n+impl_intern_key!(InternedGeneratorId);\n+\n /// This exists just for Chalk, because Chalk just has a single `FnDefId` where\n /// we have different IDs for struct and enum variant constructors.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]"}, {"sha": "431ab949b46243ae2f8b0621454fe76614212334", "filename": "crates/hir-ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -18,7 +18,9 @@ pub fn missing_unsafe(db: &dyn HirDatabase, def: DefWithBodyId) -> Vec<ExprId> {\n \n     let is_unsafe = match def {\n         DefWithBodyId::FunctionId(it) => db.function_data(it).has_unsafe_kw(),\n-        DefWithBodyId::StaticId(_) | DefWithBodyId::ConstId(_) => false,\n+        DefWithBodyId::StaticId(_) | DefWithBodyId::ConstId(_) | DefWithBodyId::VariantId(_) => {\n+            false\n+        }\n     };\n     if is_unsafe {\n         return res;"}, {"sha": "0221f922feb2ff396a2c602880eb1ad363dab60e", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 54, "deletions": 9, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -20,13 +20,14 @@ use hir_def::{\n };\n use hir_expand::{hygiene::Hygiene, name::Name};\n use itertools::Itertools;\n+use smallvec::SmallVec;\n use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase,\n     from_assoc_type_id, from_foreign_def_id, from_placeholder_idx, lt_from_placeholder_idx,\n     mapping::from_chalk,\n-    primitive, subst_prefix, to_assoc_type_id,\n+    primitive, to_assoc_type_id,\n     utils::{self, generics},\n     AdtId, AliasEq, AliasTy, Binders, CallableDefId, CallableSig, Const, ConstValue, DomainGoal,\n     GenericArg, ImplTraitId, Interner, Lifetime, LifetimeData, LifetimeOutlives, Mutability,\n@@ -221,6 +222,7 @@ pub enum DisplaySourceCodeError {\n     PathNotFound,\n     UnknownType,\n     Closure,\n+    Generator,\n }\n \n pub enum HirDisplayError {\n@@ -289,7 +291,7 @@ impl HirDisplay for ProjectionTy {\n \n         let trait_ = f.db.trait_data(self.trait_(f.db));\n         write!(f, \"<\")?;\n-        self.self_type_parameter(Interner).hir_fmt(f)?;\n+        self.self_type_parameter(f.db).hir_fmt(f)?;\n         write!(f, \" as {}\", trait_.name)?;\n         if self.substitution.len(Interner) > 1 {\n             write!(f, \"<\")?;\n@@ -504,8 +506,15 @@ impl HirDisplay for Ty {\n                     let total_len = parent_params + self_param + type_params + const_params;\n                     // We print all params except implicit impl Trait params. Still a bit weird; should we leave out parent and self?\n                     if total_len > 0 {\n+                        // `parameters` are in the order of fn's params (including impl traits),\n+                        // parent's params (those from enclosing impl or trait, if any).\n+                        let parameters = parameters.as_slice(Interner);\n+                        let fn_params_len = self_param + type_params + const_params;\n+                        let fn_params = parameters.get(..fn_params_len);\n+                        let parent_params = parameters.get(parameters.len() - parent_params..);\n+                        let params = parent_params.into_iter().chain(fn_params).flatten();\n                         write!(f, \"<\")?;\n-                        f.write_joined(&parameters.as_slice(Interner)[..total_len], \", \")?;\n+                        f.write_joined(params, \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 }\n@@ -577,9 +586,8 @@ impl HirDisplay for Ty {\n                                         Some(x) => x,\n                                         None => return true,\n                                     };\n-                                    let actual_default = default_parameter\n-                                        .clone()\n-                                        .substitute(Interner, &subst_prefix(parameters, i));\n+                                    let actual_default =\n+                                        default_parameter.clone().substitute(Interner, &parameters);\n                                     parameter != &actual_default\n                                 }\n                                 let mut default_from = 0;\n@@ -723,7 +731,7 @@ impl HirDisplay for Ty {\n                                         WhereClause::AliasEq(AliasEq {\n                                             alias: AliasTy::Projection(proj),\n                                             ty: _,\n-                                        }) => &proj.self_type_parameter(Interner) == self,\n+                                        }) => &proj.self_type_parameter(f.db) == self,\n                                         _ => false,\n                                     })\n                                     .collect::<Vec<_>>();\n@@ -743,9 +751,19 @@ impl HirDisplay for Ty {\n             }\n             TyKind::BoundVar(idx) => idx.hir_fmt(f)?,\n             TyKind::Dyn(dyn_ty) => {\n+                // Reorder bounds to satisfy `write_bounds_like_dyn_trait()`'s expectation.\n+                // FIXME: `Iterator::partition_in_place()` or `Vec::drain_filter()` may make it\n+                // more efficient when either of them hits stable.\n+                let mut bounds: SmallVec<[_; 4]> =\n+                    dyn_ty.bounds.skip_binders().iter(Interner).cloned().collect();\n+                let (auto_traits, others): (SmallVec<[_; 4]>, _) =\n+                    bounds.drain(1..).partition(|b| b.skip_binders().trait_id().is_some());\n+                bounds.extend(others);\n+                bounds.extend(auto_traits);\n+\n                 write_bounds_like_dyn_trait_with_prefix(\n                     \"dyn\",\n-                    dyn_ty.bounds.skip_binders().interned(),\n+                    &bounds,\n                     SizedByDefault::NotSized,\n                     f,\n                 )?;\n@@ -783,7 +801,34 @@ impl HirDisplay for Ty {\n                 write!(f, \"{{unknown}}\")?;\n             }\n             TyKind::InferenceVar(..) => write!(f, \"_\")?,\n-            TyKind::Generator(..) => write!(f, \"{{generator}}\")?,\n+            TyKind::Generator(_, subst) => {\n+                if f.display_target.is_source_code() {\n+                    return Err(HirDisplayError::DisplaySourceCodeError(\n+                        DisplaySourceCodeError::Generator,\n+                    ));\n+                }\n+\n+                let subst = subst.as_slice(Interner);\n+                let a: Option<SmallVec<[&Ty; 3]>> = subst\n+                    .get(subst.len() - 3..)\n+                    .map(|args| args.iter().map(|arg| arg.ty(Interner)).collect())\n+                    .flatten();\n+\n+                if let Some([resume_ty, yield_ty, ret_ty]) = a.as_deref() {\n+                    write!(f, \"|\")?;\n+                    resume_ty.hir_fmt(f)?;\n+                    write!(f, \"|\")?;\n+\n+                    write!(f, \" yields \")?;\n+                    yield_ty.hir_fmt(f)?;\n+\n+                    write!(f, \" -> \")?;\n+                    ret_ty.hir_fmt(f)?;\n+                } else {\n+                    // This *should* be unreachable, but fallback just in case.\n+                    write!(f, \"{{generator}}\")?;\n+                }\n+            }\n             TyKind::GeneratorWitness(..) => write!(f, \"{{generator witness}}\")?,\n         }\n         Ok(())"}, {"sha": "6a5c4966f7ba5ee423b0b62273fa046ba1cbb37b", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -2,7 +2,7 @@\n //! the type of each expression and pattern.\n //!\n //! For type inference, compare the implementations in rustc (the various\n-//! check_* methods in librustc_typeck/check/mod.rs are a good entry point) and\n+//! check_* methods in rustc_hir_analysis/check/mod.rs are a good entry point) and\n //! IntelliJ-Rust (org.rust.lang.core.types.infer). Our entry point for\n //! inference here is the `infer` function, which infers the types of all\n //! expressions in a given function.\n@@ -19,14 +19,15 @@ use std::sync::Arc;\n use chalk_ir::{cast::Cast, ConstValue, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n use hir_def::{\n     body::Body,\n+    builtin_type::BuiltinType,\n     data::{ConstData, StaticData},\n     expr::{BindingAnnotation, ExprId, PatId},\n     lang_item::LangItemTarget,\n     path::{path, Path},\n     resolver::{HasResolver, ResolveValueResult, Resolver, TypeNs, ValueNs},\n     type_ref::TypeRef,\n-    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule, Lookup,\n-    TraitId, TypeAliasId, VariantId,\n+    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule,\n+    ItemContainerId, Lookup, TraitId, TypeAliasId, VariantId,\n };\n use hir_expand::name::{name, Name};\n use itertools::Either;\n@@ -67,6 +68,12 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n         DefWithBodyId::ConstId(c) => ctx.collect_const(&db.const_data(c)),\n         DefWithBodyId::FunctionId(f) => ctx.collect_fn(f),\n         DefWithBodyId::StaticId(s) => ctx.collect_static(&db.static_data(s)),\n+        DefWithBodyId::VariantId(v) => {\n+            ctx.return_ty = TyBuilder::builtin(match db.enum_data(v.parent).variant_body_type() {\n+                Either::Left(builtin) => BuiltinType::Int(builtin),\n+                Either::Right(builtin) => BuiltinType::Uint(builtin),\n+            });\n+        }\n     }\n \n     ctx.infer_body();\n@@ -183,7 +190,9 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n     BreakOutsideOfLoop { expr: ExprId, is_break: bool },\n+    IncorrectTryTarget { expr: ExprId },\n     MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n+    DoesNotImplement { expr: ExprId, trait_: TraitId, ty: Ty },\n }\n \n /// A mismatch between an expected and an inferred type.\n@@ -332,7 +341,7 @@ pub struct InferenceResult {\n     /// unresolved or missing subpatterns or subpatterns of mismatched types.\n     pub type_of_pat: ArenaMap<PatId, Ty>,\n     type_mismatches: FxHashMap<ExprOrPatId, TypeMismatch>,\n-    /// Interned Unknown to return references to.\n+    /// Interned common types to return references to.\n     standard_types: InternedStandardTypes,\n     /// Stores the types which were implicitly dereferenced in pattern binding modes.\n     pub pat_adjustments: FxHashMap<PatId, Vec<Ty>>,\n@@ -412,6 +421,8 @@ pub(crate) struct InferenceContext<'a> {\n     /// closures, but currently this is the only field that will change there,\n     /// so it doesn't make sense.\n     return_ty: Ty,\n+    /// The resume type and the yield type, respectively, of the generator being inferred.\n+    resume_yield_tys: Option<(Ty, Ty)>,\n     diverges: Diverges,\n     breakables: Vec<BreakableContext>,\n }\n@@ -476,6 +487,7 @@ impl<'a> InferenceContext<'a> {\n             table: unify::InferenceTable::new(db, trait_env.clone()),\n             trait_env,\n             return_ty: TyKind::Error.intern(Interner), // set in collect_fn_signature\n+            resume_yield_tys: None,\n             db,\n             owner,\n             body,\n@@ -703,6 +715,8 @@ impl<'a> InferenceContext<'a> {\n         &mut self,\n         inner_ty: Ty,\n         assoc_ty: Option<TypeAliasId>,\n+        // FIXME(GATs): these are args for the trait ref, args for assoc type itself should be\n+        // handled when we support them.\n         params: &[GenericArg],\n     ) -> Ty {\n         match assoc_ty {\n@@ -794,7 +808,18 @@ impl<'a> InferenceContext<'a> {\n                 self.resolve_variant_on_alias(ty, unresolved, path)\n             }\n             TypeNs::TypeAliasId(it) => {\n-                let ty = TyBuilder::def_ty(self.db, it.into())\n+                let container = it.lookup(self.db.upcast()).container;\n+                let parent_subst = match container {\n+                    ItemContainerId::TraitId(id) => {\n+                        let subst = TyBuilder::subst_for_def(self.db, id, None)\n+                            .fill_with_inference_vars(&mut self.table)\n+                            .build();\n+                        Some(subst)\n+                    }\n+                    // Type aliases do not exist in impls.\n+                    _ => None,\n+                };\n+                let ty = TyBuilder::def_ty(self.db, it.into(), parent_subst)\n                     .fill_with_inference_vars(&mut self.table)\n                     .build();\n                 self.resolve_variant_on_alias(ty, unresolved, path)\n@@ -873,18 +898,13 @@ impl<'a> InferenceContext<'a> {\n     fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n         let path = path![core::iter::IntoIterator];\n         let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n+        self.db.trait_data(trait_).associated_type_by_name(&name![IntoIter])\n     }\n \n-    fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n-        // FIXME resolve via lang_item once try v2 is stable\n-        let path = path![core::ops::Try];\n+    fn resolve_iterator_item(&self) -> Option<TypeAliasId> {\n+        let path = path![core::iter::Iterator];\n         let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n-        let trait_data = self.db.trait_data(trait_);\n-        trait_data\n-            // FIXME remove once try v2 is stable\n-            .associated_type_by_name(&name![Ok])\n-            .or_else(|| trait_data.associated_type_by_name(&name![Output]))\n+        self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n     }\n \n     fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {"}, {"sha": "094e460dbf79b0b08b35f2911c0bf83d78d8faca", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -12,6 +12,7 @@ use crate::{\n use super::{Expectation, InferenceContext};\n \n impl InferenceContext<'_> {\n+    // This function handles both closures and generators.\n     pub(super) fn deduce_closure_type_from_expectations(\n         &mut self,\n         closure_expr: ExprId,\n@@ -27,6 +28,11 @@ impl InferenceContext<'_> {\n         // Deduction from where-clauses in scope, as well as fn-pointer coercion are handled here.\n         let _ = self.coerce(Some(closure_expr), closure_ty, &expected_ty);\n \n+        // Generators are not Fn* so return early.\n+        if matches!(closure_ty.kind(Interner), TyKind::Generator(..)) {\n+            return;\n+        }\n+\n         // Deduction based on the expected `dyn Fn` is done separately.\n         if let TyKind::Dyn(dyn_ty) = expected_ty.kind(Interner) {\n             if let Some(sig) = self.deduce_sig_from_dyn_ty(dyn_ty) {"}, {"sha": "8df25c83c6eb7d5b35a910881403186861be2a11", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -3,7 +3,7 @@\n //! like going from `&Vec<T>` to `&[T]`.\n //!\n //! See <https://doc.rust-lang.org/nomicon/coercions.html> and\n-//! `librustc_typeck/check/coercion.rs`.\n+//! `rustc_hir_analysis/check/coercion.rs`.\n \n use std::{iter, sync::Arc};\n "}, {"sha": "59ab50d0717ba6d5050e28c533f3c3543a881740", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 165, "deletions": 48, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -10,30 +10,33 @@ use chalk_ir::{\n     cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyVariableKind,\n };\n use hir_def::{\n-    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, LabelId, Literal, Statement, UnaryOp},\n+    expr::{\n+        ArithOp, Array, BinaryOp, ClosureKind, CmpOp, Expr, ExprId, LabelId, Literal, Statement,\n+        UnaryOp,\n+    },\n     generics::TypeOrConstParamData,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n     ConstParamId, FieldId, ItemContainerId, Lookup,\n };\n-use hir_expand::name::Name;\n+use hir_expand::{name, name::Name};\n use stdx::always;\n use syntax::ast::RangeOp;\n \n use crate::{\n     autoderef::{self, Autoderef},\n     consteval,\n-    infer::{coerce::CoerceMany, find_continuable, BreakableKind},\n+    infer::{coerce::CoerceMany, find_continuable, path, BreakableKind},\n     lower::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n     mapping::{from_chalk, ToChalk},\n     method_resolution::{self, lang_names_for_bin_op, VisibleFromModule},\n     primitive::{self, UintTy},\n-    static_lifetime, to_chalk_trait_id,\n+    static_lifetime, to_assoc_type_id, to_chalk_trait_id,\n     utils::{generics, Generics},\n-    AdtId, Binders, CallableDefId, FnPointer, FnSig, FnSubst, Interner, Rawness, Scalar,\n-    Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    AdtId, AliasEq, AliasTy, Binders, CallableDefId, FnPointer, FnSig, FnSubst, Interner,\n+    ProjectionTy, Rawness, Scalar, Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n use super::{\n@@ -204,8 +207,10 @@ impl<'a> InferenceContext<'a> {\n             }\n             &Expr::For { iterable, body, pat, label } => {\n                 let iterable_ty = self.infer_expr(iterable, &Expectation::none());\n-                let pat_ty =\n+                let into_iter_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n+                let pat_ty =\n+                    self.resolve_associated_type(into_iter_ty, self.resolve_iterator_item());\n \n                 self.infer_pat(pat, &pat_ty, BindingMode::default());\n                 self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n@@ -216,7 +221,7 @@ impl<'a> InferenceContext<'a> {\n                 self.diverges = Diverges::Maybe;\n                 TyBuilder::unit()\n             }\n-            Expr::Closure { body, args, ret_type, arg_types } => {\n+            Expr::Closure { body, args, ret_type, arg_types, closure_kind } => {\n                 assert_eq!(args.len(), arg_types.len());\n \n                 let mut sig_tys = Vec::new();\n@@ -244,20 +249,40 @@ impl<'a> InferenceContext<'a> {\n                     ),\n                 })\n                 .intern(Interner);\n-                let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n-                let closure_ty =\n-                    TyKind::Closure(closure_id, Substitution::from1(Interner, sig_ty.clone()))\n-                        .intern(Interner);\n+\n+                let (ty, resume_yield_tys) = if matches!(closure_kind, ClosureKind::Generator(_)) {\n+                    // FIXME: report error when there are more than 1 parameter.\n+                    let resume_ty = match sig_tys.first() {\n+                        // When `sig_tys.len() == 1` the first type is the return type, not the\n+                        // first parameter type.\n+                        Some(ty) if sig_tys.len() > 1 => ty.clone(),\n+                        _ => self.result.standard_types.unit.clone(),\n+                    };\n+                    let yield_ty = self.table.new_type_var();\n+\n+                    let subst = TyBuilder::subst_for_generator(self.db, self.owner)\n+                        .push(resume_ty.clone())\n+                        .push(yield_ty.clone())\n+                        .push(ret_ty.clone())\n+                        .build();\n+\n+                    let generator_id = self.db.intern_generator((self.owner, tgt_expr)).into();\n+                    let generator_ty = TyKind::Generator(generator_id, subst).intern(Interner);\n+\n+                    (generator_ty, Some((resume_ty, yield_ty)))\n+                } else {\n+                    let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n+                    let closure_ty =\n+                        TyKind::Closure(closure_id, Substitution::from1(Interner, sig_ty.clone()))\n+                            .intern(Interner);\n+\n+                    (closure_ty, None)\n+                };\n \n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n                 // infer the body.\n-                self.deduce_closure_type_from_expectations(\n-                    tgt_expr,\n-                    &closure_ty,\n-                    &sig_ty,\n-                    expected,\n-                );\n+                self.deduce_closure_type_from_expectations(tgt_expr, &ty, &sig_ty, expected);\n \n                 // Now go through the argument patterns\n                 for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n@@ -266,15 +291,18 @@ impl<'a> InferenceContext<'a> {\n \n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n+                let prev_resume_yield_tys =\n+                    mem::replace(&mut self.resume_yield_tys, resume_yield_tys);\n \n                 self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n                     this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n                 });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n+                self.resume_yield_tys = prev_resume_yield_tys;\n \n-                closure_ty\n+                ty\n             }\n             Expr::Call { callee, args, .. } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n@@ -423,11 +451,18 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::Never.intern(Interner)\n             }\n             Expr::Yield { expr } => {\n-                // FIXME: track yield type for coercion\n-                if let Some(expr) = expr {\n-                    self.infer_expr(*expr, &Expectation::none());\n+                if let Some((resume_ty, yield_ty)) = self.resume_yield_tys.clone() {\n+                    if let Some(expr) = expr {\n+                        self.infer_expr_coerce(*expr, &Expectation::has_type(yield_ty));\n+                    } else {\n+                        let unit = self.result.standard_types.unit.clone();\n+                        let _ = self.coerce(Some(tgt_expr), &unit, &yield_ty);\n+                    }\n+                    resume_ty\n+                } else {\n+                    // FIXME: report error (yield expr in non-generator)\n+                    TyKind::Error.intern(Interner)\n                 }\n-                TyKind::Never.intern(Interner)\n             }\n             Expr::RecordLit { path, fields, spread, .. } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_deref(), false);\n@@ -529,9 +564,29 @@ impl<'a> InferenceContext<'a> {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 self.resolve_associated_type(inner_ty, self.resolve_future_future_output())\n             }\n-            Expr::Try { expr } => {\n-                let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                self.resolve_associated_type(inner_ty, self.resolve_ops_try_ok())\n+            &Expr::Try { expr } => {\n+                let inner_ty = self.infer_expr_inner(expr, &Expectation::none());\n+                match self.resolve_try_impl_for(inner_ty.clone()) {\n+                    Some((_, Some((output, residual)))) => {\n+                        if let Some((_trait, false)) =\n+                            self.implements_from_residual(self.return_ty.clone(), residual)\n+                        {\n+                            self.push_diagnostic(InferenceDiagnostic::IncorrectTryTarget {\n+                                expr: tgt_expr,\n+                            });\n+                        }\n+                        output\n+                    }\n+                    Some((trait_, None)) => {\n+                        self.push_diagnostic(InferenceDiagnostic::DoesNotImplement {\n+                            expr,\n+                            trait_,\n+                            ty: inner_ty,\n+                        });\n+                        self.err_ty()\n+                    }\n+                    None => self.err_ty(),\n+                }\n             }\n             Expr::Cast { expr, type_ref } => {\n                 // FIXME: propagate the \"castable to\" expectation (and find a test case that shows this is necessary)\n@@ -952,11 +1007,13 @@ impl<'a> InferenceContext<'a> {\n         let lhs_ty = self.infer_expr(lhs, &lhs_expectation);\n         let rhs_ty = self.table.new_type_var();\n \n-        let func = lang_names_for_bin_op(op).and_then(|(name, lang_item)| {\n-            self.db.trait_data(self.resolve_lang_item(lang_item)?.as_trait()?).method_by_name(&name)\n+        let trait_func = lang_names_for_bin_op(op).and_then(|(name, lang_item)| {\n+            let trait_id = self.resolve_lang_item(lang_item)?.as_trait()?;\n+            let func = self.db.trait_data(trait_id).method_by_name(&name)?;\n+            Some((trait_id, func))\n         });\n-        let func = match func {\n-            Some(func) => func,\n+        let (trait_, func) = match trait_func {\n+            Some(it) => it,\n             None => {\n                 let rhs_ty = self.builtin_binary_op_rhs_expectation(op, lhs_ty.clone());\n                 let rhs_ty = self.infer_expr_coerce(rhs, &Expectation::from_option(rhs_ty));\n@@ -966,7 +1023,9 @@ impl<'a> InferenceContext<'a> {\n             }\n         };\n \n-        let subst = TyBuilder::subst_for_def(self.db, func)\n+        // HACK: We can use this substitution for the function because the function itself doesn't\n+        // have its own generic parameters.\n+        let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n             .push(lhs_ty.clone())\n             .push(rhs_ty.clone())\n             .build();\n@@ -1245,19 +1304,7 @@ impl<'a> InferenceContext<'a> {\n         assert_eq!(self_params, 0); // method shouldn't have another Self param\n         let total_len = parent_params + type_params + const_params + impl_trait_params;\n         let mut substs = Vec::with_capacity(total_len);\n-        // Parent arguments are unknown\n-        for (id, param) in def_generics.iter_parent() {\n-            match param {\n-                TypeOrConstParamData::TypeParamData(_) => {\n-                    substs.push(GenericArgData::Ty(self.table.new_type_var()).intern(Interner));\n-                }\n-                TypeOrConstParamData::ConstParamData(_) => {\n-                    let ty = self.db.const_param_ty(ConstParamId::from_unchecked(id));\n-                    substs\n-                        .push(GenericArgData::Const(self.table.new_const_var(ty)).intern(Interner));\n-                }\n-            }\n-        }\n+\n         // handle provided arguments\n         if let Some(generic_args) = generic_args {\n             // if args are provided, it should be all of them, but we can't rely on that\n@@ -1266,7 +1313,7 @@ impl<'a> InferenceContext<'a> {\n                 .iter()\n                 .filter(|arg| !matches!(arg, GenericArg::Lifetime(_)))\n                 .take(type_params + const_params)\n-                .zip(def_generics.iter_id().skip(parent_params))\n+                .zip(def_generics.iter_id())\n             {\n                 if let Some(g) = generic_arg_to_chalk(\n                     self.db,\n@@ -1290,6 +1337,9 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n         };\n+\n+        // Handle everything else as unknown. This also handles generic arguments for the method's\n+        // parent (impl or trait), which should come after those for the method.\n         for (id, data) in def_generics.iter().skip(substs.len()) {\n             match data {\n                 TypeOrConstParamData::TypeParamData(_) => {\n@@ -1327,9 +1377,13 @@ impl<'a> InferenceContext<'a> {\n                 CallableDefId::FunctionId(f) => {\n                     if let ItemContainerId::TraitId(trait_) = f.lookup(self.db.upcast()).container {\n                         // construct a TraitRef\n-                        let substs = crate::subst_prefix(\n-                            &*parameters,\n-                            generics(self.db.upcast(), trait_.into()).len(),\n+                        let params_len = parameters.len(Interner);\n+                        let trait_params_len = generics(self.db.upcast(), trait_.into()).len();\n+                        let substs = Substitution::from_iter(\n+                            Interner,\n+                            // The generic parameters for the trait come after those for the\n+                            // function.\n+                            &parameters.as_slice(Interner)[params_len - trait_params_len..],\n                         );\n                         self.push_obligation(\n                             TraitRef { trait_id: to_chalk_trait_id(trait_), substitution: substs }\n@@ -1496,4 +1550,67 @@ impl<'a> InferenceContext<'a> {\n         let ctx = self.breakables.pop().expect(\"breakable stack broken\");\n         (ctx.may_break.then(|| ctx.coerce.complete()), res)\n     }\n+\n+    /// Check whether `ty` implements `FromResidual<r>`\n+    fn implements_from_residual(&mut self, ty: Ty, r: Ty) -> Option<(hir_def::TraitId, bool)> {\n+        let from_residual_trait = self\n+            .resolver\n+            .resolve_known_trait(self.db.upcast(), &(super::path![core::ops::FromResidual]))?;\n+        let r = GenericArgData::Ty(r).intern(Interner);\n+        let b = TyBuilder::trait_ref(self.db, from_residual_trait);\n+        if b.remaining() != 2 {\n+            return Some((from_residual_trait, false));\n+        }\n+        let trait_ref = b.push(ty).push(r).build();\n+        Some((from_residual_trait, self.table.try_obligation(trait_ref.cast(Interner)).is_some()))\n+    }\n+\n+    fn resolve_try_impl_for(&mut self, ty: Ty) -> Option<(hir_def::TraitId, Option<(Ty, Ty)>)> {\n+        let path = path![core::ops::Try];\n+        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n+\n+        let trait_ref = TyBuilder::trait_ref(self.db, trait_).push(ty).build();\n+        let substitution = trait_ref.substitution.clone();\n+        self.push_obligation(trait_ref.clone().cast(Interner));\n+\n+        let trait_data = self.db.trait_data(trait_);\n+        let output = trait_data.associated_type_by_name(&name![Output]);\n+        let residual = trait_data.associated_type_by_name(&name![Residual]);\n+\n+        let output_ty = match output {\n+            Some(output) => {\n+                let output_ty = self.table.new_type_var();\n+                let alias_eq = AliasEq {\n+                    alias: AliasTy::Projection(ProjectionTy {\n+                        associated_ty_id: to_assoc_type_id(output),\n+                        substitution: substitution.clone(),\n+                    }),\n+                    ty: output_ty.clone(),\n+                };\n+                self.push_obligation(alias_eq.cast(Interner));\n+                output_ty\n+            }\n+            None => self.err_ty(),\n+        };\n+        let residual_ty = match residual {\n+            Some(residual) => {\n+                let residual_ty = self.table.new_type_var();\n+                let alias_eq = AliasEq {\n+                    alias: AliasTy::Projection(ProjectionTy {\n+                        associated_ty_id: to_assoc_type_id(residual),\n+                        substitution,\n+                    }),\n+                    ty: residual_ty.clone(),\n+                };\n+                self.push_obligation(alias_eq.cast(Interner));\n+                residual_ty\n+            }\n+            None => self.err_ty(),\n+        };\n+        // FIXME: We are doing the work twice here I think?\n+        Some((\n+            trait_,\n+            self.table.try_obligation(trait_ref.cast(Interner)).map(|_| (output_ty, residual_ty)),\n+        ))\n+    }\n }"}, {"sha": "7a4754cdc7bb899848ea9b032825945407e13850", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -12,8 +12,8 @@ use crate::{\n     builder::ParamKind,\n     consteval,\n     method_resolution::{self, VisibleFromModule},\n-    GenericArgData, Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n-    ValueTyDefId,\n+    utils::generics,\n+    Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind, ValueTyDefId,\n };\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n@@ -96,17 +96,21 @@ impl<'a> InferenceContext<'a> {\n             ValueNs::GenericParam(it) => return Some(self.db.const_param_ty(it)),\n         };\n \n-        let parent_substs = self_subst.unwrap_or_else(|| Substitution::empty(Interner));\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         let substs = ctx.substs_from_path(path, typable, true);\n-        let mut it = substs.as_slice(Interner)[parent_substs.len(Interner)..].iter().cloned();\n-        let ty = TyBuilder::value_ty(self.db, typable)\n-            .use_parent_substs(&parent_substs)\n+        let substs = substs.as_slice(Interner);\n+        let parent_substs = self_subst.or_else(|| {\n+            let generics = generics(self.db.upcast(), typable.to_generic_def_id()?);\n+            let parent_params_len = generics.parent_generics()?.len();\n+            let parent_args = &substs[substs.len() - parent_params_len..];\n+            Some(Substitution::from_iter(Interner, parent_args))\n+        });\n+        let parent_substs_len = parent_substs.as_ref().map_or(0, |s| s.len(Interner));\n+        let mut it = substs.iter().take(substs.len() - parent_substs_len).cloned();\n+        let ty = TyBuilder::value_ty(self.db, typable, parent_substs)\n             .fill(|x| {\n                 it.next().unwrap_or_else(|| match x {\n-                    ParamKind::Type => {\n-                        GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner)\n-                    }\n+                    ParamKind::Type => TyKind::Error.intern(Interner).cast(Interner),\n                     ParamKind::Const(ty) => consteval::unknown_const_as_generic(ty.clone()),\n                 })\n             })\n@@ -249,7 +253,7 @@ impl<'a> InferenceContext<'a> {\n                 };\n                 let substs = match container {\n                     ItemContainerId::ImplId(impl_id) => {\n-                        let impl_substs = TyBuilder::subst_for_def(self.db, impl_id)\n+                        let impl_substs = TyBuilder::subst_for_def(self.db, impl_id, None)\n                             .fill_with_inference_vars(&mut self.table)\n                             .build();\n                         let impl_self_ty ="}, {"sha": "b00e3216b2d2ce7c384c09ff42f71f152a80bf1a", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -4,7 +4,7 @@ use std::{fmt, mem, sync::Arc};\n \n use chalk_ir::{\n     cast::Cast, fold::TypeFoldable, interner::HasInterner, zip::Zip, CanonicalVarKind, FloatTy,\n-    IntTy, NoSolution, TyVariableKind, UniverseIndex,\n+    IntTy, TyVariableKind, UniverseIndex,\n };\n use chalk_solve::infer::ParameterEnaVariableExt;\n use ena::unify::UnifyKey;\n@@ -331,7 +331,6 @@ impl<'a> InferenceTable<'a> {\n             &mut resolve::Resolver { table: self, var_stack, fallback },\n             DebruijnIndex::INNERMOST,\n         )\n-        .expect(\"fold failed unexpectedly\")\n     }\n \n     pub(crate) fn resolve_completely<T>(&mut self, t: T) -> T\n@@ -452,13 +451,14 @@ impl<'a> InferenceTable<'a> {\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> T {\n         use chalk_ir::fold::TypeFolder;\n+\n+        #[derive(chalk_derive::FallibleTypeFolder)]\n+        #[has_interner(Interner)]\n         struct VarFudger<'a, 'b> {\n             table: &'a mut InferenceTable<'b>,\n             highest_known_var: InferenceVar,\n         }\n         impl<'a, 'b> TypeFolder<Interner> for VarFudger<'a, 'b> {\n-            type Error = NoSolution;\n-\n             fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n                 self\n             }\n@@ -472,37 +472,37 @@ impl<'a> InferenceTable<'a> {\n                 var: chalk_ir::InferenceVar,\n                 kind: TyVariableKind,\n                 _outer_binder: chalk_ir::DebruijnIndex,\n-            ) -> chalk_ir::Fallible<chalk_ir::Ty<Interner>> {\n-                Ok(if var < self.highest_known_var {\n+            ) -> chalk_ir::Ty<Interner> {\n+                if var < self.highest_known_var {\n                     var.to_ty(Interner, kind)\n                 } else {\n                     self.table.new_type_var()\n-                })\n+                }\n             }\n \n             fn fold_inference_lifetime(\n                 &mut self,\n                 var: chalk_ir::InferenceVar,\n                 _outer_binder: chalk_ir::DebruijnIndex,\n-            ) -> chalk_ir::Fallible<chalk_ir::Lifetime<Interner>> {\n-                Ok(if var < self.highest_known_var {\n+            ) -> chalk_ir::Lifetime<Interner> {\n+                if var < self.highest_known_var {\n                     var.to_lifetime(Interner)\n                 } else {\n                     self.table.new_lifetime_var()\n-                })\n+                }\n             }\n \n             fn fold_inference_const(\n                 &mut self,\n                 ty: chalk_ir::Ty<Interner>,\n                 var: chalk_ir::InferenceVar,\n                 _outer_binder: chalk_ir::DebruijnIndex,\n-            ) -> chalk_ir::Fallible<chalk_ir::Const<Interner>> {\n-                Ok(if var < self.highest_known_var {\n+            ) -> chalk_ir::Const<Interner> {\n+                if var < self.highest_known_var {\n                     var.to_const(Interner, ty)\n                 } else {\n                     self.table.new_const_var(ty)\n-                })\n+                }\n             }\n         }\n \n@@ -512,7 +512,6 @@ impl<'a> InferenceTable<'a> {\n         self.rollback_to(snapshot);\n         result\n             .fold_with(&mut VarFudger { table: self, highest_known_var }, DebruijnIndex::INNERMOST)\n-            .expect(\"fold_with with VarFudger\")\n     }\n \n     /// This checks whether any of the free variables in the `canonicalized`\n@@ -598,11 +597,14 @@ impl<'a> InferenceTable<'a> {\n             .build();\n \n         let projection = {\n-            let b = TyBuilder::assoc_type_projection(self.db, output_assoc_type);\n+            let b = TyBuilder::subst_for_def(self.db, fn_once_trait, None);\n             if b.remaining() != 2 {\n                 return None;\n             }\n-            b.push(ty.clone()).push(arg_ty).build()\n+            let fn_once_subst = b.push(ty.clone()).push(arg_ty).build();\n+\n+            TyBuilder::assoc_type_projection(self.db, output_assoc_type, Some(fn_once_subst))\n+                .build()\n         };\n \n         let trait_env = self.trait_env.env.clone();\n@@ -636,21 +638,24 @@ mod resolve {\n     use chalk_ir::{\n         cast::Cast,\n         fold::{TypeFoldable, TypeFolder},\n-        Fallible, NoSolution,\n     };\n     use hir_def::type_ref::ConstScalar;\n \n-    pub(super) struct Resolver<'a, 'b, F> {\n+    #[derive(chalk_derive::FallibleTypeFolder)]\n+    #[has_interner(Interner)]\n+    pub(super) struct Resolver<\n+        'a,\n+        'b,\n+        F: Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg,\n+    > {\n         pub(super) table: &'a mut InferenceTable<'b>,\n         pub(super) var_stack: &'a mut Vec<InferenceVar>,\n         pub(super) fallback: F,\n     }\n-    impl<'a, 'b, 'i, F> TypeFolder<Interner> for Resolver<'a, 'b, F>\n+    impl<'a, 'b, F> TypeFolder<Interner> for Resolver<'a, 'b, F>\n     where\n-        F: Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg + 'i,\n+        F: Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg,\n     {\n-        type Error = NoSolution;\n-\n         fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n             self\n         }\n@@ -664,20 +669,19 @@ mod resolve {\n             var: InferenceVar,\n             kind: TyVariableKind,\n             outer_binder: DebruijnIndex,\n-        ) -> Fallible<Ty> {\n+        ) -> Ty {\n             let var = self.table.var_unification_table.inference_var_root(var);\n             if self.var_stack.contains(&var) {\n                 // recursive type\n                 let default = self.table.fallback_value(var, kind).cast(Interner);\n-                return Ok((self.fallback)(var, VariableKind::Ty(kind), default, outer_binder)\n+                return (self.fallback)(var, VariableKind::Ty(kind), default, outer_binder)\n                     .assert_ty_ref(Interner)\n-                    .clone());\n+                    .clone();\n             }\n             let result = if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n                 // known_ty may contain other variables that are known by now\n                 self.var_stack.push(var);\n-                let result =\n-                    known_ty.fold_with(self, outer_binder).expect(\"fold failed unexpectedly\");\n+                let result = known_ty.fold_with(self, outer_binder);\n                 self.var_stack.pop();\n                 result.assert_ty_ref(Interner).clone()\n             } else {\n@@ -686,15 +690,15 @@ mod resolve {\n                     .assert_ty_ref(Interner)\n                     .clone()\n             };\n-            Ok(result)\n+            result\n         }\n \n         fn fold_inference_const(\n             &mut self,\n             ty: Ty,\n             var: InferenceVar,\n             outer_binder: DebruijnIndex,\n-        ) -> Fallible<Const> {\n+        ) -> Const {\n             let var = self.table.var_unification_table.inference_var_root(var);\n             let default = ConstData {\n                 ty: ty.clone(),\n@@ -704,35 +708,33 @@ mod resolve {\n             .cast(Interner);\n             if self.var_stack.contains(&var) {\n                 // recursive\n-                return Ok((self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n+                return (self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n                     .assert_const_ref(Interner)\n-                    .clone());\n+                    .clone();\n             }\n-            let result = if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n+            if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n                 // known_ty may contain other variables that are known by now\n                 self.var_stack.push(var);\n-                let result =\n-                    known_ty.fold_with(self, outer_binder).expect(\"fold failed unexpectedly\");\n+                let result = known_ty.fold_with(self, outer_binder);\n                 self.var_stack.pop();\n                 result.assert_const_ref(Interner).clone()\n             } else {\n                 (self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n                     .assert_const_ref(Interner)\n                     .clone()\n-            };\n-            Ok(result)\n+            }\n         }\n \n         fn fold_inference_lifetime(\n             &mut self,\n             _var: InferenceVar,\n             _outer_binder: DebruijnIndex,\n-        ) -> Fallible<Lifetime> {\n+        ) -> Lifetime {\n             // fall back all lifetimes to 'static -- currently we don't deal\n             // with any lifetimes, but we can sometimes get some lifetime\n             // variables through Chalk's unification, and this at least makes\n             // sure we don't leak them outside of inference\n-            Ok(crate::static_lifetime())\n+            crate::static_lifetime()\n         }\n     }\n }"}, {"sha": "c4b700cbce6db78284321f80bd956e9a4e5f5165", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 41, "deletions": 47, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -254,13 +254,13 @@ impl CallableSig {\n }\n \n impl TypeFoldable<Interner> for CallableSig {\n-    fn fold_with<E>(\n+    fn try_fold_with<E>(\n         self,\n-        folder: &mut dyn chalk_ir::fold::TypeFolder<Interner, Error = E>,\n+        folder: &mut dyn chalk_ir::fold::FallibleTypeFolder<Interner, Error = E>,\n         outer_binder: DebruijnIndex,\n     ) -> Result<Self, E> {\n         let vec = self.params_and_return.to_vec();\n-        let folded = vec.fold_with(folder, outer_binder)?;\n+        let folded = vec.try_fold_with(folder, outer_binder)?;\n         Ok(CallableSig { params_and_return: folded.into(), is_varargs: self.is_varargs })\n     }\n }\n@@ -292,16 +292,19 @@ pub(crate) fn fold_free_vars<T: HasInterner<Interner = Interner> + TypeFoldable<\n     for_ty: impl FnMut(BoundVar, DebruijnIndex) -> Ty,\n     for_const: impl FnMut(Ty, BoundVar, DebruijnIndex) -> Const,\n ) -> T {\n-    use chalk_ir::{fold::TypeFolder, Fallible};\n-    struct FreeVarFolder<F1, F2>(F1, F2);\n+    use chalk_ir::fold::TypeFolder;\n+\n+    #[derive(chalk_derive::FallibleTypeFolder)]\n+    #[has_interner(Interner)]\n+    struct FreeVarFolder<\n+        F1: FnMut(BoundVar, DebruijnIndex) -> Ty,\n+        F2: FnMut(Ty, BoundVar, DebruijnIndex) -> Const,\n+    >(F1, F2);\n     impl<\n-            'i,\n-            F1: FnMut(BoundVar, DebruijnIndex) -> Ty + 'i,\n-            F2: FnMut(Ty, BoundVar, DebruijnIndex) -> Const + 'i,\n+            F1: FnMut(BoundVar, DebruijnIndex) -> Ty,\n+            F2: FnMut(Ty, BoundVar, DebruijnIndex) -> Const,\n         > TypeFolder<Interner> for FreeVarFolder<F1, F2>\n     {\n-        type Error = NoSolution;\n-\n         fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n             self\n         }\n@@ -310,25 +313,20 @@ pub(crate) fn fold_free_vars<T: HasInterner<Interner = Interner> + TypeFoldable<\n             Interner\n         }\n \n-        fn fold_free_var_ty(\n-            &mut self,\n-            bound_var: BoundVar,\n-            outer_binder: DebruijnIndex,\n-        ) -> Fallible<Ty> {\n-            Ok(self.0(bound_var, outer_binder))\n+        fn fold_free_var_ty(&mut self, bound_var: BoundVar, outer_binder: DebruijnIndex) -> Ty {\n+            self.0(bound_var, outer_binder)\n         }\n \n         fn fold_free_var_const(\n             &mut self,\n             ty: Ty,\n             bound_var: BoundVar,\n             outer_binder: DebruijnIndex,\n-        ) -> Fallible<Const> {\n-            Ok(self.1(ty, bound_var, outer_binder))\n+        ) -> Const {\n+            self.1(ty, bound_var, outer_binder)\n         }\n     }\n     t.fold_with(&mut FreeVarFolder(for_ty, for_const), DebruijnIndex::INNERMOST)\n-        .expect(\"fold failed unexpectedly\")\n }\n \n pub(crate) fn fold_tys<T: HasInterner<Interner = Interner> + TypeFoldable<Interner>>(\n@@ -351,16 +349,13 @@ pub(crate) fn fold_tys_and_consts<T: HasInterner<Interner = Interner> + TypeFold\n     f: impl FnMut(Either<Ty, Const>, DebruijnIndex) -> Either<Ty, Const>,\n     binders: DebruijnIndex,\n ) -> T {\n-    use chalk_ir::{\n-        fold::{TypeFolder, TypeSuperFoldable},\n-        Fallible,\n-    };\n-    struct TyFolder<F>(F);\n-    impl<'i, F: FnMut(Either<Ty, Const>, DebruijnIndex) -> Either<Ty, Const> + 'i>\n-        TypeFolder<Interner> for TyFolder<F>\n+    use chalk_ir::fold::{TypeFolder, TypeSuperFoldable};\n+    #[derive(chalk_derive::FallibleTypeFolder)]\n+    #[has_interner(Interner)]\n+    struct TyFolder<F: FnMut(Either<Ty, Const>, DebruijnIndex) -> Either<Ty, Const>>(F);\n+    impl<F: FnMut(Either<Ty, Const>, DebruijnIndex) -> Either<Ty, Const>> TypeFolder<Interner>\n+        for TyFolder<F>\n     {\n-        type Error = NoSolution;\n-\n         fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n             self\n         }\n@@ -369,16 +364,16 @@ pub(crate) fn fold_tys_and_consts<T: HasInterner<Interner = Interner> + TypeFold\n             Interner\n         }\n \n-        fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n-            let ty = ty.super_fold_with(self.as_dyn(), outer_binder)?;\n-            Ok(self.0(Either::Left(ty), outer_binder).left().unwrap())\n+        fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Ty {\n+            let ty = ty.super_fold_with(self.as_dyn(), outer_binder);\n+            self.0(Either::Left(ty), outer_binder).left().unwrap()\n         }\n \n-        fn fold_const(&mut self, c: Const, outer_binder: DebruijnIndex) -> Fallible<Const> {\n-            Ok(self.0(Either::Right(c), outer_binder).right().unwrap())\n+        fn fold_const(&mut self, c: Const, outer_binder: DebruijnIndex) -> Const {\n+            self.0(Either::Right(c), outer_binder).right().unwrap()\n         }\n     }\n-    t.fold_with(&mut TyFolder(f), binders).expect(\"fold failed unexpectedly\")\n+    t.fold_with(&mut TyFolder(f), binders)\n }\n \n /// 'Canonicalizes' the `t` by replacing any errors with new variables. Also\n@@ -390,35 +385,34 @@ where\n     T: HasInterner<Interner = Interner>,\n {\n     use chalk_ir::{\n-        fold::{TypeFolder, TypeSuperFoldable},\n+        fold::{FallibleTypeFolder, TypeSuperFoldable},\n         Fallible,\n     };\n     struct ErrorReplacer {\n         vars: usize,\n     }\n-    impl TypeFolder<Interner> for ErrorReplacer {\n+    impl FallibleTypeFolder<Interner> for ErrorReplacer {\n         type Error = NoSolution;\n \n-        fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n+        fn as_dyn(&mut self) -> &mut dyn FallibleTypeFolder<Interner, Error = Self::Error> {\n             self\n         }\n \n         fn interner(&self) -> Interner {\n             Interner\n         }\n \n-        fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n+        fn try_fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n             if let TyKind::Error = ty.kind(Interner) {\n                 let index = self.vars;\n                 self.vars += 1;\n                 Ok(TyKind::BoundVar(BoundVar::new(outer_binder, index)).intern(Interner))\n             } else {\n-                let ty = ty.super_fold_with(self.as_dyn(), outer_binder)?;\n-                Ok(ty)\n+                ty.try_super_fold_with(self.as_dyn(), outer_binder)\n             }\n         }\n \n-        fn fold_inference_ty(\n+        fn try_fold_inference_ty(\n             &mut self,\n             _var: InferenceVar,\n             _kind: TyVariableKind,\n@@ -433,7 +427,7 @@ where\n             }\n         }\n \n-        fn fold_free_var_ty(\n+        fn try_fold_free_var_ty(\n             &mut self,\n             _bound_var: BoundVar,\n             _outer_binder: DebruijnIndex,\n@@ -447,7 +441,7 @@ where\n             }\n         }\n \n-        fn fold_inference_const(\n+        fn try_fold_inference_const(\n             &mut self,\n             ty: Ty,\n             _var: InferenceVar,\n@@ -460,7 +454,7 @@ where\n             }\n         }\n \n-        fn fold_free_var_const(\n+        fn try_fold_free_var_const(\n             &mut self,\n             ty: Ty,\n             _bound_var: BoundVar,\n@@ -473,7 +467,7 @@ where\n             }\n         }\n \n-        fn fold_inference_lifetime(\n+        fn try_fold_inference_lifetime(\n             &mut self,\n             _var: InferenceVar,\n             _outer_binder: DebruijnIndex,\n@@ -485,7 +479,7 @@ where\n             }\n         }\n \n-        fn fold_free_var_lifetime(\n+        fn try_fold_free_var_lifetime(\n             &mut self,\n             _bound_var: BoundVar,\n             _outer_binder: DebruijnIndex,\n@@ -498,7 +492,7 @@ where\n         }\n     }\n     let mut error_replacer = ErrorReplacer { vars: 0 };\n-    let value = match t.clone().fold_with(&mut error_replacer, DebruijnIndex::INNERMOST) {\n+    let value = match t.clone().try_fold_with(&mut error_replacer, DebruijnIndex::INNERMOST) {\n         Ok(t) => t,\n         Err(_) => panic!(\"Encountered unbound or inference vars in {:?}\", t),\n     };"}, {"sha": "223d705b157b32c03755a65e416ae380c1d22916", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 156, "deletions": 79, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -306,7 +306,7 @@ impl<'a> TyLoweringContext<'a> {\n                         // FIXME we're probably doing something wrong here\n                         self.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n                         let (\n-                            parent_params,\n+                            _parent_params,\n                             self_params,\n                             list_params,\n                             const_params,\n@@ -319,7 +319,7 @@ impl<'a> TyLoweringContext<'a> {\n                         };\n                         TyKind::BoundVar(BoundVar::new(\n                             self.in_binders,\n-                            idx as usize + parent_params + self_params + list_params + const_params,\n+                            idx as usize + self_params + list_params + const_params,\n                         ))\n                         .intern(Interner)\n                     }\n@@ -499,14 +499,31 @@ impl<'a> TyLoweringContext<'a> {\n                 .intern(Interner)\n             }\n             TypeNs::SelfType(impl_id) => {\n-                let generics = generics(self.db.upcast(), impl_id.into());\n-                let substs = match self.type_param_mode {\n-                    ParamLoweringMode::Placeholder => generics.placeholder_subst(self.db),\n+                let def =\n+                    self.resolver.generic_def().expect(\"impl should have generic param scope\");\n+                let generics = generics(self.db.upcast(), def);\n+\n+                match self.type_param_mode {\n+                    ParamLoweringMode::Placeholder => {\n+                        // `def` can be either impl itself or item within, and we need impl itself\n+                        // now.\n+                        let generics = generics.parent_generics().unwrap_or(&generics);\n+                        let subst = generics.placeholder_subst(self.db);\n+                        self.db.impl_self_ty(impl_id).substitute(Interner, &subst)\n+                    }\n                     ParamLoweringMode::Variable => {\n-                        generics.bound_vars_subst(self.db, self.in_binders)\n+                        let starting_from = match def {\n+                            GenericDefId::ImplId(_) => 0,\n+                            // `def` is an item within impl. We need to substitute `BoundVar`s but\n+                            // remember that they are for parent (i.e. impl) generic params so they\n+                            // come after our own params.\n+                            _ => generics.len_self(),\n+                        };\n+                        TyBuilder::impl_self_ty(self.db, impl_id)\n+                            .fill_with_bound_vars(self.in_binders, starting_from)\n+                            .build()\n                     }\n-                };\n-                self.db.impl_self_ty(impl_id).substitute(Interner, &substs)\n+                }\n             }\n             TypeNs::AdtSelfType(adt) => {\n                 let generics = generics(self.db.upcast(), adt.into());\n@@ -663,40 +680,31 @@ impl<'a> TyLoweringContext<'a> {\n     fn substs_from_path_segment(\n         &self,\n         segment: PathSegment<'_>,\n-        def_generic: Option<GenericDefId>,\n+        def: Option<GenericDefId>,\n         infer_args: bool,\n         explicit_self_ty: Option<Ty>,\n     ) -> Substitution {\n+        // Remember that the item's own generic args come before its parent's.\n         let mut substs = Vec::new();\n-        let def_generics = if let Some(def) = def_generic {\n-            generics(self.db.upcast(), def)\n+        let def = if let Some(d) = def {\n+            d\n         } else {\n             return Substitution::empty(Interner);\n         };\n+        let def_generics = generics(self.db.upcast(), def);\n         let (parent_params, self_params, type_params, const_params, impl_trait_params) =\n             def_generics.provenance_split();\n-        let total_len =\n-            parent_params + self_params + type_params + const_params + impl_trait_params;\n+        let item_len = self_params + type_params + const_params + impl_trait_params;\n+        let total_len = parent_params + item_len;\n \n-        let ty_error = GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner);\n+        let ty_error = TyKind::Error.intern(Interner).cast(Interner);\n \n         let mut def_generic_iter = def_generics.iter_id();\n \n-        for _ in 0..parent_params {\n-            if let Some(eid) = def_generic_iter.next() {\n-                match eid {\n-                    Either::Left(_) => substs.push(ty_error.clone()),\n-                    Either::Right(x) => {\n-                        substs.push(unknown_const_as_generic(self.db.const_param_ty(x)))\n-                    }\n-                }\n-            }\n-        }\n-\n         let fill_self_params = || {\n             for x in explicit_self_ty\n                 .into_iter()\n-                .map(|x| GenericArgData::Ty(x).intern(Interner))\n+                .map(|x| x.cast(Interner))\n                 .chain(iter::repeat(ty_error.clone()))\n                 .take(self_params)\n             {\n@@ -757,37 +765,40 @@ impl<'a> TyLoweringContext<'a> {\n             fill_self_params();\n         }\n \n+        // These params include those of parent.\n+        let remaining_params: SmallVec<[_; 2]> = def_generic_iter\n+            .map(|eid| match eid {\n+                Either::Left(_) => ty_error.clone(),\n+                Either::Right(x) => unknown_const_as_generic(self.db.const_param_ty(x)),\n+            })\n+            .collect();\n+        assert_eq!(remaining_params.len() + substs.len(), total_len);\n+\n         // handle defaults. In expression or pattern path segments without\n         // explicitly specified type arguments, missing type arguments are inferred\n         // (i.e. defaults aren't used).\n         if !infer_args || had_explicit_args {\n-            if let Some(def_generic) = def_generic {\n-                let defaults = self.db.generic_defaults(def_generic);\n-                assert_eq!(total_len, defaults.len());\n-\n-                for default_ty in defaults.iter().skip(substs.len()) {\n-                    // each default can depend on the previous parameters\n-                    let substs_so_far = Substitution::from_iter(Interner, substs.clone());\n-                    if let Some(_id) = def_generic_iter.next() {\n-                        substs.push(default_ty.clone().substitute(Interner, &substs_so_far));\n-                    }\n-                }\n+            let defaults = self.db.generic_defaults(def);\n+            assert_eq!(total_len, defaults.len());\n+            let parent_from = item_len - substs.len();\n+\n+            for (idx, default_ty) in defaults[substs.len()..item_len].iter().enumerate() {\n+                // each default can depend on the previous parameters\n+                let substs_so_far = Substitution::from_iter(\n+                    Interner,\n+                    substs.iter().cloned().chain(remaining_params[idx..].iter().cloned()),\n+                );\n+                substs.push(default_ty.clone().substitute(Interner, &substs_so_far));\n             }\n-        }\n \n-        // add placeholders for args that were not provided\n-        // FIXME: emit diagnostics in contexts where this is not allowed\n-        for eid in def_generic_iter {\n-            match eid {\n-                Either::Left(_) => substs.push(ty_error.clone()),\n-                Either::Right(x) => {\n-                    substs.push(unknown_const_as_generic(self.db.const_param_ty(x)))\n-                }\n-            }\n+            // Keep parent's params as unknown.\n+            let mut remaining_params = remaining_params;\n+            substs.extend(remaining_params.drain(parent_from..));\n+        } else {\n+            substs.extend(remaining_params);\n         }\n-        // If this assert fails, it means you pushed into subst but didn't call .next() of def_generic_iter\n-        assert_eq!(substs.len(), total_len);\n \n+        assert_eq!(substs.len(), total_len);\n         Substitution::from_iter(Interner, substs)\n     }\n \n@@ -981,10 +992,11 @@ impl<'a> TyLoweringContext<'a> {\n \n     fn lower_dyn_trait(&self, bounds: &[Interned<TypeBound>]) -> Ty {\n         let self_ty = TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(Interner);\n-        // INVARIANT: The principal trait bound must come first. Others may be in any order but\n-        // should be in the same order for the same set but possibly different order of bounds in\n-        // the input.\n-        // This invariant is used by `TyExt::dyn_trait()` and chalk.\n+        // INVARIANT: The principal trait bound, if present, must come first. Others may be in any\n+        // order but should be in the same order for the same set but possibly different order of\n+        // bounds in the input.\n+        // INVARIANT: If this function returns `DynTy`, there should be at least one trait bound.\n+        // These invariants are utilized by `TyExt::dyn_trait()` and chalk.\n         let bounds = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n             let mut bounds: Vec<_> = bounds\n                 .iter()\n@@ -1035,6 +1047,12 @@ impl<'a> TyLoweringContext<'a> {\n                 return None;\n             }\n \n+            if bounds.first().and_then(|b| b.trait_id()).is_none() {\n+                // When there's no trait bound, that's an error. This happens when the trait refs\n+                // are unresolved.\n+                return None;\n+            }\n+\n             // As multiple occurrences of the same auto traits *are* permitted, we dedulicate the\n             // bounds. We shouldn't have repeated elements besides auto traits at this point.\n             bounds.dedup();\n@@ -1046,7 +1064,8 @@ impl<'a> TyLoweringContext<'a> {\n             let bounds = crate::make_single_type_binders(bounds);\n             TyKind::Dyn(DynTy { bounds, lifetime: static_lifetime() }).intern(Interner)\n         } else {\n-            // FIXME: report error (additional non-auto traits or associated type rebound)\n+            // FIXME: report error\n+            // (additional non-auto traits, associated type rebound, or no resolved trait)\n             TyKind::Error.intern(Interner)\n         }\n     }\n@@ -1139,11 +1158,28 @@ fn named_associated_type_shorthand_candidates<R>(\n     };\n \n     match res {\n-        TypeNs::SelfType(impl_id) => search(\n+        TypeNs::SelfType(impl_id) => {\n             // we're _in_ the impl -- the binders get added back later. Correct,\n             // but it would be nice to make this more explicit\n-            db.impl_trait(impl_id)?.into_value_and_skipped_binders().0,\n-        ),\n+            let trait_ref = db.impl_trait(impl_id)?.into_value_and_skipped_binders().0;\n+\n+            let impl_id_as_generic_def: GenericDefId = impl_id.into();\n+            if impl_id_as_generic_def != def {\n+                // `trait_ref` contains `BoundVar`s bound by impl's `Binders`, but here we need\n+                // `BoundVar`s from `def`'s point of view.\n+                // FIXME: A `HirDatabase` query may be handy if this process is needed in more\n+                // places. It'd be almost identical as `impl_trait_query` where `resolver` would be\n+                // of `def` instead of `impl_id`.\n+                let starting_idx = generics(db.upcast(), def).len_self();\n+                let subst = TyBuilder::subst_for_def(db, impl_id, None)\n+                    .fill_with_bound_vars(DebruijnIndex::INNERMOST, starting_idx)\n+                    .build();\n+                let trait_ref = subst.apply(trait_ref, Interner);\n+                search(trait_ref)\n+            } else {\n+                search(trait_ref)\n+            }\n+        }\n         TypeNs::GenericParam(param_id) => {\n             let predicates = db.generic_predicates_for_param(def, param_id.into(), assoc_name);\n             let res = predicates.iter().find_map(|pred| match pred.skip_binders().skip_binders() {\n@@ -1160,10 +1196,18 @@ fn named_associated_type_shorthand_candidates<R>(\n             }\n             // Handle `Self::Type` referring to own associated type in trait definitions\n             if let GenericDefId::TraitId(trait_id) = param_id.parent() {\n-                let generics = generics(db.upcast(), trait_id.into());\n-                if generics.params.type_or_consts[param_id.local_id()].is_trait_self() {\n+                let trait_generics = generics(db.upcast(), trait_id.into());\n+                if trait_generics.params.type_or_consts[param_id.local_id()].is_trait_self() {\n+                    let def_generics = generics(db.upcast(), def);\n+                    let starting_idx = match def {\n+                        GenericDefId::TraitId(_) => 0,\n+                        // `def` is an item within trait. We need to substitute `BoundVar`s but\n+                        // remember that they are for parent (i.e. trait) generic params so they\n+                        // come after our own params.\n+                        _ => def_generics.len_self(),\n+                    };\n                     let trait_ref = TyBuilder::trait_ref(db, trait_id)\n-                        .fill_with_bound_vars(DebruijnIndex::INNERMOST, 0)\n+                        .fill_with_bound_vars(DebruijnIndex::INNERMOST, starting_idx)\n                         .build();\n                     return search(trait_ref);\n                 }\n@@ -1405,6 +1449,7 @@ pub(crate) fn generic_defaults_query(\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     let generic_params = generics(db.upcast(), def);\n+    let parent_start_idx = generic_params.len_self();\n \n     let defaults = generic_params\n         .iter()\n@@ -1417,19 +1462,17 @@ pub(crate) fn generic_defaults_query(\n                     let val = unknown_const_as_generic(\n                         db.const_param_ty(ConstParamId::from_unchecked(id)),\n                     );\n-                    return crate::make_binders_with_count(db, idx, &generic_params, val);\n+                    return make_binders(db, &generic_params, val);\n                 }\n             };\n             let mut ty =\n                 p.default.as_ref().map_or(TyKind::Error.intern(Interner), |t| ctx.lower_ty(t));\n \n             // Each default can only refer to previous parameters.\n-            // type variable default referring to parameter coming\n-            // after it. This is forbidden (FIXME: report\n-            // diagnostic)\n-            ty = fallback_bound_vars(ty, idx);\n-            let val = GenericArgData::Ty(ty).intern(Interner);\n-            crate::make_binders_with_count(db, idx, &generic_params, val)\n+            // Type variable default referring to parameter coming\n+            // after it is forbidden (FIXME: report diagnostic)\n+            ty = fallback_bound_vars(ty, idx, parent_start_idx);\n+            crate::make_binders(db, &generic_params, ty.cast(Interner))\n         })\n         .collect();\n \n@@ -1446,15 +1489,14 @@ pub(crate) fn generic_defaults_recover(\n     // we still need one default per parameter\n     let defaults = generic_params\n         .iter_id()\n-        .enumerate()\n-        .map(|(count, id)| {\n+        .map(|id| {\n             let val = match id {\n                 itertools::Either::Left(_) => {\n                     GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner)\n                 }\n                 itertools::Either::Right(id) => unknown_const_as_generic(db.const_param_ty(id)),\n             };\n-            crate::make_binders_with_count(db, count, &generic_params, val)\n+            crate::make_binders(db, &generic_params, val)\n         })\n         .collect();\n \n@@ -1633,6 +1675,19 @@ pub enum ValueTyDefId {\n }\n impl_from!(FunctionId, StructId, UnionId, EnumVariantId, ConstId, StaticId for ValueTyDefId);\n \n+impl ValueTyDefId {\n+    pub(crate) fn to_generic_def_id(self) -> Option<GenericDefId> {\n+        match self {\n+            Self::FunctionId(id) => Some(id.into()),\n+            Self::StructId(id) => Some(id.into()),\n+            Self::UnionId(id) => Some(id.into()),\n+            Self::EnumVariantId(var) => Some(var.into()),\n+            Self::ConstId(id) => Some(id.into()),\n+            Self::StaticId(_) => None,\n+        }\n+    }\n+}\n+\n /// Build the declared type of an item. This depends on the namespace; e.g. for\n /// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n /// the constructor function `(usize) -> Foo` which lives in the values\n@@ -1816,26 +1871,48 @@ pub(crate) fn const_or_path_to_chalk(\n     }\n }\n \n-/// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n-/// num_vars_to_keep) by `TyKind::Unknown`.\n+/// Replaces any 'free' `BoundVar`s in `s` by `TyKind::Error` from the perspective of generic\n+/// parameter whose index is `param_index`. A `BoundVar` is free when it is or (syntactically)\n+/// appears after the generic parameter of `param_index`.\n fn fallback_bound_vars<T: TypeFoldable<Interner> + HasInterner<Interner = Interner>>(\n     s: T,\n-    num_vars_to_keep: usize,\n+    param_index: usize,\n+    parent_start: usize,\n ) -> T {\n+    // Keep in mind that parent generic parameters, if any, come *after* those of the item in\n+    // question. In the diagrams below, `c*` and `p*` represent generic parameters of the item and\n+    // its parent respectively.\n+    let is_allowed = |index| {\n+        if param_index < parent_start {\n+            // The parameter of `param_index` is one from the item in question. Any parent generic\n+            // parameters or the item's generic parameters that come before `param_index` is\n+            // allowed.\n+            // [c1, .., cj, .., ck, p1, .., pl] where cj is `param_index`\n+            //  ^^^^^^              ^^^^^^^^^^ these are allowed\n+            !(param_index..parent_start).contains(&index)\n+        } else {\n+            // The parameter of `param_index` is one from the parent generics. Only parent generic\n+            // parameters that come before `param_index` are allowed.\n+            // [c1, .., ck, p1, .., pj, .., pl] where pj is `param_index`\n+            //              ^^^^^^ these are allowed\n+            (parent_start..param_index).contains(&index)\n+        }\n+    };\n+\n     crate::fold_free_vars(\n         s,\n         |bound, binders| {\n-            if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n-                TyKind::Error.intern(Interner)\n-            } else {\n+            if bound.index_if_innermost().map_or(true, is_allowed) {\n                 bound.shifted_in_from(binders).to_ty(Interner)\n+            } else {\n+                TyKind::Error.intern(Interner)\n             }\n         },\n         |ty, bound, binders| {\n-            if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n-                unknown_const(ty.clone())\n-            } else {\n+            if bound.index_if_innermost().map_or(true, is_allowed) {\n                 bound.shifted_in_from(binders).to_const(Interner, ty)\n+            } else {\n+                unknown_const(ty.clone())\n             }\n         },\n     )"}, {"sha": "f80fb39c1f84e24854bfecbe3fd06a06786f86b2", "filename": "crates/hir-ty/src/mapping.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmapping.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -103,6 +103,18 @@ impl From<crate::db::InternedClosureId> for chalk_ir::ClosureId<Interner> {\n     }\n }\n \n+impl From<chalk_ir::GeneratorId<Interner>> for crate::db::InternedGeneratorId {\n+    fn from(id: chalk_ir::GeneratorId<Interner>) -> Self {\n+        Self::from_intern_id(id.0)\n+    }\n+}\n+\n+impl From<crate::db::InternedGeneratorId> for chalk_ir::GeneratorId<Interner> {\n+    fn from(id: crate::db::InternedGeneratorId) -> Self {\n+        chalk_ir::GeneratorId(id.as_intern_id())\n+    }\n+}\n+\n pub fn to_foreign_def_id(id: TypeAliasId) -> ForeignDefId {\n     chalk_ir::ForeignDefId(salsa::InternKey::as_intern_id(&id))\n }"}, {"sha": "a79efeb6daa84dbc0a736ff01668dbcaa139b0e3", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -1,7 +1,7 @@\n //! This module is concerned with finding methods that a given type provides.\n //! For details about how this works in rustc, see the method lookup page in the\n //! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)\n-//! and the corresponding code mostly in librustc_typeck/check/method/probe.rs.\n+//! and the corresponding code mostly in rustc_hir_analysis/check/method/probe.rs.\n use std::{iter, ops::ControlFlow, sync::Arc};\n \n use arrayvec::ArrayVec;\n@@ -654,7 +654,7 @@ fn find_matching_impl(\n         let r = table.run_in_snapshot(|table| {\n             let impl_data = db.impl_data(impl_);\n             let substs =\n-                TyBuilder::subst_for_def(db, impl_).fill_with_inference_vars(table).build();\n+                TyBuilder::subst_for_def(db, impl_, None).fill_with_inference_vars(table).build();\n             let impl_ty = db.impl_self_ty(impl_).substitute(Interner, &substs);\n \n             table\n@@ -1111,6 +1111,24 @@ pub fn resolve_indexing_op(\n     }\n     None\n }\n+/// Returns the receiver type for the try branch trait call.\n+pub fn resolve_branch_op(\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    ty: Canonical<Ty>,\n+    try_trait: TraitId,\n+) -> Option<ReceiverAdjustments> {\n+    let mut table = InferenceTable::new(db, env.clone());\n+    let ty = table.instantiate_canonical(ty);\n+    let (deref_chain, adj) = autoderef_method_receiver(&mut table, ty);\n+    for (ty, adj) in deref_chain.into_iter().zip(adj) {\n+        let goal = generic_implements_goal(db, env.clone(), try_trait, &ty);\n+        if db.trait_solve(env.krate, goal.cast(Interner)).is_some() {\n+            return Some(adj);\n+        }\n+    }\n+    None\n+}\n \n macro_rules! check_that {\n     ($cond:expr) => {\n@@ -1147,10 +1165,9 @@ fn is_valid_candidate(\n             }));\n             if let ItemContainerId::ImplId(impl_id) = c.lookup(db.upcast()).container {\n                 let self_ty_matches = table.run_in_snapshot(|table| {\n-                    let subst =\n-                        TyBuilder::subst_for_def(db, c).fill_with_inference_vars(table).build();\n-                    let expected_self_ty =\n-                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner);\n+                    let expected_self_ty = TyBuilder::impl_self_ty(db, impl_id)\n+                        .fill_with_inference_vars(table)\n+                        .build();\n                     table.unify(&expected_self_ty, &self_ty)\n                 });\n                 if !self_ty_matches {\n@@ -1186,31 +1203,26 @@ fn is_valid_fn_candidate(\n \n     table.run_in_snapshot(|table| {\n         let container = fn_id.lookup(db.upcast()).container;\n-        let impl_subst = match container {\n+        let (impl_subst, expect_self_ty) = match container {\n             ItemContainerId::ImplId(it) => {\n-                TyBuilder::subst_for_def(db, it).fill_with_inference_vars(table).build()\n+                let subst =\n+                    TyBuilder::subst_for_def(db, it, None).fill_with_inference_vars(table).build();\n+                let self_ty = db.impl_self_ty(it).substitute(Interner, &subst);\n+                (subst, self_ty)\n             }\n             ItemContainerId::TraitId(it) => {\n-                TyBuilder::subst_for_def(db, it).fill_with_inference_vars(table).build()\n+                let subst =\n+                    TyBuilder::subst_for_def(db, it, None).fill_with_inference_vars(table).build();\n+                let self_ty = subst.at(Interner, 0).assert_ty_ref(Interner).clone();\n+                (subst, self_ty)\n             }\n             _ => unreachable!(),\n         };\n \n-        let fn_subst = TyBuilder::subst_for_def(db, fn_id)\n-            .use_parent_substs(&impl_subst)\n+        let fn_subst = TyBuilder::subst_for_def(db, fn_id, Some(impl_subst.clone()))\n             .fill_with_inference_vars(table)\n             .build();\n \n-        let expect_self_ty = match container {\n-            ItemContainerId::TraitId(_) => fn_subst.at(Interner, 0).assert_ty_ref(Interner).clone(),\n-            ItemContainerId::ImplId(impl_id) => {\n-                fn_subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n-            }\n-            // We should only get called for associated items (impl/trait)\n-            ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n-                unreachable!()\n-            }\n-        };\n         check_that!(table.unify(&expect_self_ty, self_ty));\n \n         if let Some(receiver_ty) = receiver_ty {"}, {"sha": "ebbc5410147c6b8d63e8b4df5623fba06db5b4d5", "filename": "crates/hir-ty/src/tests.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -16,7 +16,7 @@ use base_db::{fixture::WithFixture, FileRange, SourceDatabaseExt};\n use expect_test::Expect;\n use hir_def::{\n     body::{Body, BodySourceMap, SyntheticSyntax},\n-    db::DefDatabase,\n+    db::{DefDatabase, InternDatabase},\n     expr::{ExprId, PatId},\n     item_scope::ItemScope,\n     nameres::DefMap,\n@@ -135,6 +135,10 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n             let loc = it.lookup(&db);\n             loc.source(&db).value.syntax().text_range().start()\n         }\n+        DefWithBodyId::VariantId(it) => {\n+            let loc = db.lookup_intern_enum(it.parent);\n+            loc.source(&db).value.syntax().text_range().start()\n+        }\n     });\n     let mut unexpected_type_mismatches = String::new();\n     for def in defs {\n@@ -388,6 +392,10 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n             let loc = it.lookup(&db);\n             loc.source(&db).value.syntax().text_range().start()\n         }\n+        DefWithBodyId::VariantId(it) => {\n+            let loc = db.lookup_intern_enum(it.parent);\n+            loc.source(&db).value.syntax().text_range().start()\n+        }\n     });\n     for def in defs {\n         let (_body, source_map) = db.body_with_source_map(def);\n@@ -453,6 +461,18 @@ fn visit_module(\n                     let body = db.body(def);\n                     visit_body(db, &body, cb);\n                 }\n+                ModuleDefId::AdtId(hir_def::AdtId::EnumId(it)) => {\n+                    db.enum_data(it)\n+                        .variants\n+                        .iter()\n+                        .map(|(id, _)| hir_def::EnumVariantId { parent: it, local_id: id })\n+                        .for_each(|it| {\n+                            let def = it.into();\n+                            cb(def);\n+                            let body = db.body(def);\n+                            visit_body(db, &body, cb);\n+                        });\n+                }\n                 ModuleDefId::TraitId(it) => {\n                     let trait_data = db.trait_data(it);\n                     for &(_, item) in trait_data.items.iter() {"}, {"sha": "d301595bcd98a5ac3f29fda2bc5626cf8e546a8c", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -294,6 +294,24 @@ fn foo() {\n     );\n }\n \n+#[test]\n+fn generator_yield_return_coerce() {\n+    check_no_mismatches(\n+        r#\"\n+fn test() {\n+    let g = || {\n+        yield &1u32;\n+        yield &&1u32;\n+        if true {\n+            return &1u32;\n+        }\n+        &&1u32\n+    };\n+}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn assign_coerce() {\n     check_no_mismatches("}, {"sha": "8a8ff08cfe8cdab81a7250bdd273175ec3a47179", "filename": "crates/hir-ty/src/tests/display_source_code.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -55,6 +55,28 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn render_dyn_ty_independent_of_order() {\n+    check_types_source_code(\n+        r#\"\n+auto trait Send {}\n+trait A {\n+    type Assoc;\n+}\n+trait B: A {}\n+\n+fn test(\n+    _: &(dyn A<Assoc = ()> + Send),\n+  //^ &(dyn A<Assoc = ()> + Send)\n+    _: &(dyn Send + A<Assoc = ()>),\n+  //^ &(dyn A<Assoc = ()> + Send)\n+    _: &dyn B<Assoc = ()>,\n+  //^ &(dyn B<Assoc = ()>)\n+) {}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn render_dyn_for_ty() {\n     // FIXME"}, {"sha": "74de33117ee7d6dff7a4f90fb79fabd3e77cb7b9", "filename": "crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -1070,3 +1070,13 @@ fn main() {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn cfg_params() {\n+    check_types(\n+        r#\"\n+fn my_fn(#[cfg(feature = \"feature\")] u8: u8, u32: u32) {}\n+                                           //^^^ u32\n+\"#,\n+    );\n+}"}, {"sha": "a155adcec6c33b43335dbcaff4ae864cfb88f8a6", "filename": "crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -1488,7 +1488,6 @@ fn regression_11688_4() {\n \n #[test]\n fn gat_crash_1() {\n-    cov_mark::check!(ignore_gats);\n     check_no_mismatches(\n         r#\"\n trait ATrait {}\n@@ -1527,30 +1526,22 @@ unsafe impl Storage for InlineStorage {\n \n #[test]\n fn gat_crash_3() {\n-    // FIXME: This test currently crashes rust analyzer in a debug build but not in a\n-    // release build (i.e. for the user). With the assumption that tests will always be run\n-    // in debug mode, we catch the unwind and expect that it panicked. See the\n-    // [`crate::utils::generics`] function for more information.\n-    cov_mark::check!(ignore_gats);\n-    std::panic::catch_unwind(|| {\n-        check_no_mismatches(\n-            r#\"\n+    check_no_mismatches(\n+        r#\"\n trait Collection {\n-    type Item;\n-    type Member<T>: Collection<Item = T>;\n-    fn add(&mut self, value: Self::Item) -> Result<(), Self::Error>;\n+type Item;\n+type Member<T>: Collection<Item = T>;\n+fn add(&mut self, value: Self::Item) -> Result<(), Self::Error>;\n }\n struct ConstGen<T, const N: usize> {\n-    data: [T; N],\n+data: [T; N],\n }\n impl<T, const N: usize> Collection for ConstGen<T, N> {\n-    type Item = T;\n-    type Member<U> = ConstGen<U, N>;\n+type Item = T;\n+type Member<U> = ConstGen<U, N>;\n }\n-        \"#,\n-        );\n-    })\n-    .expect_err(\"must panic\");\n+    \"#,\n+    );\n }\n \n #[test]\n@@ -1691,3 +1682,28 @@ fn macrostmts() -> u8 {\n     \"#,\n     );\n }\n+\n+#[test]\n+fn dyn_with_unresolved_trait() {\n+    check_types(\n+        r#\"\n+fn foo(a: &dyn DoesNotExist) {\n+    a.bar();\n+  //^&{unknown}\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn self_assoc_with_const_generics_crash() {\n+    check_no_mismatches(\n+        r#\"\n+trait Trait { type Item; }\n+impl<T, const N: usize> Trait for [T; N] {\n+    type Item = ();\n+    fn f<U>(_: Self::Item) {}\n+}\n+        \"#,\n+    );\n+}"}, {"sha": "080e2ac1b8e1e4a1a6ced3cb7227614a998bfa88", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 138, "deletions": 21, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -1693,16 +1693,16 @@ fn infer_type_param() {\n fn infer_const() {\n     check_infer(\n         r#\"\n-        struct Foo;\n-        impl Foo { const ASSOC_CONST: u32 = 0; }\n-        const GLOBAL_CONST: u32 = 101;\n-        fn test() {\n-            const LOCAL_CONST: u32 = 99;\n-            let x = LOCAL_CONST;\n-            let z = GLOBAL_CONST;\n-            let id = Foo::ASSOC_CONST;\n-        }\n-        \"#,\n+struct Foo;\n+impl Foo { const ASSOC_CONST: u32 = 0; }\n+const GLOBAL_CONST: u32 = 101;\n+fn test() {\n+    const LOCAL_CONST: u32 = 99;\n+    let x = LOCAL_CONST;\n+    let z = GLOBAL_CONST;\n+    let id = Foo::ASSOC_CONST;\n+}\n+\"#,\n         expect![[r#\"\n             48..49 '0': u32\n             79..82 '101': u32\n@@ -1722,17 +1722,17 @@ fn infer_const() {\n fn infer_static() {\n     check_infer(\n         r#\"\n-        static GLOBAL_STATIC: u32 = 101;\n-        static mut GLOBAL_STATIC_MUT: u32 = 101;\n-        fn test() {\n-            static LOCAL_STATIC: u32 = 99;\n-            static mut LOCAL_STATIC_MUT: u32 = 99;\n-            let x = LOCAL_STATIC;\n-            let y = LOCAL_STATIC_MUT;\n-            let z = GLOBAL_STATIC;\n-            let w = GLOBAL_STATIC_MUT;\n-        }\n-        \"#,\n+static GLOBAL_STATIC: u32 = 101;\n+static mut GLOBAL_STATIC_MUT: u32 = 101;\n+fn test() {\n+    static LOCAL_STATIC: u32 = 99;\n+    static mut LOCAL_STATIC_MUT: u32 = 99;\n+    let x = LOCAL_STATIC;\n+    let y = LOCAL_STATIC_MUT;\n+    let z = GLOBAL_STATIC;\n+    let w = GLOBAL_STATIC_MUT;\n+}\n+\"#,\n         expect![[r#\"\n             28..31 '101': u32\n             69..72 '101': u32\n@@ -1751,6 +1751,41 @@ fn infer_static() {\n     );\n }\n \n+#[test]\n+fn infer_enum_variant() {\n+    check_infer(\n+        r#\"\n+enum Foo {\n+    A = 15,\n+    B = Foo::A as isize + 1\n+}\n+\"#,\n+        expect![[r#\"\n+            19..21 '15': isize\n+            31..37 'Foo::A': Foo\n+            31..46 'Foo::A as isize': isize\n+            31..50 'Foo::A...ze + 1': isize\n+            49..50 '1': isize\n+        \"#]],\n+    );\n+    check_infer(\n+        r#\"\n+#[repr(u32)]\n+enum Foo {\n+    A = 15,\n+    B = Foo::A as u32 + 1\n+}\n+\"#,\n+        expect![[r#\"\n+            32..34 '15': u32\n+            44..50 'Foo::A': Foo\n+            44..57 'Foo::A as u32': u32\n+            44..61 'Foo::A...32 + 1': u32\n+            60..61 '1': u32\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn shadowing_primitive() {\n     check_types(\n@@ -1917,6 +1952,88 @@ fn closure_return_inferred() {\n     );\n }\n \n+#[test]\n+fn generator_types_inferred() {\n+    check_infer(\n+        r#\"\n+//- minicore: generator, deref\n+use core::ops::{Generator, GeneratorState};\n+use core::pin::Pin;\n+\n+fn f(v: i64) {}\n+fn test() {\n+    let mut g = |r| {\n+        let a = yield 0;\n+        let a = yield 1;\n+        let a = yield 2;\n+        \"return value\"\n+    };\n+\n+    match Pin::new(&mut g).resume(0usize) {\n+        GeneratorState::Yielded(y) => { f(y); }\n+        GeneratorState::Complete(r) => {}\n+    }\n+}\n+        \"#,\n+        expect![[r#\"\n+            70..71 'v': i64\n+            78..80 '{}': ()\n+            91..362 '{     ...   } }': ()\n+            101..106 'mut g': |usize| yields i64 -> &str\n+            109..218 '|r| { ...     }': |usize| yields i64 -> &str\n+            110..111 'r': usize\n+            113..218 '{     ...     }': &str\n+            127..128 'a': usize\n+            131..138 'yield 0': usize\n+            137..138 '0': i64\n+            152..153 'a': usize\n+            156..163 'yield 1': usize\n+            162..163 '1': i64\n+            177..178 'a': usize\n+            181..188 'yield 2': usize\n+            187..188 '2': i64\n+            198..212 '\"return value\"': &str\n+            225..360 'match ...     }': ()\n+            231..239 'Pin::new': fn new<&mut |usize| yields i64 -> &str>(&mut |usize| yields i64 -> &str) -> Pin<&mut |usize| yields i64 -> &str>\n+            231..247 'Pin::n...mut g)': Pin<&mut |usize| yields i64 -> &str>\n+            231..262 'Pin::n...usize)': GeneratorState<i64, &str>\n+            240..246 '&mut g': &mut |usize| yields i64 -> &str\n+            245..246 'g': |usize| yields i64 -> &str\n+            255..261 '0usize': usize\n+            273..299 'Genera...ded(y)': GeneratorState<i64, &str>\n+            297..298 'y': i64\n+            303..312 '{ f(y); }': ()\n+            305..306 'f': fn f(i64)\n+            305..309 'f(y)': ()\n+            307..308 'y': i64\n+            321..348 'Genera...ete(r)': GeneratorState<i64, &str>\n+            346..347 'r': &str\n+            352..354 '{}': ()\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn generator_resume_yield_return_unit() {\n+    check_no_mismatches(\n+        r#\"\n+//- minicore: generator, deref\n+use core::ops::{Generator, GeneratorState};\n+use core::pin::Pin;\n+fn test() {\n+    let mut g = || {\n+        let () = yield;\n+    };\n+\n+    match Pin::new(&mut g).resume(()) {\n+        GeneratorState::Yielded(()) => {}\n+        GeneratorState::Complete(()) => {}\n+    }\n+}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn fn_pointer_return() {\n     check_infer("}, {"sha": "b91172e33422d67ad40c74ad62f4167399240754", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 16, "deletions": 88, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -162,98 +162,16 @@ fn test() {\n     );\n }\n \n-#[test]\n-fn infer_try() {\n-    check_types(\n-        r#\"\n-//- /main.rs crate:main deps:core\n-fn test() {\n-    let r: Result<i32, u64> = Result::Ok(1);\n-    let v = r?;\n-    v;\n-} //^ i32\n-\n-//- /core.rs crate:core\n-pub mod ops {\n-    pub trait Try {\n-        type Ok;\n-        type Error;\n-    }\n-}\n-\n-pub mod result {\n-    pub enum Result<O, E> {\n-        Ok(O),\n-        Err(E)\n-    }\n-\n-    impl<O, E> crate::ops::Try for Result<O, E> {\n-        type Ok = O;\n-        type Error = E;\n-    }\n-}\n-\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub use crate::{result::*, ops::*};\n-    }\n-}\n-\"#,\n-    );\n-}\n-\n #[test]\n fn infer_try_trait_v2() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n-fn test() {\n-    let r: Result<i32, u64> = Result::Ok(1);\n+//- minicore: try\n+fn test() -> core::ops::ControlFlow<u32, f32> {\n+    let r: core::ops::ControlFlow<u32, f32> = core::ops::ControlFlow::Continue(1.0);\n     let v = r?;\n-    v;\n-} //^ i32\n-\n-//- /core.rs crate:core\n-mod ops {\n-    mod try_trait {\n-        pub trait Try: FromResidual {\n-            type Output;\n-            type Residual;\n-        }\n-        pub trait FromResidual<R = <Self as Try>::Residual> {}\n-    }\n-\n-    pub use self::try_trait::FromResidual;\n-    pub use self::try_trait::Try;\n-}\n-\n-mod convert {\n-    pub trait From<T> {}\n-    impl<T> From<T> for T {}\n-}\n-\n-pub mod result {\n-    use crate::convert::From;\n-    use crate::ops::{Try, FromResidual};\n-\n-    pub enum Infallible {}\n-    pub enum Result<O, E> {\n-        Ok(O),\n-        Err(E)\n-    }\n-\n-    impl<O, E> Try for Result<O, E> {\n-        type Output = O;\n-        type Error = Result<Infallible, E>;\n-    }\n-\n-    impl<T, E, F: From<E>> FromResidual<Result<Infallible, E>> for Result<T, F> {}\n-}\n-\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub use crate::result::*;\n-    }\n+      //^ f32\n+    r\n }\n \"#,\n     );\n@@ -279,6 +197,10 @@ fn test() {\n pub mod iter {\n     pub trait IntoIterator {\n         type Item;\n+        type IntoIter: Iterator<Item = Self::Item>;\n+    }\n+    pub trait Iterator {\n+        type Item;\n     }\n }\n pub mod prelude {\n@@ -297,7 +219,13 @@ pub mod collections {\n     }\n \n     impl<T> IntoIterator for Vec<T> {\n-        type Item=T;\n+        type Item = T;\n+        type IntoIter = IntoIter<T>;\n+    }\n+\n+    struct IntoIter<T> {}\n+    impl<T> Iterator for IntoIter<T> {\n+        type Item = T;\n     }\n }\n \"#,"}, {"sha": "c425f35acfe7e188612bbd3827104793987eca5c", "filename": "crates/hir-ty/src/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -13,8 +13,8 @@ use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, infer::unify::InferenceTable, AliasEq, AliasTy, Canonical, DomainGoal, Goal,\n-    Guidance, InEnvironment, Interner, ProjectionTy, Solution, TraitRefExt, Ty, TyKind,\n-    WhereClause,\n+    Guidance, InEnvironment, Interner, ProjectionTy, ProjectionTyExt, Solution, TraitRefExt, Ty,\n+    TyKind, WhereClause,\n };\n \n /// This controls how much 'time' we give the Chalk solver before giving up.\n@@ -95,7 +95,7 @@ pub(crate) fn trait_solve_query(\n         ..\n     }))) = &goal.value.goal.data(Interner)\n     {\n-        if let TyKind::BoundVar(_) = projection_ty.self_type_parameter(Interner).kind(Interner) {\n+        if let TyKind::BoundVar(_) = projection_ty.self_type_parameter(db).kind(Interner) {\n             // Hack: don't ask Chalk to normalize with an unknown self type, it'll say that's impossible\n             return Some(Solution::Ambig(Guidance::Unknown));\n         }"}, {"sha": "e54bcb421a222222b8a21be500079c034ce737f2", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 38, "deletions": 63, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -4,7 +4,7 @@\n use std::iter;\n \n use base_db::CrateId;\n-use chalk_ir::{fold::Shift, BoundVar, DebruijnIndex};\n+use chalk_ir::{cast::Cast, fold::Shift, BoundVar, DebruijnIndex};\n use hir_def::{\n     db::DefDatabase,\n     generics::{\n@@ -24,8 +24,7 @@ use smallvec::{smallvec, SmallVec};\n use syntax::SmolStr;\n \n use crate::{\n-    db::HirDatabase, ChalkTraitId, ConstData, ConstValue, GenericArgData, Interner, Substitution,\n-    TraitRef, TraitRefExt, TyKind, WhereClause,\n+    db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, WhereClause,\n };\n \n pub(crate) fn fn_traits(db: &dyn DefDatabase, krate: CrateId) -> impl Iterator<Item = TraitId> {\n@@ -174,31 +173,6 @@ pub(super) fn associated_type_by_name_including_super_traits(\n \n pub(crate) fn generics(db: &dyn DefDatabase, def: GenericDefId) -> Generics {\n     let parent_generics = parent_generic_def(db, def).map(|def| Box::new(generics(db, def)));\n-    if parent_generics.is_some() && matches!(def, GenericDefId::TypeAliasId(_)) {\n-        let params = db.generic_params(def);\n-        let parent_params = &parent_generics.as_ref().unwrap().params;\n-        let has_consts =\n-            params.iter().any(|(_, x)| matches!(x, TypeOrConstParamData::ConstParamData(_)));\n-        let parent_has_consts =\n-            parent_params.iter().any(|(_, x)| matches!(x, TypeOrConstParamData::ConstParamData(_)));\n-        return if has_consts || parent_has_consts {\n-            // XXX: treat const generic associated types as not existing to avoid crashes\n-            // (#11769)\n-            //\n-            // Note: Also crashes when the parent has const generics (also even if the GAT\n-            // doesn't use them), see `tests::regression::gat_crash_3` for an example.\n-            // Avoids that by disabling GATs when the parent (i.e. `impl` block) has\n-            // const generics (#12193).\n-            //\n-            // Chalk expects the inner associated type's parameters to come\n-            // *before*, not after the trait's generics as we've always done it.\n-            // Adapting to this requires a larger refactoring\n-            cov_mark::hit!(ignore_gats);\n-            Generics { def, params: Interned::new(Default::default()), parent_generics }\n-        } else {\n-            Generics { def, params, parent_generics }\n-        };\n-    }\n     Generics { def, params: db.generic_params(def), parent_generics }\n }\n \n@@ -221,36 +195,49 @@ impl Generics {\n         })\n     }\n \n-    /// Iterator over types and const params of parent, then self.\n+    /// Iterator over types and const params of self, then parent.\n     pub(crate) fn iter<'a>(\n         &'a self,\n     ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n         let to_toc_id = |it: &'a Generics| {\n             move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p)\n         };\n-        self.parent_generics()\n-            .into_iter()\n-            .flat_map(move |it| it.params.iter().map(to_toc_id(it)))\n-            .chain(self.params.iter().map(to_toc_id(self)))\n+        self.params.iter().map(to_toc_id(self)).chain(self.iter_parent())\n+    }\n+\n+    /// Iterate over types and const params without parent params.\n+    pub(crate) fn iter_self<'a>(\n+        &'a self,\n+    ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n+        let to_toc_id = |it: &'a Generics| {\n+            move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p)\n+        };\n+        self.params.iter().map(to_toc_id(self))\n     }\n \n     /// Iterator over types and const params of parent.\n     pub(crate) fn iter_parent<'a>(\n         &'a self,\n-    ) -> impl Iterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n+    ) -> impl DoubleEndedIterator<Item = (TypeOrConstParamId, &'a TypeOrConstParamData)> + 'a {\n         self.parent_generics().into_iter().flat_map(|it| {\n             let to_toc_id =\n                 move |(local_id, p)| (TypeOrConstParamId { parent: it.def, local_id }, p);\n             it.params.iter().map(to_toc_id)\n         })\n     }\n \n+    /// Returns total number of generic parameters in scope, including those from parent.\n     pub(crate) fn len(&self) -> usize {\n         let parent = self.parent_generics().map_or(0, Generics::len);\n         let child = self.params.type_or_consts.len();\n         parent + child\n     }\n \n+    /// Returns numbers of generic parameters excluding those from parent.\n+    pub(crate) fn len_self(&self) -> usize {\n+        self.params.type_or_consts.len()\n+    }\n+\n     /// (parent total, self param, type param list, const param list, impl trait)\n     pub(crate) fn provenance_split(&self) -> (usize, usize, usize, usize, usize) {\n         let ty_iter = || self.params.iter().filter_map(|x| x.1.type_param());\n@@ -275,15 +262,17 @@ impl Generics {\n         if param.parent == self.def {\n             let (idx, (_local_id, data)) =\n                 self.params.iter().enumerate().find(|(_, (idx, _))| *idx == param.local_id)?;\n-            let parent_len = self.parent_generics().map_or(0, Generics::len);\n-            Some((parent_len + idx, data))\n+            Some((idx, data))\n         } else {\n-            self.parent_generics().and_then(|g| g.find_param(param))\n+            self.parent_generics()\n+                .and_then(|g| g.find_param(param))\n+                // Remember that parent parameters come after parameters for self.\n+                .map(|(idx, data)| (self.len_self() + idx, data))\n         }\n     }\n \n-    fn parent_generics(&self) -> Option<&Generics> {\n-        self.parent_generics.as_ref().map(|it| &**it)\n+    pub(crate) fn parent_generics(&self) -> Option<&Generics> {\n+        self.parent_generics.as_deref()\n     }\n \n     /// Returns a Substitution that replaces each parameter by a bound variable.\n@@ -295,18 +284,10 @@ impl Generics {\n         Substitution::from_iter(\n             Interner,\n             self.iter_id().enumerate().map(|(idx, id)| match id {\n-                Either::Left(_) => GenericArgData::Ty(\n-                    TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(Interner),\n-                )\n-                .intern(Interner),\n-                Either::Right(id) => GenericArgData::Const(\n-                    ConstData {\n-                        value: ConstValue::BoundVar(BoundVar::new(debruijn, idx)),\n-                        ty: db.const_param_ty(id),\n-                    }\n-                    .intern(Interner),\n-                )\n-                .intern(Interner),\n+                Either::Left(_) => BoundVar::new(debruijn, idx).to_ty(Interner).cast(Interner),\n+                Either::Right(id) => BoundVar::new(debruijn, idx)\n+                    .to_const(Interner, db.const_param_ty(id))\n+                    .cast(Interner),\n             }),\n         )\n     }\n@@ -316,18 +297,12 @@ impl Generics {\n         Substitution::from_iter(\n             Interner,\n             self.iter_id().map(|id| match id {\n-                Either::Left(id) => GenericArgData::Ty(\n-                    TyKind::Placeholder(crate::to_placeholder_idx(db, id.into())).intern(Interner),\n-                )\n-                .intern(Interner),\n-                Either::Right(id) => GenericArgData::Const(\n-                    ConstData {\n-                        value: ConstValue::Placeholder(crate::to_placeholder_idx(db, id.into())),\n-                        ty: db.const_param_ty(id),\n-                    }\n-                    .intern(Interner),\n-                )\n-                .intern(Interner),\n+                Either::Left(id) => {\n+                    crate::to_placeholder_idx(db, id.into()).to_ty(Interner).cast(Interner)\n+                }\n+                Either::Right(id) => crate::to_placeholder_idx(db, id.into())\n+                    .to_const(Interner, db.const_param_ty(id))\n+                    .cast(Interner),\n             }),\n         )\n     }"}, {"sha": "e1418de3cdc24df1169a748178272863b1641565", "filename": "crates/hir/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -13,9 +13,9 @@ doctest = false\n rustc-hash = \"1.1.0\"\n either = \"1.7.0\"\n arrayvec = \"0.7.2\"\n-itertools = \"0.10.3\"\n-smallvec = \"1.9.0\"\n-once_cell = \"1.12.0\"\n+itertools = \"0.10.5\"\n+smallvec = \"1.10.0\"\n+once_cell = \"1.15.0\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "6c8b3088adc0f1c56779c651136d18d06fea5712", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -1,12 +1,12 @@\n //! Re-export diagnostics such that clients of `hir` don't have to depend on\n //! low-level crates.\n //!\n-//! This probably isn't the best way to do this -- ideally, diagnistics should\n+//! This probably isn't the best way to do this -- ideally, diagnostics should\n //! be expressed in terms of hir types themselves.\n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n-use hir_def::path::ModPath;\n+use hir_def::{path::ModPath, TraitId};\n use hir_expand::{name::Name, HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n@@ -33,13 +33,15 @@ diagnostics![\n     BreakOutsideOfLoop,\n     InactiveCode,\n     IncorrectCase,\n+    IncorrectTryExpr,\n     InvalidDeriveTarget,\n     MacroError,\n     MalformedDerive,\n     MismatchedArgCount,\n     MissingFields,\n     MissingMatchArms,\n     MissingUnsafe,\n+    NotImplemented,\n     NoSuchField,\n     ReplaceFilterMapNextWithFindMap,\n     TypeMismatch,\n@@ -153,6 +155,16 @@ pub struct MismatchedArgCount {\n     pub expected: usize,\n     pub found: usize,\n }\n+#[derive(Debug)]\n+pub struct IncorrectTryExpr {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+}\n+#[derive(Debug)]\n+pub struct NotImplemented {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub trait_: TraitId,\n+    pub ty: Type,\n+}\n \n #[derive(Debug)]\n pub struct MissingMatchArms {"}, {"sha": "27b2f445d73cabfb415cf8d7b5625569e6355767", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -492,6 +492,9 @@ impl HirDisplay for TypeAlias {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         let data = f.db.type_alias_data(self.id);\n         write!(f, \"type {}\", data.name)?;\n+        let def_id = GenericDefId::TypeAliasId(self.id);\n+        write_generic_params(def_id, f)?;\n+        write_where_clause(def_id, f)?;\n         if !data.bounds.is_empty() {\n             f.write_str(\": \")?;\n             f.write_joined(&data.bounds, \" + \")?;"}, {"sha": "f825a72c0f58a63998d2cc32aca59b4727b02dba", "filename": "crates/hir/src/from_id.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Ffrom_id.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -140,6 +140,7 @@ impl From<DefWithBody> for DefWithBodyId {\n             DefWithBody::Function(it) => DefWithBodyId::FunctionId(it.id),\n             DefWithBody::Static(it) => DefWithBodyId::StaticId(it.id),\n             DefWithBody::Const(it) => DefWithBodyId::ConstId(it.id),\n+            DefWithBody::Variant(it) => DefWithBodyId::VariantId(it.into()),\n         }\n     }\n }\n@@ -150,6 +151,7 @@ impl From<DefWithBodyId> for DefWithBody {\n             DefWithBodyId::FunctionId(it) => DefWithBody::Function(it.into()),\n             DefWithBodyId::StaticId(it) => DefWithBody::Static(it.into()),\n             DefWithBodyId::ConstId(it) => DefWithBody::Const(it.into()),\n+            DefWithBodyId::VariantId(it) => DefWithBody::Variant(it.into()),\n         }\n     }\n }\n@@ -172,9 +174,7 @@ impl From<GenericDef> for GenericDefId {\n             GenericDef::Trait(it) => GenericDefId::TraitId(it.id),\n             GenericDef::TypeAlias(it) => GenericDefId::TypeAliasId(it.id),\n             GenericDef::Impl(it) => GenericDefId::ImplId(it.id),\n-            GenericDef::Variant(it) => {\n-                GenericDefId::EnumVariantId(EnumVariantId { parent: it.parent.id, local_id: it.id })\n-            }\n+            GenericDef::Variant(it) => GenericDefId::EnumVariantId(it.into()),\n             GenericDef::Const(it) => GenericDefId::ConstId(it.id),\n         }\n     }\n@@ -188,9 +188,7 @@ impl From<GenericDefId> for GenericDef {\n             GenericDefId::TraitId(it) => GenericDef::Trait(it.into()),\n             GenericDefId::TypeAliasId(it) => GenericDef::TypeAlias(it.into()),\n             GenericDefId::ImplId(it) => GenericDef::Impl(it.into()),\n-            GenericDefId::EnumVariantId(it) => {\n-                GenericDef::Variant(Variant { parent: it.parent.into(), id: it.local_id })\n-            }\n+            GenericDefId::EnumVariantId(it) => GenericDef::Variant(it.into()),\n             GenericDefId::ConstId(it) => GenericDef::Const(it.into()),\n         }\n     }"}, {"sha": "e6c5c6b5833980eaf9f8679fc5945c9ee3ec18dd", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 122, "deletions": 24, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -39,7 +39,7 @@ use arrayvec::ArrayVec;\n use base_db::{CrateDisplayName, CrateId, CrateOrigin, Edition, FileId, ProcMacroKind};\n use either::Either;\n use hir_def::{\n-    adt::{ReprKind, VariantData},\n+    adt::{ReprData, VariantData},\n     body::{BodyDiagnostic, SyntheticSyntax},\n     expr::{BindingAnnotation, LabelId, Pat, PatId},\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n@@ -50,7 +50,7 @@ use hir_def::{\n     resolver::{HasResolver, Resolver},\n     src::HasSource as _,\n     AdtId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId, DefWithBodyId, EnumId,\n-    FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n+    EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n     LocalEnumVariantId, LocalFieldId, Lookup, MacroExpander, MacroId, ModuleId, StaticId, StructId,\n     TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId,\n };\n@@ -61,7 +61,6 @@ use hir_ty::{\n     diagnostics::BodyValidationDiagnostic,\n     method_resolution::{self, TyFingerprint},\n     primitive::UintTy,\n-    subst_prefix,\n     traits::FnTrait,\n     AliasTy, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast, ClosureId,\n     GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar, Substitution,\n@@ -73,7 +72,7 @@ use once_cell::unsync::Lazy;\n use rustc_hash::FxHashSet;\n use stdx::{impl_from, never};\n use syntax::{\n-    ast::{self, HasAttrs as _, HasDocComments, HasName},\n+    ast::{self, Expr, HasAttrs as _, HasDocComments, HasName},\n     AstNode, AstPtr, SmolStr, SyntaxNodePtr, TextRange, T,\n };\n \n@@ -82,11 +81,12 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InvalidDeriveTarget,\n-        MacroError, MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms,\n-        MissingUnsafe, NoSuchField, ReplaceFilterMapNextWithFindMap, TypeMismatch,\n-        UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n-        UnresolvedModule, UnresolvedProcMacro,\n+        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, IncorrectTryExpr,\n+        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n+        MissingMatchArms, MissingUnsafe, NoSuchField, NotImplemented,\n+        ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n+        UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n+        UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -348,7 +348,10 @@ impl ModuleDef {\n             ModuleDef::Module(it) => it.id.into(),\n             ModuleDef::Const(it) => it.id.into(),\n             ModuleDef::Static(it) => it.id.into(),\n-            _ => return Vec::new(),\n+            ModuleDef::Variant(it) => {\n+                EnumVariantId { parent: it.parent.into(), local_id: it.id }.into()\n+            }\n+            ModuleDef::BuiltinType(_) | ModuleDef::Macro(_) => return Vec::new(),\n         };\n \n         let module = match self.module(db) {\n@@ -377,10 +380,10 @@ impl ModuleDef {\n             ModuleDef::Function(it) => Some(it.into()),\n             ModuleDef::Const(it) => Some(it.into()),\n             ModuleDef::Static(it) => Some(it.into()),\n+            ModuleDef::Variant(it) => Some(it.into()),\n \n             ModuleDef::Module(_)\n             | ModuleDef::Adt(_)\n-            | ModuleDef::Variant(_)\n             | ModuleDef::Trait(_)\n             | ModuleDef::TypeAlias(_)\n             | ModuleDef::Macro(_)\n@@ -537,6 +540,30 @@ impl Module {\n                     }\n                     acc.extend(decl.diagnostics(db))\n                 }\n+                ModuleDef::Adt(adt) => {\n+                    match adt {\n+                        Adt::Struct(s) => {\n+                            for diag in db.struct_data_with_diagnostics(s.id).1.iter() {\n+                                emit_def_diagnostic(db, acc, diag);\n+                            }\n+                        }\n+                        Adt::Union(u) => {\n+                            for diag in db.union_data_with_diagnostics(u.id).1.iter() {\n+                                emit_def_diagnostic(db, acc, diag);\n+                            }\n+                        }\n+                        Adt::Enum(e) => {\n+                            for v in e.variants(db) {\n+                                acc.extend(ModuleDef::Variant(v).diagnostics(db));\n+                            }\n+\n+                            for diag in db.enum_data_with_diagnostics(e.id).1.iter() {\n+                                emit_def_diagnostic(db, acc, diag);\n+                            }\n+                        }\n+                    }\n+                    acc.extend(decl.diagnostics(db))\n+                }\n                 _ => acc.extend(decl.diagnostics(db)),\n             }\n         }\n@@ -874,7 +901,7 @@ impl Struct {\n         Type::from_def(db, self.id)\n     }\n \n-    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprKind> {\n+    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprData> {\n         db.struct_data(self.id).repr.clone()\n     }\n \n@@ -952,6 +979,21 @@ impl Enum {\n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n         Type::from_def(db, self.id)\n     }\n+\n+    /// The type of the enum variant bodies.\n+    pub fn variant_body_ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::new_for_crate(\n+            self.id.lookup(db.upcast()).container.krate(),\n+            TyBuilder::builtin(match db.enum_data(self.id).variant_body_type() {\n+                Either::Left(builtin) => hir_def::builtin_type::BuiltinType::Int(builtin),\n+                Either::Right(builtin) => hir_def::builtin_type::BuiltinType::Uint(builtin),\n+            }),\n+        )\n+    }\n+\n+    pub fn is_data_carrying(self, db: &dyn HirDatabase) -> bool {\n+        self.variants(db).iter().any(|v| !matches!(v.kind(db), StructKind::Unit))\n+    }\n }\n \n impl HasVisibility for Enum {\n@@ -960,6 +1002,12 @@ impl HasVisibility for Enum {\n     }\n }\n \n+impl From<&Variant> for DefWithBodyId {\n+    fn from(&v: &Variant) -> Self {\n+        DefWithBodyId::VariantId(v.into())\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Variant {\n     pub(crate) parent: Enum,\n@@ -994,6 +1042,14 @@ impl Variant {\n     pub(crate) fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n         db.enum_data(self.parent.id).variants[self.id].variant_data.clone()\n     }\n+\n+    pub fn value(self, db: &dyn HirDatabase) -> Option<Expr> {\n+        self.source(db)?.value.expr()\n+    }\n+\n+    pub fn eval(self, db: &dyn HirDatabase) -> Result<ComputedExpr, ConstEvalError> {\n+        db.const_eval_variant(self.into())\n+    }\n }\n \n /// Variants inherit visibility from the parent enum.\n@@ -1034,7 +1090,7 @@ impl Adt {\n     pub fn ty_with_args(self, db: &dyn HirDatabase, args: &[Type]) -> Type {\n         let id = AdtId::from(self);\n         let mut it = args.iter().map(|t| t.ty.clone());\n-        let ty = TyBuilder::def_ty(db, id.into())\n+        let ty = TyBuilder::def_ty(db, id.into(), None)\n             .fill(|x| {\n                 let r = it.next().unwrap_or_else(|| TyKind::Error.intern(Interner));\n                 match x {\n@@ -1129,15 +1185,17 @@ pub enum DefWithBody {\n     Function(Function),\n     Static(Static),\n     Const(Const),\n+    Variant(Variant),\n }\n-impl_from!(Function, Const, Static for DefWithBody);\n+impl_from!(Function, Const, Static, Variant for DefWithBody);\n \n impl DefWithBody {\n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n         match self {\n             DefWithBody::Const(c) => c.module(db),\n             DefWithBody::Function(f) => f.module(db),\n             DefWithBody::Static(s) => s.module(db),\n+            DefWithBody::Variant(v) => v.module(db),\n         }\n     }\n \n@@ -1146,6 +1204,7 @@ impl DefWithBody {\n             DefWithBody::Function(f) => Some(f.name(db)),\n             DefWithBody::Static(s) => Some(s.name(db)),\n             DefWithBody::Const(c) => c.name(db),\n+            DefWithBody::Variant(v) => Some(v.name(db)),\n         }\n     }\n \n@@ -1155,6 +1214,7 @@ impl DefWithBody {\n             DefWithBody::Function(it) => it.ret_type(db),\n             DefWithBody::Static(it) => it.ty(db),\n             DefWithBody::Const(it) => it.ty(db),\n+            DefWithBody::Variant(it) => it.parent.variant_body_ty(db),\n         }\n     }\n \n@@ -1163,6 +1223,7 @@ impl DefWithBody {\n             DefWithBody::Function(it) => it.id.into(),\n             DefWithBody::Static(it) => it.id.into(),\n             DefWithBody::Const(it) => it.id.into(),\n+            DefWithBody::Variant(it) => it.into(),\n         }\n     }\n \n@@ -1222,30 +1283,45 @@ impl DefWithBody {\n         let infer = db.infer(self.into());\n         let source_map = Lazy::new(|| db.body_with_source_map(self.into()).1);\n         for d in &infer.diagnostics {\n-            match d {\n+            match *d {\n                 hir_ty::InferenceDiagnostic::NoSuchField { expr } => {\n-                    let field = source_map.field_syntax(*expr);\n+                    let field = source_map.field_syntax(expr);\n                     acc.push(NoSuchField { field }.into())\n                 }\n-                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break } => {\n+                hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break } => {\n                     let expr = source_map\n                         .expr_syntax(expr)\n                         .expect(\"break outside of loop in synthetic syntax\");\n                     acc.push(BreakOutsideOfLoop { expr, is_break }.into())\n                 }\n                 hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n-                    match source_map.expr_syntax(*call_expr) {\n+                    match source_map.expr_syntax(call_expr) {\n                         Ok(source_ptr) => acc.push(\n                             MismatchedArgCount {\n                                 call_expr: source_ptr,\n-                                expected: *expected,\n-                                found: *found,\n+                                expected: expected,\n+                                found: found,\n                             }\n                             .into(),\n                         ),\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }\n+                hir_ty::InferenceDiagnostic::IncorrectTryTarget { expr } => {\n+                    let expr = source_map.expr_syntax(expr).expect(\"try in synthetic syntax\");\n+                    acc.push(IncorrectTryExpr { expr }.into())\n+                }\n+                hir_ty::InferenceDiagnostic::DoesNotImplement { expr, trait_, ref ty } => {\n+                    let expr = source_map.expr_syntax(expr).expect(\"try in synthetic syntax\");\n+                    acc.push(\n+                        NotImplemented {\n+                            expr,\n+                            trait_,\n+                            ty: Type::new(db, DefWithBodyId::from(self), ty.clone()),\n+                        }\n+                        .into(),\n+                    )\n+                }\n             }\n         }\n         for (expr, mismatch) in infer.expr_type_mismatches() {\n@@ -1379,6 +1455,7 @@ impl DefWithBody {\n             DefWithBody::Function(it) => it.into(),\n             DefWithBody::Static(it) => it.into(),\n             DefWithBody::Const(it) => it.into(),\n+            DefWithBody::Variant(it) => it.into(),\n         };\n         for diag in hir_ty::diagnostics::incorrect_case(db, krate, def.into()) {\n             acc.push(diag.into())\n@@ -2485,7 +2562,7 @@ impl TypeParam {\n         let resolver = self.id.parent().resolver(db.upcast());\n         let ty = params.get(local_idx)?.clone();\n         let subst = TyBuilder::placeholder_subst(db, self.id.parent());\n-        let ty = ty.substitute(Interner, &subst_prefix(&subst, local_idx));\n+        let ty = ty.substitute(Interner, &subst);\n         match ty.data(Interner) {\n             GenericArgData::Ty(x) => Some(Type::new_with_resolver_inner(db, &resolver, x.clone())),\n             _ => None,\n@@ -2739,7 +2816,22 @@ impl Type {\n     }\n \n     fn from_def(db: &dyn HirDatabase, def: impl HasResolver + Into<TyDefId>) -> Type {\n-        let ty = TyBuilder::def_ty(db, def.into()).fill_with_unknown().build();\n+        let ty_def = def.into();\n+        let parent_subst = match ty_def {\n+            TyDefId::TypeAliasId(id) => match id.lookup(db.upcast()).container {\n+                ItemContainerId::TraitId(id) => {\n+                    let subst = TyBuilder::subst_for_def(db, id, None).fill_with_unknown().build();\n+                    Some(subst)\n+                }\n+                ItemContainerId::ImplId(id) => {\n+                    let subst = TyBuilder::subst_for_def(db, id, None).fill_with_unknown().build();\n+                    Some(subst)\n+                }\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+        let ty = TyBuilder::def_ty(db, ty_def, parent_subst).fill_with_unknown().build();\n         Type::new(db, def, ty)\n     }\n \n@@ -2879,7 +2971,11 @@ impl Type {\n         alias: TypeAlias,\n     ) -> Option<Type> {\n         let mut args = args.iter();\n-        let projection = TyBuilder::assoc_type_projection(db, alias.id)\n+        let trait_id = match alias.id.lookup(db.upcast()).container {\n+            ItemContainerId::TraitId(id) => id,\n+            _ => unreachable!(\"non assoc type alias reached in normalize_trait_assoc_type()\"),\n+        };\n+        let parent_subst = TyBuilder::subst_for_def(db, trait_id, None)\n             .push(self.ty.clone())\n             .fill(|x| {\n                 // FIXME: this code is not covered in tests.\n@@ -2891,6 +2987,8 @@ impl Type {\n                 }\n             })\n             .build();\n+        // FIXME: We don't handle GATs yet.\n+        let projection = TyBuilder::assoc_type_projection(db, alias.id, Some(parent_subst)).build();\n \n         let ty = db.normalize_projection(projection, self.env.clone());\n         if ty.is_unknown() {\n@@ -2940,7 +3038,7 @@ impl Type {\n \n         let adt = adt_id.into();\n         match adt {\n-            Adt::Struct(s) => matches!(s.repr(db), Some(ReprKind::Packed)),\n+            Adt::Struct(s) => matches!(s.repr(db), Some(ReprData { packed: true, .. })),\n             _ => false,\n         }\n     }"}, {"sha": "119ec3210e175b0ca417420c3c480f57805b9156", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -257,6 +257,11 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn original_ast_node<N: AstNode>(&self, node: N) -> Option<N> {\n         self.imp.original_ast_node(node)\n     }\n+    /// Attempts to map the node out of macro expanded files.\n+    /// This only work for attribute expansions, as other ones do not have nodes as input.\n+    pub fn original_syntax_node(&self, node: &SyntaxNode) -> Option<SyntaxNode> {\n+        self.imp.original_syntax_node(node)\n+    }\n \n     pub fn diagnostics_display_range(&self, diagnostics: InFile<SyntaxNodePtr>) -> FileRange {\n         self.imp.diagnostics_display_range(diagnostics)\n@@ -956,6 +961,16 @@ impl<'db> SemanticsImpl<'db> {\n         )\n     }\n \n+    fn original_syntax_node(&self, node: &SyntaxNode) -> Option<SyntaxNode> {\n+        let InFile { file_id, .. } = self.find_file(node);\n+        InFile::new(file_id, node).original_syntax_node(self.db.upcast()).map(\n+            |InFile { file_id, value }| {\n+                self.cache(find_root(&value), file_id);\n+                value\n+            },\n+        )\n+    }\n+\n     fn diagnostics_display_range(&self, src: InFile<SyntaxNodePtr>) -> FileRange {\n         let root = self.parse_or_expand(src.file_id).unwrap();\n         let node = src.map(|it| it.to_node(&root));"}, {"sha": "fa45e3c12eb009b37a00aaf71ad95d94993897f3", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -115,7 +115,7 @@ pub(super) struct SourceToDefCtx<'a, 'b> {\n }\n \n impl SourceToDefCtx<'_, '_> {\n-    pub(super) fn file_to_def(&mut self, file: FileId) -> SmallVec<[ModuleId; 1]> {\n+    pub(super) fn file_to_def(&self, file: FileId) -> SmallVec<[ModuleId; 1]> {\n         let _p = profile::span(\"SourceBinder::to_module_def\");\n         let mut mods = SmallVec::new();\n         for &crate_id in self.db.relevant_crates(file).iter() {\n@@ -130,7 +130,7 @@ impl SourceToDefCtx<'_, '_> {\n         mods\n     }\n \n-    pub(super) fn module_to_def(&mut self, src: InFile<ast::Module>) -> Option<ModuleId> {\n+    pub(super) fn module_to_def(&self, src: InFile<ast::Module>) -> Option<ModuleId> {\n         let _p = profile::span(\"module_to_def\");\n         let parent_declaration = src\n             .syntax()\n@@ -151,7 +151,7 @@ impl SourceToDefCtx<'_, '_> {\n         Some(def_map.module_id(child_id))\n     }\n \n-    pub(super) fn source_file_to_def(&mut self, src: InFile<ast::SourceFile>) -> Option<ModuleId> {\n+    pub(super) fn source_file_to_def(&self, src: InFile<ast::SourceFile>) -> Option<ModuleId> {\n         let _p = profile::span(\"source_file_to_def\");\n         let file_id = src.file_id.original_file(self.db.upcast());\n         self.file_to_def(file_id).get(0).copied()\n@@ -384,7 +384,7 @@ impl SourceToDefCtx<'_, '_> {\n         } else {\n             let it = ast::Variant::cast(container.value)?;\n             let def = self.enum_variant_to_def(InFile::new(container.file_id, it))?;\n-            VariantId::from(def).into()\n+            DefWithBodyId::from(def).into()\n         };\n         Some(cont)\n     }"}, {"sha": "07bae2b38c796b3ee6698ae09785e61e71bcf7a9", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -22,7 +22,7 @@ use hir_def::{\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     type_ref::Mutability,\n     AsMacroCall, AssocItemId, DefWithBodyId, FieldId, FunctionId, ItemContainerId, LocalFieldId,\n-    Lookup, ModuleDefId, VariantId,\n+    Lookup, ModuleDefId, TraitId, VariantId,\n };\n use hir_expand::{\n     builtin_fn_macro::BuiltinFnLikeExpander,\n@@ -302,10 +302,15 @@ impl SourceAnalyzer {\n             }\n         }\n \n+        let future_trait = db\n+            .lang_item(self.resolver.krate(), hir_expand::name![future_trait].to_smol_str())?\n+            .as_trait()?;\n         let poll_fn = db\n             .lang_item(self.resolver.krate(), hir_expand::name![poll].to_smol_str())?\n             .as_function()?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, poll_fn).push(ty.clone()).build();\n+        // HACK: subst for `poll()` coincides with that for `Future` because `poll()` itself\n+        // doesn't have any generic parameters, so we skip building another subst for `poll()`.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, future_trait, None).push(ty).build();\n         Some(self.resolve_impl_method_or_trait_def(db, poll_fn, &substs))\n     }\n \n@@ -321,8 +326,10 @@ impl SourceAnalyzer {\n         };\n         let ty = self.ty_of_expr(db, &prefix_expr.expr()?.into())?;\n \n-        let op_fn = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+        let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        // HACK: subst for all methods coincides with that for their trait because the methods\n+        // don't have any generic parameters, so we skip building another subst for the methods.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n         Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n@@ -337,8 +344,10 @@ impl SourceAnalyzer {\n \n         let lang_item_name = name![index];\n \n-        let op_fn = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn)\n+        let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        // HACK: subst for all methods coincides with that for their trait because the methods\n+        // don't have any generic parameters, so we skip building another subst for the methods.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None)\n             .push(base_ty.clone())\n             .push(index_ty.clone())\n             .build();\n@@ -354,10 +363,14 @@ impl SourceAnalyzer {\n         let lhs = self.ty_of_expr(db, &binop_expr.lhs()?.into())?;\n         let rhs = self.ty_of_expr(db, &binop_expr.rhs()?.into())?;\n \n-        let op_fn = lang_names_for_bin_op(op)\n+        let (op_trait, op_fn) = lang_names_for_bin_op(op)\n             .and_then(|(name, lang_item)| self.lang_trait_fn(db, &lang_item, &name))?;\n-        let substs =\n-            hir_ty::TyBuilder::subst_for_def(db, op_fn).push(lhs.clone()).push(rhs.clone()).build();\n+        // HACK: subst for `index()` coincides with that for `Index` because `index()` itself\n+        // doesn't have any generic parameters, so we skip building another subst for `index()`.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None)\n+            .push(lhs.clone())\n+            .push(rhs.clone())\n+            .build();\n \n         Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n@@ -371,7 +384,13 @@ impl SourceAnalyzer {\n \n         let op_fn =\n             db.lang_item(self.resolver.krate(), name![branch].to_smol_str())?.as_function()?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+        let op_trait = match op_fn.lookup(db.upcast()).container {\n+            ItemContainerId::TraitId(id) => id,\n+            _ => return None,\n+        };\n+        // HACK: subst for `branch()` coincides with that for `Try` because `branch()` itself\n+        // doesn't have any generic parameters, so we skip building another subst for `branch()`.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n         Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n@@ -799,9 +818,10 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         lang_trait: &Name,\n         method_name: &Name,\n-    ) -> Option<FunctionId> {\n-        db.trait_data(db.lang_item(self.resolver.krate(), lang_trait.to_smol_str())?.as_trait()?)\n-            .method_by_name(method_name)\n+    ) -> Option<(TraitId, FunctionId)> {\n+        let trait_id = db.lang_item(self.resolver.krate(), lang_trait.to_smol_str())?.as_trait()?;\n+        let fn_id = db.trait_data(trait_id).method_by_name(method_name)?;\n+        Some((trait_id, fn_id))\n     }\n \n     fn ty_of_expr(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<&Ty> {"}, {"sha": "fd78decda4e648b4373d86d2a6c2de5233d4de76", "filename": "crates/hir/src/symbols.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fhir%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsymbols.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -244,6 +244,10 @@ impl<'a> SymbolCollector<'a> {\n             DefWithBodyId::ConstId(id) => Some(\n                 id.lookup(self.db.upcast()).source(self.db.upcast()).value.name()?.text().into(),\n             ),\n+            DefWithBodyId::VariantId(id) => Some({\n+                let db = self.db.upcast();\n+                id.parent.lookup(db).source(db).value.name()?.text().into()\n+            }),\n         }\n     }\n "}, {"sha": "57a41f3d9a9378faa7c03994b83e53be9fdfc229", "filename": "crates/ide-assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -12,7 +12,7 @@ doctest = false\n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n \n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n either = \"1.7.0\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "678dc877d1381c69028953ac882dedc9d606b1e1", "filename": "crates/ide-assists/src/handlers/auto_import.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -156,6 +156,8 @@ pub(super) fn find_importable_node(\n     {\n         ImportAssets::for_method_call(&method_under_caret, &ctx.sema)\n             .zip(Some(method_under_caret.syntax().clone().into()))\n+    } else if let Some(_) = ctx.find_node_at_offset_with_descend::<ast::Param>() {\n+        None\n     } else if let Some(pat) = ctx\n         .find_node_at_offset_with_descend::<ast::IdentPat>()\n         .filter(ast::IdentPat::is_simple_ident)\n@@ -268,6 +270,20 @@ mod tests {\n         assert_eq!(labels, order);\n     }\n \n+    #[test]\n+    fn ignore_parameter_name() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            mod foo {\n+                pub mod bar {}\n+            }\n+\n+            fn foo(bar$0: &str) {}\n+            \",\n+        );\n+    }\n+\n     #[test]\n     fn prefer_shorter_paths() {\n         let before = r\""}, {"sha": "8d11e0bac9413f24b8dcfbc72faff73e0bd602ef", "filename": "crates/ide-assists/src/handlers/convert_named_struct_to_tuple_struct.rs", "status": "added", "additions": 822, "deletions": 0, "changes": 822, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -0,0 +1,822 @@\n+use either::Either;\n+use ide_db::defs::Definition;\n+use itertools::Itertools;\n+use syntax::{\n+    ast::{self, AstNode, HasGenericParams, HasVisibility},\n+    match_ast, SyntaxKind, SyntaxNode,\n+};\n+\n+use crate::{assist_context::SourceChangeBuilder, AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: convert_named_struct_to_tuple_struct\n+//\n+// Converts struct with named fields to tuple struct, and analogously for enum variants with named\n+// fields.\n+//\n+// ```\n+// struct Point$0 { x: f32, y: f32 }\n+//\n+// impl Point {\n+//     pub fn new(x: f32, y: f32) -> Self {\n+//         Point { x, y }\n+//     }\n+//\n+//     pub fn x(&self) -> f32 {\n+//         self.x\n+//     }\n+//\n+//     pub fn y(&self) -> f32 {\n+//         self.y\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// struct Point(f32, f32);\n+//\n+// impl Point {\n+//     pub fn new(x: f32, y: f32) -> Self {\n+//         Point(x, y)\n+//     }\n+//\n+//     pub fn x(&self) -> f32 {\n+//         self.0\n+//     }\n+//\n+//     pub fn y(&self) -> f32 {\n+//         self.1\n+//     }\n+// }\n+// ```\n+pub(crate) fn convert_named_struct_to_tuple_struct(\n+    acc: &mut Assists,\n+    ctx: &AssistContext<'_>,\n+) -> Option<()> {\n+    let strukt = ctx\n+        .find_node_at_offset::<ast::Struct>()\n+        .map(Either::Left)\n+        .or_else(|| ctx.find_node_at_offset::<ast::Variant>().map(Either::Right))?;\n+    let field_list = strukt.as_ref().either(|s| s.field_list(), |v| v.field_list())?;\n+    let record_fields = match field_list {\n+        ast::FieldList::RecordFieldList(it) => it,\n+        ast::FieldList::TupleFieldList(_) => return None,\n+    };\n+    let strukt_def = match &strukt {\n+        Either::Left(s) => Either::Left(ctx.sema.to_def(s)?),\n+        Either::Right(v) => Either::Right(ctx.sema.to_def(v)?),\n+    };\n+    let target = strukt.as_ref().either(|s| s.syntax(), |v| v.syntax()).text_range();\n+\n+    acc.add(\n+        AssistId(\"convert_named_struct_to_tuple_struct\", AssistKind::RefactorRewrite),\n+        \"Convert to tuple struct\",\n+        target,\n+        |edit| {\n+            edit_field_references(ctx, edit, record_fields.fields());\n+            edit_struct_references(ctx, edit, strukt_def);\n+            edit_struct_def(ctx, edit, &strukt, record_fields);\n+        },\n+    )\n+}\n+\n+fn edit_struct_def(\n+    ctx: &AssistContext<'_>,\n+    edit: &mut SourceChangeBuilder,\n+    strukt: &Either<ast::Struct, ast::Variant>,\n+    record_fields: ast::RecordFieldList,\n+) {\n+    let tuple_fields = record_fields\n+        .fields()\n+        .filter_map(|f| Some(ast::make::tuple_field(f.visibility(), f.ty()?)));\n+    let tuple_fields = ast::make::tuple_field_list(tuple_fields);\n+    let record_fields_text_range = record_fields.syntax().text_range();\n+\n+    edit.edit_file(ctx.file_id());\n+    edit.replace(record_fields_text_range, tuple_fields.syntax().text());\n+\n+    if let Either::Left(strukt) = strukt {\n+        if let Some(w) = strukt.where_clause() {\n+            let mut where_clause = w.to_string();\n+            if where_clause.ends_with(',') {\n+                where_clause.pop();\n+            }\n+            where_clause.push(';');\n+\n+            edit.delete(w.syntax().text_range());\n+            edit.insert(record_fields_text_range.end(), ast::make::tokens::single_newline().text());\n+            edit.insert(record_fields_text_range.end(), where_clause);\n+            edit.insert(record_fields_text_range.end(), ast::make::tokens::single_newline().text());\n+\n+            if let Some(tok) = strukt\n+                .generic_param_list()\n+                .and_then(|l| l.r_angle_token())\n+                .and_then(|tok| tok.next_token())\n+                .filter(|tok| tok.kind() == SyntaxKind::WHITESPACE)\n+            {\n+                edit.delete(tok.text_range());\n+            }\n+        } else {\n+            edit.insert(record_fields_text_range.end(), \";\");\n+        }\n+    }\n+\n+    if let Some(tok) = record_fields\n+        .l_curly_token()\n+        .and_then(|tok| tok.prev_token())\n+        .filter(|tok| tok.kind() == SyntaxKind::WHITESPACE)\n+    {\n+        edit.delete(tok.text_range())\n+    }\n+}\n+\n+fn edit_struct_references(\n+    ctx: &AssistContext<'_>,\n+    edit: &mut SourceChangeBuilder,\n+    strukt: Either<hir::Struct, hir::Variant>,\n+) {\n+    let strukt_def = match strukt {\n+        Either::Left(s) => Definition::Adt(hir::Adt::Struct(s)),\n+        Either::Right(v) => Definition::Variant(v),\n+    };\n+    let usages = strukt_def.usages(&ctx.sema).include_self_refs().all();\n+\n+    let edit_node = |edit: &mut SourceChangeBuilder, node: SyntaxNode| -> Option<()> {\n+        match_ast! {\n+            match node {\n+                ast::RecordPat(record_struct_pat) => {\n+                    edit.replace(\n+                        record_struct_pat.syntax().text_range(),\n+                        ast::make::tuple_struct_pat(\n+                            record_struct_pat.path()?,\n+                            record_struct_pat\n+                                .record_pat_field_list()?\n+                                .fields()\n+                                .filter_map(|pat| pat.pat())\n+                        )\n+                        .to_string()\n+                    );\n+                },\n+                ast::RecordExpr(record_expr) => {\n+                    let path = record_expr.path()?;\n+                    let args = record_expr\n+                        .record_expr_field_list()?\n+                        .fields()\n+                        .filter_map(|f| f.expr())\n+                        .join(\", \");\n+\n+                    edit.replace(record_expr.syntax().text_range(), format!(\"{path}({args})\"));\n+                },\n+                _ => return None,\n+            }\n+        }\n+        Some(())\n+    };\n+\n+    for (file_id, refs) in usages {\n+        edit.edit_file(file_id);\n+        for r in refs {\n+            for node in r.name.syntax().ancestors() {\n+                if edit_node(edit, node).is_some() {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn edit_field_references(\n+    ctx: &AssistContext<'_>,\n+    edit: &mut SourceChangeBuilder,\n+    fields: impl Iterator<Item = ast::RecordField>,\n+) {\n+    for (index, field) in fields.enumerate() {\n+        let field = match ctx.sema.to_def(&field) {\n+            Some(it) => it,\n+            None => continue,\n+        };\n+        let def = Definition::Field(field);\n+        let usages = def.usages(&ctx.sema).all();\n+        for (file_id, refs) in usages {\n+            edit.edit_file(file_id);\n+            for r in refs {\n+                if let Some(name_ref) = r.name.as_name_ref() {\n+                    // Only edit the field reference if it's part of a `.field` access\n+                    if name_ref.syntax().parent().and_then(ast::FieldExpr::cast).is_some() {\n+                        edit.replace(name_ref.syntax().text_range(), index.to_string());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn not_applicable_other_than_record_struct() {\n+        check_assist_not_applicable(convert_named_struct_to_tuple_struct, r#\"struct Foo$0(u32)\"#);\n+        check_assist_not_applicable(convert_named_struct_to_tuple_struct, r#\"struct Foo$0;\"#);\n+    }\n+\n+    #[test]\n+    fn convert_simple_struct() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner;\n+struct A$0 { inner: Inner }\n+\n+impl A {\n+    fn new(inner: Inner) -> A {\n+        A { inner }\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.inner\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A(Inner);\n+\n+impl A {\n+    fn new(inner: Inner) -> A {\n+        A(inner)\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.0\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_referenced_via_self_kw() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner;\n+struct A$0 { inner: Inner }\n+\n+impl A {\n+    fn new(inner: Inner) -> Self {\n+        Self { inner }\n+    }\n+\n+    fn new_with_default() -> Self {\n+        Self::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.inner\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A(Inner);\n+\n+impl A {\n+    fn new(inner: Inner) -> Self {\n+        Self(inner)\n+    }\n+\n+    fn new_with_default() -> Self {\n+        Self::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.0\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_destructured_struct() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner;\n+struct A$0 { inner: Inner }\n+\n+impl A {\n+    fn into_inner(self) -> Inner {\n+        let A { inner: a } = self;\n+        a\n+    }\n+\n+    fn into_inner_via_self(self) -> Inner {\n+        let Self { inner } = self;\n+        inner\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A(Inner);\n+\n+impl A {\n+    fn into_inner(self) -> Inner {\n+        let A(a) = self;\n+        a\n+    }\n+\n+    fn into_inner_via_self(self) -> Inner {\n+        let Self(inner) = self;\n+        inner\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_visibility() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct A$0 {\n+    pub first: u32,\n+    pub(crate) second: u64\n+}\n+\n+impl A {\n+    fn new() -> A {\n+        A { first: 42, second: 42 }\n+    }\n+\n+    fn into_first(self) -> u32 {\n+        self.first\n+    }\n+\n+    fn into_second(self) -> u64 {\n+        self.second\n+    }\n+}\"#,\n+            r#\"\n+struct A(pub u32, pub(crate) u64);\n+\n+impl A {\n+    fn new() -> A {\n+        A(42, 42)\n+    }\n+\n+    fn into_first(self) -> u32 {\n+        self.0\n+    }\n+\n+    fn into_second(self) -> u64 {\n+        self.1\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_wrapped_references() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner$0 { uint: u32 }\n+struct Outer { inner: Inner }\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self { inner: Inner { uint: 42 } }\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        self.inner.uint\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer { inner: Inner { uint: x } } = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+struct Inner(u32);\n+struct Outer { inner: Inner }\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self { inner: Inner(42) }\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        self.inner.0\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer { inner: Inner(x) } = self;\n+        x\n+    }\n+}\"#,\n+        );\n+\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner { uint: u32 }\n+struct Outer$0 { inner: Inner }\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self { inner: Inner { uint: 42 } }\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        self.inner.uint\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer { inner: Inner { uint: x } } = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+struct Inner { uint: u32 }\n+struct Outer(Inner);\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self(Inner { uint: 42 })\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        self.0.uint\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer(Inner { uint: x }) = self;\n+        x\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_multi_file_references() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+struct A$0 { inner: Inner }\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A { inner: Inner };\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+struct A(Inner);\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A(Inner);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_where_clause() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Wrap$0<T>\n+where\n+    T: Display,\n+{ field1: T }\n+\"#,\n+            r#\"\n+struct Wrap<T>(T)\n+where\n+    T: Display;\n+\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_other_than_record_variant() {\n+        check_assist_not_applicable(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"enum Enum { Variant$0(usize) };\"#,\n+        );\n+        check_assist_not_applicable(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"enum Enum { Variant$0 }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_simple_variant() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum A {\n+    $0Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        A::Variant { field1: value }\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            A::Variant { field1: value } => value,\n+        }\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant(usize),\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        A::Variant(value)\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            A::Variant(value) => value,\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_referenced_via_self_kw() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum A {\n+    $0Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        Self::Variant { field1: value }\n+    }\n+\n+    fn new_with_default() -> A {\n+        Self::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            Self::Variant { field1: value } => value,\n+        }\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant(usize),\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        Self::Variant(value)\n+    }\n+\n+    fn new_with_default() -> A {\n+        Self::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            Self::Variant(value) => value,\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_destructured_variant() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum A {\n+    $0Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn into_inner(self) -> usize {\n+        let A::Variant { field1: first } = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> usize {\n+        let Self::Variant { field1: first } = self;\n+        first\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant(usize),\n+}\n+\n+impl A {\n+    fn into_inner(self) -> usize {\n+        let A::Variant(first) = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> usize {\n+        let Self::Variant(first) = self;\n+        first\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_with_wrapped_references() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum Inner {\n+    $0Variant { field1: usize },\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant { field1: 42 })\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant { field1: x }) = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant(42))\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant(x)) = self;\n+        x\n+    }\n+}\"#,\n+        );\n+\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    $0Variant { field1: Inner },\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant { field1: Inner::Variant(42) }\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant { field1: Inner::Variant(x) } = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant(42))\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant(x)) = self;\n+        x\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_with_multi_file_references() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    $0Variant { field1: Inner },\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A::Variant { field1: Inner };\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    Variant(Inner),\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A::Variant(Inner);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_directly_used_variant() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    $0Variant { field1: Inner },\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A::Variant, Inner};\n+fn f() {\n+    let a = Variant { field1: Inner };\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    Variant(Inner),\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A::Variant, Inner};\n+fn f() {\n+    let a = Variant(Inner);\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "970e948dfd930f4226be3c9697f0e19dead8d044", "filename": "crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -9,7 +9,7 @@ use ide_db::{\n     search::FileReference,\n     FxHashSet, RootDatabase,\n };\n-use itertools::{Itertools, Position};\n+use itertools::Itertools;\n use syntax::{\n     ast::{\n         self, edit::IndentLevel, edit_in_place::Indent, make, AstNode, HasAttrs, HasGenericParams,\n@@ -298,37 +298,7 @@ fn update_variant(variant: &ast::Variant, generics: Option<ast::GenericParamList\n     let name = variant.name()?;\n     let ty = generics\n         .filter(|generics| generics.generic_params().count() > 0)\n-        .map(|generics| {\n-            let mut generic_str = String::with_capacity(8);\n-\n-            for (p, more) in generics.generic_params().with_position().map(|p| match p {\n-                Position::First(p) | Position::Middle(p) => (p, true),\n-                Position::Last(p) | Position::Only(p) => (p, false),\n-            }) {\n-                match p {\n-                    ast::GenericParam::ConstParam(konst) => {\n-                        if let Some(name) = konst.name() {\n-                            generic_str.push_str(name.text().as_str());\n-                        }\n-                    }\n-                    ast::GenericParam::LifetimeParam(lt) => {\n-                        if let Some(lt) = lt.lifetime() {\n-                            generic_str.push_str(lt.text().as_str());\n-                        }\n-                    }\n-                    ast::GenericParam::TypeParam(ty) => {\n-                        if let Some(name) = ty.name() {\n-                            generic_str.push_str(name.text().as_str());\n-                        }\n-                    }\n-                }\n-                if more {\n-                    generic_str.push_str(\", \");\n-                }\n-            }\n-\n-            make::ty(&format!(\"{}<{}>\", &name.text(), &generic_str))\n-        })\n+        .map(|generics| make::ty(&format!(\"{}{}\", &name.text(), generics.to_generic_args())))\n         .unwrap_or_else(|| make::ty(&name.text()));\n \n     // change from a record to a tuple field list"}, {"sha": "8b67982f9158234b91afa04bf28c691b543b2d10", "filename": "crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 52, "deletions": 61, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -1,4 +1,4 @@\n-use hir::{HasSource, HirDisplay, Module, Semantics, TypeInfo};\n+use hir::{Adt, HasSource, HirDisplay, Module, Semantics, TypeInfo};\n use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameRefClass},\n@@ -145,7 +145,8 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n         return None;\n     }\n     let (impl_, file) = get_adt_source(ctx, &adt, fn_name.text().as_str())?;\n-    let (target, insert_offset) = get_method_target(ctx, &target_module, &impl_)?;\n+    let (target, insert_offset) = get_method_target(ctx, &impl_, &adt)?;\n+\n     let function_builder =\n         FunctionBuilder::from_method_call(ctx, &call, &fn_name, target_module, target)?;\n     let text_range = call.syntax().text_range();\n@@ -174,10 +175,11 @@ fn add_func_to_accumulator(\n     label: String,\n ) -> Option<()> {\n     acc.add(AssistId(\"generate_function\", AssistKind::Generate), label, text_range, |builder| {\n-        let function_template = function_builder.render();\n+        let indent = IndentLevel::from_node(function_builder.target.syntax());\n+        let function_template = function_builder.render(adt_name.is_some());\n         let mut func = function_template.to_string(ctx.config.snippet_cap);\n         if let Some(name) = adt_name {\n-            func = format!(\"\\nimpl {} {{\\n{}\\n}}\", name, func);\n+            func = format!(\"\\n{}impl {} {{\\n{}\\n{}}}\", indent, name, func, indent);\n         }\n         builder.edit_file(file);\n         match ctx.config.snippet_cap {\n@@ -307,7 +309,7 @@ impl FunctionBuilder {\n         })\n     }\n \n-    fn render(self) -> FunctionTemplate {\n+    fn render(self, is_method: bool) -> FunctionTemplate {\n         let placeholder_expr = make::ext::expr_todo();\n         let fn_body = make::block_expr(vec![], Some(placeholder_expr));\n         let visibility = if self.needs_pub { Some(make::visibility_pub_crate()) } else { None };\n@@ -325,8 +327,14 @@ impl FunctionBuilder {\n \n         match self.target {\n             GeneratedFunctionTarget::BehindItem(it) => {\n-                let indent = IndentLevel::from_node(&it);\n-                leading_ws = format!(\"\\n\\n{}\", indent);\n+                let mut indent = IndentLevel::from_node(&it);\n+                if is_method {\n+                    indent = indent + 1;\n+                    leading_ws = format!(\"{}\", indent);\n+                } else {\n+                    leading_ws = format!(\"\\n\\n{}\", indent);\n+                }\n+\n                 fn_def = fn_def.indent(indent);\n                 trailing_ws = String::new();\n             }\n@@ -411,14 +419,13 @@ fn get_fn_target(\n \n fn get_method_target(\n     ctx: &AssistContext<'_>,\n-    target_module: &Module,\n     impl_: &Option<ast::Impl>,\n+    adt: &Adt,\n ) -> Option<(GeneratedFunctionTarget, TextSize)> {\n     let target = match impl_ {\n         Some(impl_) => next_space_for_fn_in_impl(impl_)?,\n         None => {\n-            next_space_for_fn_in_module(ctx.sema.db, &target_module.definition_source(ctx.sema.db))?\n-                .1\n+            GeneratedFunctionTarget::BehindItem(adt.source(ctx.sema.db)?.syntax().value.clone())\n         }\n     };\n     Some((target.clone(), get_insert_offset(&target)))\n@@ -437,7 +444,7 @@ fn assoc_fn_target_info(\n         return None;\n     }\n     let (impl_, file) = get_adt_source(ctx, &adt, fn_name)?;\n-    let (target, insert_offset) = get_method_target(ctx, &module, &impl_)?;\n+    let (target, insert_offset) = get_method_target(ctx, &impl_, &adt)?;\n     let adt_name = if impl_.is_none() { Some(adt.name(ctx.sema.db)) } else { None };\n     Some(TargetInfo::new(target_module, adt_name, target, file, insert_offset))\n }\n@@ -1468,14 +1475,12 @@ fn foo() {S.bar$0();}\n \",\n             r\"\n struct S;\n-fn foo() {S.bar();}\n impl S {\n-\n-\n-fn bar(&self) ${0:-> _} {\n-    todo!()\n-}\n+    fn bar(&self) ${0:-> _} {\n+        todo!()\n+    }\n }\n+fn foo() {S.bar();}\n \",\n         )\n     }\n@@ -1516,14 +1521,12 @@ fn foo() {s::S.bar$0();}\n             r\"\n mod s {\n     pub struct S;\n-impl S {\n-\n-\n-    pub(crate) fn bar(&self) ${0:-> _} {\n-        todo!()\n+    impl S {\n+        pub(crate) fn bar(&self) ${0:-> _} {\n+            todo!()\n+        }\n     }\n }\n-}\n fn foo() {s::S.bar();}\n \",\n         )\n@@ -1544,18 +1547,16 @@ mod s {\n \",\n             r\"\n struct S;\n+impl S {\n+    fn bar(&self) ${0:-> _} {\n+        todo!()\n+    }\n+}\n mod s {\n     fn foo() {\n         super::S.bar();\n     }\n }\n-impl S {\n-\n-\n-fn bar(&self) ${0:-> _} {\n-    todo!()\n-}\n-}\n \n \",\n         )\n@@ -1571,14 +1572,12 @@ fn foo() {$0S.bar();}\n \",\n             r\"\n struct S;\n-fn foo() {S.bar();}\n impl S {\n-\n-\n-fn bar(&self) ${0:-> _} {\n-    todo!()\n-}\n+    fn bar(&self) ${0:-> _} {\n+        todo!()\n+    }\n }\n+fn foo() {S.bar();}\n \",\n         )\n     }\n@@ -1593,14 +1592,12 @@ fn foo() {S::bar$0();}\n \",\n             r\"\n struct S;\n-fn foo() {S::bar();}\n impl S {\n-\n-\n-fn bar() ${0:-> _} {\n-    todo!()\n-}\n+    fn bar() ${0:-> _} {\n+        todo!()\n+    }\n }\n+fn foo() {S::bar();}\n \",\n         )\n     }\n@@ -1641,14 +1638,12 @@ fn foo() {s::S::bar$0();}\n             r\"\n mod s {\n     pub struct S;\n-impl S {\n-\n-\n-    pub(crate) fn bar() ${0:-> _} {\n-        todo!()\n+    impl S {\n+        pub(crate) fn bar() ${0:-> _} {\n+            todo!()\n+        }\n     }\n }\n-}\n fn foo() {s::S::bar();}\n \",\n         )\n@@ -1664,14 +1659,12 @@ fn foo() {$0S::bar();}\n \",\n             r\"\n struct S;\n-fn foo() {S::bar();}\n impl S {\n-\n-\n-fn bar() ${0:-> _} {\n-    todo!()\n-}\n+    fn bar() ${0:-> _} {\n+        todo!()\n+    }\n }\n+fn foo() {S::bar();}\n \",\n         )\n     }\n@@ -1841,15 +1834,13 @@ fn main() {\n \",\n             r\"\n enum Foo {}\n-fn main() {\n-    Foo::new();\n-}\n impl Foo {\n-\n-\n-fn new() ${0:-> _} {\n-    todo!()\n+    fn new() ${0:-> _} {\n+        todo!()\n+    }\n }\n+fn main() {\n+    Foo::new();\n }\n \",\n         )"}, {"sha": "307cea3d0a4f875aee3a92d954c133c0688c22c1", "filename": "crates/ide-assists/src/handlers/generate_impl.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -52,6 +52,7 @@ mod tests {\n \n     use super::*;\n \n+    // FIXME: break up into separate test fns\n     #[test]\n     fn test_add_impl() {\n         check_assist(\n@@ -134,6 +135,18 @@ mod tests {\n             }\"#,\n         );\n \n+        check_assist(\n+            generate_impl,\n+            r#\"\n+            struct Defaulted<const N: i32 = 0> {}$0\"#,\n+            r#\"\n+            struct Defaulted<const N: i32 = 0> {}\n+\n+            impl<const N: i32> Defaulted<N> {\n+                $0\n+            }\"#,\n+        );\n+\n         check_assist(\n             generate_impl,\n             r#\"pub trait Trait {}"}, {"sha": "aa710d2ce6513d4c96846a95a0e4836b863cb065", "filename": "crates/ide-assists/src/handlers/move_format_string_arg.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -7,6 +7,7 @@ use ide_db::{\n     },\n };\n use itertools::Itertools;\n+use stdx::format_to;\n use syntax::{ast, AstNode, AstToken, NodeOrToken, SyntaxKind::COMMA, TextRange};\n \n // Assist: move_format_string_arg\n@@ -78,20 +79,26 @@ pub(crate) fn move_format_string_arg(acc: &mut Assists, ctx: &AssistContext<'_>)\n \n             // Extract existing arguments in macro\n             let tokens =\n-                tt.token_trees_and_tokens().filter_map(NodeOrToken::into_token).collect_vec();\n+                tt.token_trees_and_tokens().collect_vec();\n \n             let mut existing_args: Vec<String> = vec![];\n \n             let mut current_arg = String::new();\n-            if let [_opening_bracket, format_string, _args_start_comma, tokens @ .., end_bracket] =\n+            if let [_opening_bracket, NodeOrToken::Token(format_string), _args_start_comma, tokens @ .., NodeOrToken::Token(end_bracket)] =\n                 tokens.as_slice()\n             {\n                 for t in tokens {\n-                    if t.kind() == COMMA {\n-                        existing_args.push(current_arg.trim().into());\n-                        current_arg.clear();\n-                    } else {\n-                        current_arg.push_str(t.text());\n+                    match t {\n+                        NodeOrToken::Node(n) => {\n+                            format_to!(current_arg, \"{n}\");\n+                        },\n+                        NodeOrToken::Token(t) if t.kind() == COMMA=> {\n+                            existing_args.push(current_arg.trim().into());\n+                            current_arg.clear();\n+                        },\n+                        NodeOrToken::Token(t) => {\n+                            current_arg.push_str(t.text());\n+                        },\n                     }\n                 }\n                 existing_args.push(current_arg.trim().into());\n@@ -261,6 +268,27 @@ fn main() {\n fn main() {\n     print!(\"{} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n }\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn nested_tt() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"My name is {} {x$0 + x}\", stringify!(Paperino))\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"My name is {} {}\"$0, stringify!(Paperino), x + x)\n+}\n \"#,\n             ),\n         );"}, {"sha": "25c58d086e977d71f3711fb2c09d65fdd26df653", "filename": "crates/ide-assists/src/handlers/unwrap_tuple.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_tuple.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -0,0 +1,159 @@\n+use syntax::{\n+    ast::{self, edit::AstNodeEdit},\n+    AstNode, T,\n+};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: unwrap_tuple\n+//\n+// Unwrap the tuple to different variables.\n+//\n+// ```\n+// # //- minicore: result\n+// fn main() {\n+//     $0let (foo, bar) = (\"Foo\", \"Bar\");\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let foo = \"Foo\";\n+//     let bar = \"Bar\";\n+// }\n+// ```\n+pub(crate) fn unwrap_tuple(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let let_kw = ctx.find_token_syntax_at_offset(T![let])?;\n+    let let_stmt = let_kw.parent().and_then(ast::LetStmt::cast)?;\n+    let indent_level = let_stmt.indent_level().0 as usize;\n+    let pat = let_stmt.pat()?;\n+    let ty = let_stmt.ty();\n+    let init = let_stmt.initializer()?;\n+\n+    // This only applies for tuple patterns, types, and initializers.\n+    let tuple_pat = match pat {\n+        ast::Pat::TuplePat(pat) => pat,\n+        _ => return None,\n+    };\n+    let tuple_ty = ty.and_then(|it| match it {\n+        ast::Type::TupleType(ty) => Some(ty),\n+        _ => None,\n+    });\n+    let tuple_init = match init {\n+        ast::Expr::TupleExpr(expr) => expr,\n+        _ => return None,\n+    };\n+\n+    if tuple_pat.fields().count() != tuple_init.fields().count() {\n+        return None;\n+    }\n+    if let Some(tys) = &tuple_ty {\n+        if tuple_pat.fields().count() != tys.fields().count() {\n+            return None;\n+        }\n+    }\n+\n+    let parent = let_kw.parent()?;\n+\n+    acc.add(\n+        AssistId(\"unwrap_tuple\", AssistKind::RefactorRewrite),\n+        \"Unwrap tuple\",\n+        let_kw.text_range(),\n+        |edit| {\n+            let indents = \"    \".repeat(indent_level);\n+\n+            // If there is an ascribed type, insert that type for each declaration,\n+            // otherwise, omit that type.\n+            if let Some(tys) = tuple_ty {\n+                let mut zipped_decls = String::new();\n+                for (pat, ty, expr) in\n+                    itertools::izip!(tuple_pat.fields(), tys.fields(), tuple_init.fields())\n+                {\n+                    zipped_decls.push_str(&format!(\"{}let {pat}: {ty} = {expr};\\n\", indents))\n+                }\n+                edit.replace(parent.text_range(), zipped_decls.trim());\n+            } else {\n+                let mut zipped_decls = String::new();\n+                for (pat, expr) in itertools::izip!(tuple_pat.fields(), tuple_init.fields()) {\n+                    zipped_decls.push_str(&format!(\"{}let {pat} = {expr};\\n\", indents));\n+                }\n+                edit.replace(parent.text_range(), zipped_decls.trim());\n+            }\n+        },\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_assist;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn unwrap_tuples() {\n+        check_assist(\n+            unwrap_tuple,\n+            r#\"\n+fn main() {\n+    $0let (foo, bar) = (\"Foo\", \"Bar\");\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let foo = \"Foo\";\n+    let bar = \"Bar\";\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            unwrap_tuple,\n+            r#\"\n+fn main() {\n+    $0let (foo, bar, baz) = (\"Foo\", \"Bar\", \"Baz\");\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let foo = \"Foo\";\n+    let bar = \"Bar\";\n+    let baz = \"Baz\";\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unwrap_tuple_with_types() {\n+        check_assist(\n+            unwrap_tuple,\n+            r#\"\n+fn main() {\n+    $0let (foo, bar): (u8, i32) = (5, 10);\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let foo: u8 = 5;\n+    let bar: i32 = 10;\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            unwrap_tuple,\n+            r#\"\n+fn main() {\n+    $0let (foo, bar, baz): (u8, i32, f64) = (5, 10, 17.5);\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let foo: u8 = 5;\n+    let bar: i32 = 10;\n+    let baz: f64 = 17.5;\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "a07318cefad273dbdb4410b12a670f06f86107f9", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -121,6 +121,7 @@ mod handlers {\n     mod convert_iter_for_each_to_for;\n     mod convert_let_else_to_match;\n     mod convert_tuple_struct_to_named_struct;\n+    mod convert_named_struct_to_tuple_struct;\n     mod convert_to_guarded_return;\n     mod convert_two_arm_bool_match_to_matches_macro;\n     mod convert_while_to_loop;\n@@ -189,6 +190,7 @@ mod handlers {\n     mod replace_turbofish_with_explicit_type;\n     mod split_import;\n     mod unmerge_match_arm;\n+    mod unwrap_tuple;\n     mod sort_items;\n     mod toggle_ignore;\n     mod unmerge_use;\n@@ -217,6 +219,7 @@ mod handlers {\n             convert_iter_for_each_to_for::convert_iter_for_each_to_for,\n             convert_iter_for_each_to_for::convert_for_loop_with_for_each,\n             convert_let_else_to_match::convert_let_else_to_match,\n+            convert_named_struct_to_tuple_struct::convert_named_struct_to_tuple_struct,\n             convert_to_guarded_return::convert_to_guarded_return,\n             convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n             convert_two_arm_bool_match_to_matches_macro::convert_two_arm_bool_match_to_matches_macro,\n@@ -291,6 +294,7 @@ mod handlers {\n             unnecessary_async::unnecessary_async,\n             unwrap_block::unwrap_block,\n             unwrap_result_return_type::unwrap_result_return_type,\n+            unwrap_tuple::unwrap_tuple,\n             wrap_return_type_in_result::wrap_return_type_in_result,\n             // These are manually sorted for better priorities. By default,\n             // priority is determined by the size of the target range (smaller"}, {"sha": "f7f2417d0745d7a4088ed75a11f7241875bb5663", "filename": "crates/ide-assists/src/tests.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -96,8 +96,10 @@ fn check_doc_test(assist_id: &str, before: &str, after: &str) {\n         });\n \n     let actual = {\n-        let source_change =\n-            assist.source_change.expect(\"Assist did not contain any source changes\");\n+        let source_change = assist\n+            .source_change\n+            .filter(|it| !it.source_file_edits.is_empty() || !it.file_system_edits.is_empty())\n+            .expect(\"Assist did not contain any source changes\");\n         let mut actual = before;\n         if let Some(source_file_edit) = source_change.get_source_edit(file_id) {\n             source_file_edit.apply(&mut actual);\n@@ -140,8 +142,10 @@ fn check(handler: Handler, before: &str, expected: ExpectedResult<'_>, assist_la\n \n     match (assist, expected) {\n         (Some(assist), ExpectedResult::After(after)) => {\n-            let source_change =\n-                assist.source_change.expect(\"Assist did not contain any source changes\");\n+            let source_change = assist\n+                .source_change\n+                .filter(|it| !it.source_file_edits.is_empty() || !it.file_system_edits.is_empty())\n+                .expect(\"Assist did not contain any source changes\");\n             let skip_header = source_change.source_file_edits.len() == 1\n                 && source_change.file_system_edits.len() == 0;\n \n@@ -228,6 +232,7 @@ fn assist_order_field_struct() {\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Generate a getter method\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Generate a mut getter method\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Generate a setter method\");\n+    assert_eq!(assists.next().expect(\"expected assist\").label, \"Convert to tuple struct\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Add `#[derive]`\");\n }\n "}, {"sha": "2c4000efe0fa25a9f0c159d0c5f2f046ab04c9b5", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -407,6 +407,47 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_convert_named_struct_to_tuple_struct() {\n+    check_doc_test(\n+        \"convert_named_struct_to_tuple_struct\",\n+        r#####\"\n+struct Point$0 { x: f32, y: f32 }\n+\n+impl Point {\n+    pub fn new(x: f32, y: f32) -> Self {\n+        Point { x, y }\n+    }\n+\n+    pub fn x(&self) -> f32 {\n+        self.x\n+    }\n+\n+    pub fn y(&self) -> f32 {\n+        self.y\n+    }\n+}\n+\"#####,\n+        r#####\"\n+struct Point(f32, f32);\n+\n+impl Point {\n+    pub fn new(x: f32, y: f32) -> Self {\n+        Point(x, y)\n+    }\n+\n+    pub fn x(&self) -> f32 {\n+        self.0\n+    }\n+\n+    pub fn y(&self) -> f32 {\n+        self.1\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_convert_to_guarded_return() {\n     check_doc_test(\n@@ -2386,6 +2427,25 @@ fn foo() -> i32 { 42i32 }\n     )\n }\n \n+#[test]\n+fn doctest_unwrap_tuple() {\n+    check_doc_test(\n+        \"unwrap_tuple\",\n+        r#####\"\n+//- minicore: result\n+fn main() {\n+    $0let (foo, bar) = (\"Foo\", \"Bar\");\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    let foo = \"Foo\";\n+    let bar = \"Bar\";\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_wrap_return_type_in_result() {\n     check_doc_test("}, {"sha": "38396cd7d7bafd47c36e4d4d473915cdc41f827a", "filename": "crates/ide-assists/src/utils.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -2,8 +2,6 @@\n \n use std::ops;\n \n-use itertools::Itertools;\n-\n pub(crate) use gen_trait_fn_body::gen_trait_fn_body;\n use hir::{db::HirDatabase, HirDisplay, Semantics};\n use ide_db::{famous_defs::FamousDefs, path_transform::PathTransform, RootDatabase, SnippetCap};\n@@ -15,7 +13,7 @@ use syntax::{\n         edit_in_place::{AttrsOwnerEdit, Removable},\n         make, HasArgList, HasAttrs, HasGenericParams, HasName, HasTypeBounds, Whitespace,\n     },\n-    ted, AstNode, AstToken, Direction, SmolStr, SourceFile,\n+    ted, AstNode, AstToken, Direction, SourceFile,\n     SyntaxKind::*,\n     SyntaxNode, TextRange, TextSize, T,\n };\n@@ -424,34 +422,44 @@ pub(crate) fn generate_trait_impl_text(adt: &ast::Adt, trait_text: &str, code: &\n }\n \n fn generate_impl_text_inner(adt: &ast::Adt, trait_text: Option<&str>, code: &str) -> String {\n-    let generic_params = adt.generic_param_list();\n+    // Ensure lifetime params are before type & const params\n+    let generic_params = adt.generic_param_list().map(|generic_params| {\n+        let lifetime_params =\n+            generic_params.lifetime_params().map(ast::GenericParam::LifetimeParam);\n+        let ty_or_const_params = generic_params.type_or_const_params().filter_map(|param| {\n+            // remove defaults since they can't be specified in impls\n+            match param {\n+                ast::TypeOrConstParam::Type(param) => {\n+                    let param = param.clone_for_update();\n+                    param.remove_default();\n+                    Some(ast::GenericParam::TypeParam(param))\n+                }\n+                ast::TypeOrConstParam::Const(param) => {\n+                    let param = param.clone_for_update();\n+                    param.remove_default();\n+                    Some(ast::GenericParam::ConstParam(param))\n+                }\n+            }\n+        });\n+\n+        make::generic_param_list(itertools::chain(lifetime_params, ty_or_const_params))\n+    });\n+\n+    // FIXME: use syntax::make & mutable AST apis instead\n+    // `trait_text` and `code` can't be opaque blobs of text\n     let mut buf = String::with_capacity(code.len());\n+\n+    // Copy any cfg attrs from the original adt\n     buf.push_str(\"\\n\\n\");\n-    adt.attrs()\n-        .filter(|attr| attr.as_simple_call().map(|(name, _arg)| name == \"cfg\").unwrap_or(false))\n-        .for_each(|attr| buf.push_str(format!(\"{}\\n\", attr).as_str()));\n+    let cfg_attrs = adt\n+        .attrs()\n+        .filter(|attr| attr.as_simple_call().map(|(name, _arg)| name == \"cfg\").unwrap_or(false));\n+    cfg_attrs.for_each(|attr| buf.push_str(&format!(\"{attr}\\n\")));\n+\n+    // `impl{generic_params} {trait_text} for {name}{generic_params.to_generic_args()}`\n     buf.push_str(\"impl\");\n     if let Some(generic_params) = &generic_params {\n-        let lifetimes = generic_params.lifetime_params().map(|lt| format!(\"{}\", lt.syntax()));\n-        let toc_params = generic_params.type_or_const_params().map(|toc_param| {\n-            let type_param = match toc_param {\n-                ast::TypeOrConstParam::Type(x) => x,\n-                ast::TypeOrConstParam::Const(x) => return x.syntax().to_string(),\n-            };\n-            let mut buf = String::new();\n-            if let Some(it) = type_param.name() {\n-                format_to!(buf, \"{}\", it.syntax());\n-            }\n-            if let Some(it) = type_param.colon_token() {\n-                format_to!(buf, \"{} \", it);\n-            }\n-            if let Some(it) = type_param.type_bound_list() {\n-                format_to!(buf, \"{}\", it.syntax());\n-            }\n-            buf\n-        });\n-        let generics = lifetimes.chain(toc_params).format(\", \");\n-        format_to!(buf, \"<{}>\", generics);\n+        format_to!(buf, \"{generic_params}\");\n     }\n     buf.push(' ');\n     if let Some(trait_text) = trait_text {\n@@ -460,23 +468,15 @@ fn generate_impl_text_inner(adt: &ast::Adt, trait_text: Option<&str>, code: &str\n     }\n     buf.push_str(&adt.name().unwrap().text());\n     if let Some(generic_params) = generic_params {\n-        let lifetime_params = generic_params\n-            .lifetime_params()\n-            .filter_map(|it| it.lifetime())\n-            .map(|it| SmolStr::from(it.text()));\n-        let toc_params = generic_params\n-            .type_or_const_params()\n-            .filter_map(|it| it.name())\n-            .map(|it| SmolStr::from(it.text()));\n-        format_to!(buf, \"<{}>\", lifetime_params.chain(toc_params).format(\", \"))\n+        format_to!(buf, \"{}\", generic_params.to_generic_args());\n     }\n \n     match adt.where_clause() {\n         Some(where_clause) => {\n-            format_to!(buf, \"\\n{}\\n{{\\n{}\\n}}\", where_clause, code);\n+            format_to!(buf, \"\\n{where_clause}\\n{{\\n{code}\\n}}\");\n         }\n         None => {\n-            format_to!(buf, \" {{\\n{}\\n}}\", code);\n+            format_to!(buf, \" {{\\n{code}\\n}}\");\n         }\n     }\n "}, {"sha": "75835bce95da19749e2b6abfc7416950d04aa6c0", "filename": "crates/ide-completion/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-completion%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-completion%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -11,10 +11,10 @@ doctest = false\n \n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n \n-once_cell = \"1.12.0\"\n-smallvec = \"1.9.0\"\n+once_cell = \"1.15.0\"\n+smallvec = \"1.10.0\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "296dfc14250f75013e748352511adcf8b26ff066", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -19,6 +19,7 @@ pub(crate) mod snippet;\n pub(crate) mod r#type;\n pub(crate) mod use_;\n pub(crate) mod vis;\n+pub(crate) mod env_vars;\n \n use std::iter;\n "}, {"sha": "09e95e53de63ce42f31791d8c092a2772b4e9501", "filename": "crates/ide-completion/src/completions/env_vars.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -0,0 +1,150 @@\n+//! Completes environment variables defined by Cargo (https://doc.rust-lang.org/cargo/reference/environment-variables.html)\n+use hir::Semantics;\n+use ide_db::{syntax_helpers::node_ext::macro_call_for_string_token, RootDatabase};\n+use syntax::ast::{self, IsString};\n+\n+use crate::{\n+    completions::Completions, context::CompletionContext, CompletionItem, CompletionItemKind,\n+};\n+\n+const CARGO_DEFINED_VARS: &[(&str, &str)] = &[\n+    (\"CARGO\",\"Path to the cargo binary performing the build\"),\n+    (\"CARGO_MANIFEST_DIR\",\"The directory containing the manifest of your package\"),\n+    (\"CARGO_PKG_VERSION\",\"The full version of your package\"),\n+    (\"CARGO_PKG_VERSION_MAJOR\",\"The major version of your package\"),\n+    (\"CARGO_PKG_VERSION_MINOR\",\"The minor version of your package\"),\n+    (\"CARGO_PKG_VERSION_PATCH\",\"The patch version of your package\"),\n+    (\"CARGO_PKG_VERSION_PRE\",\"The pre-release version of your package\"),\n+    (\"CARGO_PKG_AUTHORS\",\"Colon separated list of authors from the manifest of your package\"),\n+    (\"CARGO_PKG_NAME\",\"The name of your package\"),\n+    (\"CARGO_PKG_DESCRIPTION\",\"The description from the manifest of your package\"),\n+    (\"CARGO_PKG_HOMEPAGE\",\"The home page from the manifest of your package\"),\n+    (\"CARGO_PKG_REPOSITORY\",\"The repository from the manifest of your package\"),\n+    (\"CARGO_PKG_LICENSE\",\"The license from the manifest of your package\"),\n+    (\"CARGO_PKG_LICENSE_FILE\",\"The license file from the manifest of your package\"),\n+    (\"CARGO_PKG_RUST_VERSION\",\"The Rust version from the manifest of your package. Note that this is the minimum Rust version supported by the package, not the current Rust version\"),\n+    (\"CARGO_CRATE_NAME\",\"The name of the crate that is currently being compiled\"),\n+    (\"CARGO_BIN_NAME\",\"The name of the binary that is currently being compiled (if it is a binary). This name does not include any file extension, such as .exe\"),\n+    (\"CARGO_PRIMARY_PACKAGE\",\"This environment variable will be set if the package being built is primary. Primary packages are the ones the user selected on the command-line, either with -p flags or the defaults based on the current directory and the default workspace members. This environment variable will not be set when building dependencies. This is only set when compiling the package (not when running binaries or tests)\"),\n+    (\"CARGO_TARGET_TMPDIR\",\"Only set when building integration test or benchmark code. This is a path to a directory inside the target directory where integration tests or benchmarks are free to put any data needed by the tests/benches. Cargo initially creates this directory but doesn't manage its content in any way, this is the responsibility of the test code\")\n+];\n+\n+pub(crate) fn complete_cargo_env_vars(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext<'_>,\n+    expanded: &ast::String,\n+) -> Option<()> {\n+    guard_env_macro(expanded, &ctx.sema)?;\n+    let range = expanded.text_range_between_quotes()?;\n+\n+    CARGO_DEFINED_VARS.iter().for_each(|(var, detail)| {\n+        let mut item = CompletionItem::new(CompletionItemKind::Keyword, range, var);\n+        item.detail(*detail);\n+        item.add_to(acc);\n+    });\n+\n+    Some(())\n+}\n+\n+fn guard_env_macro(string: &ast::String, semantics: &Semantics<'_, RootDatabase>) -> Option<()> {\n+    let call = macro_call_for_string_token(string)?;\n+    let name = call.path()?.segment()?.name_ref()?;\n+    let makro = semantics.resolve_macro_call(&call)?;\n+    let db = semantics.db;\n+\n+    match name.text().as_str() {\n+        \"env\" | \"option_env\" if makro.kind(db) == hir::MacroKind::BuiltIn => Some(()),\n+        _ => None,\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_edit, completion_list};\n+\n+    fn check(macro_name: &str) {\n+        check_edit(\n+            \"CARGO_BIN_NAME\",\n+            &format!(\n+                r#\"\n+            #[rustc_builtin_macro]\n+            macro_rules! {} {{\n+                ($var:literal) => {{ 0 }}\n+            }}\n+\n+            fn main() {{\n+                let foo = {}!(\"CAR$0\");\n+            }}\n+        \"#,\n+                macro_name, macro_name\n+            ),\n+            &format!(\n+                r#\"\n+            #[rustc_builtin_macro]\n+            macro_rules! {} {{\n+                ($var:literal) => {{ 0 }}\n+            }}\n+\n+            fn main() {{\n+                let foo = {}!(\"CARGO_BIN_NAME\");\n+            }}\n+        \"#,\n+                macro_name, macro_name\n+            ),\n+        );\n+    }\n+    #[test]\n+    fn completes_env_variable_in_env() {\n+        check(\"env\")\n+    }\n+\n+    #[test]\n+    fn completes_env_variable_in_option_env() {\n+        check(\"option_env\");\n+    }\n+\n+    #[test]\n+    fn doesnt_complete_in_random_strings() {\n+        let fixture = r#\"\n+            fn main() {\n+                let foo = \"CA$0\";\n+            }\n+        \"#;\n+\n+        let completions = completion_list(fixture);\n+        assert!(completions.is_empty(), \"Completions weren't empty: {}\", completions);\n+    }\n+\n+    #[test]\n+    fn doesnt_complete_in_random_macro() {\n+        let fixture = r#\"\n+            macro_rules! bar {\n+                ($($arg:tt)*) => { 0 }\n+            }\n+\n+            fn main() {\n+                let foo = bar!(\"CA$0\");\n+\n+            }\n+        \"#;\n+\n+        let completions = completion_list(fixture);\n+        assert!(completions.is_empty(), \"Completions weren't empty: {}\", completions);\n+    }\n+\n+    #[test]\n+    fn doesnt_complete_for_shadowed_macro() {\n+        let fixture = r#\"\n+            macro_rules! env {\n+                ($var:literal) => { 0 }\n+            }\n+\n+            fn main() {\n+                let foo = env!(\"CA$0\");\n+            }\n+        \"#;\n+\n+        let completions = completion_list(fixture);\n+        assert!(completions.is_empty(), \"Completions weren't empty: {}\", completions)\n+    }\n+}"}, {"sha": "e82cbfdcb8402e6dbc0518c60a8d8621bc38922b", "filename": "crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -38,7 +38,7 @@ use ide_db::{\n };\n use syntax::{\n     ast::{self, edit_in_place::AttrsOwnerEdit},\n-    AstNode, SyntaxElement, SyntaxKind, SyntaxNode, TextRange, T,\n+    AstNode, SyntaxElement, SyntaxKind, TextRange, T,\n };\n use text_edit::TextEdit;\n \n@@ -85,20 +85,36 @@ fn complete_trait_impl_name(\n     name: &Option<ast::Name>,\n     kind: ImplCompletionKind,\n ) -> Option<()> {\n-    let token = ctx.token.clone();\n     let item = match name {\n         Some(name) => name.syntax().parent(),\n-        None => if token.kind() == SyntaxKind::WHITESPACE { token.prev_token()? } else { token }\n-            .parent(),\n+        None => {\n+            let token = &ctx.token;\n+            match token.kind() {\n+                SyntaxKind::WHITESPACE => token.prev_token()?,\n+                _ => token.clone(),\n+            }\n+            .parent()\n+        }\n     }?;\n-    complete_trait_impl(\n-        acc,\n-        ctx,\n-        kind,\n-        replacement_range(ctx, &item),\n-        // item -> ASSOC_ITEM_LIST -> IMPL\n-        &ast::Impl::cast(item.parent()?.parent()?)?,\n-    );\n+    let item = ctx.sema.original_syntax_node(&item)?;\n+    // item -> ASSOC_ITEM_LIST -> IMPL\n+    let impl_def = ast::Impl::cast(item.parent()?.parent()?)?;\n+    let replacement_range = {\n+        // ctx.sema.original_ast_node(item)?;\n+        let first_child = item\n+            .children_with_tokens()\n+            .find(|child| {\n+                !matches!(\n+                    child.kind(),\n+                    SyntaxKind::COMMENT | SyntaxKind::WHITESPACE | SyntaxKind::ATTR\n+                )\n+            })\n+            .unwrap_or_else(|| SyntaxElement::Node(item.clone()));\n+\n+        TextRange::new(first_child.text_range().start(), ctx.source_range().end())\n+    };\n+\n+    complete_trait_impl(acc, ctx, kind, replacement_range, &impl_def);\n     Some(())\n }\n \n@@ -341,17 +357,6 @@ fn function_declaration(node: &ast::Fn, needs_whitespace: bool) -> String {\n     syntax.trim_end().to_owned()\n }\n \n-fn replacement_range(ctx: &CompletionContext<'_>, item: &SyntaxNode) -> TextRange {\n-    let first_child = item\n-        .children_with_tokens()\n-        .find(|child| {\n-            !matches!(child.kind(), SyntaxKind::COMMENT | SyntaxKind::WHITESPACE | SyntaxKind::ATTR)\n-        })\n-        .unwrap_or_else(|| SyntaxElement::Node(item.clone()));\n-\n-    TextRange::new(first_child.text_range().start(), ctx.source_range().end())\n-}\n-\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};"}, {"sha": "9850813a0ce1c1b936f9671e67b838815cfa7f74", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -1,4 +1,4 @@\n-//! See `CompletionContext` structure.\n+//! See [`CompletionContext`] structure.\n \n mod analysis;\n #[cfg(test)]\n@@ -23,7 +23,10 @@ use syntax::{\n };\n use text_edit::Indel;\n \n-use crate::CompletionConfig;\n+use crate::{\n+    context::analysis::{expand_and_analyze, AnalysisResult},\n+    CompletionConfig,\n+};\n \n const COMPLETION_MARKER: &str = \"intellijRulezz\";\n \n@@ -561,15 +564,27 @@ impl<'a> CompletionContext<'a> {\n             let edit = Indel::insert(offset, COMPLETION_MARKER.to_string());\n             parse.reparse(&edit).tree()\n         };\n-        let fake_ident_token =\n-            file_with_fake_ident.syntax().token_at_offset(offset).right_biased()?;\n \n+        // always pick the token to the immediate left of the cursor, as that is what we are actually\n+        // completing on\n         let original_token = original_file.syntax().token_at_offset(offset).left_biased()?;\n-        let token = sema.descend_into_macros_single(original_token.clone());\n+\n+        let AnalysisResult {\n+            analysis,\n+            expected: (expected_type, expected_name),\n+            qualifier_ctx,\n+            token,\n+            offset,\n+        } = expand_and_analyze(\n+            &sema,\n+            original_file.syntax().clone(),\n+            file_with_fake_ident.syntax().clone(),\n+            offset,\n+            &original_token,\n+        )?;\n \n         // adjust for macro input, this still fails if there is no token written yet\n-        let scope_offset = if original_token == token { offset } else { token.text_range().end() };\n-        let scope = sema.scope_at_offset(&token.parent()?, scope_offset)?;\n+        let scope = sema.scope_at_offset(&token.parent()?, offset)?;\n \n         let krate = scope.krate();\n         let module = scope.module();\n@@ -583,7 +598,7 @@ impl<'a> CompletionContext<'a> {\n \n         let depth_from_crate_root = iter::successors(module.parent(db), |m| m.parent(db)).count();\n \n-        let mut ctx = CompletionContext {\n+        let ctx = CompletionContext {\n             sema,\n             scope,\n             db,\n@@ -593,19 +608,13 @@ impl<'a> CompletionContext<'a> {\n             token,\n             krate,\n             module,\n-            expected_name: None,\n-            expected_type: None,\n-            qualifier_ctx: Default::default(),\n+            expected_name,\n+            expected_type,\n+            qualifier_ctx,\n             locals,\n             depth_from_crate_root,\n         };\n-        let ident_ctx = ctx.expand_and_analyze(\n-            original_file.syntax().clone(),\n-            file_with_fake_ident.syntax().clone(),\n-            offset,\n-            fake_ident_token,\n-        )?;\n-        Some((ctx, ident_ctx))\n+        Some((ctx, analysis))\n     }\n }\n "}, {"sha": "04111ec7efaa68e4dad225e25a8a220861d6b490", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 985, "deletions": 954, "changes": 1939, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -11,1063 +11,1094 @@ use syntax::{\n };\n \n use crate::context::{\n-    AttrCtx, CompletionAnalysis, CompletionContext, DotAccess, DotAccessKind, ExprCtx,\n-    ItemListKind, LifetimeContext, LifetimeKind, NameContext, NameKind, NameRefContext,\n-    NameRefKind, ParamContext, ParamKind, PathCompletionCtx, PathKind, PatternContext,\n-    PatternRefutability, Qualified, QualifierCtx, TypeAscriptionTarget, TypeLocation,\n-    COMPLETION_MARKER,\n+    AttrCtx, CompletionAnalysis, DotAccess, DotAccessKind, ExprCtx, ItemListKind, LifetimeContext,\n+    LifetimeKind, NameContext, NameKind, NameRefContext, NameRefKind, ParamContext, ParamKind,\n+    PathCompletionCtx, PathKind, PatternContext, PatternRefutability, Qualified, QualifierCtx,\n+    TypeAscriptionTarget, TypeLocation, COMPLETION_MARKER,\n };\n \n-impl<'a> CompletionContext<'a> {\n-    /// Expand attributes and macro calls at the current cursor position for both the original file\n-    /// and fake file repeatedly. As soon as one of the two expansions fail we stop so the original\n-    /// and speculative states stay in sync.\n-    pub(super) fn expand_and_analyze(\n-        &mut self,\n-        mut original_file: SyntaxNode,\n-        mut speculative_file: SyntaxNode,\n-        mut offset: TextSize,\n-        mut fake_ident_token: SyntaxToken,\n-    ) -> Option<CompletionAnalysis> {\n-        let _p = profile::span(\"CompletionContext::expand_and_fill\");\n-        let mut derive_ctx = None;\n-\n-        'expansion: loop {\n-            let parent_item =\n-                |item: &ast::Item| item.syntax().ancestors().skip(1).find_map(ast::Item::cast);\n-            let ancestor_items = iter::successors(\n-                Option::zip(\n-                    find_node_at_offset::<ast::Item>(&original_file, offset),\n-                    find_node_at_offset::<ast::Item>(&speculative_file, offset),\n+struct ExpansionResult {\n+    original_file: SyntaxNode,\n+    speculative_file: SyntaxNode,\n+    offset: TextSize,\n+    fake_ident_token: SyntaxToken,\n+    derive_ctx: Option<(SyntaxNode, SyntaxNode, TextSize, ast::Attr)>,\n+}\n+\n+pub(super) struct AnalysisResult {\n+    pub(super) analysis: CompletionAnalysis,\n+    pub(super) expected: (Option<Type>, Option<ast::NameOrNameRef>),\n+    pub(super) qualifier_ctx: QualifierCtx,\n+    pub(super) token: SyntaxToken,\n+    pub(super) offset: TextSize,\n+}\n+\n+pub(super) fn expand_and_analyze(\n+    sema: &Semantics<'_, RootDatabase>,\n+    original_file: SyntaxNode,\n+    speculative_file: SyntaxNode,\n+    offset: TextSize,\n+    original_token: &SyntaxToken,\n+) -> Option<AnalysisResult> {\n+    // as we insert after the offset, right biased will *always* pick the identifier no matter\n+    // if there is an ident already typed or not\n+    let fake_ident_token = speculative_file.token_at_offset(offset).right_biased()?;\n+    // the relative offset between the cursor and the *identifier* token we are completing on\n+    let relative_offset = offset - fake_ident_token.text_range().start();\n+    // make the offset point to the start of the original token, as that is what the\n+    // intermediate offsets calculated in expansion always points to\n+    let offset = offset - relative_offset;\n+    let expansion = expand(sema, original_file, speculative_file, offset, fake_ident_token);\n+    // add the relative offset back, so that left_biased finds the proper token\n+    let offset = expansion.offset + relative_offset;\n+    let token = expansion.original_file.token_at_offset(offset).left_biased()?;\n+\n+    analyze(sema, expansion, original_token, &token).map(|(analysis, expected, qualifier_ctx)| {\n+        AnalysisResult { analysis, expected, qualifier_ctx, token, offset }\n+    })\n+}\n+\n+/// Expand attributes and macro calls at the current cursor position for both the original file\n+/// and fake file repeatedly. As soon as one of the two expansions fail we stop so the original\n+/// and speculative states stay in sync.\n+fn expand(\n+    sema: &Semantics<'_, RootDatabase>,\n+    mut original_file: SyntaxNode,\n+    mut speculative_file: SyntaxNode,\n+    mut offset: TextSize,\n+    mut fake_ident_token: SyntaxToken,\n+) -> ExpansionResult {\n+    let _p = profile::span(\"CompletionContext::expand\");\n+    let mut derive_ctx = None;\n+\n+    'expansion: loop {\n+        let parent_item =\n+            |item: &ast::Item| item.syntax().ancestors().skip(1).find_map(ast::Item::cast);\n+        let ancestor_items = iter::successors(\n+            Option::zip(\n+                find_node_at_offset::<ast::Item>(&original_file, offset),\n+                find_node_at_offset::<ast::Item>(&speculative_file, offset),\n+            ),\n+            |(a, b)| parent_item(a).zip(parent_item(b)),\n+        );\n+\n+        // first try to expand attributes as these are always the outermost macro calls\n+        'ancestors: for (actual_item, item_with_fake_ident) in ancestor_items {\n+            match (\n+                sema.expand_attr_macro(&actual_item),\n+                sema.speculative_expand_attr_macro(\n+                    &actual_item,\n+                    &item_with_fake_ident,\n+                    fake_ident_token.clone(),\n                 ),\n-                |(a, b)| parent_item(a).zip(parent_item(b)),\n-            );\n-\n-            // first try to expand attributes as these are always the outermost macro calls\n-            'ancestors: for (actual_item, item_with_fake_ident) in ancestor_items {\n-                match (\n-                    self.sema.expand_attr_macro(&actual_item),\n-                    self.sema.speculative_expand_attr_macro(\n-                        &actual_item,\n-                        &item_with_fake_ident,\n-                        fake_ident_token.clone(),\n-                    ),\n-                ) {\n-                    // maybe parent items have attributes, so continue walking the ancestors\n-                    (None, None) => continue 'ancestors,\n-                    // successful expansions\n-                    (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n-                        let new_offset = fake_mapped_token.text_range().start();\n-                        if new_offset > actual_expansion.text_range().end() {\n-                            // offset outside of bounds from the original expansion,\n-                            // stop here to prevent problems from happening\n-                            break 'expansion;\n-                        }\n-                        original_file = actual_expansion;\n-                        speculative_file = fake_expansion;\n-                        fake_ident_token = fake_mapped_token;\n-                        offset = new_offset;\n-                        continue 'expansion;\n+            ) {\n+                // maybe parent items have attributes, so continue walking the ancestors\n+                (None, None) => continue 'ancestors,\n+                // successful expansions\n+                (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n+                    let new_offset = fake_mapped_token.text_range().start();\n+                    if new_offset > actual_expansion.text_range().end() {\n+                        // offset outside of bounds from the original expansion,\n+                        // stop here to prevent problems from happening\n+                        break 'expansion;\n                     }\n-                    // exactly one expansion failed, inconsistent state so stop expanding completely\n-                    _ => break 'expansion,\n+                    original_file = actual_expansion;\n+                    speculative_file = fake_expansion;\n+                    fake_ident_token = fake_mapped_token;\n+                    offset = new_offset;\n+                    continue 'expansion;\n                 }\n+                // exactly one expansion failed, inconsistent state so stop expanding completely\n+                _ => break 'expansion,\n             }\n+        }\n \n-            // No attributes have been expanded, so look for macro_call! token trees or derive token trees\n-            let orig_tt = match find_node_at_offset::<ast::TokenTree>(&original_file, offset) {\n-                Some(it) => it,\n-                None => break 'expansion,\n-            };\n-            let spec_tt = match find_node_at_offset::<ast::TokenTree>(&speculative_file, offset) {\n-                Some(it) => it,\n-                None => break 'expansion,\n-            };\n+        // No attributes have been expanded, so look for macro_call! token trees or derive token trees\n+        let orig_tt = match find_node_at_offset::<ast::TokenTree>(&original_file, offset) {\n+            Some(it) => it,\n+            None => break 'expansion,\n+        };\n+        let spec_tt = match find_node_at_offset::<ast::TokenTree>(&speculative_file, offset) {\n+            Some(it) => it,\n+            None => break 'expansion,\n+        };\n \n-            // Expand pseudo-derive expansion\n-            if let (Some(orig_attr), Some(spec_attr)) = (\n-                orig_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n-                spec_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n+        // Expand pseudo-derive expansion\n+        if let (Some(orig_attr), Some(spec_attr)) = (\n+            orig_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n+            spec_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n+        ) {\n+            if let (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) = (\n+                sema.expand_derive_as_pseudo_attr_macro(&orig_attr),\n+                sema.speculative_expand_derive_as_pseudo_attr_macro(\n+                    &orig_attr,\n+                    &spec_attr,\n+                    fake_ident_token.clone(),\n+                ),\n             ) {\n-                if let (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) = (\n-                    self.sema.expand_derive_as_pseudo_attr_macro(&orig_attr),\n-                    self.sema.speculative_expand_derive_as_pseudo_attr_macro(\n-                        &orig_attr,\n-                        &spec_attr,\n-                        fake_ident_token.clone(),\n-                    ),\n-                ) {\n-                    derive_ctx = Some((\n-                        actual_expansion,\n-                        fake_expansion,\n-                        fake_mapped_token.text_range().start(),\n-                        orig_attr,\n-                    ));\n-                }\n-                // at this point we won't have any more successful expansions, so stop\n+                derive_ctx = Some((\n+                    actual_expansion,\n+                    fake_expansion,\n+                    fake_mapped_token.text_range().start(),\n+                    orig_attr,\n+                ));\n+            }\n+            // at this point we won't have any more successful expansions, so stop\n+            break 'expansion;\n+        }\n+\n+        // Expand fn-like macro calls\n+        if let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n+            orig_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n+            spec_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n+        ) {\n+            let mac_call_path0 = actual_macro_call.path().as_ref().map(|s| s.syntax().text());\n+            let mac_call_path1 =\n+                macro_call_with_fake_ident.path().as_ref().map(|s| s.syntax().text());\n+\n+            // inconsistent state, stop expanding\n+            if mac_call_path0 != mac_call_path1 {\n                 break 'expansion;\n             }\n+            let speculative_args = match macro_call_with_fake_ident.token_tree() {\n+                Some(tt) => tt,\n+                None => break 'expansion,\n+            };\n \n-            // Expand fn-like macro calls\n-            if let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n-                orig_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n-                spec_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n+            match (\n+                sema.expand(&actual_macro_call),\n+                sema.speculative_expand(\n+                    &actual_macro_call,\n+                    &speculative_args,\n+                    fake_ident_token.clone(),\n+                ),\n             ) {\n-                let mac_call_path0 = actual_macro_call.path().as_ref().map(|s| s.syntax().text());\n-                let mac_call_path1 =\n-                    macro_call_with_fake_ident.path().as_ref().map(|s| s.syntax().text());\n-\n-                // inconsistent state, stop expanding\n-                if mac_call_path0 != mac_call_path1 {\n-                    break 'expansion;\n-                }\n-                let speculative_args = match macro_call_with_fake_ident.token_tree() {\n-                    Some(tt) => tt,\n-                    None => break 'expansion,\n-                };\n-\n-                match (\n-                    self.sema.expand(&actual_macro_call),\n-                    self.sema.speculative_expand(\n-                        &actual_macro_call,\n-                        &speculative_args,\n-                        fake_ident_token.clone(),\n-                    ),\n-                ) {\n-                    // successful expansions\n-                    (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n-                        let new_offset = fake_mapped_token.text_range().start();\n-                        if new_offset > actual_expansion.text_range().end() {\n-                            // offset outside of bounds from the original expansion,\n-                            // stop here to prevent problems from happening\n-                            break 'expansion;\n-                        }\n-                        original_file = actual_expansion;\n-                        speculative_file = fake_expansion;\n-                        fake_ident_token = fake_mapped_token;\n-                        offset = new_offset;\n-                        continue 'expansion;\n+                // successful expansions\n+                (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n+                    let new_offset = fake_mapped_token.text_range().start();\n+                    if new_offset > actual_expansion.text_range().end() {\n+                        // offset outside of bounds from the original expansion,\n+                        // stop here to prevent problems from happening\n+                        break 'expansion;\n                     }\n-                    // at least on expansion failed, we won't have anything to expand from this point\n-                    // onwards so break out\n-                    _ => break 'expansion,\n+                    original_file = actual_expansion;\n+                    speculative_file = fake_expansion;\n+                    fake_ident_token = fake_mapped_token;\n+                    offset = new_offset;\n+                    continue 'expansion;\n                 }\n+                // at least on expansion failed, we won't have anything to expand from this point\n+                // onwards so break out\n+                _ => break 'expansion,\n             }\n-\n-            // none of our states have changed so stop the loop\n-            break 'expansion;\n         }\n \n-        self.analyze(&original_file, speculative_file, offset, derive_ctx)\n+        // none of our states have changed so stop the loop\n+        break 'expansion;\n     }\n+    ExpansionResult { original_file, speculative_file, offset, fake_ident_token, derive_ctx }\n+}\n \n-    /// Calculate the expected type and name of the cursor position.\n-    fn expected_type_and_name(\n-        &self,\n-        name_like: &ast::NameLike,\n-    ) -> (Option<Type>, Option<NameOrNameRef>) {\n-        let mut node = match self.token.parent() {\n-            Some(it) => it,\n-            None => return (None, None),\n-        };\n+/// Fill the completion context, this is what does semantic reasoning about the surrounding context\n+/// of the completion location.\n+fn analyze(\n+    sema: &Semantics<'_, RootDatabase>,\n+    expansion_result: ExpansionResult,\n+    original_token: &SyntaxToken,\n+    self_token: &SyntaxToken,\n+) -> Option<(CompletionAnalysis, (Option<Type>, Option<ast::NameOrNameRef>), QualifierCtx)> {\n+    let _p = profile::span(\"CompletionContext::analyze\");\n+    let ExpansionResult { original_file, speculative_file, offset, fake_ident_token, derive_ctx } =\n+        expansion_result;\n+    let syntax_element = NodeOrToken::Token(fake_ident_token);\n+    if is_in_token_of_for_loop(syntax_element.clone()) {\n+        // for pat $0\n+        // there is nothing to complete here except `in` keyword\n+        // don't bother populating the context\n+        // FIXME: the completion calculations should end up good enough\n+        // such that this special case becomes unnecessary\n+        return None;\n+    }\n \n-        let strip_refs = |mut ty: Type| match name_like {\n-            ast::NameLike::NameRef(n) => {\n-                let p = match n.syntax().parent() {\n-                    Some(it) => it,\n-                    None => return ty,\n-                };\n-                let top_syn = match_ast! {\n-                    match p {\n-                        ast::FieldExpr(e) => e\n-                            .syntax()\n-                            .ancestors()\n-                            .map_while(ast::FieldExpr::cast)\n-                            .last()\n-                            .map(|it| it.syntax().clone()),\n-                        ast::PathSegment(e) => e\n-                            .syntax()\n-                            .ancestors()\n-                            .skip(1)\n-                            .take_while(|it| ast::Path::can_cast(it.kind()) || ast::PathExpr::can_cast(it.kind()))\n-                            .find_map(ast::PathExpr::cast)\n-                            .map(|it| it.syntax().clone()),\n-                        _ => None\n-                    }\n+    // Overwrite the path kind for derives\n+    if let Some((original_file, file_with_fake_ident, offset, origin_attr)) = derive_ctx {\n+        if let Some(ast::NameLike::NameRef(name_ref)) =\n+            find_node_at_offset(&file_with_fake_ident, offset)\n+        {\n+            let parent = name_ref.syntax().parent()?;\n+            let (mut nameref_ctx, _) = classify_name_ref(&sema, &original_file, name_ref, parent)?;\n+            if let NameRefKind::Path(path_ctx) = &mut nameref_ctx.kind {\n+                path_ctx.kind = PathKind::Derive {\n+                    existing_derives: sema\n+                        .resolve_derive_macro(&origin_attr)\n+                        .into_iter()\n+                        .flatten()\n+                        .flatten()\n+                        .collect(),\n                 };\n-                let top_syn = match top_syn {\n-                    Some(it) => it,\n-                    None => return ty,\n-                };\n-                for _ in top_syn.ancestors().skip(1).map_while(ast::RefExpr::cast) {\n-                    cov_mark::hit!(expected_type_fn_param_ref);\n-                    ty = ty.strip_reference();\n-                }\n-                ty\n             }\n-            _ => ty,\n-        };\n+            return Some((\n+                CompletionAnalysis::NameRef(nameref_ctx),\n+                (None, None),\n+                QualifierCtx::default(),\n+            ));\n+        }\n+        return None;\n+    }\n \n-        loop {\n-            break match_ast! {\n-                match node {\n-                    ast::LetStmt(it) => {\n-                        cov_mark::hit!(expected_type_let_with_leading_char);\n-                        cov_mark::hit!(expected_type_let_without_leading_char);\n-                        let ty = it.pat()\n-                            .and_then(|pat| self.sema.type_of_pat(&pat))\n-                            .or_else(|| it.initializer().and_then(|it| self.sema.type_of_expr(&it)))\n-                            .map(TypeInfo::original);\n-                        let name = match it.pat() {\n-                            Some(ast::Pat::IdentPat(ident)) => ident.name().map(NameOrNameRef::Name),\n-                            Some(_) | None => None,\n-                        };\n-\n-                        (ty, name)\n-                    },\n-                    ast::LetExpr(it) => {\n-                        cov_mark::hit!(expected_type_if_let_without_leading_char);\n-                        let ty = it.pat()\n-                            .and_then(|pat| self.sema.type_of_pat(&pat))\n-                            .or_else(|| it.expr().and_then(|it| self.sema.type_of_expr(&it)))\n-                            .map(TypeInfo::original);\n-                        (ty, None)\n-                    },\n-                    ast::ArgList(_) => {\n-                        cov_mark::hit!(expected_type_fn_param);\n-                        ActiveParameter::at_token(\n-                            &self.sema,\n-                            self.token.clone(),\n-                        ).map(|ap| {\n-                            let name = ap.ident().map(NameOrNameRef::Name);\n-\n-                            let ty = strip_refs(ap.ty);\n-                            (Some(ty), name)\n-                        })\n-                        .unwrap_or((None, None))\n-                    },\n-                    ast::RecordExprFieldList(it) => {\n-                        // wouldn't try {} be nice...\n-                        (|| {\n-                            if self.token.kind() == T![..]\n-                                || self.token.prev_token().map(|t| t.kind()) == Some(T![..])\n-                            {\n-                                cov_mark::hit!(expected_type_struct_func_update);\n-                                let record_expr = it.syntax().parent().and_then(ast::RecordExpr::cast)?;\n-                                let ty = self.sema.type_of_expr(&record_expr.into())?;\n-                                Some((\n-                                    Some(ty.original),\n-                                    None\n-                                ))\n-                            } else {\n-                                cov_mark::hit!(expected_type_struct_field_without_leading_char);\n-                                let expr_field = self.token.prev_sibling_or_token()?\n-                                    .into_node()\n-                                    .and_then(ast::RecordExprField::cast)?;\n-                                let (_, _, ty) = self.sema.resolve_record_field(&expr_field)?;\n-                                Some((\n-                                    Some(ty),\n-                                    expr_field.field_name().map(NameOrNameRef::NameRef),\n-                                ))\n-                            }\n-                        })().unwrap_or((None, None))\n-                    },\n-                    ast::RecordExprField(it) => {\n-                        if let Some(expr) = it.expr() {\n-                            cov_mark::hit!(expected_type_struct_field_with_leading_char);\n-                            (\n-                                self.sema.type_of_expr(&expr).map(TypeInfo::original),\n-                                it.field_name().map(NameOrNameRef::NameRef),\n-                            )\n-                        } else {\n-                            cov_mark::hit!(expected_type_struct_field_followed_by_comma);\n-                            let ty = self.sema.resolve_record_field(&it)\n-                                .map(|(_, _, ty)| ty);\n-                            (\n-                                ty,\n-                                it.field_name().map(NameOrNameRef::NameRef),\n-                            )\n-                        }\n-                    },\n-                    // match foo { $0 }\n-                    // match foo { ..., pat => $0 }\n-                    ast::MatchExpr(it) => {\n-                        let on_arrow = previous_non_trivia_token(self.token.clone()).map_or(false, |it| T![=>] == it.kind());\n-\n-                        let ty = if on_arrow {\n-                            // match foo { ..., pat => $0 }\n-                            cov_mark::hit!(expected_type_match_arm_body_without_leading_char);\n-                            cov_mark::hit!(expected_type_match_arm_body_with_leading_char);\n-                            self.sema.type_of_expr(&it.into())\n-                        } else {\n-                            // match foo { $0 }\n-                            cov_mark::hit!(expected_type_match_arm_without_leading_char);\n-                            it.expr().and_then(|e| self.sema.type_of_expr(&e))\n-                        }.map(TypeInfo::original);\n-                        (ty, None)\n-                    },\n-                    ast::IfExpr(it) => {\n-                        let ty = it.condition()\n-                            .and_then(|e| self.sema.type_of_expr(&e))\n-                            .map(TypeInfo::original);\n-                        (ty, None)\n-                    },\n-                    ast::IdentPat(it) => {\n-                        cov_mark::hit!(expected_type_if_let_with_leading_char);\n-                        cov_mark::hit!(expected_type_match_arm_with_leading_char);\n-                        let ty = self.sema.type_of_pat(&ast::Pat::from(it)).map(TypeInfo::original);\n-                        (ty, None)\n-                    },\n-                    ast::Fn(it) => {\n-                        cov_mark::hit!(expected_type_fn_ret_with_leading_char);\n-                        cov_mark::hit!(expected_type_fn_ret_without_leading_char);\n-                        let def = self.sema.to_def(&it);\n-                        (def.map(|def| def.ret_type(self.db)), None)\n-                    },\n-                    ast::ClosureExpr(it) => {\n-                        let ty = self.sema.type_of_expr(&it.into());\n-                        ty.and_then(|ty| ty.original.as_callable(self.db))\n-                            .map(|c| (Some(c.return_type()), None))\n-                            .unwrap_or((None, None))\n-                    },\n-                    ast::ParamList(_) => (None, None),\n-                    ast::Stmt(_) => (None, None),\n-                    ast::Item(_) => (None, None),\n-                    _ => {\n-                        match node.parent() {\n-                            Some(n) => {\n-                                node = n;\n-                                continue;\n-                            },\n-                            None => (None, None),\n-                        }\n-                    },\n+    let name_like = match find_node_at_offset(&speculative_file, offset) {\n+        Some(it) => it,\n+        None => {\n+            let analysis = if let Some(original) = ast::String::cast(original_token.clone()) {\n+                CompletionAnalysis::String {\n+                    original,\n+                    expanded: ast::String::cast(self_token.clone()),\n+                }\n+            } else {\n+                // Fix up trailing whitespace problem\n+                // #[attr(foo = $0\n+                let token = syntax::algo::skip_trivia_token(self_token.clone(), Direction::Prev)?;\n+                let p = token.parent()?;\n+                if p.kind() == SyntaxKind::TOKEN_TREE\n+                    && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n+                {\n+                    let colon_prefix = previous_non_trivia_token(self_token.clone())\n+                        .map_or(false, |it| T![:] == it.kind());\n+                    CompletionAnalysis::UnexpandedAttrTT {\n+                        fake_attribute_under_caret: syntax_element\n+                            .ancestors()\n+                            .find_map(ast::Attr::cast),\n+                        colon_prefix,\n+                    }\n+                } else {\n+                    return None;\n                 }\n             };\n+            return Some((analysis, (None, None), QualifierCtx::default()));\n         }\n-    }\n-\n-    /// Fill the completion context, this is what does semantic reasoning about the surrounding context\n-    /// of the completion location.\n-    fn analyze(\n-        &mut self,\n-        original_file: &SyntaxNode,\n-        file_with_fake_ident: SyntaxNode,\n-        offset: TextSize,\n-        derive_ctx: Option<(SyntaxNode, SyntaxNode, TextSize, ast::Attr)>,\n-    ) -> Option<CompletionAnalysis> {\n-        let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased()?;\n-        let syntax_element = NodeOrToken::Token(fake_ident_token);\n-        if is_in_token_of_for_loop(syntax_element.clone()) {\n-            // for pat $0\n-            // there is nothing to complete here except `in` keyword\n-            // don't bother populating the context\n-            // FIXME: the completion calculations should end up good enough\n-            // such that this special case becomes unnecessary\n-            return None;\n+    };\n+    let expected = expected_type_and_name(sema, &self_token, &name_like);\n+    let mut qual_ctx = QualifierCtx::default();\n+    let analysis = match name_like {\n+        ast::NameLike::Lifetime(lifetime) => {\n+            CompletionAnalysis::Lifetime(classify_lifetime(sema, &original_file, lifetime)?)\n+        }\n+        ast::NameLike::NameRef(name_ref) => {\n+            let parent = name_ref.syntax().parent()?;\n+            let (nameref_ctx, qualifier_ctx) =\n+                classify_name_ref(sema, &original_file, name_ref, parent.clone())?;\n+            qual_ctx = qualifier_ctx;\n+            CompletionAnalysis::NameRef(nameref_ctx)\n+        }\n+        ast::NameLike::Name(name) => {\n+            let name_ctx = classify_name(sema, &original_file, name)?;\n+            CompletionAnalysis::Name(name_ctx)\n         }\n+    };\n+    Some((analysis, expected, qual_ctx))\n+}\n \n-        // Overwrite the path kind for derives\n-        if let Some((original_file, file_with_fake_ident, offset, origin_attr)) = derive_ctx {\n-            if let Some(ast::NameLike::NameRef(name_ref)) =\n-                find_node_at_offset(&file_with_fake_ident, offset)\n-            {\n-                let parent = name_ref.syntax().parent()?;\n-                let (mut nameref_ctx, _) =\n-                    Self::classify_name_ref(&self.sema, &original_file, name_ref, parent)?;\n-                if let NameRefKind::Path(path_ctx) = &mut nameref_ctx.kind {\n-                    path_ctx.kind = PathKind::Derive {\n-                        existing_derives: self\n-                            .sema\n-                            .resolve_derive_macro(&origin_attr)\n-                            .into_iter()\n-                            .flatten()\n-                            .flatten()\n-                            .collect(),\n-                    };\n+/// Calculate the expected type and name of the cursor position.\n+fn expected_type_and_name(\n+    sema: &Semantics<'_, RootDatabase>,\n+    token: &SyntaxToken,\n+    name_like: &ast::NameLike,\n+) -> (Option<Type>, Option<NameOrNameRef>) {\n+    let mut node = match token.parent() {\n+        Some(it) => it,\n+        None => return (None, None),\n+    };\n+\n+    let strip_refs = |mut ty: Type| match name_like {\n+        ast::NameLike::NameRef(n) => {\n+            let p = match n.syntax().parent() {\n+                Some(it) => it,\n+                None => return ty,\n+            };\n+            let top_syn = match_ast! {\n+                match p {\n+                    ast::FieldExpr(e) => e\n+                        .syntax()\n+                        .ancestors()\n+                        .map_while(ast::FieldExpr::cast)\n+                        .last()\n+                        .map(|it| it.syntax().clone()),\n+                    ast::PathSegment(e) => e\n+                        .syntax()\n+                        .ancestors()\n+                        .skip(1)\n+                        .take_while(|it| ast::Path::can_cast(it.kind()) || ast::PathExpr::can_cast(it.kind()))\n+                        .find_map(ast::PathExpr::cast)\n+                        .map(|it| it.syntax().clone()),\n+                    _ => None\n                 }\n-                return Some(CompletionAnalysis::NameRef(nameref_ctx));\n+            };\n+            let top_syn = match top_syn {\n+                Some(it) => it,\n+                None => return ty,\n+            };\n+            for _ in top_syn.ancestors().skip(1).map_while(ast::RefExpr::cast) {\n+                cov_mark::hit!(expected_type_fn_param_ref);\n+                ty = ty.strip_reference();\n             }\n-            return None;\n+            ty\n         }\n+        _ => ty,\n+    };\n \n-        let name_like = match find_node_at_offset(&file_with_fake_ident, offset) {\n-            Some(it) => it,\n-            None => {\n-                let analysis =\n-                    if let Some(original) = ast::String::cast(self.original_token.clone()) {\n-                        CompletionAnalysis::String {\n-                            original,\n-                            expanded: ast::String::cast(self.token.clone()),\n-                        }\n-                    } else {\n-                        // Fix up trailing whitespace problem\n-                        // #[attr(foo = $0\n-                        let token =\n-                            syntax::algo::skip_trivia_token(self.token.clone(), Direction::Prev)?;\n-                        let p = token.parent()?;\n-                        if p.kind() == SyntaxKind::TOKEN_TREE\n-                            && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n+    loop {\n+        break match_ast! {\n+            match node {\n+                ast::LetStmt(it) => {\n+                    cov_mark::hit!(expected_type_let_with_leading_char);\n+                    cov_mark::hit!(expected_type_let_without_leading_char);\n+                    let ty = it.pat()\n+                        .and_then(|pat| sema.type_of_pat(&pat))\n+                        .or_else(|| it.initializer().and_then(|it| sema.type_of_expr(&it)))\n+                        .map(TypeInfo::original);\n+                    let name = match it.pat() {\n+                        Some(ast::Pat::IdentPat(ident)) => ident.name().map(NameOrNameRef::Name),\n+                        Some(_) | None => None,\n+                    };\n+\n+                    (ty, name)\n+                },\n+                ast::LetExpr(it) => {\n+                    cov_mark::hit!(expected_type_if_let_without_leading_char);\n+                    let ty = it.pat()\n+                        .and_then(|pat| sema.type_of_pat(&pat))\n+                        .or_else(|| it.expr().and_then(|it| sema.type_of_expr(&it)))\n+                        .map(TypeInfo::original);\n+                    (ty, None)\n+                },\n+                ast::ArgList(_) => {\n+                    cov_mark::hit!(expected_type_fn_param);\n+                    ActiveParameter::at_token(\n+                        &sema,\n+                       token.clone(),\n+                    ).map(|ap| {\n+                        let name = ap.ident().map(NameOrNameRef::Name);\n+\n+                        let ty = strip_refs(ap.ty);\n+                        (Some(ty), name)\n+                    })\n+                    .unwrap_or((None, None))\n+                },\n+                ast::RecordExprFieldList(it) => {\n+                    // wouldn't try {} be nice...\n+                    (|| {\n+                        if token.kind() == T![..]\n+                            ||token.prev_token().map(|t| t.kind()) == Some(T![..])\n                         {\n-                            let colon_prefix = previous_non_trivia_token(self.token.clone())\n-                                .map_or(false, |it| T![:] == it.kind());\n-                            CompletionAnalysis::UnexpandedAttrTT {\n-                                fake_attribute_under_caret: syntax_element\n-                                    .ancestors()\n-                                    .find_map(ast::Attr::cast),\n-                                colon_prefix,\n-                            }\n+                            cov_mark::hit!(expected_type_struct_func_update);\n+                            let record_expr = it.syntax().parent().and_then(ast::RecordExpr::cast)?;\n+                            let ty = sema.type_of_expr(&record_expr.into())?;\n+                            Some((\n+                                Some(ty.original),\n+                                None\n+                            ))\n                         } else {\n-                            return None;\n+                            cov_mark::hit!(expected_type_struct_field_without_leading_char);\n+                            let expr_field = token.prev_sibling_or_token()?\n+                                .into_node()\n+                                .and_then(ast::RecordExprField::cast)?;\n+                            let (_, _, ty) = sema.resolve_record_field(&expr_field)?;\n+                            Some((\n+                                Some(ty),\n+                                expr_field.field_name().map(NameOrNameRef::NameRef),\n+                            ))\n                         }\n-                    };\n-                return Some(analysis);\n+                    })().unwrap_or((None, None))\n+                },\n+                ast::RecordExprField(it) => {\n+                    if let Some(expr) = it.expr() {\n+                        cov_mark::hit!(expected_type_struct_field_with_leading_char);\n+                        (\n+                            sema.type_of_expr(&expr).map(TypeInfo::original),\n+                            it.field_name().map(NameOrNameRef::NameRef),\n+                        )\n+                    } else {\n+                        cov_mark::hit!(expected_type_struct_field_followed_by_comma);\n+                        let ty = sema.resolve_record_field(&it)\n+                            .map(|(_, _, ty)| ty);\n+                        (\n+                            ty,\n+                            it.field_name().map(NameOrNameRef::NameRef),\n+                        )\n+                    }\n+                },\n+                // match foo { $0 }\n+                // match foo { ..., pat => $0 }\n+                ast::MatchExpr(it) => {\n+                    let on_arrow = previous_non_trivia_token(token.clone()).map_or(false, |it| T![=>] == it.kind());\n+\n+                    let ty = if on_arrow {\n+                        // match foo { ..., pat => $0 }\n+                        cov_mark::hit!(expected_type_match_arm_body_without_leading_char);\n+                        cov_mark::hit!(expected_type_match_arm_body_with_leading_char);\n+                        sema.type_of_expr(&it.into())\n+                    } else {\n+                        // match foo { $0 }\n+                        cov_mark::hit!(expected_type_match_arm_without_leading_char);\n+                        it.expr().and_then(|e| sema.type_of_expr(&e))\n+                    }.map(TypeInfo::original);\n+                    (ty, None)\n+                },\n+                ast::IfExpr(it) => {\n+                    let ty = it.condition()\n+                        .and_then(|e| sema.type_of_expr(&e))\n+                        .map(TypeInfo::original);\n+                    (ty, None)\n+                },\n+                ast::IdentPat(it) => {\n+                    cov_mark::hit!(expected_type_if_let_with_leading_char);\n+                    cov_mark::hit!(expected_type_match_arm_with_leading_char);\n+                    let ty = sema.type_of_pat(&ast::Pat::from(it)).map(TypeInfo::original);\n+                    (ty, None)\n+                },\n+                ast::Fn(it) => {\n+                    cov_mark::hit!(expected_type_fn_ret_with_leading_char);\n+                    cov_mark::hit!(expected_type_fn_ret_without_leading_char);\n+                    let def = sema.to_def(&it);\n+                    (def.map(|def| def.ret_type(sema.db)), None)\n+                },\n+                ast::ClosureExpr(it) => {\n+                    let ty = sema.type_of_expr(&it.into());\n+                    ty.and_then(|ty| ty.original.as_callable(sema.db))\n+                        .map(|c| (Some(c.return_type()), None))\n+                        .unwrap_or((None, None))\n+                },\n+                ast::ParamList(_) => (None, None),\n+                ast::Stmt(_) => (None, None),\n+                ast::Item(_) => (None, None),\n+                _ => {\n+                    match node.parent() {\n+                        Some(n) => {\n+                            node = n;\n+                            continue;\n+                        },\n+                        None => (None, None),\n+                    }\n+                },\n             }\n         };\n-        (self.expected_type, self.expected_name) = self.expected_type_and_name(&name_like);\n-        let analysis = match name_like {\n-            ast::NameLike::Lifetime(lifetime) => CompletionAnalysis::Lifetime(\n-                Self::classify_lifetime(&self.sema, original_file, lifetime)?,\n-            ),\n-            ast::NameLike::NameRef(name_ref) => {\n-                let parent = name_ref.syntax().parent()?;\n-                let (nameref_ctx, qualifier_ctx) =\n-                    Self::classify_name_ref(&self.sema, &original_file, name_ref, parent.clone())?;\n+    }\n+}\n \n-                self.qualifier_ctx = qualifier_ctx;\n-                CompletionAnalysis::NameRef(nameref_ctx)\n-            }\n-            ast::NameLike::Name(name) => {\n-                let name_ctx = Self::classify_name(&self.sema, original_file, name)?;\n-                CompletionAnalysis::Name(name_ctx)\n-            }\n-        };\n-        Some(analysis)\n+fn classify_lifetime(\n+    _sema: &Semantics<'_, RootDatabase>,\n+    original_file: &SyntaxNode,\n+    lifetime: ast::Lifetime,\n+) -> Option<LifetimeContext> {\n+    let parent = lifetime.syntax().parent()?;\n+    if parent.kind() == SyntaxKind::ERROR {\n+        return None;\n     }\n \n-    fn classify_lifetime(\n-        _sema: &Semantics<'_, RootDatabase>,\n-        original_file: &SyntaxNode,\n-        lifetime: ast::Lifetime,\n-    ) -> Option<LifetimeContext> {\n-        let parent = lifetime.syntax().parent()?;\n-        if parent.kind() == SyntaxKind::ERROR {\n-            return None;\n+    let kind = match_ast! {\n+        match parent {\n+            ast::LifetimeParam(param) => LifetimeKind::LifetimeParam {\n+                is_decl: param.lifetime().as_ref() == Some(&lifetime),\n+                param\n+            },\n+            ast::BreakExpr(_) => LifetimeKind::LabelRef,\n+            ast::ContinueExpr(_) => LifetimeKind::LabelRef,\n+            ast::Label(_) => LifetimeKind::LabelDef,\n+            _ => LifetimeKind::Lifetime,\n         }\n+    };\n+    let lifetime = find_node_at_offset(&original_file, lifetime.syntax().text_range().start());\n \n-        let kind = match_ast! {\n-            match parent {\n-                ast::LifetimeParam(param) => LifetimeKind::LifetimeParam {\n-                    is_decl: param.lifetime().as_ref() == Some(&lifetime),\n-                    param\n-                },\n-                ast::BreakExpr(_) => LifetimeKind::LabelRef,\n-                ast::ContinueExpr(_) => LifetimeKind::LabelRef,\n-                ast::Label(_) => LifetimeKind::LabelDef,\n-                _ => LifetimeKind::Lifetime,\n-            }\n-        };\n-        let lifetime = find_node_at_offset(&original_file, lifetime.syntax().text_range().start());\n+    Some(LifetimeContext { lifetime, kind })\n+}\n \n-        Some(LifetimeContext { lifetime, kind })\n-    }\n+fn classify_name(\n+    sema: &Semantics<'_, RootDatabase>,\n+    original_file: &SyntaxNode,\n+    name: ast::Name,\n+) -> Option<NameContext> {\n+    let parent = name.syntax().parent()?;\n+    let kind = match_ast! {\n+        match parent {\n+            ast::Const(_) => NameKind::Const,\n+            ast::ConstParam(_) => NameKind::ConstParam,\n+            ast::Enum(_) => NameKind::Enum,\n+            ast::Fn(_) => NameKind::Function,\n+            ast::IdentPat(bind_pat) => {\n+                let mut pat_ctx = pattern_context_for(sema, original_file, bind_pat.into());\n+                if let Some(record_field) = ast::RecordPatField::for_field_name(&name) {\n+                    pat_ctx.record_pat = find_node_in_file_compensated(sema, original_file, &record_field.parent_record_pat());\n+                }\n \n-    fn classify_name(\n-        sema: &Semantics<'_, RootDatabase>,\n-        original_file: &SyntaxNode,\n-        name: ast::Name,\n-    ) -> Option<NameContext> {\n-        let parent = name.syntax().parent()?;\n-        let kind = match_ast! {\n-            match parent {\n-                ast::Const(_) => NameKind::Const,\n-                ast::ConstParam(_) => NameKind::ConstParam,\n-                ast::Enum(_) => NameKind::Enum,\n-                ast::Fn(_) => NameKind::Function,\n-                ast::IdentPat(bind_pat) => {\n-                    let mut pat_ctx = pattern_context_for(sema, original_file, bind_pat.into());\n-                    if let Some(record_field) = ast::RecordPatField::for_field_name(&name) {\n-                        pat_ctx.record_pat = find_node_in_file_compensated(sema, original_file, &record_field.parent_record_pat());\n-                    }\n+                NameKind::IdentPat(pat_ctx)\n+            },\n+            ast::MacroDef(_) => NameKind::MacroDef,\n+            ast::MacroRules(_) => NameKind::MacroRules,\n+            ast::Module(module) => NameKind::Module(module),\n+            ast::RecordField(_) => NameKind::RecordField,\n+            ast::Rename(_) => NameKind::Rename,\n+            ast::SelfParam(_) => NameKind::SelfParam,\n+            ast::Static(_) => NameKind::Static,\n+            ast::Struct(_) => NameKind::Struct,\n+            ast::Trait(_) => NameKind::Trait,\n+            ast::TypeAlias(_) => NameKind::TypeAlias,\n+            ast::TypeParam(_) => NameKind::TypeParam,\n+            ast::Union(_) => NameKind::Union,\n+            ast::Variant(_) => NameKind::Variant,\n+            _ => return None,\n+        }\n+    };\n+    let name = find_node_at_offset(&original_file, name.syntax().text_range().start());\n+    Some(NameContext { name, kind })\n+}\n \n-                    NameKind::IdentPat(pat_ctx)\n-                },\n-                ast::MacroDef(_) => NameKind::MacroDef,\n-                ast::MacroRules(_) => NameKind::MacroRules,\n-                ast::Module(module) => NameKind::Module(module),\n-                ast::RecordField(_) => NameKind::RecordField,\n-                ast::Rename(_) => NameKind::Rename,\n-                ast::SelfParam(_) => NameKind::SelfParam,\n-                ast::Static(_) => NameKind::Static,\n-                ast::Struct(_) => NameKind::Struct,\n-                ast::Trait(_) => NameKind::Trait,\n-                ast::TypeAlias(_) => NameKind::TypeAlias,\n-                ast::TypeParam(_) => NameKind::TypeParam,\n-                ast::Union(_) => NameKind::Union,\n-                ast::Variant(_) => NameKind::Variant,\n-                _ => return None,\n-            }\n-        };\n-        let name = find_node_at_offset(&original_file, name.syntax().text_range().start());\n-        Some(NameContext { name, kind })\n+fn classify_name_ref(\n+    sema: &Semantics<'_, RootDatabase>,\n+    original_file: &SyntaxNode,\n+    name_ref: ast::NameRef,\n+    parent: SyntaxNode,\n+) -> Option<(NameRefContext, QualifierCtx)> {\n+    let nameref = find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n+\n+    let make_res = |kind| (NameRefContext { nameref: nameref.clone(), kind }, Default::default());\n+\n+    if let Some(record_field) = ast::RecordExprField::for_field_name(&name_ref) {\n+        let dot_prefix = previous_non_trivia_token(name_ref.syntax().clone())\n+            .map_or(false, |it| T![.] == it.kind());\n+\n+        return find_node_in_file_compensated(\n+            sema,\n+            original_file,\n+            &record_field.parent_record_lit(),\n+        )\n+        .map(|expr| NameRefKind::RecordExpr { expr, dot_prefix })\n+        .map(make_res);\n     }\n-\n-    fn classify_name_ref(\n-        sema: &Semantics<'_, RootDatabase>,\n-        original_file: &SyntaxNode,\n-        name_ref: ast::NameRef,\n-        parent: SyntaxNode,\n-    ) -> Option<(NameRefContext, QualifierCtx)> {\n-        let nameref = find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n-\n-        let make_res =\n-            |kind| (NameRefContext { nameref: nameref.clone(), kind }, Default::default());\n-\n-        if let Some(record_field) = ast::RecordExprField::for_field_name(&name_ref) {\n-            let dot_prefix = previous_non_trivia_token(name_ref.syntax().clone())\n-                .map_or(false, |it| T![.] == it.kind());\n-\n-            return find_node_in_file_compensated(\n+    if let Some(record_field) = ast::RecordPatField::for_field_name_ref(&name_ref) {\n+        let kind = NameRefKind::Pattern(PatternContext {\n+            param_ctx: None,\n+            has_type_ascription: false,\n+            ref_token: None,\n+            mut_token: None,\n+            record_pat: find_node_in_file_compensated(\n                 sema,\n                 original_file,\n-                &record_field.parent_record_lit(),\n+                &record_field.parent_record_pat(),\n+            ),\n+            ..pattern_context_for(\n+                sema,\n+                original_file,\n+                record_field.parent_record_pat().clone().into(),\n             )\n-            .map(|expr| NameRefKind::RecordExpr { expr, dot_prefix })\n-            .map(make_res);\n+        });\n+        return Some(make_res(kind));\n+    }\n+\n+    let segment = match_ast! {\n+        match parent {\n+            ast::PathSegment(segment) => segment,\n+            ast::FieldExpr(field) => {\n+                let receiver = find_opt_node_in_file(original_file, field.expr());\n+                let receiver_is_ambiguous_float_literal = match &receiver {\n+                    Some(ast::Expr::Literal(l)) => matches! {\n+                        l.kind(),\n+                        ast::LiteralKind::FloatNumber { .. } if l.syntax().last_token().map_or(false, |it| it.text().ends_with('.'))\n+                    },\n+                    _ => false,\n+                };\n+                let kind = NameRefKind::DotAccess(DotAccess {\n+                    receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n+                    kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal },\n+                    receiver\n+                });\n+                return Some(make_res(kind));\n+            },\n+            ast::MethodCallExpr(method) => {\n+                let receiver = find_opt_node_in_file(original_file, method.receiver());\n+                let kind = NameRefKind::DotAccess(DotAccess {\n+                    receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n+                    kind: DotAccessKind::Method { has_parens: method.arg_list().map_or(false, |it| it.l_paren_token().is_some()) },\n+                    receiver\n+                });\n+                return Some(make_res(kind));\n+            },\n+            _ => return None,\n         }\n-        if let Some(record_field) = ast::RecordPatField::for_field_name_ref(&name_ref) {\n-            let kind = NameRefKind::Pattern(PatternContext {\n-                param_ctx: None,\n-                has_type_ascription: false,\n-                ref_token: None,\n-                mut_token: None,\n-                record_pat: find_node_in_file_compensated(\n-                    sema,\n-                    original_file,\n-                    &record_field.parent_record_pat(),\n-                ),\n-                ..pattern_context_for(\n-                    sema,\n-                    original_file,\n-                    record_field.parent_record_pat().clone().into(),\n-                )\n-            });\n-            return Some(make_res(kind));\n+    };\n+\n+    let path = segment.parent_path();\n+    let original_path = find_node_in_file_compensated(sema, original_file, &path);\n+\n+    let mut path_ctx = PathCompletionCtx {\n+        has_call_parens: false,\n+        has_macro_bang: false,\n+        qualified: Qualified::No,\n+        parent: None,\n+        path: path.clone(),\n+        original_path,\n+        kind: PathKind::Item { kind: ItemListKind::SourceFile },\n+        has_type_args: false,\n+        use_tree_parent: false,\n+    };\n+\n+    let is_in_block = |it: &SyntaxNode| {\n+        it.parent()\n+            .map(|node| {\n+                ast::ExprStmt::can_cast(node.kind()) || ast::StmtList::can_cast(node.kind())\n+            })\n+            .unwrap_or(false)\n+    };\n+    let func_update_record = |syn: &SyntaxNode| {\n+        if let Some(record_expr) = syn.ancestors().nth(2).and_then(ast::RecordExpr::cast) {\n+            find_node_in_file_compensated(sema, original_file, &record_expr)\n+        } else {\n+            None\n+        }\n+    };\n+    let after_if_expr = |node: SyntaxNode| {\n+        let prev_expr = (|| {\n+            let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev)?.into_node()?;\n+            ast::ExprStmt::cast(prev_sibling)?.expr()\n+        })();\n+        matches!(prev_expr, Some(ast::Expr::IfExpr(_)))\n+    };\n+\n+    // We do not want to generate path completions when we are sandwiched between an item decl signature and its body.\n+    // ex. trait Foo $0 {}\n+    // in these cases parser recovery usually kicks in for our inserted identifier, causing it\n+    // to either be parsed as an ExprStmt or a MacroCall, depending on whether it is in a block\n+    // expression or an item list.\n+    // The following code checks if the body is missing, if it is we either cut off the body\n+    // from the item or it was missing in the first place\n+    let inbetween_body_and_decl_check = |node: SyntaxNode| {\n+        if let Some(NodeOrToken::Node(n)) =\n+            syntax::algo::non_trivia_sibling(node.into(), syntax::Direction::Prev)\n+        {\n+            if let Some(item) = ast::Item::cast(n) {\n+                let is_inbetween = match &item {\n+                    ast::Item::Const(it) => it.body().is_none(),\n+                    ast::Item::Enum(it) => it.variant_list().is_none(),\n+                    ast::Item::ExternBlock(it) => it.extern_item_list().is_none(),\n+                    ast::Item::Fn(it) => it.body().is_none(),\n+                    ast::Item::Impl(it) => it.assoc_item_list().is_none(),\n+                    ast::Item::Module(it) => it.item_list().is_none(),\n+                    ast::Item::Static(it) => it.body().is_none(),\n+                    ast::Item::Struct(it) => it.field_list().is_none(),\n+                    ast::Item::Trait(it) => it.assoc_item_list().is_none(),\n+                    ast::Item::TypeAlias(it) => it.ty().is_none(),\n+                    ast::Item::Union(it) => it.record_field_list().is_none(),\n+                    _ => false,\n+                };\n+                if is_inbetween {\n+                    return Some(item);\n+                }\n+            }\n         }\n+        None\n+    };\n \n-        let segment = match_ast! {\n+    let type_location = |node: &SyntaxNode| {\n+        let parent = node.parent()?;\n+        let res = match_ast! {\n             match parent {\n-                ast::PathSegment(segment) => segment,\n-                ast::FieldExpr(field) => {\n-                    let receiver = find_opt_node_in_file(original_file, field.expr());\n-                    let receiver_is_ambiguous_float_literal = match &receiver {\n-                        Some(ast::Expr::Literal(l)) => matches! {\n-                            l.kind(),\n-                            ast::LiteralKind::FloatNumber { .. } if l.syntax().last_token().map_or(false, |it| it.text().ends_with('.'))\n-                        },\n-                        _ => false,\n+                ast::Const(it) => {\n+                    let name = find_opt_node_in_file(original_file, it.name())?;\n+                    let original = ast::Const::cast(name.syntax().parent()?)?;\n+                    TypeLocation::TypeAscription(TypeAscriptionTarget::Const(original.body()))\n+                },\n+                ast::RetType(it) => {\n+                    if it.thin_arrow_token().is_none() {\n+                        return None;\n+                    }\n+                    let parent = match ast::Fn::cast(parent.parent()?) {\n+                        Some(x) => x.param_list(),\n+                        None => ast::ClosureExpr::cast(parent.parent()?)?.param_list(),\n                     };\n-                    let kind = NameRefKind::DotAccess(DotAccess {\n-                        receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n-                        kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal },\n-                        receiver\n-                    });\n-                    return Some(make_res(kind));\n+\n+                    let parent = find_opt_node_in_file(original_file, parent)?.syntax().parent()?;\n+                    TypeLocation::TypeAscription(TypeAscriptionTarget::RetType(match_ast! {\n+                        match parent {\n+                            ast::ClosureExpr(it) => {\n+                                it.body()\n+                            },\n+                            ast::Fn(it) => {\n+                                it.body().map(ast::Expr::BlockExpr)\n+                            },\n+                            _ => return None,\n+                        }\n+                    }))\n                 },\n-                ast::MethodCallExpr(method) => {\n-                    let receiver = find_opt_node_in_file(original_file, method.receiver());\n-                    let kind = NameRefKind::DotAccess(DotAccess {\n-                        receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n-                        kind: DotAccessKind::Method { has_parens: method.arg_list().map_or(false, |it| it.l_paren_token().is_some()) },\n-                        receiver\n-                    });\n-                    return Some(make_res(kind));\n+                ast::Param(it) => {\n+                    if it.colon_token().is_none() {\n+                        return None;\n+                    }\n+                    TypeLocation::TypeAscription(TypeAscriptionTarget::FnParam(find_opt_node_in_file(original_file, it.pat())))\n                 },\n+                ast::LetStmt(it) => {\n+                    if it.colon_token().is_none() {\n+                        return None;\n+                    }\n+                    TypeLocation::TypeAscription(TypeAscriptionTarget::Let(find_opt_node_in_file(original_file, it.pat())))\n+                },\n+                ast::Impl(it) => {\n+                    match it.trait_() {\n+                        Some(t) if t.syntax() == node => TypeLocation::ImplTrait,\n+                        _ => match it.self_ty() {\n+                            Some(t) if t.syntax() == node => TypeLocation::ImplTarget,\n+                            _ => return None,\n+                        },\n+                    }\n+                },\n+                ast::TypeBound(_) => TypeLocation::TypeBound,\n+                // is this case needed?\n+                ast::TypeBoundList(_) => TypeLocation::TypeBound,\n+                ast::GenericArg(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(sema, original_file, it.syntax().parent().and_then(ast::GenericArgList::cast))),\n+                // is this case needed?\n+                ast::GenericArgList(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(sema, original_file, Some(it))),\n+                ast::TupleField(_) => TypeLocation::TupleField,\n                 _ => return None,\n             }\n         };\n+        Some(res)\n+    };\n \n-        let path = segment.parent_path();\n-        let original_path = find_node_in_file_compensated(sema, original_file, &path);\n-\n-        let mut path_ctx = PathCompletionCtx {\n-            has_call_parens: false,\n-            has_macro_bang: false,\n-            qualified: Qualified::No,\n-            parent: None,\n-            path: path.clone(),\n-            original_path,\n-            kind: PathKind::Item { kind: ItemListKind::SourceFile },\n-            has_type_args: false,\n-            use_tree_parent: false,\n-        };\n-\n-        let is_in_block = |it: &SyntaxNode| {\n-            it.parent()\n-                .map(|node| {\n-                    ast::ExprStmt::can_cast(node.kind()) || ast::StmtList::can_cast(node.kind())\n-                })\n-                .unwrap_or(false)\n-        };\n-        let func_update_record = |syn: &SyntaxNode| {\n-            if let Some(record_expr) = syn.ancestors().nth(2).and_then(ast::RecordExpr::cast) {\n-                find_node_in_file_compensated(sema, original_file, &record_expr)\n+    let is_in_condition = |it: &ast::Expr| {\n+        (|| {\n+            let parent = it.syntax().parent()?;\n+            if let Some(expr) = ast::WhileExpr::cast(parent.clone()) {\n+                Some(expr.condition()? == *it)\n+            } else if let Some(expr) = ast::IfExpr::cast(parent) {\n+                Some(expr.condition()? == *it)\n             } else {\n                 None\n             }\n-        };\n-        let after_if_expr = |node: SyntaxNode| {\n-            let prev_expr = (|| {\n-                let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev)?.into_node()?;\n-                ast::ExprStmt::cast(prev_sibling)?.expr()\n-            })();\n-            matches!(prev_expr, Some(ast::Expr::IfExpr(_)))\n-        };\n+        })()\n+        .unwrap_or(false)\n+    };\n \n-        // We do not want to generate path completions when we are sandwiched between an item decl signature and its body.\n-        // ex. trait Foo $0 {}\n-        // in these cases parser recovery usually kicks in for our inserted identifier, causing it\n-        // to either be parsed as an ExprStmt or a MacroCall, depending on whether it is in a block\n-        // expression or an item list.\n-        // The following code checks if the body is missing, if it is we either cut off the body\n-        // from the item or it was missing in the first place\n-        let inbetween_body_and_decl_check = |node: SyntaxNode| {\n-            if let Some(NodeOrToken::Node(n)) =\n-                syntax::algo::non_trivia_sibling(node.into(), syntax::Direction::Prev)\n-            {\n-                if let Some(item) = ast::Item::cast(n) {\n-                    let is_inbetween = match &item {\n-                        ast::Item::Const(it) => it.body().is_none(),\n-                        ast::Item::Enum(it) => it.variant_list().is_none(),\n-                        ast::Item::ExternBlock(it) => it.extern_item_list().is_none(),\n-                        ast::Item::Fn(it) => it.body().is_none(),\n-                        ast::Item::Impl(it) => it.assoc_item_list().is_none(),\n-                        ast::Item::Module(it) => it.item_list().is_none(),\n-                        ast::Item::Static(it) => it.body().is_none(),\n-                        ast::Item::Struct(it) => it.field_list().is_none(),\n-                        ast::Item::Trait(it) => it.assoc_item_list().is_none(),\n-                        ast::Item::TypeAlias(it) => it.ty().is_none(),\n-                        ast::Item::Union(it) => it.record_field_list().is_none(),\n-                        _ => false,\n-                    };\n-                    if is_inbetween {\n-                        return Some(item);\n+    let make_path_kind_expr = |expr: ast::Expr| {\n+        let it = expr.syntax();\n+        let in_block_expr = is_in_block(it);\n+        let in_loop_body = is_in_loop_body(it);\n+        let after_if_expr = after_if_expr(it.clone());\n+        let ref_expr_parent =\n+            path.as_single_name_ref().and_then(|_| it.parent()).and_then(ast::RefExpr::cast);\n+        let (innermost_ret_ty, self_param) = {\n+            let find_ret_ty = |it: SyntaxNode| {\n+                if let Some(item) = ast::Item::cast(it.clone()) {\n+                    match item {\n+                        ast::Item::Fn(f) => Some(sema.to_def(&f).map(|it| it.ret_type(sema.db))),\n+                        ast::Item::MacroCall(_) => None,\n+                        _ => Some(None),\n                     }\n-                }\n-            }\n-            None\n-        };\n-\n-        let type_location = |node: &SyntaxNode| {\n-            let parent = node.parent()?;\n-            let res = match_ast! {\n-                match parent {\n-                    ast::Const(it) => {\n-                        let name = find_opt_node_in_file(original_file, it.name())?;\n-                        let original = ast::Const::cast(name.syntax().parent()?)?;\n-                        TypeLocation::TypeAscription(TypeAscriptionTarget::Const(original.body()))\n-                    },\n-                    ast::RetType(it) => {\n-                        if it.thin_arrow_token().is_none() {\n-                            return None;\n-                        }\n-                        let parent = match ast::Fn::cast(parent.parent()?) {\n-                            Some(x) => x.param_list(),\n-                            None => ast::ClosureExpr::cast(parent.parent()?)?.param_list(),\n-                        };\n-\n-                        let parent = find_opt_node_in_file(original_file, parent)?.syntax().parent()?;\n-                        TypeLocation::TypeAscription(TypeAscriptionTarget::RetType(match_ast! {\n-                            match parent {\n-                                ast::ClosureExpr(it) => {\n-                                    it.body()\n-                                },\n-                                ast::Fn(it) => {\n-                                    it.body().map(ast::Expr::BlockExpr)\n-                                },\n-                                _ => return None,\n-                            }\n-                        }))\n-                    },\n-                    ast::Param(it) => {\n-                        if it.colon_token().is_none() {\n-                            return None;\n-                        }\n-                        TypeLocation::TypeAscription(TypeAscriptionTarget::FnParam(find_opt_node_in_file(original_file, it.pat())))\n-                    },\n-                    ast::LetStmt(it) => {\n-                        if it.colon_token().is_none() {\n-                            return None;\n-                        }\n-                        TypeLocation::TypeAscription(TypeAscriptionTarget::Let(find_opt_node_in_file(original_file, it.pat())))\n-                    },\n-                    ast::Impl(it) => {\n-                        match it.trait_() {\n-                            Some(t) if t.syntax() == node => TypeLocation::ImplTrait,\n-                            _ => match it.self_ty() {\n-                                Some(t) if t.syntax() == node => TypeLocation::ImplTarget,\n-                                _ => return None,\n-                            },\n-                        }\n-                    },\n-                    ast::TypeBound(_) => TypeLocation::TypeBound,\n-                    // is this case needed?\n-                    ast::TypeBoundList(_) => TypeLocation::TypeBound,\n-                    ast::GenericArg(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(sema, original_file, it.syntax().parent().and_then(ast::GenericArgList::cast))),\n-                    // is this case needed?\n-                    ast::GenericArgList(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(sema, original_file, Some(it))),\n-                    ast::TupleField(_) => TypeLocation::TupleField,\n-                    _ => return None,\n-                }\n-            };\n-            Some(res)\n-        };\n-\n-        let is_in_condition = |it: &ast::Expr| {\n-            (|| {\n-                let parent = it.syntax().parent()?;\n-                if let Some(expr) = ast::WhileExpr::cast(parent.clone()) {\n-                    Some(expr.condition()? == *it)\n-                } else if let Some(expr) = ast::IfExpr::cast(parent) {\n-                    Some(expr.condition()? == *it)\n                 } else {\n-                    None\n-                }\n-            })()\n-            .unwrap_or(false)\n-        };\n-\n-        let make_path_kind_expr = |expr: ast::Expr| {\n-            let it = expr.syntax();\n-            let in_block_expr = is_in_block(it);\n-            let in_loop_body = is_in_loop_body(it);\n-            let after_if_expr = after_if_expr(it.clone());\n-            let ref_expr_parent =\n-                path.as_single_name_ref().and_then(|_| it.parent()).and_then(ast::RefExpr::cast);\n-            let (innermost_ret_ty, self_param) = {\n-                let find_ret_ty = |it: SyntaxNode| {\n-                    if let Some(item) = ast::Item::cast(it.clone()) {\n-                        match item {\n-                            ast::Item::Fn(f) => {\n-                                Some(sema.to_def(&f).map(|it| it.ret_type(sema.db)))\n-                            }\n-                            ast::Item::MacroCall(_) => None,\n-                            _ => Some(None),\n-                        }\n-                    } else {\n-                        let expr = ast::Expr::cast(it)?;\n-                        let callable = match expr {\n-                            // FIXME\n-                            // ast::Expr::BlockExpr(b) if b.async_token().is_some() || b.try_token().is_some() => sema.type_of_expr(b),\n-                            ast::Expr::ClosureExpr(_) => sema.type_of_expr(&expr),\n-                            _ => return None,\n-                        };\n-                        Some(\n-                            callable\n-                                .and_then(|c| c.adjusted().as_callable(sema.db))\n-                                .map(|it| it.return_type()),\n-                        )\n-                    }\n-                };\n-                let find_fn_self_param = |it| match it {\n-                    ast::Item::Fn(fn_) => {\n-                        Some(sema.to_def(&fn_).and_then(|it| it.self_param(sema.db)))\n-                    }\n-                    ast::Item::MacroCall(_) => None,\n-                    _ => Some(None),\n-                };\n-\n-                match find_node_in_file_compensated(sema, original_file, &expr) {\n-                    Some(it) => {\n-                        let innermost_ret_ty = sema\n-                            .ancestors_with_macros(it.syntax().clone())\n-                            .find_map(find_ret_ty)\n-                            .flatten();\n-\n-                        let self_param = sema\n-                            .ancestors_with_macros(it.syntax().clone())\n-                            .filter_map(ast::Item::cast)\n-                            .find_map(find_fn_self_param)\n-                            .flatten();\n-                        (innermost_ret_ty, self_param)\n-                    }\n-                    None => (None, None),\n+                    let expr = ast::Expr::cast(it)?;\n+                    let callable = match expr {\n+                        // FIXME\n+                        // ast::Expr::BlockExpr(b) if b.async_token().is_some() || b.try_token().is_some() => sema.type_of_expr(b),\n+                        ast::Expr::ClosureExpr(_) => sema.type_of_expr(&expr),\n+                        _ => return None,\n+                    };\n+                    Some(\n+                        callable\n+                            .and_then(|c| c.adjusted().as_callable(sema.db))\n+                            .map(|it| it.return_type()),\n+                    )\n                 }\n             };\n-            let is_func_update = func_update_record(it);\n-            let in_condition = is_in_condition(&expr);\n-            let incomplete_let = it\n-                .parent()\n-                .and_then(ast::LetStmt::cast)\n-                .map_or(false, |it| it.semicolon_token().is_none());\n-            let impl_ = fetch_immediate_impl(sema, original_file, expr.syntax());\n-\n-            let in_match_guard = match it.parent().and_then(ast::MatchArm::cast) {\n-                Some(arm) => arm\n-                    .fat_arrow_token()\n-                    .map_or(true, |arrow| it.text_range().start() < arrow.text_range().start()),\n-                None => false,\n+            let find_fn_self_param = |it| match it {\n+                ast::Item::Fn(fn_) => Some(sema.to_def(&fn_).and_then(|it| it.self_param(sema.db))),\n+                ast::Item::MacroCall(_) => None,\n+                _ => Some(None),\n             };\n \n-            PathKind::Expr {\n-                expr_ctx: ExprCtx {\n-                    in_block_expr,\n-                    in_loop_body,\n-                    after_if_expr,\n-                    in_condition,\n-                    ref_expr_parent,\n-                    is_func_update,\n-                    innermost_ret_ty,\n-                    self_param,\n-                    incomplete_let,\n-                    impl_,\n-                    in_match_guard,\n-                },\n+            match find_node_in_file_compensated(sema, original_file, &expr) {\n+                Some(it) => {\n+                    let innermost_ret_ty = sema\n+                        .ancestors_with_macros(it.syntax().clone())\n+                        .find_map(find_ret_ty)\n+                        .flatten();\n+\n+                    let self_param = sema\n+                        .ancestors_with_macros(it.syntax().clone())\n+                        .filter_map(ast::Item::cast)\n+                        .find_map(find_fn_self_param)\n+                        .flatten();\n+                    (innermost_ret_ty, self_param)\n+                }\n+                None => (None, None),\n             }\n         };\n-        let make_path_kind_type = |ty: ast::Type| {\n-            let location = type_location(ty.syntax());\n-            PathKind::Type { location: location.unwrap_or(TypeLocation::Other) }\n+        let is_func_update = func_update_record(it);\n+        let in_condition = is_in_condition(&expr);\n+        let incomplete_let = it\n+            .parent()\n+            .and_then(ast::LetStmt::cast)\n+            .map_or(false, |it| it.semicolon_token().is_none());\n+        let impl_ = fetch_immediate_impl(sema, original_file, expr.syntax());\n+\n+        let in_match_guard = match it.parent().and_then(ast::MatchArm::cast) {\n+            Some(arm) => arm\n+                .fat_arrow_token()\n+                .map_or(true, |arrow| it.text_range().start() < arrow.text_range().start()),\n+            None => false,\n         };\n \n-        let mut kind_macro_call = |it: ast::MacroCall| {\n-            path_ctx.has_macro_bang = it.excl_token().is_some();\n-            let parent = it.syntax().parent()?;\n-            // Any path in an item list will be treated as a macro call by the parser\n-            let kind = match_ast! {\n-                match parent {\n-                    ast::MacroExpr(expr) => make_path_kind_expr(expr.into()),\n-                    ast::MacroPat(it) => PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())},\n-                    ast::MacroType(ty) => make_path_kind_type(ty.into()),\n-                    ast::ItemList(_) => PathKind::Item { kind: ItemListKind::Module },\n-                    ast::AssocItemList(_) => PathKind::Item { kind: match parent.parent() {\n-                        Some(it) => match_ast! {\n-                            match it {\n-                                ast::Trait(_) => ItemListKind::Trait,\n-                                ast::Impl(it) => if it.trait_().is_some() {\n-                                    ItemListKind::TraitImpl(find_node_in_file_compensated(sema, original_file, &it))\n-                                } else {\n-                                    ItemListKind::Impl\n-                                },\n-                                _ => return None\n-                            }\n-                        },\n-                        None => return None,\n-                    } },\n-                    ast::ExternItemList(_) => PathKind::Item { kind: ItemListKind::ExternBlock },\n-                    ast::SourceFile(_) => PathKind::Item { kind: ItemListKind::SourceFile },\n-                    _ => return None,\n-                }\n-            };\n-            Some(kind)\n-        };\n-        let make_path_kind_attr = |meta: ast::Meta| {\n-            let attr = meta.parent_attr()?;\n-            let kind = attr.kind();\n-            let attached = attr.syntax().parent()?;\n-            let is_trailing_outer_attr = kind != AttrKind::Inner\n-                && non_trivia_sibling(attr.syntax().clone().into(), syntax::Direction::Next)\n-                    .is_none();\n-            let annotated_item_kind =\n-                if is_trailing_outer_attr { None } else { Some(attached.kind()) };\n-            Some(PathKind::Attr { attr_ctx: AttrCtx { kind, annotated_item_kind } })\n-        };\n+        PathKind::Expr {\n+            expr_ctx: ExprCtx {\n+                in_block_expr,\n+                in_loop_body,\n+                after_if_expr,\n+                in_condition,\n+                ref_expr_parent,\n+                is_func_update,\n+                innermost_ret_ty,\n+                self_param,\n+                incomplete_let,\n+                impl_,\n+                in_match_guard,\n+            },\n+        }\n+    };\n+    let make_path_kind_type = |ty: ast::Type| {\n+        let location = type_location(ty.syntax());\n+        PathKind::Type { location: location.unwrap_or(TypeLocation::Other) }\n+    };\n \n-        // Infer the path kind\n-        let parent = path.syntax().parent()?;\n+    let mut kind_macro_call = |it: ast::MacroCall| {\n+        path_ctx.has_macro_bang = it.excl_token().is_some();\n+        let parent = it.syntax().parent()?;\n+        // Any path in an item list will be treated as a macro call by the parser\n         let kind = match_ast! {\n             match parent {\n-                ast::PathType(it) => make_path_kind_type(it.into()),\n-                ast::PathExpr(it) => {\n-                    if let Some(p) = it.syntax().parent() {\n-                        if ast::ExprStmt::can_cast(p.kind()) {\n-                            if let Some(kind) = inbetween_body_and_decl_check(p) {\n-                                return Some(make_res(NameRefKind::Keyword(kind)));\n-                            }\n-                        }\n-                    }\n-\n-                    path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n-\n-                    make_path_kind_expr(it.into())\n-                },\n-                ast::TupleStructPat(it) => {\n-                    path_ctx.has_call_parens = true;\n-                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n-                },\n-                ast::RecordPat(it) => {\n-                    path_ctx.has_call_parens = true;\n-                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n-                },\n-                ast::PathPat(it) => {\n-                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n-                },\n-                ast::MacroCall(it) => {\n-                    // A macro call in this position is usually a result of parsing recovery, so check that\n-                    if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n-                        return Some(make_res(NameRefKind::Keyword(kind)));\n-                    }\n-\n-                    kind_macro_call(it)?\n-                },\n-                ast::Meta(meta) => make_path_kind_attr(meta)?,\n-                ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n-                ast::UseTree(_) => PathKind::Use,\n-                // completing inside a qualifier\n-                ast::Path(parent) => {\n-                    path_ctx.parent = Some(parent.clone());\n-                    let parent = iter::successors(Some(parent), |it| it.parent_path()).last()?.syntax().parent()?;\n-                    match_ast! {\n-                        match parent {\n-                            ast::PathType(it) => make_path_kind_type(it.into()),\n-                            ast::PathExpr(it) => {\n-                                path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n-\n-                                make_path_kind_expr(it.into())\n-                            },\n-                            ast::TupleStructPat(it) => {\n-                                path_ctx.has_call_parens = true;\n-                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n-                            },\n-                            ast::RecordPat(it) => {\n-                                path_ctx.has_call_parens = true;\n-                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n-                            },\n-                            ast::PathPat(it) => {\n-                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n-                            },\n-                            ast::MacroCall(it) => {\n-                                kind_macro_call(it)?\n+                ast::MacroExpr(expr) => make_path_kind_expr(expr.into()),\n+                ast::MacroPat(it) => PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())},\n+                ast::MacroType(ty) => make_path_kind_type(ty.into()),\n+                ast::ItemList(_) => PathKind::Item { kind: ItemListKind::Module },\n+                ast::AssocItemList(_) => PathKind::Item { kind: match parent.parent() {\n+                    Some(it) => match_ast! {\n+                        match it {\n+                            ast::Trait(_) => ItemListKind::Trait,\n+                            ast::Impl(it) => if it.trait_().is_some() {\n+                                ItemListKind::TraitImpl(find_node_in_file_compensated(sema, original_file, &it))\n+                            } else {\n+                                ItemListKind::Impl\n                             },\n-                            ast::Meta(meta) => make_path_kind_attr(meta)?,\n-                            ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n-                            ast::UseTree(_) => PathKind::Use,\n-                            ast::RecordExpr(it) => make_path_kind_expr(it.into()),\n-                            _ => return None,\n+                            _ => return None\n                         }\n-                    }\n-                },\n-                ast::RecordExpr(it) => make_path_kind_expr(it.into()),\n+                    },\n+                    None => return None,\n+                } },\n+                ast::ExternItemList(_) => PathKind::Item { kind: ItemListKind::ExternBlock },\n+                ast::SourceFile(_) => PathKind::Item { kind: ItemListKind::SourceFile },\n                 _ => return None,\n             }\n         };\n+        Some(kind)\n+    };\n+    let make_path_kind_attr = |meta: ast::Meta| {\n+        let attr = meta.parent_attr()?;\n+        let kind = attr.kind();\n+        let attached = attr.syntax().parent()?;\n+        let is_trailing_outer_attr = kind != AttrKind::Inner\n+            && non_trivia_sibling(attr.syntax().clone().into(), syntax::Direction::Next).is_none();\n+        let annotated_item_kind = if is_trailing_outer_attr { None } else { Some(attached.kind()) };\n+        Some(PathKind::Attr { attr_ctx: AttrCtx { kind, annotated_item_kind } })\n+    };\n \n-        path_ctx.kind = kind;\n-        path_ctx.has_type_args = segment.generic_arg_list().is_some();\n+    // Infer the path kind\n+    let parent = path.syntax().parent()?;\n+    let kind = match_ast! {\n+        match parent {\n+            ast::PathType(it) => make_path_kind_type(it.into()),\n+            ast::PathExpr(it) => {\n+                if let Some(p) = it.syntax().parent() {\n+                    if ast::ExprStmt::can_cast(p.kind()) {\n+                        if let Some(kind) = inbetween_body_and_decl_check(p) {\n+                            return Some(make_res(NameRefKind::Keyword(kind)));\n+                        }\n+                    }\n+                }\n \n-        // calculate the qualifier context\n-        if let Some((qualifier, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n-            path_ctx.use_tree_parent = use_tree_parent;\n-            if !use_tree_parent && segment.coloncolon_token().is_some() {\n-                path_ctx.qualified = Qualified::Absolute;\n-            } else {\n-                let qualifier = qualifier\n-                    .segment()\n-                    .and_then(|it| find_node_in_file(original_file, &it))\n-                    .map(|it| it.parent_path());\n-                if let Some(qualifier) = qualifier {\n-                    let type_anchor = match qualifier.segment().and_then(|it| it.kind()) {\n-                        Some(ast::PathSegmentKind::Type {\n-                            type_ref: Some(type_ref),\n-                            trait_ref,\n-                        }) if qualifier.qualifier().is_none() => Some((type_ref, trait_ref)),\n-                        _ => None,\n-                    };\n+                path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n+\n+                make_path_kind_expr(it.into())\n+            },\n+            ast::TupleStructPat(it) => {\n+                path_ctx.has_call_parens = true;\n+                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+            },\n+            ast::RecordPat(it) => {\n+                path_ctx.has_call_parens = true;\n+                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+            },\n+            ast::PathPat(it) => {\n+                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n+            },\n+            ast::MacroCall(it) => {\n+                // A macro call in this position is usually a result of parsing recovery, so check that\n+                if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n+                    return Some(make_res(NameRefKind::Keyword(kind)));\n+                }\n \n-                    path_ctx.qualified = if let Some((ty, trait_ref)) = type_anchor {\n-                        let ty = match ty {\n-                            ast::Type::InferType(_) => None,\n-                            ty => sema.resolve_type(&ty),\n-                        };\n-                        let trait_ = trait_ref.and_then(|it| sema.resolve_trait(&it.path()?));\n-                        Qualified::TypeAnchor { ty, trait_ }\n-                    } else {\n-                        let res = sema.resolve_path(&qualifier);\n-\n-                        // For understanding how and why super_chain_len is calculated the way it\n-                        // is check the documentation at it's definition\n-                        let mut segment_count = 0;\n-                        let super_count =\n-                            iter::successors(Some(qualifier.clone()), |p| p.qualifier())\n-                                .take_while(|p| {\n-                                    p.segment()\n-                                        .and_then(|s| {\n-                                            segment_count += 1;\n-                                            s.super_token()\n-                                        })\n-                                        .is_some()\n-                                })\n-                                .count();\n+                kind_macro_call(it)?\n+            },\n+            ast::Meta(meta) => make_path_kind_attr(meta)?,\n+            ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n+            ast::UseTree(_) => PathKind::Use,\n+            // completing inside a qualifier\n+            ast::Path(parent) => {\n+                path_ctx.parent = Some(parent.clone());\n+                let parent = iter::successors(Some(parent), |it| it.parent_path()).last()?.syntax().parent()?;\n+                match_ast! {\n+                    match parent {\n+                        ast::PathType(it) => make_path_kind_type(it.into()),\n+                        ast::PathExpr(it) => {\n+                            path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n+\n+                            make_path_kind_expr(it.into())\n+                        },\n+                        ast::TupleStructPat(it) => {\n+                            path_ctx.has_call_parens = true;\n+                            PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                        },\n+                        ast::RecordPat(it) => {\n+                            path_ctx.has_call_parens = true;\n+                            PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                        },\n+                        ast::PathPat(it) => {\n+                            PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n+                        },\n+                        ast::MacroCall(it) => {\n+                            kind_macro_call(it)?\n+                        },\n+                        ast::Meta(meta) => make_path_kind_attr(meta)?,\n+                        ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n+                        ast::UseTree(_) => PathKind::Use,\n+                        ast::RecordExpr(it) => make_path_kind_expr(it.into()),\n+                        _ => return None,\n+                    }\n+                }\n+            },\n+            ast::RecordExpr(it) => make_path_kind_expr(it.into()),\n+            _ => return None,\n+        }\n+    };\n \n-                        let super_chain_len =\n-                            if segment_count > super_count { None } else { Some(super_count) };\n+    path_ctx.kind = kind;\n+    path_ctx.has_type_args = segment.generic_arg_list().is_some();\n \n-                        Qualified::With { path: qualifier, resolution: res, super_chain_len }\n+    // calculate the qualifier context\n+    if let Some((qualifier, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n+        path_ctx.use_tree_parent = use_tree_parent;\n+        if !use_tree_parent && segment.coloncolon_token().is_some() {\n+            path_ctx.qualified = Qualified::Absolute;\n+        } else {\n+            let qualifier = qualifier\n+                .segment()\n+                .and_then(|it| find_node_in_file(original_file, &it))\n+                .map(|it| it.parent_path());\n+            if let Some(qualifier) = qualifier {\n+                let type_anchor = match qualifier.segment().and_then(|it| it.kind()) {\n+                    Some(ast::PathSegmentKind::Type { type_ref: Some(type_ref), trait_ref })\n+                        if qualifier.qualifier().is_none() =>\n+                    {\n+                        Some((type_ref, trait_ref))\n                     }\n+                    _ => None,\n                 };\n-            }\n-        } else if let Some(segment) = path.segment() {\n-            if segment.coloncolon_token().is_some() {\n-                path_ctx.qualified = Qualified::Absolute;\n-            }\n-        }\n \n-        let mut qualifier_ctx = QualifierCtx::default();\n-        if path_ctx.is_trivial_path() {\n-            // fetch the full expression that may have qualifiers attached to it\n-            let top_node = match path_ctx.kind {\n-                PathKind::Expr { expr_ctx: ExprCtx { in_block_expr: true, .. } } => {\n-                    parent.ancestors().find(|it| ast::PathExpr::can_cast(it.kind())).and_then(|p| {\n-                        let parent = p.parent()?;\n-                        if ast::StmtList::can_cast(parent.kind()) {\n-                            Some(p)\n-                        } else if ast::ExprStmt::can_cast(parent.kind()) {\n-                            Some(parent)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                }\n-                PathKind::Item { .. } => {\n-                    parent.ancestors().find(|it| ast::MacroCall::can_cast(it.kind()))\n+                path_ctx.qualified = if let Some((ty, trait_ref)) = type_anchor {\n+                    let ty = match ty {\n+                        ast::Type::InferType(_) => None,\n+                        ty => sema.resolve_type(&ty),\n+                    };\n+                    let trait_ = trait_ref.and_then(|it| sema.resolve_trait(&it.path()?));\n+                    Qualified::TypeAnchor { ty, trait_ }\n+                } else {\n+                    let res = sema.resolve_path(&qualifier);\n+\n+                    // For understanding how and why super_chain_len is calculated the way it\n+                    // is check the documentation at it's definition\n+                    let mut segment_count = 0;\n+                    let super_count = iter::successors(Some(qualifier.clone()), |p| p.qualifier())\n+                        .take_while(|p| {\n+                            p.segment()\n+                                .and_then(|s| {\n+                                    segment_count += 1;\n+                                    s.super_token()\n+                                })\n+                                .is_some()\n+                        })\n+                        .count();\n+\n+                    let super_chain_len =\n+                        if segment_count > super_count { None } else { Some(super_count) };\n+\n+                    Qualified::With { path: qualifier, resolution: res, super_chain_len }\n                 }\n-                _ => None,\n             };\n-            if let Some(top) = top_node {\n-                if let Some(NodeOrToken::Node(error_node)) =\n-                    syntax::algo::non_trivia_sibling(top.clone().into(), syntax::Direction::Prev)\n-                {\n-                    if error_node.kind() == SyntaxKind::ERROR {\n-                        qualifier_ctx.unsafe_tok = error_node\n-                            .children_with_tokens()\n-                            .filter_map(NodeOrToken::into_token)\n-                            .find(|it| it.kind() == T![unsafe]);\n-                        qualifier_ctx.vis_node =\n-                            error_node.children().find_map(ast::Visibility::cast);\n+        }\n+    } else if let Some(segment) = path.segment() {\n+        if segment.coloncolon_token().is_some() {\n+            path_ctx.qualified = Qualified::Absolute;\n+        }\n+    }\n+\n+    let mut qualifier_ctx = QualifierCtx::default();\n+    if path_ctx.is_trivial_path() {\n+        // fetch the full expression that may have qualifiers attached to it\n+        let top_node = match path_ctx.kind {\n+            PathKind::Expr { expr_ctx: ExprCtx { in_block_expr: true, .. } } => {\n+                parent.ancestors().find(|it| ast::PathExpr::can_cast(it.kind())).and_then(|p| {\n+                    let parent = p.parent()?;\n+                    if ast::StmtList::can_cast(parent.kind()) {\n+                        Some(p)\n+                    } else if ast::ExprStmt::can_cast(parent.kind()) {\n+                        Some(parent)\n+                    } else {\n+                        None\n                     }\n+                })\n+            }\n+            PathKind::Item { .. } => {\n+                parent.ancestors().find(|it| ast::MacroCall::can_cast(it.kind()))\n+            }\n+            _ => None,\n+        };\n+        if let Some(top) = top_node {\n+            if let Some(NodeOrToken::Node(error_node)) =\n+                syntax::algo::non_trivia_sibling(top.clone().into(), syntax::Direction::Prev)\n+            {\n+                if error_node.kind() == SyntaxKind::ERROR {\n+                    qualifier_ctx.unsafe_tok = error_node\n+                        .children_with_tokens()\n+                        .filter_map(NodeOrToken::into_token)\n+                        .find(|it| it.kind() == T![unsafe]);\n+                    qualifier_ctx.vis_node = error_node.children().find_map(ast::Visibility::cast);\n                 }\n+            }\n \n-                if let PathKind::Item { .. } = path_ctx.kind {\n-                    if qualifier_ctx.none() {\n-                        if let Some(t) = top.first_token() {\n-                            if let Some(prev) = t\n-                                .prev_token()\n-                                .and_then(|t| syntax::algo::skip_trivia_token(t, Direction::Prev))\n-                            {\n-                                if ![T![;], T!['}'], T!['{']].contains(&prev.kind()) {\n-                                    // This was inferred to be an item position path, but it seems\n-                                    // to be part of some other broken node which leaked into an item\n-                                    // list\n-                                    return None;\n-                                }\n+            if let PathKind::Item { .. } = path_ctx.kind {\n+                if qualifier_ctx.none() {\n+                    if let Some(t) = top.first_token() {\n+                        if let Some(prev) = t\n+                            .prev_token()\n+                            .and_then(|t| syntax::algo::skip_trivia_token(t, Direction::Prev))\n+                        {\n+                            if ![T![;], T!['}'], T!['{']].contains(&prev.kind()) {\n+                                // This was inferred to be an item position path, but it seems\n+                                // to be part of some other broken node which leaked into an item\n+                                // list\n+                                return None;\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n-        Some((NameRefContext { nameref, kind: NameRefKind::Path(path_ctx) }, qualifier_ctx))\n     }\n+    Some((NameRefContext { nameref, kind: NameRefKind::Path(path_ctx) }, qualifier_ctx))\n }\n \n fn pattern_context_for("}, {"sha": "9d0044e55f598870413f74f7ce879d267342482c", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -183,6 +183,7 @@ pub fn completions(\n             CompletionAnalysis::String { original, expanded: Some(expanded) } => {\n                 completions::extern_abi::complete_extern_abi(acc, ctx, expanded);\n                 completions::format_string::format_string(acc, ctx, original, expanded);\n+                completions::env_vars::complete_cargo_env_vars(acc, ctx, expanded);\n             }\n             CompletionAnalysis::UnexpandedAttrTT {\n                 colon_prefix,"}, {"sha": "cf0bcd5c96b2a39e93fed07524c95246f3ff5735", "filename": "crates/ide-db/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -15,9 +15,9 @@ tracing = \"0.1.35\"\n rayon = \"1.5.3\"\n fst = { version = \"0.4.7\", default-features = false }\n rustc-hash = \"1.1.0\"\n-once_cell = \"1.12.0\"\n+once_cell = \"1.15.0\"\n either = \"1.7.0\"\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n arrayvec = \"0.7.2\"\n indexmap = \"1.9.1\"\n memchr = \"2.5.0\""}, {"sha": "371d642c15d1d43b468213be0535284e9dc96d05", "filename": "crates/ide-db/src/imports/merge_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-db%2Fsrc%2Fimports%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-db%2Fsrc%2Fimports%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fimports%2Fmerge_imports.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -225,7 +225,7 @@ fn path_cmp_short(a: &ast::Path, b: &ast::Path) -> Ordering {\n }\n \n /// Compares two paths, if one ends earlier than the other the has_tl parameters decide which is\n-/// greater as a a path that has a tree list should be greater, while one that just ends without\n+/// greater as a path that has a tree list should be greater, while one that just ends without\n /// a tree list should be considered less.\n pub(super) fn use_tree_path_cmp(\n     a: &ast::Path,"}, {"sha": "82b85f2fa5edd58ed58c59aa172c1599bb7c994d", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -239,6 +239,7 @@ impl Definition {\n                 DefWithBody::Function(f) => f.source(db).map(|src| src.syntax().cloned()),\n                 DefWithBody::Const(c) => c.source(db).map(|src| src.syntax().cloned()),\n                 DefWithBody::Static(s) => s.source(db).map(|src| src.syntax().cloned()),\n+                DefWithBody::Variant(v) => v.source(db).map(|src| src.syntax().cloned()),\n             };\n             return match def {\n                 Some(def) => SearchScope::file_range(def.as_ref().original_file_range(db)),"}, {"sha": "2d6927cee9953c2fdd9a1a1e7cdc93d6ba2cbdfa", "filename": "crates/ide-db/src/syntax_helpers/format_string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -1,7 +1,8 @@\n //! Tools to work with format string literals for the `format_args!` family of macros.\n+use crate::syntax_helpers::node_ext::macro_call_for_string_token;\n use syntax::{\n     ast::{self, IsString},\n-    AstNode, AstToken, TextRange, TextSize,\n+    TextRange, TextSize,\n };\n \n pub fn is_format_string(string: &ast::String) -> bool {\n@@ -14,8 +15,7 @@ pub fn is_format_string(string: &ast::String) -> bool {\n     // This setup lets us correctly highlight the components of `concat!(\"{}\", \"bla\")` format\n     // strings. It still fails for `concat!(\"{\", \"}\")`, but that is rare.\n     (|| {\n-        let macro_call = string.syntax().parent_ancestors().find_map(ast::MacroCall::cast)?;\n-        let name = macro_call.path()?.segment()?.name_ref()?;\n+        let name = macro_call_for_string_token(string)?.path()?.segment()?.name_ref()?;\n \n         if !matches!(\n             name.text().as_str(),"}, {"sha": "39710b8f13eb5f7024b8fe2a385ead1badda3a21", "filename": "crates/ide-db/src/syntax_helpers/node_ext.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -2,8 +2,8 @@\n use itertools::Itertools;\n use parser::T;\n use syntax::{\n-    ast::{self, HasLoopBody, PathSegmentKind, VisibilityKind},\n-    AstNode, Preorder, RustLanguage, WalkEvent,\n+    ast::{self, HasLoopBody, MacroCall, PathSegmentKind, VisibilityKind},\n+    AstNode, AstToken, Preorder, RustLanguage, WalkEvent,\n };\n \n pub fn expr_as_name_ref(expr: &ast::Expr) -> Option<ast::NameRef> {\n@@ -457,3 +457,8 @@ pub fn parse_tt_as_comma_sep_paths(input: ast::TokenTree) -> Option<Vec<ast::Pat\n         .collect();\n     Some(paths)\n }\n+\n+pub fn macro_call_for_string_token(string: &ast::String) -> Option<MacroCall> {\n+    let macro_call = string.syntax().parent_ancestors().find_map(ast::MacroCall::cast)?;\n+    Some(macro_call)\n+}"}, {"sha": "e1d146f4ee561f368c7125ee3330d742394ed4e5", "filename": "crates/ide-diagnostics/Cargo.toml", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-diagnostics%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-diagnostics%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -11,11 +11,9 @@ doctest = false\n \n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n-itertools = \"0.10.3\"\n-\n-\n either = \"1.7.0\"\n-serde_json = \"1.0.82\"\n+itertools = \"0.10.5\"\n+serde_json = \"1.0.86\"\n \n profile = { path = \"../profile\", version = \"0.0.0\" }\n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "f558b7256a4c6473aad6f452d57aea3a0bca0fa1", "filename": "crates/ide-diagnostics/src/handlers/inactive_code.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -137,6 +137,37 @@ trait Bar {\n \n     #[cfg_attr(not(never), inline, cfg(no))] fn h() {}\n   //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: no is disabled\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inactive_fields_and_variants() {\n+        check(\n+            r#\"\n+enum Foo {\n+  #[cfg(a)] Bar,\n+//^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+  Baz {\n+    #[cfg(a)] baz: String,\n+  //^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+  },\n+  Qux(#[cfg(a)] String),\n+    //^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+}\n+\n+struct Baz {\n+  #[cfg(a)] baz: String,\n+//^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+}\n+\n+struct Qux(#[cfg(a)] String);\n+         //^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+\n+union FooBar {\n+  #[cfg(a)] baz: u32,\n+//^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+}\n \"#,\n         );\n     }"}, {"sha": "085d8d32598a1301acb9f96512d1f9d7e71a008b", "filename": "crates/ide-diagnostics/src/handlers/incorrect_try_expr.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_try_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_try_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_try_expr.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -0,0 +1,37 @@\n+use hir::InFile;\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: incorrect-try-target\n+//\n+// This diagnostic is triggered if a question mark operator was used in a context where it is not applicable.\n+pub(crate) fn incorrect_try_expr(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::IncorrectTryExpr,\n+) -> Diagnostic {\n+    Diagnostic::new(\n+        \"incorrect-try-target\",\n+        format!(\"the return type of the containing function does not implement `FromResidual`\"),\n+        ctx.sema\n+            .diagnostics_display_range(InFile::new(d.expr.file_id, d.expr.value.clone().into()))\n+            .range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn try_ops_diag() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: try\n+fn test() {\n+    core::ops::ControlFlow::<u32, f32>::Continue(1.0)?;\n+ // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: the return type of the containing function does not implement `FromResidual`\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "3bf6a4232298c7884a69c2ccd072f3483ed554c5", "filename": "crates/ide-diagnostics/src/handlers/not_implemented.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fnot_implemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fnot_implemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fnot_implemented.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -0,0 +1,35 @@\n+use hir::{db::DefDatabase, HirDisplay};\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: not-implemented\n+//\n+// This diagnostic is triggered if a type doesn't implement a necessary trait.\n+pub(crate) fn not_implemented(ctx: &DiagnosticsContext<'_>, d: &hir::NotImplemented) -> Diagnostic {\n+    Diagnostic::new(\n+        \"not-implemented\",\n+        format!(\n+            \"the trait `{}` is not implemented for `{}`\",\n+            ctx.sema.db.trait_data(d.trait_).name,\n+            d.ty.display(ctx.sema.db)\n+        ),\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn missing_try_impl() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: try\n+fn main() {\n+    ()?;\n+} //^^ error: the trait `Try` is not implemented for `()`\n+\"#,\n+        )\n+    }\n+}"}, {"sha": "4577072149a72d7b6d3a0d64f391f1bc5ef6404d", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -29,13 +29,15 @@ mod handlers {\n     pub(crate) mod break_outside_of_loop;\n     pub(crate) mod inactive_code;\n     pub(crate) mod incorrect_case;\n+    pub(crate) mod incorrect_try_expr;\n     pub(crate) mod invalid_derive_target;\n     pub(crate) mod macro_error;\n     pub(crate) mod malformed_derive;\n     pub(crate) mod mismatched_arg_count;\n     pub(crate) mod missing_fields;\n     pub(crate) mod missing_match_arms;\n     pub(crate) mod missing_unsafe;\n+    pub(crate) mod not_implemented;\n     pub(crate) mod no_such_field;\n     pub(crate) mod replace_filter_map_next_with_find_map;\n     pub(crate) mod type_mismatch;\n@@ -225,12 +227,14 @@ pub fn diagnostics(\n         let d = match diag {\n             AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n             AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n+            AnyDiagnostic::IncorrectTryExpr(d) => handlers::incorrect_try_expr::incorrect_try_expr(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => handlers::mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => handlers::missing_fields::missing_fields(&ctx, &d),\n             AnyDiagnostic::MissingMatchArms(d) => handlers::missing_match_arms::missing_match_arms(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => handlers::missing_unsafe::missing_unsafe(&ctx, &d),\n+            AnyDiagnostic::NotImplemented(d) => handlers::not_implemented::not_implemented(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => handlers::no_such_field::no_such_field(&ctx, &d),\n             AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => handlers::replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n             AnyDiagnostic::TypeMismatch(d) => handlers::type_mismatch::type_mismatch(&ctx, &d),"}, {"sha": "4baf786c455525acf462683ac82ab2515ea6bef3", "filename": "crates/ide-ssr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-ssr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide-ssr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-ssr%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -12,8 +12,7 @@ doctest = false\n \n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n-\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n \n text-edit = { path = \"../text-edit\", version = \"0.0.0\" }\n parser = { path = \"../parser\", version = \"0.0.0\" }"}, {"sha": "712459a7ee9c688c3117f38f6546b7f47163b428", "filename": "crates/ide/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -13,12 +13,12 @@ doctest = false\n cov-mark = \"2.0.0-pre.1\"\n crossbeam-channel = \"0.5.5\"\n either = \"1.7.0\"\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n tracing = \"0.1.35\"\n oorandom = \"11.1.3\"\n-pulldown-cmark-to-cmark = \"10.0.1\"\n+pulldown-cmark-to-cmark = \"10.0.4\"\n pulldown-cmark = { version = \"0.9.1\", default-features = false }\n-url = \"2.2.2\"\n+url = \"2.3.1\"\n dot = \"0.1.4\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "f994c284c713a7153cd18f26784f3934099cff09", "filename": "crates/ide/src/annotations.rs", "status": "modified", "additions": 165, "deletions": 99, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fannotations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fannotations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fannotations.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -8,13 +8,15 @@ use ide_db::{\n use syntax::{ast::HasName, AstNode, TextRange};\n \n use crate::{\n-    fn_references::find_all_methods,\n+    annotations::fn_references::find_all_methods,\n     goto_implementation::goto_implementation,\n     references::find_all_refs,\n     runnables::{runnables, Runnable},\n     NavigationTarget, RunnableKind,\n };\n \n+mod fn_references;\n+\n // Feature: Annotations\n //\n // Provides user with annotations above items for looking up references or impl blocks\n@@ -30,8 +32,8 @@ pub struct Annotation {\n #[derive(Debug)]\n pub enum AnnotationKind {\n     Runnable(Runnable),\n-    HasImpls { file_id: FileId, data: Option<Vec<NavigationTarget>> },\n-    HasReferences { file_id: FileId, data: Option<Vec<FileRange>> },\n+    HasImpls { pos: FilePosition, data: Option<Vec<NavigationTarget>> },\n+    HasReferences { pos: FilePosition, data: Option<Vec<FileRange>> },\n }\n \n pub struct AnnotationConfig {\n@@ -68,13 +70,23 @@ pub(crate) fn annotations(\n         }\n     }\n \n+    let mk_ranges = |(range, focus): (_, Option<_>)| {\n+        let cmd_target: TextRange = focus.unwrap_or(range);\n+        let annotation_range = match config.location {\n+            AnnotationLocation::AboveName => cmd_target,\n+            AnnotationLocation::AboveWholeItem => range,\n+        };\n+        let target_pos = FilePosition { file_id, offset: cmd_target.start() };\n+        (annotation_range, target_pos)\n+    };\n+\n     visit_file_defs(&Semantics::new(db), file_id, &mut |def| {\n         let range = match def {\n             Definition::Const(konst) if config.annotate_references => {\n-                konst.source(db).and_then(|node| name_range(db, config, node, file_id))\n+                konst.source(db).and_then(|node| name_range(db, node, file_id))\n             }\n             Definition::Trait(trait_) if config.annotate_references || config.annotate_impls => {\n-                trait_.source(db).and_then(|node| name_range(db, config, node, file_id))\n+                trait_.source(db).and_then(|node| name_range(db, node, file_id))\n             }\n             Definition::Adt(adt) => match adt {\n                 hir::Adt::Enum(enum_) => {\n@@ -83,27 +95,29 @@ pub(crate) fn annotations(\n                             .variants(db)\n                             .into_iter()\n                             .map(|variant| {\n-                                variant\n-                                    .source(db)\n-                                    .and_then(|node| name_range(db, config, node, file_id))\n+                                variant.source(db).and_then(|node| name_range(db, node, file_id))\n                             })\n                             .flatten()\n                             .for_each(|range| {\n+                                let (annotation_range, target_position) = mk_ranges(range);\n                                 annotations.push(Annotation {\n-                                    range,\n-                                    kind: AnnotationKind::HasReferences { file_id, data: None },\n+                                    range: annotation_range,\n+                                    kind: AnnotationKind::HasReferences {\n+                                        pos: target_position,\n+                                        data: None,\n+                                    },\n                                 })\n                             })\n                     }\n                     if config.annotate_references || config.annotate_impls {\n-                        enum_.source(db).and_then(|node| name_range(db, config, node, file_id))\n+                        enum_.source(db).and_then(|node| name_range(db, node, file_id))\n                     } else {\n                         None\n                     }\n                 }\n                 _ => {\n                     if config.annotate_references || config.annotate_impls {\n-                        adt.source(db).and_then(|node| name_range(db, config, node, file_id))\n+                        adt.source(db).and_then(|node| name_range(db, node, file_id))\n                     } else {\n                         None\n                     }\n@@ -116,65 +130,58 @@ pub(crate) fn annotations(\n             Some(range) => range,\n             None => return,\n         };\n-\n+        let (annotation_range, target_pos) = mk_ranges(range);\n         if config.annotate_impls && !matches!(def, Definition::Const(_)) {\n-            annotations\n-                .push(Annotation { range, kind: AnnotationKind::HasImpls { file_id, data: None } });\n+            annotations.push(Annotation {\n+                range: annotation_range,\n+                kind: AnnotationKind::HasImpls { pos: target_pos, data: None },\n+            });\n         }\n \n         if config.annotate_references {\n             annotations.push(Annotation {\n-                range,\n-                kind: AnnotationKind::HasReferences { file_id, data: None },\n+                range: annotation_range,\n+                kind: AnnotationKind::HasReferences { pos: target_pos, data: None },\n             });\n         }\n \n         fn name_range<T: HasName>(\n             db: &RootDatabase,\n-            config: &AnnotationConfig,\n             node: InFile<T>,\n             source_file_id: FileId,\n-        ) -> Option<TextRange> {\n+        ) -> Option<(TextRange, Option<TextRange>)> {\n             if let Some(InFile { file_id, value }) = node.original_ast_node(db) {\n                 if file_id == source_file_id.into() {\n-                    return match config.location {\n-                        AnnotationLocation::AboveName => {\n-                            value.name().map(|name| name.syntax().text_range())\n-                        }\n-                        AnnotationLocation::AboveWholeItem => Some(value.syntax().text_range()),\n-                    };\n+                    return Some((\n+                        value.syntax().text_range(),\n+                        value.name().map(|name| name.syntax().text_range()),\n+                    ));\n                 }\n             }\n             None\n         }\n     });\n \n     if config.annotate_method_references {\n-        annotations.extend(find_all_methods(db, file_id).into_iter().map(\n-            |FileRange { file_id, range }| Annotation {\n-                range,\n-                kind: AnnotationKind::HasReferences { file_id, data: None },\n-            },\n-        ));\n+        annotations.extend(find_all_methods(db, file_id).into_iter().map(|range| {\n+            let (annotation_range, target_range) = mk_ranges(range);\n+            Annotation {\n+                range: annotation_range,\n+                kind: AnnotationKind::HasReferences { pos: target_range, data: None },\n+            }\n+        }));\n     }\n \n     annotations\n }\n \n pub(crate) fn resolve_annotation(db: &RootDatabase, mut annotation: Annotation) -> Annotation {\n     match annotation.kind {\n-        AnnotationKind::HasImpls { file_id, ref mut data } => {\n-            *data =\n-                goto_implementation(db, FilePosition { file_id, offset: annotation.range.start() })\n-                    .map(|range| range.info);\n+        AnnotationKind::HasImpls { pos, ref mut data } => {\n+            *data = goto_implementation(db, pos).map(|range| range.info);\n         }\n-        AnnotationKind::HasReferences { file_id, ref mut data } => {\n-            *data = find_all_refs(\n-                &Semantics::new(db),\n-                FilePosition { file_id, offset: annotation.range.start() },\n-                None,\n-            )\n-            .map(|result| {\n+        AnnotationKind::HasReferences { pos, ref mut data } => {\n+            *data = find_all_refs(&Semantics::new(db), pos, None).map(|result| {\n                 result\n                     .into_iter()\n                     .flat_map(|res| res.references)\n@@ -268,9 +275,12 @@ fn main() {\n                     Annotation {\n                         range: 6..10,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 6,\n+                            },\n                             data: Some(\n                                 [\n                                     FileRange {\n@@ -286,9 +296,12 @@ fn main() {\n                     Annotation {\n                         range: 30..36,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 30,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -297,9 +310,12 @@ fn main() {\n                     Annotation {\n                         range: 53..57,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 53,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -344,9 +360,12 @@ fn main() {\n                     Annotation {\n                         range: 7..11,\n                         kind: HasImpls {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 7,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -355,9 +374,12 @@ fn main() {\n                     Annotation {\n                         range: 7..11,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 7,\n+                            },\n                             data: Some(\n                                 [\n                                     FileRange {\n@@ -373,9 +395,12 @@ fn main() {\n                     Annotation {\n                         range: 17..21,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 17,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -424,9 +449,12 @@ fn main() {\n                     Annotation {\n                         range: 7..11,\n                         kind: HasImpls {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 7,\n+                            },\n                             data: Some(\n                                 [\n                                     NavigationTarget {\n@@ -445,9 +473,12 @@ fn main() {\n                     Annotation {\n                         range: 7..11,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 7,\n+                            },\n                             data: Some(\n                                 [\n                                     FileRange {\n@@ -469,9 +500,12 @@ fn main() {\n                     Annotation {\n                         range: 20..31,\n                         kind: HasImpls {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 20,\n+                            },\n                             data: Some(\n                                 [\n                                     NavigationTarget {\n@@ -490,9 +524,12 @@ fn main() {\n                     Annotation {\n                         range: 20..31,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 20,\n+                            },\n                             data: Some(\n                                 [\n                                     FileRange {\n@@ -508,9 +545,12 @@ fn main() {\n                     Annotation {\n                         range: 69..73,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 69,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -551,9 +591,12 @@ fn main() {}\n                     Annotation {\n                         range: 3..7,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 3,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -602,9 +645,12 @@ fn main() {\n                     Annotation {\n                         range: 7..11,\n                         kind: HasImpls {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 7,\n+                            },\n                             data: Some(\n                                 [\n                                     NavigationTarget {\n@@ -623,9 +669,12 @@ fn main() {\n                     Annotation {\n                         range: 7..11,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 7,\n+                            },\n                             data: Some(\n                                 [\n                                     FileRange {\n@@ -647,9 +696,12 @@ fn main() {\n                     Annotation {\n                         range: 33..44,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 33,\n+                            },\n                             data: Some(\n                                 [\n                                     FileRange {\n@@ -665,9 +717,12 @@ fn main() {\n                     Annotation {\n                         range: 61..65,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 61,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -761,9 +816,12 @@ mod tests {\n                     Annotation {\n                         range: 3..7,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 3,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -821,9 +879,12 @@ struct Foo;\n                     Annotation {\n                         range: 0..71,\n                         kind: HasImpls {\n-                            file_id: FileId(\n-                                0,\n-                            ),\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 67,\n+                            },\n                             data: Some(\n                                 [],\n                             ),\n@@ -832,10 +893,15 @@ struct Foo;\n                     Annotation {\n                         range: 0..71,\n                         kind: HasReferences {\n-                            file_id: FileId(\n-                                0,\n+                            pos: FilePosition {\n+                                file_id: FileId(\n+                                    0,\n+                                ),\n+                                offset: 67,\n+                            },\n+                            data: Some(\n+                                [],\n                             ),\n-                            data: None,\n                         },\n                     },\n                 ]"}, {"sha": "0cadf125fecaec37f3f9e44d9c3c66f614e4e2ba", "filename": "crates/ide/src/annotations/fn_references.rs", "status": "renamed", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fannotations%2Ffn_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fannotations%2Ffn_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fannotations%2Ffn_references.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -4,30 +4,38 @@\n use hir::Semantics;\n use ide_assists::utils::test_related_attribute;\n use ide_db::RootDatabase;\n-use syntax::{ast, ast::HasName, AstNode, SyntaxNode};\n+use syntax::{ast, ast::HasName, AstNode, SyntaxNode, TextRange};\n \n-use crate::{FileId, FileRange};\n+use crate::FileId;\n \n-pub(crate) fn find_all_methods(db: &RootDatabase, file_id: FileId) -> Vec<FileRange> {\n+pub(super) fn find_all_methods(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+) -> Vec<(TextRange, Option<TextRange>)> {\n     let sema = Semantics::new(db);\n     let source_file = sema.parse(file_id);\n-    source_file.syntax().descendants().filter_map(|it| method_range(it, file_id)).collect()\n+    source_file.syntax().descendants().filter_map(|it| method_range(it)).collect()\n }\n \n-fn method_range(item: SyntaxNode, file_id: FileId) -> Option<FileRange> {\n+fn method_range(item: SyntaxNode) -> Option<(TextRange, Option<TextRange>)> {\n     ast::Fn::cast(item).and_then(|fn_def| {\n         if test_related_attribute(&fn_def).is_some() {\n             None\n         } else {\n-            fn_def.name().map(|name| FileRange { file_id, range: name.syntax().text_range() })\n+            Some((\n+                fn_def.syntax().text_range(),\n+                fn_def.name().map(|name| name.syntax().text_range()),\n+            ))\n         }\n     })\n }\n \n #[cfg(test)]\n mod tests {\n+    use syntax::TextRange;\n+\n     use crate::fixture;\n-    use crate::{FileRange, TextSize};\n+    use crate::TextSize;\n     use std::ops::RangeInclusive;\n \n     #[test]\n@@ -42,7 +50,7 @@ mod tests {\n         \"#,\n         );\n \n-        let refs = analysis.find_all_methods(pos.file_id).unwrap();\n+        let refs = super::find_all_methods(&analysis.db, pos.file_id);\n         check_result(&refs, &[3..=13, 27..=33, 47..=57]);\n     }\n \n@@ -57,7 +65,7 @@ mod tests {\n         \"#,\n         );\n \n-        let refs = analysis.find_all_methods(pos.file_id).unwrap();\n+        let refs = super::find_all_methods(&analysis.db, pos.file_id);\n         check_result(&refs, &[19..=22, 35..=38]);\n     }\n \n@@ -78,17 +86,18 @@ mod tests {\n         \"#,\n         );\n \n-        let refs = analysis.find_all_methods(pos.file_id).unwrap();\n+        let refs = super::find_all_methods(&analysis.db, pos.file_id);\n         check_result(&refs, &[28..=34]);\n     }\n \n-    fn check_result(refs: &[FileRange], expected: &[RangeInclusive<u32>]) {\n+    fn check_result(refs: &[(TextRange, Option<TextRange>)], expected: &[RangeInclusive<u32>]) {\n         assert_eq!(refs.len(), expected.len());\n \n-        for (i, item) in refs.iter().enumerate() {\n+        for (i, &(full, focus)) in refs.iter().enumerate() {\n             let range = &expected[i];\n-            assert_eq!(TextSize::from(*range.start()), item.range.start());\n-            assert_eq!(TextSize::from(*range.end()), item.range.end());\n+            let item = focus.unwrap_or(full);\n+            assert_eq!(TextSize::from(*range.start()), item.start());\n+            assert_eq!(TextSize::from(*range.end()), item.end());\n         }\n     }\n }", "previous_filename": "crates/ide/src/fn_references.rs"}, {"sha": "d96827326cfd8a322d5234b6f6765a90271d57c5", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -232,8 +232,13 @@ pub(crate) fn token_as_doc_comment(doc_token: &SyntaxToken) -> Option<DocComment\n     (match_ast! {\n         match doc_token {\n             ast::Comment(comment) => TextSize::try_from(comment.prefix().len()).ok(),\n-            ast::String(string) => doc_token.parent_ancestors().find_map(ast::Attr::cast)\n-                .filter(|attr| attr.simple_name().as_deref() == Some(\"doc\")).and_then(|_| string.open_quote_text_range().map(|it| it.len())),\n+            ast::String(string) => {\n+                doc_token.parent_ancestors().find_map(ast::Attr::cast).filter(|attr| attr.simple_name().as_deref() == Some(\"doc\"))?;\n+                if doc_token.parent_ancestors().find_map(ast::MacroCall::cast).filter(|mac| mac.path().and_then(|p| p.segment()?.name_ref()).as_ref().map(|n| n.text()).as_deref() == Some(\"include_str\")).is_some() {\n+                    return None;\n+                }\n+                string.open_quote_text_range().map(|it| it.len())\n+            },\n             _ => None,\n         }\n     }).map(|prefix_len| DocCommentToken { prefix_len, doc_token: doc_token.clone() })"}, {"sha": "d0be1b3f4047942fd53ef846bea823316709059a", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 56, "deletions": 7, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -48,10 +48,14 @@ pub(crate) fn goto_definition(\n             _ => 1,\n         })?;\n     if let Some(doc_comment) = token_as_doc_comment(&original_token) {\n-        return doc_comment.get_definition_with_descend_at(sema, position.offset, |def, _, _| {\n-            let nav = def.try_to_nav(db)?;\n-            Some(RangeInfo::new(original_token.text_range(), vec![nav]))\n-        });\n+        return doc_comment.get_definition_with_descend_at(\n+            sema,\n+            position.offset,\n+            |def, _, link_range| {\n+                let nav = def.try_to_nav(db)?;\n+                Some(RangeInfo::new(link_range, vec![nav]))\n+            },\n+        );\n     }\n     let navs = sema\n         .descend_into_macros(original_token.clone())\n@@ -95,6 +99,14 @@ fn try_lookup_include_path(\n     if !matches!(&*name.text(), \"include\" | \"include_str\" | \"include_bytes\") {\n         return None;\n     }\n+\n+    // Ignore non-built-in macros to account for shadowing\n+    if let Some(it) = sema.resolve_macro_call(&macro_call) {\n+        if !matches!(it.kind(sema.db), hir::MacroKind::BuiltIn) {\n+            return None;\n+        }\n+    }\n+\n     let file_id = sema.db.resolve_path(AnchoredPath { anchor: file_id, path: &path })?;\n     let size = sema.db.file_text(file_id).len().try_into().ok()?;\n     Some(NavigationTarget {\n@@ -156,9 +168,6 @@ mod tests {\n     fn check(ra_fixture: &str) {\n         let (analysis, position, expected) = fixture::annotations(ra_fixture);\n         let navs = analysis.goto_definition(position).unwrap().expect(\"no definition found\").info;\n-        if navs.is_empty() {\n-            panic!(\"unresolved reference\")\n-        }\n \n         let cmp = |&FileRange { file_id, range }: &_| (file_id, range.start());\n         let navs = navs\n@@ -1348,6 +1357,10 @@ fn f(e: Enum) {\n         check(\n             r#\"\n //- /main.rs\n+\n+#[rustc_builtin_macro]\n+macro_rules! include_str {}\n+\n fn main() {\n     let str = include_str!(\"foo.txt$0\");\n }\n@@ -1357,6 +1370,42 @@ fn main() {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn goto_doc_include_str() {\n+        check(\n+            r#\"\n+//- /main.rs\n+#[rustc_builtin_macro]\n+macro_rules! include_str {}\n+\n+#[doc = include_str!(\"docs.md$0\")]\n+struct Item;\n+\n+//- /docs.md\n+// docs\n+//^file\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_shadow_include() {\n+        check(\n+            r#\"\n+//- /main.rs\n+macro_rules! include {\n+    (\"included.rs\") => {}\n+}\n+\n+include!(\"included.rs$0\");\n+\n+//- /included.rs\n+// empty\n+\"#,\n+        );\n+    }\n+\n     #[cfg(test)]\n     mod goto_impl_of_trait_fn {\n         use super::check;"}, {"sha": "540a115832d3ef0331ec4ca1e829f5d4b4ad603a", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -1373,6 +1373,22 @@ fn main() {\n     ().func$0();\n      //^^^^\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_assoc_type_highlighting() {\n+        check(\n+            r#\"\n+trait Trait {\n+    type Output;\n+      // ^^^^^^\n+}\n+impl Trait for () {\n+    type Output$0 = ();\n+      // ^^^^^^\n+}\n \"#,\n         );\n     }"}, {"sha": "d109c0769194fbdb376da4f55c2f56e49278261e", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -346,7 +346,16 @@ pub(super) fn definition(\n         Definition::Module(it) => label_and_docs(db, it),\n         Definition::Function(it) => label_and_docs(db, it),\n         Definition::Adt(it) => label_and_docs(db, it),\n-        Definition::Variant(it) => label_and_docs(db, it),\n+        Definition::Variant(it) => label_value_and_docs(db, it, |&it| {\n+            if !it.parent_enum(db).is_data_carrying(db) {\n+                match it.eval(db) {\n+                    Ok(x) => Some(format!(\"{}\", x)),\n+                    Err(_) => it.value(db).map(|x| format!(\"{:?}\", x)),\n+                }\n+            } else {\n+                None\n+            }\n+        }),\n         Definition::Const(it) => label_value_and_docs(db, it, |it| {\n             let body = it.eval(db);\n             match body {"}, {"sha": "5cab017a58dbdba582340ca11d9c682bfd58294c", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 155, "deletions": 3, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -698,6 +698,7 @@ fn hover_enum_variant() {\n     check(\n         r#\"\n enum Option<T> {\n+    Some(T)\n     /// The None variant\n     Non$0e\n }\n@@ -3527,6 +3528,112 @@ impl<const LEN: usize> Foo<LEN$0> {}\n     );\n }\n \n+#[test]\n+fn hover_const_eval_variant() {\n+    // show hex for <10\n+    check(\n+        r#\"\n+#[repr(u8)]\n+enum E {\n+    /// This is a doc\n+    A$0 = 1 << 3,\n+}\n+\"#,\n+        expect![[r#\"\n+            *A*\n+\n+            ```rust\n+            test::E\n+            ```\n+\n+            ```rust\n+            A = 8\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n+    // show hex for >10\n+    check(\n+        r#\"\n+#[repr(u8)]\n+enum E {\n+    /// This is a doc\n+    A$0 = (1 << 3) + (1 << 2),\n+}\n+\"#,\n+        expect![[r#\"\n+            *A*\n+\n+            ```rust\n+            test::E\n+            ```\n+\n+            ```rust\n+            A = 12 (0xC)\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n+    // enums in const eval\n+    check(\n+        r#\"\n+#[repr(u8)]\n+enum E {\n+    A = 1,\n+    /// This is a doc\n+    B$0 = E::A as u8 + 1,\n+}\n+\"#,\n+        expect![[r#\"\n+            *B*\n+\n+            ```rust\n+            test::E\n+            ```\n+\n+            ```rust\n+            B = 2\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n+    // unspecified variant should increment by one\n+    check(\n+        r#\"\n+#[repr(u8)]\n+enum E {\n+    A = 4,\n+    /// This is a doc\n+    B$0,\n+}\n+\"#,\n+        expect![[r#\"\n+            *B*\n+\n+            ```rust\n+            test::E\n+            ```\n+\n+            ```rust\n+            B = 5\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn hover_const_eval() {\n     // show hex for <10\n@@ -3820,6 +3927,35 @@ fn foo() {\n \n             ---\n \n+            This is a doc\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+enum E {\n+    /// This is a doc\n+    A = 3,\n+}\n+fn foo(e: E) {\n+    match e {\n+        E::A$0 => (),\n+        _ => ()\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            *A*\n+\n+            ```rust\n+            test::E\n+            ```\n+\n+            ```rust\n+            A = 3\n+            ```\n+\n+            ---\n+\n             This is a doc\n         \"#]],\n     );\n@@ -4777,6 +4913,22 @@ fn foo() -> NotResult<(), Short> {\n                 ```\n             \"#]],\n     );\n+    check_hover_range(\n+        r#\"\n+//- minicore: try\n+use core::ops::ControlFlow;\n+fn foo() -> ControlFlow<()> {\n+    $0ControlFlow::Break(())?$0;\n+    ControlFlow::Continue(())\n+}\n+\"#,\n+        expect![[r#\"\n+            ```text\n+            Try Target Type: ControlFlow<(), {unknown}>\n+            Propagated as:          ControlFlow<(), ()>\n+            ```\n+        \"#]],\n+    );\n }\n \n #[test]\n@@ -4792,9 +4944,9 @@ fn foo() -> Option<()> {\n }\n \"#,\n         expect![[r#\"\n-                ```rust\n-                <Option<i32> as Try>::Output\n-                ```\"#]],\n+            ```rust\n+            i32\n+            ```\"#]],\n     );\n }\n "}, {"sha": "34d8bf67a3016edd55ffe4083870684aa9cb00b6", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -176,12 +176,6 @@ impl fmt::Debug for InlayHintLabelPart {\n // * elided lifetimes\n // * compiler inserted reborrows\n //\n-// |===\n-// | Editor  | Action Name\n-//\n-// | VS Code | **rust-analyzer: Toggle inlay hints*\n-// |===\n-//\n // image::https://user-images.githubusercontent.com/48062697/113020660-b5f98b80-917a-11eb-8d70-3be3fd558cdd.png[]\n pub(crate) fn inlay_hints(\n     db: &RootDatabase,\n@@ -2030,7 +2024,14 @@ impl<T> Vec<T> {\n }\n \n impl<T> IntoIterator for Vec<T> {\n-    type Item=T;\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+}\n+\n+struct IntoIter<T> {}\n+\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n }\n \n fn main() {"}, {"sha": "77fe0dbf5565866dd035718bc009b668cfc0365f", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -31,7 +31,6 @@ mod highlight_related;\n mod expand_macro;\n mod extend_selection;\n mod file_structure;\n-mod fn_references;\n mod folding_ranges;\n mod goto_declaration;\n mod goto_definition;\n@@ -236,7 +235,7 @@ impl Analysis {\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo { repo: None, name: None },\n         );\n         change.change_file(file_id, Some(Arc::new(text)));\n         change.set_crate_graph(crate_graph);\n@@ -429,11 +428,6 @@ impl Analysis {\n         self.with_db(|db| references::find_all_refs(&Semantics::new(db), position, search_scope))\n     }\n \n-    /// Finds all methods and free functions for the file. Does not return tests!\n-    pub fn find_all_methods(&self, file_id: FileId) -> Cancellable<Vec<FileRange>> {\n-        self.with_db(|db| fn_references::find_all_methods(db, file_id))\n-    }\n-\n     /// Returns a short text describing element at position.\n     pub fn hover(\n         &self,"}, {"sha": "852a8fd837616ab3c0a2fb4c1bdf75e99774fe8d", "filename": "crates/ide/src/moniker.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmoniker.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -253,10 +253,14 @@ pub(crate) fn def_to_moniker(\n         },\n         kind: if krate == from_crate { MonikerKind::Export } else { MonikerKind::Import },\n         package_information: {\n-            let name = krate.display_name(db)?.to_string();\n-            let (repo, version) = match krate.origin(db) {\n-                CrateOrigin::CratesIo { repo } => (repo?, krate.version(db)?),\n+            let (name, repo, version) = match krate.origin(db) {\n+                CrateOrigin::CratesIo { repo, name } => (\n+                    name.unwrap_or(krate.display_name(db)?.canonical_name().to_string()),\n+                    repo?,\n+                    krate.version(db)?,\n+                ),\n                 CrateOrigin::Lang(lang) => (\n+                    krate.display_name(db)?.canonical_name().to_string(),\n                     \"https://github.com/rust-lang/rust/\".to_string(),\n                     match lang {\n                         LangCrateOrigin::Other => {"}, {"sha": "e7d0a8be7f57316f2ce92ade5164fc4c9e3f996a", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -87,9 +87,9 @@ fn punctuation(\n     let parent = token.parent();\n     let parent_kind = parent.as_ref().map_or(EOF, SyntaxNode::kind);\n     match (kind, parent_kind) {\n-        (T![?], _) => HlTag::Operator(HlOperator::Other) | HlMod::ControlFlow,\n+        (T![?], TRY_EXPR) => HlTag::Operator(HlOperator::Other) | HlMod::ControlFlow,\n         (T![&], BIN_EXPR) => HlOperator::Bitwise.into(),\n-        (T![&], _) => {\n+        (T![&], REF_EXPR) => {\n             let h = HlTag::Operator(HlOperator::Other).into();\n             let is_unsafe = parent\n                 .and_then(ast::RefExpr::cast)\n@@ -100,7 +100,9 @@ fn punctuation(\n                 h\n             }\n         }\n-        (T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] | T![.], _) => HlOperator::Other.into(),\n+        (T![::] | T![->] | T![=>] | T![..] | T![..=] | T![=] | T![@] | T![.], _) => {\n+            HlOperator::Other.into()\n+        }\n         (T![!], MACRO_CALL | MACRO_RULES) => HlPunct::MacroBang.into(),\n         (T![!], NEVER_TYPE) => HlTag::BuiltinType.into(),\n         (T![!], PREFIX_EXPR) => HlOperator::Logical.into(),\n@@ -129,15 +131,14 @@ fn punctuation(\n         (T![+=] | T![-=] | T![*=] | T![/=] | T![%=], BIN_EXPR) => {\n             Highlight::from(HlOperator::Arithmetic) | HlMod::Mutable\n         }\n-        (T![|] | T![&] | T![!] | T![^] | T![>>] | T![<<], BIN_EXPR) => HlOperator::Bitwise.into(),\n+        (T![|] | T![&] | T![^] | T![>>] | T![<<], BIN_EXPR) => HlOperator::Bitwise.into(),\n         (T![|=] | T![&=] | T![^=] | T![>>=] | T![<<=], BIN_EXPR) => {\n             Highlight::from(HlOperator::Bitwise) | HlMod::Mutable\n         }\n         (T![&&] | T![||], BIN_EXPR) => HlOperator::Logical.into(),\n         (T![>] | T![<] | T![==] | T![>=] | T![<=] | T![!=], BIN_EXPR) => {\n             HlOperator::Comparison.into()\n         }\n-        (_, PREFIX_EXPR | BIN_EXPR | RANGE_EXPR | RANGE_PAT | REST_PAT) => HlOperator::Other.into(),\n         (_, ATTR) => HlTag::AttributeBracket.into(),\n         (kind, _) => match kind {\n             T!['['] | T![']'] => HlPunct::Bracket,"}, {"sha": "9ed65fbc8548d1dba4f1a50bbe2d51f175ccc6f8", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_assoc_functions.html", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_assoc_functions.html", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_assoc_functions.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_assoc_functions.html?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -48,15 +48,15 @@\n \n <span class=\"keyword\">impl</span> <span class=\"struct\">foo</span> <span class=\"brace\">{</span>\n     <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public static\">is_static</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n-    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public reference\">is_not_static</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public reference\">is_not_static</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n <span class=\"brace\">}</span>\n \n <span class=\"keyword\">trait</span> <span class=\"trait declaration\">t</span> <span class=\"brace\">{</span>\n     <span class=\"keyword\">fn</span> <span class=\"function associated declaration static trait\">t_is_static</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">t_is_not_static</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">t_is_not_static</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n <span class=\"brace\">}</span>\n \n <span class=\"keyword\">impl</span> <span class=\"trait\">t</span> <span class=\"keyword\">for</span> <span class=\"struct\">foo</span> <span class=\"brace\">{</span>\n     <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public static trait\">is_static</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n-    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public reference trait\">is_not_static</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public reference trait\">is_not_static</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n <span class=\"brace\">}</span></code></pre>\n\\ No newline at end of file"}, {"sha": "18045f1f55afdb2742da743e2eabe6f8aff6ab7f", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_doctest.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -125,7 +125,7 @@\n     <span class=\"comment documentation\">/// ```sh</span>\n     <span class=\"comment documentation\">/// echo 1</span>\n     <span class=\"comment documentation\">/// ```</span>\n-    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public reference\">foo</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">bool</span> <span class=\"brace\">{</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration public reference\">foo</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">bool</span> <span class=\"brace\">{</span>\n         <span class=\"bool_literal\">true</span>\n     <span class=\"brace\">}</span>\n <span class=\"brace\">}</span>"}, {"sha": "9f2b1926b511d270a9ea5e7ad926ec5c51722788", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_general.html", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_general.html", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_general.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_general.html?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -61,11 +61,11 @@\n <span class=\"brace\">}</span>\n \n <span class=\"keyword\">trait</span> <span class=\"trait declaration\">Bar</span> <span class=\"brace\">{</span>\n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">bar</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span><span class=\"semicolon\">;</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">bar</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span><span class=\"semicolon\">;</span>\n <span class=\"brace\">}</span>\n \n <span class=\"keyword\">impl</span> <span class=\"trait\">Bar</span> <span class=\"keyword\">for</span> <span class=\"struct\">Foo</span> <span class=\"brace\">{</span>\n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">bar</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span> <span class=\"brace\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">bar</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span> <span class=\"brace\">{</span>\n         <span class=\"self_keyword reference\">self</span><span class=\"operator\">.</span><span class=\"field\">x</span>\n     <span class=\"brace\">}</span>\n <span class=\"brace\">}</span>\n@@ -75,11 +75,11 @@\n         <span class=\"value_param\">f</span><span class=\"operator\">.</span><span class=\"function associated consuming\">baz</span><span class=\"parenthesis\">(</span><span class=\"self_keyword consuming mutable\">self</span><span class=\"parenthesis\">)</span>\n     <span class=\"brace\">}</span>\n \n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration mutable reference\">qux</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"keyword\">mut</span> <span class=\"self_keyword declaration mutable reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration mutable reference\">qux</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"keyword\">mut</span> <span class=\"self_keyword declaration mutable reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span>\n         <span class=\"self_keyword mutable reference\">self</span><span class=\"operator\">.</span><span class=\"field\">x</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">0</span><span class=\"semicolon\">;</span>\n     <span class=\"brace\">}</span>\n \n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference\">quop</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span> <span class=\"brace\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference\">quop</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span> <span class=\"brace\">{</span>\n         <span class=\"self_keyword reference\">self</span><span class=\"operator\">.</span><span class=\"field\">x</span>\n     <span class=\"brace\">}</span>\n <span class=\"brace\">}</span>\n@@ -96,11 +96,11 @@\n         <span class=\"value_param\">f</span><span class=\"operator\">.</span><span class=\"function associated\">baz</span><span class=\"parenthesis\">(</span><span class=\"self_keyword\">self</span><span class=\"parenthesis\">)</span>\n     <span class=\"brace\">}</span>\n \n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration mutable reference\">qux</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"keyword\">mut</span> <span class=\"self_keyword declaration mutable reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration mutable reference\">qux</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"keyword\">mut</span> <span class=\"self_keyword declaration mutable reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span>\n         <span class=\"self_keyword mutable reference\">self</span><span class=\"operator\">.</span><span class=\"field\">x</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">0</span><span class=\"semicolon\">;</span>\n     <span class=\"brace\">}</span>\n \n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference\">quop</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">u32</span> <span class=\"brace\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference\">quop</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">u32</span> <span class=\"brace\">{</span>\n         <span class=\"self_keyword reference\">self</span><span class=\"operator\">.</span><span class=\"field\">x</span>\n     <span class=\"brace\">}</span>\n <span class=\"brace\">}</span>"}, {"sha": "abcd80c280bf3d072f990b69352e83241544f8c1", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_injection.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_injection.html", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_injection.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_injection.html?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -42,7 +42,7 @@\n \n .unresolved_reference { color: #FC5555; text-decoration: wavy underline; }\n </style>\n-<pre><code><span class=\"keyword\">fn</span> <span class=\"function declaration\">fixture</span><span class=\"parenthesis\">(</span><span class=\"value_param declaration reference\">ra_fixture</span><span class=\"colon\">:</span> <span class=\"operator\">&</span><span class=\"builtin_type\">str</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n+<pre><code><span class=\"keyword\">fn</span> <span class=\"function declaration\">fixture</span><span class=\"parenthesis\">(</span><span class=\"value_param declaration reference\">ra_fixture</span><span class=\"colon\">:</span> <span class=\"punctuation\">&</span><span class=\"builtin_type\">str</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n \n <span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span>\n     <span class=\"function\">fixture</span><span class=\"parenthesis\">(</span><span class=\"string_literal\">r#\"</span>"}, {"sha": "f98e0b1cda6e920c6a6b884d366d78f33d5cdff8", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_lifetimes.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_lifetimes.html", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_lifetimes.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_lifetimes.html?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -45,8 +45,8 @@\n <pre><code>\n <span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"attribute attribute default_library library\">derive</span><span class=\"parenthesis attribute\">(</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">Foo</span><span class=\"angle\">&lt;</span><span class=\"lifetime declaration\">'a</span><span class=\"comma\">,</span> <span class=\"lifetime declaration\">'b</span><span class=\"comma\">,</span> <span class=\"lifetime declaration\">'c</span><span class=\"angle\">&gt;</span> <span class=\"keyword\">where</span> <span class=\"lifetime\">'a</span><span class=\"colon\">:</span> <span class=\"lifetime\">'a</span><span class=\"comma\">,</span> <span class=\"lifetime\">'static</span><span class=\"colon\">:</span> <span class=\"lifetime\">'static</span> <span class=\"brace\">{</span>\n-    <span class=\"field declaration\">field</span><span class=\"colon\">:</span> <span class=\"operator\">&</span><span class=\"lifetime\">'a</span> <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n-    <span class=\"field declaration\">field2</span><span class=\"colon\">:</span> <span class=\"operator\">&</span><span class=\"lifetime\">'static</span> <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n+    <span class=\"field declaration\">field</span><span class=\"colon\">:</span> <span class=\"punctuation\">&</span><span class=\"lifetime\">'a</span> <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n+    <span class=\"field declaration\">field2</span><span class=\"colon\">:</span> <span class=\"punctuation\">&</span><span class=\"lifetime\">'static</span> <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n <span class=\"brace\">}</span>\n <span class=\"keyword\">impl</span><span class=\"angle\">&lt;</span><span class=\"lifetime declaration\">'a</span><span class=\"angle\">&gt;</span> <span class=\"struct\">Foo</span><span class=\"angle\">&lt;</span><span class=\"lifetime\">'_</span><span class=\"comma\">,</span> <span class=\"lifetime\">'a</span><span class=\"comma\">,</span> <span class=\"lifetime\">'static</span><span class=\"angle\">&gt;</span>\n <span class=\"keyword\">where</span>"}, {"sha": "a626cda3fe8b437c98c09aa9c8f468c2534fa1d0", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_strings.html", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -62,16 +62,16 @@\n         <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n             <span class=\"punctuation\">$</span>crate<span class=\"colon\">:</span><span class=\"colon\">:</span>panicking<span class=\"colon\">:</span><span class=\"colon\">:</span>panic<span class=\"parenthesis\">(</span><span class=\"string_literal\">\"explicit panic\"</span><span class=\"parenthesis\">)</span>\n         <span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n-        <span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>msg<span class=\"colon\">:</span>literal <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"comma\">,</span><span class=\"parenthesis\">)</span><span class=\"operator control\">?</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n+        <span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>msg<span class=\"colon\">:</span>literal <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"comma\">,</span><span class=\"parenthesis\">)</span><span class=\"punctuation\">?</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n             <span class=\"punctuation\">$</span>crate<span class=\"colon\">:</span><span class=\"colon\">:</span>panicking<span class=\"colon\">:</span><span class=\"colon\">:</span>panic<span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>msg<span class=\"parenthesis\">)</span>\n         <span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n         <span class=\"comment\">// Use `panic_str` instead of `panic_display::&lt;&str&gt;` for non_fmt_panic lint.</span>\n-        <span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>msg<span class=\"colon\">:</span>expr <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"comma\">,</span><span class=\"parenthesis\">)</span><span class=\"operator control\">?</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n+        <span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>msg<span class=\"colon\">:</span>expr <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"comma\">,</span><span class=\"parenthesis\">)</span><span class=\"punctuation\">?</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n             <span class=\"punctuation\">$</span>crate<span class=\"colon\">:</span><span class=\"colon\">:</span>panicking<span class=\"colon\">:</span><span class=\"colon\">:</span>panic_str<span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>msg<span class=\"parenthesis\">)</span>\n         <span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n         <span class=\"comment\">// Special-case the single-argument case for const_panic.</span>\n-        <span class=\"parenthesis\">(</span><span class=\"string_literal\">\"{}\"</span><span class=\"comma\">,</span> <span class=\"punctuation\">$</span>arg<span class=\"colon\">:</span>expr <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"comma\">,</span><span class=\"parenthesis\">)</span><span class=\"operator control\">?</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n-            <span class=\"punctuation\">$</span>crate<span class=\"colon\">:</span><span class=\"colon\">:</span>panicking<span class=\"colon\">:</span><span class=\"colon\">:</span>panic_display<span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"punctuation\">$</span>arg<span class=\"parenthesis\">)</span>\n+        <span class=\"parenthesis\">(</span><span class=\"string_literal\">\"{}\"</span><span class=\"comma\">,</span> <span class=\"punctuation\">$</span>arg<span class=\"colon\">:</span>expr <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"comma\">,</span><span class=\"parenthesis\">)</span><span class=\"punctuation\">?</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n+            <span class=\"punctuation\">$</span>crate<span class=\"colon\">:</span><span class=\"colon\">:</span>panicking<span class=\"colon\">:</span><span class=\"colon\">:</span>panic_display<span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"punctuation\">$</span>arg<span class=\"parenthesis\">)</span>\n         <span class=\"parenthesis\">)</span><span class=\"comma\">,</span>\n         <span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>fmt<span class=\"colon\">:</span>expr<span class=\"comma\">,</span> <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>arg<span class=\"colon\">:</span>tt<span class=\"parenthesis\">)</span><span class=\"punctuation\">+</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"parenthesis\">(</span>\n             <span class=\"punctuation\">$</span>crate<span class=\"colon\">:</span><span class=\"colon\">:</span>panicking<span class=\"colon\">:</span><span class=\"colon\">:</span>panic_fmt<span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>crate<span class=\"colon\">:</span><span class=\"colon\">:</span>const_format_args<span class=\"punctuation\">!</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>fmt<span class=\"comma\">,</span> <span class=\"punctuation\">$</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">$</span>arg<span class=\"parenthesis\">)</span><span class=\"punctuation\">+</span><span class=\"parenthesis\">)</span><span class=\"parenthesis\">)</span>"}, {"sha": "1992bdc6ae35f3861fbef26415ebdca75be2ae95", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_unsafe.html", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_unsafe.html", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_unsafe.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_unsafe.html?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -49,7 +49,7 @@\n <span class=\"brace\">}</span>\n <span class=\"keyword\">macro_rules</span><span class=\"macro_bang\">!</span> <span class=\"macro declaration\">unsafe_deref</span> <span class=\"brace\">{</span>\n     <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"operator\">=</span><span class=\"angle\">&gt;</span> <span class=\"brace\">{</span>\n-        <span class=\"punctuation\">*</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"keyword\">as</span> <span class=\"punctuation\">*</span><span class=\"keyword\">const</span> <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span><span class=\"parenthesis\">)</span>\n+        <span class=\"punctuation\">*</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"keyword\">as</span> <span class=\"punctuation\">*</span><span class=\"keyword\">const</span> <span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span><span class=\"parenthesis\">)</span>\n     <span class=\"brace\">}</span><span class=\"semicolon\">;</span>\n <span class=\"brace\">}</span>\n <span class=\"keyword\">static</span> <span class=\"keyword\">mut</span> <span class=\"static declaration mutable unsafe\">MUT_GLOBAL</span><span class=\"colon\">:</span> <span class=\"struct\">Struct</span> <span class=\"operator\">=</span> <span class=\"struct\">Struct</span> <span class=\"brace\">{</span> <span class=\"field\">field</span><span class=\"colon\">:</span> <span class=\"numeric_literal\">0</span> <span class=\"brace\">}</span><span class=\"semicolon\">;</span>\n@@ -63,7 +63,7 @@\n \n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">Struct</span> <span class=\"brace\">{</span> <span class=\"field declaration\">field</span><span class=\"colon\">:</span> <span class=\"builtin_type\">i32</span> <span class=\"brace\">}</span>\n <span class=\"keyword\">impl</span> <span class=\"struct\">Struct</span> <span class=\"brace\">{</span>\n-    <span class=\"keyword unsafe\">unsafe</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference unsafe\">unsafe_method</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n+    <span class=\"keyword unsafe\">unsafe</span> <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference unsafe\">unsafe_method</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n <span class=\"brace\">}</span>\n \n <span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"builtin_attr attribute library\">repr</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">packed</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n@@ -78,11 +78,11 @@\n <span class=\"keyword\">fn</span> <span class=\"function declaration\">unsafe_trait_bound</span><span class=\"angle\">&lt;</span><span class=\"type_param declaration\">T</span><span class=\"colon\">:</span> <span class=\"trait\">UnsafeTrait</span><span class=\"angle\">&gt;</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">_</span><span class=\"colon\">:</span> <span class=\"type_param\">T</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n \n <span class=\"keyword\">trait</span> <span class=\"trait declaration\">DoTheAutoref</span> <span class=\"brace\">{</span>\n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">calls_autoref</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span><span class=\"semicolon\">;</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">calls_autoref</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span><span class=\"semicolon\">;</span>\n <span class=\"brace\">}</span>\n \n <span class=\"keyword\">impl</span> <span class=\"trait\">DoTheAutoref</span> <span class=\"keyword\">for</span> <span class=\"builtin_type\">u16</span> <span class=\"brace\">{</span>\n-    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">calls_autoref</span><span class=\"parenthesis\">(</span><span class=\"operator\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function associated declaration reference trait\">calls_autoref</span><span class=\"parenthesis\">(</span><span class=\"punctuation\">&</span><span class=\"self_keyword declaration reference\">self</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n <span class=\"brace\">}</span>\n \n <span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span>"}, {"sha": "13cd8901031d526c91c7d9561a8e647e0d738242", "filename": "crates/mbe/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fmbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fmbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -12,7 +12,7 @@ doctest = false\n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n rustc-hash = \"1.1.0\"\n-smallvec = \"1.9.0\"\n+smallvec = \"1.10.0\"\n tracing = \"0.1.35\"\n \n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "9c92bae6a1962d593219c3d869bb0c454967ec78", "filename": "crates/mbe/src/benchmark.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fbenchmark.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -8,7 +8,7 @@ use syntax::{\n use test_utils::{bench, bench_fixture, skip_slow_tests};\n \n use crate::{\n-    parser::{Op, RepeatKind, Separator},\n+    parser::{MetaVarKind, Op, RepeatKind, Separator},\n     syntax_node_to_token_tree, DeclarativeMacro,\n };\n \n@@ -111,35 +111,35 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n \n     fn collect_from_op(op: &Op, parent: &mut tt::Subtree, seed: &mut usize) {\n         return match op {\n-            Op::Var { kind, .. } => match kind.as_ref().map(|it| it.as_str()) {\n-                Some(\"ident\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"ty\") => parent.token_trees.push(make_ident(\"Foo\")),\n-                Some(\"tt\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"vis\") => parent.token_trees.push(make_ident(\"pub\")),\n-                Some(\"pat\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"path\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"literal\") => parent.token_trees.push(make_literal(\"1\")),\n-                Some(\"expr\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"lifetime\") => {\n+            Op::Var { kind, .. } => match kind.as_ref() {\n+                Some(MetaVarKind::Ident) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Ty) => parent.token_trees.push(make_ident(\"Foo\")),\n+                Some(MetaVarKind::Tt) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Vis) => parent.token_trees.push(make_ident(\"pub\")),\n+                Some(MetaVarKind::Pat) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Path) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Literal) => parent.token_trees.push(make_literal(\"1\")),\n+                Some(MetaVarKind::Expr) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Lifetime) => {\n                     parent.token_trees.push(make_punct('\\''));\n                     parent.token_trees.push(make_ident(\"a\"));\n                 }\n-                Some(\"block\") => {\n+                Some(MetaVarKind::Block) => {\n                     parent.token_trees.push(make_subtree(tt::DelimiterKind::Brace, None))\n                 }\n-                Some(\"item\") => {\n+                Some(MetaVarKind::Item) => {\n                     parent.token_trees.push(make_ident(\"fn\"));\n                     parent.token_trees.push(make_ident(\"foo\"));\n                     parent.token_trees.push(make_subtree(tt::DelimiterKind::Parenthesis, None));\n                     parent.token_trees.push(make_subtree(tt::DelimiterKind::Brace, None));\n                 }\n-                Some(\"meta\") => {\n+                Some(MetaVarKind::Meta) => {\n                     parent.token_trees.push(make_ident(\"foo\"));\n                     parent.token_trees.push(make_subtree(tt::DelimiterKind::Parenthesis, None));\n                 }\n \n                 None => (),\n-                Some(kind) => panic!(\"Unhandled kind {}\", kind),\n+                Some(kind) => panic!(\"Unhandled kind {:?}\", kind),\n             },\n             Op::Leaf(leaf) => parent.token_trees.push(leaf.clone().into()),\n             Op::Repeat { tokens, kind, separator } => {"}, {"sha": "100ec6bfb93ac17e3cf0006c8c65ed78c5e7b646", "filename": "crates/mbe/src/expander.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fmbe%2Fsrc%2Fexpander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fmbe%2Fsrc%2Fexpander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -8,7 +8,7 @@ mod transcriber;\n use rustc_hash::FxHashMap;\n use syntax::SmolStr;\n \n-use crate::{ExpandError, ExpandResult};\n+use crate::{parser::MetaVarKind, ExpandError, ExpandResult};\n \n pub(crate) fn expand_rules(\n     rules: &[crate::Rule],\n@@ -104,6 +104,7 @@ enum Binding {\n     Fragment(Fragment),\n     Nested(Vec<Binding>),\n     Empty,\n+    Missing(MetaVarKind),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "3f656df25f7d4e04398ed1df21bc046dc0c35d2c", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -66,7 +66,7 @@ use syntax::SmolStr;\n \n use crate::{\n     expander::{Binding, Bindings, ExpandResult, Fragment},\n-    parser::{Op, RepeatKind, Separator},\n+    parser::{MetaVarKind, Op, RepeatKind, Separator},\n     tt_iter::TtIter,\n     ExpandError, MetaTemplate,\n };\n@@ -119,6 +119,7 @@ pub(super) fn match_(pattern: &MetaTemplate, input: &tt::Subtree) -> Match {\n             .map(|it| match it {\n                 Binding::Fragment(_) => 1,\n                 Binding::Empty => 1,\n+                Binding::Missing(_) => 1,\n                 Binding::Nested(it) => count(it.iter()),\n             })\n             .sum()\n@@ -130,6 +131,7 @@ enum BindingKind {\n     Empty(SmolStr),\n     Optional(SmolStr),\n     Fragment(SmolStr, Fragment),\n+    Missing(SmolStr, MetaVarKind),\n     Nested(usize, usize),\n }\n \n@@ -190,6 +192,10 @@ impl BindingsBuilder {\n             .push(LinkNode::Node(Rc::new(BindingKind::Fragment(var.clone(), fragment))));\n     }\n \n+    fn push_missing(&mut self, idx: &mut BindingsIdx, var: &SmolStr, kind: MetaVarKind) {\n+        self.nodes[idx.0].push(LinkNode::Node(Rc::new(BindingKind::Missing(var.clone(), kind))));\n+    }\n+\n     fn push_nested(&mut self, parent: &mut BindingsIdx, child: &BindingsIdx) {\n         let BindingsIdx(idx, nidx) = self.copy(child);\n         self.nodes[parent.0].push(LinkNode::Node(Rc::new(BindingKind::Nested(idx, nidx))));\n@@ -222,6 +228,9 @@ impl BindingsBuilder {\n                 BindingKind::Fragment(name, fragment) => {\n                     bindings.inner.insert(name.clone(), Binding::Fragment(fragment.clone()));\n                 }\n+                BindingKind::Missing(name, kind) => {\n+                    bindings.inner.insert(name.clone(), Binding::Missing(*kind));\n+                }\n                 BindingKind::Nested(idx, nested_idx) => {\n                     let mut nested_nodes = Vec::new();\n                     self.collect_nested(*idx, *nested_idx, &mut nested_nodes);\n@@ -458,9 +467,9 @@ fn match_loop_inner<'t>(\n                 }\n             }\n             OpDelimited::Op(Op::Var { kind, name, .. }) => {\n-                if let Some(kind) = kind {\n+                if let &Some(kind) = kind {\n                     let mut fork = src.clone();\n-                    let match_res = match_meta_var(kind.as_str(), &mut fork);\n+                    let match_res = match_meta_var(kind, &mut fork);\n                     match match_res.err {\n                         None => {\n                             // Some meta variables are optional (e.g. vis)\n@@ -475,8 +484,15 @@ fn match_loop_inner<'t>(\n                         }\n                         Some(err) => {\n                             res.add_err(err);\n-                            if let Some(fragment) = match_res.value {\n-                                bindings_builder.push_fragment(&mut item.bindings, name, fragment);\n+                            match match_res.value {\n+                                Some(fragment) => bindings_builder.push_fragment(\n+                                    &mut item.bindings,\n+                                    name,\n+                                    fragment,\n+                                ),\n+                                None => {\n+                                    bindings_builder.push_missing(&mut item.bindings, name, kind)\n+                                }\n                             }\n                             item.is_error = true;\n                             error_items.push(item);\n@@ -668,20 +684,20 @@ fn match_leaf(lhs: &tt::Leaf, src: &mut TtIter<'_>) -> Result<(), ExpandError> {\n     }\n }\n \n-fn match_meta_var(kind: &str, input: &mut TtIter<'_>) -> ExpandResult<Option<Fragment>> {\n+fn match_meta_var(kind: MetaVarKind, input: &mut TtIter<'_>) -> ExpandResult<Option<Fragment>> {\n     let fragment = match kind {\n-        \"path\" => parser::PrefixEntryPoint::Path,\n-        \"ty\" => parser::PrefixEntryPoint::Ty,\n+        MetaVarKind::Path => parser::PrefixEntryPoint::Path,\n+        MetaVarKind::Ty => parser::PrefixEntryPoint::Ty,\n         // FIXME: These two should actually behave differently depending on the edition.\n         //\n         // https://doc.rust-lang.org/edition-guide/rust-2021/or-patterns-macro-rules.html\n-        \"pat\" | \"pat_param\" => parser::PrefixEntryPoint::Pat,\n-        \"stmt\" => parser::PrefixEntryPoint::Stmt,\n-        \"block\" => parser::PrefixEntryPoint::Block,\n-        \"meta\" => parser::PrefixEntryPoint::MetaItem,\n-        \"item\" => parser::PrefixEntryPoint::Item,\n-        \"vis\" => parser::PrefixEntryPoint::Vis,\n-        \"expr\" => {\n+        MetaVarKind::Pat | MetaVarKind::PatParam => parser::PrefixEntryPoint::Pat,\n+        MetaVarKind::Stmt => parser::PrefixEntryPoint::Stmt,\n+        MetaVarKind::Block => parser::PrefixEntryPoint::Block,\n+        MetaVarKind::Meta => parser::PrefixEntryPoint::MetaItem,\n+        MetaVarKind::Item => parser::PrefixEntryPoint::Item,\n+        MetaVarKind::Vis => parser::PrefixEntryPoint::Vis,\n+        MetaVarKind::Expr => {\n             // `expr` should not match underscores.\n             // HACK: Macro expansion should not be done using \"rollback and try another alternative\".\n             // rustc [explicitly checks the next token][0].\n@@ -698,17 +714,17 @@ fn match_meta_var(kind: &str, input: &mut TtIter<'_>) -> ExpandResult<Option<Fra\n         }\n         _ => {\n             let tt_result = match kind {\n-                \"ident\" => input\n+                MetaVarKind::Ident => input\n                     .expect_ident()\n                     .map(|ident| tt::Leaf::from(ident.clone()).into())\n                     .map_err(|()| ExpandError::binding_error(\"expected ident\")),\n-                \"tt\" => input\n+                MetaVarKind::Tt => input\n                     .expect_tt()\n                     .map_err(|()| ExpandError::binding_error(\"expected token tree\")),\n-                \"lifetime\" => input\n+                MetaVarKind::Lifetime => input\n                     .expect_lifetime()\n                     .map_err(|()| ExpandError::binding_error(\"expected lifetime\")),\n-                \"literal\" => {\n+                MetaVarKind::Literal => {\n                     let neg = input.eat_char('-');\n                     input\n                         .expect_literal()"}, {"sha": "cbb59ab8e67b5f5278a35c3f5c6c9a7368ad5e14", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -6,7 +6,7 @@ use tt::{Delimiter, Subtree};\n \n use crate::{\n     expander::{Binding, Bindings, Fragment},\n-    parser::{Op, RepeatKind, Separator},\n+    parser::{MetaVarKind, Op, RepeatKind, Separator},\n     ExpandError, ExpandResult, MetaTemplate,\n };\n \n@@ -15,7 +15,7 @@ impl Bindings {\n         self.inner.contains_key(name)\n     }\n \n-    fn get(&self, name: &str, nesting: &mut [NestingState]) -> Result<&Fragment, ExpandError> {\n+    fn get(&self, name: &str, nesting: &mut [NestingState]) -> Result<Fragment, ExpandError> {\n         macro_rules! binding_err {\n             ($($arg:tt)*) => { ExpandError::binding_error(format!($($arg)*)) };\n         }\n@@ -26,6 +26,7 @@ impl Bindings {\n             nesting_state.hit = true;\n             b = match b {\n                 Binding::Fragment(_) => break,\n+                Binding::Missing(_) => break,\n                 Binding::Nested(bs) => bs.get(nesting_state.idx).ok_or_else(|| {\n                     nesting_state.at_end = true;\n                     binding_err!(\"could not find nested binding `{name}`\")\n@@ -37,7 +38,55 @@ impl Bindings {\n             };\n         }\n         match b {\n-            Binding::Fragment(it) => Ok(it),\n+            Binding::Fragment(it) => Ok(it.clone()),\n+            // emit some reasonable default expansion for missing bindings,\n+            // this gives better recovery than emitting the `$fragment-name` verbatim\n+            Binding::Missing(it) => Ok(match it {\n+                MetaVarKind::Stmt => {\n+                    Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct {\n+                        id: tt::TokenId::unspecified(),\n+                        char: ';',\n+                        spacing: tt::Spacing::Alone,\n+                    })))\n+                }\n+                MetaVarKind::Block => Fragment::Tokens(tt::TokenTree::Subtree(tt::Subtree {\n+                    delimiter: Some(tt::Delimiter {\n+                        id: tt::TokenId::unspecified(),\n+                        kind: tt::DelimiterKind::Brace,\n+                    }),\n+                    token_trees: vec![],\n+                })),\n+                // FIXME: Meta and Item should get proper defaults\n+                MetaVarKind::Meta | MetaVarKind::Item | MetaVarKind::Tt | MetaVarKind::Vis => {\n+                    Fragment::Tokens(tt::TokenTree::Subtree(tt::Subtree {\n+                        delimiter: None,\n+                        token_trees: vec![],\n+                    }))\n+                }\n+                MetaVarKind::Path\n+                | MetaVarKind::Ty\n+                | MetaVarKind::Pat\n+                | MetaVarKind::PatParam\n+                | MetaVarKind::Expr\n+                | MetaVarKind::Ident => {\n+                    Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                        text: SmolStr::new_inline(\"missing\"),\n+                        id: tt::TokenId::unspecified(),\n+                    })))\n+                }\n+                MetaVarKind::Lifetime => {\n+                    Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                        text: SmolStr::new_inline(\"'missing\"),\n+                        id: tt::TokenId::unspecified(),\n+                    })))\n+                }\n+                MetaVarKind::Literal => {\n+                    Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                        text: SmolStr::new_inline(\"\\\"missing\\\"\"),\n+                        id: tt::TokenId::unspecified(),\n+                    })))\n+                }\n+            }),\n             Binding::Nested(_) => {\n                 Err(binding_err!(\"expected simple binding, found nested binding `{name}`\"))\n             }\n@@ -157,7 +206,7 @@ fn expand_var(ctx: &mut ExpandCtx<'_>, v: &SmolStr, id: tt::TokenId) -> ExpandRe\n     } else {\n         ctx.bindings.get(v, &mut ctx.nesting).map_or_else(\n             |e| ExpandResult { value: Fragment::Tokens(tt::TokenTree::empty()), err: Some(e) },\n-            |b| ExpandResult::ok(b.clone()),\n+            |it| ExpandResult::ok(it),\n         )\n     }\n }"}, {"sha": "c4f0fa20d6de03959f3600fd57bf6e52475c2eee", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -21,7 +21,7 @@ mod token_map;\n use std::fmt;\n \n use crate::{\n-    parser::{MetaTemplate, Op},\n+    parser::{MetaTemplate, MetaVarKind, Op},\n     tt_iter::TtIter,\n };\n \n@@ -291,9 +291,9 @@ fn validate(pattern: &MetaTemplate) -> Result<(), ParseError> {\n                 // Checks that no repetition which could match an empty token\n                 // https://github.com/rust-lang/rust/blob/a58b1ed44f5e06976de2bdc4d7dc81c36a96934f/src/librustc_expand/mbe/macro_rules.rs#L558\n                 let lsh_is_empty_seq = separator.is_none() && subtree.iter().all(|child_op| {\n-                    match child_op {\n+                    match *child_op {\n                         // vis is optional\n-                        Op::Var { kind: Some(kind), .. } => kind == \"vis\",\n+                        Op::Var { kind: Some(kind), .. } => kind == MetaVarKind::Vis,\n                         Op::Repeat {\n                             kind: parser::RepeatKind::ZeroOrMore | parser::RepeatKind::ZeroOrOne,\n                             .."}, {"sha": "351c359b73c87ea8352a0bb406f7dbb285360849", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -50,7 +50,7 @@ impl MetaTemplate {\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Op {\n-    Var { name: SmolStr, kind: Option<SmolStr>, id: tt::TokenId },\n+    Var { name: SmolStr, kind: Option<MetaVarKind>, id: tt::TokenId },\n     Ignore { name: SmolStr, id: tt::TokenId },\n     Index { depth: u32 },\n     Repeat { tokens: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n@@ -65,6 +65,24 @@ pub(crate) enum RepeatKind {\n     ZeroOrOne,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum MetaVarKind {\n+    Path,\n+    Ty,\n+    Pat,\n+    PatParam,\n+    Stmt,\n+    Block,\n+    Meta,\n+    Item,\n+    Vis,\n+    Expr,\n+    Ident,\n+    Tt,\n+    Lifetime,\n+    Literal,\n+}\n+\n #[derive(Clone, Debug, Eq)]\n pub(crate) enum Separator {\n     Literal(tt::Literal),\n@@ -179,13 +197,30 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n     Ok(res)\n }\n \n-fn eat_fragment_kind(src: &mut TtIter<'_>, mode: Mode) -> Result<Option<SmolStr>, ParseError> {\n+fn eat_fragment_kind(src: &mut TtIter<'_>, mode: Mode) -> Result<Option<MetaVarKind>, ParseError> {\n     if let Mode::Pattern = mode {\n         src.expect_char(':').map_err(|()| ParseError::unexpected(\"missing fragment specifier\"))?;\n         let ident = src\n             .expect_ident()\n             .map_err(|()| ParseError::unexpected(\"missing fragment specifier\"))?;\n-        return Ok(Some(ident.text.clone()));\n+        let kind = match ident.text.as_str() {\n+            \"path\" => MetaVarKind::Path,\n+            \"ty\" => MetaVarKind::Ty,\n+            \"pat\" => MetaVarKind::Pat,\n+            \"pat_param\" => MetaVarKind::PatParam,\n+            \"stmt\" => MetaVarKind::Stmt,\n+            \"block\" => MetaVarKind::Block,\n+            \"meta\" => MetaVarKind::Meta,\n+            \"item\" => MetaVarKind::Item,\n+            \"vis\" => MetaVarKind::Vis,\n+            \"expr\" => MetaVarKind::Expr,\n+            \"ident\" => MetaVarKind::Ident,\n+            \"tt\" => MetaVarKind::Tt,\n+            \"lifetime\" => MetaVarKind::Lifetime,\n+            \"literal\" => MetaVarKind::Literal,\n+            _ => return Ok(None),\n+        };\n+        return Ok(Some(kind));\n     };\n     Ok(None)\n }"}, {"sha": "54879c1870c050239ca2d8bb511a27fae6be54de", "filename": "crates/proc-macro-api/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproc-macro-api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproc-macro-api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-api%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -19,7 +19,7 @@ object = { version = \"0.29.0\", default-features = false, features = [\n ] }\n serde = { version = \"1.0.137\", features = [\"derive\"] }\n serde_json = { version = \"1.0.81\", features = [\"unbounded_depth\"] }\n-tracing = \"0.1.35\"\n+tracing = \"0.1.37\"\n memmap2 = \"0.5.4\"\n snap = \"1.0.5\"\n "}, {"sha": "243972b04997cc6128a582d3e9b62f18a802655e", "filename": "crates/proc-macro-srv/src/abis/abi_sysroot/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -11,6 +11,8 @@ use proc_macro_api::ProcMacroKind;\n \n use super::PanicMessage;\n \n+pub use ra_server::TokenStream;\n+\n pub(crate) struct Abi {\n     exported_macros: Vec<proc_macro::bridge::client::ProcMacro>,\n }"}, {"sha": "2f854bc1595489e95ebf72041a28fb7c753b0489", "filename": "crates/proc-macro-srv/src/abis/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -32,8 +32,8 @@ mod abi_sysroot;\n include!(concat!(env!(\"OUT_DIR\"), \"/rustc_version.rs\"));\n \n // Used by `test/utils.rs`\n-#[cfg(test)]\n-pub(crate) use abi_1_63::TokenStream as TestTokenStream;\n+#[cfg(all(test, feature = \"sysroot-abi\"))]\n+pub(crate) use abi_sysroot::TokenStream as TestTokenStream;\n \n use super::dylib::LoadProcMacroDylibError;\n pub(crate) use abi_1_58::Abi as Abi_1_58;\n@@ -144,3 +144,10 @@ impl Abi {\n         }\n     }\n }\n+\n+#[test]\n+fn test_version_check() {\n+    let path = paths::AbsPathBuf::assert(crate::proc_macro_test_dylib_path());\n+    let info = proc_macro_api::read_dylib_info(&path).unwrap();\n+    assert!(info.version.1 >= 50);\n+}"}, {"sha": "72a2dfe72d3742f24049e2181e070e1159cbc98d", "filename": "crates/proc-macro-srv/src/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -20,6 +20,8 @@\n mod dylib;\n mod abis;\n \n+pub mod cli;\n+\n use std::{\n     collections::{hash_map::Entry, HashMap},\n     env,\n@@ -149,7 +151,10 @@ impl EnvSnapshot {\n     }\n }\n \n-pub mod cli;\n+#[cfg(all(feature = \"sysroot-abi\", test))]\n+mod tests;\n \n #[cfg(test)]\n-mod tests;\n+pub fn proc_macro_test_dylib_path() -> std::path::PathBuf {\n+    proc_macro_test::PROC_MACRO_TEST_LOCATION.into()\n+}"}, {"sha": "b46cdddcf6b1090314e8fe4b513167cfc77877cc", "filename": "crates/proc-macro-srv/src/tests/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -2,10 +2,10 @@\n \n #[macro_use]\n mod utils;\n-use expect_test::expect;\n-use paths::AbsPathBuf;\n use utils::*;\n \n+use expect_test::expect;\n+\n #[test]\n fn test_derive_empty() {\n     assert_expand(\"DeriveEmpty\", r#\"struct S;\"#, expect![[r#\"SUBTREE $\"#]]);\n@@ -157,10 +157,3 @@ fn list_test_macros() {\n         DeriveError [CustomDerive]\"#]]\n     .assert_eq(&res);\n }\n-\n-#[test]\n-fn test_version_check() {\n-    let path = AbsPathBuf::assert(fixtures::proc_macro_test_dylib_path());\n-    let info = proc_macro_api::read_dylib_info(&path).unwrap();\n-    assert!(info.version.1 >= 50);\n-}"}, {"sha": "44b1b6588da0a2c2ddddc50af9bdfb1789b92e54", "filename": "crates/proc-macro-srv/src/tests/utils.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Futils.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -1,15 +1,9 @@\n //! utils used in proc-macro tests\n \n-use crate::dylib;\n-use crate::ProcMacroSrv;\n use expect_test::Expect;\n use std::str::FromStr;\n \n-pub mod fixtures {\n-    pub fn proc_macro_test_dylib_path() -> std::path::PathBuf {\n-        proc_macro_test::PROC_MACRO_TEST_LOCATION.into()\n-    }\n-}\n+use crate::{dylib, proc_macro_test_dylib_path, ProcMacroSrv};\n \n fn parse_string(code: &str) -> Option<crate::abis::TestTokenStream> {\n     // This is a bit strange. We need to parse a string into a token stream into\n@@ -30,7 +24,7 @@ pub fn assert_expand_attr(macro_name: &str, ra_fixture: &str, attr_args: &str, e\n }\n \n fn assert_expand_impl(macro_name: &str, input: &str, attr: Option<&str>, expect: Expect) {\n-    let path = fixtures::proc_macro_test_dylib_path();\n+    let path = proc_macro_test_dylib_path();\n     let expander = dylib::Expander::new(&path).unwrap();\n     let fixture = parse_string(input).unwrap();\n     let attr = attr.map(|attr| parse_string(attr).unwrap().into_subtree());\n@@ -40,7 +34,7 @@ fn assert_expand_impl(macro_name: &str, input: &str, attr: Option<&str>, expect:\n }\n \n pub(crate) fn list() -> Vec<String> {\n-    let dylib_path = fixtures::proc_macro_test_dylib_path();\n+    let dylib_path = proc_macro_test_dylib_path();\n     let mut srv = ProcMacroSrv::default();\n     let res = srv.list_macros(&dylib_path).unwrap();\n     res.into_iter().map(|(name, kind)| format!(\"{} [{:?}]\", name, kind)).collect()"}, {"sha": "5697aea964f787a59bf8b0d5c49a4fc8aece848d", "filename": "crates/profile/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fprofile%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fprofile%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fprofile%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -10,9 +10,9 @@ rust-version = \"1.57\"\n doctest = false\n \n [dependencies]\n-once_cell = \"1.12.0\"\n+once_cell = \"1.15.0\"\n cfg-if = \"1.0.0\"\n-libc = \"0.2.126\"\n+libc = \"0.2.135\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n countme = { version = \"3.0.1\", features = [\"enable\"] }\n jemalloc-ctl = { version = \"0.5.0\", package = \"tikv-jemalloc-ctl\", optional = true }"}, {"sha": "6fd7c3166f821a04b5ae83283a58334fe43ae3d3", "filename": "crates/project-model/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -13,10 +13,10 @@ doctest = false\n tracing = \"0.1.35\"\n rustc-hash = \"1.1.0\"\n cargo_metadata = \"0.15.0\"\n-semver = \"1.0.10\"\n+semver = \"1.0.14\"\n serde = { version = \"1.0.137\", features = [\"derive\"] }\n-serde_json = \"1.0.81\"\n-anyhow = \"1.0.57\"\n+serde_json = \"1.0.86\"\n+anyhow = \"1.0.62\"\n expect-test = \"1.4.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n "}, {"sha": "d9f09c0349566129a762c9f58d528dea9094fa38", "filename": "crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -15,7 +15,7 @@ use rustc_hash::FxHashMap;\n use semver::Version;\n use serde::Deserialize;\n \n-use crate::{cfg_flag::CfgFlag, CargoConfig, CargoWorkspace, Package};\n+use crate::{cfg_flag::CfgFlag, CargoConfig, CargoFeatures, CargoWorkspace, Package};\n \n #[derive(Debug, Default, Clone, PartialEq, Eq)]\n pub struct WorkspaceBuildScripts {\n@@ -49,7 +49,6 @@ impl WorkspaceBuildScripts {\n \n         let mut cmd = Command::new(toolchain::cargo());\n         cmd.envs(&config.extra_env);\n-\n         cmd.args(&[\"check\", \"--quiet\", \"--workspace\", \"--message-format=json\"]);\n \n         // --all-targets includes tests, benches and examples in addition to the\n@@ -61,15 +60,18 @@ impl WorkspaceBuildScripts {\n             cmd.args(&[\"--target\", target]);\n         }\n \n-        if config.all_features {\n-            cmd.arg(\"--all-features\");\n-        } else {\n-            if config.no_default_features {\n-                cmd.arg(\"--no-default-features\");\n+        match &config.features {\n+            CargoFeatures::All => {\n+                cmd.arg(\"--all-features\");\n             }\n-            if !config.features.is_empty() {\n-                cmd.arg(\"--features\");\n-                cmd.arg(config.features.join(\" \"));\n+            CargoFeatures::Selected { features, no_default_features } => {\n+                if *no_default_features {\n+                    cmd.arg(\"--no-default-features\");\n+                }\n+                if !features.is_empty() {\n+                    cmd.arg(\"--features\");\n+                    cmd.arg(features.join(\" \"));\n+                }\n             }\n         }\n \n@@ -152,6 +154,8 @@ impl WorkspaceBuildScripts {\n                             Some(&it) => it,\n                             None => return,\n                         };\n+                        progress(format!(\"running build-script: {}\", workspace[package].name));\n+\n                         let cfgs = {\n                             let mut acc = Vec::new();\n                             for cfg in message.cfgs {\n@@ -187,7 +191,7 @@ impl WorkspaceBuildScripts {\n                             None => return,\n                         };\n \n-                        progress(format!(\"metadata {}\", message.target.name));\n+                        progress(format!(\"building proc-macros: {}\", message.target.name));\n \n                         if message.target.kind.iter().any(|k| k == \"proc-macro\") {\n                             // Skip rmeta file"}, {"sha": "8e690f1125a015fd82725255a71bca4b3bbda411", "filename": "crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 60, "deletions": 74, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -71,35 +71,40 @@ impl Default for UnsetTestCrates {\n     }\n }\n \n-#[derive(Default, Clone, Debug, PartialEq, Eq)]\n-pub struct CargoConfig {\n-    /// Do not activate the `default` feature.\n-    pub no_default_features: bool,\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum CargoFeatures {\n+    All,\n+    Selected {\n+        /// List of features to activate.\n+        features: Vec<String>,\n+        /// Do not activate the `default` feature.\n+        no_default_features: bool,\n+    },\n+}\n \n-    /// Activate all available features\n-    pub all_features: bool,\n+impl Default for CargoFeatures {\n+    fn default() -> Self {\n+        CargoFeatures::Selected { features: vec![], no_default_features: false }\n+    }\n+}\n \n+#[derive(Default, Clone, Debug, PartialEq, Eq)]\n+pub struct CargoConfig {\n     /// List of features to activate.\n-    /// This will be ignored if `cargo_all_features` is true.\n-    pub features: Vec<String>,\n-\n+    pub features: CargoFeatures,\n     /// rustc target\n     pub target: Option<String>,\n-\n-    /// Don't load sysroot crates (`std`, `core` & friends). Might be useful\n-    /// when debugging isolated issues.\n-    pub no_sysroot: bool,\n-\n+    /// Sysroot loading behavior\n+    pub sysroot: Option<RustcSource>,\n     /// rustc private crate source\n     pub rustc_source: Option<RustcSource>,\n-\n     /// crates to disable `#[cfg(test)]` on\n     pub unset_test_crates: UnsetTestCrates,\n-\n+    /// Invoke `cargo check` through the RUSTC_WRAPPER.\n     pub wrap_rustc_in_build_scripts: bool,\n-\n+    /// The command to run instead of `cargo check` for building build scripts.\n     pub run_build_script_command: Option<Vec<String>>,\n-\n+    /// Extra env vars to set when invoking the cargo command\n     pub extra_env: FxHashMap<String, String>,\n }\n \n@@ -143,7 +148,7 @@ pub struct PackageData {\n     pub targets: Vec<Target>,\n     /// Does this package come from the local filesystem (and is editable)?\n     pub is_local: bool,\n-    // Whether this package is a member of the workspace\n+    /// Whether this package is a member of the workspace\n     pub is_member: bool,\n     /// List of packages this package depends on\n     pub dependencies: Vec<PackageDependency>,\n@@ -249,8 +254,8 @@ impl TargetKind {\n     }\n }\n \n+// Deserialize helper for the cargo metadata\n #[derive(Deserialize, Default)]\n-// Deserialise helper for the cargo metadata\n struct PackageMetadata {\n     #[serde(rename = \"rust-analyzer\")]\n     rust_analyzer: Option<RustAnalyzerPackageMetaData>,\n@@ -266,22 +271,25 @@ impl CargoWorkspace {\n         let target = config\n             .target\n             .clone()\n-            .or_else(|| cargo_config_build_target(cargo_toml, config))\n-            .or_else(|| rustc_discover_host_triple(cargo_toml, config));\n+            .or_else(|| cargo_config_build_target(cargo_toml, &config.extra_env))\n+            .or_else(|| rustc_discover_host_triple(cargo_toml, &config.extra_env));\n \n         let mut meta = MetadataCommand::new();\n         meta.cargo_path(toolchain::cargo());\n         meta.manifest_path(cargo_toml.to_path_buf());\n-        if config.all_features {\n-            meta.features(CargoOpt::AllFeatures);\n-        } else {\n-            if config.no_default_features {\n-                // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n-                // https://github.com/oli-obk/cargo_metadata/issues/79\n-                meta.features(CargoOpt::NoDefaultFeatures);\n+        match &config.features {\n+            CargoFeatures::All => {\n+                meta.features(CargoOpt::AllFeatures);\n             }\n-            if !config.features.is_empty() {\n-                meta.features(CargoOpt::SomeFeatures(config.features.clone()));\n+            CargoFeatures::Selected { features, no_default_features } => {\n+                if *no_default_features {\n+                    // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n+                    // https://github.com/oli-obk/cargo_metadata/issues/79\n+                    meta.features(CargoOpt::NoDefaultFeatures);\n+                }\n+                if !features.is_empty() {\n+                    meta.features(CargoOpt::SomeFeatures(features.clone()));\n+                }\n             }\n         }\n         meta.current_dir(current_dir.as_os_str());\n@@ -295,12 +303,9 @@ impl CargoWorkspace {\n         // unclear whether cargo itself supports it.\n         progress(\"metadata\".to_string());\n \n-        fn exec_with_env(\n-            command: &cargo_metadata::MetadataCommand,\n-            extra_env: &FxHashMap<String, String>,\n-        ) -> Result<cargo_metadata::Metadata, cargo_metadata::Error> {\n-            let mut command = command.cargo_command();\n-            command.envs(extra_env);\n+        (|| -> Result<cargo_metadata::Metadata, cargo_metadata::Error> {\n+            let mut command = meta.cargo_command();\n+            command.envs(&config.extra_env);\n             let output = command.output()?;\n             if !output.status.success() {\n                 return Err(cargo_metadata::Error::CargoMetadata {\n@@ -312,12 +317,8 @@ impl CargoWorkspace {\n                 .find(|line| line.starts_with('{'))\n                 .ok_or(cargo_metadata::Error::NoJson)?;\n             cargo_metadata::MetadataCommand::parse(stdout)\n-        }\n-\n-        let meta = exec_with_env(&meta, &config.extra_env)\n-            .with_context(|| format!(\"Failed to run `{:?}`\", meta.cargo_command()))?;\n-\n-        Ok(meta)\n+        })()\n+        .with_context(|| format!(\"Failed to run `{:?}`\", meta.cargo_command()))\n     }\n \n     pub fn new(mut meta: cargo_metadata::Metadata) -> CargoWorkspace {\n@@ -386,32 +387,14 @@ impl CargoWorkspace {\n         }\n         let resolve = meta.resolve.expect(\"metadata executed with deps\");\n         for mut node in resolve.nodes {\n-            let source = match pkg_by_id.get(&node.id) {\n-                Some(&src) => src,\n-                // FIXME: replace this and a similar branch below with `.unwrap`, once\n-                // https://github.com/rust-lang/cargo/issues/7841\n-                // is fixed and hits stable (around 1.43-is probably?).\n-                None => {\n-                    tracing::error!(\"Node id do not match in cargo metadata, ignoring {}\", node.id);\n-                    continue;\n-                }\n-            };\n+            let &source = pkg_by_id.get(&node.id).unwrap();\n             node.deps.sort_by(|a, b| a.pkg.cmp(&b.pkg));\n-            for (dep_node, kind) in node\n+            let dependencies = node\n                 .deps\n                 .iter()\n-                .flat_map(|dep| DepKind::iter(&dep.dep_kinds).map(move |kind| (dep, kind)))\n-            {\n-                let pkg = match pkg_by_id.get(&dep_node.pkg) {\n-                    Some(&pkg) => pkg,\n-                    None => {\n-                        tracing::error!(\n-                            \"Dep node id do not match in cargo metadata, ignoring {}\",\n-                            dep_node.pkg\n-                        );\n-                        continue;\n-                    }\n-                };\n+                .flat_map(|dep| DepKind::iter(&dep.dep_kinds).map(move |kind| (dep, kind)));\n+            for (dep_node, kind) in dependencies {\n+                let &pkg = pkg_by_id.get(&dep_node.pkg).unwrap();\n                 let dep = PackageDependency { name: dep_node.name.clone(), pkg, kind };\n                 packages[source].dependencies.push(dep);\n             }\n@@ -456,10 +439,7 @@ impl CargoWorkspace {\n                     found = true\n                 }\n                 self[pkg].dependencies.iter().find_map(|dep| {\n-                    if &self[dep.pkg].manifest == manifest_path {\n-                        return Some(self[pkg].manifest.clone());\n-                    }\n-                    None\n+                    (&self[dep.pkg].manifest == manifest_path).then(|| self[pkg].manifest.clone())\n                 })\n             })\n             .collect::<Vec<ManifestPath>>();\n@@ -485,9 +465,12 @@ impl CargoWorkspace {\n     }\n }\n \n-fn rustc_discover_host_triple(cargo_toml: &ManifestPath, config: &CargoConfig) -> Option<String> {\n+fn rustc_discover_host_triple(\n+    cargo_toml: &ManifestPath,\n+    extra_env: &FxHashMap<String, String>,\n+) -> Option<String> {\n     let mut rustc = Command::new(toolchain::rustc());\n-    rustc.envs(&config.extra_env);\n+    rustc.envs(extra_env);\n     rustc.current_dir(cargo_toml.parent()).arg(\"-vV\");\n     tracing::debug!(\"Discovering host platform by {:?}\", rustc);\n     match utf8_stdout(rustc) {\n@@ -509,9 +492,12 @@ fn rustc_discover_host_triple(cargo_toml: &ManifestPath, config: &CargoConfig) -\n     }\n }\n \n-fn cargo_config_build_target(cargo_toml: &ManifestPath, config: &CargoConfig) -> Option<String> {\n+fn cargo_config_build_target(\n+    cargo_toml: &ManifestPath,\n+    extra_env: &FxHashMap<String, String>,\n+) -> Option<String> {\n     let mut cargo_config = Command::new(toolchain::cargo());\n-    cargo_config.envs(&config.extra_env);\n+    cargo_config.envs(extra_env);\n     cargo_config\n         .current_dir(cargo_toml.parent())\n         .args(&[\"-Z\", \"unstable-options\", \"config\", \"get\", \"build.target\"])"}, {"sha": "ce78ce85697afd23170359c5ebf572ca69a93e5a", "filename": "crates/project-model/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Flib.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -42,8 +42,8 @@ use rustc_hash::FxHashSet;\n pub use crate::{\n     build_scripts::WorkspaceBuildScripts,\n     cargo_workspace::{\n-        CargoConfig, CargoWorkspace, Package, PackageData, PackageDependency, RustcSource, Target,\n-        TargetData, TargetKind, UnsetTestCrates,\n+        CargoConfig, CargoFeatures, CargoWorkspace, Package, PackageData, PackageDependency,\n+        RustcSource, Target, TargetData, TargetKind, UnsetTestCrates,\n     },\n     manifest_path::ManifestPath,\n     project_json::{ProjectJson, ProjectJsonData},"}, {"sha": "5133a14d532bb2467934d058678a5dae6bb5bfaf", "filename": "crates/project-model/src/project_json.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Fproject_json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Fproject_json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fproject_json.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -110,14 +110,17 @@ impl ProjectJson {\n                 .collect::<Vec<_>>(),\n         }\n     }\n+\n     /// Returns the number of crates in the project.\n     pub fn n_crates(&self) -> usize {\n         self.crates.len()\n     }\n+\n     /// Returns an iterator over the crates in the project.\n     pub fn crates(&self) -> impl Iterator<Item = (CrateId, &Crate)> + '_ {\n         self.crates.iter().enumerate().map(|(idx, krate)| (CrateId(idx as u32), krate))\n     }\n+\n     /// Returns the path to the project's root folder.\n     pub fn path(&self) -> &AbsPath {\n         &self.project_root"}, {"sha": "3231361836634a179171a9367722ecad23da9510", "filename": "crates/project-model/src/rustc_cfg.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Frustc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Frustc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Frustc_cfg.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -3,13 +3,14 @@\n use std::process::Command;\n \n use anyhow::Result;\n+use rustc_hash::FxHashMap;\n \n-use crate::{cfg_flag::CfgFlag, utf8_stdout, CargoConfig, ManifestPath};\n+use crate::{cfg_flag::CfgFlag, utf8_stdout, ManifestPath};\n \n pub(crate) fn get(\n     cargo_toml: Option<&ManifestPath>,\n     target: Option<&str>,\n-    config: &CargoConfig,\n+    extra_env: &FxHashMap<String, String>,\n ) -> Vec<CfgFlag> {\n     let _p = profile::span(\"rustc_cfg::get\");\n     let mut res = Vec::with_capacity(6 * 2 + 1);\n@@ -22,7 +23,7 @@ pub(crate) fn get(\n         }\n     }\n \n-    match get_rust_cfgs(cargo_toml, target, config) {\n+    match get_rust_cfgs(cargo_toml, target, extra_env) {\n         Ok(rustc_cfgs) => {\n             tracing::debug!(\n                 \"rustc cfgs found: {:?}\",\n@@ -42,11 +43,11 @@ pub(crate) fn get(\n fn get_rust_cfgs(\n     cargo_toml: Option<&ManifestPath>,\n     target: Option<&str>,\n-    config: &CargoConfig,\n+    extra_env: &FxHashMap<String, String>,\n ) -> Result<String> {\n     if let Some(cargo_toml) = cargo_toml {\n         let mut cargo_config = Command::new(toolchain::cargo());\n-        cargo_config.envs(&config.extra_env);\n+        cargo_config.envs(extra_env);\n         cargo_config\n             .current_dir(cargo_toml.parent())\n             .args(&[\"-Z\", \"unstable-options\", \"rustc\", \"--print\", \"cfg\"])\n@@ -61,7 +62,7 @@ fn get_rust_cfgs(\n     }\n     // using unstable cargo features failed, fall back to using plain rustc\n     let mut cmd = Command::new(toolchain::rustc());\n-    cmd.envs(&config.extra_env);\n+    cmd.envs(extra_env);\n     cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n     if let Some(target) = target {\n         cmd.args(&[\"--target\", target]);"}, {"sha": "bc37e3d132a6ce6f70da3ab54cf3abe4a89f3091", "filename": "crates/project-model/src/sysroot.rs", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fsysroot.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -9,8 +9,9 @@ use std::{env, fs, iter, ops, path::PathBuf, process::Command};\n use anyhow::{format_err, Result};\n use la_arena::{Arena, Idx};\n use paths::{AbsPath, AbsPathBuf};\n+use rustc_hash::FxHashMap;\n \n-use crate::{utf8_stdout, CargoConfig, ManifestPath};\n+use crate::{utf8_stdout, ManifestPath};\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Sysroot {\n@@ -66,23 +67,37 @@ impl Sysroot {\n     pub fn crates<'a>(&'a self) -> impl Iterator<Item = SysrootCrate> + ExactSizeIterator + 'a {\n         self.crates.iter().map(|(id, _data)| id)\n     }\n+}\n \n-    pub fn discover(dir: &AbsPath, config: &CargoConfig) -> Result<Sysroot> {\n+impl Sysroot {\n+    pub fn discover(dir: &AbsPath, extra_env: &FxHashMap<String, String>) -> Result<Sysroot> {\n         tracing::debug!(\"Discovering sysroot for {}\", dir.display());\n-        let sysroot_dir = discover_sysroot_dir(dir, config)?;\n-        let sysroot_src_dir = discover_sysroot_src_dir(&sysroot_dir, dir, config)?;\n+        let sysroot_dir = discover_sysroot_dir(dir, extra_env)?;\n+        let sysroot_src_dir =\n+            discover_sysroot_src_dir_or_add_component(&sysroot_dir, dir, extra_env)?;\n         let res = Sysroot::load(sysroot_dir, sysroot_src_dir)?;\n         Ok(res)\n     }\n \n-    pub fn discover_rustc(cargo_toml: &ManifestPath, config: &CargoConfig) -> Option<ManifestPath> {\n+    pub fn discover_rustc(\n+        cargo_toml: &ManifestPath,\n+        extra_env: &FxHashMap<String, String>,\n+    ) -> Option<ManifestPath> {\n         tracing::debug!(\"Discovering rustc source for {}\", cargo_toml.display());\n         let current_dir = cargo_toml.parent();\n-        discover_sysroot_dir(current_dir, config)\n+        discover_sysroot_dir(current_dir, extra_env)\n             .ok()\n             .and_then(|sysroot_dir| get_rustc_src(&sysroot_dir))\n     }\n \n+    pub fn with_sysroot_dir(sysroot_dir: AbsPathBuf) -> Result<Sysroot> {\n+        let sysroot_src_dir = discover_sysroot_src_dir(&sysroot_dir).ok_or_else(|| {\n+            format_err!(\"can't load standard library from sysroot {}\", sysroot_dir.display())\n+        })?;\n+        let res = Sysroot::load(sysroot_dir, sysroot_src_dir)?;\n+        Ok(res)\n+    }\n+\n     pub fn load(sysroot_dir: AbsPathBuf, sysroot_src_dir: AbsPathBuf) -> Result<Sysroot> {\n         let mut sysroot =\n             Sysroot { root: sysroot_dir, src_root: sysroot_src_dir, crates: Arena::default() };\n@@ -146,35 +161,43 @@ impl Sysroot {\n     }\n }\n \n-fn discover_sysroot_dir(current_dir: &AbsPath, config: &CargoConfig) -> Result<AbsPathBuf> {\n+fn discover_sysroot_dir(\n+    current_dir: &AbsPath,\n+    extra_env: &FxHashMap<String, String>,\n+) -> Result<AbsPathBuf> {\n     let mut rustc = Command::new(toolchain::rustc());\n-    rustc.envs(&config.extra_env);\n+    rustc.envs(extra_env);\n     rustc.current_dir(current_dir).args(&[\"--print\", \"sysroot\"]);\n     tracing::debug!(\"Discovering sysroot by {:?}\", rustc);\n     let stdout = utf8_stdout(rustc)?;\n     Ok(AbsPathBuf::assert(PathBuf::from(stdout)))\n }\n \n-fn discover_sysroot_src_dir(\n-    sysroot_path: &AbsPathBuf,\n-    current_dir: &AbsPath,\n-    config: &CargoConfig,\n-) -> Result<AbsPathBuf> {\n+fn discover_sysroot_src_dir(sysroot_path: &AbsPathBuf) -> Option<AbsPathBuf> {\n     if let Ok(path) = env::var(\"RUST_SRC_PATH\") {\n-        let path = AbsPathBuf::try_from(path.as_str())\n-            .map_err(|path| format_err!(\"RUST_SRC_PATH must be absolute: {}\", path.display()))?;\n-        let core = path.join(\"core\");\n-        if fs::metadata(&core).is_ok() {\n-            tracing::debug!(\"Discovered sysroot by RUST_SRC_PATH: {}\", path.display());\n-            return Ok(path);\n+        if let Ok(path) = AbsPathBuf::try_from(path.as_str()) {\n+            let core = path.join(\"core\");\n+            if fs::metadata(&core).is_ok() {\n+                tracing::debug!(\"Discovered sysroot by RUST_SRC_PATH: {}\", path.display());\n+                return Some(path);\n+            }\n+            tracing::debug!(\"RUST_SRC_PATH is set, but is invalid (no core: {:?}), ignoring\", core);\n+        } else {\n+            tracing::debug!(\"RUST_SRC_PATH is set, but is invalid, ignoring\");\n         }\n-        tracing::debug!(\"RUST_SRC_PATH is set, but is invalid (no core: {:?}), ignoring\", core);\n     }\n \n     get_rust_src(sysroot_path)\n+}\n+fn discover_sysroot_src_dir_or_add_component(\n+    sysroot_path: &AbsPathBuf,\n+    current_dir: &AbsPath,\n+    extra_env: &FxHashMap<String, String>,\n+) -> Result<AbsPathBuf> {\n+    discover_sysroot_src_dir(sysroot_path)\n         .or_else(|| {\n             let mut rustup = Command::new(toolchain::rustup());\n-            rustup.envs(&config.extra_env);\n+            rustup.envs(extra_env);\n             rustup.current_dir(current_dir).args(&[\"component\", \"add\", \"rust-src\"]);\n             utf8_stdout(rustup).ok()?;\n             get_rust_src(sysroot_path)"}, {"sha": "e2444e24974a75fcdf163dd0e4764f051f4731cf", "filename": "crates/project-model/src/tests.rs", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Ftests.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -10,8 +10,8 @@ use paths::{AbsPath, AbsPathBuf};\n use serde::de::DeserializeOwned;\n \n use crate::{\n-    CargoConfig, CargoWorkspace, CfgOverrides, ProjectJson, ProjectJsonData, ProjectWorkspace,\n-    Sysroot, WorkspaceBuildScripts,\n+    CargoWorkspace, CfgOverrides, ProjectJson, ProjectJsonData, ProjectWorkspace, Sysroot,\n+    WorkspaceBuildScripts,\n };\n \n fn load_cargo(file: &str) -> CrateGraph {\n@@ -101,7 +101,7 @@ fn to_crate_graph(project_workspace: ProjectWorkspace) -> CrateGraph {\n                 Some(FileId(counter))\n             }\n         },\n-        &CargoConfig::default(),\n+        &Default::default(),\n     )\n }\n \n@@ -185,6 +185,9 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -260,6 +263,9 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -335,6 +341,9 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -410,6 +419,9 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -477,6 +489,9 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                             repo: Some(\n                                 \"https://github.com/rust-lang/libc\",\n                             ),\n+                            name: Some(\n+                                \"libc\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -567,6 +582,9 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -644,6 +662,9 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -721,6 +742,9 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -798,6 +822,9 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -865,6 +892,9 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                             repo: Some(\n                                 \"https://github.com/rust-lang/libc\",\n                             ),\n+                            name: Some(\n+                                \"libc\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -946,6 +976,9 @@ fn cargo_hello_world_project_model() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -1023,6 +1056,9 @@ fn cargo_hello_world_project_model() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -1100,6 +1136,9 @@ fn cargo_hello_world_project_model() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -1177,6 +1216,9 @@ fn cargo_hello_world_project_model() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello-world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -1244,6 +1286,9 @@ fn cargo_hello_world_project_model() {\n                             repo: Some(\n                                 \"https://github.com/rust-lang/libc\",\n                             ),\n+                            name: Some(\n+                                \"libc\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -1804,6 +1849,9 @@ fn rust_project_hello_world_project_model() {\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n+                            name: Some(\n+                                \"hello_world\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },"}, {"sha": "72ddf809288aa35338ac2a283db0ed30336cd677", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 77, "deletions": 55, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -21,8 +21,8 @@ use crate::{\n     cfg_flag::CfgFlag,\n     rustc_cfg,\n     sysroot::SysrootCrate,\n-    utf8_stdout, CargoConfig, CargoWorkspace, ManifestPath, ProjectJson, ProjectManifest, Sysroot,\n-    TargetKind, WorkspaceBuildScripts,\n+    utf8_stdout, CargoConfig, CargoWorkspace, ManifestPath, Package, ProjectJson, ProjectManifest,\n+    Sysroot, TargetKind, WorkspaceBuildScripts,\n };\n \n /// A set of cfg-overrides per crate.\n@@ -156,7 +156,11 @@ impl ProjectWorkspace {\n                 })?;\n                 let project_location = project_json.parent().to_path_buf();\n                 let project_json = ProjectJson::new(&project_location, data);\n-                ProjectWorkspace::load_inline(project_json, config.target.as_deref(), config)?\n+                ProjectWorkspace::load_inline(\n+                    project_json,\n+                    config.target.as_deref(),\n+                    &config.extra_env,\n+                )?\n             }\n             ProjectManifest::CargoToml(cargo_toml) => {\n                 let cargo_version = utf8_stdout({\n@@ -184,20 +188,33 @@ impl ProjectWorkspace {\n                 })?;\n                 let cargo = CargoWorkspace::new(meta);\n \n-                let sysroot = if config.no_sysroot {\n-                    None\n-                } else {\n-                    Some(Sysroot::discover(cargo_toml.parent(), config).with_context(|| {\n-                        format!(\n+                let sysroot = match &config.sysroot {\n+                    Some(RustcSource::Path(path)) => {\n+                        Some(Sysroot::with_sysroot_dir(path.clone()).with_context(|| {\n+                            format!(\n+                                \"Failed to find sysroot for Cargo.toml file {}.\",\n+                                cargo_toml.display()\n+                            )\n+                        })?)\n+                    }\n+                    Some(RustcSource::Discover) => Some(\n+                        Sysroot::discover(cargo_toml.parent(), &config.extra_env).with_context(\n+                            || {\n+                                format!(\n                             \"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed?\",\n                             cargo_toml.display()\n                         )\n-                    })?)\n+                            },\n+                        )?,\n+                    ),\n+                    None => None,\n                 };\n \n                 let rustc_dir = match &config.rustc_source {\n                     Some(RustcSource::Path(path)) => ManifestPath::try_from(path.clone()).ok(),\n-                    Some(RustcSource::Discover) => Sysroot::discover_rustc(&cargo_toml, config),\n+                    Some(RustcSource::Discover) => {\n+                        Sysroot::discover_rustc(&cargo_toml, &config.extra_env)\n+                    }\n                     None => None,\n                 };\n \n@@ -217,7 +234,8 @@ impl ProjectWorkspace {\n                     None => None,\n                 };\n \n-                let rustc_cfg = rustc_cfg::get(Some(&cargo_toml), config.target.as_deref(), config);\n+                let rustc_cfg =\n+                    rustc_cfg::get(Some(&cargo_toml), config.target.as_deref(), &config.extra_env);\n \n                 let cfg_overrides = config.cfg_overrides();\n                 ProjectWorkspace::Cargo {\n@@ -238,7 +256,7 @@ impl ProjectWorkspace {\n     pub fn load_inline(\n         project_json: ProjectJson,\n         target: Option<&str>,\n-        config: &CargoConfig,\n+        extra_env: &FxHashMap<String, String>,\n     ) -> Result<ProjectWorkspace> {\n         let sysroot = match (project_json.sysroot.clone(), project_json.sysroot_src.clone()) {\n             (Some(sysroot), Some(sysroot_src)) => Some(Sysroot::load(sysroot, sysroot_src)?),\n@@ -260,7 +278,7 @@ impl ProjectWorkspace {\n             (None, None) => None,\n         };\n \n-        let rustc_cfg = rustc_cfg::get(None, target, config);\n+        let rustc_cfg = rustc_cfg::get(None, target, extra_env);\n         Ok(ProjectWorkspace::Json { project: project_json, sysroot, rustc_cfg })\n     }\n \n@@ -270,9 +288,9 @@ impl ProjectWorkspace {\n                 .first()\n                 .and_then(|it| it.parent())\n                 .ok_or_else(|| format_err!(\"No detached files to load\"))?,\n-            &CargoConfig::default(),\n+            &Default::default(),\n         )?;\n-        let rustc_cfg = rustc_cfg::get(None, None, &CargoConfig::default());\n+        let rustc_cfg = rustc_cfg::get(None, None, &Default::default());\n         Ok(ProjectWorkspace::DetachedFiles { files: detached_files, sysroot, rustc_cfg })\n     }\n \n@@ -306,6 +324,13 @@ impl ProjectWorkspace {\n     /// The return type contains the path and whether or not\n     /// the root is a member of the current workspace\n     pub fn to_roots(&self) -> Vec<PackageRoot> {\n+        let mk_sysroot = |sysroot: Option<&Sysroot>| {\n+            sysroot.map(|sysroot| PackageRoot {\n+                is_local: false,\n+                include: vec![sysroot.src_root().to_path_buf()],\n+                exclude: Vec::new(),\n+            })\n+        };\n         match self {\n             ProjectWorkspace::Json { project, sysroot, rustc_cfg: _ } => project\n                 .crates()\n@@ -316,13 +341,7 @@ impl ProjectWorkspace {\n                 })\n                 .collect::<FxHashSet<_>>()\n                 .into_iter()\n-                .chain(sysroot.as_ref().into_iter().flat_map(|sysroot| {\n-                    sysroot.crates().map(move |krate| PackageRoot {\n-                        is_local: false,\n-                        include: vec![sysroot[krate].root.parent().to_path_buf()],\n-                        exclude: Vec::new(),\n-                    })\n-                }))\n+                .chain(mk_sysroot(sysroot.as_ref()))\n                 .collect::<Vec<_>>(),\n             ProjectWorkspace::Cargo {\n                 cargo,\n@@ -371,11 +390,7 @@ impl ProjectWorkspace {\n                         }\n                         PackageRoot { is_local, include, exclude }\n                     })\n-                    .chain(sysroot.iter().map(|sysroot| PackageRoot {\n-                        is_local: false,\n-                        include: vec![sysroot.src_root().to_path_buf()],\n-                        exclude: Vec::new(),\n-                    }))\n+                    .chain(mk_sysroot(sysroot.as_ref()))\n                     .chain(rustc.iter().flat_map(|rustc| {\n                         rustc.packages().map(move |krate| PackageRoot {\n                             is_local: false,\n@@ -392,11 +407,7 @@ impl ProjectWorkspace {\n                     include: vec![detached_file.clone()],\n                     exclude: Vec::new(),\n                 })\n-                .chain(sysroot.crates().map(|krate| PackageRoot {\n-                    is_local: false,\n-                    include: vec![sysroot[krate].root.parent().to_path_buf()],\n-                    exclude: Vec::new(),\n-                }))\n+                .chain(mk_sysroot(Some(sysroot)))\n                 .collect(),\n         }\n     }\n@@ -419,7 +430,7 @@ impl ProjectWorkspace {\n         &self,\n         load_proc_macro: &mut dyn FnMut(&str, &AbsPath) -> ProcMacroLoadResult,\n         load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-        config: &CargoConfig,\n+        extra_env: &FxHashMap<String, String>,\n     ) -> CrateGraph {\n         let _p = profile::span(\"ProjectWorkspace::to_crate_graph\");\n \n@@ -430,7 +441,7 @@ impl ProjectWorkspace {\n                 load,\n                 project,\n                 sysroot,\n-                config,\n+                extra_env,\n             ),\n             ProjectWorkspace::Cargo {\n                 cargo,\n@@ -469,7 +480,7 @@ fn project_json_to_crate_graph(\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     project: &ProjectJson,\n     sysroot: &Option<Sysroot>,\n-    config: &CargoConfig,\n+    extra_env: &FxHashMap<String, String>,\n ) -> CrateGraph {\n     let mut crate_graph = CrateGraph::default();\n     let sysroot_deps = sysroot\n@@ -497,7 +508,7 @@ fn project_json_to_crate_graph(\n             let target_cfgs = match krate.target.as_deref() {\n                 Some(target) => cfg_cache\n                     .entry(target)\n-                    .or_insert_with(|| rustc_cfg::get(None, Some(target), config)),\n+                    .or_insert_with(|| rustc_cfg::get(None, Some(target), extra_env)),\n                 None => &rustc_cfg,\n             };\n \n@@ -516,9 +527,15 @@ fn project_json_to_crate_graph(\n                     proc_macro,\n                     krate.is_proc_macro,\n                     if krate.display_name.is_some() {\n-                        CrateOrigin::CratesIo { repo: krate.repository.clone() }\n+                        CrateOrigin::CratesIo {\n+                            repo: krate.repository.clone(),\n+                            name: krate\n+                                .display_name\n+                                .clone()\n+                                .map(|n| n.canonical_name().to_string()),\n+                        }\n                     } else {\n-                        CrateOrigin::CratesIo { repo: None }\n+                        CrateOrigin::CratesIo { repo: None, name: None }\n                     },\n                 ),\n             )\n@@ -630,6 +647,8 @@ fn cargo_to_crate_graph(\n                     lib_tgt = Some((crate_id, cargo[tgt].name.clone()));\n                     pkg_to_lib_crate.insert(pkg, crate_id);\n                 }\n+                // Even crates that don't set proc-macro = true are allowed to depend on proc_macro\n+                // (just none of the APIs work when called outside of a proc macro).\n                 if let Some(proc_macro) = libproc_macro {\n                     add_dep_with_prelude(\n                         &mut crate_graph,\n@@ -645,19 +664,19 @@ fn cargo_to_crate_graph(\n         }\n \n         // Set deps to the core, std and to the lib target of the current package\n-        for (from, kind) in pkg_crates.get(&pkg).into_iter().flatten() {\n+        for &(from, kind) in pkg_crates.get(&pkg).into_iter().flatten() {\n             // Add sysroot deps first so that a lib target named `core` etc. can overwrite them.\n-            public_deps.add(*from, &mut crate_graph);\n+            public_deps.add(from, &mut crate_graph);\n \n             if let Some((to, name)) = lib_tgt.clone() {\n-                if to != *from && *kind != TargetKind::BuildScript {\n+                if to != from && kind != TargetKind::BuildScript {\n                     // (build script can not depend on its library target)\n \n                     // For root projects with dashes in their name,\n                     // cargo metadata does not do any normalization,\n                     // so we do it ourselves currently\n                     let name = CrateName::normalize_dashes(&name);\n-                    add_dep(&mut crate_graph, *from, name, to);\n+                    add_dep(&mut crate_graph, from, name, to);\n                 }\n             }\n         }\n@@ -669,17 +688,17 @@ fn cargo_to_crate_graph(\n         for dep in cargo[pkg].dependencies.iter() {\n             let name = CrateName::new(&dep.name).unwrap();\n             if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                for (from, kind) in pkg_crates.get(&pkg).into_iter().flatten() {\n-                    if dep.kind == DepKind::Build && *kind != TargetKind::BuildScript {\n+                for &(from, kind) in pkg_crates.get(&pkg).into_iter().flatten() {\n+                    if dep.kind == DepKind::Build && kind != TargetKind::BuildScript {\n                         // Only build scripts may depend on build dependencies.\n                         continue;\n                     }\n-                    if dep.kind != DepKind::Build && *kind == TargetKind::BuildScript {\n+                    if dep.kind != DepKind::Build && kind == TargetKind::BuildScript {\n                         // Build scripts may only depend on build dependencies.\n                         continue;\n                     }\n \n-                    add_dep(&mut crate_graph, *from, name.clone(), to)\n+                    add_dep(&mut crate_graph, from, name.clone(), to)\n                 }\n             }\n         }\n@@ -690,9 +709,9 @@ fn cargo_to_crate_graph(\n         // and create dependencies on them for the crates which opt-in to that\n         if let Some(rustc_workspace) = rustc {\n             handle_rustc_crates(\n+                &mut crate_graph,\n                 rustc_workspace,\n                 load,\n-                &mut crate_graph,\n                 &cfg_options,\n                 override_cfg,\n                 load_proc_macro,\n@@ -736,14 +755,17 @@ fn detached_files_to_crate_graph(\n         let detached_file_crate = crate_graph.add_crate_root(\n             file_id,\n             Edition::CURRENT,\n-            display_name,\n+            display_name.clone(),\n             None,\n             cfg_options.clone(),\n             cfg_options.clone(),\n             Env::default(),\n             Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None },\n+            CrateOrigin::CratesIo {\n+                repo: None,\n+                name: display_name.map(|n| n.canonical_name().to_string()),\n+            },\n         );\n \n         public_deps.add(detached_file_crate, &mut crate_graph);\n@@ -752,16 +774,16 @@ fn detached_files_to_crate_graph(\n }\n \n fn handle_rustc_crates(\n+    crate_graph: &mut CrateGraph,\n     rustc_workspace: &CargoWorkspace,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-    crate_graph: &mut CrateGraph,\n     cfg_options: &CfgOptions,\n     override_cfg: &CfgOverrides,\n     load_proc_macro: &mut dyn FnMut(&str, &AbsPath) -> ProcMacroLoadResult,\n-    pkg_to_lib_crate: &mut FxHashMap<la_arena::Idx<crate::PackageData>, CrateId>,\n+    pkg_to_lib_crate: &mut FxHashMap<Package, CrateId>,\n     public_deps: &SysrootPublicDeps,\n     cargo: &CargoWorkspace,\n-    pkg_crates: &FxHashMap<la_arena::Idx<crate::PackageData>, Vec<(CrateId, TargetKind)>>,\n+    pkg_crates: &FxHashMap<Package, Vec<(CrateId, TargetKind)>>,\n     build_scripts: &WorkspaceBuildScripts,\n ) {\n     let mut rustc_pkg_crates = FxHashMap::default();\n@@ -775,8 +797,8 @@ fn handle_rustc_crates(\n         let mut queue = VecDeque::new();\n         queue.push_back(root_pkg);\n         while let Some(pkg) = queue.pop_front() {\n-            // Don't duplicate packages if they are dependended on a diamond pattern\n-            // N.B. if this line is omitted, we try to analyse over 4_800_000 crates\n+            // Don't duplicate packages if they are dependent on a diamond pattern\n+            // N.B. if this line is omitted, we try to analyze over 4_800_000 crates\n             // which is not ideal\n             if rustc_pkg_crates.contains_key(&pkg) {\n                 continue;\n@@ -919,7 +941,7 @@ fn add_target_crate_root(\n         env,\n         proc_macro,\n         is_proc_macro,\n-        CrateOrigin::CratesIo { repo: pkg.repository.clone() },\n+        CrateOrigin::CratesIo { repo: pkg.repository.clone(), name: Some(pkg.name.clone()) },\n     )\n }\n "}, {"sha": "5445028536cb54fcb6d2ac94da44ed6409223caf", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -18,25 +18,25 @@ name = \"rust-analyzer\"\n path = \"src/bin/main.rs\"\n \n [dependencies]\n-anyhow = \"1.0.57\"\n+anyhow = \"1.0.62\"\n crossbeam-channel = \"0.5.5\"\n dissimilar = \"1.0.4\"\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n scip = \"0.1.1\"\n lsp-types = { version = \"0.93.1\", features = [\"proposed\"] }\n parking_lot = \"0.12.1\"\n-xflags = \"0.2.4\"\n+xflags = \"0.3.0\"\n oorandom = \"11.1.3\"\n rustc-hash = \"1.1.0\"\n serde = { version = \"1.0.137\", features = [\"derive\"] }\n serde_json = { version = \"1.0.81\", features = [\"preserve_order\"] }\n threadpool = \"1.8.1\"\n rayon = \"1.5.3\"\n num_cpus = \"1.13.1\"\n-mimalloc = { version = \"0.1.29\", default-features = false, optional = true }\n-lsp-server = { version = \"0.6.0\", path = \"../../lib/lsp-server\" }\n+mimalloc = { version = \"0.1.30\", default-features = false, optional = true }\n+lsp-server = { version = \"0.7.0\", path = \"../../lib/lsp-server\" }\n tracing = \"0.1.35\"\n-tracing-subscriber = { version = \"0.3.14\", default-features = false, features = [\n+tracing-subscriber = { version = \"0.3.16\", default-features = false, features = [\n     \"env-filter\",\n     \"registry\",\n     \"fmt\",\n@@ -87,7 +87,6 @@ jemalloc = [\"jemallocator\", \"profile/jemalloc\"]\n force-always-assert = [\"always-assert/force\"]\n in-rust-tree = [\n     \"proc-macro-srv/sysroot-abi\",\n-    \"sourcegen/in-rust-tree\",\n     \"ide/in-rust-tree\",\n     \"syntax/in-rust-tree\",\n ]"}, {"sha": "ac10721d95514049baa41f351b7a2a4c0a989811", "filename": "crates/rust-analyzer/src/bin/logger.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -132,7 +132,7 @@ where\n \n             let ext = span.extensions();\n \n-            // `FormattedFields` is a a formatted representation of the span's\n+            // `FormattedFields` is a formatted representation of the span's\n             // fields, which is stored in its extensions by the `fmt` layer's\n             // `new_span` method. The fields will have been formatted\n             // by the same field formatter that's provided to the event"}, {"sha": "eabfcf1944dfd4f47c44a97d9e2b5c5c4ce63aaf", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -37,16 +37,15 @@ fn main() {\n         process::exit(code);\n     }\n \n-    if let Err(err) = try_main() {\n+    let flags = flags::RustAnalyzer::from_env_or_exit();\n+    if let Err(err) = try_main(flags) {\n         tracing::error!(\"Unexpected error: {}\", err);\n         eprintln!(\"{}\", err);\n         process::exit(101);\n     }\n }\n \n-fn try_main() -> Result<()> {\n-    let flags = flags::RustAnalyzer::from_env()?;\n-\n+fn try_main(flags: flags::RustAnalyzer) -> Result<()> {\n     #[cfg(debug_assertions)]\n     if flags.wait_dbg || env::var(\"RA_WAIT_DBG\").is_ok() {\n         #[allow(unused_mut)]\n@@ -76,10 +75,6 @@ fn try_main() -> Result<()> {\n                 println!(\"rust-analyzer {}\", rust_analyzer::version());\n                 return Ok(());\n             }\n-            if cmd.help {\n-                println!(\"{}\", flags::RustAnalyzer::HELP);\n-                return Ok(());\n-            }\n             with_extra_thread(\"LspServer\", run_server)?;\n         }\n         flags::RustAnalyzerCmd::ProcMacro(flags::ProcMacro) => {"}, {"sha": "e1675a030c0f6f19f36b5d4bf12e975db471ba9d", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -4,7 +4,7 @@ use std::mem;\n \n use cfg::{CfgAtom, CfgExpr};\n use ide::{FileId, RunnableKind, TestId};\n-use project_model::{self, ManifestPath, TargetKind};\n+use project_model::{self, CargoFeatures, ManifestPath, TargetKind};\n use vfs::AbsPathBuf;\n \n use crate::{global_state::GlobalStateSnapshot, Result};\n@@ -35,41 +35,41 @@ impl CargoTargetSpec {\n \n         match kind {\n             RunnableKind::Test { test_id, attr } => {\n-                args.push(\"test\".to_string());\n+                args.push(\"test\".to_owned());\n                 extra_args.push(test_id.to_string());\n                 if let TestId::Path(_) = test_id {\n-                    extra_args.push(\"--exact\".to_string());\n+                    extra_args.push(\"--exact\".to_owned());\n                 }\n-                extra_args.push(\"--nocapture\".to_string());\n+                extra_args.push(\"--nocapture\".to_owned());\n                 if attr.ignore {\n-                    extra_args.push(\"--ignored\".to_string());\n+                    extra_args.push(\"--ignored\".to_owned());\n                 }\n             }\n             RunnableKind::TestMod { path } => {\n-                args.push(\"test\".to_string());\n-                extra_args.push(path.to_string());\n-                extra_args.push(\"--nocapture\".to_string());\n+                args.push(\"test\".to_owned());\n+                extra_args.push(path.clone());\n+                extra_args.push(\"--nocapture\".to_owned());\n             }\n             RunnableKind::Bench { test_id } => {\n-                args.push(\"bench\".to_string());\n+                args.push(\"bench\".to_owned());\n                 extra_args.push(test_id.to_string());\n                 if let TestId::Path(_) = test_id {\n-                    extra_args.push(\"--exact\".to_string());\n+                    extra_args.push(\"--exact\".to_owned());\n                 }\n-                extra_args.push(\"--nocapture\".to_string());\n+                extra_args.push(\"--nocapture\".to_owned());\n             }\n             RunnableKind::DocTest { test_id } => {\n-                args.push(\"test\".to_string());\n-                args.push(\"--doc\".to_string());\n+                args.push(\"test\".to_owned());\n+                args.push(\"--doc\".to_owned());\n                 extra_args.push(test_id.to_string());\n-                extra_args.push(\"--nocapture\".to_string());\n+                extra_args.push(\"--nocapture\".to_owned());\n             }\n             RunnableKind::Bin => {\n                 let subcommand = match spec {\n                     Some(CargoTargetSpec { target_kind: TargetKind::Test, .. }) => \"test\",\n                     _ => \"run\",\n                 };\n-                args.push(subcommand.to_string());\n+                args.push(subcommand.to_owned());\n             }\n         }\n \n@@ -82,29 +82,35 @@ impl CargoTargetSpec {\n         };\n \n         let cargo_config = snap.config.cargo();\n-        if cargo_config.all_features {\n-            args.push(\"--all-features\".to_string());\n \n-            for feature in target_required_features {\n-                args.push(\"--features\".to_string());\n-                args.push(feature);\n-            }\n-        } else {\n-            let mut features = Vec::new();\n-            if let Some(cfg) = cfg.as_ref() {\n-                required_features(cfg, &mut features);\n+        match &cargo_config.features {\n+            CargoFeatures::All => {\n+                args.push(\"--all-features\".to_owned());\n+                for feature in target_required_features {\n+                    args.push(\"--features\".to_owned());\n+                    args.push(feature);\n+                }\n             }\n+            CargoFeatures::Selected { features, no_default_features } => {\n+                let mut feats = Vec::new();\n+                if let Some(cfg) = cfg.as_ref() {\n+                    required_features(cfg, &mut feats);\n+                }\n \n-            features.extend(cargo_config.features);\n-            features.extend(target_required_features);\n+                feats.extend(features.iter().cloned());\n+                feats.extend(target_required_features);\n \n-            features.dedup();\n-            for feature in features {\n-                args.push(\"--features\".to_string());\n-                args.push(feature);\n+                feats.dedup();\n+                for feature in feats {\n+                    args.push(\"--features\".to_owned());\n+                    args.push(feature);\n+                }\n+\n+                if *no_default_features {\n+                    args.push(\"--no-default-features\".to_owned());\n+                }\n             }\n         }\n-\n         Ok((args, extra_args))\n     }\n \n@@ -136,7 +142,7 @@ impl CargoTargetSpec {\n     }\n \n     pub(crate) fn push_to(self, buf: &mut Vec<String>, kind: &RunnableKind) {\n-        buf.push(\"--package\".to_string());\n+        buf.push(\"--package\".to_owned());\n         buf.push(self.package);\n \n         // Can't mix --doc with other target flags\n@@ -145,23 +151,23 @@ impl CargoTargetSpec {\n         }\n         match self.target_kind {\n             TargetKind::Bin => {\n-                buf.push(\"--bin\".to_string());\n+                buf.push(\"--bin\".to_owned());\n                 buf.push(self.target);\n             }\n             TargetKind::Test => {\n-                buf.push(\"--test\".to_string());\n+                buf.push(\"--test\".to_owned());\n                 buf.push(self.target);\n             }\n             TargetKind::Bench => {\n-                buf.push(\"--bench\".to_string());\n+                buf.push(\"--bench\".to_owned());\n                 buf.push(self.target);\n             }\n             TargetKind::Example => {\n-                buf.push(\"--example\".to_string());\n+                buf.push(\"--example\".to_owned());\n                 buf.push(self.target);\n             }\n             TargetKind::Lib => {\n-                buf.push(\"--lib\".to_string());\n+                buf.push(\"--lib\".to_owned());\n             }\n             TargetKind::Other | TargetKind::BuildScript => (),\n         }"}, {"sha": "01fccc83e8227be05109dd1ada0528c24ed92a28", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -24,7 +24,7 @@ use ide_db::base_db::{\n use itertools::Itertools;\n use oorandom::Rand32;\n use profile::{Bytes, StopWatch};\n-use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n+use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustcSource};\n use rayon::prelude::*;\n use rustc_hash::FxHashSet;\n use stdx::format_to;\n@@ -55,7 +55,10 @@ impl flags::AnalysisStats {\n         };\n \n         let mut cargo_config = CargoConfig::default();\n-        cargo_config.no_sysroot = self.no_sysroot;\n+        cargo_config.sysroot = match self.no_sysroot {\n+            true => None,\n+            false => Some(RustcSource::Discover),\n+        };\n         let load_cargo_config = LoadCargoConfig {\n             load_out_dirs_from_check: !self.disable_build_scripts,\n             with_proc_macro: !self.disable_proc_macros,\n@@ -81,7 +84,7 @@ impl flags::AnalysisStats {\n         };\n \n         let (host, vfs, _proc_macro) =\n-            load_workspace(workspace, &cargo_config, &load_cargo_config)?;\n+            load_workspace(workspace, &cargo_config.extra_env, &load_cargo_config)?;\n         let db = host.raw_database();\n         eprint!(\"{:<20} {}\", \"Database loaded:\", db_load_sw.elapsed());\n         eprint!(\" (metadata {}\", metadata_time);"}, {"sha": "5bcc97e22612257f8e025d2dbd24ff16e0f64bf8", "filename": "crates/rust-analyzer/src/cli/flags.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -31,8 +31,6 @@ xflags::xflags! {\n         default cmd lsp-server {\n             /// Print version.\n             optional --version\n-            /// Print help.\n-            optional -h, --help\n \n             /// Dump a LSP config JSON schema.\n             optional --print-config-schema\n@@ -54,10 +52,10 @@ xflags::xflags! {\n         }\n \n         /// Batch typecheck project and print summary statistics\n-        cmd analysis-stats\n+        cmd analysis-stats {\n             /// Directory with Cargo.toml.\n             required path: PathBuf\n-        {\n+\n             optional --output format: OutputFormat\n \n             /// Randomize order in which crates, modules, and items are processed.\n@@ -84,38 +82,37 @@ xflags::xflags! {\n             optional --skip-inference\n         }\n \n-        cmd diagnostics\n+        cmd diagnostics {\n             /// Directory with Cargo.toml.\n             required path: PathBuf\n-        {\n+\n             /// Don't run build scripts or load `OUT_DIR` values by running `cargo check` before analysis.\n             optional --disable-build-scripts\n             /// Don't use expand proc macros.\n             optional --disable-proc-macros\n         }\n \n-        cmd ssr\n+        cmd ssr {\n             /// A structured search replace rule (`$a.foo($b) ==> bar($a, $b)`)\n             repeated rule: SsrRule\n-        {}\n+        }\n \n-        cmd search\n+        cmd search {\n             /// A structured search replace pattern (`$a.foo($b)`)\n             repeated pattern: SsrPattern\n-        {\n             /// Prints debug information for any nodes with source exactly equal to snippet.\n             optional --debug snippet: String\n         }\n \n         cmd proc-macro {}\n \n-        cmd lsif\n+        cmd lsif {\n             required path: PathBuf\n-        {}\n+        }\n \n-        cmd scip\n+        cmd scip {\n             required path: PathBuf\n-        {}\n+        }\n     }\n }\n \n@@ -150,7 +147,6 @@ pub enum RustAnalyzerCmd {\n #[derive(Debug)]\n pub struct LspServer {\n     pub version: bool,\n-    pub help: bool,\n     pub print_config_schema: bool,\n }\n \n@@ -218,7 +214,10 @@ pub struct Scip {\n }\n \n impl RustAnalyzer {\n-    pub const HELP: &'static str = Self::HELP_;\n+    #[allow(dead_code)]\n+    pub fn from_env_or_exit() -> Self {\n+        Self::from_env_or_exit_()\n+    }\n \n     #[allow(dead_code)]\n     pub fn from_env() -> xflags::Result<Self> {"}, {"sha": "5dba545b871844f37f25917fce8bb15926165aa8", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -6,7 +6,7 @@ use anyhow::Result;\n use crossbeam_channel::{unbounded, Receiver};\n use hir::db::DefDatabase;\n use ide::{AnalysisHost, Change};\n-use ide_db::base_db::CrateGraph;\n+use ide_db::{base_db::CrateGraph, FxHashMap};\n use proc_macro_api::ProcMacroServer;\n use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n use vfs::{loader::Handle, AbsPath, AbsPathBuf};\n@@ -38,7 +38,7 @@ pub fn load_workspace_at(\n         workspace.set_build_scripts(build_scripts)\n     }\n \n-    load_workspace(workspace, cargo_config, load_config)\n+    load_workspace(workspace, &cargo_config.extra_env, load_config)\n }\n \n // Note: Since this function is used by external tools that use rust-analyzer as a library\n@@ -48,7 +48,7 @@ pub fn load_workspace_at(\n // these tools need access to `ProjectWorkspace`, too, which `load_workspace_at` hides.\n pub fn load_workspace(\n     ws: ProjectWorkspace,\n-    cargo_config: &CargoConfig,\n+    extra_env: &FxHashMap<String, String>,\n     load_config: &LoadCargoConfig,\n ) -> Result<(AnalysisHost, vfs::Vfs, Option<ProcMacroServer>)> {\n     let (sender, receiver) = unbounded();\n@@ -60,10 +60,26 @@ pub fn load_workspace(\n     };\n \n     let proc_macro_client = if load_config.with_proc_macro {\n-        let path = AbsPathBuf::assert(std::env::current_exe()?);\n-        Ok(ProcMacroServer::spawn(path, &[\"proc-macro\"]).unwrap())\n+        let mut path = AbsPathBuf::assert(std::env::current_exe()?);\n+        let mut args = vec![\"proc-macro\"];\n+\n+        if let ProjectWorkspace::Cargo { sysroot, .. } | ProjectWorkspace::Json { sysroot, .. } =\n+            &ws\n+        {\n+            if let Some(sysroot) = sysroot.as_ref() {\n+                let standalone_server_name =\n+                    format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n+                let server_path = sysroot.root().join(\"libexec\").join(&standalone_server_name);\n+                if std::fs::metadata(&server_path).is_ok() {\n+                    path = server_path;\n+                    args = vec![];\n+                }\n+            }\n+        }\n+\n+        ProcMacroServer::spawn(path.clone(), args.clone()).map_err(|e| e.to_string())\n     } else {\n-        Err(\"proc macro server not started\".to_owned())\n+        Err(\"proc macro server disabled\".to_owned())\n     };\n \n     let crate_graph = ws.to_crate_graph(\n@@ -76,7 +92,7 @@ pub fn load_workspace(\n             vfs.set_file_contents(path.clone(), contents);\n             vfs.file_id(&path)\n         },\n-        cargo_config,\n+        extra_env,\n     );\n \n     let project_folders = ProjectFolders::new(&[ws], &[]);"}, {"sha": "748306ea57d4ee25babc020925925e1a624b8fcf", "filename": "crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -300,7 +300,7 @@ impl flags::Lsif {\n         let workspace = ProjectWorkspace::load(manifest, &cargo_config, no_progress)?;\n \n         let (host, vfs, _proc_macro) =\n-            load_workspace(workspace, &cargo_config, &load_cargo_config)?;\n+            load_workspace(workspace, &cargo_config.extra_env, &load_cargo_config)?;\n         let db = host.raw_database();\n         let analysis = host.analysis();\n "}, {"sha": "2c29b3ee3a6f7d82e76892855c48ef70b56a5206", "filename": "crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -40,7 +40,8 @@ impl flags::Scip {\n \n         let workspace = ProjectWorkspace::load(manifest, &cargo_config, no_progress)?;\n \n-        let (host, vfs, _) = load_workspace(workspace, &cargo_config, &load_cargo_config)?;\n+        let (host, vfs, _) =\n+            load_workspace(workspace, &cargo_config.extra_env, &load_cargo_config)?;\n         let db = host.raw_database();\n         let analysis = host.analysis();\n "}, {"sha": "577a8640a4c00acd659e6dfe6b6e3cadb5e95aca", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -7,7 +7,7 @@\n //! configure the server itself, feature flags are passed into analysis, and\n //! tweak things like automatic insertion of `()` in completions.\n \n-use std::{ffi::OsString, fmt, iter, path::PathBuf};\n+use std::{fmt, iter, path::PathBuf};\n \n use flycheck::FlycheckConfig;\n use ide::{\n@@ -22,7 +22,8 @@ use ide_db::{\n use itertools::Itertools;\n use lsp_types::{ClientCapabilities, MarkupKind};\n use project_model::{\n-    CargoConfig, ProjectJson, ProjectJsonData, ProjectManifest, RustcSource, UnsetTestCrates,\n+    CargoConfig, CargoFeatures, ProjectJson, ProjectJsonData, ProjectManifest, RustcSource,\n+    UnsetTestCrates,\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n use serde::{de::DeserializeOwned, Deserialize};\n@@ -90,11 +91,16 @@ config_data! {\n         /// List of features to activate.\n         ///\n         /// Set this to `\"all\"` to pass `--all-features` to cargo.\n-        cargo_features: CargoFeatures      = \"[]\",\n+        cargo_features: CargoFeaturesDef      = \"[]\",\n         /// Whether to pass `--no-default-features` to cargo.\n         cargo_noDefaultFeatures: bool    = \"false\",\n-        /// Internal config for debugging, disables loading of sysroot crates.\n-        cargo_noSysroot: bool            = \"false\",\n+        /// Relative path to the sysroot, or \"discover\" to try to automatically find it via\n+        /// \"rustc --print sysroot\".\n+        ///\n+        /// Unsetting this disables sysroot loading.\n+        ///\n+        /// This option does not take effect until rust-analyzer is restarted.\n+        cargo_sysroot: Option<String>    = \"\\\"discover\\\"\",\n         /// Compilation target override (target triple).\n         cargo_target: Option<String>     = \"null\",\n         /// Unsets `#[cfg(test)]` for the specified crates.\n@@ -109,12 +115,13 @@ config_data! {\n         /// Extra arguments for `cargo check`.\n         checkOnSave_extraArgs: Vec<String>               = \"[]\",\n         /// Extra environment variables that will be set when running `cargo check`.\n+        /// Extends `#rust-analyzer.cargo.extraEnv#`.\n         checkOnSave_extraEnv: FxHashMap<String, String> = \"{}\",\n         /// List of features to activate. Defaults to\n         /// `#rust-analyzer.cargo.features#`.\n         ///\n         /// Set to `\"all\"` to pass `--all-features` to Cargo.\n-        checkOnSave_features: Option<CargoFeatures>      = \"null\",\n+        checkOnSave_features: Option<CargoFeaturesDef>      = \"null\",\n         /// Whether to pass `--no-default-features` to Cargo. Defaults to\n         /// `#rust-analyzer.cargo.noDefaultFeatures#`.\n         checkOnSave_noDefaultFeatures: Option<bool>      = \"null\",\n@@ -975,15 +982,17 @@ impl Config {\n         self.data.lru_capacity\n     }\n \n-    pub fn proc_macro_srv(&self) -> Option<(AbsPathBuf, Vec<OsString>)> {\n+    pub fn proc_macro_srv(&self) -> Option<(AbsPathBuf, /* is path explicitly set */ bool)> {\n         if !self.data.procMacro_enable {\n             return None;\n         }\n-        let path = match &self.data.procMacro_server {\n-            Some(it) => self.root_path.join(it),\n-            None => AbsPathBuf::assert(std::env::current_exe().ok()?),\n-        };\n-        Some((path, vec![\"proc-macro\".into()]))\n+        Some(match &self.data.procMacro_server {\n+            Some(it) => (\n+                AbsPathBuf::try_from(it.clone()).unwrap_or_else(|path| self.root_path.join(path)),\n+                true,\n+            ),\n+            None => (AbsPathBuf::assert(std::env::current_exe().ok()?), false),\n+        })\n     }\n \n     pub fn dummy_replacements(&self) -> &FxHashMap<Box<str>, Box<[Box<str>]>> {\n@@ -1026,16 +1035,24 @@ impl Config {\n                 RustcSource::Path(self.root_path.join(rustc_src))\n             }\n         });\n+        let sysroot = self.data.cargo_sysroot.as_ref().map(|sysroot| {\n+            if sysroot == \"discover\" {\n+                RustcSource::Discover\n+            } else {\n+                RustcSource::Path(self.root_path.join(sysroot))\n+            }\n+        });\n \n         CargoConfig {\n-            no_default_features: self.data.cargo_noDefaultFeatures,\n-            all_features: matches!(self.data.cargo_features, CargoFeatures::All),\n             features: match &self.data.cargo_features {\n-                CargoFeatures::All => vec![],\n-                CargoFeatures::Listed(it) => it.clone(),\n+                CargoFeaturesDef::All => CargoFeatures::All,\n+                CargoFeaturesDef::Selected(features) => CargoFeatures::Selected {\n+                    features: features.clone(),\n+                    no_default_features: self.data.cargo_noDefaultFeatures,\n+                },\n             },\n             target: self.data.cargo_target.clone(),\n-            no_sysroot: self.data.cargo_noSysroot,\n+            sysroot,\n             rustc_source,\n             unset_test_crates: UnsetTestCrates::Only(self.data.cargo_unsetTest.clone()),\n             wrap_rustc_in_build_scripts: self.data.cargo_buildScripts_useRustcWrapper,\n@@ -1086,16 +1103,16 @@ impl Config {\n                     .unwrap_or(self.data.cargo_noDefaultFeatures),\n                 all_features: matches!(\n                     self.data.checkOnSave_features.as_ref().unwrap_or(&self.data.cargo_features),\n-                    CargoFeatures::All\n+                    CargoFeaturesDef::All\n                 ),\n                 features: match self\n                     .data\n                     .checkOnSave_features\n                     .clone()\n                     .unwrap_or_else(|| self.data.cargo_features.clone())\n                 {\n-                    CargoFeatures::All => vec![],\n-                    CargoFeatures::Listed(it) => it,\n+                    CargoFeaturesDef::All => vec![],\n+                    CargoFeaturesDef::Selected(it) => it,\n                 },\n                 extra_args: self.data.checkOnSave_extraArgs.clone(),\n                 extra_env: self.check_on_save_extra_env(),\n@@ -1564,10 +1581,10 @@ enum CallableCompletionDef {\n \n #[derive(Deserialize, Debug, Clone)]\n #[serde(untagged)]\n-enum CargoFeatures {\n+enum CargoFeaturesDef {\n     #[serde(deserialize_with = \"de_unit_v::all\")]\n     All,\n-    Listed(Vec<String>),\n+    Selected(Vec<String>),\n }\n \n #[derive(Deserialize, Debug, Clone)]\n@@ -1912,7 +1929,7 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 \"Only show mutable reborrow hints.\"\n             ]\n         },\n-        \"CargoFeatures\" => set! {\n+        \"CargoFeaturesDef\" => set! {\n             \"anyOf\": [\n                 {\n                     \"type\": \"string\",\n@@ -1929,7 +1946,7 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 }\n             ],\n         },\n-        \"Option<CargoFeatures>\" => set! {\n+        \"Option<CargoFeaturesDef>\" => set! {\n             \"anyOf\": [\n                 {\n                     \"type\": \"string\","}, {"sha": "f2db9a27334979da9b2185f0e651c6f071081969", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -95,22 +95,22 @@ pub(crate) fn annotation(\n \n     match resolve {\n         lsp_ext::CodeLensResolveData::Impls(params) => {\n-            let file_id =\n-                snap.url_to_file_id(&params.text_document_position_params.text_document.uri)?;\n+            let pos @ FilePosition { file_id, .. } =\n+                file_position(snap, params.text_document_position_params)?;\n             let line_index = snap.file_line_index(file_id)?;\n \n             Ok(Annotation {\n                 range: text_range(&line_index, code_lens.range)?,\n-                kind: AnnotationKind::HasImpls { file_id, data: None },\n+                kind: AnnotationKind::HasImpls { pos, data: None },\n             })\n         }\n         lsp_ext::CodeLensResolveData::References(params) => {\n-            let file_id = snap.url_to_file_id(&params.text_document.uri)?;\n+            let pos @ FilePosition { file_id, .. } = file_position(snap, params)?;\n             let line_index = snap.file_line_index(file_id)?;\n \n             Ok(Annotation {\n                 range: text_range(&line_index, code_lens.range)?,\n-                kind: AnnotationKind::HasReferences { file_id, data: None },\n+                kind: AnnotationKind::HasReferences { pos, data: None },\n             })\n         }\n     }"}, {"sha": "000ff88e458f6e4256a227138490369d9cbbbfb1", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -185,11 +185,48 @@ impl GlobalState {\n         let (change, changed_files) = {\n             let mut change = Change::new();\n             let (vfs, line_endings_map) = &mut *self.vfs.write();\n-            let changed_files = vfs.take_changes();\n+            let mut changed_files = vfs.take_changes();\n             if changed_files.is_empty() {\n                 return false;\n             }\n \n+            // important: this needs to be a stable sort, the order between changes is relevant\n+            // for the same file ids\n+            changed_files.sort_by_key(|file| file.file_id);\n+            // We need to fix up the changed events a bit, if we have a create or modify for a file\n+            // id that is followed by a delete we actually no longer observe the file text from the\n+            // create or modify which may cause problems later on\n+            changed_files.dedup_by(|a, b| {\n+                use vfs::ChangeKind::*;\n+\n+                if a.file_id != b.file_id {\n+                    return false;\n+                }\n+\n+                match (a.change_kind, b.change_kind) {\n+                    // duplicate can be merged\n+                    (Create, Create) | (Modify, Modify) | (Delete, Delete) => true,\n+                    // just leave the create, modify is irrelevant\n+                    (Create, Modify) => {\n+                        std::mem::swap(a, b);\n+                        true\n+                    }\n+                    // modify becomes irrelevant if the file is deleted\n+                    (Modify, Delete) => true,\n+                    // we should fully remove this occurrence,\n+                    // but leaving just a delete works as well\n+                    (Create, Delete) => true,\n+                    // this is equivalent to a modify\n+                    (Delete, Create) => {\n+                        a.change_kind = Modify;\n+                        true\n+                    }\n+                    // can't really occur\n+                    (Modify, Create) => false,\n+                    (Delete, Modify) => false,\n+                }\n+            });\n+\n             for file in &changed_files {\n                 if let Some(path) = vfs.file_path(file.file_id).as_path() {\n                     let path = path.to_path_buf();\n@@ -317,6 +354,10 @@ impl GlobalState {\n         }\n     }\n \n+    pub(crate) fn is_completed(&self, request: &lsp_server::Request) -> bool {\n+        self.req_queue.incoming.is_completed(&request.id)\n+    }\n+\n     fn send(&mut self, message: lsp_server::Message) {\n         self.sender.send(message).unwrap()\n     }"}, {"sha": "15922dac651cce834818de41cc479e50248632d6", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -425,7 +425,9 @@ impl GlobalState {\n     fn handle_task(&mut self, prime_caches_progress: &mut Vec<PrimeCachesProgress>, task: Task) {\n         match task {\n             Task::Response(response) => self.respond(response),\n-            Task::Retry(req) => self.on_request(req),\n+            // Only retry requests that haven't been cancelled. Otherwise we do unnecessary work.\n+            Task::Retry(req) if !self.is_completed(&req) => self.on_request(req),\n+            Task::Retry(_) => (),\n             Task::Diagnostics(diagnostics_per_file) => {\n                 for (file_id, diagnostics) in diagnostics_per_file {\n                     self.diagnostics.set_native_diagnostics(file_id, diagnostics)"}, {"sha": "f8734893944624e169bc8969da9759707945b9ad", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -143,7 +143,7 @@ impl GlobalState {\n                             project_model::ProjectWorkspace::load_inline(\n                                 it.clone(),\n                                 cargo_config.target.as_deref(),\n-                                &cargo_config,\n+                                &cargo_config.extra_env,\n                             )\n                         }\n                     })\n@@ -306,41 +306,50 @@ impl GlobalState {\n             format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n \n         if self.proc_macro_clients.is_empty() {\n-            if let Some((path, args)) = self.config.proc_macro_srv() {\n+            if let Some((path, path_manually_set)) = self.config.proc_macro_srv() {\n                 tracing::info!(\"Spawning proc-macro servers\");\n                 self.proc_macro_clients = self\n                     .workspaces\n                     .iter()\n                     .map(|ws| {\n-                        let mut args = args.clone();\n-                        let mut path = path.clone();\n-\n-                        if let ProjectWorkspace::Cargo { sysroot, .. }\n-                        | ProjectWorkspace::Json { sysroot, .. } = ws\n-                        {\n-                            tracing::debug!(\"Found a cargo workspace...\");\n-                            if let Some(sysroot) = sysroot.as_ref() {\n-                                tracing::debug!(\"Found a cargo workspace with a sysroot...\");\n-                                let server_path =\n-                                    sysroot.root().join(\"libexec\").join(&standalone_server_name);\n-                                if std::fs::metadata(&server_path).is_ok() {\n-                                    tracing::debug!(\n-                                        \"And the server exists at {}\",\n-                                        server_path.display()\n-                                    );\n-                                    path = server_path;\n-                                    args = vec![];\n-                                } else {\n-                                    tracing::debug!(\n-                                        \"And the server does not exist at {}\",\n-                                        server_path.display()\n-                                    );\n+                        let (path, args) = if path_manually_set {\n+                            tracing::debug!(\n+                                \"Pro-macro server path explicitly set: {}\",\n+                                path.display()\n+                            );\n+                            (path.clone(), vec![])\n+                        } else {\n+                            let mut sysroot_server = None;\n+                            if let ProjectWorkspace::Cargo { sysroot, .. }\n+                            | ProjectWorkspace::Json { sysroot, .. } = ws\n+                            {\n+                                if let Some(sysroot) = sysroot.as_ref() {\n+                                    let server_path = sysroot\n+                                        .root()\n+                                        .join(\"libexec\")\n+                                        .join(&standalone_server_name);\n+                                    if std::fs::metadata(&server_path).is_ok() {\n+                                        tracing::debug!(\n+                                            \"Sysroot proc-macro server exists at {}\",\n+                                            server_path.display()\n+                                        );\n+                                        sysroot_server = Some(server_path);\n+                                    } else {\n+                                        tracing::debug!(\n+                                            \"Sysroot proc-macro server does not exist at {}\",\n+                                            server_path.display()\n+                                        );\n+                                    }\n                                 }\n                             }\n-                        }\n+                            sysroot_server.map_or_else(\n+                                || (path.clone(), vec![\"proc-macro\".to_owned()]),\n+                                |path| (path, vec![]),\n+                            )\n+                        };\n \n                         tracing::info!(?args, \"Using proc-macro server at {}\", path.display(),);\n-                        ProcMacroServer::spawn(path.clone(), args.clone()).map_err(|err| {\n+                        ProcMacroServer::spawn(path.clone(), args).map_err(|err| {\n                             let error = format!(\n                                 \"Failed to run proc-macro server from path {}, error: {:?}\",\n                                 path.display(),\n@@ -402,7 +411,7 @@ impl GlobalState {\n                 crate_graph.extend(ws.to_crate_graph(\n                     &mut load_proc_macro,\n                     &mut load,\n-                    &self.config.cargo(),\n+                    &self.config.cargo().extra_env,\n                 ));\n             }\n             crate_graph"}, {"sha": "5936454a7c546e487122b0f06dc822a36890755b", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -1177,13 +1177,13 @@ pub(crate) fn code_lens(\n                 })\n             }\n         }\n-        AnnotationKind::HasImpls { file_id, data } => {\n+        AnnotationKind::HasImpls { pos: file_range, data } => {\n             if !client_commands_config.show_reference {\n                 return Ok(());\n             }\n-            let line_index = snap.file_line_index(file_id)?;\n+            let line_index = snap.file_line_index(file_range.file_id)?;\n             let annotation_range = range(&line_index, annotation.range);\n-            let url = url(snap, file_id);\n+            let url = url(snap, file_range.file_id);\n \n             let id = lsp_types::TextDocumentIdentifier { uri: url.clone() };\n \n@@ -1221,13 +1221,13 @@ pub(crate) fn code_lens(\n                 data: Some(to_value(lsp_ext::CodeLensResolveData::Impls(goto_params)).unwrap()),\n             })\n         }\n-        AnnotationKind::HasReferences { file_id, data } => {\n+        AnnotationKind::HasReferences { pos: file_range, data } => {\n             if !client_commands_config.show_reference {\n                 return Ok(());\n             }\n-            let line_index = snap.file_line_index(file_id)?;\n+            let line_index = snap.file_line_index(file_range.file_id)?;\n             let annotation_range = range(&line_index, annotation.range);\n-            let url = url(snap, file_id);\n+            let url = url(snap, file_range.file_id);\n \n             let id = lsp_types::TextDocumentIdentifier { uri: url.clone() };\n "}, {"sha": "fa55f7d90c49db01e7a0d8019615599a43dafdd3", "filename": "crates/rust-analyzer/tests/slow-tests/main.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -18,7 +18,6 @@ mod tidy;\n \n use std::{collections::HashMap, path::PathBuf, time::Instant};\n \n-use expect_test::expect;\n use lsp_types::{\n     notification::DidOpenTextDocument,\n     request::{\n@@ -60,7 +59,7 @@ use std::collections::Spam;\n \"#,\n     )\n     .with_config(serde_json::json!({\n-        \"cargo\": { \"noSysroot\": false }\n+        \"cargo\": { \"sysroot\": \"discover\" }\n     }))\n     .server()\n     .wait_until_workspace_is_loaded();\n@@ -615,7 +614,7 @@ fn main() {{}}\n         librs, libs\n     ))\n     .with_config(serde_json::json!({\n-        \"cargo\": { \"noSysroot\": false }\n+        \"cargo\": { \"sysroot\": \"discover\" }\n     }))\n     .server()\n     .wait_until_workspace_is_loaded();\n@@ -743,7 +742,7 @@ fn main() {\n             \"buildScripts\": {\n                 \"enable\": true\n             },\n-            \"noSysroot\": true,\n+            \"sysroot\": null,\n         }\n     }))\n     .server()\n@@ -821,7 +820,10 @@ fn main() {\n }\n \n #[test]\n+// FIXME: Re-enable once we can run proc-macro tests on rust-lang/rust-analyzer again\n+#[cfg(any())]\n fn resolve_proc_macro() {\n+    use expect_test::expect;\n     if skip_slow_tests() {\n         return;\n     }\n@@ -898,7 +900,7 @@ pub fn foo(_input: TokenStream) -> TokenStream {\n             \"buildScripts\": {\n                 \"enable\": true\n             },\n-            \"noSysroot\": true,\n+            \"sysroot\": null,\n         },\n         \"procMacro\": {\n             \"enable\": true,"}, {"sha": "7257445dabe05f108da9bebcb6c61162bc72137b", "filename": "crates/rust-analyzer/tests/slow-tests/support.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -34,7 +34,7 @@ impl<'a> Project<'a> {\n             config: serde_json::json!({\n                 \"cargo\": {\n                     // Loading standard library is costly, let's ignore it by default\n-                    \"noSysroot\": true,\n+                    \"sysroot\": null,\n                     // Can't use test binary as rustc wrapper.\n                     \"buildScripts\": {\n                         \"useRustcWrapper\": false"}, {"sha": "24e68eca676d7419ece4bb0125f479f652a617ef", "filename": "crates/rust-analyzer/tests/slow-tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -177,6 +177,7 @@ fn check_licenses() {\n     let sh = &Shell::new().unwrap();\n \n     let expected = \"\n+(MIT OR Apache-2.0) AND Unicode-DFS-2016\n 0BSD OR MIT OR Apache-2.0\n Apache-2.0\n Apache-2.0 OR BSL-1.0"}, {"sha": "e75867e2d81cf59bf75b46a2a2f7af1b59a3ede0", "filename": "crates/sourcegen/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fsourcegen%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fsourcegen%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsourcegen%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -11,6 +11,3 @@ doctest = false\n \n [dependencies]\n xshell = \"0.2.2\"\n-\n-[features]\n-in-rust-tree = []"}, {"sha": "e0657ab0f6d1c20fe439a74720da590b07cf8c3e", "filename": "crates/stdx/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fstdx%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fstdx%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -10,7 +10,7 @@ rust-version = \"1.57\"\n doctest = false\n \n [dependencies]\n-libc = \"0.2.126\"\n+libc = \"0.2.135\"\n backtrace = { version = \"0.3.65\", optional = true }\n always-assert = { version = \"0.1.2\", features = [\"log\"] }\n # Think twice before adding anything here"}, {"sha": "1ef903371cf896de2c31abf83b17d1b58af112d3", "filename": "crates/syntax/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -12,11 +12,11 @@ doctest = false\n \n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n-itertools = \"0.10.3\"\n-rowan = \"0.15.8\"\n+itertools = \"0.10.5\"\n+rowan = \"0.15.10\"\n rustc_lexer = { version = \"725.0.0\", package = \"rustc-ap-rustc_lexer\" }\n rustc-hash = \"1.1.0\"\n-once_cell = \"1.12.0\"\n+once_cell = \"1.15.0\"\n indexmap = \"1.9.1\"\n smol_str = \"0.1.23\"\n \n@@ -28,7 +28,7 @@ profile = { path = \"../profile\", version = \"0.0.0\" }\n [dev-dependencies]\n rayon = \"1.5.3\"\n expect-test = \"1.4.0\"\n-proc-macro2 = \"1.0.39\"\n+proc-macro2 = \"1.0.47\"\n quote = \"1.0.20\"\n ungrammar = \"1.16.1\"\n "}, {"sha": "229e7419b736febecf341b114dc86b121e6e006d", "filename": "crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -235,6 +235,24 @@ impl ast::GenericParamList {\n             }\n         }\n     }\n+\n+    /// Constructs a matching [`ast::GenericArgList`]\n+    pub fn to_generic_args(&self) -> ast::GenericArgList {\n+        let args = self.generic_params().filter_map(|param| match param {\n+            ast::GenericParam::LifetimeParam(it) => {\n+                Some(ast::GenericArg::LifetimeArg(make::lifetime_arg(it.lifetime()?)))\n+            }\n+            ast::GenericParam::TypeParam(it) => {\n+                Some(ast::GenericArg::TypeArg(make::type_arg(make::ext::ty_name(it.name()?))))\n+            }\n+            ast::GenericParam::ConstParam(it) => {\n+                // Name-only const params get parsed as `TypeArg`s\n+                Some(ast::GenericArg::TypeArg(make::type_arg(make::ext::ty_name(it.name()?))))\n+            }\n+        });\n+\n+        make::generic_arg_list(args)\n+    }\n }\n \n impl ast::WhereClause {\n@@ -248,6 +266,42 @@ impl ast::WhereClause {\n     }\n }\n \n+impl ast::TypeParam {\n+    pub fn remove_default(&self) {\n+        if let Some((eq, last)) = self\n+            .syntax()\n+            .children_with_tokens()\n+            .find(|it| it.kind() == T![=])\n+            .zip(self.syntax().last_child_or_token())\n+        {\n+            ted::remove_all(eq..=last);\n+\n+            // remove any trailing ws\n+            if let Some(last) = self.syntax().last_token().filter(|it| it.kind() == WHITESPACE) {\n+                last.detach();\n+            }\n+        }\n+    }\n+}\n+\n+impl ast::ConstParam {\n+    pub fn remove_default(&self) {\n+        if let Some((eq, last)) = self\n+            .syntax()\n+            .children_with_tokens()\n+            .find(|it| it.kind() == T![=])\n+            .zip(self.syntax().last_child_or_token())\n+        {\n+            ted::remove_all(eq..=last);\n+\n+            // remove any trailing ws\n+            if let Some(last) = self.syntax().last_token().filter(|it| it.kind() == WHITESPACE) {\n+                last.detach();\n+            }\n+        }\n+    }\n+}\n+\n pub trait Removable: AstNode {\n     fn remove(&self);\n }\n@@ -264,7 +318,7 @@ impl Removable for ast::TypeBoundList {\n impl ast::PathSegment {\n     pub fn get_or_create_generic_arg_list(&self) -> ast::GenericArgList {\n         if self.generic_arg_list().is_none() {\n-            let arg_list = make::generic_arg_list().clone_for_update();\n+            let arg_list = make::generic_arg_list(empty()).clone_for_update();\n             ted::append_child(self.syntax(), arg_list.syntax());\n         }\n         self.generic_arg_list().unwrap()"}, {"sha": "4057a75e7c1e693d053e987ac39bb588ec02b9fa", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -88,6 +88,9 @@ pub mod ext {\n         block_expr(None, None)\n     }\n \n+    pub fn ty_name(name: ast::Name) -> ast::Type {\n+        ty_path(ident_path(&name.to_string()))\n+    }\n     pub fn ty_bool() -> ast::Type {\n         ty_path(ident_path(\"bool\"))\n     }\n@@ -160,6 +163,7 @@ pub fn assoc_item_list() -> ast::AssocItemList {\n     ast_from_text(\"impl C for D {}\")\n }\n \n+// FIXME: `ty_params` should be `ast::GenericArgList`\n pub fn impl_(\n     ty: ast::Path,\n     params: Option<ast::GenericParamList>,\n@@ -185,10 +189,6 @@ pub fn impl_trait(\n     ast_from_text(&format!(\"impl{ty_params} {trait_} for {ty}{ty_params} {{}}\"))\n }\n \n-pub(crate) fn generic_arg_list() -> ast::GenericArgList {\n-    ast_from_text(\"const S: T<> = ();\")\n-}\n-\n pub fn path_segment(name_ref: ast::NameRef) -> ast::PathSegment {\n     ast_from_text(&format!(\"type __ = {name_ref};\"))\n }\n@@ -718,6 +718,21 @@ pub fn generic_param_list(\n     ast_from_text(&format!(\"fn f<{args}>() {{ }}\"))\n }\n \n+pub fn type_arg(ty: ast::Type) -> ast::TypeArg {\n+    ast_from_text(&format!(\"const S: T<{ty}> = ();\"))\n+}\n+\n+pub fn lifetime_arg(lifetime: ast::Lifetime) -> ast::LifetimeArg {\n+    ast_from_text(&format!(\"const S: T<{lifetime}> = ();\"))\n+}\n+\n+pub(crate) fn generic_arg_list(\n+    args: impl IntoIterator<Item = ast::GenericArg>,\n+) -> ast::GenericArgList {\n+    let args = args.into_iter().join(\", \");\n+    ast_from_text(&format!(\"const S: T<{args}> = ();\"))\n+}\n+\n pub fn visibility_pub_crate() -> ast::Visibility {\n     ast_from_text(\"pub(crate) struct S\")\n }"}, {"sha": "fe82aa907222f7d4e97d03c69cd91d420c276c3c", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -873,3 +873,33 @@ impl ast::MatchGuard {\n         support::child(&self.syntax)\n     }\n }\n+\n+impl From<ast::Item> for ast::AnyHasAttrs {\n+    fn from(node: ast::Item) -> Self {\n+        Self::new(node)\n+    }\n+}\n+\n+impl From<ast::AssocItem> for ast::AnyHasAttrs {\n+    fn from(node: ast::AssocItem) -> Self {\n+        Self::new(node)\n+    }\n+}\n+\n+impl From<ast::Variant> for ast::AnyHasAttrs {\n+    fn from(node: ast::Variant) -> Self {\n+        Self::new(node)\n+    }\n+}\n+\n+impl From<ast::RecordField> for ast::AnyHasAttrs {\n+    fn from(node: ast::RecordField) -> Self {\n+        Self::new(node)\n+    }\n+}\n+\n+impl From<ast::TupleField> for ast::AnyHasAttrs {\n+    fn from(node: ast::TupleField) -> Self {\n+        Self::new(node)\n+    }\n+}"}, {"sha": "c824f5af7258485bb8aa97460ab23fc0f216a647", "filename": "crates/test-utils/src/fixture.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Ftest-utils%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Ftest-utils%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Ffixture.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -61,6 +61,8 @@\n //! \"\n //! ```\n \n+use std::iter;\n+\n use rustc_hash::FxHashMap;\n use stdx::trim_indent;\n \n@@ -259,7 +261,7 @@ impl MiniCore {\n             if res.has_flag(entry) {\n                 panic!(\"duplicate minicore flag: {:?}\", entry);\n             }\n-            res.activated_flags.push(entry.to_string());\n+            res.activated_flags.push(entry.to_owned());\n         }\n \n         res\n@@ -273,35 +275,34 @@ impl MiniCore {\n         let raw_mini_core = include_str!(\"./minicore.rs\");\n         let mut lines = raw_mini_core.split_inclusive('\\n');\n \n-        let mut parsing_flags = false;\n         let mut implications = Vec::new();\n \n         // Parse `//!` preamble and extract flags and dependencies.\n-        for line in lines.by_ref() {\n-            let line = match line.strip_prefix(\"//!\") {\n-                Some(it) => it,\n-                None => {\n-                    assert!(line.trim().is_empty());\n-                    break;\n-                }\n-            };\n-\n-            if parsing_flags {\n-                let (flag, deps) = line.split_once(':').unwrap();\n-                let flag = flag.trim();\n-                self.valid_flags.push(flag.to_string());\n-                for dep in deps.split(\", \") {\n-                    let dep = dep.trim();\n-                    if !dep.is_empty() {\n-                        self.assert_valid_flag(dep);\n-                        implications.push((flag, dep));\n-                    }\n-                }\n+        let trim_doc: fn(&str) -> Option<&str> = |line| match line.strip_prefix(\"//!\") {\n+            Some(it) => Some(it),\n+            None => {\n+                assert!(line.trim().is_empty(), \"expected empty line after minicore header\");\n+                None\n             }\n+        };\n+        for line in lines\n+            .by_ref()\n+            .map_while(trim_doc)\n+            .skip_while(|line| !line.contains(\"Available flags:\"))\n+            .skip(1)\n+        {\n+            let (flag, deps) = line.split_once(':').unwrap();\n+            let flag = flag.trim();\n+\n+            self.valid_flags.push(flag.to_string());\n+            implications.extend(\n+                iter::repeat(flag)\n+                    .zip(deps.split(\", \").map(str::trim).filter(|dep| !dep.is_empty())),\n+            );\n+        }\n \n-            if line.contains(\"Available flags:\") {\n-                parsing_flags = true;\n-            }\n+        for (_, dep) in &implications {\n+            self.assert_valid_flag(dep);\n         }\n \n         for flag in &self.activated_flags {\n@@ -332,7 +333,7 @@ impl MiniCore {\n             }\n             if let Some(region) = trimmed.strip_prefix(\"// endregion:\") {\n                 let prev = active_regions.pop().unwrap();\n-                assert_eq!(prev, region);\n+                assert_eq!(prev, region, \"unbalanced region pairs\");\n                 continue;\n             }\n "}, {"sha": "59b1c147d7f174e08339de3225c5e3541b2af1c9", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 105, "deletions": 26, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -8,35 +8,37 @@\n //! We then strip all the code marked with other flags.\n //!\n //! Available flags:\n-//!     sized:\n-//!     unsize: sized\n+//!     add:\n+//!     as_ref: sized\n+//!     bool_impl: option, fn\n+//!     clone: sized\n //!     coerce_unsized: unsize\n-//!     slice:\n-//!     range:\n-//!     deref: sized\n+//!     copy: clone\n+//!     default: sized\n //!     deref_mut: deref\n-//!     index: sized\n+//!     deref: sized\n+//!     derive:\n+//!     drop:\n+//!     eq: sized\n+//!     fmt: result\n //!     fn:\n-//!     try:\n-//!     pin:\n+//!     from: sized\n //!     future: pin\n-//!     option:\n-//!     result:\n+//!     generator: pin\n+//!     hash:\n+//!     index: sized\n+//!     infallible:\n //!     iterator: option\n //!     iterators: iterator, fn\n-//!     default: sized\n-//!     hash:\n-//!     clone: sized\n-//!     copy: clone\n-//!     from: sized\n-//!     eq: sized\n+//!     option:\n //!     ord: eq, option\n-//!     derive:\n-//!     fmt: result\n-//!     bool_impl: option, fn\n-//!     add:\n-//!     as_ref: sized\n-//!     drop:\n+//!     pin:\n+//!     range:\n+//!     result:\n+//!     sized:\n+//!     slice:\n+//!     try: infallible\n+//!     unsize: sized\n \n pub mod marker {\n     // region:sized\n@@ -149,6 +151,9 @@ pub mod convert {\n         fn as_ref(&self) -> &T;\n     }\n     // endregion:as_ref\n+    // region:infallible\n+    pub enum Infallible {}\n+    // endregion:infallible\n }\n \n pub mod ops {\n@@ -182,6 +187,19 @@ pub mod ops {\n             type Target: ?Sized;\n             fn deref(&self) -> &Self::Target;\n         }\n+\n+        impl<T: ?Sized> Deref for &T {\n+            type Target = T;\n+            fn deref(&self) -> &T {\n+                loop {}\n+            }\n+        }\n+        impl<T: ?Sized> Deref for &mut T {\n+            type Target = T;\n+            fn deref(&self) -> &T {\n+                loop {}\n+            }\n+        }\n         // region:deref_mut\n         #[lang = \"deref_mut\"]\n         pub trait DerefMut: Deref {\n@@ -312,7 +330,7 @@ pub mod ops {\n             Continue(C),\n             Break(B),\n         }\n-        pub trait FromResidual<R = Self::Residual> {\n+        pub trait FromResidual<R = <Self as Try>::Residual> {\n             #[lang = \"from_residual\"]\n             fn from_residual(residual: R) -> Self;\n         }\n@@ -328,13 +346,13 @@ pub mod ops {\n \n         impl<B, C> Try for ControlFlow<B, C> {\n             type Output = C;\n-            type Residual = ControlFlow<B, convert::Infallible>;\n+            type Residual = ControlFlow<B, crate::convert::Infallible>;\n             fn from_output(output: Self::Output) -> Self {}\n             fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {}\n         }\n \n         impl<B, C> FromResidual for ControlFlow<B, C> {\n-            fn from_residual(residual: ControlFlow<B, convert::Infallible>) -> Self {}\n+            fn from_residual(residual: ControlFlow<B, crate::convert::Infallible>) -> Self {}\n         }\n     }\n     pub use self::try_::{ControlFlow, FromResidual, Try};\n@@ -347,6 +365,27 @@ pub mod ops {\n         fn add(self, rhs: Rhs) -> Self::Output;\n     }\n     // endregion:add\n+\n+    // region:generator\n+    mod generator {\n+        use crate::pin::Pin;\n+\n+        #[lang = \"generator\"]\n+        pub trait Generator<R = ()> {\n+            type Yield;\n+            #[lang = \"generator_return\"]\n+            type Return;\n+            fn resume(self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return>;\n+        }\n+\n+        #[lang = \"generator_state\"]\n+        pub enum GeneratorState<Y, R> {\n+            Yielded(Y),\n+            Complete(R),\n+        }\n+    }\n+    pub use self::generator::{Generator, GeneratorState};\n+    // endregion:generator\n }\n \n // region:eq\n@@ -434,6 +473,33 @@ pub mod option {\n             }\n         }\n     }\n+    // region:try\n+    impl<T> crate::ops::Try for Option<T> {\n+        type Output = T;\n+        type Residual = Option<crate::convert::Infallible>;\n+\n+        #[inline]\n+        fn from_output(output: Self::Output) -> Self {\n+            Some(output)\n+        }\n+\n+        #[inline]\n+        fn branch(self) -> crate::ops::ControlFlow<Self::Residual, Self::Output> {\n+            match self {\n+                Some(v) => crate::ops::ControlFlow::Continue(v),\n+                None => crate::ops::ControlFlow::Break(None),\n+            }\n+        }\n+    }\n+    impl<T> crate::ops::FromResidual for Option<T> {\n+        #[inline]\n+        fn from_residual(residual: Option<crate::convert::Infallible>) -> Self {\n+            match residual {\n+                None => None,\n+            }\n+        }\n+    }\n+    // endregion:try\n }\n // endregion:option\n \n@@ -455,6 +521,19 @@ pub mod pin {\n     pub struct Pin<P> {\n         pointer: P,\n     }\n+    impl<P> Pin<P> {\n+        pub fn new(pointer: P) -> Pin<P> {\n+            loop {}\n+        }\n+    }\n+    // region:deref\n+    impl<P: crate::ops::Deref> crate::ops::Deref for Pin<P> {\n+        type Target = P::Target;\n+        fn deref(&self) -> &P::Target {\n+            loop {}\n+        }\n+    }\n+    // endregion:deref\n }\n // endregion:pin\n \n@@ -536,7 +615,7 @@ pub mod iter {\n             }\n         }\n     }\n-    pub use self::adapters::{Take, FilterMap};\n+    pub use self::adapters::{FilterMap, Take};\n \n     mod sources {\n         mod repeat {"}, {"sha": "7a90d64a98ba9b01a55678f82ec00328724094ba", "filename": "crates/text-edit/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Ftext-edit%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Ftext-edit%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftext-edit%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -10,5 +10,5 @@ rust-version = \"1.57\"\n doctest = false\n \n [dependencies]\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n text-size = \"1.1.0\""}, {"sha": "3e0f31f19c507fc417fc413fd0039a5b9d124e8a", "filename": "crates/toolchain/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Ftoolchain%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Ftoolchain%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftoolchain%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -10,4 +10,4 @@ rust-version = \"1.57\"\n doctest = false\n \n [dependencies]\n-home = \"0.5.3\"\n+home = \"0.5.4\""}, {"sha": "df5dc24e2cd12a15806ecef192798595a013e27b", "filename": "crates/vfs-notify/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fvfs-notify%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/crates%2Fvfs-notify%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -14,7 +14,7 @@ tracing = \"0.1.35\"\n jod-thread = \"0.1.2\"\n walkdir = \"2.3.2\"\n crossbeam-channel = \"0.5.5\"\n-notify = \"=5.0.0-pre.16\"\n+notify = \"5.0\"\n \n vfs = { path = \"../vfs\", version = \"0.0.0\" }\n paths = { path = \"../paths\", version = \"0.0.0\" }"}, {"sha": "4ac75b4bbfd965712d6415c7f888eb77d10cb975", "filename": "docs/dev/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -98,7 +98,7 @@ After I am done with the fix, I use `cargo xtask install --client` to try the ne\n If I need to fix something in the `rust-analyzer` crate, I feel sad because it's on the boundary between the two processes, and working there is slow.\n I usually just `cargo xtask install --server` and poke changes from my live environment.\n Note that this uses `--release`, which is usually faster overall, because loading stdlib into debug version of rust-analyzer takes a lot of time.\n-To speed things up, sometimes I open a temporary hello-world project which has `\"rust-analyzer.cargo.noSysroot\": true` in `.code/settings.json`.\n+To speed things up, sometimes I open a temporary hello-world project which has `\"rust-analyzer.cargo.sysroot\": null` in `.code/settings.json`.\n This flag causes rust-analyzer to skip loading the sysroot, which greatly reduces the amount of things rust-analyzer needs to do, and makes printf's more useful.\n Note that you should only use the `eprint!` family of macros for debugging: stdout is used for LSP communication, and `print!` would break it.\n "}, {"sha": "52a13da31c5d3ea3d25f963ec94e18b09fdbebd2", "filename": "docs/dev/guide.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/docs%2Fdev%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/docs%2Fdev%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fguide.md?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -40,8 +40,8 @@ terms of files and offsets, and **not** in terms of Rust concepts like structs,\n traits, etc. The \"typed\" API with Rust specific types is slightly lower in the\n stack, we'll talk about it later.\n \n-[`AnalysisHost`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ide_api/src/lib.rs#L265-L284\n-[`Analysis`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ide_api/src/lib.rs#L291-L478\n+[`AnalysisHost`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L265-L284\n+[`Analysis`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L291-L478\n \n The reason for this separation of `Analysis` and `AnalysisHost` is that we want to apply\n changes \"uniquely\", but we might also want to fork an `Analysis` and send it to\n@@ -88,9 +88,8 @@ is lower than Cargo's model of packages: each Cargo package consists of several\n targets, each of which is a separate crate (or several crates, if you try\n different feature combinations).\n \n-Procedural macros should become inputs as well, but currently they are not\n-supported. Procedural macro will be a black box `Box<dyn Fn(TokenStream) -> TokenStream>`\n-function, and will be inserted into the crate graph just like dependencies.\n+Procedural macros are inputs as well, roughly modeled as a crate with a bunch of\n+additional black box `dyn Fn(TokenStream) -> TokenStream` functions.\n \n Soon we'll talk how we build an LSP server on top of `Analysis`, but first,\n let's deal with that paths issue."}, {"sha": "97e376787c828d9bb9ef5c9f391f3bbb637f7829", "filename": "docs/dev/syntax.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/docs%2Fdev%2Fsyntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/docs%2Fdev%2Fsyntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fsyntax.md?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -8,10 +8,10 @@ This guide describes the current state of syntax trees and parsing in rust-analy\n \n The things described are implemented in three places\n \n-* [rowan](https://github.com/rust-analyzer/rowan/tree/v0.9.0) -- a generic library for rowan syntax trees.\n-* [ra_syntax](https://github.com/rust-lang/rust-analyzer/tree/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_syntax) crate inside rust-analyzer which wraps `rowan` into rust-analyzer specific API.\n+* [rowan](https://github.com/rust-analyzer/rowan/tree/v0.15.10) -- a generic library for rowan syntax trees.\n+* [syntax](https://github.com/rust-lang/rust-analyzer/tree/36a70b7435c48837018c71576d7bb4e8f763f501/crates/syntax) crate inside rust-analyzer which wraps `rowan` into rust-analyzer specific API.\n   Nothing in rust-analyzer except this crate knows about `rowan`.\n-* [parser](https://github.com/rust-lang/rust-analyzer/tree/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/parser) crate parses input tokens into an `ra_syntax` tree\n+* [parser](https://github.com/rust-lang/rust-analyzer/tree/36a70b7435c48837018c71576d7bb4e8f763f501/crates/parser) crate parses input tokens into a `syntax` tree\n \n ## Design Goals\n "}, {"sha": "acf0aaea859a28c988bbcf682f01b07a64789fcc", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -64,10 +64,15 @@ Set this to `\"all\"` to pass `--all-features` to cargo.\n --\n Whether to pass `--no-default-features` to cargo.\n --\n-[[rust-analyzer.cargo.noSysroot]]rust-analyzer.cargo.noSysroot (default: `false`)::\n+[[rust-analyzer.cargo.sysroot]]rust-analyzer.cargo.sysroot (default: `\"discover\"`)::\n +\n --\n-Internal config for debugging, disables loading of sysroot crates.\n+Relative path to the sysroot, or \"discover\" to try to automatically find it via\n+\"rustc --print sysroot\".\n+\n+Unsetting this disables sysroot loading.\n+\n+This option does not take effect until rust-analyzer is restarted.\n --\n [[rust-analyzer.cargo.target]]rust-analyzer.cargo.target (default: `null`)::\n +\n@@ -103,6 +108,7 @@ Extra arguments for `cargo check`.\n +\n --\n Extra environment variables that will be set when running `cargo check`.\n+Extends `#rust-analyzer.cargo.extraEnv#`.\n --\n [[rust-analyzer.checkOnSave.features]]rust-analyzer.checkOnSave.features (default: `null`)::\n +"}, {"sha": "c30838e5f5e1e09b10ac34ce19c718d195f67a07", "filename": "docs/user/manual.adoc", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/docs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/docs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fmanual.adoc?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -174,14 +174,25 @@ On Unix, running the editor from a shell or changing the `.desktop` file to set\n \n ==== `rustup`\n \n-`rust-analyzer` is available in `rustup`, but only in the nightly toolchain:\n+`rust-analyzer` is available in `rustup`:\n \n [source,bash]\n ----\n-$ rustup +nightly component add rust-analyzer-preview\n+$ rustup component add rust-analyzer\n ----\n \n-However, in contrast to `component add clippy` or `component add rustfmt`, this does not actually place a `rust-analyzer` binary in `~/.cargo/bin`, see https://github.com/rust-lang/rustup/issues/2411[this issue].\n+However, in contrast to `component add clippy` or `component add rustfmt`, this does not actually place a `rust-analyzer` binary in `~/.cargo/bin`, see https://github.com/rust-lang/rustup/issues/2411[this issue]. You can find the path to the binary using:\n+[source,bash]\n+----\n+$ rustup which --toolchain stable rust-analyzer\n+----\n+You can link to there from `~/.cargo/bin` or configure your editor to use the full path.\n+\n+Alternatively you might be able to configure your editor to start `rust-analyzer` using the command:\n+[source,bash]\n+----\n+$ rustup run stable rust-analyzer\n+----\n \n ==== Arch Linux\n "}, {"sha": "f1dd3aa79ff043b664b519cea469bfe32d520116", "filename": "editors/code/package.json", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -468,10 +468,13 @@\n                     \"default\": false,\n                     \"type\": \"boolean\"\n                 },\n-                \"rust-analyzer.cargo.noSysroot\": {\n-                    \"markdownDescription\": \"Internal config for debugging, disables loading of sysroot crates.\",\n-                    \"default\": false,\n-                    \"type\": \"boolean\"\n+                \"rust-analyzer.cargo.sysroot\": {\n+                    \"markdownDescription\": \"Relative path to the sysroot, or \\\"discover\\\" to try to automatically find it via\\n\\\"rustc --print sysroot\\\".\\n\\nUnsetting this disables sysroot loading.\\n\\nThis option does not take effect until rust-analyzer is restarted.\",\n+                    \"default\": \"discover\",\n+                    \"type\": [\n+                        \"null\",\n+                        \"string\"\n+                    ]\n                 },\n                 \"rust-analyzer.cargo.target\": {\n                     \"markdownDescription\": \"Compilation target override (target triple).\",\n@@ -515,7 +518,7 @@\n                     }\n                 },\n                 \"rust-analyzer.checkOnSave.extraEnv\": {\n-                    \"markdownDescription\": \"Extra environment variables that will be set when running `cargo check`.\",\n+                    \"markdownDescription\": \"Extra environment variables that will be set when running `cargo check`.\\nExtends `#rust-analyzer.cargo.extraEnv#`.\",\n                     \"default\": {},\n                     \"type\": \"object\"\n                 },"}, {"sha": "15846a5e8645e67fd6d2888a81b4b1ca862efefc", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -133,7 +133,21 @@ export class Config {\n     }\n \n     get runnableEnv() {\n-        return this.get<RunnableEnvCfg>(\"runnableEnv\");\n+        const item = this.get<any>(\"runnableEnv\");\n+        if (!item) return item;\n+        const fixRecord = (r: Record<string, any>) => {\n+            for (const key in r) {\n+                if (typeof r[key] !== \"string\") {\n+                    r[key] = String(r[key]);\n+                }\n+            }\n+        };\n+        if (item instanceof Array) {\n+            item.forEach((x) => fixRecord(x.env));\n+        } else {\n+            fixRecord(item);\n+        }\n+        return item;\n     }\n \n     get restartServerOnConfigChange() {"}, {"sha": "5922bbfdb483d6d2f679475d9d8c04875c50b558", "filename": "lib/lsp-server/Cargo.toml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/lib%2Flsp-server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/lib%2Flsp-server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Flsp-server%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -1,16 +1,16 @@\n [package]\n name = \"lsp-server\"\n-version = \"0.6.0\"\n+version = \"0.7.0\"\n description = \"Generic LSP server scaffold.\"\n license = \"MIT OR Apache-2.0\"\n repository = \"https://github.com/rust-lang/rust-analyzer/tree/master/lib/lsp-server\"\n edition = \"2021\"\n \n [dependencies]\n log = \"0.4.17\"\n-serde_json = \"1.0.81\"\n-serde = { version = \"1.0.137\", features = [\"derive\"] }\n-crossbeam-channel = \"0.5.5\"\n+serde_json = \"1.0.86\"\n+serde = { version = \"1.0.144\", features = [\"derive\"] }\n+crossbeam-channel = \"0.5.6\"\n \n [dev-dependencies]\n-lsp-types = \"0.93.0\"\n+lsp-types = \"0.93.1\""}, {"sha": "b241561f9c0ddc80f4b821a01a46ddece489e8b4", "filename": "lib/lsp-server/src/msg.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/lib%2Flsp-server%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/lib%2Flsp-server%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Flsp-server%2Fsrc%2Fmsg.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -98,7 +98,7 @@ pub struct ResponseError {\n }\n \n #[derive(Clone, Copy, Debug)]\n-#[allow(unused)]\n+#[non_exhaustive]\n pub enum ErrorCode {\n     // Defined by JSON RPC:\n     ParseError = -32700,\n@@ -135,6 +135,14 @@ pub enum ErrorCode {\n     ///\n     /// @since 3.17.0\n     ServerCancelled = -32802,\n+\n+    /// A request failed but it was syntactically correct, e.g the\n+    /// method name was known and the parameters were valid. The error\n+    /// message should contain human readable information about why\n+    /// the request failed.\n+    ///\n+    /// @since 3.17.0\n+    RequestFailed = -32803,\n }\n \n #[derive(Debug, Serialize, Deserialize, Clone)]"}, {"sha": "e5f19be20b069d5a7df710fe1fcf6a0a6913dccf", "filename": "lib/lsp-server/src/req_queue.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/lib%2Flsp-server%2Fsrc%2Freq_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/lib%2Flsp-server%2Fsrc%2Freq_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Flsp-server%2Fsrc%2Freq_queue.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -35,6 +35,7 @@ impl<I> Incoming<I> {\n     pub fn register(&mut self, id: RequestId, data: I) {\n         self.pending.insert(id, data);\n     }\n+\n     pub fn cancel(&mut self, id: RequestId) -> Option<Response> {\n         let _data = self.complete(id.clone())?;\n         let error = ResponseError {\n@@ -44,9 +45,14 @@ impl<I> Incoming<I> {\n         };\n         Some(Response { id, result: None, error: Some(error) })\n     }\n+\n     pub fn complete(&mut self, id: RequestId) -> Option<I> {\n         self.pending.remove(&id)\n     }\n+\n+    pub fn is_completed(&self, id: &RequestId) -> bool {\n+        !self.pending.contains_key(id)\n+    }\n }\n \n impl<O> Outgoing<O> {\n@@ -56,6 +62,7 @@ impl<O> Outgoing<O> {\n         self.next_id += 1;\n         Request::new(id, method, params)\n     }\n+\n     pub fn complete(&mut self, id: RequestId) -> Option<O> {\n         self.pending.remove(&id)\n     }"}, {"sha": "0be0bf920de9dd661d4851c4c03fb5527d97b63d", "filename": "xtask/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/xtask%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/xtask%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2FCargo.toml?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -7,9 +7,9 @@ edition = \"2021\"\n rust-version = \"1.57\"\n \n [dependencies]\n-anyhow = \"1.0.57\"\n+anyhow = \"1.0.62\"\n flate2 = \"1.0.24\"\n write-json = \"0.1.2\"\n xshell = \"0.2.2\"\n-xflags = \"0.2.4\"\n+xflags = \"0.3.0\"\n # Avoid adding more dependencies to this crate"}, {"sha": "0fce48898349a8580c046e9dbcc0a6587c2374df", "filename": "xtask/src/flags.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/xtask%2Fsrc%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/xtask%2Fsrc%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fflags.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -7,10 +7,6 @@ xflags::xflags! {\n \n     /// Run custom build command.\n     cmd xtask {\n-        default cmd help {\n-            /// Print help information.\n-            optional -h, --help\n-        }\n \n         /// Install rust-analyzer server or editor plugin.\n         cmd install {\n@@ -42,9 +38,9 @@ xflags::xflags! {\n             optional --dry-run\n         }\n         /// Builds a benchmark version of rust-analyzer and puts it into `./target`.\n-        cmd bb\n+        cmd bb {\n             required suffix: String\n-        {}\n+        }\n     }\n }\n \n@@ -58,7 +54,6 @@ pub struct Xtask {\n \n #[derive(Debug)]\n pub enum XtaskCmd {\n-    Help(Help),\n     Install(Install),\n     FuzzTests(FuzzTests),\n     Release(Release),\n@@ -68,11 +63,6 @@ pub enum XtaskCmd {\n     Bb(Bb),\n }\n \n-#[derive(Debug)]\n-pub struct Help {\n-    pub help: bool,\n-}\n-\n #[derive(Debug)]\n pub struct Install {\n     pub client: bool,\n@@ -111,7 +101,10 @@ pub struct Bb {\n }\n \n impl Xtask {\n-    pub const HELP: &'static str = Self::HELP_;\n+    #[allow(dead_code)]\n+    pub fn from_env_or_exit() -> Self {\n+        Self::from_env_or_exit_()\n+    }\n \n     #[allow(dead_code)]\n     pub fn from_env() -> xflags::Result<Self> {"}, {"sha": "a37f469adcb60771ef7c0e393b6d39e7cc7daf8b", "filename": "xtask/src/main.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26a413e015b7fef4c0edb51bda0d39ab499f4950/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a413e015b7fef4c0edb51bda0d39ab499f4950/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=26a413e015b7fef4c0edb51bda0d39ab499f4950", "patch": "@@ -25,15 +25,12 @@ use std::{\n use xshell::{cmd, Shell};\n \n fn main() -> anyhow::Result<()> {\n+    let flags = flags::Xtask::from_env_or_exit();\n+\n     let sh = &Shell::new()?;\n     sh.change_dir(project_root());\n \n-    let flags = flags::Xtask::from_env()?;\n     match flags.subcommand {\n-        flags::XtaskCmd::Help(_) => {\n-            println!(\"{}\", flags::Xtask::HELP);\n-            Ok(())\n-        }\n         flags::XtaskCmd::Install(cmd) => cmd.run(sh),\n         flags::XtaskCmd::FuzzTests(_) => run_fuzzer(sh),\n         flags::XtaskCmd::Release(cmd) => cmd.run(sh),"}]}