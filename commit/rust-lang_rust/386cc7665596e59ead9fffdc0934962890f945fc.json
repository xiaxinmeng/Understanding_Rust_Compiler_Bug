{"sha": "386cc7665596e59ead9fffdc0934962890f945fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NmNjNzY2NTU5NmU1OWVhZDlmZmZkYzA5MzQ5NjI4OTBmOTQ1ZmM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-03T02:45:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-03T16:31:46Z"}, "message": "rollup merge of #18537 : japaric/no-secret", "tree": {"sha": "9a81c00c5aadcb613d06f5f6acaf8cff72ecb357", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a81c00c5aadcb613d06f5f6acaf8cff72ecb357"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/386cc7665596e59ead9fffdc0934962890f945fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/386cc7665596e59ead9fffdc0934962890f945fc", "html_url": "https://github.com/rust-lang/rust/commit/386cc7665596e59ead9fffdc0934962890f945fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/386cc7665596e59ead9fffdc0934962890f945fc/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8fdcc305e112556fd3842bd8ce85531e45d6bc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8fdcc305e112556fd3842bd8ce85531e45d6bc6", "html_url": "https://github.com/rust-lang/rust/commit/a8fdcc305e112556fd3842bd8ce85531e45d6bc6"}, {"sha": "3a075dce9af716a7512618bad6b37b00e559060d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a075dce9af716a7512618bad6b37b00e559060d", "html_url": "https://github.com/rust-lang/rust/commit/3a075dce9af716a7512618bad6b37b00e559060d"}], "stats": {"total": 179, "additions": 157, "deletions": 22}, "files": [{"sha": "ddfbfa7850202ec28a3314c5dbcb3f342c1b47cd", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 132, "deletions": 4, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/386cc7665596e59ead9fffdc0934962890f945fc/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386cc7665596e59ead9fffdc0934962890f945fc/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=386cc7665596e59ead9fffdc0934962890f945fc", "patch": "@@ -250,8 +250,8 @@ pub trait UpperExp for Sized? {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-// FIXME #11938 - UFCS would make us able call the above methods\n-// directly Show::show(x, fmt).\n+// NOTE(stage0): Remove macro after next snapshot\n+#[cfg(stage0)]\n macro_rules! uniform_fn_call_workaround {\n     ($( $name: ident, $trait_: ident; )*) => {\n         $(\n@@ -262,6 +262,8 @@ macro_rules! uniform_fn_call_workaround {\n             )*\n     }\n }\n+// NOTE(stage0): Remove macro after next snapshot\n+#[cfg(stage0)]\n uniform_fn_call_workaround! {\n     secret_show, Show;\n     secret_bool, Bool;\n@@ -568,36 +570,65 @@ pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n \n /// When the compiler determines that the type of an argument *must* be a string\n /// (such as for select), then it invokes this method.\n+// NOTE(stage0): remove function after a snapshot\n+#[cfg(stage0)]\n #[doc(hidden)] #[inline]\n pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n     argument(secret_string, s)\n }\n \n+/// When the compiler determines that the type of an argument *must* be a string\n+/// (such as for select), then it invokes this method.\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[doc(hidden)] #[inline]\n+pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n+    argument(String::fmt, s)\n+}\n+\n /// When the compiler determines that the type of an argument *must* be a uint\n /// (such as for plural), then it invokes this method.\n+// NOTE(stage0): remove function after a snapshot\n+#[cfg(stage0)]\n #[doc(hidden)] #[inline]\n pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n     argument(secret_unsigned, s)\n }\n \n+/// When the compiler determines that the type of an argument *must* be a uint\n+/// (such as for plural), then it invokes this method.\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[doc(hidden)] #[inline]\n+pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n+    argument(Unsigned::fmt, s)\n+}\n+\n // Implementations of the core formatting traits\n \n impl<'a, Sized? T: Show> Show for &'a T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }\n+    fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n impl<'a, Sized? T: Show> Show for &'a mut T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n+    fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n impl<'a> Show for &'a Show+'a {\n     fn fmt(&self, f: &mut Formatter) -> Result { (*self).fmt(f) }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl Bool for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         secret_string(&(if *self {\"true\"} else {\"false\"}), f)\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl Bool for bool {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        String::fmt(if *self { \"true\" } else { \"false\" }, f)\n+    }\n+}\n+\n impl<T: str::Str> String for T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(self.as_slice())\n@@ -610,6 +641,8 @@ impl String for str {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl Char for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         use char::Char;\n@@ -621,28 +654,80 @@ impl Char for char {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl Char for char {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        use char::Char;\n+\n+        let mut utf8 = [0u8, ..4];\n+        let amt = self.encode_utf8(utf8).unwrap_or(0);\n+        let s: &str = unsafe { mem::transmute(utf8[..amt]) };\n+        String::fmt(s, f)\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (rt::FlagAlternate as uint);\n         secret_lower_hex::<uint>(&(*self as uint), f)\n     }\n }\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> Pointer for *const T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.flags |= 1 << (rt::FlagAlternate as uint);\n+        LowerHex::fmt(&(*self as uint), f)\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> Pointer for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         secret_pointer::<*const T>(&(*self as *const T), f)\n     }\n }\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> Pointer for *mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        Pointer::fmt(&(*self as *const T), f)\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, T> Pointer for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         secret_pointer::<*const T>(&(&**self as *const T), f)\n     }\n }\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, T> Pointer for &'a T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        Pointer::fmt(&(*self as *const T), f)\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, T> Pointer for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         secret_pointer::<*const T>(&(&**self as *const T), f)\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, T> Pointer for &'a mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        Pointer::fmt(&(&**self as *const T), f)\n+    }\n+}\n+\n macro_rules! floating(($ty:ident) => {\n     impl Float for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n@@ -712,26 +797,69 @@ floating!(f64)\n \n // Implementation of Show for various core types\n \n+// NOTE(stage0): remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! delegate(($ty:ty to $other:ident) => {\n     impl Show for $ty {\n         fn fmt(&self, f: &mut Formatter) -> Result {\n             (concat_idents!(secret_, $other)(self, f))\n         }\n     }\n })\n+\n+// NOTE(stage0): remove these macros after a snapshot\n+#[cfg(stage0)]\n delegate!(str to string)\n+#[cfg(stage0)]\n delegate!(bool to bool)\n+#[cfg(stage0)]\n delegate!(char to char)\n+#[cfg(stage0)]\n delegate!(f32 to float)\n+#[cfg(stage0)]\n delegate!(f64 to float)\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+macro_rules! delegate(($ty:ty to $other:ident) => {\n+    impl Show for $ty {\n+        fn fmt(&self, f: &mut Formatter) -> Result {\n+            $other::fmt(self, f)\n+        }\n+    }\n+})\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(str to String)\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(bool to Bool)\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(char to Char)\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(f32 to Float)\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(f64 to Float)\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> Show for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n }\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> Show for *const T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> Show for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> Show for *mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n+}\n+\n macro_rules! peel(($name:ident, $($other:ident,)*) => (tuple!($($other,)*)))\n \n macro_rules! tuple ("}, {"sha": "cb151dd9c0abfa6b16bde7228a84c054504ade54", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/386cc7665596e59ead9fffdc0934962890f945fc/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386cc7665596e59ead9fffdc0934962890f945fc/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=386cc7665596e59ead9fffdc0934962890f945fc", "patch": "@@ -424,14 +424,20 @@ pub use core::fmt::{Argument, Arguments, write, radix, Radix, RadixFmt};\n \n #[doc(hidden)]\n pub use core::fmt::{argument, argumentstr, argumentuint};\n+// NOTE(stage0): remove these imports after a snapshot\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_show, secret_string, secret_unsigned};\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_signed, secret_lower_hex, secret_upper_hex};\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_bool, secret_char, secret_octal, secret_binary};\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_float, secret_upper_exp, secret_lower_exp};\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_pointer};\n "}, {"sha": "486ce910e2b6f9e6d40dd66af4888666573d60b1", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/386cc7665596e59ead9fffdc0934962890f945fc/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386cc7665596e59ead9fffdc0934962890f945fc/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=386cc7665596e59ead9fffdc0934962890f945fc", "patch": "@@ -663,28 +663,28 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn format_arg(ecx: &ExtCtxt, sp: Span,\n                   ty: &ArgumentType, arg: P<ast::Expr>)\n                   -> P<ast::Expr> {\n-        let (krate, fmt_fn) = match *ty {\n+        let trait_ = match *ty {\n             Known(ref tyname) => {\n                 match tyname.as_slice() {\n-                    \"\"  => (\"std\", \"secret_show\"),\n-                    \"b\" => (\"std\", \"secret_bool\"),\n-                    \"c\" => (\"std\", \"secret_char\"),\n-                    \"d\" | \"i\" => (\"std\", \"secret_signed\"),\n-                    \"e\" => (\"std\", \"secret_lower_exp\"),\n-                    \"E\" => (\"std\", \"secret_upper_exp\"),\n-                    \"f\" => (\"std\", \"secret_float\"),\n-                    \"o\" => (\"std\", \"secret_octal\"),\n-                    \"p\" => (\"std\", \"secret_pointer\"),\n-                    \"s\" => (\"std\", \"secret_string\"),\n-                    \"t\" => (\"std\", \"secret_binary\"),\n-                    \"u\" => (\"std\", \"secret_unsigned\"),\n-                    \"x\" => (\"std\", \"secret_lower_hex\"),\n-                    \"X\" => (\"std\", \"secret_upper_hex\"),\n+                    \"\"  => \"Show\",\n+                    \"b\" => \"Bool\",\n+                    \"c\" => \"Char\",\n+                    \"d\" | \"i\" => \"Signed\",\n+                    \"e\" => \"LowerExp\",\n+                    \"E\" => \"UpperExp\",\n+                    \"f\" => \"Float\",\n+                    \"o\" => \"Octal\",\n+                    \"p\" => \"Pointer\",\n+                    \"s\" => \"String\",\n+                    \"t\" => \"Binary\",\n+                    \"u\" => \"Unsigned\",\n+                    \"x\" => \"LowerHex\",\n+                    \"X\" => \"UpperHex\",\n                     _ => {\n                         ecx.span_err(sp,\n                                      format!(\"unknown format trait `{}`\",\n                                              *tyname).as_slice());\n-                        (\"std\", \"dummy\")\n+                        \"Dummy\"\n                     }\n                 }\n             }\n@@ -697,9 +697,10 @@ impl<'a, 'b> Context<'a, 'b> {\n         };\n \n         let format_fn = ecx.path_global(sp, vec![\n-                ecx.ident_of(krate),\n+                ecx.ident_of(\"std\"),\n                 ecx.ident_of(\"fmt\"),\n-                ecx.ident_of(fmt_fn)]);\n+                ecx.ident_of(trait_),\n+                ecx.ident_of(\"fmt\")]);\n         ecx.expr_call_global(sp, vec![\n                 ecx.ident_of(\"std\"),\n                 ecx.ident_of(\"fmt\"),"}]}