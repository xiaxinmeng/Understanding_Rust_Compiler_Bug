{"sha": "33df20868da38ca47f22f8bfab36dd4c965cf333", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZGYyMDg2OGRhMzhjYTQ3ZjIyZjhiZmFiMzZkZDRjOTY1Y2YzMzM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-09T19:27:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-09T19:27:06Z"}, "message": "Merge #3918\n\n3918: Add support for feature attributes in struct literal r=matklad a=bnjjj\n\nAs promised here is the next PR to solve 2 different scenarios with feature flag on struct literal.\r\nclose #3870 \n\nCo-authored-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "d1651cf0e2cda2b50e13a631c11a5d94e92ea306", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1651cf0e2cda2b50e13a631c11a5d94e92ea306"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33df20868da38ca47f22f8bfab36dd4c965cf333", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJej3cKCRBK7hj4Ov3rIwAAdHIIAGOmEuFG6k8Llksoeg05+f6q\nXrjPjJBtRxh8YSQNo2a2fI5w7c+vHUuT5/dT+EO2T1K59YsSBRtJf434ZeaskutM\nace+rIFGDrKOKibtYwAlTsBeddY9lLjdO0hAT6xHDNIXpN9XG0g/MLEQ0VU1vDMH\n1ikNVvjQ7vMFnXIK6tSd9qMZQdSt0OJEoxrVenyIATgk0MEFoPHpAn1iyMW07omd\niIQJ1i8KjghRWvXDMroInCo+EHx66ju4sRwCr8hMDhCDg7289Sb373tRHlQxixiC\nSDaoMfR617WeH8iMNWMZO/FXxHAsJNEXcbSfxOjqaPJh03MChOb55WjPTXFDGhQ=\n=LRUY\n-----END PGP SIGNATURE-----\n", "payload": "tree d1651cf0e2cda2b50e13a631c11a5d94e92ea306\nparent 9635d8bc44cf58875e97e9e77c3426f746ab7007\nparent c1317d692321ba5ba8f138067ebefbb9559d098d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586460426 +0000\ncommitter GitHub <noreply@github.com> 1586460426 +0000\n\nMerge #3918\n\n3918: Add support for feature attributes in struct literal r=matklad a=bnjjj\n\nAs promised here is the next PR to solve 2 different scenarios with feature flag on struct literal.\r\nclose #3870 \n\nCo-authored-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33df20868da38ca47f22f8bfab36dd4c965cf333", "html_url": "https://github.com/rust-lang/rust/commit/33df20868da38ca47f22f8bfab36dd4c965cf333", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33df20868da38ca47f22f8bfab36dd4c965cf333/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9635d8bc44cf58875e97e9e77c3426f746ab7007", "url": "https://api.github.com/repos/rust-lang/rust/commits/9635d8bc44cf58875e97e9e77c3426f746ab7007", "html_url": "https://github.com/rust-lang/rust/commit/9635d8bc44cf58875e97e9e77c3426f746ab7007"}, {"sha": "c1317d692321ba5ba8f138067ebefbb9559d098d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1317d692321ba5ba8f138067ebefbb9559d098d", "html_url": "https://github.com/rust-lang/rust/commit/c1317d692321ba5ba8f138067ebefbb9559d098d"}], "stats": {"total": 187, "additions": 142, "deletions": 45}, "files": [{"sha": "be4b0accb832bdf221bacae32f44331fba6cc6da", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/33df20868da38ca47f22f8bfab36dd4c965cf333/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33df20868da38ca47f22f8bfab36dd4c965cf333/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=33df20868da38ca47f22f8bfab36dd4c965cf333", "patch": "@@ -4,6 +4,7 @@ use std::sync::Arc;\n \n use either::Either;\n use hir_expand::{\n+    hygiene::Hygiene,\n     name::{AsName, Name},\n     InFile,\n };\n@@ -12,9 +13,9 @@ use ra_prof::profile;\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner, VisibilityOwner};\n \n use crate::{\n-    db::DefDatabase, src::HasChildSource, src::HasSource, trace::Trace, type_ref::TypeRef,\n-    visibility::RawVisibility, EnumId, LocalEnumVariantId, LocalStructFieldId, Lookup, StructId,\n-    UnionId, VariantId,\n+    attr::Attrs, db::DefDatabase, src::HasChildSource, src::HasSource, trace::Trace,\n+    type_ref::TypeRef, visibility::RawVisibility, EnumId, HasModule, LocalEnumVariantId,\n+    LocalStructFieldId, Lookup, ModuleId, StructId, UnionId, VariantId,\n };\n \n /// Note that we use `StructData` for unions as well!\n@@ -56,7 +57,8 @@ impl StructData {\n         let src = id.lookup(db).source(db);\n \n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n-        let variant_data = VariantData::new(db, src.map(|s| s.kind()));\n+        let variant_data =\n+            VariantData::new(db, src.map(|s| s.kind()), id.lookup(db).container.module(db));\n         let variant_data = Arc::new(variant_data);\n         Arc::new(StructData { name, variant_data })\n     }\n@@ -70,6 +72,7 @@ impl StructData {\n                     .map(ast::StructKind::Record)\n                     .unwrap_or(ast::StructKind::Unit)\n             }),\n+            id.lookup(db).container.module(db),\n         );\n         let variant_data = Arc::new(variant_data);\n         Arc::new(StructData { name, variant_data })\n@@ -82,7 +85,7 @@ impl EnumData {\n         let src = e.lookup(db).source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let mut trace = Trace::new_for_arena();\n-        lower_enum(db, &mut trace, &src);\n+        lower_enum(db, &mut trace, &src, e.lookup(db).container.module(db));\n         Arc::new(EnumData { name, variants: trace.into_arena() })\n     }\n \n@@ -98,7 +101,7 @@ impl HasChildSource for EnumId {\n     fn child_source(&self, db: &dyn DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>> {\n         let src = self.lookup(db).source(db);\n         let mut trace = Trace::new_for_map();\n-        lower_enum(db, &mut trace, &src);\n+        lower_enum(db, &mut trace, &src, self.lookup(db).container.module(db));\n         src.with_value(trace.into_map())\n     }\n }\n@@ -107,22 +110,23 @@ fn lower_enum(\n     db: &dyn DefDatabase,\n     trace: &mut Trace<EnumVariantData, ast::EnumVariant>,\n     ast: &InFile<ast::EnumDef>,\n+    module_id: ModuleId,\n ) {\n     for var in ast.value.variant_list().into_iter().flat_map(|it| it.variants()) {\n         trace.alloc(\n             || var.clone(),\n             || EnumVariantData {\n                 name: var.name().map_or_else(Name::missing, |it| it.as_name()),\n-                variant_data: Arc::new(VariantData::new(db, ast.with_value(var.kind()))),\n+                variant_data: Arc::new(VariantData::new(db, ast.with_value(var.kind()), module_id)),\n             },\n         );\n     }\n }\n \n impl VariantData {\n-    fn new(db: &dyn DefDatabase, flavor: InFile<ast::StructKind>) -> Self {\n+    fn new(db: &dyn DefDatabase, flavor: InFile<ast::StructKind>, module_id: ModuleId) -> Self {\n         let mut trace = Trace::new_for_arena();\n-        match lower_struct(db, &mut trace, &flavor) {\n+        match lower_struct(db, &mut trace, &flavor, module_id) {\n             StructKind::Tuple => VariantData::Tuple(trace.into_arena()),\n             StructKind::Record => VariantData::Record(trace.into_arena()),\n             StructKind::Unit => VariantData::Unit,\n@@ -155,22 +159,27 @@ impl HasChildSource for VariantId {\n     type Value = Either<ast::TupleFieldDef, ast::RecordFieldDef>;\n \n     fn child_source(&self, db: &dyn DefDatabase) -> InFile<ArenaMap<Self::ChildId, Self::Value>> {\n-        let src = match self {\n+        let (src, module_id) = match self {\n             VariantId::EnumVariantId(it) => {\n                 // I don't really like the fact that we call into parent source\n                 // here, this might add to more queries then necessary.\n                 let src = it.parent.child_source(db);\n-                src.map(|map| map[it.local_id].kind())\n+                (src.map(|map| map[it.local_id].kind()), it.parent.lookup(db).container.module(db))\n             }\n-            VariantId::StructId(it) => it.lookup(db).source(db).map(|it| it.kind()),\n-            VariantId::UnionId(it) => it.lookup(db).source(db).map(|it| {\n-                it.record_field_def_list()\n-                    .map(ast::StructKind::Record)\n-                    .unwrap_or(ast::StructKind::Unit)\n-            }),\n+            VariantId::StructId(it) => {\n+                (it.lookup(db).source(db).map(|it| it.kind()), it.lookup(db).container.module(db))\n+            }\n+            VariantId::UnionId(it) => (\n+                it.lookup(db).source(db).map(|it| {\n+                    it.record_field_def_list()\n+                        .map(ast::StructKind::Record)\n+                        .unwrap_or(ast::StructKind::Unit)\n+                }),\n+                it.lookup(db).container.module(db),\n+            ),\n         };\n         let mut trace = Trace::new_for_map();\n-        lower_struct(db, &mut trace, &src);\n+        lower_struct(db, &mut trace, &src, module_id);\n         src.with_value(trace.into_map())\n     }\n }\n@@ -186,10 +195,17 @@ fn lower_struct(\n     db: &dyn DefDatabase,\n     trace: &mut Trace<StructFieldData, Either<ast::TupleFieldDef, ast::RecordFieldDef>>,\n     ast: &InFile<ast::StructKind>,\n+    module_id: ModuleId,\n ) -> StructKind {\n+    let crate_graph = db.crate_graph();\n     match &ast.value {\n         ast::StructKind::Tuple(fl) => {\n             for (i, fd) in fl.fields().enumerate() {\n+                let attrs = Attrs::new(&fd, &Hygiene::new(db.upcast(), ast.file_id));\n+                if !attrs.is_cfg_enabled(&crate_graph[module_id.krate].cfg_options) {\n+                    continue;\n+                }\n+\n                 trace.alloc(\n                     || Either::Left(fd.clone()),\n                     || StructFieldData {\n@@ -203,6 +219,11 @@ fn lower_struct(\n         }\n         ast::StructKind::Record(fl) => {\n             for fd in fl.fields() {\n+                let attrs = Attrs::new(&fd, &Hygiene::new(db.upcast(), ast.file_id));\n+                if !attrs.is_cfg_enabled(&crate_graph[module_id.krate].cfg_options) {\n+                    continue;\n+                }\n+\n                 trace.alloc(\n                     || Either::Right(fd.clone()),\n                     || StructFieldData {"}, {"sha": "7b0c506b16b0f669629129d81895849014fd2bfd", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/33df20868da38ca47f22f8bfab36dd4c965cf333/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33df20868da38ca47f22f8bfab36dd4c965cf333/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=33df20868da38ca47f22f8bfab36dd4c965cf333", "patch": "@@ -5,6 +5,7 @@ use std::{ops, sync::Arc};\n use either::Either;\n use hir_expand::{hygiene::Hygiene, AstId, InFile};\n use mbe::ast_to_token_tree;\n+use ra_cfg::CfgOptions;\n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner},\n     SmolStr,\n@@ -90,6 +91,10 @@ impl Attrs {\n     pub fn by_key(&self, key: &'static str) -> AttrQuery<'_> {\n         AttrQuery { attrs: self, key }\n     }\n+\n+    pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> bool {\n+        self.by_key(\"cfg\").tt_values().all(|tt| cfg_options.is_cfg_enabled(tt) != Some(false))\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "df560155c6cf0e588ea69cb394b601bd00d1dcb0", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/33df20868da38ca47f22f8bfab36dd4c965cf333/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33df20868da38ca47f22f8bfab36dd4c965cf333/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=33df20868da38ca47f22f8bfab36dd4c965cf333", "patch": "@@ -4,6 +4,7 @@\n use either::Either;\n \n use hir_expand::{\n+    hygiene::Hygiene,\n     name::{name, AsName, Name},\n     MacroDefId, MacroDefKind,\n };\n@@ -20,6 +21,7 @@ use test_utils::tested_by;\n use super::{ExprSource, PatSource};\n use crate::{\n     adt::StructKind,\n+    attr::Attrs,\n     body::{Body, BodySourceMap, Expander, PatPtr, SyntheticSyntax},\n     builtin_type::{BuiltinFloat, BuiltinInt},\n     db::DefDatabase,\n@@ -31,8 +33,8 @@ use crate::{\n     path::GenericArgs,\n     path::Path,\n     type_ref::{Mutability, TypeRef},\n-    AdtId, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, Intern, ModuleDefId,\n-    StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n+    AdtId, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, HasModule, Intern,\n+    ModuleDefId, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n };\n \n pub(super) fn lower(\n@@ -298,28 +300,41 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n             ast::Expr::RecordLit(e) => {\n+                let crate_graph = self.db.crate_graph();\n                 let path = e.path().and_then(|path| self.expander.parse_path(path));\n                 let mut field_ptrs = Vec::new();\n                 let record_lit = if let Some(nfl) = e.record_field_list() {\n                     let fields = nfl\n                         .fields()\n                         .inspect(|field| field_ptrs.push(AstPtr::new(field)))\n-                        .map(|field| RecordLitField {\n-                            name: field\n-                                .name_ref()\n-                                .map(|nr| nr.as_name())\n-                                .unwrap_or_else(Name::missing),\n-                            expr: if let Some(e) = field.expr() {\n-                                self.collect_expr(e)\n-                            } else if let Some(nr) = field.name_ref() {\n-                                // field shorthand\n-                                self.alloc_expr_field_shorthand(\n-                                    Expr::Path(Path::from_name_ref(&nr)),\n-                                    AstPtr::new(&field),\n-                                )\n-                            } else {\n-                                self.missing_expr()\n-                            },\n+                        .filter_map(|field| {\n+                            let module_id = ContainerId::DefWithBodyId(self.def).module(self.db);\n+                            let attrs = Attrs::new(\n+                                &field,\n+                                &Hygiene::new(self.db.upcast(), self.expander.current_file_id),\n+                            );\n+\n+                            if !attrs.is_cfg_enabled(&crate_graph[module_id.krate].cfg_options) {\n+                                return None;\n+                            }\n+\n+                            Some(RecordLitField {\n+                                name: field\n+                                    .name_ref()\n+                                    .map(|nr| nr.as_name())\n+                                    .unwrap_or_else(Name::missing),\n+                                expr: if let Some(e) = field.expr() {\n+                                    self.collect_expr(e)\n+                                } else if let Some(nr) = field.name_ref() {\n+                                    // field shorthand\n+                                    self.alloc_expr_field_shorthand(\n+                                        Expr::Path(Path::from_name_ref(&nr)),\n+                                        AstPtr::new(&field),\n+                                    )\n+                                } else {\n+                                    self.missing_expr()\n+                                },\n+                            })\n                         })\n                         .collect();\n                     let spread = nfl.spread().map(|s| self.collect_expr(s));"}, {"sha": "419d62c2888b23bfd6e4188066452a0b61d31676", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/33df20868da38ca47f22f8bfab36dd4c965cf333/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33df20868da38ca47f22f8bfab36dd4c965cf333/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=33df20868da38ca47f22f8bfab36dd4c965cf333", "patch": "@@ -7,7 +7,6 @@ use hir_expand::{\n     name::{name, AsName, Name},\n     AstId, InFile,\n };\n-use ra_cfg::CfgOptions;\n use ra_prof::profile;\n use ra_syntax::ast::{\n     self, AstNode, ImplItem, ModuleItemOwner, NameOwner, TypeAscriptionOwner, VisibilityOwner,\n@@ -318,10 +317,6 @@ fn collect_impl_items_in_macro(\n     }\n }\n \n-fn is_cfg_enabled(cfg_options: &CfgOptions, attrs: &Attrs) -> bool {\n-    attrs.by_key(\"cfg\").tt_values().all(|tt| cfg_options.is_cfg_enabled(tt) != Some(false))\n-}\n-\n fn collect_impl_items(\n     db: &dyn DefDatabase,\n     impl_items: impl Iterator<Item = ImplItem>,\n@@ -341,10 +336,11 @@ fn collect_impl_items(\n                 }\n                 .intern(db);\n \n-                if !is_cfg_enabled(\n-                    &crate_graph[module_id.krate].cfg_options,\n-                    &db.function_data(def).attrs,\n-                ) {\n+                if !db\n+                    .function_data(def)\n+                    .attrs\n+                    .is_cfg_enabled(&crate_graph[module_id.krate].cfg_options)\n+                {\n                     None\n                 } else {\n                     Some(def.into())"}, {"sha": "3b078b8c7a5d7bdf640d64244e9a0a45e5ae51b0", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/33df20868da38ca47f22f8bfab36dd4c965cf333/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33df20868da38ca47f22f8bfab36dd4c965cf333/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=33df20868da38ca47f22f8bfab36dd4c965cf333", "patch": "@@ -349,3 +349,63 @@ fn no_such_field_with_feature_flag_diagnostics() {\n \n     assert_snapshot!(diagnostics, @r###\"\"###);\n }\n+\n+#[test]\n+fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n+    let diagnostics = TestDB::with_files(\n+        r#\"\n+        //- /lib.rs crate:foo cfg:feature=foo\n+        struct S {\n+            #[cfg(feature = \"foo\")]\n+            foo: u32,\n+            #[cfg(not(feature = \"foo\"))]\n+            bar: u32,\n+        }\n+\n+        impl S {\n+            #[cfg(feature = \"foo\")]\n+            fn new(foo: u32) -> Self {\n+                Self { foo }\n+            }\n+            #[cfg(not(feature = \"foo\"))]\n+            fn new(bar: u32) -> Self {\n+                Self { bar }\n+            }\n+        }\n+        \"#,\n+    )\n+    .diagnostics()\n+    .0;\n+\n+    assert_snapshot!(diagnostics, @r###\"\"###);\n+}\n+\n+#[test]\n+fn no_such_field_with_feature_flag_diagnostics_on_struct_fields() {\n+    let diagnostics = TestDB::with_files(\n+        r#\"\n+        //- /lib.rs crate:foo cfg:feature=foo\n+        struct S {\n+            #[cfg(feature = \"foo\")]\n+            foo: u32,\n+            #[cfg(not(feature = \"foo\"))]\n+            bar: u32,\n+        }\n+\n+        impl S {\n+            fn new(val: u32) -> Self {\n+                Self {\n+                    #[cfg(feature = \"foo\")]\n+                    foo: val,\n+                    #[cfg(not(feature = \"foo\"))]\n+                    bar: val,\n+                }\n+            }\n+        }\n+        \"#,\n+    )\n+    .diagnostics()\n+    .0;\n+\n+    assert_snapshot!(diagnostics, @r###\"\"###);\n+}"}]}