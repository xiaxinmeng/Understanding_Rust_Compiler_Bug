{"sha": "f3e80760e9e7ceaa40661e07e0c89e1739f68d9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzZTgwNzYwZTllN2NlYWE0MDY2MWUwN2UwYzg5ZTE3MzlmNjhkOWE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-16T02:42:24Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-26T23:23:09Z"}, "message": "Refactor `CfgFolder::in_cfg` -> `CfgFolder::configure`", "tree": {"sha": "81a2eeeaaa036f93e236c843f7c694976660e88a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81a2eeeaaa036f93e236c843f7c694976660e88a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3e80760e9e7ceaa40661e07e0c89e1739f68d9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3e80760e9e7ceaa40661e07e0c89e1739f68d9a", "html_url": "https://github.com/rust-lang/rust/commit/f3e80760e9e7ceaa40661e07e0c89e1739f68d9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3e80760e9e7ceaa40661e07e0c89e1739f68d9a/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79854395caef3a5cda5ff6b0015d49c303eec93e", "url": "https://api.github.com/repos/rust-lang/rust/commits/79854395caef3a5cda5ff6b0015d49c303eec93e", "html_url": "https://github.com/rust-lang/rust/commit/79854395caef3a5cda5ff6b0015d49c303eec93e"}], "stats": {"total": 74, "additions": 29, "deletions": 45}, "files": [{"sha": "a22e08d4275718e18367251fd515efb48953038b", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 29, "deletions": 45, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f3e80760e9e7ceaa40661e07e0c89e1739f68d9a/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3e80760e9e7ceaa40661e07e0c89e1739f68d9a/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=f3e80760e9e7ceaa40661e07e0c89e1739f68d9a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use attr::AttrMetaMethods;\n+use attr::{AttrMetaMethods, HasAttrs};\n use errors::Handler;\n use feature_gate::GatedCfgAttr;\n use fold::Folder;\n@@ -20,7 +20,7 @@ use ptr::P;\n use util::small_vector::SmallVector;\n \n pub trait CfgFolder: fold::Folder {\n-    fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool;\n+    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T>;\n     fn visit_unconfigurable_expr(&mut self, _expr: &ast::Expr) {}\n }\n \n@@ -32,8 +32,12 @@ struct Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n }\n \n impl<'a, F: FnMut(&[ast::Attribute]) -> bool> CfgFolder for Context<'a, F> {\n-    fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool {\n-        (self.in_cfg)(attrs)\n+    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n+        if (self.in_cfg)(node.attrs()) {\n+            Some(node)\n+        } else {\n+            None\n+        }\n     }\n \n     fn visit_unconfigurable_expr(&mut self, expr: &ast::Expr) {\n@@ -70,58 +74,48 @@ impl<T: CfgFolder> fold::Folder for T {\n     fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         ast::ForeignMod {\n             abi: foreign_mod.abi,\n-            items: foreign_mod.items.into_iter().filter(|item| {\n-                self.in_cfg(&item.attrs)\n-            }).collect(),\n+            items: foreign_mod.items.into_iter().filter_map(|item| self.configure(item)).collect(),\n         }\n     }\n \n     fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n         let fold_struct = |this: &mut Self, vdata| match vdata {\n             ast::VariantData::Struct(fields, id) => {\n-                ast::VariantData::Struct(fields.into_iter().filter(|m| {\n-                    this.in_cfg(&m.attrs)\n-                }).collect(), id)\n+                let fields = fields.into_iter().filter_map(|field| this.configure(field));\n+                ast::VariantData::Struct(fields.collect(), id)\n             }\n             ast::VariantData::Tuple(fields, id) => {\n-                ast::VariantData::Tuple(fields.into_iter().filter(|m| {\n-                    this.in_cfg(&m.attrs)\n-                }).collect(), id)\n+                let fields = fields.into_iter().filter_map(|field| this.configure(field));\n+                ast::VariantData::Tuple(fields.collect(), id)\n             }\n             ast::VariantData::Unit(id) => ast::VariantData::Unit(id)\n         };\n \n         let item = match item {\n-            ast::ItemKind::Impl(u, o, a, b, c, impl_items) => {\n-                let impl_items = impl_items.into_iter()\n-                                           .filter(|ii| self.in_cfg(&ii.attrs))\n-                                           .collect();\n-                ast::ItemKind::Impl(u, o, a, b, c, impl_items)\n+            ast::ItemKind::Impl(u, o, a, b, c, items) => {\n+                let items = items.into_iter().filter_map(|item| self.configure(item)).collect();\n+                ast::ItemKind::Impl(u, o, a, b, c, items)\n             }\n-            ast::ItemKind::Trait(u, a, b, methods) => {\n-                let methods = methods.into_iter()\n-                                     .filter(|ti| self.in_cfg(&ti.attrs))\n-                                     .collect();\n-                ast::ItemKind::Trait(u, a, b, methods)\n+            ast::ItemKind::Trait(u, a, b, items) => {\n+                let items = items.into_iter().filter_map(|item| self.configure(item)).collect();\n+                ast::ItemKind::Trait(u, a, b, items)\n             }\n             ast::ItemKind::Struct(def, generics) => {\n                 ast::ItemKind::Struct(fold_struct(self, def), generics)\n             }\n             ast::ItemKind::Enum(def, generics) => {\n                 let variants = def.variants.into_iter().filter_map(|v| {\n-                    if !self.in_cfg(&v.node.attrs) {\n-                        None\n-                    } else {\n-                        Some(Spanned {\n+                    self.configure(v).map(|v| {\n+                        Spanned {\n                             node: ast::Variant_ {\n                                 name: v.node.name,\n                                 attrs: v.node.attrs,\n                                 data: fold_struct(self, v.node.data),\n                                 disr_expr: v.node.disr_expr,\n                             },\n                             span: v.span\n-                        })\n-                    }\n+                        }\n+                    })\n                 });\n                 ast::ItemKind::Enum(ast::EnumDef {\n                     variants: variants.collect(),\n@@ -146,31 +140,21 @@ impl<T: CfgFolder> fold::Folder for T {\n     }\n \n     fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        if self.in_cfg(expr.attrs()) {\n-            Some(fold_expr(self, expr))\n-        } else {\n-            None\n-        }\n+        self.configure(expr).map(|expr| fold_expr(self, expr))\n     }\n \n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n-        if self.in_cfg(stmt.node.attrs()) {\n-            fold::noop_fold_stmt(stmt, self)\n-        } else {\n-            SmallVector::zero()\n-        }\n+        self.configure(stmt).map(|stmt| fold::noop_fold_stmt(stmt, self))\n+                            .unwrap_or(SmallVector::zero())\n     }\n \n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n         fold::noop_fold_mac(mac, self)\n     }\n \n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        if self.in_cfg(&item.attrs) {\n-            SmallVector::one(item.map(|i| self.fold_item_simple(i)))\n-        } else {\n-            SmallVector::zero()\n-        }\n+        self.configure(item).map(|item| SmallVector::one(item.map(|i| self.fold_item_simple(i))))\n+                            .unwrap_or(SmallVector::zero())\n     }\n }\n \n@@ -192,7 +176,7 @@ fn fold_expr<F: CfgFolder>(folder: &mut F, expr: P<ast::Expr>) -> P<ast::Expr> {\n             node: match node {\n                 ast::ExprKind::Match(m, arms) => {\n                     ast::ExprKind::Match(m, arms.into_iter()\n-                                        .filter(|a| folder.in_cfg(&a.attrs))\n+                                        .filter_map(|a| folder.configure(a))\n                                         .collect())\n                 }\n                 _ => node"}]}