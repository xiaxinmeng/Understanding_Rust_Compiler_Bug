{"sha": "2180c243214ebce29c45c37020e929924a8520d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxODBjMjQzMjE0ZWJjZTI5YzQ1YzM3MDIwZTkyOTkyNGE4NTIwZDg=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-09-24T20:55:49Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-10-02T19:39:01Z"}, "message": "Make lifetimes in constants live at the point of use", "tree": {"sha": "033864fd841b43716f22b0b8b0991daae91fd0df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/033864fd841b43716f22b0b8b0991daae91fd0df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2180c243214ebce29c45c37020e929924a8520d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2180c243214ebce29c45c37020e929924a8520d8", "html_url": "https://github.com/rust-lang/rust/commit/2180c243214ebce29c45c37020e929924a8520d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2180c243214ebce29c45c37020e929924a8520d8/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08a60ac6ed68628c4ccdb3fcbb6d780cadd7565a", "url": "https://api.github.com/repos/rust-lang/rust/commits/08a60ac6ed68628c4ccdb3fcbb6d780cadd7565a", "html_url": "https://github.com/rust-lang/rust/commit/08a60ac6ed68628c4ccdb3fcbb6d780cadd7565a"}], "stats": {"total": 85, "additions": 58, "deletions": 27}, "files": [{"sha": "adc3381a1e7625dfac076d8e2e6f52ba60ae90b8", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2180c243214ebce29c45c37020e929924a8520d8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2180c243214ebce29c45c37020e929924a8520d8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=2180c243214ebce29c45c37020e929924a8520d8", "patch": "@@ -276,7 +276,17 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n \n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n-        self.sanitize_type(constant, constant.literal.ty);\n+        let ty = self.sanitize_type(constant, constant.literal.ty);\n+\n+        self.cx.infcx.tcx.for_each_free_region(&ty, |live_region| {\n+            let live_region_vid =\n+                self.cx.borrowck_context.universal_regions.to_region_vid(live_region);\n+            self.cx\n+                .borrowck_context\n+                .constraints\n+                .liveness_constraints\n+                .add_element(live_region_vid, location);\n+        });\n \n         if let Some(annotation_index) = constant.user_ty {\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n@@ -528,56 +538,64 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         let parent_body = mem::replace(&mut self.body, promoted_body);\n \n+        // Use new sets of constraints and closure bounds so that we can\n+        // modify their locations.\n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n         let mut closure_bounds = Default::default();\n+        let mut liveness_constraints = LivenessValues::new(\n+            Rc::new(RegionValueElements::new(promoted_body)),\n+        );\n         // Don't try to add borrow_region facts for the promoted MIR\n-        mem::swap(self.cx.borrowck_context.all_facts, all_facts);\n \n-        // Use a new sets of constraints and closure bounds so that we can\n-        // modify their locations.\n-        mem::swap(\n-            &mut self.cx.borrowck_context.constraints.outlives_constraints,\n-            &mut constraints\n-        );\n-        mem::swap(\n-            &mut self.cx.borrowck_context.constraints.closure_bounds_mapping,\n-            &mut closure_bounds\n-        );\n+        let mut swap_constraints = |this: &mut Self| {\n+            mem::swap(this.cx.borrowck_context.all_facts, all_facts);\n+            mem::swap(\n+                &mut this.cx.borrowck_context.constraints.outlives_constraints,\n+                &mut constraints\n+            );\n+            mem::swap(\n+                &mut this.cx.borrowck_context.constraints.closure_bounds_mapping,\n+                &mut closure_bounds\n+            );\n+            mem::swap(\n+                &mut this.cx.borrowck_context.constraints.liveness_constraints,\n+                &mut liveness_constraints\n+            );\n+        };\n+\n+        swap_constraints(self);\n \n         self.visit_body(promoted_body);\n \n+\n         if !self.errors_reported {\n             // if verifier failed, don't do further checks to avoid ICEs\n             self.cx.typeck_mir(promoted_body);\n         }\n \n         self.body = parent_body;\n         // Merge the outlives constraints back in, at the given location.\n-        mem::swap(self.cx.borrowck_context.all_facts, all_facts);\n-        mem::swap(\n-            &mut self.cx.borrowck_context.constraints.outlives_constraints,\n-            &mut constraints\n-        );\n-        mem::swap(\n-            &mut self.cx.borrowck_context.constraints.closure_bounds_mapping,\n-            &mut closure_bounds\n-        );\n+        swap_constraints(self);\n \n         let locations = location.to_locations();\n         for constraint in constraints.outlives().iter() {\n             let mut constraint = *constraint;\n             constraint.locations = locations;\n             if let ConstraintCategory::Return\n-                | ConstraintCategory::UseAsConst\n-                | ConstraintCategory::UseAsStatic = constraint.category\n+            | ConstraintCategory::UseAsConst\n+            | ConstraintCategory::UseAsStatic = constraint.category\n             {\n                 // \"Returning\" from a promoted is an assigment to a\n                 // temporary from the user's point of view.\n                 constraint.category = ConstraintCategory::Boring;\n             }\n             self.cx.borrowck_context.constraints.outlives_constraints.push(constraint)\n         }\n+        for live_region in liveness_constraints.rows() {\n+            self.cx.borrowck_context.constraints.liveness_constraints\n+                .add_element(live_region, location);\n+        }\n \n         if !closure_bounds.is_empty() {\n             let combined_bounds_mapping = closure_bounds"}, {"sha": "e476047a7a644358b1a9040183e6993c5d4a83d1", "filename": "src/test/ui/hrtb/due-to-where-clause.nll.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2180c243214ebce29c45c37020e929924a8520d8/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2180c243214ebce29c45c37020e929924a8520d8/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.nll.stderr?ref=2180c243214ebce29c45c37020e929924a8520d8", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/due-to-where-clause.rs:2:5\n+   |\n+LL |     test::<FooS>(&mut 42);\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "1afd15613b51c301643befc0db04542813a037c9", "filename": "src/test/ui/hrtb/due-to-where-clause.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2180c243214ebce29c45c37020e929924a8520d8/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2180c243214ebce29c45c37020e929924a8520d8/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.rs?ref=2180c243214ebce29c45c37020e929924a8520d8", "patch": "@@ -1,6 +1,3 @@\n-// ignore-compare-mode-nll\n-// ^ This code works in nll mode.\n-\n fn main() {\n     test::<FooS>(&mut 42); //~ ERROR implementation of `Foo` is not general enough\n }"}, {"sha": "e4096ec059a6e9c52a488da06575525b2096344a", "filename": "src/test/ui/hrtb/due-to-where-clause.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2180c243214ebce29c45c37020e929924a8520d8/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2180c243214ebce29c45c37020e929924a8520d8/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.stderr?ref=2180c243214ebce29c45c37020e929924a8520d8", "patch": "@@ -1,5 +1,5 @@\n error: implementation of `Foo` is not general enough\n-  --> $DIR/due-to-where-clause.rs:5:5\n+  --> $DIR/due-to-where-clause.rs:2:5\n    |\n LL |     test::<FooS>(&mut 42);\n    |     ^^^^^^^^^^^^ implementation of `Foo` is not general enough"}, {"sha": "e5a8e1e5c2fccd1c2c616f67941e42addffc000a", "filename": "src/test/ui/nll/promoted-liveness.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2180c243214ebce29c45c37020e929924a8520d8/src%2Ftest%2Fui%2Fnll%2Fpromoted-liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2180c243214ebce29c45c37020e929924a8520d8/src%2Ftest%2Fui%2Fnll%2Fpromoted-liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpromoted-liveness.rs?ref=2180c243214ebce29c45c37020e929924a8520d8", "patch": "@@ -0,0 +1,8 @@\n+// Test that promoted that have larger mir bodies than their containing function\n+// don't cause an ICE.\n+\n+// check-pass\n+\n+fn main() {\n+    &[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"];\n+}"}]}