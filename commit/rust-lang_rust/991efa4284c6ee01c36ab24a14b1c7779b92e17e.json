{"sha": "991efa4284c6ee01c36ab24a14b1c7779b92e17e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5MWVmYTQyODRjNmVlMDFjMzZhYjI0YTE0YjFjNzc3OWI5MmUxN2U=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-14T11:05:47Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-20T11:23:33Z"}, "message": "Address various comments", "tree": {"sha": "a2ee0d3261c98c46d1edffa53eb7131ecf1580a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2ee0d3261c98c46d1edffa53eb7131ecf1580a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/991efa4284c6ee01c36ab24a14b1c7779b92e17e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/991efa4284c6ee01c36ab24a14b1c7779b92e17e", "html_url": "https://github.com/rust-lang/rust/commit/991efa4284c6ee01c36ab24a14b1c7779b92e17e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/991efa4284c6ee01c36ab24a14b1c7779b92e17e/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91712bc665d82019c5238dcd43280c9b8e2192cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/91712bc665d82019c5238dcd43280c9b8e2192cb", "html_url": "https://github.com/rust-lang/rust/commit/91712bc665d82019c5238dcd43280c9b8e2192cb"}], "stats": {"total": 200, "additions": 103, "deletions": 97}, "files": [{"sha": "aec94d60f94306f2390e2e03e9f705ca8affcfde", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=991efa4284c6ee01c36ab24a14b1c7779b92e17e", "patch": "@@ -379,15 +379,15 @@ impl<'a> LoweringContext<'a> {\n                 });\n \n                 if item_lowered {\n-                    let item_lifetimes = match self.lctx.items.get(&item.id).unwrap().node {\n+                    let item_generics = match self.lctx.items.get(&item.id).unwrap().node {\n                         hir::Item_::ItemImpl(_, _, _, ref generics, ..)\n                         | hir::Item_::ItemTrait(_, _, ref generics, ..) => {\n                             generics.params.clone()\n                         }\n                         _ => HirVec::new(),\n                     };\n \n-                    self.lctx.with_parent_impl_lifetime_defs(&item_lifetimes, |this| {\n+                    self.lctx.with_parent_impl_lifetime_defs(&item_generics, |this| {\n                         let this = &mut ItemLowerer { lctx: this };\n                         if let ItemKind::Impl(_, _, _, _, ref opt_trait_ref, _, _) = item.node {\n                             this.with_trait_impl_ref(opt_trait_ref, |this| {"}, {"sha": "178b9b1f45af14133292ea886e76e4891b772dfd", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=991efa4284c6ee01c36ab24a14b1c7779b92e17e", "patch": "@@ -49,11 +49,16 @@ pub enum LifetimeDefOrigin {\n }\n \n impl LifetimeDefOrigin {\n-    fn from_is_in_band(is_in_band: bool) -> Self {\n-        if is_in_band {\n-            LifetimeDefOrigin::InBand\n-        } else {\n-            LifetimeDefOrigin::Explicit\n+    fn from_param(param: &GenericParam) -> Self {\n+        match param.kind {\n+            GenericParamKind::Lifetime { in_band } => {\n+                if in_band {\n+                    LifetimeDefOrigin::InBand\n+                } else {\n+                    LifetimeDefOrigin::Explicit\n+                }\n+            }\n+            _ => bug!(\"expected a lifetime param\"),\n         }\n     }\n }\n@@ -82,29 +87,20 @@ pub enum Region {\n     Free(DefId, /* lifetime decl */ DefId),\n }\n \n-fn new_region(hir_map: &Map, param: &GenericParam) -> (DefId, LifetimeDefOrigin) {\n-    let def_id = hir_map.local_def_id(param.id);\n-    let origin = match param.kind {\n-        GenericParamKind::Lifetime { in_band, .. } => {\n-            LifetimeDefOrigin::from_is_in_band(in_band)\n-        }\n-        _ => bug!(\"expected a lifetime param\"),\n-    };\n-    (def_id, origin)\n-}\n-\n impl Region {\n     fn early(hir_map: &Map, index: &mut u32, param: &GenericParam) -> (ParamName, Region) {\n         let i = *index;\n         *index += 1;\n-        let (def_id, origin) = new_region(hir_map, param);\n+        let def_id = hir_map.local_def_id(param.id);\n+        let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n         (param.name, Region::EarlyBound(i, def_id, origin))\n     }\n \n     fn late(hir_map: &Map, param: &GenericParam) -> (ParamName, Region) {\n         let depth = ty::INNERMOST;\n-        let (def_id, origin) = new_region(hir_map, param);\n+        let def_id = hir_map.local_def_id(param.id);\n+        let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\n             \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n             param,\n@@ -1300,16 +1296,19 @@ fn object_lifetime_defaults_for_item(\n                         Set1::One(Region::Static)\n                     } else {\n                         generics.params.iter().filter_map(|param| match param.kind {\n-                            GenericParamKind::Lifetime { in_band } => {\n-                                Some((param.id, hir::LifetimeName::Param(param.name), in_band))\n+                            GenericParamKind::Lifetime { .. } => {\n+                                Some((\n+                                    param.id,\n+                                    hir::LifetimeName::Param(param.name),\n+                                    LifetimeDefOrigin::from_param(param),\n+                                ))\n                             }\n                             _ => None,\n                         })\n                         .enumerate()\n                         .find(|&(_, (_, lt_name, _))| lt_name == name)\n-                        .map_or(Set1::Many, |(i, (id, _, in_band))| {\n+                        .map_or(Set1::Many, |(i, (id, _, origin))| {\n                             let def_id = tcx.hir.local_def_id(id);\n-                            let origin = LifetimeDefOrigin::from_is_in_band(in_band);\n                             Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n                         })\n                     }"}, {"sha": "804000faa370e281ee782dad17bd241d58d5de9d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=991efa4284c6ee01c36ab24a14b1c7779b92e17e", "patch": "@@ -821,43 +821,50 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n             let item_def_id = cx.tcx.hir.local_def_id(it.id);\n             let t = cx.tcx.type_of(item_def_id);\n             let ty = cx.tcx.erase_regions(&t);\n-            let layout = cx.layout_of(ty).unwrap_or_else(|e| {\n-                bug!(\"failed to get layout for `{}`: {}\", t, e)\n-            });\n-\n-            if let layout::Variants::Tagged { ref variants, ref tag, .. } = layout.variants {\n-                let discr_size = tag.value.size(cx.tcx).bytes();\n-\n-                debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n-                    t, layout.size.bytes(), layout);\n-\n-                let (largest, slargest, largest_index) = enum_definition.variants\n-                    .iter()\n-                    .zip(variants)\n-                    .map(|(variant, variant_layout)| {\n-                        // Subtract the size of the enum discriminant.\n-                        let bytes = variant_layout.size.bytes().saturating_sub(discr_size);\n-\n-                        debug!(\"- variant `{}` is {} bytes large\", variant.node.name, bytes);\n-                        bytes\n-                    })\n-                    .enumerate()\n-                    .fold((0, 0, 0), |(l, s, li), (idx, size)| if size > l {\n-                        (size, l, idx)\n-                    } else if size > s {\n-                        (l, size, li)\n-                    } else {\n-                        (l, s, li)\n-                    });\n-\n-                // We only warn if the largest variant is at least thrice as large as\n-                // the second-largest.\n-                if largest > slargest * 3 && slargest > 0 {\n-                    cx.span_lint(VARIANT_SIZE_DIFFERENCES,\n-                                    enum_definition.variants[largest_index].span,\n-                                    &format!(\"enum variant is more than three times larger \\\n-                                            ({} bytes) than the next largest\",\n-                                            largest));\n+            match cx.layout_of(ty) {\n+                Ok(layout) => {\n+                    let variants = &layout.variants;\n+                    if let layout::Variants::Tagged { ref variants, ref tag, .. } = variants {\n+                        let discr_size = tag.value.size(cx.tcx).bytes();\n+\n+                        debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n+                               t, layout.size.bytes(), layout);\n+\n+                        let (largest, slargest, largest_index) = enum_definition.variants\n+                            .iter()\n+                            .zip(variants)\n+                            .map(|(variant, variant_layout)| {\n+                                // Subtract the size of the enum discriminant.\n+                                let bytes = variant_layout.size.bytes().saturating_sub(discr_size);\n+\n+                                debug!(\"- variant `{}` is {} bytes large\",\n+                                       variant.node.name,\n+                                       bytes);\n+                                bytes\n+                            })\n+                            .enumerate()\n+                            .fold((0, 0, 0), |(l, s, li), (idx, size)| if size > l {\n+                                (size, l, idx)\n+                            } else if size > s {\n+                                (l, size, li)\n+                            } else {\n+                                (l, s, li)\n+                            });\n+\n+                        // We only warn if the largest variant is at least thrice as large as\n+                        // the second-largest.\n+                        if largest > slargest * 3 && slargest > 0 {\n+                            cx.span_lint(VARIANT_SIZE_DIFFERENCES,\n+                                            enum_definition.variants[largest_index].span,\n+                                            &format!(\"enum variant is more than three times \\\n+                                                      larger ({} bytes) than the next largest\",\n+                                                     largest));\n+                        }\n+                    }\n+                }\n+                Err(ty::layout::LayoutError::Unknown(_)) => return,\n+                Err(err @ ty::layout::LayoutError::SizeOverflow(_)) => {\n+                    bug!(\"failed to get layout for `{}`: {}\", t, err);\n                 }\n             }\n         }"}, {"sha": "e311701ac0589722ecc7a435d79e6ad39a49112e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=991efa4284c6ee01c36ab24a14b1c7779b92e17e", "patch": "@@ -2208,26 +2208,26 @@ impl<'a> Resolver<'a> {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = FxHashMap();\n                 generics.params.iter().for_each(|param| match param.kind {\n-                        GenericParamKind::Type { .. } => {\n-                            let ident = param.ident.modern();\n-                            debug!(\"with_type_parameter_rib: {}\", param.id);\n-\n-                            if seen_bindings.contains_key(&ident) {\n-                                let span = seen_bindings.get(&ident).unwrap();\n-                                let err = ResolutionError::NameAlreadyUsedInTypeParameterList(\n-                                    ident.name,\n-                                    span,\n-                                );\n-                                resolve_error(self, param.ident.span, err);\n-                            }\n-                            seen_bindings.entry(ident).or_insert(param.ident.span);\n-\n-                        // Plain insert (no renaming).\n-                        let def = Def::TyParam(self.definitions.local_def_id(param.id));\n-                            function_type_rib.bindings.insert(ident, def);\n-                            self.record_def(param.id, PathResolution::new(def));\n+                    GenericParamKind::Lifetime { .. } => {}\n+                    GenericParamKind::Type { .. } => {\n+                        let ident = param.ident.modern();\n+                        debug!(\"with_type_parameter_rib: {}\", param.id);\n+\n+                        if seen_bindings.contains_key(&ident) {\n+                            let span = seen_bindings.get(&ident).unwrap();\n+                            let err = ResolutionError::NameAlreadyUsedInTypeParameterList(\n+                                ident.name,\n+                                span,\n+                            );\n+                            resolve_error(self, param.ident.span, err);\n                         }\n-                        _ => {}\n+                        seen_bindings.entry(ident).or_insert(param.ident.span);\n+\n+                    // Plain insert (no renaming).\n+                    let def = Def::TyParam(self.definitions.local_def_id(param.id));\n+                        function_type_rib.bindings.insert(ident, def);\n+                        self.record_def(param.id, PathResolution::new(def));\n+                    }\n                 });\n                 self.ribs[TypeNS].push(function_type_rib);\n             }"}, {"sha": "48c5353a400012083dfe24c7c52b179e709c4908", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=991efa4284c6ee01c36ab24a14b1c7779b92e17e", "patch": "@@ -379,7 +379,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         self_ty: Ty<'tcx>)\n         -> ty::TraitRef<'tcx>\n     {\n-        self.prohibit_type_params(trait_ref.path.segments.split_last().unwrap().1);\n+        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n         let trait_def_id = self.trait_def_id(trait_ref);\n         self.ast_path_to_mono_trait_ref(trait_ref.path.span,\n@@ -413,7 +413,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"ast_path_to_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n \n-        self.prohibit_type_params(trait_ref.path.segments.split_last().unwrap().1);\n+        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n         let (substs, assoc_bindings) =\n             self.create_substs_for_ast_trait_ref(trait_ref.path.span,\n@@ -891,7 +891,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"associated_path_def_to_ty: {:?}::{}\", ty, assoc_name);\n \n-        self.prohibit_type_params(slice::from_ref(item_segment));\n+        self.prohibit_generics(slice::from_ref(item_segment));\n \n         // Find the type of the associated item, and the trait where the associated\n         // item is declared.\n@@ -968,7 +968,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n         let trait_def_id = tcx.parent_def_id(item_def_id).unwrap();\n \n-        self.prohibit_type_params(slice::from_ref(item_segment));\n+        self.prohibit_generics(slice::from_ref(item_segment));\n \n         let self_ty = if let Some(ty) = opt_self_ty {\n             ty\n@@ -993,7 +993,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         self.normalize_ty(span, tcx.mk_projection(item_def_id, trait_ref.substs))\n     }\n \n-    pub fn prohibit_type_params(&self, segments: &[hir::PathSegment]) {\n+    pub fn prohibit_generics(&self, segments: &[hir::PathSegment]) {\n         for segment in segments {\n             segment.with_generic_args(|generic_args| {\n                 let (mut err_for_lt, mut err_for_ty) = (false, false);\n@@ -1053,21 +1053,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) |\n             Def::Union(did) | Def::TyForeign(did) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_type_params(path.segments.split_last().unwrap().1);\n+                self.prohibit_generics(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n             Def::Variant(did) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_type_params(path.segments.split_last().unwrap().1);\n+                self.prohibit_generics(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(span,\n                                     tcx.parent_def_id(did).unwrap(),\n                                     path.segments.last().unwrap())\n             }\n             Def::TyParam(did) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_type_params(&path.segments);\n+                self.prohibit_generics(&path.segments);\n \n                 let node_id = tcx.hir.as_local_node_id(did).unwrap();\n                 let item_id = tcx.hir.get_parent_node(node_id);\n@@ -1080,18 +1080,18 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // Self in impl (we know the concrete type).\n \n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_type_params(&path.segments);\n+                self.prohibit_generics(&path.segments);\n \n                 tcx.at(span).type_of(def_id)\n             }\n             Def::SelfTy(Some(_), None) => {\n                 // Self in trait.\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_type_params(&path.segments);\n+                self.prohibit_generics(&path.segments);\n                 tcx.mk_self_type()\n             }\n             Def::AssociatedTy(def_id) => {\n-                self.prohibit_type_params(&path.segments[..path.segments.len()-2]);\n+                self.prohibit_generics(&path.segments[..path.segments.len()-2]);\n                 self.qpath_to_ty(span,\n                                  opt_self_ty,\n                                  def_id,\n@@ -1100,7 +1100,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             Def::PrimTy(prim_ty) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_type_params(&path.segments);\n+                self.prohibit_generics(&path.segments);\n                 match prim_ty {\n                     hir::TyBool => tcx.types.bool,\n                     hir::TyChar => tcx.types.char,"}, {"sha": "bececfc08ac0ea9cfaef79eb188a037e27f0ec6c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=991efa4284c6ee01c36ab24a14b1c7779b92e17e", "patch": "@@ -4782,7 +4782,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // errors if type parameters are provided in an inappropriate place.\n         let poly_segments = type_segment.is_some() as usize +\n                             fn_segment.is_some() as usize;\n-        AstConv::prohibit_type_params(self, &segments[..segments.len() - poly_segments]);\n+        AstConv::prohibit_generics(self, &segments[..segments.len() - poly_segments]);\n \n         match def {\n             Def::Local(nid) | Def::Upvar(nid, ..) => {"}, {"sha": "b61f09cbaea6d22b2789f476416768f0f039dd7a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=991efa4284c6ee01c36ab24a14b1c7779b92e17e", "patch": "@@ -602,8 +602,8 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n }\n \n fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    item: &hir::Item,\n-                                    ast_generics: &hir::Generics)\n+                                           item: &hir::Item,\n+                                           hir_generics: &hir::Generics)\n {\n     let item_def_id = tcx.hir.local_def_id(item.id);\n     let ty = tcx.type_of(item_def_id);\n@@ -631,7 +631,7 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             continue;\n         }\n \n-        let param = &ast_generics.params[index];\n+        let param = &hir_generics.params[index];\n         report_bivariance(tcx, param.span, param.name.name());\n     }\n }"}, {"sha": "6e154819c4c4e0f5ec3c1b662f2b776aba5765ea", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/991efa4284c6ee01c36ab24a14b1c7779b92e17e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=991efa4284c6ee01c36ab24a14b1c7779b92e17e", "patch": "@@ -117,7 +117,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n         for param in &generics.params {\n             match param.kind {\n                 hir::GenericParamKind::Lifetime { .. } => {}\n-                hir::GenericParamKind::Type { ref default, .. } if default.is_some() => {\n+                hir::GenericParamKind::Type { default: Some(_), .. } => {\n                     let def_id = self.tcx.hir.local_def_id(param.id);\n                     self.tcx.type_of(def_id);\n                 }"}]}