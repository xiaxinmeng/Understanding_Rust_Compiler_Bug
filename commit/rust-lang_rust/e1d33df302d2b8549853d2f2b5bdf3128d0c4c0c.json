{"sha": "e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZDMzZGYzMDJkMmI4NTQ5ODUzZDJmMmI1YmRmMzEyOGQwYzRjMGM=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-04-15T01:50:10Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-04-15T01:50:10Z"}, "message": "Merge pull request #923 from matklad/proper-exit-code\n\nreturn non-zero exit code if there are errors", "tree": {"sha": "5545d76c05eda644a626559a45156ca0c59e708e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5545d76c05eda644a626559a45156ca0c59e708e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c", "html_url": "https://github.com/rust-lang/rust/commit/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5adc453f2397630e2031a694bc5d83968c70d77c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5adc453f2397630e2031a694bc5d83968c70d77c", "html_url": "https://github.com/rust-lang/rust/commit/5adc453f2397630e2031a694bc5d83968c70d77c"}, {"sha": "77350e49b5d4674085e306986c564fd99686cc67", "url": "https://api.github.com/repos/rust-lang/rust/commits/77350e49b5d4674085e306986c564fd99686cc67", "html_url": "https://github.com/rust-lang/rust/commit/77350e49b5d4674085e306986c564fd99686cc67"}], "stats": {"total": 153, "additions": 132, "deletions": 21}, "files": [{"sha": "d2dc9a22f8511e432b74b920273bc577d1e98563", "filename": "README.md", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c", "patch": "@@ -63,10 +63,18 @@ diff, replace, overwrite, display, coverage, and checkstyle.\n The write mode can be set by passing the `--write-mode` flag on\n the command line. For example `rustfmt --write-mode=display src/filename.rs`\n \n-You can run `rustfmt --help` for more information.\n-\n `cargo fmt` uses `--write-mode=replace` by default.\n \n+If `rustfmt` successfully reformatted the code it will exit with `0` exit\n+status. Exit status `1` signals some unexpected error, like an unknown option or\n+a failure to read a file. Exit status `2` is returned if there are syntax errors\n+in the input files. `rustfmt` can't format syntatically invalid code. Finally,\n+exit status `3` is returned if there are some issues which can't be resolved\n+automatically. For example, if you have a very long comment line `rustfmt`\n+doesn't split it. Instead it prints a warning and exits with `3`.\n+\n+You can run `rustfmt --help` for more information.\n+\n \n ## Running Rustfmt from your editor\n "}, {"sha": "778a96a3c1b0765632af71d2bc2d92097a033299", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c", "patch": "@@ -17,7 +17,7 @@ extern crate toml;\n extern crate env_logger;\n extern crate getopts;\n \n-use rustfmt::{run, Input};\n+use rustfmt::{run, Input, Summary};\n use rustfmt::config::{Config, WriteMode};\n \n use std::{env, error};\n@@ -156,18 +156,21 @@ fn make_opts() -> Options {\n     opts\n }\n \n-fn execute(opts: &Options) -> FmtResult<()> {\n+fn execute(opts: &Options) -> FmtResult<Summary> {\n     let matches = try!(opts.parse(env::args().skip(1)));\n \n     match try!(determine_operation(&matches)) {\n         Operation::Help => {\n             print_usage(&opts, \"\");\n+            Ok(Summary::new())\n         }\n         Operation::Version => {\n             print_version();\n+            Ok(Summary::new())\n         }\n         Operation::ConfigHelp => {\n             Config::print_docs();\n+            Ok(Summary::new())\n         }\n         Operation::Stdin { input, config_path } => {\n             // try to read config from local directory\n@@ -177,7 +180,7 @@ fn execute(opts: &Options) -> FmtResult<()> {\n             // write_mode is always Plain for Stdin.\n             config.write_mode = WriteMode::Plain;\n \n-            run(Input::Text(input), &config);\n+            Ok(run(Input::Text(input), &config))\n         }\n         Operation::Format { files, config_path } => {\n             let mut config = Config::default();\n@@ -193,6 +196,8 @@ fn execute(opts: &Options) -> FmtResult<()> {\n             if let Some(path) = path.as_ref() {\n                 println!(\"Using rustfmt config file {}\", path.display());\n             }\n+\n+            let mut error_summary = Summary::new();\n             for file in files {\n                 // Check the file directory if the config-path could not be read or not provided\n                 if path.is_none() {\n@@ -209,11 +214,11 @@ fn execute(opts: &Options) -> FmtResult<()> {\n                 }\n \n                 try!(update_config(&mut config, &matches));\n-                run(Input::File(file), &config);\n+                error_summary.add(run(Input::File(file), &config));\n             }\n+            Ok(error_summary)\n         }\n     }\n-    Ok(())\n }\n \n fn main() {\n@@ -222,7 +227,18 @@ fn main() {\n     let opts = make_opts();\n \n     let exit_code = match execute(&opts) {\n-        Ok(..) => 0,\n+        Ok(summary) => {\n+            if summary.has_operational_errors() {\n+                1\n+            } else if summary.has_parsing_errors() {\n+                2\n+            } else if summary.has_formatting_errors() {\n+                3\n+            } else {\n+                assert!(summary.has_no_errors());\n+                0\n+            }\n+        }\n         Err(e) => {\n             print_usage(&opts, &e.to_string());\n             1"}, {"sha": "9d90c58bea52f2ea625b651071cd78cda57f7db7", "filename": "src/lib.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c", "patch": "@@ -41,7 +41,9 @@ use std::fmt;\n use issues::{BadIssueSeeker, Issue};\n use filemap::FileMap;\n use visitor::FmtVisitor;\n-use config::{Config, WriteMode};\n+use config::Config;\n+\n+pub use self::summary::Summary;\n \n #[macro_use]\n mod utils;\n@@ -64,6 +66,7 @@ pub mod rustfmt_diff;\n mod chains;\n mod macros;\n mod patterns;\n+mod summary;\n \n const MIN_STRING: usize = 10;\n // When we get scoped annotations, we should have rustfmt::skip.\n@@ -239,9 +242,17 @@ pub struct FormatReport {\n }\n \n impl FormatReport {\n+    fn new() -> FormatReport {\n+        FormatReport { file_error_map: HashMap::new() }\n+    }\n+\n     pub fn warning_count(&self) -> usize {\n         self.file_error_map.iter().map(|(_, ref errors)| errors.len()).fold(0, |acc, x| acc + x)\n     }\n+\n+    pub fn has_warnings(&self) -> bool {\n+        self.warning_count() > 0\n+    }\n }\n \n impl fmt::Display for FormatReport {\n@@ -289,7 +300,7 @@ fn format_ast(krate: &ast::Crate,\n // TODO(#20) other stuff for parity with make tidy\n fn format_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n     let mut truncate_todo = Vec::new();\n-    let mut report = FormatReport { file_error_map: HashMap::new() };\n+    let mut report = FormatReport::new();\n \n     // Iterate over the chars in the file map.\n     for (f, text) in file_map.iter() {\n@@ -368,17 +379,16 @@ fn format_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n }\n \n fn parse_input(input: Input, parse_session: &ParseSess) -> Result<ast::Crate, DiagnosticBuilder> {\n-    let krate = match input {\n+    match input {\n         Input::File(file) => parse::parse_crate_from_file(&file, Vec::new(), &parse_session),\n         Input::Text(text) => {\n             parse::parse_crate_from_source_str(\"stdin\".to_owned(), text, Vec::new(), &parse_session)\n         }\n-    };\n-\n-    krate\n+    }\n }\n \n-pub fn format_input(input: Input, config: &Config) -> (FileMap, FormatReport) {\n+pub fn format_input(input: Input, config: &Config) -> (Summary, FileMap, FormatReport) {\n+    let mut summary = Summary::new();\n     let codemap = Rc::new(CodeMap::new());\n \n     let tty_handler = Handler::with_tty_emitter(ColorConfig::Auto,\n@@ -397,10 +407,15 @@ pub fn format_input(input: Input, config: &Config) -> (FileMap, FormatReport) {\n         Ok(krate) => krate,\n         Err(mut diagnostic) => {\n             diagnostic.emit();\n-            panic!(\"Unrecoverable parse error\");\n+            summary.add_parsing_error();\n+            return (summary, FileMap::new(), FormatReport::new());\n         }\n     };\n \n+    if parse_session.span_diagnostic.has_errors() {\n+        summary.add_parsing_error();\n+    }\n+\n     // Suppress error output after parsing.\n     let silent_emitter = Box::new(EmitterWriter::new(Box::new(Vec::new()), None, codemap.clone()));\n     parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n@@ -412,22 +427,28 @@ pub fn format_input(input: Input, config: &Config) -> (FileMap, FormatReport) {\n     filemap::append_newlines(&mut file_map);\n \n     let report = format_lines(&mut file_map, config);\n-    (file_map, report)\n+    if report.has_warnings() {\n+        summary.add_formatting_error();\n+    }\n+    (summary, file_map, report)\n }\n \n pub enum Input {\n     File(PathBuf),\n     Text(String),\n }\n \n-pub fn run(input: Input, config: &Config) {\n-    let (file_map, report) = format_input(input, config);\n+pub fn run(input: Input, config: &Config) -> Summary {\n+    let (mut summary, file_map, report) = format_input(input, config);\n     msg!(\"{}\", report);\n \n     let mut out = stdout();\n     let write_result = filemap::write_all_files(&file_map, &mut out, config);\n \n     if let Err(msg) = write_result {\n         msg!(\"Error writing files: {}\", msg);\n+        summary.add_operational_error();\n     }\n+\n+    summary\n }"}, {"sha": "5e5c0a579af6af3cc9b999ce4e1313ba544be68f", "filename": "src/summary.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c/src%2Fsummary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c/src%2Fsummary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsummary.rs?ref=e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c", "patch": "@@ -0,0 +1,55 @@\n+#[must_use]\n+pub struct Summary {\n+    // Encountered e.g. an IO error.\n+    has_operational_errors: bool,\n+\n+    // Failed to reformat code because of parsing errors.\n+    has_parsing_errors: bool,\n+\n+    // Code is valid, but it is impossible to format it properly.\n+    has_formatting_errors: bool,\n+}\n+\n+impl Summary {\n+    pub fn new() -> Summary {\n+        Summary {\n+            has_operational_errors: false,\n+            has_parsing_errors: false,\n+            has_formatting_errors: false,\n+        }\n+    }\n+\n+    pub fn has_operational_errors(&self) -> bool {\n+        self.has_operational_errors\n+    }\n+\n+    pub fn has_parsing_errors(&self) -> bool {\n+        self.has_parsing_errors\n+    }\n+\n+    pub fn has_formatting_errors(&self) -> bool {\n+        self.has_formatting_errors\n+    }\n+\n+    pub fn add_operational_error(&mut self) {\n+        self.has_operational_errors = true;\n+    }\n+\n+    pub fn add_parsing_error(&mut self) {\n+        self.has_parsing_errors = true;\n+    }\n+\n+    pub fn add_formatting_error(&mut self) {\n+        self.has_formatting_errors = true;\n+    }\n+\n+    pub fn has_no_errors(&self) -> bool {\n+        !(self.has_operational_errors || self.has_parsing_errors || self.has_formatting_errors)\n+    }\n+\n+    pub fn add(&mut self, other: Summary) {\n+        self.has_operational_errors |= other.has_operational_errors;\n+        self.has_formatting_errors |= other.has_formatting_errors;\n+        self.has_parsing_errors |= other.has_parsing_errors;\n+    }\n+}"}, {"sha": "2a6b1a9e19c15323dd573d3fd96efec11568166c", "filename": "tests/system.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=e1d33df302d2b8549853d2f2b5bdf3128d0c4c0c", "patch": "@@ -143,10 +143,20 @@ fn self_tests() {\n fn stdin_formatting_smoke_test() {\n     let input = Input::Text(\"fn main () {}\".to_owned());\n     let config = Config::default();\n-    let (file_map, _report) = format_input(input, &config);\n+    let (error_summary, file_map, _report) = format_input(input, &config);\n+    assert!(error_summary.has_no_errors());\n     assert_eq!(file_map[\"stdin\"].to_string(), \"fn main() {}\\n\")\n }\n \n+#[test]\n+fn format_lines_errors_are_reported() {\n+    let long_identifier = String::from_utf8(vec![b'a'; 239]).unwrap();\n+    let input = Input::Text(format!(\"fn {}() {{}}\", long_identifier));\n+    let config = Config::default();\n+    let (error_summary, _file_map, _report) = format_input(input, &config);\n+    assert!(error_summary.has_formatting_errors());\n+}\n+\n // For each file, run rustfmt and collect the output.\n // Returns the number of files checked and the number of failures.\n fn check_files<I>(files: I) -> (Vec<FormatReport>, u32, u32)\n@@ -202,7 +212,8 @@ fn read_config(filename: &str) -> Config {\n \n fn format_file<P: Into<PathBuf>>(filename: P, config: &Config) -> (FileMap, FormatReport) {\n     let input = Input::File(filename.into());\n-    format_input(input, &config)\n+    let (_error_summary, file_map, report) = format_input(input, &config);\n+    return (file_map, report);\n }\n \n pub fn idempotent_check(filename: String) -> Result<FormatReport, HashMap<String, Vec<Mismatch>>> {"}]}