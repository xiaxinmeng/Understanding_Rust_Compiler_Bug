{"sha": "0f49254b31353a80710af50e4f387740d154e60b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNDkyNTRiMzEzNTNhODA3MTBhZjUwZTRmMzg3NzQwZDE1NGU2MGI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-05T11:20:48Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-24T12:14:17Z"}, "message": "rustc: use partially resolved definitions to replace the `T::A` hack.", "tree": {"sha": "6df845d55cc576759ebb058248e11523ac408ba7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6df845d55cc576759ebb058248e11523ac408ba7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f49254b31353a80710af50e4f387740d154e60b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f49254b31353a80710af50e4f387740d154e60b", "html_url": "https://github.com/rust-lang/rust/commit/0f49254b31353a80710af50e4f387740d154e60b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f49254b31353a80710af50e4f387740d154e60b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5809f8ae746dbde96e0924b8e422b9e0d092375b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5809f8ae746dbde96e0924b8e422b9e0d092375b", "html_url": "https://github.com/rust-lang/rust/commit/5809f8ae746dbde96e0924b8e422b9e0d092375b"}], "stats": {"total": 751, "additions": 376, "deletions": 375}, "files": [{"sha": "621a231ed7d186304e7b861875c62560c70cc37a", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -17,29 +17,47 @@\n use middle::def;\n use middle::ty::{self, Ty};\n use syntax::ast;\n+use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n pub const NO_REGIONS: uint = 1;\n pub const NO_TPS: uint = 2;\n \n pub fn check_path_args(tcx: &ty::ctxt,\n-                       path: &ast::Path,\n+                       span: Span,\n+                       segments: &[ast::PathSegment],\n                        flags: uint) {\n     if (flags & NO_TPS) != 0 {\n-        if path.segments.iter().any(|s| s.parameters.has_types()) {\n-            span_err!(tcx.sess, path.span, E0109,\n+        if segments.iter().any(|s| s.parameters.has_types()) {\n+            span_err!(tcx.sess, span, E0109,\n                 \"type parameters are not allowed on this type\");\n         }\n     }\n \n     if (flags & NO_REGIONS) != 0 {\n-        if path.segments.iter().any(|s| s.parameters.has_lifetimes()) {\n-            span_err!(tcx.sess, path.span, E0110,\n+        if segments.iter().any(|s| s.parameters.has_lifetimes()) {\n+            span_err!(tcx.sess, span, E0110,\n                 \"lifetime parameters are not allowed on this type\");\n         }\n     }\n }\n \n+pub fn prim_ty_to_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                           span: Span,\n+                           segments: &[ast::PathSegment],\n+                           nty: ast::PrimTy)\n+                           -> Ty<'tcx> {\n+    check_path_args(tcx, span, segments, NO_TPS | NO_REGIONS);\n+    match nty {\n+        ast::TyBool => tcx.types.bool,\n+        ast::TyChar => tcx.types.char,\n+        ast::TyInt(it) => ty::mk_mach_int(tcx, it),\n+        ast::TyUint(uit) => ty::mk_mach_uint(tcx, uit),\n+        ast::TyFloat(ft) => ty::mk_mach_float(tcx, ft),\n+        ast::TyStr => ty::mk_str(tcx)\n+    }\n+}\n+\n pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                                -> Option<Ty<'tcx>> {\n     if let ast::TyPath(ref path) = ast_ty.node {\n@@ -51,15 +69,7 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n             Some(&d) => d\n         };\n         if let def::DefPrimTy(nty) = def {\n-            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-            Some(match nty {\n-                ast::TyBool => tcx.types.bool,\n-                ast::TyChar => tcx.types.char,\n-                ast::TyInt(it) => ty::mk_mach_int(tcx, it),\n-                ast::TyUint(uit) => ty::mk_mach_uint(tcx, uit),\n-                ast::TyFloat(ft) => ty::mk_mach_float(tcx, ft),\n-                ast::TyStr => ty::mk_str(tcx)\n-            })\n+            Some(prim_ty_to_ty(tcx, path.span, &path.segments[], nty))\n         } else {\n             None\n         }"}, {"sha": "f7d34f0056b0cedd978792461dc52b23ca9243af", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -444,10 +444,6 @@ impl tr for def::Def {\n           def::DefTy(did, is_enum) => def::DefTy(did.tr(dcx), is_enum),\n           def::DefAssociatedTy(trait_did, did) =>\n               def::DefAssociatedTy(trait_did.tr(dcx), did.tr(dcx)),\n-          def::DefAssociatedPath(def::TyParamProvenance::FromSelf(did), ident) =>\n-              def::DefAssociatedPath(def::TyParamProvenance::FromSelf(did.tr(dcx)), ident),\n-          def::DefAssociatedPath(def::TyParamProvenance::FromParam(did), ident) =>\n-              def::DefAssociatedPath(def::TyParamProvenance::FromParam(did.tr(dcx)), ident),\n           def::DefPrimTy(p) => def::DefPrimTy(p),\n           def::DefTyParam(s, index, def_id, n) => def::DefTyParam(s, index, def_id.tr(dcx), n),\n           def::DefUse(did) => def::DefUse(did.tr(dcx)),"}, {"sha": "e1794cc0c8ae2d4d214b3e0d6683f3ce324f13c6", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -33,11 +33,6 @@ pub enum Def {\n     DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n     DefTy(ast::DefId, bool /* is_enum */),\n     DefAssociatedTy(ast::DefId /* trait */, ast::DefId),\n-    // A partially resolved path to an associated type `T::U` where `T` is a concrete\n-    // type (indicated by the DefId) which implements a trait which has an associated\n-    // type `U` (indicated by the Ident).\n-    // FIXME(#20301) -- should use Name\n-    DefAssociatedPath(TyParamProvenance, ast::Ident),\n     DefTrait(ast::DefId),\n     DefPrimTy(ast::PrimTy),\n     DefTyParam(ParamSpace, u32, ast::DefId, ast::Name),\n@@ -59,8 +54,24 @@ pub enum Def {\n     DefMethod(ast::DefId /* method */, Option<ast::DefId> /* trait */, MethodProvenance),\n }\n \n+/// The result of resolving the prefix of a path to a type:\n+///\n+///     module::Type::AssocA::AssocB::AssocC::MethodOrAssocType\n+///     ^~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~\n+///     base_type     extra_associated_types\n+///\n+///     <T as Trait>::AssocA::AssocB::AssocC::MethodOrAssocType\n+///           ^~~~~~~~~~~~~~  ^~~~~~~~~~~~~~\n+///           base_type       extra_associated_types\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct PartialDef {\n+    pub base_type: Def,\n+    pub extra_associated_types: u32,\n+}\n+\n // Definition mapping\n pub type DefMap = RefCell<NodeMap<Def>>;\n+pub type PartialDefMap = RefCell<NodeMap<PartialDef>>;\n // This is the replacement export map. It maps a module to all of the exports\n // within.\n pub type ExportMap = NodeMap<Vec<Export>>;\n@@ -77,12 +88,6 @@ pub enum MethodProvenance {\n     FromImpl(ast::DefId),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum TyParamProvenance {\n-    FromSelf(ast::DefId),\n-    FromParam(ast::DefId),\n-}\n-\n impl MethodProvenance {\n     pub fn map<F>(self, f: F) -> MethodProvenance where\n         F: FnOnce(ast::DefId) -> ast::DefId,\n@@ -94,15 +99,6 @@ impl MethodProvenance {\n     }\n }\n \n-impl TyParamProvenance {\n-    pub fn def_id(&self) -> ast::DefId {\n-        match *self {\n-            TyParamProvenance::FromSelf(ref did) => did.clone(),\n-            TyParamProvenance::FromParam(ref did) => did.clone(),\n-        }\n-    }\n-}\n-\n #[derive(Clone, Copy, Eq, PartialEq)]\n pub enum TraitItemKind {\n     NonstaticMethodTraitItemKind,\n@@ -135,9 +131,7 @@ impl Def {\n             DefForeignMod(id) | DefStatic(id, _) |\n             DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(_, id) |\n             DefTyParam(_, _, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |\n-            DefMethod(id, _, _) | DefConst(id) |\n-            DefAssociatedPath(TyParamProvenance::FromSelf(id), _) |\n-            DefAssociatedPath(TyParamProvenance::FromParam(id), _) => {\n+            DefMethod(id, _, _) | DefConst(id) => {\n                 id\n             }\n             DefLocal(id) |"}, {"sha": "57aac8f98b6c5783557a833e1e66bf40bba8ba44", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -582,7 +582,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           def::DefTrait(_) | def::DefTy(..) | def::DefPrimTy(_) |\n           def::DefTyParam(..) | def::DefRegion(_) |\n           def::DefLabel(_) | def::DefSelfTy(..) |\n-          def::DefAssociatedTy(..) | def::DefAssociatedPath(..)=> {\n+          def::DefAssociatedTy(..) => {\n               Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,"}, {"sha": "2b0d032aa6df8f32989e9c528c3cda6edd2d94ed", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -46,7 +46,7 @@ use metadata::csearch;\n use middle;\n use middle::check_const;\n use middle::const_eval;\n-use middle::def::{self, DefMap, ExportMap};\n+use middle::def::{self, DefMap, ExportMap, PartialDefMap};\n use middle::dependency_format;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n use middle::lang_items::{FnOnceTraitLangItem, TyDescStructLangItem};\n@@ -682,6 +682,7 @@ pub struct ctxt<'tcx> {\n \n     pub sess: Session,\n     pub def_map: DefMap,\n+    pub partial_def_map: PartialDefMap,\n \n     pub named_region_map: resolve_lifetime::NamedRegionMap,\n \n@@ -2423,7 +2424,8 @@ impl<'tcx> CommonTypes<'tcx> {\n \n pub fn mk_ctxt<'tcx>(s: Session,\n                      arenas: &'tcx CtxtArenas<'tcx>,\n-                     dm: DefMap,\n+                     def_map: DefMap,\n+                     partial_def_map: PartialDefMap,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n                      freevars: RefCell<FreevarMap>,\n@@ -2445,7 +2447,8 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         item_variance_map: RefCell::new(DefIdMap()),\n         variance_computed: Cell::new(false),\n         sess: s,\n-        def_map: dm,\n+        def_map: def_map,\n+        partial_def_map: partial_def_map,\n         region_maps: region_maps,\n         node_types: RefCell::new(FnvHashMap()),\n         item_substs: RefCell::new(NodeMap()),"}, {"sha": "b5933ca11bafcd8b723762cdc79cf106cad4aebd", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -567,6 +567,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n \n     let resolve::CrateMap {\n         def_map,\n+        partial_def_map,\n         freevars,\n         export_map,\n         trait_map,\n@@ -607,6 +608,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     let ty_cx = ty::mk_ctxt(sess,\n                             arenas,\n                             def_map,\n+                            partial_def_map,\n                             named_region_map,\n                             ast_map,\n                             freevars,"}, {"sha": "fefb3c5fe7dc4570c1ba0a3fcb455837e3d074f0", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -940,7 +940,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                   is_public,\n                                                   DUMMY_SP)\n           }\n-          DefTy(..) | DefAssociatedTy(..) | DefAssociatedPath(..) => {\n+          DefTy(..) | DefAssociatedTy(..) => {\n               debug!(\"(building reduced graph for external \\\n                       crate) building type {}\", final_ident);\n "}, {"sha": "4a57dd0912e6a99c9cb173f0cc604ac8f9362ccc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 68, "deletions": 82, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -935,6 +935,7 @@ struct Resolver<'a, 'tcx:'a> {\n     primitive_type_table: PrimitiveTypeTable,\n \n     def_map: DefMap,\n+    partial_def_map: PartialDefMap,\n     freevars: RefCell<FreevarMap>,\n     freevars_seen: RefCell<NodeMap<NodeSet>>,\n     export_map: ExportMap,\n@@ -1008,6 +1009,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             primitive_type_table: PrimitiveTypeTable::new(),\n \n             def_map: RefCell::new(NodeMap()),\n+            partial_def_map: RefCell::new(NodeMap()),\n             freevars: RefCell::new(NodeMap()),\n             freevars_seen: RefCell::new(NodeMap()),\n             export_map: NodeMap(),\n@@ -2988,13 +2990,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                id: NodeId,\n                                trait_path: &Path,\n                                path_depth: usize)\n-                               -> Result<(Def, LastPrivate), ()> {\n+                               -> Result<(Def, LastPrivate, usize), ()> {\n         match self.resolve_path(id, trait_path, path_depth, TypeNS, true) {\n-            Some(def @ (DefTrait(_), _)) => {\n+            Some(def @ (DefTrait(_), _, _)) => {\n                 debug!(\"(resolving trait) found trait def: {:?}\", def);\n                 Ok(def)\n             }\n-            Some((def, _)) => {\n+            Some((def, _, _)) => {\n                 self.resolve_error(trait_path.span,\n                     &format!(\"`{}` is not a trait\",\n                              self.path_names_to_string(trait_path, path_depth)));\n@@ -3025,8 +3027,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 &ast::WherePredicate::RegionPredicate(_) => {}\n                 &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n                     match self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS, true) {\n-                        Some((def @ DefTyParam(..), last_private)) => {\n-                            self.record_def(eq_pred.id, (def, last_private));\n+                        Some(def @ (DefTyParam(..), _, _)) => {\n+                            self.record_def(eq_pred.id, def);\n                         }\n                         _ => {\n                             self.resolve_error(eq_pred.path.span,\n@@ -3121,30 +3123,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 });\n             });\n         });\n-\n-        // Check that the current type is indeed a type, if we have an anonymous impl\n-        if opt_trait_reference.is_none() {\n-            match self_type.node {\n-                // TyPath is the only thing that we handled in `build_reduced_graph_for_item`,\n-                // where we created a module with the name of the type in order to implement\n-                // an anonymous trait. In the case that the path does not resolve to an actual\n-                // type, the result will be that the type name resolves to a module but not\n-                // a type (shadowing any imported modules or types with this name), leading\n-                // to weird user-visible bugs. So we ward this off here. See #15060.\n-                TyPath(ref path) => {\n-                    match self.def_map.borrow().get(&self_type.id) {\n-                        // FIXME: should we catch other options and give more precise errors?\n-                        Some(&DefMod(_)) => {\n-                            self.resolve_error(path.span, \"inherent implementations are not \\\n-                                                           allowed for types not defined in \\\n-                                                           the current module\");\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-                _ => { }\n-            }\n-        }\n     }\n \n     fn check_trait_item(&self, name: Name, span: Span) {\n@@ -3304,14 +3282,31 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // on whether the path has multiple elements in it or not.\n \n             TyPath(ref path) | TyQPath(ast::QPath { ref path, .. }) => {\n-                if let TyQPath(_) = ty.node {\n+                let max_assoc_types = if let TyQPath(_) = ty.node {\n                     // Make sure the trait is valid.\n-                    self.resolve_trait_reference(ty.id, path, 1);\n+                    let _ = self.resolve_trait_reference(ty.id, path, 1);\n+                    1\n+                } else {\n+                    path.segments.len()\n+                };\n+\n+                let mut result = None;\n+                for depth in 0..max_assoc_types {\n+                    self.with_no_errors(|this| {\n+                        result = this.resolve_path(ty.id, path, depth, TypeNS, true);\n+                    });\n+                    if result.is_some() {\n+                        break;\n+                    }\n+                }\n+                if let Some((DefMod(_), _, _)) = result {\n+                    // A module is not a valid type.\n+                    result = None;\n                 }\n \n                 // This is a path in the type namespace. Walk through scopes\n                 // looking for it.\n-                match self.resolve_path(ty.id, path, 0, TypeNS, true) {\n+                match result {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `{}` \\\n@@ -3321,6 +3316,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.record_def(ty.id, def);\n                     }\n                     None => {\n+                        // Keep reporting some errors even if they're ignored above.\n+                        self.resolve_path(ty.id, path, 0, TypeNS, true);\n+\n                         let kind = match ty.node {\n                             TyQPath(_) => \"associated type\",\n                             _ => \"type name\"\n@@ -3371,7 +3369,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 pattern,\n                                 binding_mode,\n                                 \"an enum variant\");\n-                            self.record_def(pattern.id, (def, lp));\n+                            self.record_def(pattern.id, (def, lp, 0));\n                         }\n                         FoundStructOrEnumVariant(..) => {\n                             self.resolve_error(\n@@ -3390,7 +3388,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 pattern,\n                                 binding_mode,\n                                 \"a constant\");\n-                            self.record_def(pattern.id, (def, lp));\n+                            self.record_def(pattern.id, (def, lp, 0));\n                         }\n                         FoundConst(..) => {\n                             self.resolve_error(pattern.span,\n@@ -3407,7 +3405,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // will be able to distinguish variants from\n                             // locals in patterns.\n \n-                            self.record_def(pattern.id, (def, LastMod(AllPublic)));\n+                            self.record_def(pattern.id, (def, LastMod(AllPublic), 0));\n \n                             // Add the binding to the local ribs, if it\n                             // doesn't already exist in the bindings list. (We\n@@ -3451,12 +3449,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 PatEnum(ref path, _) => {\n                     // This must be an enum variant, struct or const.\n                     match self.resolve_path(pat_id, path, 0, ValueNS, false) {\n-                        Some(def @ (DefVariant(..), _)) |\n-                        Some(def @ (DefStruct(..), _))  |\n-                        Some(def @ (DefConst(..), _)) => {\n+                        Some(def @ (DefVariant(..), _, _)) |\n+                        Some(def @ (DefStruct(..), _, _))  |\n+                        Some(def @ (DefConst(..), _, _)) => {\n                             self.record_def(pattern.id, def);\n                         }\n-                        Some((DefStatic(..), _)) => {\n+                        Some((DefStatic(..), _, _)) => {\n                             self.resolve_error(path.span,\n                                                \"static variables cannot be \\\n                                                 referenced in a pattern, \\\n@@ -3573,40 +3571,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     path: &Path,\n                     path_depth: usize,\n                     namespace: Namespace,\n-                    check_ribs: bool) -> Option<(Def, LastPrivate)> {\n+                    check_ribs: bool) -> Option<(Def, LastPrivate, usize)> {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len()-path_depth];\n \n-        // A special case for sugared associated type paths `T::A` where `T` is\n-        // a type parameter and `A` is an associated type on some bound of `T`.\n-        if namespace == TypeNS && segments.len() == 2 {\n-            match self.resolve_identifier(segments[0].identifier,\n-                                          TypeNS,\n-                                          true,\n-                                          span) {\n-                Some((def, last_private)) => {\n-                    match def {\n-                        DefTyParam(_, _, did, _) => {\n-                            let def = DefAssociatedPath(TyParamProvenance::FromParam(did),\n-                                                        segments.last()\n-                                                            .unwrap().identifier);\n-                            return Some((def, last_private));\n-                        }\n-                        DefSelfTy(nid) => {\n-                            let def = DefAssociatedPath(TyParamProvenance::FromSelf(local_def(nid)),\n-                                                        segments.last()\n-                                                            .unwrap().identifier);\n-                            return Some((def, last_private));\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-\n         if path.global {\n-            return self.resolve_crate_relative_path(span, segments, namespace);\n+            let def = self.resolve_crate_relative_path(span, segments, namespace);\n+            return def.map(|(def, lp)| (def, lp, path_depth));\n         }\n \n         // Try to find a path to an item in a module.\n@@ -3628,10 +3599,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 _ => ()\n             }\n \n-            return def;\n+            def.map(|(def, lp)| (def, lp, path_depth))\n+        } else {\n+            unqualified_def.map(|(def, lp)| (def, lp, path_depth))\n         }\n-\n-        unqualified_def\n     }\n \n     // resolve a single identifier (used as a varref)\n@@ -4105,14 +4076,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ExprPath(ref path) | ExprQPath(ast::QPath { ref path, .. }) => {\n                 if let ExprQPath(_) = expr.node {\n                     // Make sure the trait is valid.\n-                    self.resolve_trait_reference(expr.id, path, 1);\n+                    let _ = self.resolve_trait_reference(expr.id, path, 1);\n                 }\n \n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n                 match self.resolve_path(expr.id, path, 0, ValueNS, true) {\n                     // Check if struct variant\n-                    Some((DefVariant(_, _, true), _)) => {\n+                    Some((DefVariant(_, _, true), _, _)) => {\n                         let path_name = self.path_names_to_string(path, 0);\n                         self.resolve_error(expr.span,\n                                 &format!(\"`{}` is a struct variant name, but \\\n@@ -4140,7 +4111,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let path_name = self.path_names_to_string(path, 0);\n                         match self.with_no_errors(|this|\n                             this.resolve_path(expr.id, path, 0, TypeNS, false)) {\n-                            Some((DefTy(struct_id, _), _))\n+                            Some((DefTy(struct_id, _), _, 0))\n                               if self.structs.contains_key(&struct_id) => {\n                                 self.resolve_error(expr.span,\n                                         &format!(\"`{}` is a structure name, but \\\n@@ -4252,7 +4223,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n-                        self.record_def(expr.id, (def, LastMod(AllPublic)))\n+                        self.record_def(expr.id, (def, LastMod(AllPublic), 0))\n                     }\n                     Some(_) => {\n                         self.session.span_bug(expr.span,\n@@ -4372,18 +4343,31 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn record_def(&mut self,\n                   node_id: NodeId,\n-                  (def, lp): (Def, LastPrivate)) {\n+                  (def, lp, depth): (Def, LastPrivate, usize)) {\n         debug!(\"(recording def) recording {:?} for {}, last private {:?}\",\n                 def, node_id, lp);\n         assert!(match lp {LastImport{..} => false, _ => true},\n                 \"Import should only be used for `use` directives\");\n         self.last_private.insert(node_id, lp);\n \n-        if let Some(prev_def) = self.def_map.borrow_mut().insert(node_id, def) {\n-            let span = self.ast_map.opt_span(node_id).unwrap_or(codemap::DUMMY_SP);\n-            self.session.span_bug(span, &format!(\"path resolved multiple times \\\n-                                                  ({:?} before, {:?} now)\",\n-                                                  prev_def, def));\n+        if depth == 0 {\n+            if let Some(prev_def) = self.def_map.borrow_mut().insert(node_id, def) {\n+                let span = self.ast_map.opt_span(node_id).unwrap_or(codemap::DUMMY_SP);\n+                self.session.span_bug(span, &format!(\"path resolved multiple times \\\n+                                                      ({:?} before, {:?} now)\",\n+                                                     prev_def, def));\n+            }\n+        } else {\n+            let def = PartialDef {\n+                base_type: def,\n+                extra_associated_types: (depth - 1) as u32\n+            };\n+            if let Some(prev_def) = self.partial_def_map.borrow_mut().insert(node_id, def) {\n+                let span = self.ast_map.opt_span(node_id).unwrap_or(codemap::DUMMY_SP);\n+                self.session.span_bug(span, &format!(\"path resolved multiple times \\\n+                                                      ({:?} before, {:?} now)\",\n+                                                     prev_def, def));\n+            }\n         }\n     }\n \n@@ -4474,6 +4458,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n pub struct CrateMap {\n     pub def_map: DefMap,\n+    pub partial_def_map: PartialDefMap,\n     pub freevars: RefCell<FreevarMap>,\n     pub export_map: ExportMap,\n     pub trait_map: TraitMap,\n@@ -4513,6 +4498,7 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n \n     CrateMap {\n         def_map: resolver.def_map,\n+        partial_def_map: resolver.partial_def_map,\n         freevars: resolver.freevars,\n         export_map: resolver.export_map,\n         trait_map: resolver.trait_map,"}, {"sha": "0ba7bd84603cfe484ff3bef6ef0c934ee17b2de7", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -238,7 +238,6 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefStruct(_) => Some(recorder::StructRef),\n             def::DefTy(..) |\n             def::DefAssociatedTy(..) |\n-            def::DefAssociatedPath(..) |\n             def::DefTrait(_) => Some(recorder::TypeRef),\n             def::DefStatic(_, _) |\n             def::DefConst(_) |"}, {"sha": "196686a70d1a19cd11b48eb6f2ec3cca1faeaa65", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -210,7 +210,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             def::DefMod(..) | def::DefForeignMod(..) | def::DefTrait(..) |\n             def::DefTy(..) | def::DefPrimTy(..) | def::DefAssociatedTy(..) |\n             def::DefUse(..) | def::DefRegion(..) | def::DefLabel(..) |\n-            def::DefTyParam(..) | def::DefSelfTy(..) | def::DefAssociatedPath(..) => {\n+            def::DefTyParam(..) | def::DefSelfTy(..) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     &format!(\"cannot translate def {:?} \\"}, {"sha": "bc0986eff1f28521093a35c534bf4ad6beee6132", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 247, "deletions": 234, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -48,7 +48,7 @@\n //! case but `&a` in the second.  Basically, defaults that appear inside\n //! an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \n-use middle::astconv_util::{ast_ty_to_prim_ty, check_path_args, NO_TPS, NO_REGIONS};\n+use middle::astconv_util::{prim_ty_to_ty, check_path_args, NO_TPS, NO_REGIONS};\n use middle::const_eval;\n use middle::def;\n use middle::resolve_lifetime as rl;\n@@ -57,13 +57,13 @@ use middle::traits;\n use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n-use TypeAndSubsts;\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::DefIdMap;\n use util::ppaux::{self, Repr, UserString};\n \n-use std::rc::Rc;\n use std::iter::{repeat, AdditiveIterator};\n+use std::rc::Rc;\n+use std::slice;\n use syntax::{abi, ast, ast_util};\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -245,8 +245,9 @@ pub fn opt_ast_region_to_region<'tcx>(\n pub fn ast_path_substs_for_ty<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n+    span: Span,\n     decl_generics: &ty::Generics<'tcx>,\n-    path: &ast::Path)\n+    item_segment: &ast::PathSegment)\n     -> Substs<'tcx>\n {\n     let tcx = this.tcx();\n@@ -262,12 +263,12 @@ pub fn ast_path_substs_for_ty<'tcx>(\n     assert!(decl_generics.regions.all(|d| d.space == TypeSpace));\n     assert!(decl_generics.types.all(|d| d.space != FnSpace));\n \n-    let (regions, types, assoc_bindings) = match path.segments.last().unwrap().parameters {\n+    let (regions, types, assoc_bindings) = match item_segment.parameters {\n         ast::AngleBracketedParameters(ref data) => {\n             convert_angle_bracketed_parameters(this, rscope, path.span, decl_generics, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n-            span_err!(tcx.sess, path.span, E0214,\n+            span_err!(tcx.sess, span, E0214,\n                 \"parenthesized parameters may only be used with a trait\");\n             convert_parenthesized_parameters(this, rscope, path.span, decl_generics, data)\n         }\n@@ -276,7 +277,7 @@ pub fn ast_path_substs_for_ty<'tcx>(\n     prohibit_projections(this.tcx(), &assoc_bindings);\n \n     create_substs_for_ast_path(this,\n-                               path.span,\n+                               span,\n                                decl_generics,\n                                None,\n                                types,\n@@ -625,8 +626,9 @@ pub fn instantiate_trait_ref<'tcx>(\n fn object_path_to_poly_trait_ref<'a,'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n+    span: Span,\n     trait_def_id: ast::DefId,\n-    path: &ast::Path,\n+    trait_segment: &ast::PathSegment,\n     mut projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n     -> ty::PolyTraitRef<'tcx>\n {\n@@ -637,10 +639,10 @@ fn object_path_to_poly_trait_ref<'a,'tcx>(\n     let mut tmp = Vec::new();\n     let trait_ref = ty::Binder(ast_path_to_trait_ref(this,\n                                                      &shifted_rscope,\n-                                                     path.span,\n+                                                     span,\n                                                      trait_def_id,\n                                                      None,\n-                                                     path.segments.last().unwrap(),\n+                                                     trait_segment,\n                                                      Some(&mut tmp)));\n     projections.extend(tmp.into_iter().map(ty::Binder));\n     trait_ref\n@@ -824,78 +826,28 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n     })\n }\n \n-pub fn ast_path_to_ty<'tcx>(\n+fn ast_path_to_ty<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n+    span: Span,\n     did: ast::DefId,\n-    path: &ast::Path)\n-    -> TypeAndSubsts<'tcx>\n+    item_segment: &ast::PathSegment)\n+    -> Ty<'tcx>\n {\n-    let tcx = this.tcx();\n     let ty::TypeScheme {\n         generics,\n         ty: decl_ty\n     } = this.get_item_type_scheme(did);\n \n-    let substs = ast_path_substs_for_ty(this,\n-                                        rscope,\n-                                        &generics,\n-                                        path);\n-    let ty = decl_ty.subst(tcx, &substs);\n-    TypeAndSubsts { substs: substs, ty: ty }\n-}\n+    let substs = ast_path_substs_for_ty(this, rscope, span, &generics, item_segment);\n \n-/// Converts the given AST type to a built-in type. A \"built-in type\" is, at\n-/// present, either a core numeric type, a string, or `Box`.\n-pub fn ast_ty_to_builtin_ty<'tcx>(\n-        this: &AstConv<'tcx>,\n-        rscope: &RegionScope,\n-        ast_ty: &ast::Ty)\n-        -> Option<Ty<'tcx>> {\n-    match ast_ty_to_prim_ty(this.tcx(), ast_ty) {\n-        Some(typ) => return Some(typ),\n-        None => {}\n+    // FIXME(#12938): This is a hack until we have full support for DST.\n+    if Some(did) == this.tcx().lang_items.owned_box() {\n+        assert_eq!(substs.types.len(TypeSpace), 1);\n+        return ty::mk_uniq(this.tcx(), *substs.types.get(TypeSpace, 0));\n     }\n \n-    match ast_ty.node {\n-        ast::TyPath(ref path) => {\n-            let a_def = match this.tcx().def_map.borrow().get(&ast_ty.id) {\n-                None => {\n-                    this.tcx()\n-                        .sess\n-                        .span_bug(ast_ty.span,\n-                                  &format!(\"unbound path {}\",\n-                                          path.repr(this.tcx())))\n-                }\n-                Some(&d) => d\n-            };\n-\n-            // FIXME(#12938): This is a hack until we have full support for\n-            // DST.\n-            match a_def {\n-                def::DefTy(did, _) |\n-                def::DefStruct(did) if Some(did) == this.tcx().lang_items.owned_box() => {\n-                    let ty = ast_path_to_ty(this, rscope, did, path).ty;\n-                    match ty.sty {\n-                        ty::ty_struct(struct_def_id, ref substs) => {\n-                            assert_eq!(struct_def_id, did);\n-                            assert_eq!(substs.types.len(TypeSpace), 1);\n-                            let referent_ty = *substs.types.get(TypeSpace, 0);\n-                            Some(ty::mk_uniq(this.tcx(), referent_ty))\n-                        }\n-                        _ => {\n-                            this.tcx().sess.span_bug(\n-                                path.span,\n-                                &format!(\"converting `Box` to `{}`\",\n-                                        ty.repr(this.tcx())));\n-                        }\n-                    }\n-                }\n-                _ => None\n-            }\n-        }\n-        _ => None\n-    }\n+    decl_ty.subst(this.tcx(), &substs)\n }\n \n type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>);\n@@ -919,13 +871,15 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n \n     match ty.node {\n         ast::TyPath(ref path) => {\n-            match this.tcx().def_map.borrow().get(&ty.id) {\n-                Some(&def::DefTrait(trait_def_id)) => {\n+            let def = this.tcx().def_map.borrow().get(&ty.id).cloned();\n+            match def {\n+                Some(def::DefTrait(trait_def_id)) => {\n                     let mut projection_bounds = Vec::new();\n                     let trait_ref = object_path_to_poly_trait_ref(this,\n                                                                   rscope,\n+                                                                  path.span,\n                                                                   trait_def_id,\n-                                                                  path,\n+                                                                  path.segments.last().unwrap(),\n                                                                   &mut projection_bounds);\n                     Ok((trait_ref, projection_bounds))\n                 }\n@@ -989,21 +943,35 @@ fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx>,\n }\n \n fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n-                                   ast_ty: &ast::Ty,\n-                                   provenance: def::TyParamProvenance,\n-                                   assoc_name: ast::Name)\n-                                   -> Ty<'tcx>\n+                                   span: Span,\n+                                   ty: Ty<'tcx>,\n+                                   ty_path_def: def::Def,\n+                                   item_segment: &ast::PathSegment)\n+                                   -> (Ty<'tcx>, def::Def)\n {\n     let tcx = this.tcx();\n-    let ty_param_def_id = provenance.def_id();\n+    check_path_args(tcx, span, slice::ref_slice(item_segment),\n+                    NO_TPS | NO_REGIONS);\n+    let assoc_name = item_segment.identifier.name;\n+\n+    let ty_param_node_id = if let ty::ty_param(_) = ty.sty {\n+        ty_path_def.local_node_id()\n+    } else {\n+        span_err!(tcx.sess, span, E0223,\n+                \"ambiguous associated type; specify the type using the syntax \\\n+                `<{} as Trait>::{}`\",\n+                ty.user_string(tcx), token::get_name(assoc_name));\n+        return (tcx.types.err, ty_path_def);\n+    };\n \n     let mut suitable_bounds: Vec<_>;\n     let ty_param_name: ast::Name;\n     { // contain scope of refcell:\n         let ty_param_defs = tcx.ty_param_defs.borrow();\n-        let ty_param_def = &ty_param_defs[ty_param_def_id.node];\n+        let ty_param_def = &ty_param_defs[ty_param_node_id];\n         ty_param_name = ty_param_def.name;\n \n+\n         // FIXME(#20300) -- search where clauses, not bounds\n         suitable_bounds =\n             traits::transitive_bounds(tcx, &ty_param_def.bounds.trait_bounds)\n@@ -1012,29 +980,54 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     }\n \n     if suitable_bounds.len() == 0 {\n-        span_err!(tcx.sess, ast_ty.span, E0220,\n+        span_err!(tcx.sess, span, E0220,\n                           \"associated type `{}` not found for type parameter `{}`\",\n                                   token::get_name(assoc_name),\n                                   token::get_name(ty_param_name));\n-        return this.tcx().types.err;\n+        return (this.tcx().types.err, ty_path_def);\n     }\n \n     if suitable_bounds.len() > 1 {\n-        span_err!(tcx.sess, ast_ty.span, E0221,\n+        span_err!(tcx.sess, span, E0221,\n                           \"ambiguous associated type `{}` in bounds of `{}`\",\n                                   token::get_name(assoc_name),\n                                   token::get_name(ty_param_name));\n \n         for suitable_bound in &suitable_bounds {\n-            span_note!(this.tcx().sess, ast_ty.span,\n+            span_note!(this.tcx().sess, span,\n                        \"associated type `{}` could derive from `{}`\",\n                        token::get_name(ty_param_name),\n                        suitable_bound.user_string(this.tcx()));\n         }\n     }\n \n     let suitable_bound = suitable_bounds.pop().unwrap().clone();\n-    return this.projected_ty_from_poly_trait_ref(ast_ty.span, suitable_bound, assoc_name);\n+    let trait_did = suitable_bound.0.def_id;\n+\n+    let ty = this.projected_ty_from_poly_trait_ref(span, suitable_bound, assoc_name);\n+\n+    let item_did = if trait_did.krate == ast::LOCAL_CRATE {\n+        // `ty::trait_items` used below requires information generated\n+        // by type collection, which may be in progress at this point.\n+        match this.tcx().map.expect_item(trait_did.node).node {\n+            ast::ItemTrait(_, _, _, ref trait_items) => {\n+                trait_items.iter().filter_map(|i| {\n+                    if let ast::TypeTraitItem(ref assoc) = *i {\n+                        if assoc.ty_param.ident.name == assoc_name {\n+                            return Some(ast_util::local_def(assoc.ty_param.id));\n+                        }\n+                    }\n+                    None\n+                }).next().expect(\"missing associated type\")\n+            }\n+            _ => unreachable!()\n+        }\n+    } else {\n+        let trait_items = ty::trait_items(this.tcx(), trait_did);\n+        let item = trait_items.iter().find(|i| i.name() == assoc_name);\n+        item.expect(\"missing associated type\").def_id()\n+    };\n+    (ty, def::DefAssociatedTy(trait_did, item_did))\n }\n \n fn trait_defines_associated_type_named(this: &AstConv,\n@@ -1058,6 +1051,9 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n {\n     let tcx = this.tcx();\n \n+    check_path_args(tcx, span, slice::ref_slice(item_segment),\n+                    NO_TPS | NO_REGIONS);\n+\n     let self_ty = if let Some(ty) = opt_self_ty {\n         ast_ty_to_ty(this, rscope, ty)\n     } else {\n@@ -1081,9 +1077,6 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(tcx));\n \n-    // `<T as Trait>::U<V>` shouldn't parse right now.\n-    assert!(item_segment.parameters.is_empty());\n-\n     this.projected_ty(span, trait_ref, item_segment.identifier.name)\n }\n \n@@ -1146,164 +1139,184 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n     ast_ty_to_ty_cache.insert(ast_ty.id, ty::atttce_unresolved);\n     drop(ast_ty_to_ty_cache);\n \n-    let typ = ast_ty_to_builtin_ty(this, rscope, ast_ty).unwrap_or_else(|| {\n-        match ast_ty.node {\n-            ast::TyVec(ref ty) => {\n-                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n-            }\n-            ast::TyObjectSum(ref ty, ref bounds) => {\n-                match ast_ty_to_trait_ref(this, rscope, &**ty, &bounds[..]) {\n-                    Ok((trait_ref, projection_bounds)) => {\n-                        trait_ref_to_object_type(this,\n-                                                 rscope,\n-                                                 ast_ty.span,\n-                                                 trait_ref,\n-                                                 projection_bounds,\n-                                                 &bounds[..])\n-                    }\n-                    Err(ErrorReported) => {\n-                        this.tcx().types.err\n-                    }\n+    let typ = match ast_ty.node {\n+        ast::TyVec(ref ty) => {\n+            ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n+        }\n+        ast::TyObjectSum(ref ty, ref bounds) => {\n+            match ast_ty_to_trait_ref(this, rscope, &**ty, bounds) {\n+                Ok((trait_ref, projection_bounds)) => {\n+                    trait_ref_to_object_type(this,\n+                                             rscope,\n+                                             ast_ty.span,\n+                                             trait_ref,\n+                                             projection_bounds,\n+                                             bounds)\n                 }\n-            }\n-            ast::TyPtr(ref mt) => {\n-                ty::mk_ptr(tcx, ty::mt {\n-                    ty: ast_ty_to_ty(this, rscope, &*mt.ty),\n-                    mutbl: mt.mutbl\n-                })\n-            }\n-            ast::TyRptr(ref region, ref mt) => {\n-                let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n-                debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n-                let rscope1 =\n-                    &ObjectLifetimeDefaultRscope::new(\n-                        rscope,\n-                        Some(ty::ObjectLifetimeDefault::Specific(r)));\n-                let t = ast_ty_to_ty(this, rscope1, &*mt.ty);\n-                ty::mk_rptr(tcx, tcx.mk_region(r), ty::mt {ty: t, mutbl: mt.mutbl})\n-            }\n-            ast::TyTup(ref fields) => {\n-                let flds = fields.iter()\n-                                 .map(|t| ast_ty_to_ty(this, rscope, &**t))\n-                                 .collect();\n-                ty::mk_tup(tcx, flds)\n-            }\n-            ast::TyParen(ref typ) => ast_ty_to_ty(this, rscope, &**typ),\n-            ast::TyBareFn(ref bf) => {\n-                if bf.decl.variadic && bf.abi != abi::C {\n-                    span_err!(tcx.sess, ast_ty.span, E0222,\n-                                      \"variadic function must have C calling convention\");\n+                Err(ErrorReported) => {\n+                    this.tcx().types.err\n                 }\n-                let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl);\n-                ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(bare_fn))\n             }\n-            ast::TyPolyTraitRef(ref bounds) => {\n-                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, &bounds[..])\n+        }\n+        ast::TyPtr(ref mt) => {\n+            ty::mk_ptr(tcx, ty::mt {\n+                ty: ast_ty_to_ty(this, rscope, &*mt.ty),\n+                mutbl: mt.mutbl\n+            })\n+        }\n+        ast::TyRptr(ref region, ref mt) => {\n+            let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n+            debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n+            let rscope1 =\n+                &ObjectLifetimeDefaultRscope::new(\n+                    rscope,\n+                    Some(ty::ObjectLifetimeDefault::Specific(r)));\n+            let t = ast_ty_to_ty(this, rscope1, &*mt.ty);\n+            ty::mk_rptr(tcx, tcx.mk_region(r), ty::mt {ty: t, mutbl: mt.mutbl})\n+        }\n+        ast::TyTup(ref fields) => {\n+            let flds = fields.iter()\n+                             .map(|t| ast_ty_to_ty(this, rscope, &**t))\n+                             .collect();\n+            ty::mk_tup(tcx, flds)\n+        }\n+        ast::TyParen(ref typ) => ast_ty_to_ty(this, rscope, &**typ),\n+        ast::TyBareFn(ref bf) => {\n+            if bf.decl.variadic && bf.abi != abi::C {\n+                span_err!(tcx.sess, ast_ty.span, E0222,\n+                          \"variadic function must have C calling convention\");\n             }\n-            ast::TyPath(ref path) | ast::TyQPath(ast::QPath { ref path, .. }) => {\n-                let a_def = match tcx.def_map.borrow().get(&ast_ty.id) {\n-                    None => {\n-                        tcx.sess\n-                           .span_bug(ast_ty.span,\n-                                     &format!(\"unbound path {}\",\n-                                             ast_ty.repr(tcx)))\n-                    }\n-                    Some(&d) => d\n-                };\n-                match a_def {\n-                    def::DefTrait(trait_def_id) => {\n-                        // N.B. this case overlaps somewhat with\n-                        // TyObjectSum, see that fn for details\n-                        let mut projection_bounds = Vec::new();\n-\n-                        let trait_ref = object_path_to_poly_trait_ref(this,\n-                                                                      rscope,\n-                                                                      trait_def_id,\n-                                                                      path,\n-                                                                      &mut projection_bounds);\n-\n-                        trait_ref_to_object_type(this, rscope, ast_ty.span,\n-                                                 trait_ref, projection_bounds, &[])\n-                    }\n-                    def::DefTy(did, _) | def::DefStruct(did) => {\n-                        ast_path_to_ty(this, rscope, did, path).ty\n-                    }\n-                    def::DefTyParam(space, index, _, name) => {\n-                        check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                        ty::mk_param(tcx, space, index, name)\n-                    }\n-                    def::DefSelfTy(_) => {\n-                        // n.b.: resolve guarantees that the this type only appears in a\n-                        // trait, which we rely upon in various places when creating\n-                        // substs\n-                        check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                        ty::mk_self_type(tcx)\n-                    }\n-                    def::DefMod(id) => {\n-                        span_fatal!(tcx.sess, ast_ty.span, E0247,\n-                            \"found module name used as a type: {}\",\n-                                    tcx.map.node_to_string(id.node));\n-                    }\n-                    def::DefPrimTy(_) => {\n-                        panic!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n-                    }\n-                    def::DefAssociatedTy(trait_did, _) => {\n-                        let opt_self_ty = if let ast::TyQPath(ref qpath) = ast_ty.node {\n-                            Some(&*qpath.self_type)\n-                        } else {\n-                            None\n-                        };\n-                        qpath_to_ty(this, rscope, ast_ty.span, opt_self_ty, trait_did,\n-                                    &path.segments[path.segments.len()-2],\n-                                    path.segments.last().unwrap())\n-                    }\n-                    def::DefAssociatedPath(provenance, assoc_ident) => {\n-                        associated_path_def_to_ty(this, ast_ty, provenance, assoc_ident.name)\n-                    }\n-                    _ => {\n-                        span_fatal!(tcx.sess, ast_ty.span, E0248,\n-                                            \"found value name used \\\n-                                                     as a type: {:?}\",\n-                                                    a_def);\n-                    }\n+            let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl);\n+            ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(bare_fn))\n+        }\n+        ast::TyPolyTraitRef(ref bounds) => {\n+            conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds)\n+        }\n+        ast::TyPath(ref path) | ast::TyQPath(ast::QPath { ref path, .. }) => {\n+            let result = if let Some(&d) = tcx.def_map.borrow().get(&ast_ty.id) {\n+                (d, 0)\n+            } else if let Some(d) = tcx.partial_def_map.borrow().get(&ast_ty.id) {\n+                (d.base_type, (d.extra_associated_types + 1) as usize)\n+            } else {\n+                tcx.sess.span_bug(ast_ty.span,\n+                                  &format!(\"unbound path {}\", ast_ty.repr(tcx)))\n+            };\n+            let (base_def, max_depth) = result;\n+            let span = ast_ty.span; // Could be more granular.\n+            let segments = &path.segments[..path.segments.len()-max_depth];\n+            let base_ty = match base_def {\n+                def::DefTrait(trait_def_id) => {\n+                    // N.B. this case overlaps somewhat with\n+                    // TyObjectSum, see that fn for details\n+                    let mut projection_bounds = Vec::new();\n+\n+                    let trait_ref = object_path_to_poly_trait_ref(this,\n+                                                                  rscope,\n+                                                                  span,\n+                                                                  trait_def_id,\n+                                                                  segments.last().unwrap(),\n+                                                                  &mut projection_bounds);\n+\n+                    check_path_args(tcx, span, segments.init(), NO_TPS | NO_REGIONS);\n+                    trait_ref_to_object_type(this, rscope, span, trait_ref,\n+                                             projection_bounds, &[])\n+                }\n+                def::DefTy(did, _) | def::DefStruct(did) => {\n+                    check_path_args(tcx, span, segments.init(), NO_TPS | NO_REGIONS);\n+                    ast_path_to_ty(this, rscope, span, did, segments.last().unwrap())\n                 }\n+                def::DefTyParam(space, index, _, name) => {\n+                    check_path_args(tcx, span, segments, NO_TPS | NO_REGIONS);\n+                    ty::mk_param(tcx, space, index, name)\n+                }\n+                def::DefSelfTy(_) => {\n+                    // n.b.: resolve guarantees that the this type only appears in a\n+                    // trait, which we rely upon in various places when creating\n+                    // substs\n+                    check_path_args(tcx, span, segments, NO_TPS | NO_REGIONS);\n+                    ty::mk_self_type(tcx)\n+                }\n+                def::DefAssociatedTy(trait_did, _) => {\n+                    let opt_self_ty = if let ast::TyQPath(ref qpath) = ast_ty.node {\n+                        Some(&*qpath.self_type)\n+                    } else {\n+                        None\n+                    };\n+                    check_path_args(tcx, span, &segments[..segments.len()-2],\n+                                    NO_TPS | NO_REGIONS);\n+                    qpath_to_ty(this, rscope, span, opt_self_ty, trait_did,\n+                                &segments[segments.len()-2],\n+                                segments.last().unwrap())\n+                }\n+                def::DefMod(id) => {\n+                    tcx.sess.span_bug(span,\n+                                      &format!(\"found module name used as a type: {}\",\n+                                               tcx.map.node_to_string(id.node)));\n+                }\n+                def::DefPrimTy(prim_ty) => {\n+                    prim_ty_to_ty(tcx, span, segments, prim_ty)\n+                }\n+                _ => {\n+                    span_fatal!(tcx.sess, span, E0248,\n+                                \"found value name used as a type: {:?}\", base_def);\n+                }\n+            };\n+\n+            // If any associated type segments remain, attempt to resolve them.\n+            let mut ty = base_ty;\n+            let mut def = base_def;\n+            for depth in (0..max_depth).rev() {\n+                if ty.sty == ty::ty_err {\n+                    break;\n+                }\n+                // This is pretty bad (it will fail except for T::A and Self::A).\n+                let segment = &path.segments[path.segments.len()-depth-1];\n+                let (a_ty, a_def) = associated_path_def_to_ty(this, span,\n+                                                              ty, def, segment);\n+                ty = a_ty;\n+                def = a_def;\n             }\n-            ast::TyFixedLengthVec(ref ty, ref e) => {\n-                match const_eval::eval_const_expr_partial(tcx, &**e, Some(tcx.types.uint)) {\n-                    Ok(ref r) => {\n-                        match *r {\n-                            const_eval::const_int(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n-                                           Some(i as uint)),\n-                            const_eval::const_uint(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n-                                           Some(i as uint)),\n-                            _ => {\n-                                span_fatal!(tcx.sess, ast_ty.span, E0249,\n-                                            \"expected constant expr for array length\");\n-                            }\n+\n+            if max_depth != 0 && ty.sty != ty::ty_err {\n+                // Write back the new resolution.\n+                tcx.def_map.borrow_mut().insert(ast_ty.id, def);\n+            }\n+\n+            ty\n+        }\n+        ast::TyFixedLengthVec(ref ty, ref e) => {\n+            match const_eval::eval_const_expr_partial(tcx, &**e, Some(tcx.types.uint)) {\n+                Ok(r) => {\n+                    match r {\n+                        const_eval::const_int(i) =>\n+                            ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n+                                        Some(i as uint)),\n+                        const_eval::const_uint(i) =>\n+                            ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n+                                        Some(i as uint)),\n+                        _ => {\n+                            span_fatal!(tcx.sess, ast_ty.span, E0249,\n+                                        \"expected constant expr for array length\");\n                         }\n                     }\n-                    Err(ref r) => {\n-                        span_fatal!(tcx.sess, ast_ty.span, E0250,\n-                            \"expected constant expr for array \\\n-                                     length: {}\",\n-                                    *r);\n-                    }\n                 }\n-            }\n-            ast::TyTypeof(ref _e) => {\n-                tcx.sess.span_bug(ast_ty.span, \"typeof is reserved but unimplemented\");\n-            }\n-            ast::TyInfer => {\n-                // TyInfer also appears as the type of arguments or return\n-                // values in a ExprClosure, or as\n-                // the type of local variables. Both of these cases are\n-                // handled specially and will not descend into this routine.\n-                this.ty_infer(ast_ty.span)\n+                Err(r) => {\n+                    span_fatal!(tcx.sess, ast_ty.span, E0250,\n+                                \"expected constant expr for array length: {}\", r);\n+                }\n             }\n         }\n-    });\n+        ast::TyTypeof(ref _e) => {\n+            tcx.sess.span_bug(ast_ty.span, \"typeof is reserved but unimplemented\");\n+        }\n+        ast::TyInfer => {\n+            // TyInfer also appears as the type of arguments or return\n+            // values in a ExprClosure, or as\n+            // the type of local variables. Both of these cases are\n+            // handled specially and will not descend into this routine.\n+            this.ty_infer(ast_ty.span)\n+        }\n+    };\n \n     tcx.ast_ty_to_ty_cache.borrow_mut().insert(ast_ty.id, ty::atttce_resolved(typ));\n     return typ;"}, {"sha": "f797d2b6fe7d704c928d598a3134c631bfadc23d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -1613,7 +1613,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                   generics.regions.get_slice(TypeSpace));\n             Substs::new_type(tps, rps)\n         } else {\n-            astconv::ast_path_substs_for_ty(self, self, &generics, path)\n+            astconv::ast_path_substs_for_ty(self, self,\n+                                            path.span,\n+                                            &generics,\n+                                            path.segments.last().unwrap())\n         };\n \n         let ty = self.instantiate_type_scheme(path.span, &substs, &decl_ty);\n@@ -4632,7 +4635,6 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefTrait(_) |\n         def::DefTy(..) |\n         def::DefAssociatedTy(..) |\n-        def::DefAssociatedPath(..) |\n         def::DefPrimTy(_) |\n         def::DefTyParam(..) |\n         def::DefMod(..) |\n@@ -4731,7 +4733,6 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefVariant(..) |\n         def::DefTy(..) |\n         def::DefAssociatedTy(..) |\n-        def::DefAssociatedPath(..) |\n         def::DefTrait(..) |\n         def::DefPrimTy(..) |\n         def::DefTyParam(..) => {"}, {"sha": "4ac901776099d0b0e4164e4d6296645ccbbd57b0", "filename": "src/test/compile-fail/issue-7607-1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Ftest%2Fcompile-fail%2Fissue-7607-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Ftest%2Fcompile-fail%2Fissue-7607-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7607-1.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-tidy-linelength\n-\n struct Foo {\n     x: isize\n }\n \n-impl Fo { //~ERROR inherent implementations are not allowed for types not defined in the current module\n+impl Fo { //~ ERROR use of undeclared type name `Fo`\n     fn foo() {}\n }\n "}, {"sha": "2ef0a75f77b5a9fb25b4b1784d24c98d24075861", "filename": "src/test/compile-fail/issue-8767.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Ftest%2Fcompile-fail%2Fissue-8767.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Ftest%2Fcompile-fail%2Fissue-8767.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8767.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n \n-impl B { //~ERROR inherent implementations are not allowed for types not defined in the current module\n+impl B { //~ ERROR use of undeclared type name `B`\n }\n \n fn main() {"}, {"sha": "969b6398fdb10d787ed9ef456c64273afc92ade3", "filename": "src/test/compile-fail/trait-impl-for-module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Ftest%2Fcompile-fail%2Ftrait-impl-for-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Ftest%2Fcompile-fail%2Ftrait-impl-for-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-for-module.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -14,7 +14,7 @@ mod a {\n trait A {\n }\n \n-impl A for a { //~ERROR found module name used as a type\n+impl A for a { //~ ERROR use of undeclared type name `a`\n }\n \n fn main() {"}, {"sha": "047e4e50c822374df5486d51ed1b13c7056a97ec", "filename": "src/test/compile-fail/trait-or-new-type-instead.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f49254b31353a80710af50e4f387740d154e60b/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f49254b31353a80710af50e4f387740d154e60b/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs?ref=0f49254b31353a80710af50e4f387740d154e60b", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-tidy-linelength\n-\n-impl<T> Option<T> { //~ERROR inherent implementations are not allowed for types not defined in the current module\n+// FIXME(eddyb/UFCS) This should have a nicer error, but that's not possible just yet.\n+impl<T> Option<T> { //~ ERROR use of undeclared type name `Option`\n     pub fn foo(&self) { }\n }\n "}]}