{"sha": "c82fe0efb4591f1a39e135152db77a43a6820c51", "node_id": "C_kwDOAAsO6NoAKGM4MmZlMGVmYjQ1OTFmMWEzOWUxMzUxNTJkYjc3YTQzYTY4MjBjNTE", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-05-09T18:02:24Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-12-06T20:05:22Z"}, "message": "Optimization: Merge parent and ancestor arrays\n\nAs the paper indicates, the unprocessed vertices in the DFS tree and processed\nvertices are disjoint, and we can use them in the same space, tracking only the index\nof the split.", "tree": {"sha": "f3a5093cb8b6f670a1738ec23b96ff65dc12e7a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3a5093cb8b6f670a1738ec23b96ff65dc12e7a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c82fe0efb4591f1a39e135152db77a43a6820c51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c82fe0efb4591f1a39e135152db77a43a6820c51", "html_url": "https://github.com/rust-lang/rust/commit/c82fe0efb4591f1a39e135152db77a43a6820c51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c82fe0efb4591f1a39e135152db77a43a6820c51/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8d7248093036b042f58cf80b321e3cc0cf857fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8d7248093036b042f58cf80b321e3cc0cf857fa", "html_url": "https://github.com/rust-lang/rust/commit/e8d7248093036b042f58cf80b321e3cc0cf857fa"}], "stats": {"total": 31, "additions": 21, "deletions": 10}, "files": [{"sha": "eb6e2b296cd9d9a12a6e4083208ebe48ed83a562", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c82fe0efb4591f1a39e135152db77a43a6820c51/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c82fe0efb4591f1a39e135152db77a43a6820c51/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=c82fe0efb4591f1a39e135152db77a43a6820c51", "patch": "@@ -65,16 +65,16 @@ fn dominators_given_rpo<G: ControlFlowGraph>(graph: G, rpo: &[G::Node]) -> Domin\n         stack.pop();\n     }\n \n-    let mut ancestor = IndexVec::from_elem_n(None, graph.num_nodes());\n     let mut idom = IndexVec::from_elem_n(graph.start_node(), graph.num_nodes());\n     let mut semi = IndexVec::from_fn_n(std::convert::identity, graph.num_nodes());\n     let mut label = semi.clone();\n     let mut bucket = IndexVec::from_elem_n(vec![], graph.num_nodes());\n+    let mut lastlinked = None;\n \n     for &w in pre_order_nodes[1..].iter().rev() {\n         semi[w] = w;\n         for v in graph.predecessors(w) {\n-            let x = eval(&pre_order_index, &mut ancestor, &semi, &mut label, v);\n+            let x = eval(&pre_order_index, &mut parent, lastlinked, &semi, &mut label, v);\n             semi[w] = if pre_order_index[semi[w]].unwrap() < pre_order_index[semi[x]].unwrap() {\n                 semi[w]\n             } else {\n@@ -91,6 +91,10 @@ fn dominators_given_rpo<G: ControlFlowGraph>(graph: G, rpo: &[G::Node]) -> Domin\n             let y = eval(&pre_order_index, &mut ancestor, &semi, &mut label, v);\n             idom[v] = if pre_order_index[semi[y]] < pre_order_index[z] { y } else { z };\n         }\n+\n+        // Optimization: We share the parent array between processed and not\n+        // processed elements; lastlinked represents the divider.\n+        lastlinked = Some(w);\n     }\n     for &w in pre_order_nodes.iter().skip(1) {\n         if idom[w] != semi[w] {\n@@ -111,39 +115,46 @@ fn dominators_given_rpo<G: ControlFlowGraph>(graph: G, rpo: &[G::Node]) -> Domin\n fn eval<N: Idx>(\n     pre_order_index: &IndexVec<N, Option<usize>>,\n     ancestor: &mut IndexVec<N, Option<N>>,\n+    lastlinked: Option<N>,\n     semi: &IndexVec<N, N>,\n     label: &mut IndexVec<N, N>,\n     node: N,\n ) -> N {\n-    if ancestor[node].is_some() {\n-        compress(pre_order_index, ancestor, semi, label, node);\n+    if is_processed(pre_order_index, node, lastlinked) {\n+        compress(pre_order_index, ancestor, lastlinked, semi, label, node);\n         label[node]\n     } else {\n         node\n     }\n }\n \n+fn is_processed<N: Idx>(\n+    pre_order_index: &IndexVec<N, Option<usize>>,\n+    v: N,\n+    lastlinked: Option<N>,\n+) -> bool {\n+    if let Some(ll) = lastlinked { pre_order_index[v] >= pre_order_index[ll] } else { false }\n+}\n+\n fn compress<N: Idx>(\n     pre_order_index: &IndexVec<N, Option<usize>>,\n     ancestor: &mut IndexVec<N, Option<N>>,\n+    lastlinked: Option<N>,\n     semi: &IndexVec<N, N>,\n     label: &mut IndexVec<N, N>,\n     v: N,\n ) {\n+    assert!(is_processed(pre_order_index, v, lastlinked));\n     let u = ancestor[v].unwrap();\n-    if ancestor[u].is_some() {\n-        compress(pre_order_index, ancestor, semi, label, u);\n+    if is_processed(pre_order_index, u, lastlinked) {\n+        compress(pre_order_index, ancestor, lastlinked, semi, label, u);\n         if pre_order_index[semi[label[u]]] < pre_order_index[semi[label[v]]] {\n             label[v] = label[u];\n         }\n         ancestor[v] = ancestor[u];\n     }\n }\n \n-fn link<N: Idx>(ancestor: &mut IndexVec<N, Option<N>>, parent: &IndexVec<N, Option<N>>, w: N) {\n-    ancestor[w] = Some(parent[w].unwrap());\n-}\n-\n #[derive(Clone, Debug)]\n pub struct Dominators<N: Idx> {\n     post_order_rank: IndexVec<N, usize>,"}]}