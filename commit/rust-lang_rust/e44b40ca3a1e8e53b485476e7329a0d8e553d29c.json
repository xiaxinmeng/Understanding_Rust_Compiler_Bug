{"sha": "e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NGI0MGNhM2ExZThlNTNiNDg1NDc2ZTczMjlhMGQ4ZTU1M2QyOWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-04T05:56:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-04T05:56:33Z"}, "message": "auto merge of #9712 : ben0x539/rust/obsolete-syntax, r=pcwalton\n\nMostly as per a short discussion on irc. (@cmr)\r\n\r\n    08:46 < cmr> so I'm thinking\r\n    Obsolete{Let,With,FieldTerminator,ClassTraits,ModeInFnType,MoveInit,BinaryMove,I\r\n    mplSyntax,MutOwnedPointer,MutVector,RecordType,RecordPattern,PostFnTySigil,Newty\r\n    pEnum,Mode,ImplicitSelf,LifetimeNotation,Purity,StaticMethod,ConstItem,FixedLeng\r\n    thVectorType}\r\n    08:46 < cmr> Those are the ones that are older than 0.6\r\n    08:46 < cmr> (at least!)\r\n\r\nThis PR removes these specific \"obsolete syntax\"/\"suggestion for change\" errors and just lets the parser run into regular parser errors for long-invalid syntax. I also removed `ObsoletePrivSection` which apparently dates further back than cmr or I could recall and `ObsoleteUnenforcedBound` which seemed unused. Also I removed `ObsoleteNewtypeEnum`.", "tree": {"sha": "5d5b6963feb25a22698da19153e00bd780ded170", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d5b6963feb25a22698da19153e00bd780ded170"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "html_url": "https://github.com/rust-lang/rust/commit/e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f32898a7b78888b73c59db6def2dfea8a7b1931", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f32898a7b78888b73c59db6def2dfea8a7b1931", "html_url": "https://github.com/rust-lang/rust/commit/3f32898a7b78888b73c59db6def2dfea8a7b1931"}, {"sha": "fa411500f969be6131aee62e3885460f90c150bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa411500f969be6131aee62e3885460f90c150bb", "html_url": "https://github.com/rust-lang/rust/commit/fa411500f969be6131aee62e3885460f90c150bb"}], "stats": {"total": 886, "additions": 358, "deletions": 528}, "files": [{"sha": "6de3b7aa0b099f05af83135250682db1f59d8e2f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -531,9 +531,7 @@ pub enum Expr_ {\n     ExprWhile(@Expr, Block),\n     // FIXME #6993: change to Option<Name>\n     ExprForLoop(@Pat, @Expr, Block, Option<Ident>),\n-    /* Conditionless loop (can be exited with break, cont, or ret)\n-       Same semantics as while(true) { body }, but typestate knows that the\n-       (implicit) condition is always true. */\n+    // Conditionless loop (can be exited with break, cont, or ret)\n     // FIXME #6993: change to Option<Name>\n     ExprLoop(Block, Option<Ident>),\n     ExprMatch(@Expr, ~[Arm]),"}, {"sha": "8c26793605c6117686f821ea8e5be8e6813e7931", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 166, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -17,11 +17,10 @@ Obsolete syntax that becomes too hard to parse can be\n removed.\n */\n \n-use ast::{Expr, ExprLit, lit_nil, Attribute};\n-use ast;\n+use ast::{Expr, ExprLit, lit_nil};\n use codemap::{Span, respan};\n use parse::parser::Parser;\n-use parse::token::{keywords, Token};\n+use parse::token::Token;\n use parse::token;\n \n use std::str;\n@@ -30,32 +29,9 @@ use std::to_bytes;\n /// The specific types of unsupported syntax\n #[deriving(Eq)]\n pub enum ObsoleteSyntax {\n-    ObsoleteLet,\n-    ObsoleteFieldTerminator,\n-    ObsoleteWith,\n-    ObsoleteClassTraits,\n-    ObsoletePrivSection,\n-    ObsoleteModeInFnType,\n-    ObsoleteMoveInit,\n-    ObsoleteBinaryMove,\n     ObsoleteSwap,\n     ObsoleteUnsafeBlock,\n-    ObsoleteUnenforcedBound,\n-    ObsoleteImplSyntax,\n-    ObsoleteMutOwnedPointer,\n-    ObsoleteMutVector,\n-    ObsoleteRecordType,\n-    ObsoleteRecordPattern,\n-    ObsoletePostFnTySigil,\n     ObsoleteBareFnType,\n-    ObsoleteNewtypeEnum,\n-    ObsoleteMode,\n-    ObsoleteImplicitSelf,\n-    ObsoleteLifetimeNotation,\n-    ObsoletePurity,\n-    ObsoleteStaticMethod,\n-    ObsoleteConstItem,\n-    ObsoleteFixedLengthVectorType,\n     ObsoleteNamedExternModule,\n     ObsoleteMultipleLocalDecl,\n     ObsoleteMutWithMultipleBindings,\n@@ -87,50 +63,12 @@ pub trait ParserObsoleteMethods {\n     fn token_is_obsolete_ident(&self, ident: &str, token: &Token) -> bool;\n     fn is_obsolete_ident(&self, ident: &str) -> bool;\n     fn eat_obsolete_ident(&self, ident: &str) -> bool;\n-    fn try_parse_obsolete_with(&self) -> bool;\n-    fn try_parse_obsolete_priv_section(&self, attrs: &[Attribute]) -> bool;\n }\n \n impl ParserObsoleteMethods for Parser {\n     /// Reports an obsolete syntax non-fatal error.\n     fn obsolete(&self, sp: Span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {\n-            ObsoleteLet => (\n-                \"`let` in field declaration\",\n-                \"declare fields as `field: Type`\"\n-            ),\n-            ObsoleteFieldTerminator => (\n-                \"field declaration terminated with semicolon\",\n-                \"fields are now separated by commas\"\n-            ),\n-            ObsoleteWith => (\n-                \"with\",\n-                \"record update is done with `..`, e.g. \\\n-                 `MyStruct { foo: bar, .. baz }`\"\n-            ),\n-            ObsoleteClassTraits => (\n-                \"class traits\",\n-                \"implemented traits are specified on the impl, as in \\\n-                 `impl foo : bar {`\"\n-            ),\n-            ObsoletePrivSection => (\n-                \"private section\",\n-                \"the `priv` keyword is applied to individual items, methods, \\\n-                 and fields\"\n-            ),\n-            ObsoleteModeInFnType => (\n-                \"mode without identifier in fn type\",\n-                \"to use a (deprecated) mode in a fn type, you should \\\n-                 give the argument an explicit name (like `&&v: int`)\"\n-            ),\n-            ObsoleteMoveInit => (\n-                \"initializer-by-move\",\n-                \"Write `let foo = move bar` instead\"\n-            ),\n-            ObsoleteBinaryMove => (\n-                \"binary move\",\n-                \"Write `foo = move bar` instead\"\n-            ),\n             ObsoleteSwap => (\n                 \"swap\",\n                 \"Use std::util::{swap, replace} instead\"\n@@ -139,79 +77,10 @@ impl ParserObsoleteMethods for Parser {\n                 \"non-standalone unsafe block\",\n                 \"use an inner `unsafe { ... }` block instead\"\n             ),\n-            ObsoleteUnenforcedBound => (\n-                \"unenforced type parameter bound\",\n-                \"use trait bounds on the functions that take the type as \\\n-                 arguments, not on the types themselves\"\n-            ),\n-            ObsoleteImplSyntax => (\n-                \"colon-separated impl syntax\",\n-                \"write `impl Trait for Type`\"\n-            ),\n-            ObsoleteMutOwnedPointer => (\n-                \"const or mutable owned pointer\",\n-                \"mutability inherits through `~` pointers; place the `~` box\n-                 in a mutable location, like a mutable local variable or an \\\n-                 `@mut` box\"\n-            ),\n-            ObsoleteMutVector => (\n-                \"const or mutable vector\",\n-                \"mutability inherits through `~` pointers; place the vector \\\n-                 in a mutable location, like a mutable local variable or an \\\n-                 `@mut` box\"\n-            ),\n-            ObsoleteRecordType => (\n-                \"structural record type\",\n-                \"use a structure instead\"\n-            ),\n-            ObsoleteRecordPattern => (\n-                \"structural record pattern\",\n-                \"use a structure instead\"\n-            ),\n-            ObsoletePostFnTySigil => (\n-                \"fn sigil in postfix position\",\n-                \"Rather than `fn@`, `fn~`, or `fn&`, \\\n-                 write `@fn`, `~fn`, and `&fn` respectively\"\n-            ),\n             ObsoleteBareFnType => (\n                 \"bare function type\",\n                 \"use `&fn` or `extern fn` instead\"\n             ),\n-            ObsoleteNewtypeEnum => (\n-                \"newtype enum\",\n-                \"instead of `enum Foo = int`, write `struct Foo(int)`\"\n-            ),\n-            ObsoleteMode => (\n-                \"obsolete argument mode\",\n-                \"replace `-` or `++` mode with `+`\"\n-            ),\n-            ObsoleteImplicitSelf => (\n-                \"implicit self\",\n-                \"use an explicit `self` declaration or declare the method as \\\n-                 static\"\n-            ),\n-            ObsoleteLifetimeNotation => (\n-                \"`/` lifetime notation\",\n-                \"instead of `&foo/bar`, write `&'foo bar`; instead of \\\n-                 `bar/&foo`, write `&bar<'foo>\"\n-            ),\n-            ObsoletePurity => (\n-                \"pure function\",\n-                \"remove `pure`\"\n-            ),\n-            ObsoleteStaticMethod => (\n-                \"`static` notation\",\n-                \"`static` is superfluous; remove it\"\n-            ),\n-            ObsoleteConstItem => (\n-                \"`const` item\",\n-                \"`const` items are now `static` items; replace `const` with \\\n-                 `static`\"\n-            ),\n-            ObsoleteFixedLengthVectorType => (\n-                \"fixed-length vector notation\",\n-                \"instead of `[T * N]`, write `[T, ..N]`\"\n-            ),\n             ObsoleteNamedExternModule => (\n                 \"named external module\",\n                 \"instead of `extern mod foo { ... }`, write `mod foo { \\\n@@ -297,37 +166,4 @@ impl ParserObsoleteMethods for Parser {\n             false\n         }\n     }\n-\n-    fn try_parse_obsolete_with(&self) -> bool {\n-        if *self.token == token::COMMA\n-            && self.look_ahead(1,\n-                               |t| self.token_is_obsolete_ident(\"with\", t)) {\n-            self.bump();\n-        }\n-        if self.eat_obsolete_ident(\"with\") {\n-            self.obsolete(*self.last_span, ObsoleteWith);\n-            self.parse_expr();\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn try_parse_obsolete_priv_section(&self, attrs: &[Attribute])\n-                                           -> bool {\n-        if self.is_keyword(keywords::Priv) &&\n-                self.look_ahead(1, |t| *t == token::LBRACE) {\n-            self.obsolete(*self.span, ObsoletePrivSection);\n-            self.eat_keyword(keywords::Priv);\n-            self.bump();\n-            while *self.token != token::RBRACE {\n-                self.parse_single_struct_field(ast::private, attrs.to_owned());\n-            }\n-            self.bump();\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n }"}, {"sha": "cad19543608ba1ab19d387c6ee3381e2cb3f3c5a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 56, "deletions": 283, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -402,7 +402,7 @@ impl Parser {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on Iterator.\n             let b = i.next().map_default(~\"\", |t| p.token_to_str(*t));\n-            i.fold(b, |b,a| b + \" \" + p.token_to_str(a))\n+            i.fold(b, |b,a| b + \"`, `\" + p.token_to_str(a))\n         }\n         if edible.contains(self.token) {\n             self.bump();\n@@ -548,7 +548,7 @@ impl Parser {\n     // signal an error if the given string is a strict keyword\n     pub fn check_strict_keywords(&self) {\n         if token::is_strict_keyword(self.token) {\n-            self.span_err(*self.last_span,\n+            self.span_err(*self.span,\n                           format!(\"found `{}` in ident position\", self.this_token_to_str()));\n         }\n     }\n@@ -762,8 +762,7 @@ impl Parser {\n \n     // is this one of the keywords that signals a closure type?\n     pub fn token_is_closure_keyword(&self, tok: &token::Token) -> bool {\n-        token::is_keyword(keywords::Pure, tok) ||\n-            token::is_keyword(keywords::Unsafe, tok) ||\n+        token::is_keyword(keywords::Unsafe, tok) ||\n             token::is_keyword(keywords::Once, tok) ||\n             token::is_keyword(keywords::Fn, tok)\n     }\n@@ -786,12 +785,12 @@ impl Parser {\n     pub fn parse_ty_bare_fn(&self) -> ty_ {\n         /*\n \n-        extern \"ABI\" [pure|unsafe] fn <'lt> (S) -> T\n-               ^~~~^ ^~~~~~~~~~~~^    ^~~~^ ^~^    ^\n-                 |     |                |    |     |\n-                 |     |                |    |   Return type\n-                 |     |                |  Argument types\n-                 |     |            Lifetimes\n+        extern \"ABI\" [unsafe] fn <'lt> (S) -> T\n+               ^~~~^ ^~~~~~~^    ^~~~^ ^~^    ^\n+                 |     |           |    |     |\n+                 |     |           |    |   Return type\n+                 |     |           |  Argument types\n+                 |     |       Lifetimes\n                  |     |\n                  |   Purity\n                 ABI\n@@ -818,14 +817,14 @@ impl Parser {\n                             -> ty_ {\n         /*\n \n-        (&|~|@) ['r] [pure|unsafe] [once] fn [:Bounds] <'lt> (S) -> T\n-        ^~~~~~^ ^~~^ ^~~~~~~~~~~~^ ^~~~~^    ^~~~~~~~^ ^~~~^ ^~^    ^\n-           |     |     |             |           |       |    |     |\n-           |     |     |             |           |       |    |   Return type\n-           |     |     |             |           |       |  Argument types\n-           |     |     |             |           |   Lifetimes\n-           |     |     |             |       Closure bounds\n-           |     |     |          Once-ness (a.k.a., affine)\n+        (&|~|@) ['r] [unsafe] [once] fn [:Bounds] <'lt> (S) -> T\n+        ^~~~~~^ ^~~^ ^~~~~~~^ ^~~~~^    ^~~~~~~~^ ^~~~^ ^~^    ^\n+           |     |     |        |           |       |    |     |\n+           |     |     |        |           |       |    |   Return type\n+           |     |     |        |           |       |  Argument types\n+           |     |     |        |           |   Lifetimes\n+           |     |     |        |       Closure bounds\n+           |     |     |     Once-ness (a.k.a., affine)\n            |     |   Purity\n            | Lifetime bound\n         Allocation type\n@@ -840,10 +839,6 @@ impl Parser {\n         self.expect_keyword(keywords::Fn);\n         let bounds = self.parse_optional_ty_param_bounds();\n \n-        if self.parse_fn_ty_sigil().is_some() {\n-            self.obsolete(*self.span, ObsoletePostFnTySigil);\n-        }\n-\n         let (decl, lifetimes) = self.parse_ty_fn_decl();\n \n         return ty_closure(@TyClosure {\n@@ -865,12 +860,8 @@ impl Parser {\n         }\n     }\n \n-    // looks like this should be called parse_unsafety\n     pub fn parse_unsafety(&self) -> purity {\n-        if self.eat_keyword(keywords::Pure) {\n-            self.obsolete(*self.last_span, ObsoletePurity);\n-            return impure_fn;\n-        } else if self.eat_keyword(keywords::Unsafe) {\n+        if self.eat_keyword(keywords::Unsafe) {\n             return unsafe_fn;\n         } else {\n             return impure_fn;\n@@ -1096,26 +1087,10 @@ impl Parser {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n             ty_ptr(self.parse_mt())\n-        } else if *self.token == token::LBRACE {\n-            // STRUCTURAL RECORD (remove?)\n-            let elems = self.parse_unspanned_seq(\n-                &token::LBRACE,\n-                &token::RBRACE,\n-                seq_sep_trailing_allowed(token::COMMA),\n-                |p| p.parse_ty_field()\n-            );\n-            if elems.len() == 0 {\n-                self.unexpected_last(&token::RBRACE);\n-            }\n-            self.obsolete(*self.last_span, ObsoleteRecordType);\n-            ty_nil\n         } else if *self.token == token::LBRACKET {\n             // VECTOR\n             self.expect(&token::LBRACKET);\n-            let mt = self.parse_mt();\n-            if mt.mutbl == MutMutable {    // `m_const` too after snapshot\n-                self.obsolete(*self.last_span, ObsoleteMutVector);\n-            }\n+            let mt = mt { ty: ~self.parse_ty(false), mutbl: MutImmutable };\n \n             // Parse the `, ..e` in `[ int, ..e ]`\n             // where `e` is a const expression\n@@ -1164,38 +1139,30 @@ impl Parser {\n     pub fn parse_box_or_uniq_pointee(&self,\n                                      sigil: ast::Sigil,\n                                      ctor: &fn(v: mt) -> ty_) -> ty_ {\n-        // @'foo fn() or @foo/fn() or @fn() are parsed directly as fn types:\n+        // ~'foo fn() or ~fn() are parsed directly as fn types:\n         match *self.token {\n             token::LIFETIME(*) => {\n                 let lifetime = self.parse_lifetime();\n                 return self.parse_ty_closure(sigil, Some(lifetime));\n             }\n \n             token::IDENT(*) => {\n-                if self.look_ahead(1, |t| *t == token::BINOP(token::SLASH)) &&\n-                        self.look_ahead(2, |t|\n-                                        self.token_is_closure_keyword(t)) {\n-                    let lifetime = self.parse_lifetime();\n-                    self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n-                    return self.parse_ty_closure(sigil, Some(lifetime));\n-                } else if self.token_is_closure_keyword(self.token) {\n+                if self.token_is_closure_keyword(self.token) {\n                     return self.parse_ty_closure(sigil, None);\n                 }\n             }\n             _ => {}\n         }\n \n-        // other things are parsed as @ + a type.  Note that constructs like\n+        // other things are parsed as @/~ + a type.  Note that constructs like\n         // @[] and @str will be resolved during typeck to slices and so forth,\n         // rather than boxed ptrs.  But the special casing of str/vec is not\n         // reflected in the AST type.\n-        let mt = self.parse_mt();\n-\n-        if mt.mutbl != MutImmutable && sigil == OwnedSigil {\n-            self.obsolete(*self.last_span, ObsoleteMutOwnedPointer);\n+        if sigil == OwnedSigil {\n+            ctor(mt { ty: ~self.parse_ty(false), mutbl: MutImmutable })\n+        } else {\n+            ctor(self.parse_mt())\n         }\n-\n-        ctor(mt)\n     }\n \n     pub fn parse_borrowed_pointee(&self) -> ty_ {\n@@ -1210,25 +1177,6 @@ impl Parser {\n         return ty_rptr(opt_lifetime, mt);\n     }\n \n-    // parse an optional, obsolete argument mode.\n-    pub fn parse_arg_mode(&self) {\n-        if self.eat(&token::BINOP(token::MINUS)) {\n-            self.obsolete(*self.last_span, ObsoleteMode);\n-        } else if self.eat(&token::ANDAND) {\n-            self.obsolete(*self.last_span, ObsoleteMode);\n-        } else if self.eat(&token::BINOP(token::PLUS)) {\n-            let lo = self.last_span.lo;\n-            if self.eat(&token::BINOP(token::PLUS)) {\n-                let hi = self.last_span.hi;\n-                self.obsolete(mk_sp(lo, hi), ObsoleteMode);\n-            } else {\n-                self.obsolete(*self.last_span, ObsoleteMode);\n-            }\n-        } else {\n-            // Ignore.\n-        }\n-    }\n-\n     pub fn is_named_argument(&self) -> bool {\n         let offset = match *self.token {\n             token::BINOP(token::AND) => 1,\n@@ -1262,7 +1210,6 @@ impl Parser {\n         let pat = if require_name || self.is_named_argument() {\n             debug2!(\"parse_arg_general parse_pat (require_name:{:?})\",\n                    require_name);\n-            self.parse_arg_mode();\n             let pat = self.parse_pat();\n \n             if is_mutbl && !ast_util::pat_is_ident(pat) {\n@@ -1295,7 +1242,6 @@ impl Parser {\n \n     // parse an argument in a lambda header e.g. |arg, arg|\n     pub fn parse_fn_block_arg(&self) -> arg {\n-        self.parse_arg_mode();\n         let is_mutbl = self.eat_keyword(keywords::Mut);\n         let pat = self.parse_pat();\n         let t = if self.eat(&token::COLON) {\n@@ -1316,10 +1262,7 @@ impl Parser {\n     }\n \n     pub fn maybe_parse_fixed_vstore(&self) -> Option<@ast::Expr> {\n-        if self.eat(&token::BINOP(token::STAR)) {\n-            self.obsolete(*self.last_span, ObsoleteFixedLengthVectorType);\n-            Some(self.parse_expr())\n-        } else if *self.token == token::COMMA &&\n+        if *self.token == token::COMMA &&\n                 self.look_ahead(1, |t| *t == token::DOTDOT) {\n             self.bump();\n             self.bump();\n@@ -1535,25 +1478,14 @@ impl Parser {\n             token::LIFETIME(*) => {\n                 Some(self.parse_lifetime())\n             }\n-\n-            // Also accept the (obsolete) syntax `foo/`\n-            token::IDENT(*) => {\n-                if self.look_ahead(1, |t| *t == token::BINOP(token::SLASH)) {\n-                    self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n-                    Some(self.parse_lifetime())\n-                } else {\n-                    None\n-                }\n-            }\n-\n             _ => {\n                 None\n             }\n         }\n     }\n \n     /// Parses a single lifetime\n-    // matches lifetime = ( LIFETIME ) | ( IDENT / )\n+    // matches lifetime = LIFETIME\n     pub fn parse_lifetime(&self) -> ast::Lifetime {\n         match *self.token {\n             token::LIFETIME(i) => {\n@@ -1565,20 +1497,6 @@ impl Parser {\n                     ident: i\n                 };\n             }\n-\n-            // Also accept the (obsolete) syntax `foo/`\n-            token::IDENT(i, _) => {\n-                let span = self.span;\n-                self.bump();\n-                self.expect(&token::BINOP(token::SLASH));\n-                self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n-                return ast::Lifetime {\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: *span,\n-                    ident: i\n-                };\n-            }\n-\n             _ => {\n                 self.fatal(format!(\"Expected a lifetime name\"));\n             }\n@@ -1805,10 +1723,7 @@ impl Parser {\n             return self.parse_block_expr(lo, UnsafeBlock(ast::UserProvided));\n         } else if *self.token == token::LBRACKET {\n             self.bump();\n-            let mutbl = self.parse_mutability();\n-            if mutbl == MutMutable {\n-                self.obsolete(*self.last_span, ObsoleteMutVector);\n-            }\n+            let mutbl = MutImmutable;\n \n             if *self.token == token::RBRACKET {\n                 // Empty vector.\n@@ -1897,10 +1812,6 @@ impl Parser {\n \n                     fields.push(self.parse_field());\n                     while *self.token != token::RBRACE {\n-                        if self.try_parse_obsolete_with() {\n-                            break;\n-                        }\n-\n                         self.commit_expr(fields.last().expr, &[token::COMMA], &[token::RBRACE]);\n \n                         if self.eat(&token::DOTDOT) {\n@@ -2277,10 +2188,6 @@ impl Parser {\n           }\n           token::TILDE => {\n             self.bump();\n-            let m = self.parse_mutability();\n-            if m != MutImmutable {\n-                self.obsolete(*self.last_span, ObsoleteMutOwnedPointer);\n-            }\n \n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n@@ -2379,15 +2286,6 @@ impl Parser {\n               self.mk_expr(lo, rhs.span.hi,\n                            self.mk_assign_op(aop, lhs, rhs))\n           }\n-          token::LARROW => {\n-              self.obsolete(*self.span, ObsoleteBinaryMove);\n-              // Bogus value (but it's an error)\n-              self.bump(); // <-\n-              self.bump(); // rhs\n-              self.bump(); // ;\n-              self.mk_expr(lo, self.span.hi,\n-                           ExprBreak(None))\n-          }\n           token::DARROW => {\n             self.obsolete(*self.span, ObsoleteSwap);\n             self.bump();\n@@ -2590,8 +2488,7 @@ impl Parser {\n             let hi = body.span.hi;\n             return self.mk_expr(lo, hi, ExprLoop(body, opt_ident));\n         } else {\n-            // This is a 'continue' expression\n-            // FIXME #9467 rm support for 'loop' here after snapshot\n+            // This is an obsolete 'continue' expression\n             if opt_ident.is_some() {\n                 self.span_err(*self.last_span,\n                               \"a label may not be used with a `loop` expression\");\n@@ -2675,20 +2572,11 @@ impl Parser {\n \n     // parse the RHS of a local variable declaration (e.g. '= 14;')\n     fn parse_initializer(&self) -> Option<@Expr> {\n-        match *self.token {\n-          token::EQ => {\n+        if *self.token == token::EQ {\n             self.bump();\n-            return Some(self.parse_expr());\n-          }\n-          token::LARROW => {\n-              self.obsolete(*self.span, ObsoleteMoveInit);\n-              self.bump();\n-              self.bump();\n-              return None;\n-          }\n-          _ => {\n-            return None;\n-          }\n+            Some(self.parse_expr())\n+        } else {\n+            None\n         }\n     }\n \n@@ -2893,19 +2781,6 @@ impl Parser {\n                 span: mk_sp(lo, hi)\n             }\n           }\n-          token::LBRACE => {\n-            self.bump();\n-            let (_, _) = self.parse_pat_fields();\n-            self.bump();\n-            self.obsolete(*self.span, ObsoleteRecordPattern);\n-            pat = PatWild;\n-            hi = self.last_span.hi;\n-            return @ast::Pat {\n-                id: ast::DUMMY_NODE_ID,\n-                node: pat,\n-                span: mk_sp(lo, hi)\n-            }\n-          }\n           token::LPAREN => {\n             // parse (pat,pat,pat,...) as tuple\n             self.bump();\n@@ -3420,10 +3295,7 @@ impl Parser {\n     }\n \n     fn parse_optional_purity(&self) -> ast::purity {\n-        if self.eat_keyword(keywords::Pure) {\n-            self.obsolete(*self.last_span, ObsoletePurity);\n-            ast::impure_fn\n-        } else if self.eat_keyword(keywords::Unsafe) {\n+        if self.eat_keyword(keywords::Unsafe) {\n             ast::unsafe_fn\n         } else {\n             ast::impure_fn\n@@ -3563,7 +3435,7 @@ impl Parser {\n             cnstr: &fn(v: Mutability) -> ast::explicit_self_,\n             p: &Parser\n         ) -> ast::explicit_self_ {\n-            // We need to make sure it isn't a mode or a type\n+            // We need to make sure it isn't a type\n             if p.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) ||\n                 ((p.look_ahead(1, |t| token::is_keyword(keywords::Const, t)) ||\n                   p.look_ahead(1, |t| token::is_keyword(keywords::Mut, t))) &&\n@@ -3637,7 +3509,8 @@ impl Parser {\n           token::TILDE => {\n             maybe_parse_explicit_self(|mutability| {\n                 if mutability != MutImmutable {\n-                    self.obsolete(*self.last_span, ObsoleteMutOwnedPointer);\n+                    self.span_err(*self.last_span,\n+                                  \"mutability declaration not allowed here\");\n                 }\n                 sty_uniq\n             }, self)\n@@ -3802,7 +3675,6 @@ impl Parser {\n     // parse trait Foo { ... }\n     fn parse_item_trait(&self) -> item_info {\n         let ident = self.parse_ident();\n-        self.parse_region_param();\n         let tps = self.parse_generics();\n \n         // Parse traits, if necessary.\n@@ -3859,9 +3731,6 @@ impl Parser {\n \n             ty = self.parse_ty(false);\n             opt_trait_ref\n-        } else if self.eat(&token::COLON) {\n-            self.obsolete(*self.span, ObsoleteImplSyntax);\n-            Some(self.parse_trait_ref())\n         } else {\n             None\n         };\n@@ -3899,12 +3768,7 @@ impl Parser {\n     // parse struct Foo { ... }\n     fn parse_item_struct(&self) -> item_info {\n         let class_name = self.parse_ident();\n-        self.parse_region_param();\n         let generics = self.parse_generics();\n-        if self.eat(&token::COLON) {\n-            self.obsolete(*self.span, ObsoleteClassTraits);\n-            let _ = self.parse_trait_ref_list(&token::LBRACE);\n-        }\n \n         let mut fields: ~[@struct_field];\n         let is_tuple_like;\n@@ -3914,10 +3778,7 @@ impl Parser {\n             is_tuple_like = false;\n             fields = ~[];\n             while *self.token != token::RBRACE {\n-                let r = self.parse_struct_decl_field();\n-                for struct_field in r.iter() {\n-                    fields.push(*struct_field)\n-                }\n+                fields.push(self.parse_struct_decl_field());\n             }\n             if fields.len() == 0 {\n                 self.fatal(format!(\"Unit-like struct definition should be written as `struct {};`\",\n@@ -3979,47 +3840,35 @@ impl Parser {\n                                      vis: visibility,\n                                      attrs: ~[Attribute])\n                                      -> @struct_field {\n-        if self.eat_obsolete_ident(\"let\") {\n-            self.obsolete(*self.last_span, ObsoleteLet);\n-        }\n-\n         let a_var = self.parse_name_and_ty(vis, attrs);\n         match *self.token {\n-            token::SEMI => {\n-                self.obsolete(*self.span, ObsoleteFieldTerminator);\n-                self.bump();\n-            }\n             token::COMMA => {\n                 self.bump();\n             }\n             token::RBRACE => {}\n             _ => {\n                 self.span_fatal(*self.span,\n-                                format!(\"expected `,`, or '\\\\}' but found `{}`\",\n+                                format!(\"expected `,`, or `\\\\}` but found `{}`\",\n                                      self.this_token_to_str()));\n             }\n         }\n         a_var\n     }\n \n     // parse an element of a struct definition\n-    fn parse_struct_decl_field(&self) -> ~[@struct_field] {\n+    fn parse_struct_decl_field(&self) -> @struct_field {\n \n         let attrs = self.parse_outer_attributes();\n \n-        if self.try_parse_obsolete_priv_section(attrs) {\n-            return ~[];\n-        }\n-\n         if self.eat_keyword(keywords::Priv) {\n-            return ~[self.parse_single_struct_field(private, attrs)]\n+            return self.parse_single_struct_field(private, attrs);\n         }\n \n         if self.eat_keyword(keywords::Pub) {\n-           return ~[self.parse_single_struct_field(public, attrs)];\n+           return self.parse_single_struct_field(public, attrs);\n         }\n \n-        return ~[self.parse_single_struct_field(inherited, attrs)];\n+        return self.parse_single_struct_field(inherited, attrs);\n     }\n \n     // parse visiility: PUB, PRIV, or nothing\n@@ -4029,15 +3878,6 @@ impl Parser {\n         else { inherited }\n     }\n \n-    fn parse_staticness(&self) -> bool {\n-        if self.eat_keyword(keywords::Static) {\n-            self.obsolete(*self.last_span, ObsoleteStaticMethod);\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n     // given a termination token and a vector of already-parsed\n     // attributes (of length 0 or 1), parse all of the items in a module\n     fn parse_mod_items(&self,\n@@ -4241,17 +4081,12 @@ impl Parser {\n                              vis: vis }\n     }\n \n-    // parse a const definition from a foreign module\n-    fn parse_item_foreign_const(&self, vis: ast::visibility,\n-                                attrs: ~[Attribute]) -> @foreign_item {\n+    // parse a static item from a foreign module\n+    fn parse_item_foreign_static(&self, vis: ast::visibility,\n+                                 attrs: ~[Attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n \n-        // XXX: Obsolete; remove after snap.\n-        if self.eat_keyword(keywords::Const) {\n-            self.obsolete(*self.last_span, ObsoleteConstItem);\n-        } else {\n-            self.expect_keyword(keywords::Static);\n-        }\n+        self.expect_keyword(keywords::Static);\n         let mutbl = self.eat_keyword(keywords::Mut);\n \n         let ident = self.parse_ident();\n@@ -4270,12 +4105,7 @@ impl Parser {\n     // parse safe/unsafe and fn\n     fn parse_fn_purity(&self) -> purity {\n         if self.eat_keyword(keywords::Fn) { impure_fn }\n-        else if self.eat_keyword(keywords::Pure) {\n-            self.obsolete(*self.last_span, ObsoletePurity);\n-            self.expect_keyword(keywords::Fn);\n-            // NB: We parse this as impure for bootstrapping purposes.\n-            impure_fn\n-        } else if self.eat_keyword(keywords::Unsafe) {\n+        else if self.eat_keyword(keywords::Unsafe) {\n             self.expect_keyword(keywords::Fn);\n             unsafe_fn\n         }\n@@ -4389,31 +4219,19 @@ impl Parser {\n     // parse type Foo = Bar;\n     fn parse_item_type(&self) -> item_info {\n         let ident = self.parse_ident();\n-        self.parse_region_param();\n         let tps = self.parse_generics();\n         self.expect(&token::EQ);\n         let ty = self.parse_ty(false);\n         self.expect(&token::SEMI);\n         (ident, item_ty(ty, tps), None)\n     }\n \n-    // parse obsolete region parameter\n-    fn parse_region_param(&self) {\n-        if self.eat(&token::BINOP(token::SLASH)) {\n-            self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n-            self.expect(&token::BINOP(token::AND));\n-        }\n-    }\n-\n     // parse a structure-like enum variant definition\n     // this should probably be renamed or refactored...\n     fn parse_struct_def(&self) -> @struct_def {\n         let mut fields: ~[@struct_field] = ~[];\n         while *self.token != token::RBRACE {\n-            let r = self.parse_struct_decl_field();\n-            for struct_field in r.iter() {\n-                fields.push(*struct_field);\n-            }\n+            fields.push(self.parse_struct_decl_field());\n         }\n         self.bump();\n \n@@ -4490,36 +4308,7 @@ impl Parser {\n     // parse an \"enum\" declaration\n     fn parse_item_enum(&self) -> item_info {\n         let id = self.parse_ident();\n-        self.parse_region_param();\n         let generics = self.parse_generics();\n-        // Newtype syntax\n-        if *self.token == token::EQ {\n-            // enum x = ty;\n-            self.bump();\n-            let ty = self.parse_ty(false);\n-            self.expect(&token::SEMI);\n-            let variant = spanned(ty.span.lo, ty.span.hi, ast::variant_ {\n-                name: id,\n-                attrs: ~[],\n-                kind: tuple_variant_kind(\n-                    ~[ast::variant_arg {ty: ty, id: ast::DUMMY_NODE_ID}]\n-                ),\n-                id: ast::DUMMY_NODE_ID,\n-                disr_expr: None,\n-                vis: public,\n-            });\n-\n-            self.obsolete(*self.last_span, ObsoleteNewtypeEnum);\n-\n-            return (\n-                id,\n-                item_enum(\n-                    ast::enum_def { variants: ~[variant] },\n-                    generics),\n-                None\n-            );\n-        }\n-        // enum X { ... }\n         self.expect(&token::LBRACE);\n \n         let enum_definition = self.parse_enum_def(&generics);\n@@ -4648,13 +4437,8 @@ impl Parser {\n             }\n         }\n         // the rest are all guaranteed to be items:\n-        if (self.is_keyword(keywords::Const) ||\n-            (self.is_keyword(keywords::Static) &&\n-             self.look_ahead(1, |t| !token::is_keyword(keywords::Fn, t)))) {\n-            // CONST / STATIC ITEM\n-            if self.is_keyword(keywords::Const) {\n-                self.obsolete(*self.span, ObsoleteConstItem);\n-            }\n+        if self.is_keyword(keywords::Static) {\n+            // STATIC ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) = self.parse_item_const();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n@@ -4671,16 +4455,6 @@ impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(keywords::Pure) {\n-            // PURE FUNCTION ITEM (obsolete)\n-            self.obsolete(*self.last_span, ObsoletePurity);\n-            self.expect_keyword(keywords::Fn);\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(impure_fn, AbiSet::Rust());\n-            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n-                                          visibility,\n-                                          maybe_append(attrs, extra_attrs)));\n-        }\n         if self.is_keyword(keywords::Unsafe)\n             && self.look_ahead(1u, |t| *t != token::LBRACE) {\n             // UNSAFE FUNCTION ITEM\n@@ -4747,13 +4521,12 @@ impl Parser {\n \n         let visibility = self.parse_visibility();\n \n-        if (self.is_keyword(keywords::Const) || self.is_keyword(keywords::Static)) {\n-            // FOREIGN CONST ITEM\n-            let item = self.parse_item_foreign_const(visibility, attrs);\n+        if self.is_keyword(keywords::Static) {\n+            // FOREIGN STATIC ITEM\n+            let item = self.parse_item_foreign_static(visibility, attrs);\n             return iovi_foreign_item(item);\n         }\n-        if (self.is_keyword(keywords::Fn) || self.is_keyword(keywords::Pure) ||\n-                self.is_keyword(keywords::Unsafe)) {\n+        if self.is_keyword(keywords::Fn) || self.is_keyword(keywords::Unsafe) {\n             // FOREIGN FUNCTION ITEM\n             let item = self.parse_item_foreign_fn(visibility, attrs);\n             return iovi_foreign_item(item);"}, {"sha": "82249453ac24df2773e6bac49c870c2167b52d80", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -134,9 +134,6 @@ impl StrInterner {\n         new_idx\n     }\n \n-    // this isn't \"pure\" in the traditional sense, because it can go from\n-    // failing to returning a value as items are interned. But for typestate,\n-    // where we first check a pred and then rely on it, ceasing to fail is ok.\n     pub fn get(&self, idx: uint) -> @str { self.vect[idx] }\n \n     pub fn len(&self) -> uint { let vect = &*self.vect; vect.len() }"}, {"sha": "07fa5077d9b264ac6754833e2b360298d957888d", "filename": "src/test/compile-fail/obsolete-syntax.rs", "status": "modified", "additions": 1, "deletions": 42, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,47 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct s {\n-    let foo: (),\n-    //~^ ERROR obsolete syntax: `let` in field declaration\n-    bar: ();\n-    //~^ ERROR obsolete syntax: field declaration terminated with semicolon\n-}\n-\n-struct q : r {\n-    //~^ ERROR obsolete syntax: class traits\n-    foo: int\n-}\n-\n-struct sss {\n-    bar: int,\n-    priv {\n-    //~^ ERROR obsolete syntax: private section\n-        foo: ()\n-    }\n-}\n-\n-fn obsolete_with() {\n-    struct S {\n-        foo: (),\n-        bar: (),\n-    }\n-\n-    let a = S { foo: (), bar: () };\n-    let b = S { foo: () with a };\n-    //~^ ERROR obsolete syntax: with\n-    let c = S { foo: (), with a };\n-    //~^ ERROR obsolete syntax: with\n-}\n-\n-fn obsolete_moves() {\n-    let mut x = 0;\n-    let y <- x;\n-    //~^ ERROR obsolete syntax: initializer-by-move\n-    y <- x;\n-    //~^ ERROR obsolete syntax: binary move\n-}\n-\n extern mod obsolete_name {\n     //~^ ERROR obsolete syntax: named external module\n     fn bar();"}, {"sha": "45b648560da0567def3fa9884d91c1b4cb776e6d", "filename": "src/test/compile-fail/removed-syntax-class-traits.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-class-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-class-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-class-traits.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct q : r {\n+    //~^ ERROR expected `{`, `(`, or `;` after struct name\n+    foo: int\n+}"}, {"sha": "e2ab70b1678cb59a2202e59650e2c02d2e835b07", "filename": "src/test/compile-fail/removed-syntax-closure-lifetime.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+type closure = ~lt/fn(); //~ ERROR expected `;` but found `/`"}, {"sha": "a87f62189417fc3a714f102537028afa55cd77e2", "filename": "src/test/compile-fail/removed-syntax-const-item.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-const-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-const-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-const-item.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const i: int = 42; //~ ERROR expected item but found `const`"}, {"sha": "e40ed28e93fa340a5a00d50d6acd582a3d8204de", "filename": "src/test/compile-fail/removed-syntax-enum-newtype.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-enum-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-enum-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-enum-newtype.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum e = int; //~ ERROR expected `{` but found `=`"}, {"sha": "2f98552a953fc949df2a51e38301c9a68b1eac46", "filename": "src/test/compile-fail/removed-syntax-extern-const.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-extern-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-extern-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-extern-const.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern {\n+    const i: int; //~ ERROR unexpected token: `const`\n+}"}, {"sha": "48b0f008d2227e9aa3d6fb3bcfcd9428cfea21ca", "filename": "src/test/compile-fail/removed-syntax-field-let.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-field-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-field-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-field-let.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct s {\n+    let foo: (),\n+    //~^  ERROR found `let` in ident position\n+    //~^^ ERROR expected `:` but found `foo`\n+}"}, {"sha": "3efcf996f93cbadd25bee0f8b4a64eefa7049696", "filename": "src/test/compile-fail/removed-syntax-field-semicolon.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-field-semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-field-semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-field-semicolon.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct s {\n+    bar: ();\n+    //~^ ERROR expected `,`, or `}` but found `;`\n+}"}, {"sha": "b85880f198174876a48917dfd20affb6a18ca8ad", "filename": "src/test/compile-fail/removed-syntax-fixed-vec.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+type v = [int * 3]; //~ ERROR expected `]` but found `*`"}, {"sha": "865b5f7ad8b9b16af6474244618c49647214dadd", "filename": "src/test/compile-fail/removed-syntax-fn-pure.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fn-pure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fn-pure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fn-pure.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pure fn f() {} //~ ERROR expected item but found `pure`"}, {"sha": "4f21769fe25e6494cadee60464699d06e8bb89d2", "filename": "src/test/compile-fail/removed-syntax-fn-sigil.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fn-sigil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fn-sigil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fn-sigil.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f() {\n+    let x: fn~() = || (); //~ ERROR expected `(` but found `~`\n+}"}, {"sha": "4f615af7c1ca493806f5c8000a1bd065c425dbf8", "filename": "src/test/compile-fail/removed-syntax-larrow-init.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-init.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn removed_moves() {\n+    let mut x = 0;\n+    let y <- x;\n+    //~^ ERROR expected `;` but found `<-`\n+}"}, {"sha": "af49f204e9788374b537401932055e3811caf2f5", "filename": "src/test/compile-fail/removed-syntax-larrow-move.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-move.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn removed_moves() {\n+    let mut x = 0;\n+    let y = 0;\n+    y <- x;\n+    //~^ ERROR expected one of `;`, `}` but found `<-`\n+}"}, {"sha": "d2ab1881b1a0788683316eb68ca8f4aa1ba9535a", "filename": "src/test/compile-fail/removed-syntax-mode.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mode.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f(+x: int) {} //~ ERROR unexpected token: `+`"}, {"sha": "171cf03f7114190b51716a3e51f76213a3c15340", "filename": "src/test/compile-fail/removed-syntax-mut-vec-expr.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f() {\n+    let v = [mut 1, 2, 3, 4];\n+    //~^  ERROR found `mut` in ident position\n+    //~^^ ERROR expected `]` but found `1`\n+}"}, {"sha": "4c0be562f9254ce16ed78795f2e09e10ba31818d", "filename": "src/test/compile-fail/removed-syntax-mut-vec-ty.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+type v = [mut int];\n+    //~^  ERROR found `mut` in ident position\n+    //~^^ ERROR expected `]` but found `int`"}, {"sha": "8fbad2df0020783d1e57e859dde3e02d5949ee06", "filename": "src/test/compile-fail/removed-syntax-priv-group.rs", "status": "renamed", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-priv-group.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-priv-group.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-priv-group.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,16 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct cat : int { //~ ERROR trait\n-  meows: uint,\n-}\n-\n-fn cat(in_x : uint) -> cat {\n-    cat {\n-        meows: in_x\n+struct sss {\n+    bar: int,\n+    priv {\n+    //~^ ERROR expected ident\n+        foo: ()\n     }\n }\n-\n-fn main() {\n-  let nyan = cat(0u);\n-}", "previous_filename": "src/test/compile-fail/class-implements-int.rs"}, {"sha": "5b969da4fd22f8bb5539441f47034eb9f5081340", "filename": "src/test/compile-fail/removed-syntax-ptr-lifetime.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-ptr-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-ptr-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-ptr-lifetime.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+type bptr = &lifetime/int; //~ ERROR expected `;` but found `/`"}, {"sha": "38c5122c2c3f4403d1f4d0aae60d8885b6e7f27e", "filename": "src/test/compile-fail/removed-syntax-record.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-record.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-record.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-record.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+type t = { f: () }; //~ ERROR expected type, found token LBRACE"}, {"sha": "f6455608fdc436143b32c95cbe980c0d220f2d6b", "filename": "src/test/compile-fail/removed-syntax-static-fn.rs", "status": "renamed", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-static-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-static-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-static-fn.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:unexpected token: `}`\n-// Issue #1200\n+struct S;\n \n-type t = {};\n-\n-fn main() {\n+impl S {\n+    static fn f() {} //~ ERROR unexpected token: `static`\n }", "previous_filename": "src/test/compile-fail/empty-record-type.rs"}, {"sha": "eeeb0c3e1247af9591693563651a45ad0d45729c", "filename": "src/test/compile-fail/removed-syntax-uniq-mut-expr.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f() {\n+    let box = ~mut 42;\n+    //~^  ERROR found `mut` in ident position\n+    //~^^ ERROR expected `;` but found `42`\n+}"}, {"sha": "98ab7522966e25e2622847cc340c59b76dfca42b", "filename": "src/test/compile-fail/removed-syntax-uniq-mut-ty.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+type mut_box = ~mut int;\n+    //~^  ERROR found `mut` in ident position\n+    //~^^ ERROR expected `;` but found `int`"}, {"sha": "19e52305a4eac492aa29e0ff487ebbdf04db3e68", "filename": "src/test/compile-fail/removed-syntax-uniq-self.rs", "status": "renamed", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-self.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,17 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use extra;\n+struct S;\n \n-struct Deserializer : extra::serialization::deserializer{ //~ ERROR obsolete syntax: class traits\n-    x: ()\n+impl S {\n+    fn f(~mut self) {} //~ ERROR mutability declaration not allowed here\n }\n-\n-struct Foo {\n-    a: ()\n-}\n-\n-fn deserialize_foo<__D: extra::serialization::deserializer>(__d: __D) {\n-}\n-\n-fn main() { let des = Deserializer(); let foo = deserialize_foo(des); }", "previous_filename": "src/test/compile-fail/issue-3296.rs"}, {"sha": "a0a332af6f6479a266a0c5ff1384a72834f9dcfa", "filename": "src/test/compile-fail/removed-syntax-with-1.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-with-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-with-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-with-1.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn removed_with() {\n+    struct S {\n+        foo: (),\n+        bar: (),\n+    }\n+\n+    let a = S { foo: (), bar: () };\n+    let b = S { foo: () with a };\n+    //~^ ERROR expected one of `,`, `}` but found `with`\n+}"}, {"sha": "3068c5804c8ecaba1d25dc8447fed778c910a1a0", "filename": "src/test/compile-fail/removed-syntax-with-2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-with-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e44b40ca3a1e8e53b485476e7329a0d8e553d29c/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-with-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-with-2.rs?ref=e44b40ca3a1e8e53b485476e7329a0d8e553d29c", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn removed_with() {\n+    struct S {\n+        foo: (),\n+        bar: (),\n+    }\n+\n+    let a = S { foo: (), bar: () };\n+    let b = S { foo: (), with a };\n+    //~^ ERROR expected `:` but found `a`\n+}"}]}