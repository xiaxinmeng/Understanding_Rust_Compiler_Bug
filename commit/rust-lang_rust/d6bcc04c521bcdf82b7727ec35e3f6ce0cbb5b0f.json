{"sha": "d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YmNjMDRjNTIxYmNkZjgyYjc3MjdlYzM1ZTNmNmNlMGNiYjViMGY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-14T00:14:03Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-19T22:13:35Z"}, "message": "Move DefCollector to its own module.", "tree": {"sha": "10cbbc27d2a6e2e10058384750ec86aa52a8cd0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10cbbc27d2a6e2e10058384750ec86aa52a8cd0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f", "html_url": "https://github.com/rust-lang/rust/commit/d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f61b40446777f9ef9b32c19d8df24ded855fd082", "url": "https://api.github.com/repos/rust-lang/rust/commits/f61b40446777f9ef9b32c19d8df24ded855fd082", "html_url": "https://github.com/rust-lang/rust/commit/f61b40446777f9ef9b32c19d8df24ded855fd082"}], "stats": {"total": 515, "additions": 267, "deletions": 248}, "files": [{"sha": "d7fccf03aec75c72fcb13aa9c43df0fd281b673b", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 3, "deletions": 245, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015-2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,10 +13,10 @@ use super::MapEntry::*;\n \n use hir::*;\n use hir::intravisit::Visitor;\n-use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n+use hir::def_id::DefId;\n use middle::cstore::InlinedItem;\n use std::iter::repeat;\n-use syntax::ast::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n+use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax::codemap::Span;\n \n /// A Visitor that walks over the HIR and collects Node's into a HIR map.\n@@ -26,248 +26,6 @@ pub struct NodeCollector<'ast> {\n     pub parent_node: NodeId,\n }\n \n-pub struct DefCollector<'ast> {\n-    pub krate: &'ast Crate,\n-    pub map: &'ast [MapEntry<'ast>],\n-    pub definitions: Definitions,\n-    pub parent_def: Option<DefIndex>,\n-}\n-\n-impl<'ast> DefCollector<'ast> {\n-    pub fn root(krate: &'ast Crate, map: &'ast [MapEntry<'ast>]) -> DefCollector<'ast> {\n-        let mut collector = DefCollector {\n-            krate: krate,\n-            map: map,\n-            definitions: Definitions::new(),\n-            parent_def: None,\n-        };\n-        let result = collector.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n-        assert_eq!(result, CRATE_DEF_INDEX);\n-\n-        collector.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n-\n-        collector\n-    }\n-\n-    pub fn extend(krate: &'ast Crate,\n-                  parent_node: NodeId,\n-                  parent_def_path: DefPath,\n-                  parent_def_id: DefId,\n-                  map: &'ast [MapEntry<'ast>],\n-                  definitions: Definitions)\n-                  -> DefCollector<'ast> {\n-        let mut collector = DefCollector {\n-            krate: krate,\n-            map: map,\n-            parent_def: None,\n-            definitions: definitions,\n-        };\n-\n-        assert_eq!(parent_def_path.krate, parent_def_id.krate);\n-        let root_path = Box::new(InlinedRootPath {\n-            data: parent_def_path.data,\n-            def_id: parent_def_id,\n-        });\n-\n-        let def = collector.create_def(parent_node, DefPathData::InlinedRoot(root_path));\n-        collector.parent_def = Some(def);\n-\n-        collector\n-    }\n-\n-    fn parent_def(&self) -> Option<DefIndex> {\n-        self.parent_def\n-    }\n-\n-    fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n-        let parent_def = self.parent_def();\n-        debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n-        self.definitions.create_def_with_parent(parent_def, node_id, data)\n-    }\n-\n-    fn create_def_with_parent(&mut self,\n-                              parent: Option<DefIndex>,\n-                              node_id: NodeId,\n-                              data: DefPathData)\n-                              -> DefIndex {\n-        self.definitions.create_def_with_parent(parent, node_id, data)\n-    }\n-}\n-\n-impl<'ast> Visitor<'ast> for DefCollector<'ast> {\n-    /// Because we want to track parent items and so forth, enable\n-    /// deep walking so that we walk nested items in the context of\n-    /// their outer items.\n-    fn visit_nested_item(&mut self, item: ItemId) {\n-        debug!(\"visit_nested_item: {:?}\", item);\n-        self.visit_item(self.krate.item(item.id))\n-    }\n-\n-    fn visit_item(&mut self, i: &'ast Item) {\n-        debug!(\"visit_item: {:?}\", i);\n-\n-        // Pick the def data. This need not be unique, but the more\n-        // information we encapsulate into\n-        let def_data = match i.node {\n-            ItemDefaultImpl(..) | ItemImpl(..) =>\n-                DefPathData::Impl,\n-            ItemEnum(..) | ItemStruct(..) | ItemTrait(..) |\n-            ItemExternCrate(..) | ItemForeignMod(..) | ItemTy(..) =>\n-                DefPathData::TypeNs(i.name),\n-            ItemMod(..) =>\n-                DefPathData::Module(i.name),\n-            ItemStatic(..) | ItemConst(..) | ItemFn(..) =>\n-                DefPathData::ValueNs(i.name),\n-            ItemUse(..) =>\n-                DefPathData::Misc,\n-        };\n-\n-        let def = self.create_def(i.id, def_data);\n-\n-        let parent_def = self.parent_def;\n-        self.parent_def = Some(def);\n-\n-        match i.node {\n-            ItemEnum(ref enum_definition, _) => {\n-                for v in &enum_definition.variants {\n-                    let variant_def_index =\n-                        self.create_def(v.node.data.id(),\n-                                        DefPathData::EnumVariant(v.node.name));\n-\n-                    for field in v.node.data.fields() {\n-                        self.create_def_with_parent(\n-                            Some(variant_def_index),\n-                            field.id,\n-                            DefPathData::Field(field.name));\n-                    }\n-                }\n-            }\n-            ItemStruct(ref struct_def, _) => {\n-                // If this is a tuple-like struct, register the constructor.\n-                if !struct_def.is_struct() {\n-                    self.create_def(struct_def.id(),\n-                                    DefPathData::StructCtor);\n-                }\n-\n-                for field in struct_def.fields() {\n-                    self.create_def(field.id, DefPathData::Field(field.name));\n-                }\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_item(self, i);\n-        self.parent_def = parent_def;\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n-        let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.name));\n-\n-        let parent_def = self.parent_def;\n-        self.parent_def = Some(def);\n-        intravisit::walk_foreign_item(self, foreign_item);\n-        self.parent_def = parent_def;\n-    }\n-\n-    fn visit_generics(&mut self, generics: &'ast Generics) {\n-        for ty_param in generics.ty_params.iter() {\n-            self.create_def(ty_param.id,\n-                            DefPathData::TypeParam(ty_param.name));\n-        }\n-\n-        intravisit::walk_generics(self, generics);\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n-        let def_data = match ti.node {\n-            MethodTraitItem(..) | ConstTraitItem(..) => DefPathData::ValueNs(ti.name),\n-            TypeTraitItem(..) => DefPathData::TypeNs(ti.name),\n-        };\n-\n-        let def = self.create_def(ti.id, def_data);\n-\n-        let parent_def = self.parent_def;\n-        self.parent_def = Some(def);\n-\n-        match ti.node {\n-            ConstTraitItem(_, Some(ref expr)) => {\n-                self.create_def(expr.id, DefPathData::Initializer);\n-            }\n-            _ => { }\n-        }\n-\n-        intravisit::walk_trait_item(self, ti);\n-\n-        self.parent_def = parent_def;\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n-        let def_data = match ii.node {\n-            ImplItemKind::Method(..) | ImplItemKind::Const(..) => DefPathData::ValueNs(ii.name),\n-            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name),\n-        };\n-\n-        let def = self.create_def(ii.id, def_data);\n-\n-        let parent_def = self.parent_def;\n-        self.parent_def = Some(def);\n-\n-        match ii.node {\n-            ImplItemKind::Const(_, ref expr) => {\n-                self.create_def(expr.id, DefPathData::Initializer);\n-            }\n-            _ => { }\n-        }\n-\n-        intravisit::walk_impl_item(self, ii);\n-\n-        self.parent_def = parent_def;\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'ast Pat) {\n-        let maybe_binding = match pat.node {\n-            PatKind::Ident(_, id, _) => Some(id.node),\n-            _ => None\n-        };\n-\n-        let parent_def = self.parent_def;\n-        if let Some(id) = maybe_binding {\n-            let def = self.create_def(pat.id, DefPathData::Binding(id.name));\n-            self.parent_def = Some(def);\n-        }\n-\n-        intravisit::walk_pat(self, pat);\n-        self.parent_def = parent_def;\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'ast Expr) {\n-        let parent_def = self.parent_def;\n-\n-        if let ExprClosure(..) = expr.node {\n-            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n-            self.parent_def = Some(def);\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-        self.parent_def = parent_def;\n-    }\n-\n-    fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n-        intravisit::walk_stmt(self, stmt);\n-    }\n-\n-    fn visit_block(&mut self, block: &'ast Block) {\n-        intravisit::walk_block(self, block);\n-    }\n-\n-    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n-        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n-    }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n-        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n-    }\n-}\n-\n impl<'ast> NodeCollector<'ast> {\n     pub fn root(krate: &'ast Crate) -> NodeCollector<'ast> {\n         let mut collector = NodeCollector {"}, {"sha": "0e64a2d676e7d8bfbe3f81828816522d8afdb2ae", "filename": "src/librustc/hir/map/def_collector.rs", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f", "patch": "@@ -0,0 +1,258 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+use hir::*;\n+use hir::intravisit::Visitor;\n+use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n+use syntax::ast::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n+\n+/// Creates def ids for nodes in the HIR.\n+pub struct DefCollector<'ast> {\n+    pub krate: &'ast Crate,\n+    pub map: &'ast [MapEntry<'ast>],\n+    pub definitions: Definitions,\n+    pub parent_def: Option<DefIndex>,\n+}\n+\n+impl<'ast> DefCollector<'ast> {\n+    pub fn root(krate: &'ast Crate, map: &'ast [MapEntry<'ast>]) -> DefCollector<'ast> {\n+        let mut collector = DefCollector {\n+            krate: krate,\n+            map: map,\n+            definitions: Definitions::new(),\n+            parent_def: None,\n+        };\n+        let result = collector.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n+        assert_eq!(result, CRATE_DEF_INDEX);\n+\n+        collector.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n+\n+        collector\n+    }\n+\n+    pub fn extend(krate: &'ast Crate,\n+                  parent_node: NodeId,\n+                  parent_def_path: DefPath,\n+                  parent_def_id: DefId,\n+                  map: &'ast [MapEntry<'ast>],\n+                  definitions: Definitions)\n+                  -> DefCollector<'ast> {\n+        let mut collector = DefCollector {\n+            krate: krate,\n+            map: map,\n+            parent_def: None,\n+            definitions: definitions,\n+        };\n+\n+        assert_eq!(parent_def_path.krate, parent_def_id.krate);\n+        let root_path = Box::new(InlinedRootPath {\n+            data: parent_def_path.data,\n+            def_id: parent_def_id,\n+        });\n+\n+        let def = collector.create_def(parent_node, DefPathData::InlinedRoot(root_path));\n+        collector.parent_def = Some(def);\n+\n+        collector\n+    }\n+\n+    fn parent_def(&self) -> Option<DefIndex> {\n+        self.parent_def\n+    }\n+\n+    fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n+        let parent_def = self.parent_def();\n+        debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n+        self.definitions.create_def_with_parent(parent_def, node_id, data)\n+    }\n+\n+    fn create_def_with_parent(&mut self,\n+                              parent: Option<DefIndex>,\n+                              node_id: NodeId,\n+                              data: DefPathData)\n+                              -> DefIndex {\n+        self.definitions.create_def_with_parent(parent, node_id, data)\n+    }\n+}\n+\n+impl<'ast> Visitor<'ast> for DefCollector<'ast> {\n+    /// Because we want to track parent items and so forth, enable\n+    /// deep walking so that we walk nested items in the context of\n+    /// their outer items.\n+    fn visit_nested_item(&mut self, item: ItemId) {\n+        debug!(\"visit_nested_item: {:?}\", item);\n+        self.visit_item(self.krate.item(item.id))\n+    }\n+\n+    fn visit_item(&mut self, i: &'ast Item) {\n+        debug!(\"visit_item: {:?}\", i);\n+\n+        // Pick the def data. This need not be unique, but the more\n+        // information we encapsulate into\n+        let def_data = match i.node {\n+            ItemDefaultImpl(..) | ItemImpl(..) =>\n+                DefPathData::Impl,\n+            ItemEnum(..) | ItemStruct(..) | ItemTrait(..) |\n+            ItemExternCrate(..) | ItemMod(..) | ItemForeignMod(..) |\n+            ItemTy(..) =>\n+                DefPathData::TypeNs(i.name),\n+            ItemStatic(..) | ItemConst(..) | ItemFn(..) =>\n+                DefPathData::ValueNs(i.name),\n+            ItemUse(..) =>\n+                DefPathData::Misc,\n+        };\n+\n+        let def = self.create_def(i.id, def_data);\n+\n+        let parent_def = self.parent_def;\n+        self.parent_def = Some(def);\n+\n+        match i.node {\n+            ItemEnum(ref enum_definition, _) => {\n+                for v in &enum_definition.variants {\n+                    let variant_def_index =\n+                        self.create_def(v.node.data.id(),\n+                                        DefPathData::EnumVariant(v.node.name));\n+\n+                    for field in v.node.data.fields() {\n+                        self.create_def_with_parent(\n+                            Some(variant_def_index),\n+                            field.id,\n+                            DefPathData::Field(field.name));\n+                    }\n+                }\n+            }\n+            ItemStruct(ref struct_def, _) => {\n+                // If this is a tuple-like struct, register the constructor.\n+                if !struct_def.is_struct() {\n+                    self.create_def(struct_def.id(),\n+                                    DefPathData::StructCtor);\n+                }\n+\n+                for field in struct_def.fields() {\n+                    self.create_def(field.id, DefPathData::Field(field.name));\n+                }\n+            }\n+            _ => {}\n+        }\n+        intravisit::walk_item(self, i);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n+        let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.name));\n+\n+        let parent_def = self.parent_def;\n+        self.parent_def = Some(def);\n+        intravisit::walk_foreign_item(self, foreign_item);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_generics(&mut self, generics: &'ast Generics) {\n+        for ty_param in generics.ty_params.iter() {\n+            self.create_def(ty_param.id,\n+                            DefPathData::TypeParam(ty_param.name));\n+        }\n+\n+        intravisit::walk_generics(self, generics);\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n+        let def_data = match ti.node {\n+            MethodTraitItem(..) | ConstTraitItem(..) => DefPathData::ValueNs(ti.name),\n+            TypeTraitItem(..) => DefPathData::TypeNs(ti.name),\n+        };\n+\n+        let def = self.create_def(ti.id, def_data);\n+\n+        let parent_def = self.parent_def;\n+        self.parent_def = Some(def);\n+\n+        match ti.node {\n+            ConstTraitItem(_, Some(ref expr)) => {\n+                self.create_def(expr.id, DefPathData::Initializer);\n+            }\n+            _ => { }\n+        }\n+\n+        intravisit::walk_trait_item(self, ti);\n+\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n+        let def_data = match ii.node {\n+            ImplItemKind::Method(..) | ImplItemKind::Const(..) => DefPathData::ValueNs(ii.name),\n+            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name),\n+        };\n+\n+        let def = self.create_def(ii.id, def_data);\n+\n+        let parent_def = self.parent_def;\n+        self.parent_def = Some(def);\n+\n+        match ii.node {\n+            ImplItemKind::Const(_, ref expr) => {\n+                self.create_def(expr.id, DefPathData::Initializer);\n+            }\n+            _ => { }\n+        }\n+\n+        intravisit::walk_impl_item(self, ii);\n+\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'ast Pat) {\n+        let maybe_binding = match pat.node {\n+            PatKind::Ident(_, id, _) => Some(id.node),\n+            _ => None\n+        };\n+\n+        let parent_def = self.parent_def;\n+        if let Some(id) = maybe_binding {\n+            let def = self.create_def(pat.id, DefPathData::Binding(id.name));\n+            self.parent_def = Some(def);\n+        }\n+\n+        intravisit::walk_pat(self, pat);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'ast Expr) {\n+        let parent_def = self.parent_def;\n+\n+        if let ExprClosure(..) = expr.node {\n+            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n+            self.parent_def = Some(def);\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+        self.parent_def = parent_def;\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n+        intravisit::walk_stmt(self, stmt);\n+    }\n+\n+    fn visit_block(&mut self, block: &'ast Block) {\n+        intravisit::walk_block(self, block);\n+    }\n+\n+    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n+        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n+    }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n+        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n+    }\n+}"}, {"sha": "d0ec83b7eb3a19e102d285940a6e79b00913e84a", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f", "patch": "@@ -10,7 +10,8 @@\n \n pub use self::Node::*;\n use self::MapEntry::*;\n-use self::collector::{NodeCollector, DefCollector};\n+use self::collector::NodeCollector;\n+use self::def_collector::DefCollector;\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n                             DisambiguatedDefPathData, InlinedRootPath};\n \n@@ -36,6 +37,7 @@ use std::mem;\n \n pub mod blocks;\n mod collector;\n+mod def_collector;\n pub mod definitions;\n \n #[derive(Copy, Clone, Debug)]\n@@ -852,12 +854,13 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     ii.visit(&mut collector);\n \n     {\n+        let defs = mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new());\n         let mut def_collector = DefCollector::extend(map.krate(),\n                                                      ii_parent_id,\n                                                      parent_def_path,\n                                                      parent_def_id,\n                                                      &collector.map,\n-                                                     mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new()));\n+                                                     defs);\n         ii.visit(&mut def_collector);\n         *map.definitions.borrow_mut() = def_collector.definitions;\n     }"}, {"sha": "488e7ae56ef87e86e6e1b80f604a3f397ad33fbe", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d6bcc04c521bcdf82b7727ec35e3f6ce0cbb5b0f", "patch": "@@ -121,7 +121,7 @@ pub fn compile_input(sess: &Session,\n \n         let expanded_crate = assign_node_ids(sess, expanded_crate);\n         let dep_graph = DepGraph::new(sess.opts.build_dep_graph);\n-        \n+\n         // TODO\n         // time(sess.time_passes(),\n         //      \"external crate/lib resolution\","}]}