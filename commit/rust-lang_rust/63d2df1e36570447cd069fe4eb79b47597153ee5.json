{"sha": "63d2df1e36570447cd069fe4eb79b47597153ee5", "node_id": "C_kwDOAAsO6NoAKDYzZDJkZjFlMzY1NzA0NDdjZDA2OWZlNGViNzliNDc1OTcxNTNlZTU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-03T12:42:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-03T12:42:52Z"}, "message": "Merge #11699\n\n11699: feat: assist to remove unneeded `async`s r=Ethiraric a=Ethiraric\n\nThis should fix #11392 \r\n\r\nThis PR adds a quickfix on functions marked with `async` that suggests, if and only if no `await` expression in find in the body of the function (it relies on `SyntaxNode::descendants()` to recursively traverse blocks), to remove the `async` keyword.\r\n\r\nThe lint is made so that it triggers only if the cursor is not in the body of the function, so that it does not pollute the quickfix list.\r\n\r\nIt does not trigger a diagnostic. I don't know if this repository is the place to implement those (`clippy`?). If it is, I would very much like pointers on where to start looking.\r\n\r\nIf there are test cases I haven't thought about, please do suggest.\n\nCo-authored-by: Ethiraric <ethiraric@gmail.com>", "tree": {"sha": "2af9460aade8f67f9a0719cd189ebfec1d7b0385", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2af9460aade8f67f9a0719cd189ebfec1d7b0385"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63d2df1e36570447cd069fe4eb79b47597153ee5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiSZZMCRBK7hj4Ov3rIwAAxxYIAH0lD/2uxWtwxW4lFKqqQhGv\nC/9wgCPpR7A0LX36ACqIQ2Ui6QVQ/Cixu59GWT0hK8TpZrVoa8uoW9CvDakcv7ZZ\nW084K4DmS7psq6AjHIDivBojhLNG7vxIoLdRvl94ocS0EwciBSsMcyKPQ5K8VD4N\nvWCaZhxXbCcYBm7PymG8U6PZcqC1D3mTXfk5syh2vMtuLZj0HU1tWwmtrQ2DEBgI\nLBSsOUPPh6a9IFqhzikMX5C9xz2RXSBCEIOUNmZiFUVzsvkg59YI8nKMaBvRY0j8\nbnbuMf/sBNN0P/uoesWwBB1SJG0haiV9YNrs00FCBQww34akXXhwaHrE9uuoSRM=\n=9L0J\n-----END PGP SIGNATURE-----\n", "payload": "tree 2af9460aade8f67f9a0719cd189ebfec1d7b0385\nparent bc0825d1358abece6e85b928ea3a197451d083c7\nparent 520557d45c15375f32cb838ed2e2030b86d11fd2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1648989772 +0000\ncommitter GitHub <noreply@github.com> 1648989772 +0000\n\nMerge #11699\n\n11699: feat: assist to remove unneeded `async`s r=Ethiraric a=Ethiraric\n\nThis should fix #11392 \r\n\r\nThis PR adds a quickfix on functions marked with `async` that suggests, if and only if no `await` expression in find in the body of the function (it relies on `SyntaxNode::descendants()` to recursively traverse blocks), to remove the `async` keyword.\r\n\r\nThe lint is made so that it triggers only if the cursor is not in the body of the function, so that it does not pollute the quickfix list.\r\n\r\nIt does not trigger a diagnostic. I don't know if this repository is the place to implement those (`clippy`?). If it is, I would very much like pointers on where to start looking.\r\n\r\nIf there are test cases I haven't thought about, please do suggest.\n\nCo-authored-by: Ethiraric <ethiraric@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63d2df1e36570447cd069fe4eb79b47597153ee5", "html_url": "https://github.com/rust-lang/rust/commit/63d2df1e36570447cd069fe4eb79b47597153ee5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63d2df1e36570447cd069fe4eb79b47597153ee5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc0825d1358abece6e85b928ea3a197451d083c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc0825d1358abece6e85b928ea3a197451d083c7", "html_url": "https://github.com/rust-lang/rust/commit/bc0825d1358abece6e85b928ea3a197451d083c7"}, {"sha": "520557d45c15375f32cb838ed2e2030b86d11fd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/520557d45c15375f32cb838ed2e2030b86d11fd2", "html_url": "https://github.com/rust-lang/rust/commit/520557d45c15375f32cb838ed2e2030b86d11fd2"}], "stats": {"total": 274, "additions": 274, "deletions": 0}, "files": [{"sha": "d90fee7809e8ac69814b0c0b18fc0c1018104b1a", "filename": "crates/ide_assists/src/handlers/unnecessary_async.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/63d2df1e36570447cd069fe4eb79b47597153ee5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d2df1e36570447cd069fe4eb79b47597153ee5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs?ref=63d2df1e36570447cd069fe4eb79b47597153ee5", "patch": "@@ -0,0 +1,257 @@\n+use ide_db::{\n+    assists::{AssistId, AssistKind},\n+    base_db::FileId,\n+    defs::Definition,\n+    search::FileReference,\n+    syntax_helpers::node_ext::full_path_of_name_ref,\n+};\n+use syntax::{\n+    ast::{self, NameLike, NameRef},\n+    AstNode, SyntaxKind, TextRange,\n+};\n+\n+use crate::{AssistContext, Assists};\n+\n+// Assist: unnecessary_async\n+//\n+// Removes the `async` mark from functions which have no `.await` in their body.\n+// Looks for calls to the functions and removes the `.await` on the call site.\n+//\n+// ```\n+// pub async f$0n foo() {}\n+// pub async fn bar() { foo().await }\n+// ```\n+// ->\n+// ```\n+// pub fn foo() {}\n+// pub async fn bar() { foo() }\n+// ```\n+pub(crate) fn unnecessary_async(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let function: ast::Fn = ctx.find_node_at_offset()?;\n+\n+    // Do nothing if the cursor is not on the prototype. This is so that the check does not pollute\n+    // when the user asks us for assists when in the middle of the function body.\n+    // We consider the prototype to be anything that is before the body of the function.\n+    let cursor_position = ctx.offset();\n+    if cursor_position >= function.body()?.syntax().text_range().start() {\n+        return None;\n+    }\n+    // Do nothing if the function isn't async.\n+    if let None = function.async_token() {\n+        return None;\n+    }\n+    // Do nothing if the function has an `await` expression in its body.\n+    if function.body()?.syntax().descendants().find_map(ast::AwaitExpr::cast).is_some() {\n+        return None;\n+    }\n+\n+    // Remove the `async` keyword plus whitespace after it, if any.\n+    let async_range = {\n+        let async_token = function.async_token()?;\n+        let next_token = async_token.next_token()?;\n+        if matches!(next_token.kind(), SyntaxKind::WHITESPACE) {\n+            TextRange::new(async_token.text_range().start(), next_token.text_range().end())\n+        } else {\n+            async_token.text_range()\n+        }\n+    };\n+\n+    // Otherwise, we may remove the `async` keyword.\n+    acc.add(\n+        AssistId(\"unnecessary_async\", AssistKind::QuickFix),\n+        \"Remove unnecessary async\",\n+        async_range,\n+        |edit| {\n+            // Remove async on the function definition.\n+            edit.replace(async_range, \"\");\n+\n+            // Remove all `.await`s from calls to the function we remove `async` from.\n+            if let Some(fn_def) = ctx.sema.to_def(&function) {\n+                for await_expr in find_all_references(ctx, &Definition::Function(fn_def))\n+                    // Keep only references that correspond NameRefs.\n+                    .filter_map(|(_, reference)| match reference.name {\n+                        NameLike::NameRef(nameref) => Some(nameref),\n+                        _ => None,\n+                    })\n+                    // Keep only references that correspond to await expressions\n+                    .filter_map(|nameref| find_await_expression(ctx, &nameref))\n+                {\n+                    if let Some(await_token) = &await_expr.await_token() {\n+                        edit.replace(await_token.text_range(), \"\");\n+                    }\n+                    if let Some(dot_token) = &await_expr.dot_token() {\n+                        edit.replace(dot_token.text_range(), \"\");\n+                    }\n+                }\n+            }\n+        },\n+    )\n+}\n+\n+fn find_all_references(\n+    ctx: &AssistContext,\n+    def: &Definition,\n+) -> impl Iterator<Item = (FileId, FileReference)> {\n+    def.usages(&ctx.sema).all().into_iter().flat_map(|(file_id, references)| {\n+        references.into_iter().map(move |reference| (file_id, reference))\n+    })\n+}\n+\n+/// Finds the await expression for the given `NameRef`.\n+/// If no await expression is found, returns None.\n+fn find_await_expression(ctx: &AssistContext, nameref: &NameRef) -> Option<ast::AwaitExpr> {\n+    // From the nameref, walk up the tree to the await expression.\n+    let await_expr = if let Some(path) = full_path_of_name_ref(&nameref) {\n+        // Function calls.\n+        path.syntax()\n+            .parent()\n+            .and_then(ast::PathExpr::cast)?\n+            .syntax()\n+            .parent()\n+            .and_then(ast::CallExpr::cast)?\n+            .syntax()\n+            .parent()\n+            .and_then(ast::AwaitExpr::cast)\n+    } else {\n+        // Method calls.\n+        nameref\n+            .syntax()\n+            .parent()\n+            .and_then(ast::MethodCallExpr::cast)?\n+            .syntax()\n+            .parent()\n+            .and_then(ast::AwaitExpr::cast)\n+    };\n+\n+    ctx.sema.original_ast_node(await_expr?)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    #[test]\n+    fn applies_on_empty_function() {\n+        check_assist(unnecessary_async, \"pub async f$0n f() {}\", \"pub fn f() {}\")\n+    }\n+\n+    #[test]\n+    fn applies_and_removes_whitespace() {\n+        check_assist(unnecessary_async, \"pub async       f$0n f() {}\", \"pub fn f() {}\")\n+    }\n+\n+    #[test]\n+    fn does_not_apply_on_non_async_function() {\n+        check_assist_not_applicable(unnecessary_async, \"pub f$0n f() {}\")\n+    }\n+\n+    #[test]\n+    fn applies_on_function_with_a_non_await_expr() {\n+        check_assist(unnecessary_async, \"pub async f$0n f() { f2() }\", \"pub fn f() { f2() }\")\n+    }\n+\n+    #[test]\n+    fn does_not_apply_on_function_with_an_await_expr() {\n+        check_assist_not_applicable(unnecessary_async, \"pub async f$0n f() { f2().await }\")\n+    }\n+\n+    #[test]\n+    fn applies_and_removes_await_on_reference() {\n+        check_assist(\n+            unnecessary_async,\n+            r#\"\n+pub async fn f4() { }\n+pub async f$0n f2() { }\n+pub async fn f() { f2().await }\n+pub async fn f3() { f2().await }\"#,\n+            r#\"\n+pub async fn f4() { }\n+pub fn f2() { }\n+pub async fn f() { f2() }\n+pub async fn f3() { f2() }\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn applies_and_removes_await_from_within_module() {\n+        check_assist(\n+            unnecessary_async,\n+            r#\"\n+pub async fn f4() { }\n+mod a { pub async f$0n f2() { } }\n+pub async fn f() { a::f2().await }\n+pub async fn f3() { a::f2().await }\"#,\n+            r#\"\n+pub async fn f4() { }\n+mod a { pub fn f2() { } }\n+pub async fn f() { a::f2() }\n+pub async fn f3() { a::f2() }\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn applies_and_removes_await_on_inner_await() {\n+        check_assist(\n+            unnecessary_async,\n+            // Ensure that it is the first await on the 3rd line that is removed\n+            r#\"\n+pub async fn f() { f2().await }\n+pub async f$0n f2() -> i32 { 1 }\n+pub async fn f3() { f4(f2().await).await }\n+pub async fn f4(i: i32) { }\"#,\n+            r#\"\n+pub async fn f() { f2() }\n+pub fn f2() -> i32 { 1 }\n+pub async fn f3() { f4(f2()).await }\n+pub async fn f4(i: i32) { }\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn applies_and_removes_await_on_outer_await() {\n+        check_assist(\n+            unnecessary_async,\n+            // Ensure that it is the second await on the 3rd line that is removed\n+            r#\"\n+pub async fn f() { f2().await }\n+pub async f$0n f2(i: i32) { }\n+pub async fn f3() { f2(f4().await).await }\n+pub async fn f4() -> i32 { 1 }\"#,\n+            r#\"\n+pub async fn f() { f2() }\n+pub fn f2(i: i32) { }\n+pub async fn f3() { f2(f4().await) }\n+pub async fn f4() -> i32 { 1 }\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn applies_on_method_call() {\n+        check_assist(\n+            unnecessary_async,\n+            r#\"\n+pub struct S { }\n+impl S { pub async f$0n f2(&self) { } }\n+pub async fn f(s: &S) { s.f2().await }\"#,\n+            r#\"\n+pub struct S { }\n+impl S { pub fn f2(&self) { } }\n+pub async fn f(s: &S) { s.f2() }\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn does_not_apply_on_function_with_a_nested_await_expr() {\n+        check_assist_not_applicable(\n+            unnecessary_async,\n+            \"async f$0n f() { if true { loop { f2().await } } }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn does_not_apply_when_not_on_prototype() {\n+        check_assist_not_applicable(unnecessary_async, \"pub async fn f() { $0f2() }\")\n+    }\n+}"}, {"sha": "ef4aa1c62bdf7594bd5d84bc34991fb4a9cedc86", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63d2df1e36570447cd069fe4eb79b47597153ee5/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d2df1e36570447cd069fe4eb79b47597153ee5/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=63d2df1e36570447cd069fe4eb79b47597153ee5", "patch": "@@ -183,6 +183,7 @@ mod handlers {\n     mod sort_items;\n     mod toggle_ignore;\n     mod unmerge_use;\n+    mod unnecessary_async;\n     mod unwrap_block;\n     mod unwrap_result_return_type;\n     mod wrap_return_type_in_result;\n@@ -268,6 +269,7 @@ mod handlers {\n             split_import::split_import,\n             toggle_ignore::toggle_ignore,\n             unmerge_use::unmerge_use,\n+            unnecessary_async::unnecessary_async,\n             unwrap_block::unwrap_block,\n             unwrap_result_return_type::unwrap_result_return_type,\n             wrap_return_type_in_result::wrap_return_type_in_result,"}, {"sha": "8a1e95d8947be3ed0e26ff35a787a38be3d15038", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/63d2df1e36570447cd069fe4eb79b47597153ee5/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d2df1e36570447cd069fe4eb79b47597153ee5/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=63d2df1e36570447cd069fe4eb79b47597153ee5", "patch": "@@ -2106,6 +2106,21 @@ use std::fmt::Display;\n     )\n }\n \n+#[test]\n+fn doctest_unnecessary_async() {\n+    check_doc_test(\n+        \"unnecessary_async\",\n+        r#####\"\n+pub async f$0n foo() {}\n+pub async fn bar() { foo().await }\n+\"#####,\n+        r#####\"\n+pub fn foo() {}\n+pub async fn bar() { foo() }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_unwrap_block() {\n     check_doc_test("}]}