{"sha": "260ec9347838714ad9fa4f7e083bdc0448f4f9be", "node_id": "C_kwDOAAsO6NoAKDI2MGVjOTM0NzgzODcxNGFkOWZhNGY3ZTA4M2JkYzA0NDhmNGY5YmU", "commit": {"author": {"name": "Jake Goulding", "email": "jake.goulding@gmail.com", "date": "2022-07-22T01:39:20Z"}, "committer": {"name": "Jake Goulding", "email": "jake.goulding@gmail.com", "date": "2022-08-23T14:48:59Z"}, "message": "Add `Provider::{would_be_satisfied_by_value_of,would_be_satisfied_by_ref_of}`\n\nWhile the `provide_*` methods already short-circuit when a value has\nbeen provided, there are times where an expensive computation is\nneeded to determine if the `provide_*` method can even be called.", "tree": {"sha": "f7ffc23cbc1e3ac507b57eaf838f05024d0f080b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7ffc23cbc1e3ac507b57eaf838f05024d0f080b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/260ec9347838714ad9fa4f7e083bdc0448f4f9be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/260ec9347838714ad9fa4f7e083bdc0448f4f9be", "html_url": "https://github.com/rust-lang/rust/commit/260ec9347838714ad9fa4f7e083bdc0448f4f9be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/260ec9347838714ad9fa4f7e083bdc0448f4f9be/comments", "author": {"login": "shepmaster", "id": 174509, "node_id": "MDQ6VXNlcjE3NDUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/174509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shepmaster", "html_url": "https://github.com/shepmaster", "followers_url": "https://api.github.com/users/shepmaster/followers", "following_url": "https://api.github.com/users/shepmaster/following{/other_user}", "gists_url": "https://api.github.com/users/shepmaster/gists{/gist_id}", "starred_url": "https://api.github.com/users/shepmaster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shepmaster/subscriptions", "organizations_url": "https://api.github.com/users/shepmaster/orgs", "repos_url": "https://api.github.com/users/shepmaster/repos", "events_url": "https://api.github.com/users/shepmaster/events{/privacy}", "received_events_url": "https://api.github.com/users/shepmaster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "shepmaster", "id": 174509, "node_id": "MDQ6VXNlcjE3NDUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/174509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shepmaster", "html_url": "https://github.com/shepmaster", "followers_url": "https://api.github.com/users/shepmaster/followers", "following_url": "https://api.github.com/users/shepmaster/following{/other_user}", "gists_url": "https://api.github.com/users/shepmaster/gists{/gist_id}", "starred_url": "https://api.github.com/users/shepmaster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shepmaster/subscriptions", "organizations_url": "https://api.github.com/users/shepmaster/orgs", "repos_url": "https://api.github.com/users/shepmaster/repos", "events_url": "https://api.github.com/users/shepmaster/events{/privacy}", "received_events_url": "https://api.github.com/users/shepmaster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38de102cffb7692738ec7940794e59452372d395", "url": "https://api.github.com/repos/rust-lang/rust/commits/38de102cffb7692738ec7940794e59452372d395", "html_url": "https://github.com/rust-lang/rust/commit/38de102cffb7692738ec7940794e59452372d395"}], "stats": {"total": 165, "additions": 165, "deletions": 0}, "files": [{"sha": "1a379ecc11c01d7ae8cdfde75d8a591425eaa2ca", "filename": "library/core/src/any.rs", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/260ec9347838714ad9fa4f7e083bdc0448f4f9be/library%2Fcore%2Fsrc%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260ec9347838714ad9fa4f7e083bdc0448f4f9be/library%2Fcore%2Fsrc%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fany.rs?ref=260ec9347838714ad9fa4f7e083bdc0448f4f9be", "patch": "@@ -1008,6 +1008,156 @@ impl<'a> Demand<'a> {\n         }\n         self\n     }\n+\n+    /// Check if the `Demand` would be satisfied if provided with a\n+    /// value of the specified type. If the type does not match or has\n+    /// already been provided, returns false.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Check if an `u8` still needs to be provided and then provides\n+    /// it.\n+    ///\n+    /// ```rust\n+    /// #![feature(provide_any)]\n+    ///\n+    /// use std::any::{Provider, Demand};\n+    ///\n+    /// struct Parent(Option<u8>);\n+    ///\n+    /// impl Provider for Parent {\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         if let Some(v) = self.0 {\n+    ///             demand.provide_value::<u8>(v);\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// struct Child {\n+    ///     parent: Parent,\n+    /// }\n+    ///\n+    /// impl Child {\n+    ///     // Pretend that this takes a lot of resources to evaluate.\n+    ///     fn an_expensive_computation(&self) -> Option<u8> {\n+    ///         Some(99)\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Provider for Child {\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         // In general, we don't know if this call will provide\n+    ///         // an `u8` value or not...\n+    ///         self.parent.provide(demand);\n+    ///\n+    ///         // ...so we check to see if the `u8` is needed before\n+    ///         // we run our expensive computation.\n+    ///         if demand.would_be_satisfied_by_value_of::<u8>() {\n+    ///             if let Some(v) = self.an_expensive_computation() {\n+    ///                 demand.provide_value::<u8>(v);\n+    ///             }\n+    ///         }\n+    ///\n+    ///         // The demand will be satisfied now, regardless of if\n+    ///         // the parent provided the value or we did.\n+    ///         assert!(!demand.would_be_satisfied_by_value_of::<u8>());\n+    ///     }\n+    /// }\n+    ///\n+    /// let parent = Parent(Some(42));\n+    /// let child = Child { parent };\n+    /// assert_eq!(Some(42), std::any::request_value::<u8>(&child));\n+    ///\n+    /// let parent = Parent(None);\n+    /// let child = Child { parent };\n+    /// assert_eq!(Some(99), std::any::request_value::<u8>(&child));\n+    /// ```\n+    #[unstable(feature = \"provide_any\", issue = \"96024\")]\n+    pub fn would_be_satisfied_by_value_of<T>(&self) -> bool\n+    where\n+        T: 'static,\n+    {\n+        self.would_be_satisfied_by::<tags::Value<T>>()\n+    }\n+\n+    /// Check if the `Demand` would be satisfied if provided with a\n+    /// reference to a value of the specified type. If the type does\n+    /// not match or has already been provided, returns false.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Check if a `&str` still needs to be provided and then provides\n+    /// it.\n+    ///\n+    /// ```rust\n+    /// #![feature(provide_any)]\n+    ///\n+    /// use std::any::{Provider, Demand};\n+    ///\n+    /// struct Parent(Option<String>);\n+    ///\n+    /// impl Provider for Parent {\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         if let Some(v) = &self.0 {\n+    ///             demand.provide_ref::<str>(v);\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// struct Child {\n+    ///     parent: Parent,\n+    ///     name: String,\n+    /// }\n+    ///\n+    /// impl Child {\n+    ///     // Pretend that this takes a lot of resources to evaluate.\n+    ///     fn an_expensive_computation(&self) -> Option<&str> {\n+    ///         Some(&self.name)\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Provider for Child {\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         // In general, we don't know if this call will provide\n+    ///         // a `str` reference or not...\n+    ///         self.parent.provide(demand);\n+    ///\n+    ///         // ...so we check to see if the `&str` is needed before\n+    ///         // we run our expensive computation.\n+    ///         if demand.would_be_satisfied_by_ref_of::<str>() {\n+    ///             if let Some(v) = self.an_expensive_computation() {\n+    ///                 demand.provide_ref::<str>(v);\n+    ///             }\n+    ///         }\n+    ///\n+    ///         // The demand will be satisfied now, regardless of if\n+    ///         // the parent provided the reference or we did.\n+    ///         assert!(!demand.would_be_satisfied_by_ref_of::<str>());\n+    ///     }\n+    /// }\n+    ///\n+    /// let parent = Parent(Some(\"parent\".into()));\n+    /// let child = Child { parent, name: \"child\".into() };\n+    /// assert_eq!(Some(\"parent\"), std::any::request_ref::<str>(&child));\n+    ///\n+    /// let parent = Parent(None);\n+    /// let child = Child { parent, name: \"child\".into() };\n+    /// assert_eq!(Some(\"child\"), std::any::request_ref::<str>(&child));\n+    /// ```\n+    #[unstable(feature = \"provide_any\", issue = \"96024\")]\n+    pub fn would_be_satisfied_by_ref_of<T>(&self) -> bool\n+    where\n+        T: ?Sized + 'static,\n+    {\n+        self.would_be_satisfied_by::<tags::Ref<tags::MaybeSizedValue<T>>>()\n+    }\n+\n+    fn would_be_satisfied_by<I>(&self) -> bool\n+    where\n+        I: tags::Type<'a>,\n+    {\n+        matches!(self.0.downcast::<I>(), Some(TaggedOption(None)))\n+    }\n }\n \n #[unstable(feature = \"provide_any\", issue = \"96024\")]\n@@ -1112,6 +1262,21 @@ impl<'a> dyn Erased<'a> + 'a {\n     /// Returns some reference to the dynamic value if it is tagged with `I`,\n     /// or `None` otherwise.\n     #[inline]\n+    fn downcast<I>(&self) -> Option<&TaggedOption<'a, I>>\n+    where\n+        I: tags::Type<'a>,\n+    {\n+        if self.tag_id() == TypeId::of::<I>() {\n+            // SAFETY: Just checked whether we're pointing to an I.\n+            Some(unsafe { &*(self as *const Self).cast::<TaggedOption<'a, I>>() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns some mutable reference to the dynamic value if it is tagged with `I`,\n+    /// or `None` otherwise.\n+    #[inline]\n     fn downcast_mut<I>(&mut self) -> Option<&mut TaggedOption<'a, I>>\n     where\n         I: tags::Type<'a>,"}]}