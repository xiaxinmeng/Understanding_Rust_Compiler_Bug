{"sha": "95521c408438efc5794e83953086c812b795c756", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NTIxYzQwODQzOGVmYzU3OTRlODM5NTMwODZjODEyYjc5NWM3NTY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-08T02:17:30Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-10T06:56:53Z"}, "message": "std: Convert to rustdoc", "tree": {"sha": "b18b23905bd9ddc5d9e56f6787d6057b0a9bbfea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b18b23905bd9ddc5d9e56f6787d6057b0a9bbfea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95521c408438efc5794e83953086c812b795c756", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95521c408438efc5794e83953086c812b795c756", "html_url": "https://github.com/rust-lang/rust/commit/95521c408438efc5794e83953086c812b795c756", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95521c408438efc5794e83953086c812b795c756/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b22556a6f818845cd400ad58065a83916ba591a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b22556a6f818845cd400ad58065a83916ba591a7", "html_url": "https://github.com/rust-lang/rust/commit/b22556a6f818845cd400ad58065a83916ba591a7"}], "stats": {"total": 2273, "additions": 708, "deletions": 1565}, "files": [{"sha": "01bbc1588bb6311cc6c0bce3b40d7acb94d642c9", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 47, "deletions": 127, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,9 +1,3 @@\n-/*\n-Module: bitv\n-\n-Bitvectors.\n-*/\n-\n export t;\n export create;\n export union;\n@@ -28,25 +22,19 @@ export eq_vec;\n //        an optimizing version of this module that produces a different obj\n //        for the case where nbits <= 32.\n \n-/*\n-Type: t\n-\n-The bitvector type.\n-*/\n+#[doc = \"The bitvector type\"]\n type t = @{storage: [mutable uint], nbits: uint};\n \n-\n const uint_bits: uint = 32u + (1u << 32u >> 27u);\n \n-/*\n-Function: create\n+#[doc = \"\n+Constructs a bitvector\n \n-Constructs a bitvector.\n+# Arguments\n \n-Parameters:\n-nbits - The number of bits in the bitvector\n-init - If true then the bits are initialized to 1, otherwise 0\n-*/\n+* nbits - The number of bits in the bitvector\n+* init - If true then the bits are initialized to 1, otherwise 0\n+\"]\n fn create(nbits: uint, init: bool) -> t {\n     let elt = if init { !0u } else { 0u };\n     let storage = vec::to_mut(vec::init_elt(nbits / uint_bits + 1u, elt));\n@@ -74,60 +62,35 @@ fn union(v0: t, v1: t) -> bool { let sub = lor; ret process(v0, v1, sub); }\n \n fn land(w0: uint, w1: uint) -> uint { ret w0 & w1; }\n \n-/*\n-Function: intersect\n-\n+#[doc = \"\n Calculates the intersection of two bitvectors\n \n-Sets `v0` to the intersection of `v0` and `v1`\n-\n-Preconditions:\n-\n-Both bitvectors must be the same length\n-\n-Returns:\n-\n-True if `v0` was changed\n-*/\n+Sets `v0` to the intersection of `v0` and `v1`. Both bitvectors must be the\n+same length. Returns 'true' if `v0` was changed.\n+\"]\n fn intersect(v0: t, v1: t) -> bool {\n     let sub = land;\n     ret process(v0, v1, sub);\n }\n \n fn right(_w0: uint, w1: uint) -> uint { ret w1; }\n \n-/*\n-Function: assign\n-\n+#[doc = \"\n Assigns the value of `v1` to `v0`\n \n-Preconditions:\n-\n-Both bitvectors must be the same length\n-\n-Returns:\n-\n-True if `v0` was changed\n-*/\n+Both bitvectors must be the same length. Returns `true` if `v0` was changed\n+\"]\n fn assign(v0: t, v1: t) -> bool { let sub = right; ret process(v0, v1, sub); }\n \n-/*\n-Function: clone\n-\n-Makes a copy of a bitvector\n-*/\n+#[doc = \"Makes a copy of a bitvector\"]\n fn clone(v: t) -> t {\n     let storage = vec::to_mut(vec::init_elt(v.nbits / uint_bits + 1u, 0u));\n     let len = vec::len(v.storage);\n     uint::range(0u, len) {|i| storage[i] = v.storage[i]; };\n     ret @{storage: storage, nbits: v.nbits};\n }\n \n-/*\n-Function: get\n-\n-Retreive the value at index `i`\n-*/\n+#[doc = \"Retreive the value at index `i`\"]\n pure fn get(v: t, i: uint) -> bool {\n     assert (i < v.nbits);\n     let bits = uint_bits;\n@@ -139,19 +102,12 @@ pure fn get(v: t, i: uint) -> bool {\n \n // FIXME: This doesn't account for the actual size of the vectors,\n // so it could end up comparing garbage bits\n-/*\n-Function: equal\n-\n+#[doc = \"\n Compares two bitvectors\n \n-Preconditions:\n-\n-Both bitvectors must be the same length\n-\n-Returns:\n-\n-True if both bitvectors contain identical elements\n-*/\n+Both bitvectors must be the same length. Returns `true` if both bitvectors\n+contain identical elements.\n+\"]\n fn equal(v0: t, v1: t) -> bool {\n     // FIXME: when we can break or return from inside an iterator loop,\n     //        we can eliminate this painful while-loop\n@@ -165,67 +121,43 @@ fn equal(v0: t, v1: t) -> bool {\n     ret true;\n }\n \n-/*\n-Function: clear\n-\n-Set all bits to 0\n-*/\n+#[doc = \"Set all bits to 0\"]\n fn clear(v: t) {\n     uint::range(0u, vec::len(v.storage)) {|i| v.storage[i] = 0u; };\n }\n \n-/*\n-Function: set_all\n-\n-Set all bits to 1\n-*/\n+#[doc = \"Set all bits to 1\"]\n fn set_all(v: t) {\n     uint::range(0u, v.nbits) {|i| set(v, i, true); };\n }\n \n-/*\n-Function: invert\n-\n-Invert all bits\n-*/\n+#[doc = \"Invert all bits\"]\n fn invert(v: t) {\n     uint::range(0u, vec::len(v.storage)) {|i|\n         v.storage[i] = !v.storage[i];\n     };\n }\n \n-/*\n-Function: difference\n-\n+#[doc = \"\n Calculate the difference between two bitvectors\n \n Sets each element of `v0` to the value of that element minus the element\n-of `v1` at the same index.\n-\n-Preconditions:\n-\n-Both bitvectors must be the same length\n+of `v1` at the same index. Both bitvectors must be the same length.\n \n-Returns:\n-\n-True if `v0` was changed\n-*/\n+Returns `true` if `v0` was changed.\n+\"]\n fn difference(v0: t, v1: t) -> bool {\n     invert(v1);\n     let b = intersect(v0, v1);\n     invert(v1);\n     ret b;\n }\n \n-/*\n-Function: set\n-\n+#[doc = \"\n Set the value of a bit at a given index\n \n-Preconditions:\n-\n-`i` must be less than the length of the bitvector\n-*/\n+`i` must be less than the length of the bitvector.\n+\"]\n fn set(v: t, i: uint, x: bool) {\n     assert (i < v.nbits);\n     let bits = uint_bits;\n@@ -236,62 +168,50 @@ fn set(v: t, i: uint, x: bool) {\n }\n \n \n-/*\n-Function: is_true\n-\n-Returns true if all bits are 1\n-*/\n+#[doc = \"Returns true if all bits are 1\"]\n fn is_true(v: t) -> bool {\n     for i: uint in to_vec(v) { if i != 1u { ret false; } }\n     ret true;\n }\n \n \n-/*\n-Function: is_false\n-\n-Returns true if all bits are 0\n-*/\n+#[doc = \"Returns true if all bits are 0\"]\n fn is_false(v: t) -> bool {\n     for i: uint in to_vec(v) { if i == 1u { ret false; } }\n     ret true;\n }\n \n fn init_to_vec(v: t, i: uint) -> uint { ret if get(v, i) { 1u } else { 0u }; }\n \n-/*\n-Function: to_vec\n+#[doc = \"\n+Converts the bitvector to a vector of uint with the same length.\n \n-Converts the bitvector to a vector of uint with the same length. Each uint\n-in the resulting vector has either value 0u or 1u.\n-*/\n+Each uint in the resulting vector has either value 0u or 1u.\n+\"]\n fn to_vec(v: t) -> [uint] {\n     let sub = bind init_to_vec(v, _);\n     ret vec::init_fn::<uint>(v.nbits, sub);\n }\n \n-/*\n-Function: to_str\n \n-Converts the bitvector to a string. The resulting string has the same\n-length as the bitvector, and each character is either '0' or '1'.\n-*/\n+#[doc = \"\n+Converts the bitvector to a string.\n+\n+The resulting string has the same length as the bitvector, and each character\n+is either '0' or '1'.\n+\"]\n fn to_str(v: t) -> str {\n     let rs = \"\";\n     for i: uint in to_vec(v) { if i == 1u { rs += \"1\"; } else { rs += \"0\"; } }\n     ret rs;\n }\n \n-/*\n-Function: eq_vec\n-\n-Compare a bitvector to a vector of uint. The uint vector is expected to\n-only contain the values 0u and 1u.\n-\n-Preconditions:\n+#[doc = \"\n+Compare a bitvector to a vector of uint\n \n-Both the bitvector and vector must have the same length\n-*/\n+The uint vector is expected to only contain the values 0u and 1u. Both the\n+bitvector and vector must have the same length\n+\"]\n fn eq_vec(v0: t, v1: [uint]) -> bool {\n     assert (v0.nbits == vec::len::<uint>(v1));\n     let len = v0.nbits;"}, {"sha": "e17a44234f465e7258532ba20132e09e95829c74", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 27, "deletions": 52, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,6 +1,4 @@\n-/*\n-Module: c_vec\n-\n+#[doc = \"\n Library to interface with chunks of memory allocated in C.\n \n It is often desirable to safely interface with memory allocated from C,\n@@ -25,23 +23,20 @@ itself around, the c_vec could be garbage collected, and the memory within\n could be destroyed.  There are legitimate uses for the pointer elimination\n form -- for instance, to pass memory back into C -- but great care must be\n taken to ensure that a reference to the c_vec::t is still held if needed.\n-\n- */\n+\"];\n \n export t;\n export create, create_with_dtor;\n export get, set;\n export len;\n export ptr;\n \n-/*\n- Type: t\n-\n- The type representing a native chunk of memory.  Wrapped in a enum for\n- opacity; FIXME #818 when it is possible to have truly opaque types, this\n- should be revisited.\n- */\n+#[doc = \"\n+The type representing a native chunk of memory\n \n+Wrapped in a enum for opacity; FIXME #818 when it is possible to have\n+truly opaque types, this should be revisited.\n+\"]\n enum t<T> {\n     t({ base: *mutable T, len: uint, rsrc: @dtor_res})\n }\n@@ -57,36 +52,32 @@ resource dtor_res(dtor: option<fn@()>) {\n  Section: Introduction forms\n  */\n \n-/*\n-Function: create\n-\n+#[doc = \"\n Create a c_vec::t from a native buffer with a given length.\n \n-Parameters:\n+# Arguments\n \n-base - A native pointer to a buffer\n-len - The number of elements in the buffer\n-*/\n+* base - A native pointer to a buffer\n+* len - The number of elements in the buffer\n+\"]\n unsafe fn create<T>(base: *mutable T, len: uint) -> t<T> {\n     ret t({base: base,\n            len: len,\n            rsrc: @dtor_res(option::none)\n           });\n }\n \n-/*\n-Function: create_with_dtor\n-\n+#[doc = \"\n Create a c_vec::t from a native buffer, with a given length,\n and a function to run upon destruction.\n \n-Parameters:\n+# Arguments\n \n-base - A native pointer to a buffer\n-len - The number of elements in the buffer\n-dtor - A function to run when the value is destructed, useful\n-       for freeing the buffer, etc.\n-*/\n+* base - A native pointer to a buffer\n+* len - The number of elements in the buffer\n+* dtor - A function to run when the value is destructed, useful\n+         for freeing the buffer, etc.\n+\"]\n unsafe fn create_with_dtor<T>(base: *mutable T, len: uint, dtor: fn@())\n   -> t<T> {\n     ret t({base: base,\n@@ -99,29 +90,21 @@ unsafe fn create_with_dtor<T>(base: *mutable T, len: uint, dtor: fn@())\n  Section: Operations\n  */\n \n-/*\n-Function: get\n-\n+#[doc = \"\n Retrieves an element at a given index\n \n-Failure:\n-\n-If `ofs` is greater or equal to the length of the vector\n-*/\n+Fails if `ofs` is greater or equal to the length of the vector\n+\"]\n fn get<T: copy>(t: t<T>, ofs: uint) -> T {\n     assert ofs < len(t);\n     ret unsafe { *ptr::mut_offset((*t).base, ofs) };\n }\n \n-/*\n-Function: set\n-\n+#[doc = \"\n Sets the value of an element at a given index\n \n-Failure:\n-\n-If `ofs` is greater or equal to the length of the vector\n-*/\n+Fails if `ofs` is greater or equal to the length of the vector\n+\"]\n fn set<T: copy>(t: t<T>, ofs: uint, v: T) {\n     assert ofs < len(t);\n     unsafe { *ptr::mut_offset((*t).base, ofs) = v };\n@@ -131,20 +114,12 @@ fn set<T: copy>(t: t<T>, ofs: uint, v: T) {\n  Section: Elimination forms\n  */\n \n-/*\n-Function: len\n-\n-Returns the length of the vector\n-*/\n+#[doc = \"Returns the length of the vector\"]\n fn len<T>(t: t<T>) -> uint {\n     ret (*t).len;\n }\n \n-/*\n-Function: ptr\n-\n-Returns a pointer to the first element of the vector\n-*/\n+#[doc = \"Returns a pointer to the first element of the vector\"]\n unsafe fn ptr<T>(t: t<T>) -> *mutable T {\n     ret (*t).base;\n }"}, {"sha": "5278caf867e3729e557858082009cb7180fe36de", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,12 +1,4 @@\n-\n-\n-\n-/**\n- * Unsafe debugging functions for inspecting values.\n- *\n- * Your RUST_LOG environment variable must contain \"stdlib\" for any debug\n- * logging.\n- */\n+#[doc = \"Unsafe debugging functions for inspecting values.\"];\n \n #[abi = \"cdecl\"]\n native mod rustrt {"}, {"sha": "83452e6ab6800e6df2166dd4fe840f0266345097", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,40 +1,18 @@\n-import option::{some, none};\n-\n-/*\n-Module: deque\n+#[doc = \"A deque. Untested as of yet. Likely buggy\"];\n \n-A deque.  Untested as of yet.  Likely buggy.\n-*/\n+import option::{some, none};\n \n-/*\n-Iface: t\n-*/\n iface t<T> {\n-    // Method: size\n     fn size() -> uint;\n-    // Method: add_front\n     fn add_front(T);\n-    // Method: add_back\n     fn add_back(T);\n-    // Method: pop_front\n     fn pop_front() -> T;\n-    // Method: pop_back\n     fn pop_back() -> T;\n-    // Method: peek_front\n     fn peek_front() -> T;\n-    // Method: peek_back\n     fn peek_back() -> T;\n-    // Method: get\n     fn get(int) -> T;\n }\n \n-/*\n-Section: Functions\n-*/\n-\n-/*\n-Function: create\n-*/\n // FIXME eventually, a proper datatype plus an exported impl would be\n // preferrable\n fn create<T: copy>() -> t<T> {"}, {"sha": "744dc0a4c91e60f65494819d152d05006b149fd2", "filename": "src/libstd/four.rs", "status": "modified", "additions": 51, "deletions": 125, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Ffour.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Ffour.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffour.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,16 +1,14 @@\n // -*- rust -*-\n \n-/*\n-Module: four\n-\n+#[doc = \"\n The fourrternary Belnap relevance logic FOUR represented as ADT\n \n This allows reasoning with four logic values (true, false, none, both).\n \n Implementation: Truth values are represented using a single u8 and\n all operations are done using bit operations which is fast\n on current cpus.\n-*/\n+\"];\n \n import tri;\n \n@@ -19,152 +17,93 @@ export not, and, or, xor, implies, implies_materially;\n export eq, ne, is_true, is_false;\n export from_str, to_str, all_values, to_trit, to_bit;\n \n-/*\n-Type: t\n-\n+#[doc = \"\n The type of fourrternary logic values\n \n It may be thought of as  tuple `(y, x)` of two bools\n-\n-*/\n+\"]\n type t = u8;\n \n const b0: u8  = 1u8;\n const b1: u8  = 2u8;\n const b01: u8 = 3u8;\n \n-/*\n-Constant: none\n-\n-Logic value `(0, 0)` for bottom (neither true or false)\n-*/\n+#[doc = \"Logic value `(0, 0)` for bottom (neither true or false)\"]\n const none: t  = 0u8;\n \n-/*\n-Constant: true\n-\n-Logic value `(0, 1)` for truth\n-*/\n+#[doc = \"Logic value `(0, 1)` for truth\"]\n const true: t  = 1u8;\n \n-/*\n-Constant: false\n-\n-Logic value `(1, 0)` for falsehood\n-*/\n+#[doc = \"Logic value `(1, 0)` for falsehood\"]\n const false: t = 2u8;\n \n-/*\n-Constant: both\n-\n-Logic value `(1, 1)` for top (both true and false)\n-*/\n+#[doc = \"Logic value `(1, 1)` for top (both true and false)\"]\n const both: t  = 3u8;\n \n-/* Function: not\n-\n+#[doc = \"\n Negation/Inverse\n \n-Returns:\n-\n-`'(v.y, v.x)`\n-*/\n+Returns `'(v.y, v.x)`\n+\"]\n pure fn not(v: t) -> t { ((v << 1u8) | (v >> 1u8)) & b01 }\n \n-/* Function: and\n-\n+#[doc = \"\n Conjunction\n \n-Returns:\n-\n-`(a.x | b.x, a.y & b.y)`\n-*/\n+Returns `(a.x | b.x, a.y & b.y)`\n+\"]\n pure fn and(a: t, b: t) -> t { ((a & b) & b0) | ((a | b) & b1) }\n \n-/* Function: or\n-\n+#[doc = \"\n Disjunction\n \n-Returns:\n-\n-`(a.x & b.x, a.y | b.y)`\n-*/\n+Returns `(a.x & b.x, a.y | b.y)`\n+\"]\n pure fn or(a: t, b: t) -> t { ((a | b) & b0) | ((a & b) & b1) }\n \n-/* Function: xor\n-\n+#[doc = \"\n Classic exclusive or\n \n-Returns:\n-\n-`or(and(a, not(b)), and(not(a), b))`\n-*/\n+Returns `or(and(a, not(b)), and(not(a), b))`\n+\"]\n pure fn xor(a: t, b: t) -> t { or(and(a, not(b)), and(not(a), b)) }\n \n-/*\n-Function: implies\n-\n+#[doc = \"\n Strong implication (from `a` strongly follows `b`)\n \n-Returns:\n-\n-`( x1 & y2, !x1 | x2)`\n-*/\n+Returns `( x1 & y2, !x1 | x2)`\n+\"]\n pure fn implies(a: t, b: t) -> t { ((a << 1u8) & b & b1) | (((!a) | b) & b0) }\n \n-/*\n-Function: implies_materially\n-\n+#[doc = \"\n Classic (material) implication in the logic\n (from `a` materially follows `b`)\n \n-Returns:\n-\n-`or(not(a), b)`\n-*/\n+Returns `or(not(a), b)`\n+\"]\n pure fn implies_materially(a: t, b: t) -> t { or(not(a), b) }\n \n-/*\n-Predicate: eq\n-\n-Returns:\n-\n-true if truth values `a` and `b` are indistinguishable in the logic\n-*/\n+#[doc = \"\n+Returns true if truth values `a` and `b` are indistinguishable in the logic\n+\"]\n pure fn eq(a: t, b: t) -> bool { a == b }\n \n-/*\n-Predicate: ne\n-\n-Returns:\n-\n-true if truth values `a` and `b` are distinguishable in the logic\n-*/\n+#[doc = \"\n+Returns true if truth values `a` and `b` are distinguishable in the logic\n+\"]\n pure fn ne(a: t, b: t) -> bool { a != b }\n \n-/*\n-Predicate: is_true\n-\n-Returns:\n-\n-true if `v` represents truth in the logic (is `true` or `both`)\n-*/\n+#[doc = \"\n+Returns true if `v` represents truth in the logic (is `true` or `both`)\n+\"]\n pure fn is_true(v: t) -> bool { (v & b0) != 0u8 }\n \n-/*\n-Predicate: is_false\n-\n-Returns:\n-\n-true if `v` represents falsehood in the logic (is `false` or `none`)\n-*/\n+#[doc = \"\n+Returns true if `v` represents falsehood in the logic (is `false` or `none`)\n+\"]\n pure fn is_false(v: t) -> bool { (v & b0) == 0u8 }\n \n-/*\n-Function: from_str\n-\n-Parse logic value from `s`\n-*/\n+#[doc = \"Parse logic value from `s`\"]\n pure fn from_str(s: str) -> t {\n     alt check s {\n       \"none\" { none }\n@@ -174,11 +113,7 @@ pure fn from_str(s: str) -> t {\n     }\n }\n \n-/*\n-Function: to_str\n-\n-Convert `v` into a string\n-*/\n+#[doc = \"Convert `v` into a string\"]\n pure fn to_str(v: t) -> str {\n     // FIXME replace with consts as soon as that works\n     alt check v {\n@@ -189,35 +124,26 @@ pure fn to_str(v: t) -> str {\n     }\n }\n \n-/*\n-Function: all_values\n-\n-Iterates over all truth values by passing them to `blk`\n-in an unspecified order\n-*/\n+#[doc = \"\n+Iterates over all truth values by passing them to `blk` in an unspecified\n+order\n+\"]\n fn all_values(blk: fn(v: t)) {\n     blk(both);\n     blk(four::true);\n     blk(four::false);\n     blk(none);\n }\n \n-/*\n-Function: to_bit\n-\n-Returns:\n-\n-An u8 whose first bit is set if `if_true(v)` holds\n-*/\n+#[doc = \"\n+Returns an `u8` whose first bit is set if `if_true(v)` holds\n+\"]\n fn to_bit(v: t) -> u8 { v & b0 }\n \n-/*\n-Function: to_tri\n-\n-Returns:\n-\n-A trit of `v` (`both` and `none` are both coalesced into `trit::unknown`)\n-*/\n+#[doc = \"\n+Returns a trit of `v` (`both` and `none` are both coalesced into\n+`trit::unknown`)\n+\"]\n fn to_trit(v: t) -> tri::t { v & (v ^ not(v)) }\n \n #[cfg(test)]"}, {"sha": "3e1a11665fe36dc248c927ffabfc069c429be021", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 6, "deletions": 35, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,6 +1,4 @@\n-/*\n-Module: fun_treemap\n-\n+#[doc = \"\n A functional key,value store that works on anything.\n \n This works using a binary search tree. In the first version, it's a\n@@ -9,8 +7,7 @@ red-black tree or something else.\n \n This is copied and modified from treemap right now. It's missing a lot\n of features.\n-\n-*/\n+\"];\n \n import option::{some, none};\n import option = option;\n@@ -21,35 +18,17 @@ export insert;\n export find;\n export traverse;\n \n-/* Section: Types */\n-\n-/*\n-Type: treemap\n-*/\n type treemap<K, V> = @tree_node<K, V>;\n \n-/*\n-Tag: tree_node\n-*/\n enum tree_node<K, V> {\n     empty,\n     node(@K, @V, @tree_node<K, V>, @tree_node<K, V>)\n }\n \n-/* Section: Operations */\n-\n-/*\n-Function: init\n-\n-Create a treemap\n-*/\n+#[doc = \"Create a treemap\"]\n fn init<K, V>() -> treemap<K, V> { @empty }\n \n-/*\n-Function: insert\n-\n-Insert a value into the map\n-*/\n+#[doc = \"Insert a value into the map\"]\n fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n     @alt m {\n        @empty { node(@k, @v, @empty, @empty) }\n@@ -63,11 +42,7 @@ fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n      }\n }\n \n-/*\n-Function: find\n-\n-Find a value based on the key\n-*/\n+#[doc = \"Find a value based on the key\"]\n fn find<K, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n       empty { none }\n@@ -79,11 +54,7 @@ fn find<K, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n     }\n }\n \n-/*\n-Function: traverse\n-\n-Visit all pairs in the map in order.\n-*/\n+#[doc = \"Visit all pairs in the map in order.\"]\n fn traverse<K, V: copy>(m: treemap<K, V>, f: fn(K, V)) {\n     alt *m {\n       empty { }"}, {"sha": "2177f2468ef11565d814d9465ad622503f05ee66", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 64, "deletions": 119, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,49 +1,49 @@\n-/*\n-Module: getopts\n+#[doc = \"\n+Simple getopt alternative.\n \n-Simple getopt alternative. Construct a vector of options, either by using\n-reqopt, optopt, and optflag or by building them from components yourself, and\n-pass them to getopts, along with a vector of actual arguments (not including\n-argv[0]). You'll either get a failure code back, or a match.  You'll have to\n-verify whether the amount of 'free' arguments in the match is what you\n-expect. Use opt_* accessors to get argument values out of the match object.\n+Construct a vector of options, either by using reqopt, optopt, and optflag or\n+by building them from components yourself, and pass them to getopts, along\n+with a vector of actual arguments (not including argv[0]). You'll either get a\n+failure code back, or a match.  You'll have to verify whether the amount of\n+'free' arguments in the match is what you expect. Use opt_* accessors to get\n+argument values out of the match object.\n \n Single-character options are expected to appear on the command line with a\n single preceeding dash; multiple-character options are expected to be\n proceeded by two dashes. Options that expect an argument accept their argument\n following either a space or an equals sign.\n \n-Example:\n+# Example\n \n The following example shows simple command line parsing for an application\n that requires an input file to be specified, accepts an optional output file\n name following -o, and accepts both -h and --help as optional flags.\n \n-> fn main(args: [str]) {\n->   let opts = [\n->     optopt(\"o\"),\n->     optflag(\"h\"),\n->     optflag(\"help\")\n->   ];\n->   let match = alt getopts(vec::shift(args), opts) {\n->     ok(m) { m }\n->     err(f) { fail fail_str(f) }\n->   };\n->   if opt_present(match, \"h\") || opt_present(match, \"help\") {\n->     print_usage();\n->     ret;\n->   }\n->   let output = opt_maybe_str(match, \"o\");\n->   let input = if !vec::is_empty(match.free) {\n->     match.free[0]\n->   } else {\n->     print_usage();\n->     ret;\n->   }\n->   do_work(input, output);\n-> }\n-\n-*/\n+    fn main(args: [str]) {\n+        let opts = [\n+            optopt(\\\"o\\\"),\n+            optflag(\\\"h\\\"),\n+            optflag(\\\"help\\\")\n+        ];\n+        let match = alt getopts(vec::shift(args), opts) {\n+          ok(m) { m }\n+          err(f) { fail fail_str(f) }\n+        };\n+        if opt_present(match, \\\"h\\\") || opt_present(match, \\\"help\\\") {\n+            print_usage();\n+            ret;\n+        }\n+        let output = opt_maybe_str(match, \\\"o\\\");\n+        let input = if !vec::is_empty(match.free) {\n+            match.free[0]\n+        } else {\n+            print_usage();\n+            ret;\n+        }\n+        do_work(input, output);\n+    }\n+\n+\"];\n \n import core::result;\n import core::result::{err, ok};\n@@ -71,11 +71,7 @@ enum hasarg { yes, no, maybe, }\n \n enum occur { req, optional, multi, }\n \n-/*\n-Type: opt\n-\n-A description of a possible option\n-*/\n+#[doc = \"A description of a possible option\"]\n type opt = {name: name, hasarg: hasarg, occur: occur};\n \n fn mkname(nm: str) -> name {\n@@ -84,60 +80,40 @@ fn mkname(nm: str) -> name {\n         } else { long(nm) };\n }\n \n-/*\n-Function: reqopt\n-\n-Create an option that is required and takes an argument\n-*/\n+#[doc = \"Create an option that is required and takes an argument\"]\n fn reqopt(name: str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: req};\n }\n \n-/*\n-Function: optopt\n-\n-Create an option that is optional and takes an argument\n-*/\n+#[doc = \"Create an option that is optional and takes an argument\"]\n fn optopt(name: str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: optional};\n }\n \n-/*\n-Function: optflag\n-\n-Create an option that is optional and does not take an argument\n-*/\n+#[doc = \"Create an option that is optional and does not take an argument\"]\n fn optflag(name: str) -> opt {\n     ret {name: mkname(name), hasarg: no, occur: optional};\n }\n \n-/*\n-Function: optflagopt\n-\n-Create an option that is optional and takes an optional argument\n-*/\n+#[doc = \"Create an option that is optional and takes an optional argument\"]\n fn optflagopt(name: str) -> opt {\n     ret {name: mkname(name), hasarg: maybe, occur: optional};\n }\n \n-/*\n-Function: optmulti\n-\n+#[doc = \"\n Create an option that is optional, takes an argument, and may occur\n multiple times\n-*/\n+\"]\n fn optmulti(name: str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: multi};\n }\n \n enum optval { val(str), given, }\n \n-/*\n-Type: match\n-\n+#[doc = \"\n The result of checking command line arguments. Contains a vector\n of matches and a vector of free strings.\n-*/\n+\"]\n type match = {opts: [opt], vals: [mutable [optval]], free: [str]};\n \n fn is_arg(arg: str) -> bool {\n@@ -152,12 +128,10 @@ fn find_opt(opts: [opt], nm: name) -> option<uint> {\n     vec::position(opts, { |opt| opt.name == nm })\n }\n \n-/*\n-Type: fail_\n-\n+#[doc = \"\n The type returned when the command line does not conform to the\n expected format. Pass this value to <fail_str> to get an error message.\n-*/\n+\"]\n enum fail_ {\n     argument_missing(str),\n     unrecognized_option(str),\n@@ -166,11 +140,7 @@ enum fail_ {\n     unexpected_argument(str),\n }\n \n-/*\n-Function: fail_str\n-\n-Convert a <fail_> enum into an error string\n-*/\n+#[doc = \"Convert a `fail_` enum into an error string\"]\n fn fail_str(f: fail_) -> str {\n     ret alt f {\n           argument_missing(nm) { \"Argument to option '\" + nm + \"' missing.\" }\n@@ -185,30 +155,19 @@ fn fail_str(f: fail_) -> str {\n         };\n }\n \n-/*\n-Type: result\n-\n+#[doc = \"\n The result of parsing a command line with a set of options\n (result::t<match, fail_>)\n-\n-Variants:\n-\n-ok(match) - Returned from getopts on success\n-err(fail_) - Returned from getopts on failure\n-*/\n+\"]\n type result = result::t<match, fail_>;\n \n-/*\n-Function: getopts\n-\n+#[doc = \"\n Parse command line arguments according to the provided options\n \n-Returns:\n-\n-ok(match) - On success. Use functions such as <opt_present>\n-            <opt_str>, etc. to interrogate results.\n-err(fail_) - On failure. Use <fail_str> to get an error message.\n-*/\n+On success returns `ok(opt)`. Use functions such as `opt_present` `opt_str`,\n+etc. to interrogate results.  Returns `err(fail_)` on failure. Use <fail_str>\n+to get an error message.\n+\"]\n fn getopts(args: [str], opts: [opt]) -> result unsafe {\n     let n_opts = vec::len::<opt>(opts);\n     fn f(_x: uint) -> [optval] { ret []; }\n@@ -311,35 +270,25 @@ fn opt_vals(m: match, nm: str) -> [optval] {\n \n fn opt_val(m: match, nm: str) -> optval { ret opt_vals(m, nm)[0]; }\n \n-/*\n-Function: opt_present\n-\n-Returns true if an option was matched\n-*/\n+#[doc = \"Returns true if an option was matched\"]\n fn opt_present(m: match, nm: str) -> bool {\n     ret vec::len::<optval>(opt_vals(m, nm)) > 0u;\n }\n \n-/*\n-Function: opt_str\n-\n+#[doc = \"\n Returns the string argument supplied to a matching option\n \n-Failure:\n-\n-- If the option was not matched\n-- If the match did not take an argument\n-*/\n+Fails if the option was not matched or if the match did not take an argument\n+\"]\n fn opt_str(m: match, nm: str) -> str {\n     ret alt opt_val(m, nm) { val(s) { s } _ { fail } };\n }\n \n-/*\n-Function: opt_str\n-\n+#[doc = \"\n Returns a vector of the arguments provided to all matches of the given option.\n+\n Used when an option accepts multiple values.\n-*/\n+\"]\n fn opt_strs(m: match, nm: str) -> [str] {\n     let acc: [str] = [];\n     for v: optval in opt_vals(m, nm) {\n@@ -348,27 +297,23 @@ fn opt_strs(m: match, nm: str) -> [str] {\n     ret acc;\n }\n \n-/*\n-Function: opt_str\n-\n+#[doc = \"\n Returns the string argument supplied to a matching option or none\n-*/\n+\"]\n fn opt_maybe_str(m: match, nm: str) -> option<str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n     ret alt vals[0] { val(s) { some::<str>(s) } _ { none::<str> } };\n }\n \n \n-/*\n-Function: opt_default\n-\n+#[doc = \"\n Returns the matching string, a default, or none\n \n Returns none if the option was not present, `def` if the option was\n present but no argument was provided, and the argument if the option was\n present and an argument was provided.\n-*/\n+\"]\n fn opt_default(m: match, nm: str, def: str) -> option<str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { ret none::<str>; }"}, {"sha": "499e3f36061fd9a869bf93654bcf5f159eff3bb4", "filename": "src/libstd/json.rs", "status": "modified", "additions": 8, "deletions": 37, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,6 +1,8 @@\n // Rust JSON serialization library\n // Copyright (c) 2011 Google Inc.\n \n+#[doc = \"json serialization\"];\n+\n import result::{ok, err};\n import io;\n import io::{reader_util, writer_util};\n@@ -22,23 +24,13 @@ export list;\n export dict;\n export null;\n \n-/*\n-Tag: json\n-\n-Represents a json value.\n-*/\n+#[doc = \"Represents a json value\"]\n enum json {\n-    /* Variant: num */\n     num(float),\n-    /* Variant: string */\n     string(str),\n-    /* Variant: boolean */\n     boolean(bool),\n-    /* Variant: list */\n     list([json]),\n-    /* Variant: dict */\n     dict(map::hashmap<str,json>),\n-    /* Variant: null */\n     null,\n }\n \n@@ -48,11 +40,7 @@ type error = {\n     msg: str,\n };\n \n-/*\n-Function: to_writer\n-\n-Serializes a json value into a io::writer.\n-*/\n+#[doc = \"Serializes a json value into a io::writer\"]\n fn to_writer(wr: io::writer, j: json) {\n     alt j {\n       num(n) { wr.write_str(float::to_str(n, 6u)); }\n@@ -114,11 +102,7 @@ fn to_writer(wr: io::writer, j: json) {\n     }\n }\n \n-/*\n-Function: to_str\n-\n-Serializes a json value into a string.\n-*/\n+#[doc = \"Serializes a json value into a string\"]\n fn to_str(j: json) -> str {\n     io::with_str_writer { |wr| to_writer(wr, j) }\n }\n@@ -469,12 +453,7 @@ impl parser for parser {\n     }\n }\n \n-/*\n-Function: from_reader\n-\n-Deserializes a json value from an io::reader.\n-*/\n-\n+#[doc = \"Deserializes a json value from an io::reader\"]\n fn from_reader(rdr: io::reader) -> result::t<json, error> {\n     let parser = {\n         rdr: rdr,\n@@ -486,20 +465,12 @@ fn from_reader(rdr: io::reader) -> result::t<json, error> {\n     parser.parse()\n }\n \n-/*\n-Function: from_str\n-\n-Deserializes a json value from a string.\n-*/\n+#[doc = \"Deserializes a json value from a string\"]\n fn from_str(s: str) -> result::t<json, error> {\n     io::with_str_reader(s, from_reader)\n }\n \n-/*\n-Function: eq\n-\n-Test if two json values are equal.\n-*/\n+#[doc = \"Test if two json values are equal\"]\n fn eq(value0: json, value1: json) -> bool {\n     alt (value0, value1) {\n       (num(f0), num(f1)) { f0 == f1 }"}, {"sha": "613a4790d363ef957d095b1cdba6887a70fe3a16", "filename": "src/libstd/list.rs", "status": "modified", "additions": 21, "deletions": 74, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,66 +1,45 @@\n-/*\n-Module: list\n-\n-A standard linked list\n-*/\n+#[doc = \"A standard linked list\"];\n \n import core::option;\n import option::*;\n import option::{some, none};\n \n-/* Section: Types */\n-\n-/*\n-Tag: list\n-*/\n enum list<T> {\n-    /* Variant: cons */\n     cons(T, @list<T>),\n-    /* Variant: nil */\n     nil,\n }\n \n-/*Section: Operations */\n-\n-/*\n-Function: from_vec\n-\n-Create a list from a vector\n-*/\n+#[doc = \"Create a list from a vector\"]\n fn from_vec<T: copy>(v: [const T]) -> list<T> {\n     *vec::foldr(v, @nil::<T>, { |h, t| @cons(h, t) })\n }\n \n-/*\n-Function: foldl\n-\n+#[doc = \"\n Left fold\n \n-Applies `f` to `u` and the first element in the list, then applies\n-`f` to the result of the previous call and the second element,\n-and so on, returning the accumulated result.\n+Applies `f` to `u` and the first element in the list, then applies `f` to the\n+result of the previous call and the second element, and so on, returning the\n+accumulated result.\n \n-Parameters:\n+# Arguments\n \n-ls - The list to fold\n-z - The initial value\n-f - The function to apply\n-*/\n+* ls - The list to fold\n+* z - The initial value\n+* f - The function to apply\n+\"]\n fn foldl<T: copy, U>(ls: list<U>, z: T, f: fn(T, U) -> T) -> T {\n     let accum: T = z;\n     iter(ls) {|elt| accum = f(accum, elt);}\n     accum\n }\n \n-/*\n-Function: find\n-\n+#[doc = \"\n Search for an element that matches a given predicate\n \n Apply function `f` to each element of `v`, starting from the first.\n When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n-*/\n+\"]\n fn find<T: copy, U: copy>(ls: list<T>, f: fn(T) -> option<U>)\n     -> option<U> {\n     let ls = ls;\n@@ -75,11 +54,7 @@ fn find<T: copy, U: copy>(ls: list<T>, f: fn(T) -> option<U>)\n     ret none;\n }\n \n-/*\n-Function: has\n-\n-Returns true if a list contains an element with the given value\n-*/\n+#[doc = \"Returns true if a list contains an element with the given value\"]\n fn has<T: copy>(ls: list<T>, elt: T) -> bool {\n     let ls = ls;\n     while true {\n@@ -91,76 +66,48 @@ fn has<T: copy>(ls: list<T>, elt: T) -> bool {\n     ret false;\n }\n \n-/*\n-Function: is_empty\n-\n-Returns true if the list is empty.\n-*/\n+#[doc = \"Returns true if the list is empty\"]\n pure fn is_empty<T: copy>(ls: list<T>) -> bool {\n     alt ls {\n         nil { true }\n         _ { false }\n     }\n }\n \n-/*\n-Function: is_not_empty\n-\n-Returns true if the list is not empty.\n-*/\n+#[doc = \"Returns true if the list is not empty\"]\n pure fn is_not_empty<T: copy>(ls: list<T>) -> bool {\n     ret !is_empty(ls);\n }\n \n-/*\n-Function: len\n-\n-Returns the length of a list\n-*/\n+#[doc = \"Returns the length of a list\"]\n fn len<T>(ls: list<T>) -> uint {\n     let count = 0u;\n     iter(ls) {|_e| count += 1u;}\n     count\n }\n \n-/*\n-Function: tail\n-\n-Returns all but the first element of a list\n-*/\n+#[doc = \"Returns all but the first element of a list\"]\n pure fn tail<T: copy>(ls: list<T>) -> list<T> {\n     alt ls {\n         cons(_, tl) { ret *tl; }\n         nil { fail \"list empty\" }\n     }\n }\n \n-/*\n-Function: head\n-\n-Returns the first element of a list\n-*/\n+#[doc = \"Returns the first element of a list\"]\n pure fn head<T: copy>(ls: list<T>) -> T {\n     alt check ls { cons(hd, _) { hd } }\n }\n \n-/*\n-Function: append\n-\n-Appends one list to another\n-*/\n+#[doc = \"Appends one list to another\"]\n pure fn append<T: copy>(l: list<T>, m: list<T>) -> list<T> {\n     alt l {\n       nil { ret m; }\n       cons(x, xs) { let rest = append(*xs, m); ret cons(x, @rest); }\n     }\n }\n \n-/*\n-Function: iter\n-\n-Iterate over a list\n-*/\n+#[doc = \"Iterate over a list\"]\n fn iter<T>(l: list<T>, f: fn(T)) {\n     alt l {\n       cons(hd, tl) {"}, {"sha": "6eae6992bcb360b9dd56558804b28f06b17243f5", "filename": "src/libstd/map.rs", "status": "modified", "additions": 33, "deletions": 93, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,107 +1,65 @@\n-/*\n-Module: map\n-\n-A map type\n-*/\n+#[doc = \"A map type\"];\n \n import chained::hashmap;\n export hashmap, hashfn, eqfn, set, map, chained, mk_hashmap, new_str_hash;\n export new_bytes_hash, new_int_hash, new_uint_hash, set_add;\n \n-/* Section: Types */\n+#[doc = \"\n+A function that returns a hash of a value\n \n-/*\n-Type: hashfn\n-\n-A function that returns a hash of a value.\n-The hash should concentrate entropy in the\n-lower bits.\n-*/\n+The hash should concentrate entropy in the lower bits.\n+\"]\n type hashfn<K> = fn@(K) -> uint;\n \n-/*\n-Type: eqfn\n-\n-Equality\n-*/\n type eqfn<K> = fn@(K, K) -> bool;\n \n-/*\n-Type: set\n-\n-A convenience type to treat a hashmap as a set\n-*/\n+#[doc = \"A convenience type to treat a hashmap as a set\"]\n type set<K> = hashmap<K, ()>;\n \n type hashmap<K, V> = chained::t<K, V>;\n \n-/*\n-IFace: map\n-*/\n iface map<K: copy, V: copy> {\n-    /*\n-    Method: size\n-\n-    Return the number of elements in the map\n-    */\n+    #[doc = \"Return the number of elements in the map\"]\n     fn size() -> uint;\n-    /*\n-    Method: insert\n \n-    Add a value to the map. If the map already contains a value for\n-    the specified key then the original value is replaced.\n+    #[doc = \"\n+    Add a value to the map.\n \n-    Returns:\n+    If the map already contains a value for the specified key then the\n+    original value is replaced.\n \n-    True if the key did not already exist in the map\n-    */\n+    Returns true if the key did not already exist in the map\n+    \"]\n     fn insert(K, V) -> bool;\n-    /*\n-    Method: contains_key\n \n-    Returns true if the map contains a value for the specified key\n-    */\n+    #[doc = \"Returns true if the map contains a value for the specified key\"]\n     fn contains_key(K) -> bool;\n-    /*\n-    Method: get\n-\n-    Get the value for the specified key\n \n-    Failure:\n-\n-    If the key does not exist in the map\n-    */\n+    #[doc = \"\n+    Get the value for the specified key. Fails if the key does not exist in\n+    the map.\n+    \"]\n     fn get(K) -> V;\n-    /*\n-    Method: find\n \n-    Get the value for the specified key. If the key does not exist\n-    in the map then returns none.\n-    */\n+    #[doc = \"\n+    Get the value for the specified key. If the key does not exist in\n+    the map then returns none.\n+    \"]\n     fn find(K) -> option<V>;\n-    /*\n-    Method: remove\n \n+    #[doc = \"\n     Remove and return a value from the map. If the key does not exist\n     in the map then returns none.\n-    */\n+    \"]\n     fn remove(K) -> option<V>;\n-    /*\n-    Method: items\n \n-    Iterate over all the key/value pairs in the map\n-    */\n+    #[doc = \"Iterate over all the key/value pairs in the map\"]\n     fn items(fn(K, V));\n-    /*\n-    Method: keys\n \n-    Iterate over all the keys in the map\n-    */\n+    #[doc = \"Iterate over all the keys in the map\"]\n     fn keys(fn(K));\n \n-    /*\n-    Iterate over all the values in the map\n-    */\n+    #[doc = \"Iterate over all the values in the map\"]\n     fn values(fn(V));\n }\n \n@@ -345,51 +303,33 @@ fn mk_hashmap<K: copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>)\n     chained::mk(hasher, eqer)\n }\n \n-/*\n-Function: new_str_hash\n-\n-Construct a hashmap for string keys\n-*/\n+#[doc = \"Construct a hashmap for string keys\"]\n fn new_str_hash<V: copy>() -> hashmap<str, V> {\n     ret mk_hashmap(str::hash, str::eq);\n }\n \n-/*\n-Function: new_bytes_hash\n-\n-Construct a hashmap for byte string keys\n-*/\n+#[doc = \"Construct a hashmap for byte string keys\"]\n fn new_bytes_hash<V: copy>() -> hashmap<[u8], V> {\n     ret mk_hashmap(vec::u8::hash, vec::u8::eq);\n }\n \n-/*\n-Function: new_int_hash\n-\n-Construct a hashmap for int keys\n-*/\n+#[doc = \"Construct a hashmap for int keys\"]\n fn new_int_hash<V: copy>() -> hashmap<int, V> {\n     fn hash_int(&&x: int) -> uint { int::hash(x) }\n     fn eq_int(&&a: int, &&b: int) -> bool { ret a == b; }\n     ret mk_hashmap(hash_int, eq_int);\n }\n \n-/*\n-Function: new_uint_hash\n-\n-Construct a hashmap for uint keys\n-*/\n+#[doc = \"Construct a hashmap for uint keys\"]\n fn new_uint_hash<V: copy>() -> hashmap<uint, V> {\n     fn hash_uint(&&x: uint) -> uint { uint::hash(x) }\n     fn eq_uint(&&a: uint, &&b: uint) -> bool { ret a == b; }\n     ret mk_hashmap(hash_uint, eq_uint);\n }\n \n-/*\n-Function: set_add\n-\n+#[doc = \"\n Convenience function for adding keys to a hashmap with nil type keys\n-*/\n+\"]\n fn set_add<K>(set: set<K>, key: K) -> bool { ret set.insert(key, ()); }\n \n #[cfg(test)]"}, {"sha": "796b87bb7472e77c9a203810c63aeec166b68035", "filename": "src/libstd/net.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,17 +1,7 @@\n-/*\n-Module: net\n-*/\n-\n import vec;\n import uint;\n \n-/* Section: Types */\n-\n-/*\n-Tag: ip_addr\n-\n-An IP address\n-*/\n+#[doc = \"An IP address\"]\n enum ip_addr {\n     /*\n     Variant: ipv4\n@@ -21,13 +11,7 @@ enum ip_addr {\n     ipv4(u8, u8, u8, u8),\n }\n \n-/* Section: Operations */\n-\n-/*\n-Function: format_addr\n-\n-Convert an <ip_addr> to a str\n-*/\n+#[doc = \"Convert an `ip_addr` to a str\"]\n fn format_addr(ip: ip_addr) -> str {\n     alt ip {\n       ipv4(a, b, c, d) {\n@@ -37,17 +21,13 @@ fn format_addr(ip: ip_addr) -> str {\n     }\n }\n \n-/*\n-Function: parse_addr\n-\n-Convert a str to <ip_addr>\n-\n-Converts a string of the format \"x.x.x.x\" into an ip_addr enum.\n+#[doc = \"\n+Convert a str to `ip_addr`\n \n-Failure:\n+Converts a string of the format `x.x.x.x` into an ip_addr enum.\n \n-String must be a valid IPv4 address\n-*/\n+Fails if the string is not a valid IPv4 address\n+\"]\n fn parse_addr(ip: str) -> ip_addr {\n     let parts = vec::map(str::split_char(ip, '.'), {|s|\n         alt uint::from_str(s) {"}, {"sha": "f9052e6c84870ffe633fe2a85e64185c47b2c4bf", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 7, "deletions": 39, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,8 +1,4 @@\n-/*\n-Module: rand\n-\n-Random number generation\n-*/\n+#[doc = \"Random number generation\"]\n \n enum rctx {}\n \n@@ -13,52 +9,24 @@ native mod rustrt {\n     fn rand_free(c: *rctx);\n }\n \n-/* Section: Types */\n-\n-/*\n-Obj: rng\n-\n-A random number generator\n-*/\n+#[doc = \"A random number generator\"]\n iface rng {\n-    /*\n-    Method: next\n-\n-    Return the next random integer\n-    */\n+    #[doc = \"Return the next random integer\"]\n     fn next() -> u32;\n \n-    /*\n-    Method: next_float\n-\n-    Return the next random float\n-    */\n+    #[doc = \"Return the next random float\"]\n     fn next_float() -> float;\n \n-    /*\n-    Method: gen_str\n-\n-    Return a random string composed of A-Z, a-z, 0-9.\n-    */\n+    #[doc = \"Return a random string composed of A-Z, a-z, 0-9.\"]\n     fn gen_str(len: uint) -> str;\n \n-    /*\n-    Method: gen_bytes\n-\n-    Return a random byte string.\n-    */\n+    #[doc = \"Return a random byte string.\"]\n     fn gen_bytes(len: uint) -> [u8];\n }\n \n resource rand_res(c: *rctx) { rustrt::rand_free(c); }\n \n-/* Section: Operations */\n-\n-/*\n-Function: mk_rng\n-\n-Create a random number generator\n-*/\n+#[doc = \"Create a random number generator\"]\n fn mk_rng() -> rng {\n     impl of rng for @rand_res {\n         fn next() -> u32 { ret rustrt::rand_next(**self); }"}, {"sha": "1166241f010bda2a98266869c501b600cb7049d2", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 296, "deletions": 390, "changes": 686, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,7 +1,4 @@\n-/*\n-Module: rope\n-\n-\n+#[doc = \"\n High-level text containers.\n \n Ropes are a high-level representation of text that offers\n@@ -18,79 +15,70 @@ structure of ropes makes them suitable as a form of index to speed-up\n access to Unicode characters by index in long chunks of text.\n \n The following operations are algorithmically faster in ropes:\n-- extracting a subrope is logarithmic (linear in strings);\n-- appending/prepending is near-constant time (linear in strings);\n-- concatenation is near-constant time (linear in strings);\n-- char length is constant-time (linear in strings);\n-- access to a character by index is logarithmic (linear in strings);\n- */\n \n+* extracting a subrope is logarithmic (linear in strings);\n+* appending/prepending is near-constant time (linear in strings);\n+* concatenation is near-constant time (linear in strings);\n+* char length is constant-time (linear in strings);\n+* access to a character by index is logarithmic (linear in strings);\n+\"];\n \n-/*\n- Type: rope\n \n- The type of ropes.\n- */\n+#[doc = \"The type of ropes.\"]\n type rope = node::root;\n \n /*\n  Section: Creating a rope\n  */\n \n-/*\n- Function:empty\n-\n- Create an empty rope\n- */\n+#[doc = \"Create an empty rope\"]\n fn empty() -> rope {\n    ret node::empty;\n }\n \n-/*\n- Function: of_str\n-\n- Adopt a string as a rope.\n+#[doc = \"\n+Adopt a string as a rope.\n \n- Parameters:\n+# Arguments\n \n-str - A valid string.\n+* str - A valid string.\n \n- Returns:\n+# Return value\n \n A rope representing the same string as `str`. Depending of the length\n of `str`, this rope may be empty, flat or complex.\n \n-Performance notes:\n-- this operation does not copy the string;\n-- the function runs in linear time.\n- */\n+# Performance notes\n+\n+* this operation does not copy the string;\n+* the function runs in linear time.\n+\"]\n fn of_str(str: @str) -> rope {\n     ret of_substr(str, 0u, str::len(*str));\n }\n \n-/*\n-Function: of_substr\n-\n+#[doc = \"\n As `of_str` but for a substring.\n \n-Performance note:\n-- this operation does not copy the substring.\n+# Arguments\n+* byte_offset - The offset of `str` at which the rope starts.\n+* byte_len - The number of bytes of `str` to use.\n \n-Parameters:\n+# Return value\n \n-byte_offset - The offset of `str` at which the rope starts.\n-byte_len    - The number of bytes of `str` to use.\n+A rope representing the same string as `str::substr(str, byte_offset,\n+byte_len)`.  Depending on `byte_len`, this rope may be empty, flat or\n+complex.\n \n-Returns:\n+# Performance note\n \n-A rope representing the same string as\n-`str::substr(str, byte_offset, byte_len)`.\n-Depending on `byte_len`, this rope may be empty, flat or complex.\n+This operation does not copy the substring.\n \n-Safety notes:\n-- this function does _not_ check the validity of the substring;\n-- this function fails if `byte_offset` or `byte_len` do not match `str`.\n- */\n+# Safety notes\n+\n+* this function does _not_ check the validity of the substring;\n+* this function fails if `byte_offset` or `byte_len` do not match `str`.\n+\"]\n fn of_substr(str: @str, byte_offset: uint, byte_len: uint) -> rope {\n     if byte_len == 0u { ret node::empty; }\n     if byte_offset + byte_len  > str::len(*str) { fail; }\n@@ -101,59 +89,49 @@ fn of_substr(str: @str, byte_offset: uint, byte_len: uint) -> rope {\n Section: Adding things to a rope\n  */\n \n-/*\n-Function: append_char\n-\n+#[doc = \"\n Add one char to the end of the rope\n \n-Performance note:\n-- this function executes in near-constant time\n- */\n+# Performance note\n+\n+* this function executes in near-constant time\n+\"]\n fn append_char(rope: rope, char: char) -> rope {\n     ret append_str(rope, @str::from_chars([char]));\n }\n \n-/*\n-Function: append_str\n-\n+#[doc = \"\n Add one string to the end of the rope\n \n-Performance note:\n-- this function executes in near-linear time\n- */\n+# Performance note\n+\n+* this function executes in near-linear time\n+\"]\n fn append_str(rope: rope, str: @str) -> rope {\n     ret append_rope(rope, of_str(str))\n }\n \n-/*\n-Function: prepend_char\n-\n+#[doc = \"\n Add one char to the beginning of the rope\n \n-Performance note:\n-- this function executes in near-constant time\n- */\n+# Performance note\n+* this function executes in near-constant time\n+\"]\n fn prepend_char(rope: rope, char: char) -> rope {\n     ret prepend_str(rope, @str::from_chars([char]));\n }\n \n-/*\n-Function: prepend_str\n-\n+#[doc = \"\n Add one string to the beginning of the rope\n \n-Performance note:\n-- this function executes in near-linear time\n- */\n+# Performance note\n+* this function executes in near-linear time\n+\"]\n fn prepend_str(rope: rope, str: @str) -> rope {\n     ret append_rope(of_str(str), rope)\n }\n \n-/*\n-Function: append_rope\n-\n-Concatenate two ropes\n- */\n+#[doc = \"Concatenate two ropes\"]\n fn append_rope(left: rope, right: rope) -> rope {\n    alt(left) {\n      node::empty { ret right; }\n@@ -168,15 +146,13 @@ fn append_rope(left: rope, right: rope) -> rope {\n    }\n }\n \n-/*\n-Function: concat\n-\n+#[doc = \"\n Concatenate many ropes.\n \n If the ropes are balanced initially and have the same height, the resulting\n rope remains balanced. However, this function does not take any further\n measure to ensure that the result is balanced.\n- */\n+\"]\n fn concat(v: [rope]) -> rope {\n     //Copy `v` into a mutable vector\n     let len   = vec::len(v);\n@@ -209,19 +185,17 @@ Section: Keeping ropes healthy\n  */\n \n \n-/*\n-Function: bal\n-\n+#[doc = \"\n Balance a rope.\n \n-Returns:\n+# Return value\n \n A copy of the rope in which small nodes have been grouped in memory,\n and with a reduced height.\n \n If you perform numerous rope concatenations, it is generally a good idea\n to rebalance your rope at some point, before using it for other purposes.\n- */\n+\"]\n fn bal(rope:rope) -> rope {\n     alt(rope) {\n       node::empty { ret rope }\n@@ -239,19 +213,19 @@ Section: Transforming ropes\n  */\n \n \n-/*\n-Function: sub_chars\n-\n+#[doc = \"\n Extract a subrope from a rope.\n \n-Performance note:\n-- on a balanced rope, this operation takes algorithmic time;\n-- this operation does not involve any copying\n+# Performance note\n \n-Safety note:\n-- this function fails if char_offset/char_len do not represent\n-valid positions in rope\n- */\n+* on a balanced rope, this operation takes algorithmic time;\n+* this operation does not involve any copying\n+\n+# Safety note\n+\n+* this function fails if char_offset/char_len do not represent\n+  valid positions in rope\n+\"]\n fn sub_chars(rope: rope, char_offset: uint, char_len: uint) -> rope {\n     if char_len == 0u { ret node::empty; }\n     alt(rope) {\n@@ -265,19 +239,19 @@ fn sub_chars(rope: rope, char_offset: uint, char_len: uint) -> rope {\n     }\n }\n \n-/*\n-Function:sub_bytes\n-\n+#[doc = \"\n Extract a subrope from a rope.\n \n-Performance note:\n-- on a balanced rope, this operation takes algorithmic time;\n-- this operation does not involve any copying\n+# Performance note\n \n-Safety note:\n-- this function fails if byte_offset/byte_len do not represent\n-valid positions in rope\n- */\n+* on a balanced rope, this operation takes algorithmic time;\n+* this operation does not involve any copying\n+\n+# Safety note\n+\n+* this function fails if byte_offset/byte_len do not represent\n+  valid positions in rope\n+\"]\n fn sub_bytes(rope: rope, byte_offset: uint, byte_len: uint) -> rope {\n     if byte_len == 0u { ret node::empty; }\n     alt(rope) {\n@@ -295,18 +269,16 @@ fn sub_bytes(rope: rope, byte_offset: uint, byte_len: uint) -> rope {\n Section: Comparing ropes\n  */\n \n-/*\n-Function: cmp\n-\n+#[doc = \"\n Compare two ropes by Unicode lexicographical order.\n \n This function compares only the contents of the rope, not their structure.\n \n-Returns:\n+# Return value\n \n A negative value if `left < right`, 0 if eq(left, right) or a positive\n value if `left > right`\n-*/\n+\"]\n fn cmp(left: rope, right: rope) -> int {\n     alt((left, right)) {\n       (node::empty, node::empty) { ret 0; }\n@@ -318,78 +290,70 @@ fn cmp(left: rope, right: rope) -> int {\n     }\n }\n \n-/*\n-Function: eq\n-\n-Returns:\n-\n- `true` if both ropes have the same content (regardless of their structure),\n-`false` otherwise\n-*/\n+#[doc = \"\n+Returns `true` if both ropes have the same content (regardless of\n+their structure), `false` otherwise\n+\"]\n fn eq(left: rope, right: rope) -> bool {\n     ret cmp(left, right) == 0;\n }\n \n-/*\n-Function: le\n+#[doc = \"\n+# Arguments\n \n-Parameters\n-  left - an arbitrary rope\n-  right - an arbitrary rope\n+* left - an arbitrary rope\n+* right - an arbitrary rope\n \n-Returns:\n+# Return value\n \n- `true` if `left <= right` in lexicographical order (regardless of their\n+`true` if `left <= right` in lexicographical order (regardless of their\n structure), `false` otherwise\n-*/\n+\"]\n fn le(left: rope, right: rope) -> bool {\n     ret cmp(left, right) <= 0;\n }\n \n-/*\n-Function: lt\n+#[doc = \"\n+# Arguments\n \n-Parameters\n-  left - an arbitrary rope\n-  right - an arbitrary rope\n+* left - an arbitrary rope\n+* right - an arbitrary rope\n \n-Returns:\n+# Return value\n \n- `true` if `left < right` in lexicographical order (regardless of their\n+`true` if `left < right` in lexicographical order (regardless of their\n structure), `false` otherwise\n-*/\n+\"]\n fn lt(left: rope, right: rope) -> bool {\n     ret cmp(left, right) < 0;\n }\n \n-/*\n-Function: ge\n+#[doc = \"\n+# Arguments\n \n-Parameters\n-  left - an arbitrary rope\n-  right - an arbitrary rope\n+* left - an arbitrary rope\n+* right - an arbitrary rope\n \n-Returns:\n+# Return value\n \n  `true` if `left >= right` in lexicographical order (regardless of their\n structure), `false` otherwise\n-*/\n+\"]\n fn ge(left: rope, right: rope) -> bool {\n     ret cmp(left, right) >= 0;\n }\n \n-/*\n-Function: gt\n+#[doc = \"\n+# Arguments\n \n-Parameters\n-  left - an arbitrary rope\n-  right - an arbitrary rope\n+* left - an arbitrary rope\n+* right - an arbitrary rope\n \n-Returns:\n+# Return value\n \n- `true` if `left > right` in lexicographical order (regardless of their\n+`true` if `left > right` in lexicographical order (regardless of their\n structure), `false` otherwise\n-*/\n+\"]\n fn gt(left: rope, right: rope) -> bool {\n     ret cmp(left, right) > 0;\n }\n@@ -398,9 +362,7 @@ fn gt(left: rope, right: rope) -> bool {\n Section: Iterating\n  */\n \n-/*\n-Function: loop_chars\n-\n+#[doc = \"\n Loop through a rope, char by char\n \n While other mechanisms are available, this is generally the best manner\n@@ -409,42 +371,39 @@ loop that iterates through the contents string by string (e.g. to print\n the contents of the rope or output it to the system), however,\n you should rather use `traverse_components`.\n \n-Parameters:\n-rope - A rope to traverse. It may be empty.\n-it - A block to execute with each consecutive character of the rope.\n-Return `true` to continue, `false` to stop.\n+# Arguments\n+\n+* rope - A rope to traverse. It may be empty.\n+* it - A block to execute with each consecutive character of the rope.\n+       Return `true` to continue, `false` to stop.\n \n-Returns:\n+# Return value\n \n `true` If execution proceeded correctly, `false` if it was interrupted,\n that is if `it` returned `false` at any point.\n- */\n+\"]\n fn loop_chars(rope: rope, it: fn(char) -> bool) -> bool {\n    alt(rope) {\n       node::empty { ret true }\n       node::content(x) { ret node::loop_chars(x, it) }\n    }\n }\n \n-/*\n-Function: iter_chars\n-\n+#[doc = \"\n Loop through a rope, char by char, until the end.\n \n-Parameters:\n-rope - A rope to traverse. It may be empty\n-it - A block to execute with each consecutive character of the rope.\n- */\n+# Arguments\n+* rope - A rope to traverse. It may be empty\n+* it - A block to execute with each consecutive character of the rope.\n+\"]\n fn iter_chars(rope: rope, it: fn(char)) {\n     loop_chars(rope) {|x|\n         it(x);\n         ret true\n     };\n }\n \n-/*\n-Function: loop_leaves\n-\n+#[doc =\"\n Loop through a rope, string by string\n \n While other mechanisms are available, this is generally the best manner of\n@@ -455,17 +414,17 @@ a file, etc.. If you prefer a loop that iterates through the contents\n char by char (e.g. to search for a char), however, you should rather\n use `traverse`.\n \n-Parameters:\n+# Arguments\n \n-rope - A rope to traverse. It may be empty\n-it - A block to execute with each consecutive string component of the rope.\n-Return `true` to continue, `false` to stop\n+* rope - A rope to traverse. It may be empty\n+* it - A block to execute with each consecutive string component of the rope.\n+       Return `true` to continue, `false` to stop\n \n-Returns:\n+# Return value\n \n `true` If execution proceeded correctly, `false` if it was interrupted,\n that is if `it` returned `false` at any point.\n- */\n+\"]\n fn loop_leaves(rope: rope, it: fn(node::leaf) -> bool) -> bool{\n    alt(rope) {\n       node::empty { ret true }\n@@ -502,15 +461,17 @@ mod iterator {\n  Section: Rope properties\n  */\n \n-/*\n- Function: height\n+#[doc =\"\n+Returns the height of the rope.\n \n- Returns: The height of the rope, i.e. a bound on the number of\n-operations which must be performed during a character access before\n-finding the leaf in which a character is contained.\n+The height of the rope is a bound on the number of operations which\n+must be performed during a character access before finding the leaf in\n+which a character is contained.\n \n- Performance note: Constant time.\n-*/\n+# Performance note\n+\n+Constant time.\n+\"]\n fn height(rope: rope) -> uint {\n    alt(rope) {\n       node::empty    { ret 0u; }\n@@ -520,50 +481,50 @@ fn height(rope: rope) -> uint {\n \n \n \n-/*\n- Function: char_len\n+#[doc =\"\n+The number of character in the rope\n \n- Returns: The number of character in the rope\n+# Performance note\n \n- Performance note: Constant time.\n- */\n+Constant time.\n+\"]\n pure fn char_len(rope: rope) -> uint {\n    alt(rope) {\n      node::empty           { ret 0u; }\n      node::content(x)       { ret node::char_len(x) }\n    }\n }\n \n-/*\n- Function: char_len\n+#[doc = \"\n+The number of bytes in the rope\n \n- Returns: The number of bytes in the rope\n+# Performance note\n \n- Performance note: Constant time.\n- FIXME: char or byte?\n- */\n+Constant time.\n+\"]\n pure fn byte_len(rope: rope) -> uint {\n    alt(rope) {\n      node::empty           { ret 0u; }\n      node::content(x)       { ret node::byte_len(x) }\n    }\n }\n \n-/*\n- Function: char_at\n+#[doc = \"\n+The character at position `pos`\n \n- Parameters:\n-  pos - A position in the rope\n+# Arguments\n \n- Returns: The character at position `pos`\n+* pos - A position in the rope\n \n- Safety notes: The function will fail if `pos`\n- is not a valid position in the rope.\n+# Safety notes\n \n- Performance note: This function executes in a time\n- proportional to the height of the rope + the (bounded)\n- length of the largest leaf.\n- */\n+The function will fail if `pos` is not a valid position in the rope.\n+\n+# Performance note\n+\n+This function executes in a time proportional to the height of the\n+rope + the (bounded) length of the largest leaf.\n+\"]\n fn char_at(rope: rope, pos: uint) -> char {\n    alt(rope) {\n       node::empty { fail }\n@@ -577,140 +538,84 @@ fn char_at(rope: rope, pos: uint) -> char {\n */\n mod node {\n \n-    /*\n-     Enum: node::root\n-\n-     Implementation of type `rope`\n-\n-     Constants:\n-       empty   - An empty rope\n-       content - A non-empty rope\n-    */\n+    #[doc = \"Implementation of type `rope`\"]\n     enum root {\n+        #[doc = \"An empty rope\"]\n         empty,\n+        #[doc = \"A non-empty rope\"]\n         content(@node),\n     }\n \n-    /*\n-     Struct: node::leaf\n+    #[doc = \"\n+    A text component in a rope.\n \n-     A text component in a rope.\n+    This is actually a slice in a rope, so as to ensure maximal sharing.\n \n-     This is actually a slice in a rope, so as to ensure maximal sharing.\n-    */\n-    type leaf = {\n-\n-    /*\n-     Field: byte_offset\n-\n-     The number of bytes skipped in `content`\n-    */\n-    byte_offset: uint,\n-\n-    /*\n-     Field: byte_len\n-\n-     The number of bytes of `content` to use\n-    */\n-    byte_len:    uint,\n+    # Fields\n \n-    /*\n-     Field: char_len\n+    * byte_offset = The number of bytes skippen in `content`\n+    * byte_len - The number of bytes of `content` to use\n+    * char_len - The number of chars in the leaf.\n+    * content - Contents of the leaf.\n \n+        Note that we can have `char_len < str::char_len(content)`, if\n+        this leaf is only a subset of the string. Also note that the\n+        string can be shared between several ropes, e.g. for indexing\n+        purposes.\n+    \"]\n+    type leaf = {\n+        byte_offset: uint,\n+        byte_len:    uint,\n+        char_len:   uint,\n+        content:    @str\n+    };\n \n-     The number of chars in the leaf.\n-    */\n-    char_len:   uint,\n-\n-    /*\n-    Field: content\n+    #[doc = \"\n+    A node obtained from the concatenation of two other nodes\n \n-    Contents of the leaf.\n+    # Fields\n \n-    Note that we can have `char_len < str::char_len(content)`, if this\n-    leaf is only a subset of the string. Also note that the string\n-    can be shared between several ropes, e.g. for indexing purposes.\n-    */\n-    content:    @str\n-    };\n+    * left - The node containing the beginning of the text.\n+    * right - The node containing the end of the text.\n+    * char_len - The number of chars contained in all leaves of this node.\n+    * byte_len - The number of bytes in the subrope.\n \n+        Used to pre-allocate the correct amount of storage for serialization.\n \n-    /*\n-     Struct node::concat\n+    * height - Height of the subrope.\n \n-     A node obtained from the concatenation of two other nodes\n-    */\n+        Used for rebalancing and to allocate stacks for traversals.\n+    \"]\n     type concat = {\n-\n-        /*\n-        Field: left\n-\n-        The node containing the beginning of the text.\n-        */\n         left:     @node,//TODO: Perhaps a `vec` instead of `left`/`right`\n-\n-        /*\n-        Field: right\n-\n-        The node containing the end of the text.\n-        */\n         right:    @node,\n-\n-        /*\n-        Field: char_len\n-\n-        The number of chars contained in all leaves of this node.\n-        */\n         char_len: uint,\n-\n-        /*\n-        Field: byte_len\n-\n-        The number of bytes in the subrope.\n-\n-        Used to pre-allocate the correct amount of storage for serialization.\n-        */\n         byte_len: uint,\n-\n-        /*\n-        Field: height\n-\n-        Height of the subrope.\n-\n-        Used for rebalancing and to allocate stacks for\n-        traversals.\n-        */\n         height:   uint\n     };\n \n-    /*\n-    Enum: node::node\n-\n-    leaf - A leaf consisting in a `str`\n-    concat - The concatenation of two ropes\n-    */\n     enum node {\n+        #[doc = \"A leaf consisting in a `str`\"]\n         leaf(leaf),\n+        #[doc = \"The concatenation of two ropes\"]\n         concat(concat),\n     }\n \n-    /*\n+    #[doc = \"\n     The maximal number of chars that _should_ be permitted in a single node.\n \n     This is not a strict value\n-     */\n+    \"]\n     const hint_max_leaf_char_len: uint = 256u;\n \n-    /*\n+    #[doc = \"\n     The maximal height that _should_ be permitted in a tree.\n \n     This is not a strict value\n-     */\n+    \"]\n     const hint_max_node_height:   uint = 16u;\n \n-    /*\n-    Function: of_str\n-\n+    #[doc = \"\n     Adopt a string as a node.\n \n     If the string is longer than `max_leaf_char_len`, it is\n@@ -719,53 +624,54 @@ mod node {\n \n     Performance note: The complexity of this function is linear in\n     the length of `str`.\n-     */\n+    \"]\n     fn of_str(str: @str) -> @node {\n         ret of_substr(str, 0u, str::len(*str));\n     }\n \n-    /*\n-    Function: of_substr\n-\n+    #[doc =\"\n     Adopt a slice of a string as a node.\n \n     If the slice is longer than `max_leaf_char_len`, it is logically split\n     between as many leaves as necessary. Regardless, the string itself\n     is not copied\n \n-    Parameters:\n-    byte_start - The byte offset where the slice of `str` starts.\n-    byte_len   - The number of bytes from `str` to use.\n+    # Arguments\n \n-    Safety note:\n-    - Behavior is undefined if `byte_start` or `byte_len` do not represent\n-     valid positions in `str`\n-     */\n+    * byte_start - The byte offset where the slice of `str` starts.\n+    * byte_len   - The number of bytes from `str` to use.\n+\n+    # Safety note\n+\n+    Behavior is undefined if `byte_start` or `byte_len` do not represent\n+    valid positions in `str`\n+    \"]\n     fn of_substr(str: @str, byte_start: uint, byte_len: uint) -> @node {\n         ret of_substr_unsafer(str, byte_start, byte_len,\n                               str::count_chars(*str, byte_start, byte_len));\n     }\n \n-    /*\n-    Function: of_substr_unsafer\n-\n+    #[doc = \"\n     Adopt a slice of a string as a node.\n \n     If the slice is longer than `max_leaf_char_len`, it is logically split\n     between as many leaves as necessary. Regardless, the string itself\n     is not copied\n \n-    byte_start - The byte offset where the slice of `str` starts.\n-    byte_len   - The number of bytes from `str` to use.\n-    char_len   - The number of chars in `str` in the interval\n-          [byte_start, byte_start+byte_len(\n-\n-    Safety note:\n-    - Behavior is undefined if `byte_start` or `byte_len` do not represent\n-     valid positions in `str`\n-    - Behavior is undefined if `char_len` does not accurately represent the\n-     number of chars between byte_start and byte_start+byte_len\n-    */\n+    # Arguments\n+\n+    * byte_start - The byte offset where the slice of `str` starts.\n+    * byte_len - The number of bytes from `str` to use.\n+    * char_len - The number of chars in `str` in the interval\n+                 [byte_start, byte_start+byte_len(\n+\n+    # Safety notes\n+\n+    * Behavior is undefined if `byte_start` or `byte_len` do not represent\n+      valid positions in `str`\n+    * Behavior is undefined if `char_len` does not accurately represent the\n+      number of chars between byte_start and byte_start+byte_len\n+    \"]\n     fn of_substr_unsafer(str: @str, byte_start: uint, byte_len: uint,\n                           char_len: uint) -> @node {\n         assert(byte_start + byte_len <= str::len(*str));\n@@ -838,16 +744,14 @@ mod node {\n         }\n     }\n \n-\n-    /*\n-    Function: tree_from_forest_destructive\n-\n+    #[doc =\"\n     Concatenate a forest of nodes into one tree.\n \n-    Parameters:\n-    forest - The forest. This vector is progressively rewritten during\n-    execution and should be discarded as meaningless afterwards.\n-    */\n+    # Arguments\n+\n+    * forest - The forest. This vector is progressively rewritten during\n+               execution and should be discarded as meaningless afterwards.\n+    \"]\n     fn tree_from_forest_destructive(forest: [mutable @node]) -> @node {\n         let i = 0u;\n         let len = vec::len(forest);\n@@ -917,13 +821,13 @@ mod node {\n         ret str;\n     }\n \n-    /*\n-    Function: flatten\n-\n+    #[doc =\"\n     Replace a subtree by a single leaf with the same contents.\n \n-    Performance note: This function executes in linear time.\n-     */\n+    * Performance note\n+\n+    This function executes in linear time.\n+    \"]\n     fn flatten(node: @node) -> @node unsafe {\n         alt(*node) {\n           leaf(_) { ret node }\n@@ -938,21 +842,21 @@ mod node {\n         }\n     }\n \n-    /*\n-    Function: bal\n-\n+    #[doc =\"\n     Balance a node.\n \n-    Algorithm:\n-    - if the node height is smaller than `hint_max_node_height`, do nothing\n-    - otherwise, gather all leaves as a forest, rebuild a balanced node,\n-         concatenating small leaves along the way\n+    # Algorithm\n+\n+    * if the node height is smaller than `hint_max_node_height`, do nothing\n+    * otherwise, gather all leaves as a forest, rebuild a balanced node,\n+      concatenating small leaves along the way\n \n-    Returns:\n-    - `option::none` if no transformation happened\n-    - `option::some(x)` otherwise, in which case `x` has the same contents\n+    # Return value\n+\n+    * `option::none` if no transformation happened\n+    * `option::some(x)` otherwise, in which case `x` has the same contents\n        as `node` bot lower height and/or fragmentation.\n-    */\n+    \"]\n     fn bal(node: @node) -> option<@node> {\n         if height(node) < hint_max_node_height { ret option::none; }\n         //1. Gather all leaves as a forest\n@@ -970,24 +874,25 @@ mod node {\n \n     }\n \n-    /*\n-    Function: sub_bytes\n-\n+    #[doc =\"\n     Compute the subnode of a node.\n \n-    Parameters:\n-    node        - A node\n-    byte_offset - A byte offset in `node`\n-    byte_len    - The number of bytes to return\n+    # Arguments\n+\n+    * node        - A node\n+    * byte_offset - A byte offset in `node`\n+    * byte_len    - The number of bytes to return\n+\n+    # Performance notes\n \n-    Performance notes:\n-    - this function performs no copying;\n-    - this function executes in a time proportional to the height of `node`.\n+    * this function performs no copying;\n+    * this function executes in a time proportional to the height of `node`.\n \n-    Safety notes:\n-    - this function fails if `byte_offset` or `byte_len` do not represent\n+    # Safety notes\n+\n+    This function fails if `byte_offset` or `byte_len` do not represent\n     valid positions in `node`.\n-    */\n+    \"]\n     fn sub_bytes(node: @node, byte_offset: uint, byte_len: uint) -> @node {\n         let node        = node;\n         let byte_offset = byte_offset;\n@@ -1031,24 +936,25 @@ mod node {\n         core::unreachable();\n     }\n \n-    /*\n-    Function: sub_chars\n-\n+    #[doc =\"\n     Compute the subnode of a node.\n \n-    Parameters:\n-    node        - A node\n-    char_offset - A char offset in `node`\n-    char_len    - The number of chars to return\n+    # Arguments\n+\n+    * node        - A node\n+    * char_offset - A char offset in `node`\n+    * char_len    - The number of chars to return\n+\n+    # Performance notes\n \n-    Performance notes:\n-    - this function performs no copying;\n-    - this function executes in a time proportional to the height of `node`.\n+    * this function performs no copying;\n+    * this function executes in a time proportional to the height of `node`.\n \n-    Safety notes:\n-    - this function fails if `char_offset` or `char_len` do not represent\n+    # Safety notes\n+\n+    This function fails if `char_offset` or `char_len` do not represent\n     valid positions in `node`.\n-    */\n+    \"]\n     fn sub_chars(node: @node, char_offset: uint, char_len: uint) -> @node {\n         let node        = node;\n         let char_offset = char_offset;\n@@ -1144,22 +1050,20 @@ mod node {\n         })\n     }\n \n-    /*\n-    Function: loop_leaves\n-\n+    #[doc =\"\n     Loop through a node, leaf by leaf\n \n-    Parameters:\n+    # Arguments\n \n-    rope - A node to traverse.\n-    it - A block to execute with each consecutive leaf of the node.\n-    Return `true` to continue, `false` to stop\n+    * rope - A node to traverse.\n+    * it - A block to execute with each consecutive leaf of the node.\n+           Return `true` to continue, `false` to stop\n \n-    Returns:\n+    # Arguments\n \n     `true` If execution proceeded correctly, `false` if it was interrupted,\n     that is if `it` returned `false` at any point.\n-    */\n+    \"]\n     fn loop_leaves(node: @node, it: fn(leaf) -> bool) -> bool{\n         let current = node;\n         while true {\n@@ -1179,21 +1083,23 @@ mod node {\n         core::unreachable();\n     }\n \n-    /*\n-    Function: char_at\n+    #[doc =\"\n+    # Arguments\n+\n+    * pos - A position in the rope\n+\n+    # Return value\n \n-    Parameters:\n-    pos - A position in the rope\n+    The character at position `pos`\n \n-    Returns: The character at position `pos`\n+    # Safety notes\n \n-    Safety notes: The function will fail if `pos`\n-    is not a valid position in the rope.\n+    The function will fail if `pos` is not a valid position in the rope.\n \n     Performance note: This function executes in a time\n     proportional to the height of the rope + the (bounded)\n     length of the largest leaf.\n-    */\n+    \"]\n     fn char_at(node: @node, pos: uint) -> char {\n         let node    = node;\n         let pos     = pos;"}, {"sha": "1334e7db723bb75921078aa85f0cb14406936ef0", "filename": "src/libstd/run_program.rs", "status": "modified", "additions": 40, "deletions": 90, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun_program.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,8 +1,4 @@\n-/*\n-Module: run\n-\n-Process spawning\n-*/\n+#[doc =\"Process spawning\"];\n import option::{some, none};\n import str::sbuf;\n import ctypes::{fd_t, pid_t, void};\n@@ -21,87 +17,51 @@ native mod rustrt {\n         -> pid_t;\n }\n \n-/* Section: Types */\n-\n-/*\n-Iface: program\n-\n-A value representing a child process\n-*/\n+#[doc =\"A value representing a child process\"]\n iface program {\n-    /*\n-    Method: get_id\n-\n-    Returns the process id of the program\n-    */\n+    #[doc =\"Returns the process id of the program\"]\n     fn get_id() -> pid_t;\n \n-    /*\n-    Method: input\n-\n-    Returns an io::writer that can be used to write to stdin\n-    */\n+    #[doc =\"Returns an io::writer that can be used to write to stdin\"]\n     fn input() -> io::writer;\n \n-    /*\n-    Method: output\n-\n-    Returns an io::reader that can be used to read from stdout\n-    */\n+    #[doc =\"Returns an io::reader that can be used to read from stdout\"]\n     fn output() -> io::reader;\n \n-    /*\n-    Method: err\n-\n-    Returns an io::reader that can be used to read from stderr\n-    */\n+    #[doc =\"Returns an io::reader that can be used to read from stderr\"]\n     fn err() -> io::reader;\n \n-    /*\n-    Method: close_input\n-\n-    Closes the handle to the child processes standard input\n-    */\n+    #[doc = \"Closes the handle to the child processes standard input\"]\n     fn close_input();\n \n-    /*\n-    Method: finish\n-\n+    #[doc = \"\n     Waits for the child process to terminate. Closes the handle\n     to stdin if necessary.\n-    */\n+    \"]\n     fn finish() -> int;\n \n-    /*\n-    Method: destroy\n-\n-    Closes open handles\n-    */\n+    #[doc =\"Closes open handles\"]\n     fn destroy();\n }\n \n \n-/* Section: Operations */\n-\n-/*\n-Function: spawn_process\n-\n+#[doc = \"\n Run a program, providing stdin, stdout and stderr handles\n \n-Parameters:\n+# Arguments\n \n-prog - The path to an executable\n-args - Vector of arguments to pass to the child process\n-env - optional env-modification for child\n-dir - optional dir to run child in (default current dir)\n-in_fd - A file descriptor for the child to use as std input\n-out_fd - A file descriptor for the child to use as std output\n-err_fd - A file descriptor for the child to use as std error\n+* prog - The path to an executable\n+* args - Vector of arguments to pass to the child process\n+* env - optional env-modification for child\n+* dir - optional dir to run child in (default current dir)\n+* in_fd - A file descriptor for the child to use as std input\n+* out_fd - A file descriptor for the child to use as std output\n+* err_fd - A file descriptor for the child to use as std error\n \n-Returns:\n+# Return value\n \n The process id of the spawned process\n-*/\n+\"]\n fn spawn_process(prog: str, args: [str],\n                  env: option<[(str,str)]>,\n                  dir: option<str>,\n@@ -188,43 +148,39 @@ fn with_dirp<T>(d: option<str>,\n     }\n }\n \n-/*\n-Function: run_program\n-\n+#[doc =\"\n Spawns a process and waits for it to terminate\n \n-Parameters:\n+# Arguments\n \n-prog - The path to an executable\n-args - Vector of arguments to pass to the child process\n+* prog - The path to an executable\n+* args - Vector of arguments to pass to the child process\n \n-Returns:\n+# Return value\n \n The process id\n-*/\n+\"]\n fn run_program(prog: str, args: [str]) -> int {\n     ret waitpid(spawn_process(prog, args, none, none,\n                               0i32, 0i32, 0i32));\n }\n \n-/*\n-Function: start_program\n-\n+#[doc =\"\n Spawns a process and returns a program\n \n The returned value is a boxed resource containing a <program> object that can\n be used for sending and recieving data over the standard file descriptors.\n The resource will ensure that file descriptors are closed properly.\n \n-Parameters:\n+# Arguments\n \n-prog - The path to an executable\n-args - Vector of arguments to pass to the child process\n+* prog - The path to an executable\n+* args - Vector of arguments to pass to the child process\n \n-Returns:\n+# Return value\n \n A boxed resource of <program>\n-*/\n+\"]\n fn start_program(prog: str, args: [str]) -> program {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n@@ -291,22 +247,20 @@ fn read_all(rd: io::reader) -> str {\n     ret buf;\n }\n \n-/*\n-Function: program_output\n-\n+#[doc =\"\n Spawns a process, waits for it to exit, and returns the exit code, and\n contents of stdout and stderr.\n \n-Parameters:\n+# Arguments\n \n-prog - The path to an executable\n-args - Vector of arguments to pass to the child process\n+* prog - The path to an executable\n+* args - Vector of arguments to pass to the child process\n \n-Returns:\n+# Return value\n \n A record, {status: int, out: str, err: str} containing the exit code,\n the contents of stdout and the contents of stderr.\n-*/\n+\"]\n fn program_output(prog: str, args: [str]) ->\n    {status: int, out: str, err: str} {\n     let pr = start_program(prog, args);\n@@ -316,11 +270,7 @@ fn program_output(prog: str, args: [str]) ->\n     ret {status: pr.finish(), out: out, err: err};\n }\n \n-/*\n-Function: waitpid\n-\n-Waits for a process to exit and returns the exit code\n-*/\n+#[doc =\"Waits for a process to exit and returns the exit code\"]\n fn waitpid(pid: pid_t) -> int {\n     ret waitpid_os(pid);\n "}, {"sha": "19cbd7a610b74c9af97824521b83269089a11a4a", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,8 +1,4 @@\n-/*\n-Module: serialization\n-\n-Support code for serialization.\n-*/\n+#[doc = \"Support code for serialization.\"];\n \n import list::list;\n import ebml::writer;"}, {"sha": "22d26fc2bd9bbc1ddda34279c3d5f651628e84b5", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 16, "deletions": 46, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,18 +1,16 @@\n-/*\n-Module: sha1\n-\n+#[doc =\"\n An implementation of the SHA-1 cryptographic hash.\n \n-First create a <sha1> object using the <mk_sha1> constructor, then\n-feed it input using the <input> or <input_str> methods, which may be\n+First create a `sha1` object using the `mk_sha1` constructor, then\n+feed it input using the `input` or `input_str` methods, which may be\n called any number of times.\n \n After the entire input has been fed to the hash read the result using\n-the <result> or <result_str> methods.\n+the `result` or `result_str` methods.\n \n-The <sha1> object may be reused to create multiple hashes by calling\n-the <reset> method.\n-*/\n+The `sha1` object may be reused to create multiple hashes by calling\n+the `reset` method.\n+\"];\n \n /*\n  * A SHA-1 implementation derived from Paul E. Jones's reference\n@@ -22,50 +20,26 @@ the <reset> method.\n export sha1;\n export mk_sha1;\n \n-/* Section: Types */\n-\n-/*\n-Iface: sha1\n-\n-The SHA-1 interface\n-*/\n+#[doc = \"The SHA-1 interface\"]\n iface sha1 {\n-    /*\n-    Method: input\n-\n-    Provide message input as bytes\n-    */\n+    #[doc = \"Provide message input as bytes\"]\n     fn input([u8]);\n-    /*\n-    Method: input_str\n-\n-    Provide message input as string\n-    */\n+    #[doc = \"Provide message input as string\"]\n     fn input_str(str);\n-    /*\n-    Method: result\n-\n+    #[doc = \"\n     Read the digest as a vector of 20 bytes. After calling this no further\n     input may be provided until reset is called.\n-    */\n+    \"]\n     fn result() -> [u8];\n-    /*\n-    Method: result_str\n-\n+    #[doc = \"\n     Read the digest as a hex string. After calling this no further\n     input may be provided until reset is called.\n-    */\n+    \"]\n     fn result_str() -> str;\n-    /*\n-    Method: reset\n-\n-    Reset the SHA-1 state for reuse\n-    */\n+    #[doc = \"Reset the SHA-1 state for reuse\"]\n     fn reset();\n }\n \n-/* Section: Operations */\n-\n // Some unexported constants\n const digest_buf_len: uint = 5u;\n const msg_block_len: uint = 64u;\n@@ -76,11 +50,7 @@ const k2: u32 = 0x8F1BBCDCu32;\n const k3: u32 = 0xCA62C1D6u32;\n \n \n-/*\n-Function: mk_sha1\n-\n-Construct a <sha1> object\n-*/\n+#[doc = \"Construct a `sha` object\"]\n fn mk_sha1() -> sha1 {\n     type sha1state =\n         {h: [mutable u32],"}, {"sha": "3ddc2bb5d6e4c24a4a2fef8626fa4085d716be43", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 14, "deletions": 39, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,71 +1,54 @@\n-/*\n-Module: smallintmap\n-\n+#[doc = \"\n A simple map based on a vector for small integer keys. Space requirements\n are O(highest integer key).\n-*/\n+\"];\n import core::option;\n import core::option::{some, none};\n \n // FIXME: Should not be @; there's a bug somewhere in rustc that requires this\n // to be.\n-/*\n-Type: smallintmap\n-*/\n type smallintmap<T> = @{mutable v: [mutable option<T>]};\n \n-/*\n-Function: mk\n-\n-Create a smallintmap\n-*/\n+#[doc = \"Create a smallintmap\"]\n fn mk<T>() -> smallintmap<T> {\n     let v: [mutable option<T>] = [mutable];\n     ret @{mutable v: v};\n }\n \n-/*\n-Function: insert\n-\n+#[doc = \"\n Add a value to the map. If the map already contains a value for\n the specified key then the original value is replaced.\n-*/\n+\"]\n fn insert<T: copy>(m: smallintmap<T>, key: uint, val: T) {\n     vec::grow_set::<option<T>>(m.v, key, none::<T>, some::<T>(val));\n }\n \n-/*\n-Function: find\n-\n+#[doc = \"\n Get the value for the specified key. If the key does not exist\n in the map then returns none\n-*/\n+\"]\n fn find<T: copy>(m: smallintmap<T>, key: uint) -> option<T> {\n     if key < vec::len::<option<T>>(m.v) { ret m.v[key]; }\n     ret none::<T>;\n }\n \n-/*\n-Method: get\n-\n+#[doc = \"\n Get the value for the specified key\n \n-Failure:\n+# Failure\n \n If the key does not exist in the map\n-*/\n+\"]\n fn get<T: copy>(m: smallintmap<T>, key: uint) -> T {\n     alt find(m, key) {\n       none { #error(\"smallintmap::get(): key not present\"); fail; }\n       some(v) { ret v; }\n     }\n }\n \n-/*\n-Method: contains_key\n-\n+#[doc = \"\n Returns true if the map contains a value for the specified key\n-*/\n+\"]\n fn contains_key<T: copy>(m: smallintmap<T>, key: uint) -> bool {\n     ret !option::is_none(find::<T>(m, key));\n }\n@@ -80,11 +63,7 @@ fn max_key<T>(m: smallintmap<T>) -> uint {\n     ret vec::len::<option<T>>(m.v);\n }\n \n-/*\n-Impl: map\n-\n-Implements the map::map interface for smallintmap\n-*/\n+#[doc = \"Implements the map::map interface for smallintmap\"]\n impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     fn size() -> uint {\n         let sz = 0u;\n@@ -136,11 +115,7 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     }\n }\n \n-/*\n-Funtion: as_map\n-\n-Cast the given smallintmap to a map::map\n-*/\n+#[doc = \"Cast the given smallintmap to a map::map\"]\n fn as_map<V>(s: smallintmap<V>) -> map::map<uint, V> {\n     s as map::map::<uint, V>\n }"}, {"sha": "8a4d59d9cfab97da7e8ef2141546bd071edc70d1", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,25 +1,18 @@\n-/*\n-Module: sort\n-\n-Sorting methods\n-*/\n+#[doc = \"Sorting methods\"];\n import vec::len;\n \n export merge_sort;\n export quick_sort;\n export quick_sort3;\n \n-/* Type: le */\n type le<T> = fn(T, T) -> bool;\n \n-/*\n-Function: merge_sort\n-\n+#[doc = \"\n Merge sort. Returns a new vector containing the sorted list.\n \n Has worst case O(n log n) performance, best case O(n), but\n is not space efficient. This is a stable sort.\n-*/\n+\"]\n fn merge_sort<T: copy>(le: le<T>, v: [const T]) -> [T] {\n     type slice = (uint, uint);\n \n@@ -88,14 +81,12 @@ fn qsort<T: copy>(compare_func: le<T>, arr: [mutable T], left: uint,\n     }\n }\n \n-/*\n-Function: quick_sort\n-\n+#[doc = \"\n Quicksort. Sorts a mutable vector in place.\n \n Has worst case O(n^2) performance, average case O(n log n).\n This is an unstable sort.\n-*/\n+\"]\n fn quick_sort<T: copy>(compare_func: le<T>, arr: [mutable T]) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n@@ -150,18 +141,16 @@ fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n }\n \n // FIXME: This should take lt and eq types\n-/*\n-Function: quick_sort3\n-\n+#[doc = \"\n Fancy quicksort. Sorts a mutable vector in place.\n \n-Based on algorithm presented by Sedgewick and Bentley\n-<http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf>.\n+Based on algorithm presented by [Sedgewick and Bentley]\n+(http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf).\n According to these slides this is the algorithm of choice for\n 'randomly ordered keys, abstract compare' & 'small number of key values'.\n \n This is an unstable sort.\n-*/\n+\"]\n fn quick_sort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n                        arr: [mutable T]) {\n     if len::<T>(arr) == 0u { ret; }"}, {"sha": "604e5cb63a736c7f4498a275c70cd2952a73f292", "filename": "src/libstd/std.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -7,6 +7,8 @@\n #[license = \"MIT\"];\n #[crate_type = \"lib\"];\n \n+#[doc = \"The Rust standard library\"];\n+\n export fs, io, net, run, uv;\n export c_vec, four, tri, util;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap, ufind;"}, {"sha": "c7e3e60ef205cb888a679e99d64068dcfe53ebec", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,17 +1,10 @@\n-/*\n-Module: tempfile\n-\n-Temporary files and directories\n-*/\n+#[doc = \"Temporary files and directories\"];\n \n import core::option;\n import fs;\n import option::{none, some};\n import rand;\n \n-/*\n-Function: mkdtemp\n-*/\n fn mkdtemp(prefix: str, suffix: str) -> option<str> {\n     let r = rand::mk_rng();\n     let i = 0u;"}, {"sha": "e782abb8e6fc7ab5a04da924cccc9486ceec5f5a", "filename": "src/libstd/term.rs", "status": "modified", "additions": 5, "deletions": 43, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,67 +1,37 @@\n-/*\n-Module: term\n-\n-Simple ANSI color library\n-*/\n+#[doc = \"Simple ANSI color library\"];\n \n import core::option;\n \n // TODO: Windows support.\n \n-/* Const: color_black */\n const color_black: u8 = 0u8;\n-/* Const: color_red */\n const color_red: u8 = 1u8;\n-/* Const: color_green */\n const color_green: u8 = 2u8;\n-/* Const: color_yellow */\n const color_yellow: u8 = 3u8;\n-/* Const: color_blue */\n const color_blue: u8 = 4u8;\n-/* Const: color_magenta */\n const color_magenta: u8 = 5u8;\n-/* Const: color_cyan */\n const color_cyan: u8 = 6u8;\n-/* Const: color_light_gray */\n const color_light_gray: u8 = 7u8;\n-/* Const: color_light_grey */\n const color_light_grey: u8 = 7u8;\n-/* Const: color_dark_gray */\n const color_dark_gray: u8 = 8u8;\n-/* Const: color_dark_grey */\n const color_dark_grey: u8 = 8u8;\n-/* Const: color_bright_red */\n const color_bright_red: u8 = 9u8;\n-/* Const: color_bright_green */\n const color_bright_green: u8 = 10u8;\n-/* Const: color_bright_yellow */\n const color_bright_yellow: u8 = 11u8;\n-/* Const: color_bright_blue */\n const color_bright_blue: u8 = 12u8;\n-/* Const: color_bright_magenta */\n const color_bright_magenta: u8 = 13u8;\n-/* Const: color_bright_cyan */\n const color_bright_cyan: u8 = 14u8;\n-/* Const: color_bright_white */\n const color_bright_white: u8 = 15u8;\n \n fn esc(writer: io::writer) { writer.write([0x1bu8, '[' as u8]); }\n \n-/*\n-Function: reset\n-\n-Reset the foreground and background colors to default\n-*/\n+#[doc = \"Reset the foreground and background colors to default\"]\n fn reset(writer: io::writer) {\n     esc(writer);\n     writer.write(['0' as u8, 'm' as u8]);\n }\n \n-/*\n-Function: color_supported\n-\n-Returns true if the terminal supports color\n-*/\n+#[doc = \"Returns true if the terminal supports color\"]\n fn color_supported() -> bool {\n     let supported_terms = [\"xterm-color\", \"xterm\",\n                            \"screen-bce\", \"xterm-256color\"];\n@@ -84,20 +54,12 @@ fn set_color(writer: io::writer, first_char: u8, color: u8) {\n     writer.write([first_char, ('0' as u8) + color, 'm' as u8]);\n }\n \n-/*\n-Function: fg\n-\n-Set the foreground color\n-*/\n+#[doc = \"Set the foreground color\"]\n fn fg(writer: io::writer, color: u8) {\n     ret set_color(writer, '3' as u8, color);\n }\n \n-/*\n-Function: fg\n-\n-Set the background color\n-*/\n+#[doc = \"Set the background color\"]\n fn bg(writer: io::writer, color: u8) {\n     ret set_color(writer, '4' as u8, color);\n }"}, {"sha": "d8d14df667a13141e5033de70d6392e6a27b41f5", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,3 +1,5 @@\n+#[doc(hidden)];\n+\n // Support code for rustc's built in test runner generator. Currently,\n // none of this is meant for users. It is intended to support the\n // simplest interface possible for representing and running tests"}, {"sha": "dcdc82434ab3aaf7bc8a48e55c414f1156dddb30", "filename": "src/libstd/time.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,47 +1,33 @@\n-/*\n-Module: time\n-*/\n-\n #[abi = \"cdecl\"]\n native mod rustrt {\n     fn get_time(&sec: u32, &usec: u32);\n     fn precise_time_ns(&ns: u64);\n }\n \n-/*\n-Type: timeval\n-\n-A record specifying a time value in seconds and microseconds.\n-*/\n+#[doc = \"A record specifying a time value in seconds and microseconds.\"]\n type timeval = {sec: u32, usec: u32};\n \n-/*\n-Function: get_time\n-\n+#[doc = \"\n Returns the current time as a `timeval` containing the seconds and\n microseconds since 1970-01-01T00:00:00Z.\n-*/\n+\"]\n fn get_time() -> timeval {\n     let sec = 0u32;\n     let usec = 0u32;\n     rustrt::get_time(sec, usec);\n     ret {sec: sec, usec: usec};\n }\n \n-/*\n-Function: precise_time_ns\n-\n+#[doc = \"\n Returns the current value of a high-resolution performance counter\n in nanoseconds since an unspecified epoch.\n-*/\n+\"]\n fn precise_time_ns() -> u64 { let ns = 0u64; rustrt::precise_time_ns(ns); ns }\n \n-/*\n-Function: precise_time_s\n-\n+#[doc = \"\n Returns the current value of a high-resolution performance counter\n in seconds since an unspecified epoch.\n-*/\n+\"]\n fn precise_time_s() -> float {\n     ret (precise_time_ns() as float) / 1000000000.;\n }"}, {"sha": "e8084ac4f5ee6b6abdb02ec94f31a434dceb3bb7", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 6, "deletions": 35, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,13 +1,10 @@\n-/*\n-Module: treemap\n-\n+#[doc = \"\n A key,value store that works on anything.\n \n This works using a binary search tree. In the first version, it's a\n very naive algorithm, but it will probably be updated to be a\n red-black tree or something else.\n-\n-*/\n+\"];\n \n import core::option::{some, none};\n import option = core::option;\n@@ -18,32 +15,14 @@ export insert;\n export find;\n export traverse;\n \n-/* Section: Types */\n-\n-/*\n-Type: treemap\n-*/\n type treemap<K, V> = @mutable tree_node<K, V>;\n \n-/*\n-Tag: tree_node\n-*/\n enum tree_node<K, V> { empty, node(@K, @V, treemap<K, V>, treemap<K, V>) }\n \n-/* Section: Operations */\n-\n-/*\n-Function: init\n-\n-Create a treemap\n-*/\n+#[doc = \"Create a treemap\"]\n fn init<K, V>() -> treemap<K, V> { @mutable empty }\n \n-/*\n-Function: insert\n-\n-Insert a value into the map\n-*/\n+#[doc = \"Insert a value into the map\"]\n fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) {\n     alt m {\n       @empty { *m = node(@k, @v, @mutable empty, @mutable empty); }\n@@ -62,11 +41,7 @@ fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) {\n     }\n }\n \n-/*\n-Function: find\n-\n-Find a value based on the key\n-*/\n+#[doc = \"Find a value based on the key\"]\n fn find<K: copy, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n       empty { none }\n@@ -81,11 +56,7 @@ fn find<K: copy, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n     }\n }\n \n-/*\n-Function: traverse\n-\n-Visit all pairs in the map in order.\n-*/\n+#[doc = \"Visit all pairs in the map in order.\"]\n fn traverse<K, V>(m: treemap<K, V>, f: fn(K, V)) {\n     alt *m {\n       empty { }"}, {"sha": "b40444a8a075c012ec9a514d74462f26a160a5f4", "filename": "src/libstd/tri.rs", "status": "modified", "additions": 33, "deletions": 90, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Ftri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Ftri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftri.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,141 +1,92 @@\n // -*- rust -*-\n \n-/*\n-Module: tri\n-\n+#[doc = \"\n ADT for the ternary Kleene logic K3\n \n This allows reasoning with three logic values (true, false, unknown).\n \n Implementation: Truth values are represented using a single u8 and\n all operations are done using bit operations which is fast\n on current cpus.\n-*/\n+\"];\n \n export t, true, false, unknown;\n export not, and, or, xor, implies, eq, ne, is_true, is_false;\n export from_str, to_str, all_values, to_bit;\n \n-/*\n-Type: t\n-\n-The type of ternary logic values\n-*/\n+#[doc = \"The type of ternary logic values\"]\n type t = u8;\n \n const b0: u8  = 1u8;\n const b1: u8  = 2u8;\n const b01: u8 = 3u8;\n \n-/*\n-Constant: unknown\n-\n-Logic value for unknown (maybe true xor maybe false)\n-*/\n+#[doc = \"Logic value for unknown (maybe true xor maybe false)\"]\n const unknown: t = 0u8;\n \n-/*\n-Constant: true\n-\n-Logic value for truth\n-*/\n+#[doc = \"Logic value for truth\"]\n const true: t = 1u8;\n \n-/*\n-Constant: false\n-\n-Logic value for falsehood\n-*/\n+#[doc = \"Logic value for falsehood\"]\n const false: t = 2u8;\n \n-/* Function: not\n-\n-Negation/Inverse\n-*/\n+#[doc = \"Negation/Inverse\"]\n pure fn not(v: t) -> t { ((v << 1u8) | (v >> 1u8)) & b01 }\n \n-/* Function: and\n-\n-Conjunction\n-*/\n+#[doc = \"Conjunction\"]\n pure fn and(a: t, b: t) -> t { ((a | b) & b1) | ((a & b) & b0) }\n \n-/* Function: or\n-\n-Disjunction\n-*/\n+#[doc = \"Disjunction\"]\n pure fn or(a: t, b: t) -> t { ((a & b) & b1) | ((a | b) & b0) }\n \n-/*\n-Function: xor\n-\n-Exclusive or\n-*/\n+#[doc = \"Exclusive or\"]\n pure fn xor(a: t, b: t) -> t {\n     let anb = a & b;\n     let aob = a & not(b);\n     ret ((anb & b1) | (anb << 1u8) | (aob >> 1u8) | (aob & b0)) & b01;\n }\n \n-/*\n-Function: implies\n-\n-Classic implication, i.e. from `a` follows `b`\n-*/\n+#[doc = \"Classic implication, i.e. from `a` follows `b`\"]\n pure fn implies(a: t, b: t) -> t {\n     ret ((a & b1) >> 1u8) | (b & b0) | ((a << 1u8) & b & b1);\n }\n \n-/*\n-Predicate: eq\n-\n-Returns:\n+#[doc = \"\n+# Return value\n \n true if truth values `a` and `b` are indistinguishable in the logic\n-*/\n+\"]\n pure fn eq(a: t, b: t) -> bool {  a == b }\n \n-/*\n-Predicate: ne\n-\n-Returns:\n+#[doc = \"\n+# Return value\n \n true if truth values `a` and `b` are distinguishable in the logic\n-*/\n+\"]\n pure fn ne(a: t, b: t) -> bool { a != b }\n \n-/*\n-Predicate: is_true\n-\n-Returns:\n+#[doc = \"\n+# Return value\n \n true if `v` represents truth in the logic\n-*/\n+\"]\n pure fn is_true(v: t) -> bool { v == tri::true }\n \n-/*\n-Predicate: is_false\n-\n-Returns:\n+#[doc = \"\n+# Return value\n \n true if `v` represents false in the logic\n-*/\n+\"]\n pure fn is_false(v: t) -> bool { v == tri::false }\n \n-/*\n-Predicate: is_unknown\n-\n-Returns:\n+#[doc = \"\n+# Return value\n \n true if `v` represents the unknown state in the logic\n-*/\n+\"]\n pure fn is_unknown(v: t) -> bool { v == unknown }\n \n-/*\n-Function: from_str\n-\n-Parse logic value from `s`\n-*/\n+#[doc = \"Parse logic value from `s`\"]\n pure fn from_str(s: str) -> t {\n     alt check s {\n       \"unknown\" { unknown }\n@@ -144,11 +95,7 @@ pure fn from_str(s: str) -> t {\n     }\n }\n \n-/*\n-Function: to_str\n-\n-Convert `v` into a string\n-*/\n+#[doc = \"Convert `v` into a string\"]\n pure fn to_str(v: t) -> str {\n     // FIXME replace with consts as soon as that works\n     alt check v {\n@@ -158,25 +105,21 @@ pure fn to_str(v: t) -> str {\n     }\n }\n \n-/*\n-Function: all_values\n-\n+#[doc = \"\n Iterates over all truth values by passing them to `blk`\n in an unspecified order\n-*/\n+\"]\n fn all_values(blk: fn(v: t)) {\n     blk(tri::false);\n     blk(unknown);\n     blk(tri::true);\n }\n \n-/*\n-Function: to_bit\n-\n-Returns:\n+#[doc = \"\n+# Return value\n \n An u8 whose first bit is set if `if_true(v)` holds\n-*/\n+\"]\n fn to_bit(v: t) -> u8 { v & b0 }\n \n #[cfg(test)]"}, {"sha": "fc0a326dee764f24b94ee3c22d86fe7d5e0cfa73", "filename": "src/libstd/util.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95521c408438efc5794e83953086c812b795c756/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=95521c408438efc5794e83953086c812b795c756", "patch": "@@ -1,26 +1,11 @@\n-/*\n-Module: util\n-*/\n-\n-/*\n-Function: id\n-\n-The identity function\n-*/\n+#[doc = \"The identity function\"]\n pure fn id<T: copy>(x: T) -> T { x }\n \n /* FIXME (issue #141):  See test/run-pass/constrained-type.rs.  Uncomment\n  * the constraint once fixed. */\n-/*\n-Function: rational\n-\n-A rational number\n-*/\n+#[doc = \"A rational number\"]\n type rational = {num: int, den: int}; // : int::positive(*.den);\n \n-/*\n-Function: rational_leq\n-*/\n pure fn rational_leq(x: rational, y: rational) -> bool {\n     // NB: Uses the fact that rationals have positive denominators WLOG:\n "}]}