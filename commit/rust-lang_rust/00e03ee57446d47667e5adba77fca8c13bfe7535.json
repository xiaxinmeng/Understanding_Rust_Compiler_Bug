{"sha": "00e03ee57446d47667e5adba77fca8c13bfe7535", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZTAzZWU1NzQ0NmQ0NzY2N2U1YWRiYTc3ZmNhOGMxM2JmZTc1MzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-22T20:29:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-22T20:29:51Z"}, "message": "Auto merge of #56143 - nikomatsakis:issue-56128-segment-id-ice-nightly, r=petrochenkov\n\nIssue 56128 segment id ice nightly\n\nTentative fix for #56128\n\nFrom what I can tell, the problem is that if you have `pub(super) use foo::{a, b}`, then when we explode the `a` and `b`, the segment ids from the `super` path were not getting cloned. However, once I fixed *that*, then I ran into a problem that the \"visibility\" node-ids were not present in the final HIR -- this is because the visibility of the \"stem\" that is returned in this case was getting reset to inherited. I don't *think* it is a problem to undo that, so that the visibility is returned unmodified.\n\nFixes #55475\nFixes #56128\n\ncc @nrc @petrochenkov", "tree": {"sha": "c3192ee8a32c041b3d202da49f065071dca1980f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3192ee8a32c041b3d202da49f065071dca1980f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00e03ee57446d47667e5adba77fca8c13bfe7535", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00e03ee57446d47667e5adba77fca8c13bfe7535", "html_url": "https://github.com/rust-lang/rust/commit/00e03ee57446d47667e5adba77fca8c13bfe7535", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00e03ee57446d47667e5adba77fca8c13bfe7535/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c08840d5c3e6fa29b0fa734ad4405455f2e4c879", "url": "https://api.github.com/repos/rust-lang/rust/commits/c08840d5c3e6fa29b0fa734ad4405455f2e4c879", "html_url": "https://github.com/rust-lang/rust/commit/c08840d5c3e6fa29b0fa734ad4405455f2e4c879"}, {"sha": "5f2a173f75204e23737eef128edc74f88dba7f39", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f2a173f75204e23737eef128edc74f88dba7f39", "html_url": "https://github.com/rust-lang/rust/commit/5f2a173f75204e23737eef128edc74f88dba7f39"}], "stats": {"total": 164, "additions": 123, "deletions": 41}, "files": [{"sha": "b3ba2968c9f51b769a79a78818d65cb378538b17", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 69, "deletions": 12, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/00e03ee57446d47667e5adba77fca8c13bfe7535/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00e03ee57446d47667e5adba77fca8c13bfe7535/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=00e03ee57446d47667e5adba77fca8c13bfe7535", "patch": "@@ -1866,6 +1866,10 @@ impl<'a> LoweringContext<'a> {\n         } else {\n             self.lower_node_id(segment.id)\n         };\n+        debug!(\n+            \"lower_path_segment: ident={:?} original-id={:?} new-id={:?}\",\n+            segment.ident, segment.id, id,\n+        );\n \n         hir::PathSegment::new(\n             segment.ident,\n@@ -2955,6 +2959,9 @@ impl<'a> LoweringContext<'a> {\n         name: &mut Name,\n         attrs: &hir::HirVec<Attribute>,\n     ) -> hir::ItemKind {\n+        debug!(\"lower_use_tree(tree={:?})\", tree);\n+        debug!(\"lower_use_tree: vis = {:?}\", vis);\n+\n         let path = &tree.prefix;\n         let segments = prefix\n             .segments\n@@ -3022,12 +3029,7 @@ impl<'a> LoweringContext<'a> {\n                             hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n                             hir::VisibilityKind::Restricted { ref path, id: _, hir_id: _ } => {\n                                 let id = this.next_id();\n-                                let mut path = path.clone();\n-                                for seg in path.segments.iter_mut() {\n-                                    if seg.id.is_some() {\n-                                        seg.id = Some(this.next_id().node_id);\n-                                    }\n-                                }\n+                                let path = this.renumber_segment_ids(path);\n                                 hir::VisibilityKind::Restricted {\n                                     path,\n                                     id: id.node_id,\n@@ -3068,7 +3070,29 @@ impl<'a> LoweringContext<'a> {\n                 hir::ItemKind::Use(path, hir::UseKind::Glob)\n             }\n             UseTreeKind::Nested(ref trees) => {\n-                // Nested imports are desugared into simple imports.\n+                // Nested imports are desugared into simple\n+                // imports. So if we start with\n+                //\n+                // ```\n+                // pub(x) use foo::{a, b};\n+                // ```\n+                //\n+                // we will create three items:\n+                //\n+                // ```\n+                // pub(x) use foo::a;\n+                // pub(x) use foo::b;\n+                // pub(x) use foo::{}; // <-- this is called the `ListStem`\n+                // ```\n+                //\n+                // The first two are produced by recursively invoking\n+                // `lower_use_tree` (and indeed there may be things\n+                // like `use foo::{a::{b, c}}` and so forth).  They\n+                // wind up being directly added to\n+                // `self.items`. However, the structure of this\n+                // function also requires us to return one item, and\n+                // for that we return the `{}` import (called the\n+                // \"`ListStem`\").\n \n                 let prefix = Path {\n                     segments,\n@@ -3112,8 +3136,9 @@ impl<'a> LoweringContext<'a> {\n                             hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n                             hir::VisibilityKind::Restricted { ref path, id: _, hir_id: _ } => {\n                                 let id = this.next_id();\n+                                let path = this.renumber_segment_ids(path);\n                                 hir::VisibilityKind::Restricted {\n-                                    path: path.clone(),\n+                                    path: path,\n                                     id: id.node_id,\n                                     hir_id: id.hir_id,\n                                 }\n@@ -3136,17 +3161,48 @@ impl<'a> LoweringContext<'a> {\n                     });\n                 }\n \n-                // Privatize the degenerate import base, used only to check\n-                // the stability of `use a::{};`, to avoid it showing up as\n-                // a re-export by accident when `pub`, e.g. in documentation.\n+                // Subtle and a bit hacky: we lower the privacy level\n+                // of the list stem to \"private\" most of the time, but\n+                // not for \"restricted\" paths. The key thing is that\n+                // we don't want it to stay as `pub` (with no caveats)\n+                // because that affects rustdoc and also the lints\n+                // about `pub` items. But we can't *always* make it\n+                // private -- particularly not for restricted paths --\n+                // because it contains node-ids that would then be\n+                // unused, failing the check that HirIds are \"densely\n+                // assigned\".\n+                match vis.node {\n+                    hir::VisibilityKind::Public |\n+                    hir::VisibilityKind::Crate(_) |\n+                    hir::VisibilityKind::Inherited => {\n+                        *vis = respan(prefix.span.shrink_to_lo(), hir::VisibilityKind::Inherited);\n+                    }\n+                    hir::VisibilityKind::Restricted { .. } => {\n+                        // do nothing here, as described in the comment on the match\n+                    }\n+                }\n+\n                 let def = self.expect_full_def_from_use(id).next().unwrap_or(Def::Err);\n                 let path = P(self.lower_path_extra(def, &prefix, ParamMode::Explicit, None));\n-                *vis = respan(prefix.span.shrink_to_lo(), hir::VisibilityKind::Inherited);\n                 hir::ItemKind::Use(path, hir::UseKind::ListStem)\n             }\n         }\n     }\n \n+    /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n+    /// many times in the HIR tree; for each occurrence, we need to assign distinct\n+    /// node-ids. (See e.g. #56128.)\n+    fn renumber_segment_ids(&mut self, path: &P<hir::Path>) -> P<hir::Path> {\n+        debug!(\"renumber_segment_ids(path = {:?})\", path);\n+        let mut path = path.clone();\n+        for seg in path.segments.iter_mut() {\n+            if seg.id.is_some() {\n+                seg.id = Some(self.next_id().node_id);\n+            }\n+        }\n+        path\n+    }\n+\n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n         let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n         let trait_item_def_id = self.resolver.definitions().local_def_id(node_id);\n@@ -4540,6 +4596,7 @@ impl<'a> LoweringContext<'a> {\n             VisibilityKind::Public => hir::VisibilityKind::Public,\n             VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n             VisibilityKind::Restricted { ref path, id } => {\n+                debug!(\"lower_visibility: restricted path id = {:?}\", id);\n                 let lowered_id = if let Some(owner) = explicit_owner {\n                     self.lower_node_id_with_owner(id, owner)\n                 } else {"}, {"sha": "2917fd7457acf364ca3f44a473ec1f99503d55da", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/00e03ee57446d47667e5adba77fca8c13bfe7535/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00e03ee57446d47667e5adba77fca8c13bfe7535/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=00e03ee57446d47667e5adba77fca8c13bfe7535", "patch": "@@ -28,6 +28,10 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHashe\n pub(super) struct NodeCollector<'a, 'hir> {\n     /// The crate\n     krate: &'hir Crate,\n+\n+    /// Source map\n+    source_map: &'a SourceMap,\n+\n     /// The node map\n     map: Vec<Option<Entry<'hir>>>,\n     /// The parent of this node\n@@ -54,7 +58,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn root(krate: &'hir Crate,\n                        dep_graph: &'a DepGraph,\n                        definitions: &'a definitions::Definitions,\n-                       hcx: StableHashingContext<'a>)\n+                       hcx: StableHashingContext<'a>,\n+                       source_map: &'a SourceMap)\n                 -> NodeCollector<'a, 'hir> {\n         let root_mod_def_path_hash = definitions.def_path_hash(CRATE_DEF_INDEX);\n \n@@ -102,6 +107,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n         let mut collector = NodeCollector {\n             krate,\n+            source_map,\n             map: vec![],\n             parent_node: CRATE_NODE_ID,\n             current_signature_dep_index: root_mod_sig_dep_index,\n@@ -125,7 +131,6 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn finalize_and_compute_crate_hash(mut self,\n                                                   crate_disambiguator: CrateDisambiguator,\n                                                   cstore: &dyn CrateStore,\n-                                                  source_map: &SourceMap,\n                                                   commandline_args_hash: u64)\n                                                   -> (Vec<Option<Entry<'hir>>>, Svh)\n     {\n@@ -154,7 +159,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         // If we included the full mapping in the SVH, we could only have\n         // reproducible builds by compiling from the same directory. So we just\n         // hash the result of the mapping instead of the mapping itself.\n-        let mut source_file_names: Vec<_> = source_map\n+        let mut source_file_names: Vec<_> = self\n+            .source_map\n             .files()\n             .iter()\n             .filter(|source_file| CrateNum::from_u32(source_file.crate_of_origin) == LOCAL_CRATE)\n@@ -186,7 +192,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         self.map[id.as_usize()] = Some(entry);\n     }\n \n-    fn insert(&mut self, id: NodeId, node: Node<'hir>) {\n+    fn insert(&mut self, span: Span, id: NodeId, node: Node<'hir>) {\n         let entry = Entry {\n             parent: self.parent_node,\n             dep_node: if self.currently_in_body {\n@@ -216,16 +222,20 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                     String::new()\n                 };\n \n-                bug!(\"inconsistent DepNode for `{}`: \\\n-                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?}){}\",\n+                span_bug!(\n+                    span,\n+                    \"inconsistent DepNode at `{:?}` for `{}`: \\\n+                     current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?}){}\",\n+                    self.source_map.span_to_string(span),\n                     node_str,\n                     self.definitions\n                         .def_path(self.current_dep_node_owner)\n                         .to_string_no_crate(),\n                     self.current_dep_node_owner,\n                     self.definitions.def_path(hir_id.owner).to_string_no_crate(),\n                     hir_id.owner,\n-                    forgot_str)\n+                    forgot_str,\n+                )\n             }\n         }\n \n@@ -309,12 +319,12 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug_assert_eq!(i.hir_id.owner,\n                          self.definitions.opt_def_index(i.id).unwrap());\n         self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n-            this.insert(i.id, Node::Item(i));\n+            this.insert(i.span, i.id, Node::Item(i));\n             this.with_parent(i.id, |this| {\n                 if let ItemKind::Struct(ref struct_def, _) = i.node {\n                     // If this is a tuple-like struct, register the constructor.\n                     if !struct_def.is_struct() {\n-                        this.insert(struct_def.id(), Node::StructCtor(struct_def));\n+                        this.insert(i.span, struct_def.id(), Node::StructCtor(struct_def));\n                     }\n                 }\n                 intravisit::walk_item(this, i);\n@@ -323,23 +333,23 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'hir ForeignItem) {\n-        self.insert(foreign_item.id, Node::ForeignItem(foreign_item));\n+        self.insert(foreign_item.span, foreign_item.id, Node::ForeignItem(foreign_item));\n \n         self.with_parent(foreign_item.id, |this| {\n             intravisit::walk_foreign_item(this, foreign_item);\n         });\n     }\n \n     fn visit_generic_param(&mut self, param: &'hir GenericParam) {\n-        self.insert(param.id, Node::GenericParam(param));\n+        self.insert(param.span, param.id, Node::GenericParam(param));\n         intravisit::walk_generic_param(self, param);\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n         debug_assert_eq!(ti.hir_id.owner,\n                          self.definitions.opt_def_index(ti.id).unwrap());\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n-            this.insert(ti.id, Node::TraitItem(ti));\n+            this.insert(ti.span, ti.id, Node::TraitItem(ti));\n \n             this.with_parent(ti.id, |this| {\n                 intravisit::walk_trait_item(this, ti);\n@@ -351,7 +361,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug_assert_eq!(ii.hir_id.owner,\n                          self.definitions.opt_def_index(ii.id).unwrap());\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this| {\n-            this.insert(ii.id, Node::ImplItem(ii));\n+            this.insert(ii.span, ii.id, Node::ImplItem(ii));\n \n             this.with_parent(ii.id, |this| {\n                 intravisit::walk_impl_item(this, ii);\n@@ -365,23 +375,23 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         } else {\n             Node::Pat(pat)\n         };\n-        self.insert(pat.id, node);\n+        self.insert(pat.span, pat.id, node);\n \n         self.with_parent(pat.id, |this| {\n             intravisit::walk_pat(this, pat);\n         });\n     }\n \n     fn visit_anon_const(&mut self, constant: &'hir AnonConst) {\n-        self.insert(constant.id, Node::AnonConst(constant));\n+        self.insert(DUMMY_SP, constant.id, Node::AnonConst(constant));\n \n         self.with_parent(constant.id, |this| {\n             intravisit::walk_anon_const(this, constant);\n         });\n     }\n \n     fn visit_expr(&mut self, expr: &'hir Expr) {\n-        self.insert(expr.id, Node::Expr(expr));\n+        self.insert(expr.span, expr.id, Node::Expr(expr));\n \n         self.with_parent(expr.id, |this| {\n             intravisit::walk_expr(this, expr);\n@@ -390,7 +400,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_stmt(&mut self, stmt: &'hir Stmt) {\n         let id = stmt.node.id();\n-        self.insert(id, Node::Stmt(stmt));\n+        self.insert(stmt.span, id, Node::Stmt(stmt));\n \n         self.with_parent(id, |this| {\n             intravisit::walk_stmt(this, stmt);\n@@ -399,21 +409,21 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'hir PathSegment) {\n         if let Some(id) = path_segment.id {\n-            self.insert(id, Node::PathSegment(path_segment));\n+            self.insert(path_span, id, Node::PathSegment(path_segment));\n         }\n         intravisit::walk_path_segment(self, path_span, path_segment);\n     }\n \n     fn visit_ty(&mut self, ty: &'hir Ty) {\n-        self.insert(ty.id, Node::Ty(ty));\n+        self.insert(ty.span, ty.id, Node::Ty(ty));\n \n         self.with_parent(ty.id, |this| {\n             intravisit::walk_ty(this, ty);\n         });\n     }\n \n     fn visit_trait_ref(&mut self, tr: &'hir TraitRef) {\n-        self.insert(tr.ref_id, Node::TraitRef(tr));\n+        self.insert(tr.path.span, tr.ref_id, Node::TraitRef(tr));\n \n         self.with_parent(tr.ref_id, |this| {\n             intravisit::walk_trait_ref(this, tr);\n@@ -427,21 +437,21 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_block(&mut self, block: &'hir Block) {\n-        self.insert(block.id, Node::Block(block));\n+        self.insert(block.span, block.id, Node::Block(block));\n         self.with_parent(block.id, |this| {\n             intravisit::walk_block(this, block);\n         });\n     }\n \n     fn visit_local(&mut self, l: &'hir Local) {\n-        self.insert(l.id, Node::Local(l));\n+        self.insert(l.span, l.id, Node::Local(l));\n         self.with_parent(l.id, |this| {\n             intravisit::walk_local(this, l)\n         })\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'hir Lifetime) {\n-        self.insert(lifetime.id, Node::Lifetime(lifetime));\n+        self.insert(lifetime.span, lifetime.id, Node::Lifetime(lifetime));\n     }\n \n     fn visit_vis(&mut self, visibility: &'hir Visibility) {\n@@ -450,7 +460,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n             VisibilityKind::Crate(_) |\n             VisibilityKind::Inherited => {}\n             VisibilityKind::Restricted { id, .. } => {\n-                self.insert(id, Node::Visibility(visibility));\n+                self.insert(visibility.span, id, Node::Visibility(visibility));\n                 self.with_parent(id, |this| {\n                     intravisit::walk_vis(this, visibility);\n                 });\n@@ -462,20 +472,20 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         let def_index = self.definitions.opt_def_index(macro_def.id).unwrap();\n \n         self.with_dep_node_owner(def_index, macro_def, |this| {\n-            this.insert(macro_def.id, Node::MacroDef(macro_def));\n+            this.insert(macro_def.span, macro_def.id, Node::MacroDef(macro_def));\n         });\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: NodeId) {\n         let id = v.node.data.id();\n-        self.insert(id, Node::Variant(v));\n+        self.insert(v.span, id, Node::Variant(v));\n         self.with_parent(id, |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }\n \n     fn visit_struct_field(&mut self, field: &'hir StructField) {\n-        self.insert(field.id, Node::Field(field));\n+        self.insert(field.span, field.id, Node::Field(field));\n         self.with_parent(field.id, |this| {\n             intravisit::walk_struct_field(this, field);\n         });"}, {"sha": "ef777abfbc41aa1780d132895682adef63b06b82", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00e03ee57446d47667e5adba77fca8c13bfe7535/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00e03ee57446d47667e5adba77fca8c13bfe7535/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=00e03ee57446d47667e5adba77fca8c13bfe7535", "patch": "@@ -1032,14 +1032,14 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n         let mut collector = NodeCollector::root(&forest.krate,\n                                                 &forest.dep_graph,\n                                                 &definitions,\n-                                                hcx);\n+                                                hcx,\n+                                                sess.source_map());\n         intravisit::walk_crate(&mut collector, &forest.krate);\n \n         let crate_disambiguator = sess.local_crate_disambiguator();\n         let cmdline_args = sess.opts.dep_tracking_hash();\n         collector.finalize_and_compute_crate_hash(crate_disambiguator,\n                                                   cstore,\n-                                                  sess.source_map(),\n                                                   cmdline_args)\n     };\n "}, {"sha": "3a3eccdc33ce8f63e90b516e39f20b1c40568724", "filename": "src/test/ui/issues/issue-56128.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/00e03ee57446d47667e5adba77fca8c13bfe7535/src%2Ftest%2Fui%2Fissues%2Fissue-56128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00e03ee57446d47667e5adba77fca8c13bfe7535/src%2Ftest%2Fui%2Fissues%2Fissue-56128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56128.rs?ref=00e03ee57446d47667e5adba77fca8c13bfe7535", "patch": "@@ -0,0 +1,15 @@\n+// Regression test for #56128. When this `pub(super) use...` gets\n+// exploded in the HIR, we were not handling ids correctly.\n+//\n+// compile-pass\n+\n+mod bar {\n+    pub(super) use self::baz::{x, y};\n+\n+    mod baz {\n+        pub fn x() { }\n+        pub fn y() { }\n+    }\n+}\n+\n+fn main() { }"}]}