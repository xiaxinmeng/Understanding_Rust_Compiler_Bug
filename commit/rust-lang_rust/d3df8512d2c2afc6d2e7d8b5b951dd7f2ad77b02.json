{"sha": "d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZGY4NTEyZDJjMmFmYzZkMmU3ZDhiNWI5NTFkZDdmMmFkNzdiMDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-17T21:10:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-17T21:10:14Z"}, "message": "Auto merge of #74461 - Manishearth:rollup-xadbh00, r=Manishearth\n\nRollup of 18 pull requests\n\nSuccessful merges:\n\n - #71670 (Enforce even more the code blocks attributes check through rustdoc)\n - #73930 (Make some Option methods const)\n - #74009 (Fix MinGW `run-make-fulldeps` tests)\n - #74056 (Add Arguments::as_str().)\n - #74169 (Stop processing unreachable blocks when solving dataflow)\n - #74251 (Teach bootstrap about target files vs target triples)\n - #74288 (Fix src/test/run-make/static-pie/test-aslr.rs)\n - #74300 (Use intra-doc links in core::iter module)\n - #74364 (add lazy normalization regression tests)\n - #74368 (Add CSS tidy check)\n - #74394 (Remove leftover from emscripten fastcomp support)\n - #74411 (Don't assign `()` to `!` MIR locals)\n - #74416 (Use an UTF-8 locale for the linker.)\n - #74424 (Move hir::Place to librustc_middle/hir)\n - #74428 (docs: better demonstrate that None values are skipped as many times a\u2026)\n - #74438 (warn about uninitialized multi-variant enums)\n - #74440 (Fix Arc::as_ptr docs)\n - #74452 (intra-doc links: resolve modules in the type namespace)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "2d4c9ecdcd068e028ae8367e165b9d54a8669633", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d4c9ecdcd068e028ae8367e165b9d54a8669633"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "html_url": "https://github.com/rust-lang/rust/commit/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39d5a61f2e4e237123837f5162cc275c2fd7e625", "url": "https://api.github.com/repos/rust-lang/rust/commits/39d5a61f2e4e237123837f5162cc275c2fd7e625", "html_url": "https://github.com/rust-lang/rust/commit/39d5a61f2e4e237123837f5162cc275c2fd7e625"}, {"sha": "c587386fd6eb21b5cc53cad2456e9745ec327855", "url": "https://api.github.com/repos/rust-lang/rust/commits/c587386fd6eb21b5cc53cad2456e9745ec327855", "html_url": "https://github.com/rust-lang/rust/commit/c587386fd6eb21b5cc53cad2456e9745ec327855"}], "stats": {"total": 2372, "additions": 1315, "deletions": 1057}, "files": [{"sha": "a8161c9bfb85927db91f9af30d330e1d98334968", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -16,6 +16,7 @@ use build_helper::{output, t};\n use crate::cache::{Cache, Interned, INTERNER};\n use crate::check;\n use crate::compile;\n+use crate::config::TargetSelection;\n use crate::dist;\n use crate::doc;\n use crate::flags::Subcommand;\n@@ -86,8 +87,8 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n \n pub struct RunConfig<'a> {\n     pub builder: &'a Builder<'a>,\n-    pub host: Interned<String>,\n-    pub target: Interned<String>,\n+    pub host: TargetSelection,\n+    pub target: TargetSelection,\n     pub path: PathBuf,\n }\n \n@@ -576,7 +577,7 @@ impl<'a> Builder<'a> {\n     /// not take `Compiler` since all `Compiler` instances are meant to be\n     /// obtained through this function, since it ensures that they are valid\n     /// (i.e., built and assembled).\n-    pub fn compiler(&self, stage: u32, host: Interned<String>) -> Compiler {\n+    pub fn compiler(&self, stage: u32, host: TargetSelection) -> Compiler {\n         self.ensure(compile::Assemble { target_compiler: Compiler { stage, host } })\n     }\n \n@@ -594,8 +595,8 @@ impl<'a> Builder<'a> {\n     pub fn compiler_for(\n         &self,\n         stage: u32,\n-        host: Interned<String>,\n-        target: Interned<String>,\n+        host: TargetSelection,\n+        target: TargetSelection,\n     ) -> Compiler {\n         if self.build.force_use_stage1(Compiler { stage, host }, target) {\n             self.compiler(1, self.config.build)\n@@ -610,15 +611,11 @@ impl<'a> Builder<'a> {\n \n     /// Returns the libdir where the standard library and other artifacts are\n     /// found for a compiler's sysroot.\n-    pub fn sysroot_libdir(\n-        &self,\n-        compiler: Compiler,\n-        target: Interned<String>,\n-    ) -> Interned<PathBuf> {\n+    pub fn sysroot_libdir(&self, compiler: Compiler, target: TargetSelection) -> Interned<PathBuf> {\n         #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         struct Libdir {\n             compiler: Compiler,\n-            target: Interned<String>,\n+            target: TargetSelection,\n         }\n         impl Step for Libdir {\n             type Output = Interned<PathBuf>;\n@@ -633,7 +630,7 @@ impl<'a> Builder<'a> {\n                     .sysroot(self.compiler)\n                     .join(lib)\n                     .join(\"rustlib\")\n-                    .join(self.target)\n+                    .join(self.target.triple)\n                     .join(\"lib\");\n                 let _ = fs::remove_dir_all(&sysroot);\n                 t!(fs::create_dir_all(&sysroot));\n@@ -656,7 +653,7 @@ impl<'a> Builder<'a> {\n                 Some(relative_libdir) if compiler.stage >= 1 => {\n                     self.sysroot(compiler).join(relative_libdir)\n                 }\n-                _ => self.sysroot(compiler).join(libdir(&compiler.host)),\n+                _ => self.sysroot(compiler).join(libdir(compiler.host)),\n             }\n         }\n     }\n@@ -668,11 +665,11 @@ impl<'a> Builder<'a> {\n     /// Windows.\n     pub fn libdir_relative(&self, compiler: Compiler) -> &Path {\n         if compiler.is_snapshot(self) {\n-            libdir(&self.config.build).as_ref()\n+            libdir(self.config.build).as_ref()\n         } else {\n             match self.config.libdir_relative() {\n                 Some(relative_libdir) if compiler.stage >= 1 => relative_libdir,\n-                _ => libdir(&compiler.host).as_ref(),\n+                _ => libdir(compiler.host).as_ref(),\n             }\n         }\n     }\n@@ -707,7 +704,7 @@ impl<'a> Builder<'a> {\n         if compiler.is_snapshot(self) {\n             self.initial_rustc.clone()\n         } else {\n-            self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", &compiler.host))\n+            self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", compiler.host))\n         }\n     }\n \n@@ -725,7 +722,11 @@ impl<'a> Builder<'a> {\n             .env(\"CFG_RELEASE_CHANNEL\", &self.config.channel)\n             .env(\"RUSTDOC_REAL\", self.rustdoc(compiler))\n             .env(\"RUSTDOC_CRATE_VERSION\", self.rust_version())\n-            .env(\"RUSTC_BOOTSTRAP\", \"1\");\n+            .env(\"RUSTC_BOOTSTRAP\", \"1\")\n+            .arg(\"-Winvalid_codeblock_attributes\");\n+        if self.config.deny_warnings {\n+            cmd.arg(\"-Dwarnings\");\n+        }\n \n         // Remove make-related flags that can cause jobserver problems.\n         cmd.env_remove(\"MAKEFLAGS\");\n@@ -741,7 +742,7 @@ impl<'a> Builder<'a> {\n     ///\n     /// Note that this returns `None` if LLVM is disabled, or if we're in a\n     /// check build or dry-run, where there's no need to build all of LLVM.\n-    fn llvm_config(&self, target: Interned<String>) -> Option<PathBuf> {\n+    fn llvm_config(&self, target: TargetSelection) -> Option<PathBuf> {\n         if self.config.llvm_enabled() && self.kind != Kind::Check && !self.config.dry_run {\n             let llvm_config = self.ensure(native::Llvm { target });\n             if llvm_config.is_file() {\n@@ -763,7 +764,7 @@ impl<'a> Builder<'a> {\n         compiler: Compiler,\n         mode: Mode,\n         source_type: SourceType,\n-        target: Interned<String>,\n+        target: TargetSelection,\n         cmd: &str,\n     ) -> Cargo {\n         let mut cargo = Command::new(&self.initial_cargo);\n@@ -773,7 +774,7 @@ impl<'a> Builder<'a> {\n             let my_out = match mode {\n                 // This is the intended out directory for compiler documentation.\n                 Mode::Rustc | Mode::ToolRustc | Mode::Codegen => self.compiler_doc_out(target),\n-                Mode::Std => out_dir.join(target).join(\"doc\"),\n+                Mode::Std => out_dir.join(target.triple).join(\"doc\"),\n                 _ => panic!(\"doc mode {:?} not expected\", mode),\n             };\n             let rustdoc = self.rustdoc(compiler);\n@@ -795,7 +796,7 @@ impl<'a> Builder<'a> {\n         }\n \n         if cmd != \"install\" {\n-            cargo.arg(\"--target\").arg(target);\n+            cargo.arg(\"--target\").arg(target.rustc_target_arg());\n         } else {\n             assert_eq!(target, compiler.host);\n         }\n@@ -821,7 +822,7 @@ impl<'a> Builder<'a> {\n             compiler.stage\n         };\n \n-        let mut rustflags = Rustflags::new(&target);\n+        let mut rustflags = Rustflags::new(target);\n         if stage != 0 {\n             if let Ok(s) = env::var(\"CARGOFLAGS_NOT_BOOTSTRAP\") {\n                 cargo.args(s.split_whitespace());\n@@ -838,7 +839,7 @@ impl<'a> Builder<'a> {\n         // FIXME: It might be better to use the same value for both `RUSTFLAGS` and `RUSTDOCFLAGS`,\n         // but this breaks CI. At the very least, stage0 `rustdoc` needs `--cfg bootstrap`. See\n         // #71458.\n-        let rustdocflags = rustflags.clone();\n+        let mut rustdocflags = rustflags.clone();\n \n         if let Ok(s) = env::var(\"CARGOFLAGS\") {\n             cargo.args(s.split_whitespace());\n@@ -994,7 +995,7 @@ impl<'a> Builder<'a> {\n         // argument manually via `-C link-args=-Wl,-rpath,...`. Plus isn't it\n         // fun to pass a flag to a tool to pass a flag to pass a flag to a tool\n         // to change a flag in a binary?\n-        if self.config.rust_rpath && util::use_host_linker(&target) {\n+        if self.config.rust_rpath && util::use_host_linker(target) {\n             let rpath = if target.contains(\"apple\") {\n                 // Note that we need to take one extra step on macOS to also pass\n                 // `-Wl,-instal_name,@rpath/...` to get things to work right. To\n@@ -1022,7 +1023,7 @@ impl<'a> Builder<'a> {\n         }\n \n         if let Some(target_linker) = self.linker(target, can_use_lld) {\n-            let target = crate::envify(&target);\n+            let target = crate::envify(&target.triple);\n             cargo.env(&format!(\"CARGO_TARGET_{}_LINKER\", target), target_linker);\n         }\n         if !([\"build\", \"check\", \"clippy\", \"fix\", \"rustc\"].contains(&cmd)) && want_rustdoc {\n@@ -1140,6 +1141,7 @@ impl<'a> Builder<'a> {\n \n             if self.config.deny_warnings {\n                 lint_flags.push(\"-Dwarnings\");\n+                rustdocflags.arg(\"-Dwarnings\");\n             }\n \n             // FIXME(#58633) hide \"unused attribute\" errors in incremental\n@@ -1157,6 +1159,8 @@ impl<'a> Builder<'a> {\n             // are always ignored in dependencies. Eventually this should be\n             // fixed via better support from Cargo.\n             cargo.env(\"RUSTC_LINT_FLAGS\", lint_flags.join(\" \"));\n+\n+            rustdocflags.arg(\"-Winvalid_codeblock_attributes\");\n         }\n \n         if let Mode::Rustc | Mode::Codegen = mode {\n@@ -1193,21 +1197,23 @@ impl<'a> Builder<'a> {\n                 }\n             };\n             let cc = ccacheify(&self.cc(target));\n-            cargo.env(format!(\"CC_{}\", target), &cc);\n+            cargo.env(format!(\"CC_{}\", target.triple), &cc);\n \n             let cflags = self.cflags(target, GitRepo::Rustc).join(\" \");\n-            cargo.env(format!(\"CFLAGS_{}\", target), cflags.clone());\n+            cargo.env(format!(\"CFLAGS_{}\", target.triple), cflags.clone());\n \n             if let Some(ar) = self.ar(target) {\n                 let ranlib = format!(\"{} s\", ar.display());\n-                cargo.env(format!(\"AR_{}\", target), ar).env(format!(\"RANLIB_{}\", target), ranlib);\n+                cargo\n+                    .env(format!(\"AR_{}\", target.triple), ar)\n+                    .env(format!(\"RANLIB_{}\", target.triple), ranlib);\n             }\n \n             if let Ok(cxx) = self.cxx(target) {\n                 let cxx = ccacheify(&cxx);\n                 cargo\n-                    .env(format!(\"CXX_{}\", target), &cxx)\n-                    .env(format!(\"CXXFLAGS_{}\", target), cflags);\n+                    .env(format!(\"CXX_{}\", target.triple), &cxx)\n+                    .env(format!(\"CXXFLAGS_{}\", target.triple), cflags);\n             }\n         }\n \n@@ -1241,7 +1247,7 @@ impl<'a> Builder<'a> {\n         // Environment variables *required* throughout the build\n         //\n         // FIXME: should update code to not require this env var\n-        cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n+        cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target.triple);\n \n         // Set this for all builds to make sure doc builds also get it.\n         cargo.env(\"CFG_RELEASE_CHANNEL\", &self.config.channel);\n@@ -1397,15 +1403,15 @@ mod tests;\n struct Rustflags(String);\n \n impl Rustflags {\n-    fn new(target: &str) -> Rustflags {\n+    fn new(target: TargetSelection) -> Rustflags {\n         let mut ret = Rustflags(String::new());\n \n         // Inherit `RUSTFLAGS` by default ...\n         ret.env(\"RUSTFLAGS\");\n \n         // ... and also handle target-specific env RUSTFLAGS if they're\n         // configured.\n-        let target_specific = format!(\"CARGO_TARGET_{}_RUSTFLAGS\", crate::envify(target));\n+        let target_specific = format!(\"CARGO_TARGET_{}_RUSTFLAGS\", crate::envify(&target.triple));\n         ret.env(&target_specific);\n \n         ret"}, {"sha": "69a54bec33b678ebbb8a062888100ea5f763f555", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -1,5 +1,5 @@\n use super::*;\n-use crate::config::Config;\n+use crate::config::{Config, TargetSelection};\n use std::thread;\n \n use pretty_assertions::assert_eq;\n@@ -17,16 +17,16 @@ fn configure(host: &[&str], target: &[&str]) -> Config {\n         .join(&thread::current().name().unwrap_or(\"unknown\").replace(\":\", \"-\"));\n     t!(fs::create_dir_all(&dir));\n     config.out = dir;\n-    config.build = INTERNER.intern_str(\"A\");\n+    config.build = TargetSelection::from_user(\"A\");\n     config.hosts = vec![config.build]\n         .into_iter()\n-        .chain(host.iter().map(|s| INTERNER.intern_str(s)))\n+        .chain(host.iter().map(|s| TargetSelection::from_user(s)))\n         .collect::<Vec<_>>();\n     config.targets = config\n         .hosts\n         .clone()\n         .into_iter()\n-        .chain(target.iter().map(|s| INTERNER.intern_str(s)))\n+        .chain(target.iter().map(|s| TargetSelection::from_user(s)))\n         .collect::<Vec<_>>();\n     config\n }\n@@ -41,7 +41,7 @@ fn dist_baseline() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n+    let a = TargetSelection::from_user(\"A\");\n \n     assert_eq!(first(builder.cache.all::<dist::Docs>()), &[dist::Docs { host: a },]);\n     assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[dist::Mingw { host: a },]);\n@@ -67,8 +67,8 @@ fn dist_with_targets() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n@@ -98,8 +98,8 @@ fn dist_with_hosts() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n@@ -128,8 +128,8 @@ fn dist_with_hosts() {\n \n #[test]\n fn dist_only_cross_host() {\n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n     let mut build = Build::new(configure(&[\"B\"], &[]));\n     build.config.docs = false;\n     build.config.extended = true;\n@@ -156,9 +156,9 @@ fn dist_with_targets_and_hosts() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n-    let c = INTERNER.intern_str(\"C\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n+    let c = TargetSelection::from_user(\"C\");\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n@@ -194,9 +194,9 @@ fn dist_with_target_flag() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n-    let c = INTERNER.intern_str(\"C\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n+    let c = TargetSelection::from_user(\"C\");\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n@@ -224,8 +224,8 @@ fn dist_with_same_targets_and_hosts() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n \n     assert_eq!(\n         first(builder.cache.all::<dist::Docs>()),\n@@ -277,9 +277,9 @@ fn build_default() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n-    let c = INTERNER.intern_str(\"C\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n+    let c = TargetSelection::from_user(\"C\");\n \n     assert_eq!(\n         first(builder.cache.all::<compile::Std>()),\n@@ -318,9 +318,9 @@ fn build_with_target_flag() {\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n \n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n-    let c = INTERNER.intern_str(\"C\");\n+    let a = TargetSelection::from_user(\"A\");\n+    let b = TargetSelection::from_user(\"B\");\n+    let c = TargetSelection::from_user(\"C\");\n \n     assert_eq!(\n         first(builder.cache.all::<compile::Std>()),\n@@ -374,7 +374,7 @@ fn test_with_no_doc_stage0() {\n     let build = Build::new(config);\n     let mut builder = Builder::new(&build);\n \n-    let host = INTERNER.intern_str(\"A\");\n+    let host = TargetSelection::from_user(\"A\");\n \n     builder\n         .run_step_descriptions(&[StepDescription::from::<test::Crate>()], &[\"src/libstd\".into()]);\n@@ -428,7 +428,7 @@ fn doc_default() {\n     let build = Build::new(config);\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), &[]);\n-    let a = INTERNER.intern_str(\"A\");\n+    let a = TargetSelection::from_user(\"A\");\n \n     // error_index_generator uses stage 1 to share rustdoc artifacts with the\n     // rustdoc tool.\n@@ -466,7 +466,7 @@ fn test_docs() {\n     let build = Build::new(config);\n     let mut builder = Builder::new(&build);\n     builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n-    let a = INTERNER.intern_str(\"A\");\n+    let a = TargetSelection::from_user(\"A\");\n \n     // error_index_generator uses stage 1 to share rustdoc artifacts with the\n     // rustdoc tool."}, {"sha": "7ff00d85dd2f24a0ea0d9bc8552e4d6960aadc11", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -28,16 +28,15 @@ use std::{env, iter};\n \n use build_helper::output;\n \n-use crate::cache::Interned;\n-use crate::config::Target;\n+use crate::config::{Target, TargetSelection};\n use crate::{Build, GitRepo};\n \n // The `cc` crate doesn't provide a way to obtain a path to the detected archiver,\n // so use some simplified logic here. First we respect the environment variable `AR`, then\n // try to infer the archiver path from the C compiler path.\n // In the future this logic should be replaced by calling into the `cc` crate.\n-fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n-    if let Some(ar) = env::var_os(format!(\"AR_{}\", target.replace(\"-\", \"_\"))) {\n+fn cc2ar(cc: &Path, target: TargetSelection) -> Option<PathBuf> {\n+    if let Some(ar) = env::var_os(format!(\"AR_{}\", target.triple.replace(\"-\", \"_\"))) {\n         Some(PathBuf::from(ar))\n     } else if let Some(ar) = env::var_os(\"AR\") {\n         Some(PathBuf::from(ar))\n@@ -79,8 +78,8 @@ pub fn find(build: &mut Build) {\n             .opt_level(2)\n             .warnings(false)\n             .debug(false)\n-            .target(&target)\n-            .host(&build.build);\n+            .target(&target.triple)\n+            .host(&build.build.triple);\n         match build.crt_static(target) {\n             Some(a) => {\n                 cfg.static_crt(a);\n@@ -106,10 +105,10 @@ pub fn find(build: &mut Build) {\n         let ar = if let ar @ Some(..) = config.and_then(|c| c.ar.clone()) {\n             ar\n         } else {\n-            cc2ar(compiler.path(), &target)\n+            cc2ar(compiler.path(), target)\n         };\n \n-        build.cc.insert(target, compiler);\n+        build.cc.insert(target, compiler.clone());\n         let cflags = build.cflags(target, GitRepo::Rustc);\n \n         // If we use llvm-libunwind, we will need a C++ compiler as well for all targets\n@@ -120,8 +119,8 @@ pub fn find(build: &mut Build) {\n             .warnings(false)\n             .debug(false)\n             .cpp(true)\n-            .target(&target)\n-            .host(&build.build);\n+            .target(&target.triple)\n+            .host(&build.build.triple);\n \n         let cxx_configured = if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n             cfg.compiler(cxx);\n@@ -138,14 +137,14 @@ pub fn find(build: &mut Build) {\n             build.cxx.insert(target, compiler);\n         }\n \n-        build.verbose(&format!(\"CC_{} = {:?}\", &target, build.cc(target)));\n-        build.verbose(&format!(\"CFLAGS_{} = {:?}\", &target, cflags));\n+        build.verbose(&format!(\"CC_{} = {:?}\", &target.triple, build.cc(target)));\n+        build.verbose(&format!(\"CFLAGS_{} = {:?}\", &target.triple, cflags));\n         if let Ok(cxx) = build.cxx(target) {\n-            build.verbose(&format!(\"CXX_{} = {:?}\", &target, cxx));\n-            build.verbose(&format!(\"CXXFLAGS_{} = {:?}\", &target, cflags));\n+            build.verbose(&format!(\"CXX_{} = {:?}\", &target.triple, cxx));\n+            build.verbose(&format!(\"CXXFLAGS_{} = {:?}\", &target.triple, cflags));\n         }\n         if let Some(ar) = ar {\n-            build.verbose(&format!(\"AR_{} = {:?}\", &target, ar));\n+            build.verbose(&format!(\"AR_{} = {:?}\", &target.triple, ar));\n             build.ar.insert(target, ar);\n         }\n     }\n@@ -154,17 +153,18 @@ pub fn find(build: &mut Build) {\n fn set_compiler(\n     cfg: &mut cc::Build,\n     compiler: Language,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     config: Option<&Target>,\n     build: &Build,\n ) {\n-    match &*target {\n+    match &*target.triple {\n         // When compiling for android we may have the NDK configured in the\n         // config.toml in which case we look there. Otherwise the default\n         // compiler already takes into account the triple in question.\n         t if t.contains(\"android\") => {\n             if let Some(ndk) = config.and_then(|c| c.ndk.as_ref()) {\n                 let target = target\n+                    .triple\n                     .replace(\"armv7neon\", \"arm\")\n                     .replace(\"armv7\", \"arm\")\n                     .replace(\"thumbv7neon\", \"arm\")"}, {"sha": "9f34bb4e6ccd73b159ab78cfd2b7112dae06cf62", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -1,15 +1,15 @@\n //! Implementation of compiling the compiler and standard library, in \"check\"-based modes.\n \n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n-use crate::cache::Interned;\n use crate::compile::{add_to_sysroot, run_cargo, rustc_cargo, std_cargo};\n+use crate::config::TargetSelection;\n use crate::tool::{prepare_tool_cargo, SourceType};\n use crate::{Compiler, Mode};\n use std::path::PathBuf;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Std {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n fn args(kind: Kind) -> Vec<String> {\n@@ -71,7 +71,7 @@ impl Step for Std {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Rustc {\n@@ -127,7 +127,7 @@ macro_rules! tool_check_step {\n     ($name:ident, $path:expr, $source_type:expr) => {\n         #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n         pub struct $name {\n-            pub target: Interned<String>,\n+            pub target: TargetSelection,\n         }\n \n         impl Step for $name {\n@@ -163,8 +163,8 @@ macro_rules! tool_check_step {\n                 println!(\n                     \"Checking {} artifacts ({} -> {})\",\n                     stringify!($name).to_lowercase(),\n-                    &compiler.host,\n-                    target\n+                    &compiler.host.triple,\n+                    target.triple\n                 );\n                 run_cargo(\n                     builder,\n@@ -184,7 +184,7 @@ macro_rules! tool_check_step {\n                 fn stamp(\n                     builder: &Builder<'_>,\n                     compiler: Compiler,\n-                    target: Interned<String>,\n+                    target: TargetSelection,\n                 ) -> PathBuf {\n                     builder\n                         .cargo_out(compiler, Mode::ToolRustc, target)\n@@ -204,12 +204,12 @@ tool_check_step!(Clippy, \"src/tools/clippy\", SourceType::InTree);\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-fn libstd_stamp(builder: &Builder<'_>, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+fn libstd_stamp(builder: &Builder<'_>, compiler: Compiler, target: TargetSelection) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-fn librustc_stamp(builder: &Builder<'_>, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+fn librustc_stamp(builder: &Builder<'_>, compiler: Compiler, target: TargetSelection) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc-check.stamp\")\n }"}, {"sha": "f83dfe8e635e3a759b9c3a8e82d6d87e28ab318d", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -23,7 +23,7 @@ pub fn clean(build: &Build, all: bool) {\n         rm_rf(&build.out.join(\"dist\"));\n \n         for host in &build.hosts {\n-            let entries = match build.out.join(host).read_dir() {\n+            let entries = match build.out.join(host.triple).read_dir() {\n                 Ok(iter) => iter,\n                 Err(_) => continue,\n             };"}, {"sha": "89b070e15e28699e4c9d0e277c66b2c3f35fd255", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -22,6 +22,7 @@ use serde::Deserialize;\n use crate::builder::Cargo;\n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n+use crate::config::TargetSelection;\n use crate::dist;\n use crate::native;\n use crate::tool::SourceType;\n@@ -30,7 +31,7 @@ use crate::{Compiler, DependencyType, GitRepo, Mode};\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Std {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n     pub compiler: Compiler,\n }\n \n@@ -129,7 +130,7 @@ fn copy_and_stamp(\n fn copy_third_party_objects(\n     builder: &Builder<'_>,\n     compiler: &Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n ) -> Vec<(PathBuf, DependencyType)> {\n     let mut target_deps = vec![];\n \n@@ -157,7 +158,7 @@ fn copy_third_party_objects(\n fn copy_self_contained_objects(\n     builder: &Builder<'_>,\n     compiler: &Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n ) -> Vec<(PathBuf, DependencyType)> {\n     let libdir_self_contained = builder.sysroot_libdir(*compiler, target).join(\"self-contained\");\n     t!(fs::create_dir_all(&libdir_self_contained));\n@@ -206,7 +207,7 @@ fn copy_self_contained_objects(\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n /// and such.\n-pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, stage: u32, cargo: &mut Cargo) {\n+pub fn std_cargo(builder: &Builder<'_>, target: TargetSelection, stage: u32, cargo: &mut Cargo) {\n     if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n@@ -301,7 +302,7 @@ pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, stage: u32, ca\n struct StdLink {\n     pub compiler: Compiler,\n     pub target_compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for StdLink {\n@@ -337,7 +338,7 @@ impl Step for StdLink {\n fn copy_sanitizers(\n     builder: &Builder<'_>,\n     compiler: &Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n ) -> Vec<PathBuf> {\n     let runtimes: Vec<native::SanitizerRuntime> = builder.ensure(native::Sanitizers { target });\n \n@@ -372,7 +373,7 @@ fn copy_sanitizers(\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct StartupObjects {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for StartupObjects {\n@@ -419,7 +420,7 @@ impl Step for StartupObjects {\n                         .arg(\"--cfg\")\n                         .arg(\"bootstrap\")\n                         .arg(\"--target\")\n-                        .arg(target)\n+                        .arg(target.rustc_target_arg())\n                         .arg(\"--emit=obj\")\n                         .arg(\"-o\")\n                         .arg(dst_file)\n@@ -438,7 +439,7 @@ impl Step for StartupObjects {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n     pub compiler: Compiler,\n }\n \n@@ -518,7 +519,7 @@ impl Step for Rustc {\n     }\n }\n \n-pub fn rustc_cargo(builder: &Builder<'_>, cargo: &mut Cargo, target: Interned<String>) {\n+pub fn rustc_cargo(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetSelection) {\n     cargo\n         .arg(\"--features\")\n         .arg(builder.rustc_features())\n@@ -527,7 +528,7 @@ pub fn rustc_cargo(builder: &Builder<'_>, cargo: &mut Cargo, target: Interned<St\n     rustc_cargo_env(builder, cargo, target);\n }\n \n-pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: Interned<String>) {\n+pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetSelection) {\n     // Set some configuration variables picked up by build scripts and\n     // the compiler alike\n     cargo\n@@ -608,7 +609,7 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: Interne\n struct RustcLink {\n     pub compiler: Compiler,\n     pub target_compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for RustcLink {\n@@ -638,11 +639,7 @@ impl Step for RustcLink {\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-pub fn libstd_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n+pub fn libstd_stamp(builder: &Builder<'_>, compiler: Compiler, target: TargetSelection) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd.stamp\")\n }\n \n@@ -651,15 +648,15 @@ pub fn libstd_stamp(\n pub fn librustc_stamp(\n     builder: &Builder<'_>,\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n ) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc.stamp\")\n }\n \n pub fn compiler_file(\n     builder: &Builder<'_>,\n     compiler: &Path,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     file: &str,\n ) -> PathBuf {\n     let mut cmd = Command::new(compiler);\n@@ -690,9 +687,9 @@ impl Step for Sysroot {\n     fn run(self, builder: &Builder<'_>) -> Interned<PathBuf> {\n         let compiler = self.compiler;\n         let sysroot = if compiler.stage == 0 {\n-            builder.out.join(&compiler.host).join(\"stage0-sysroot\")\n+            builder.out.join(&compiler.host.triple).join(\"stage0-sysroot\")\n         } else {\n-            builder.out.join(&compiler.host).join(format!(\"stage{}\", compiler.stage))\n+            builder.out.join(&compiler.host.triple).join(format!(\"stage{}\", compiler.stage))\n         };\n         let _ = fs::remove_dir_all(&sysroot);\n         t!(fs::create_dir_all(&sysroot));\n@@ -806,8 +803,8 @@ impl Step for Assemble {\n \n         let libdir = builder.sysroot_libdir(target_compiler, target_compiler.host);\n         if let Some(lld_install) = lld_install {\n-            let src_exe = exe(\"lld\", &target_compiler.host);\n-            let dst_exe = exe(\"rust-lld\", &target_compiler.host);\n+            let src_exe = exe(\"lld\", target_compiler.host);\n+            let dst_exe = exe(\"rust-lld\", target_compiler.host);\n             // we prepend this bin directory to the user PATH when linking Rust binaries. To\n             // avoid shadowing the system LLD we rename the LLD we provide to `rust-lld`.\n             let dst = libdir.parent().unwrap().join(\"bin\");\n@@ -822,7 +819,7 @@ impl Step for Assemble {\n \n         // Link the compiler binary itself into place\n         let out_dir = builder.cargo_out(build_compiler, Mode::Rustc, host);\n-        let rustc = out_dir.join(exe(\"rustc_binary\", &*host));\n+        let rustc = out_dir.join(exe(\"rustc_binary\", host));\n         let bindir = sysroot.join(\"bin\");\n         t!(fs::create_dir_all(&bindir));\n         let compiler = builder.rustc(target_compiler);"}, {"sha": "d71f31704209eb1b895956fe5acd46f37589509f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 74, "deletions": 10, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -7,6 +7,7 @@ use std::cmp;\n use std::collections::{HashMap, HashSet};\n use std::env;\n use std::ffi::OsString;\n+use std::fmt;\n use std::fs;\n use std::path::{Path, PathBuf};\n use std::process;\n@@ -39,7 +40,7 @@ pub struct Config {\n     pub docs: bool,\n     pub locked_deps: bool,\n     pub vendor: bool,\n-    pub target_config: HashMap<Interned<String>, Target>,\n+    pub target_config: HashMap<TargetSelection, Target>,\n     pub full_bootstrap: bool,\n     pub extended: bool,\n     pub tools: Option<HashSet<String>>,\n@@ -112,9 +113,9 @@ pub struct Config {\n     pub rust_thin_lto_import_instr_limit: Option<u32>,\n     pub rust_remap_debuginfo: bool,\n \n-    pub build: Interned<String>,\n-    pub hosts: Vec<Interned<String>>,\n-    pub targets: Vec<Interned<String>>,\n+    pub build: TargetSelection,\n+    pub hosts: Vec<TargetSelection>,\n+    pub targets: Vec<TargetSelection>,\n     pub local_rebuild: bool,\n     pub jemalloc: bool,\n     pub control_flow_guard: bool,\n@@ -158,6 +159,67 @@ pub struct Config {\n     pub out: PathBuf,\n }\n \n+#[derive(Debug, Copy, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct TargetSelection {\n+    pub triple: Interned<String>,\n+    file: Option<Interned<String>>,\n+}\n+\n+impl TargetSelection {\n+    pub fn from_user(selection: &str) -> Self {\n+        let path = Path::new(selection);\n+\n+        let (triple, file) = if path.exists() {\n+            let triple = path\n+                .file_stem()\n+                .expect(\"Target specification file has no file stem\")\n+                .to_str()\n+                .expect(\"Target specification file stem is not UTF-8\");\n+\n+            (triple, Some(selection))\n+        } else {\n+            (selection, None)\n+        };\n+\n+        let triple = INTERNER.intern_str(triple);\n+        let file = file.map(|f| INTERNER.intern_str(f));\n+\n+        Self { triple, file }\n+    }\n+\n+    pub fn rustc_target_arg(&self) -> &str {\n+        self.file.as_ref().unwrap_or(&self.triple)\n+    }\n+\n+    pub fn contains(&self, needle: &str) -> bool {\n+        self.triple.contains(needle)\n+    }\n+\n+    pub fn starts_with(&self, needle: &str) -> bool {\n+        self.triple.starts_with(needle)\n+    }\n+\n+    pub fn ends_with(&self, needle: &str) -> bool {\n+        self.triple.ends_with(needle)\n+    }\n+}\n+\n+impl fmt::Display for TargetSelection {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.triple)?;\n+        if let Some(file) = self.file {\n+            write!(f, \"({})\", file)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl PartialEq<&str> for TargetSelection {\n+    fn eq(&self, other: &&str) -> bool {\n+        self.triple == *other\n+    }\n+}\n+\n /// Per-target configuration stored in the global configuration structure.\n #[derive(Default)]\n pub struct Target {\n@@ -403,7 +465,7 @@ impl Config {\n         config.missing_tools = false;\n \n         // set by bootstrap.py\n-        config.build = INTERNER.intern_str(&env::var(\"BUILD\").expect(\"'BUILD' to be set\"));\n+        config.build = TargetSelection::from_user(&env::var(\"BUILD\").expect(\"'BUILD' to be set\"));\n         config.src = Config::path_from_python(\"SRC\");\n         config.out = Config::path_from_python(\"BUILD_DIR\");\n \n@@ -464,14 +526,16 @@ impl Config {\n         let build = toml.build.clone().unwrap_or_default();\n         // set by bootstrap.py\n         config.hosts.push(config.build.clone());\n-        for host in build.host.iter() {\n-            let host = INTERNER.intern_str(host);\n+        for host in build.host.iter().map(|h| TargetSelection::from_user(h)) {\n             if !config.hosts.contains(&host) {\n                 config.hosts.push(host);\n             }\n         }\n-        for target in\n-            config.hosts.iter().cloned().chain(build.target.iter().map(|s| INTERNER.intern_str(s)))\n+        for target in config\n+            .hosts\n+            .iter()\n+            .copied()\n+            .chain(build.target.iter().map(|h| TargetSelection::from_user(h)))\n         {\n             if !config.targets.contains(&target) {\n                 config.targets.push(target);\n@@ -637,7 +701,7 @@ impl Config {\n                 target.wasi_root = cfg.wasi_root.clone().map(PathBuf::from);\n                 target.qemu_rootfs = cfg.qemu_rootfs.clone().map(PathBuf::from);\n \n-                config.target_config.insert(INTERNER.intern_string(triple.clone()), target);\n+                config.target_config.insert(TargetSelection::from_user(triple), target);\n             }\n         }\n "}, {"sha": "af30747a9592e6dcaf4eccaa226ba34f0c1d06cb", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -20,6 +20,7 @@ use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::channel;\n use crate::compile;\n+use crate::config::TargetSelection;\n use crate::tool::{self, Tool};\n use crate::util::{exe, is_dylib, timeit};\n use crate::{Compiler, DependencyType, Mode, LLVM_TOOLS};\n@@ -68,7 +69,7 @@ fn missing_tool(tool_name: &str, skip: bool) {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Docs {\n-    pub host: Interned<String>,\n+    pub host: TargetSelection,\n }\n \n impl Step for Docs {\n@@ -131,7 +132,7 @@ impl Step for Docs {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustcDocs {\n-    pub host: Interned<String>,\n+    pub host: TargetSelection,\n }\n \n impl Step for RustcDocs {\n@@ -210,11 +211,11 @@ fn find_files(files: &[&str], path: &[PathBuf]) -> Vec<PathBuf> {\n fn make_win_dist(\n     rust_root: &Path,\n     plat_root: &Path,\n-    target_triple: Interned<String>,\n+    target: TargetSelection,\n     builder: &Builder<'_>,\n ) {\n     //Ask gcc where it keeps its stuff\n-    let mut cmd = Command::new(builder.cc(target_triple));\n+    let mut cmd = Command::new(builder.cc(target));\n     cmd.arg(\"-print-search-dirs\");\n     let gcc_out = output(&mut cmd);\n \n@@ -234,16 +235,16 @@ fn make_win_dist(\n         }\n     }\n \n-    let compiler = if target_triple == \"i686-pc-windows-gnu\" {\n+    let compiler = if target == \"i686-pc-windows-gnu\" {\n         \"i686-w64-mingw32-gcc.exe\"\n-    } else if target_triple == \"x86_64-pc-windows-gnu\" {\n+    } else if target == \"x86_64-pc-windows-gnu\" {\n         \"x86_64-w64-mingw32-gcc.exe\"\n     } else {\n         \"gcc.exe\"\n     };\n     let target_tools = [compiler, \"ld.exe\", \"dlltool.exe\", \"libwinpthread-1.dll\"];\n     let mut rustc_dlls = vec![\"libwinpthread-1.dll\"];\n-    if target_triple.starts_with(\"i686-\") {\n+    if target.starts_with(\"i686-\") {\n         rustc_dlls.push(\"libgcc_s_dw2-1.dll\");\n     } else {\n         rustc_dlls.push(\"libgcc_s_seh-1.dll\");\n@@ -311,7 +312,7 @@ fn make_win_dist(\n     let target_bin_dir = plat_root\n         .join(\"lib\")\n         .join(\"rustlib\")\n-        .join(target_triple)\n+        .join(target.triple)\n         .join(\"bin\")\n         .join(\"self-contained\");\n     fs::create_dir_all(&target_bin_dir).expect(\"creating target_bin_dir failed\");\n@@ -331,7 +332,7 @@ fn make_win_dist(\n     let target_lib_dir = plat_root\n         .join(\"lib\")\n         .join(\"rustlib\")\n-        .join(target_triple)\n+        .join(target.triple)\n         .join(\"lib\")\n         .join(\"self-contained\");\n     fs::create_dir_all(&target_lib_dir).expect(\"creating target_lib_dir failed\");\n@@ -342,7 +343,7 @@ fn make_win_dist(\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Mingw {\n-    pub host: Interned<String>,\n+    pub host: TargetSelection,\n }\n \n impl Step for Mingw {\n@@ -530,11 +531,11 @@ impl Step for Rustc {\n \n             // Copy over lld if it's there\n             if builder.config.lld_enabled {\n-                let exe = exe(\"rust-lld\", &compiler.host);\n+                let exe = exe(\"rust-lld\", compiler.host);\n                 let src =\n                     builder.sysroot_libdir(compiler, host).parent().unwrap().join(\"bin\").join(&exe);\n                 // for the rationale about this rename check `compile::copy_lld_to_sysroot`\n-                let dst = image.join(\"lib/rustlib\").join(&*host).join(\"bin\").join(&exe);\n+                let dst = image.join(\"lib/rustlib\").join(&*host.triple).join(\"bin\").join(&exe);\n                 t!(fs::create_dir_all(&dst.parent().unwrap()));\n                 builder.copy(&src, &dst);\n             }\n@@ -592,7 +593,7 @@ impl Step for Rustc {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct DebuggerScripts {\n     pub sysroot: Interned<PathBuf>,\n-    pub host: Interned<String>,\n+    pub host: TargetSelection,\n }\n \n impl Step for DebuggerScripts {\n@@ -662,8 +663,8 @@ fn skip_host_target_lib(builder: &Builder<'_>, compiler: Compiler) -> bool {\n }\n \n /// Copy stamped files into an image's `target/lib` directory.\n-fn copy_target_libs(builder: &Builder<'_>, target: &str, image: &Path, stamp: &Path) {\n-    let dst = image.join(\"lib/rustlib\").join(target).join(\"lib\");\n+fn copy_target_libs(builder: &Builder<'_>, target: TargetSelection, image: &Path, stamp: &Path) {\n+    let dst = image.join(\"lib/rustlib\").join(target.triple).join(\"lib\");\n     let self_contained_dst = dst.join(\"self-contained\");\n     t!(fs::create_dir_all(&dst));\n     t!(fs::create_dir_all(&self_contained_dst));\n@@ -679,7 +680,7 @@ fn copy_target_libs(builder: &Builder<'_>, target: &str, image: &Path, stamp: &P\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Std {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Std {\n@@ -718,7 +719,7 @@ impl Step for Std {\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         let stamp = compile::libstd_stamp(builder, compiler_to_use, target);\n-        copy_target_libs(builder, &target, &image, &stamp);\n+        copy_target_libs(builder, target, &image, &stamp);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -747,7 +748,7 @@ impl Step for Std {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustcDev {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for RustcDev {\n@@ -787,7 +788,7 @@ impl Step for RustcDev {\n \n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         let stamp = compile::librustc_stamp(builder, compiler_to_use, target);\n-        copy_target_libs(builder, &target, &image, &stamp);\n+        copy_target_libs(builder, target, &image, &stamp);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -818,7 +819,7 @@ impl Step for RustcDev {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Analysis {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Analysis {\n@@ -861,12 +862,12 @@ impl Step for Analysis {\n \n         let src = builder\n             .stage_out(compiler, Mode::Std)\n-            .join(target)\n+            .join(target.triple)\n             .join(builder.cargo_dir())\n             .join(\"deps\");\n \n         let image_src = src.join(\"save-analysis\");\n-        let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n+        let dst = image.join(\"lib/rustlib\").join(target.triple).join(\"analysis\");\n         t!(fs::create_dir_all(&dst));\n         builder.info(&format!(\"image_src: {:?}, dst: {:?}\", image_src, dst));\n         builder.cp_r(&image_src, &dst);\n@@ -1163,7 +1164,7 @@ pub fn sanitize_sh(path: &Path) -> String {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Cargo {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Cargo {\n@@ -1255,7 +1256,7 @@ impl Step for Cargo {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rls {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Rls {\n@@ -1345,7 +1346,7 @@ impl Step for Rls {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustAnalyzer {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for RustAnalyzer {\n@@ -1432,7 +1433,7 @@ impl Step for RustAnalyzer {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Clippy {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Clippy {\n@@ -1523,7 +1524,7 @@ impl Step for Clippy {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Miri {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Miri {\n@@ -1620,7 +1621,7 @@ impl Step for Miri {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustfmt {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Rustfmt {\n@@ -1714,8 +1715,8 @@ impl Step for Rustfmt {\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Extended {\n     stage: u32,\n-    host: Interned<String>,\n-    target: Interned<String>,\n+    host: TargetSelection,\n+    target: TargetSelection,\n }\n \n impl Step for Extended {\n@@ -2255,7 +2256,7 @@ impl Step for Extended {\n     }\n }\n \n-fn add_env(builder: &Builder<'_>, cmd: &mut Command, target: Interned<String>) {\n+fn add_env(builder: &Builder<'_>, cmd: &mut Command, target: TargetSelection) {\n     let mut parts = channel::CFG_RELEASE_NUM.split('.');\n     cmd.env(\"CFG_RELEASE_INFO\", builder.rust_version())\n         .env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM)\n@@ -2266,7 +2267,7 @@ fn add_env(builder: &Builder<'_>, cmd: &mut Command, target: Interned<String>) {\n         .env(\"CFG_VER_BUILD\", \"0\") // just needed to build\n         .env(\"CFG_PACKAGE_VERS\", builder.rust_package_vers())\n         .env(\"CFG_PACKAGE_NAME\", pkgname(builder, \"rust\"))\n-        .env(\"CFG_BUILD\", target)\n+        .env(\"CFG_BUILD\", target.triple)\n         .env(\"CFG_CHANNEL\", &builder.config.channel);\n \n     if target.contains(\"windows-gnu\") {\n@@ -2348,7 +2349,7 @@ impl Step for HashSign {\n ///\n /// Note: This function does not yet support Windows, but we also don't support\n ///       linking LLVM tools dynamically on Windows yet.\n-fn maybe_install_llvm(builder: &Builder<'_>, target: Interned<String>, dst_libdir: &Path) {\n+fn maybe_install_llvm(builder: &Builder<'_>, target: TargetSelection, dst_libdir: &Path) {\n     let src_libdir = builder.llvm_out(target).join(\"lib\");\n \n     if target.contains(\"apple-darwin\") {\n@@ -2373,21 +2374,21 @@ fn maybe_install_llvm(builder: &Builder<'_>, target: Interned<String>, dst_libdi\n }\n \n /// Maybe add libLLVM.so to the target lib-dir for linking.\n-pub fn maybe_install_llvm_target(builder: &Builder<'_>, target: Interned<String>, sysroot: &Path) {\n-    let dst_libdir = sysroot.join(\"lib/rustlib\").join(&*target).join(\"lib\");\n+pub fn maybe_install_llvm_target(builder: &Builder<'_>, target: TargetSelection, sysroot: &Path) {\n+    let dst_libdir = sysroot.join(\"lib/rustlib\").join(&*target.triple).join(\"lib\");\n     maybe_install_llvm(builder, target, &dst_libdir);\n }\n \n /// Maybe add libLLVM.so to the runtime lib-dir for rustc itself.\n-pub fn maybe_install_llvm_runtime(builder: &Builder<'_>, target: Interned<String>, sysroot: &Path) {\n+pub fn maybe_install_llvm_runtime(builder: &Builder<'_>, target: TargetSelection, sysroot: &Path) {\n     let dst_libdir =\n         sysroot.join(builder.sysroot_libdir_relative(Compiler { stage: 1, host: target }));\n     maybe_install_llvm(builder, target, &dst_libdir);\n }\n \n #[derive(Clone, Debug, Eq, Hash, PartialEq)]\n pub struct LlvmTools {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for LlvmTools {\n@@ -2425,10 +2426,10 @@ impl Step for LlvmTools {\n \n         // Prepare the image directory\n         let src_bindir = builder.llvm_out(target).join(\"bin\");\n-        let dst_bindir = image.join(\"lib/rustlib\").join(&*target).join(\"bin\");\n+        let dst_bindir = image.join(\"lib/rustlib\").join(&*target.triple).join(\"bin\");\n         t!(fs::create_dir_all(&dst_bindir));\n         for tool in LLVM_TOOLS {\n-            let exe = src_bindir.join(exe(tool, &target));\n+            let exe = src_bindir.join(exe(tool, target));\n             builder.install(&exe, &dst_bindir, 0o755);\n         }\n "}, {"sha": "b051390fc2671f73b7fe1f134717b5e8a4bc4dec", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -18,7 +18,7 @@ use build_helper::{t, up_to_date};\n use crate::builder::{Builder, Compiler, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::compile;\n-use crate::config::Config;\n+use crate::config::{Config, TargetSelection};\n use crate::tool::{self, prepare_tool_cargo, SourceType, Tool};\n use crate::util::symlink_dir;\n \n@@ -27,7 +27,7 @@ macro_rules! book {\n         $(\n             #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n-            target: Interned<String>,\n+            target: TargetSelection,\n         }\n \n         impl Step for $name {\n@@ -101,7 +101,7 @@ fn is_explicit_request(builder: &Builder<'_>, path: &str) -> bool {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct UnstableBook {\n-    target: Interned<String>,\n+    target: TargetSelection,\n }\n \n impl Step for UnstableBook {\n@@ -129,7 +129,7 @@ impl Step for UnstableBook {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n struct RustbookSrc {\n-    target: Interned<String>,\n+    target: TargetSelection,\n     name: Interned<String>,\n     src: Interned<PathBuf>,\n }\n@@ -169,7 +169,7 @@ impl Step for RustbookSrc {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct TheBook {\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n }\n \n impl Step for TheBook {\n@@ -241,7 +241,7 @@ impl Step for TheBook {\n fn invoke_rustdoc(\n     builder: &Builder<'_>,\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     markdown: &str,\n ) {\n     let out = builder.doc_out(target);\n@@ -277,7 +277,7 @@ fn invoke_rustdoc(\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Standalone {\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n }\n \n impl Step for Standalone {\n@@ -386,7 +386,7 @@ impl Step for Standalone {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Std {\n     pub stage: u32,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Std {\n@@ -415,7 +415,7 @@ impl Step for Std {\n         let compiler = builder.compiler(stage, builder.config.build);\n \n         builder.ensure(compile::Std { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Std).join(target).join(\"doc\");\n+        let out_dir = builder.stage_out(compiler, Mode::Std).join(target.triple).join(\"doc\");\n \n         t!(fs::copy(builder.src.join(\"src/doc/rust.css\"), out.join(\"rust.css\")));\n \n@@ -475,7 +475,7 @@ impl Step for Std {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustc {\n     stage: u32,\n-    target: Interned<String>,\n+    target: TargetSelection,\n }\n \n impl Step for Rustc {\n@@ -522,7 +522,7 @@ impl Step for Rustc {\n         // needed because rustdoc is built in a different directory from\n         // rustc. rustdoc needs to be able to see everything, for example when\n         // merging the search index, or generating local (relative) links.\n-        let out_dir = builder.stage_out(compiler, Mode::Rustc).join(target).join(\"doc\");\n+        let out_dir = builder.stage_out(compiler, Mode::Rustc).join(target.triple).join(\"doc\");\n         t!(symlink_dir_force(&builder.config, &out, &out_dir));\n \n         // Build cargo command.\n@@ -559,7 +559,7 @@ impl Step for Rustc {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustdoc {\n     stage: u32,\n-    target: Interned<String>,\n+    target: TargetSelection,\n }\n \n impl Step for Rustdoc {\n@@ -604,7 +604,7 @@ impl Step for Rustdoc {\n         builder.ensure(tool::Rustdoc { compiler });\n \n         // Symlink compiler docs to the output directory of rustdoc documentation.\n-        let out_dir = builder.stage_out(compiler, Mode::ToolRustc).join(target).join(\"doc\");\n+        let out_dir = builder.stage_out(compiler, Mode::ToolRustc).join(target.triple).join(\"doc\");\n         t!(fs::create_dir_all(&out_dir));\n         t!(symlink_dir_force(&builder.config, &out, &out_dir));\n \n@@ -632,7 +632,7 @@ impl Step for Rustdoc {\n #[derive(Ord, PartialOrd, Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct ErrorIndex {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for ErrorIndex {\n@@ -672,7 +672,7 @@ impl Step for ErrorIndex {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct UnstableBookGen {\n-    target: Interned<String>,\n+    target: TargetSelection,\n }\n \n impl Step for UnstableBookGen {"}, {"sha": "1055689c81e6a7680d5f4fd1e25c6175e9025ac4", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -10,8 +10,7 @@ use std::process;\n use getopts::Options;\n \n use crate::builder::Builder;\n-use crate::cache::{Interned, INTERNER};\n-use crate::config::Config;\n+use crate::config::{Config, TargetSelection};\n use crate::{Build, DocTests};\n \n /// Deserialized version of all flags for this compile.\n@@ -21,8 +20,8 @@ pub struct Flags {\n     pub stage: Option<u32>,\n     pub keep_stage: Vec<u32>,\n \n-    pub host: Vec<Interned<String>>,\n-    pub target: Vec<Interned<String>>,\n+    pub host: Vec<TargetSelection>,\n+    pub target: Vec<TargetSelection>,\n     pub config: Option<PathBuf>,\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n@@ -532,11 +531,11 @@ Arguments:\n                 .collect(),\n             host: split(&matches.opt_strs(\"host\"))\n                 .into_iter()\n-                .map(|x| INTERNER.intern_string(x))\n+                .map(|x| TargetSelection::from_user(&x))\n                 .collect::<Vec<_>>(),\n             target: split(&matches.opt_strs(\"target\"))\n                 .into_iter()\n-                .map(|x| INTERNER.intern_string(x))\n+                .map(|x| TargetSelection::from_user(&x))\n                 .collect::<Vec<_>>(),\n             config: cfg_file,\n             jobs: matches.opt_str(\"jobs\").map(|j| j.parse().expect(\"`jobs` should be a number\")),"}, {"sha": "7266625ff39f89176dc3b51c7c4a0a562d871345", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -14,46 +14,47 @@ use crate::dist::{self, pkgname, sanitize_sh, tmpdir};\n use crate::Compiler;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n-use crate::cache::Interned;\n-use crate::config::Config;\n+use crate::config::{Config, TargetSelection};\n \n-pub fn install_docs(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+pub fn install_docs(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"docs\", \"rust-docs\", stage, Some(host));\n }\n \n-pub fn install_std(builder: &Builder<'_>, stage: u32, target: Interned<String>) {\n+pub fn install_std(builder: &Builder<'_>, stage: u32, target: TargetSelection) {\n     install_sh(builder, \"std\", \"rust-std\", stage, Some(target));\n }\n \n-pub fn install_cargo(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+pub fn install_cargo(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"cargo\", \"cargo\", stage, Some(host));\n }\n \n-pub fn install_rls(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+pub fn install_rls(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"rls\", \"rls\", stage, Some(host));\n }\n-pub fn install_rust_analyzer(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+\n+pub fn install_rust_analyzer(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"rust-analyzer\", \"rust-analyzer\", stage, Some(host));\n }\n-pub fn install_clippy(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+\n+pub fn install_clippy(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"clippy\", \"clippy\", stage, Some(host));\n }\n-pub fn install_miri(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+pub fn install_miri(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"miri\", \"miri\", stage, Some(host));\n }\n \n-pub fn install_rustfmt(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+pub fn install_rustfmt(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"rustfmt\", \"rustfmt\", stage, Some(host));\n }\n \n-pub fn install_analysis(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+pub fn install_analysis(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"analysis\", \"rust-analysis\", stage, Some(host));\n }\n \n pub fn install_src(builder: &Builder<'_>, stage: u32) {\n     install_sh(builder, \"src\", \"rust-src\", stage, None);\n }\n-pub fn install_rustc(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n+pub fn install_rustc(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n     install_sh(builder, \"rustc\", \"rustc\", stage, Some(host));\n }\n \n@@ -62,7 +63,7 @@ fn install_sh(\n     package: &str,\n     name: &str,\n     stage: u32,\n-    host: Option<Interned<String>>,\n+    host: Option<TargetSelection>,\n ) {\n     builder.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n \n@@ -150,7 +151,7 @@ macro_rules! install {\n             #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n             pub compiler: Compiler,\n-            pub target: Interned<String>,\n+            pub target: TargetSelection,\n         }\n \n         impl $name {"}, {"sha": "77820ef87e3b470399217ffcbcb9c33128bcfe76", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -123,6 +123,7 @@ use std::os::windows::fs::symlink_file;\n use build_helper::{mtime, output, run, run_suppressed, t, try_run, try_run_suppressed};\n use filetime::FileTime;\n \n+use crate::config::TargetSelection;\n use crate::util::{exe, libdir, CiEnv};\n \n mod builder;\n@@ -187,7 +188,7 @@ const LLVM_TOOLS: &[&str] = &[\n #[derive(Eq, PartialOrd, Ord, PartialEq, Clone, Copy, Hash, Debug)]\n pub struct Compiler {\n     stage: u32,\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n #[derive(PartialEq, Eq, Copy, Clone, Debug)]\n@@ -236,9 +237,9 @@ pub struct Build {\n     verbosity: usize,\n \n     // Targets for which to build\n-    build: Interned<String>,\n-    hosts: Vec<Interned<String>>,\n-    targets: Vec<Interned<String>>,\n+    build: TargetSelection,\n+    hosts: Vec<TargetSelection>,\n+    targets: Vec<TargetSelection>,\n \n     // Stage 0 (downloaded) compiler, lld and cargo or their local rust equivalents\n     initial_rustc: PathBuf,\n@@ -248,18 +249,18 @@ pub struct Build {\n \n     // Runtime state filled in later on\n     // C/C++ compilers and archiver for all targets\n-    cc: HashMap<Interned<String>, cc::Tool>,\n-    cxx: HashMap<Interned<String>, cc::Tool>,\n-    ar: HashMap<Interned<String>, PathBuf>,\n-    ranlib: HashMap<Interned<String>, PathBuf>,\n+    cc: HashMap<TargetSelection, cc::Tool>,\n+    cxx: HashMap<TargetSelection, cc::Tool>,\n+    ar: HashMap<TargetSelection, PathBuf>,\n+    ranlib: HashMap<TargetSelection, PathBuf>,\n     // Miscellaneous\n     crates: HashMap<Interned<String>, Crate>,\n     is_sudo: bool,\n     ci_env: CiEnv,\n     delayed_failures: RefCell<Vec<String>>,\n     prerelease_version: Cell<Option<u32>>,\n     tool_artifacts:\n-        RefCell<HashMap<Interned<String>, HashMap<String, (&'static str, PathBuf, Vec<String>)>>>,\n+        RefCell<HashMap<TargetSelection, HashMap<String, (&'static str, PathBuf, Vec<String>)>>>,\n }\n \n #[derive(Debug)]\n@@ -365,7 +366,7 @@ impl Build {\n             output(\n                 Command::new(&config.initial_rustc)\n                     .arg(\"--target\")\n-                    .arg(config.build)\n+                    .arg(config.build.rustc_target_arg())\n                     .arg(\"--print\")\n                     .arg(\"target-libdir\"),\n             )\n@@ -453,7 +454,7 @@ impl Build {\n     }\n \n     pub fn build_triple(&self) -> &[Interned<String>] {\n-        unsafe { slice::from_raw_parts(&self.build, 1) }\n+        slice::from_ref(&self.build.triple)\n     }\n \n     /// Executes the entire build, as configured by the flags and configuration.\n@@ -558,7 +559,10 @@ impl Build {\n     }\n \n     fn tools_dir(&self, compiler: Compiler) -> PathBuf {\n-        let out = self.out.join(&*compiler.host).join(format!(\"stage{}-tools-bin\", compiler.stage));\n+        let out = self\n+            .out\n+            .join(&*compiler.host.triple)\n+            .join(format!(\"stage{}-tools-bin\", compiler.stage));\n         t!(fs::create_dir_all(&out));\n         out\n     }\n@@ -575,69 +579,69 @@ impl Build {\n             Mode::ToolBootstrap => \"-bootstrap-tools\",\n             Mode::ToolStd | Mode::ToolRustc => \"-tools\",\n         };\n-        self.out.join(&*compiler.host).join(format!(\"stage{}{}\", compiler.stage, suffix))\n+        self.out.join(&*compiler.host.triple).join(format!(\"stage{}{}\", compiler.stage, suffix))\n     }\n \n     /// Returns the root output directory for all Cargo output in a given stage,\n     /// running a particular compiler, whether or not we're building the\n     /// standard library, and targeting the specified architecture.\n-    fn cargo_out(&self, compiler: Compiler, mode: Mode, target: Interned<String>) -> PathBuf {\n-        self.stage_out(compiler, mode).join(&*target).join(self.cargo_dir())\n+    fn cargo_out(&self, compiler: Compiler, mode: Mode, target: TargetSelection) -> PathBuf {\n+        self.stage_out(compiler, mode).join(&*target.triple).join(self.cargo_dir())\n     }\n \n     /// Root output directory for LLVM compiled for `target`\n     ///\n     /// Note that if LLVM is configured externally then the directory returned\n     /// will likely be empty.\n-    fn llvm_out(&self, target: Interned<String>) -> PathBuf {\n-        self.out.join(&*target).join(\"llvm\")\n+    fn llvm_out(&self, target: TargetSelection) -> PathBuf {\n+        self.out.join(&*target.triple).join(\"llvm\")\n     }\n \n-    fn lld_out(&self, target: Interned<String>) -> PathBuf {\n-        self.out.join(&*target).join(\"lld\")\n+    fn lld_out(&self, target: TargetSelection) -> PathBuf {\n+        self.out.join(&*target.triple).join(\"lld\")\n     }\n \n     /// Output directory for all documentation for a target\n-    fn doc_out(&self, target: Interned<String>) -> PathBuf {\n-        self.out.join(&*target).join(\"doc\")\n+    fn doc_out(&self, target: TargetSelection) -> PathBuf {\n+        self.out.join(&*target.triple).join(\"doc\")\n     }\n \n     /// Output directory for all documentation for a target\n-    fn compiler_doc_out(&self, target: Interned<String>) -> PathBuf {\n-        self.out.join(&*target).join(\"compiler-doc\")\n+    fn compiler_doc_out(&self, target: TargetSelection) -> PathBuf {\n+        self.out.join(&*target.triple).join(\"compiler-doc\")\n     }\n \n     /// Output directory for some generated md crate documentation for a target (temporary)\n-    fn md_doc_out(&self, target: Interned<String>) -> Interned<PathBuf> {\n-        INTERNER.intern_path(self.out.join(&*target).join(\"md-doc\"))\n+    fn md_doc_out(&self, target: TargetSelection) -> Interned<PathBuf> {\n+        INTERNER.intern_path(self.out.join(&*target.triple).join(\"md-doc\"))\n     }\n \n     /// Returns `true` if no custom `llvm-config` is set for the specified target.\n     ///\n     /// If no custom `llvm-config` was specified then Rust's llvm will be used.\n-    fn is_rust_llvm(&self, target: Interned<String>) -> bool {\n+    fn is_rust_llvm(&self, target: TargetSelection) -> bool {\n         match self.config.target_config.get(&target) {\n             Some(ref c) => c.llvm_config.is_none(),\n             None => true,\n         }\n     }\n \n     /// Returns the path to `FileCheck` binary for the specified target\n-    fn llvm_filecheck(&self, target: Interned<String>) -> PathBuf {\n+    fn llvm_filecheck(&self, target: TargetSelection) -> PathBuf {\n         let target_config = self.config.target_config.get(&target);\n         if let Some(s) = target_config.and_then(|c| c.llvm_filecheck.as_ref()) {\n             s.to_path_buf()\n         } else if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n             let llvm_bindir = output(Command::new(s).arg(\"--bindir\"));\n-            let filecheck = Path::new(llvm_bindir.trim()).join(exe(\"FileCheck\", &*target));\n+            let filecheck = Path::new(llvm_bindir.trim()).join(exe(\"FileCheck\", target));\n             if filecheck.exists() {\n                 filecheck\n             } else {\n                 // On Fedora the system LLVM installs FileCheck in the\n                 // llvm subdirectory of the libdir.\n                 let llvm_libdir = output(Command::new(s).arg(\"--libdir\"));\n                 let lib_filecheck =\n-                    Path::new(llvm_libdir.trim()).join(\"llvm\").join(exe(\"FileCheck\", &*target));\n+                    Path::new(llvm_libdir.trim()).join(\"llvm\").join(exe(\"FileCheck\", target));\n                 if lib_filecheck.exists() {\n                     lib_filecheck\n                 } else {\n@@ -662,18 +666,18 @@ impl Build {\n             } else {\n                 base\n             };\n-            base.join(\"bin\").join(exe(\"FileCheck\", &*target))\n+            base.join(\"bin\").join(exe(\"FileCheck\", target))\n         }\n     }\n \n     /// Directory for libraries built from C/C++ code and shared between stages.\n-    fn native_dir(&self, target: Interned<String>) -> PathBuf {\n-        self.out.join(&*target).join(\"native\")\n+    fn native_dir(&self, target: TargetSelection) -> PathBuf {\n+        self.out.join(&*target.triple).join(\"native\")\n     }\n \n     /// Root output directory for rust_test_helpers library compiled for\n     /// `target`\n-    fn test_helpers_out(&self, target: Interned<String>) -> PathBuf {\n+    fn test_helpers_out(&self, target: TargetSelection) -> PathBuf {\n         self.native_dir(target).join(\"rust-test-helpers\")\n     }\n \n@@ -686,7 +690,7 @@ impl Build {\n \n     /// Returns the libdir of the snapshot compiler.\n     fn rustc_snapshot_libdir(&self) -> PathBuf {\n-        self.rustc_snapshot_sysroot().join(libdir(&self.config.build))\n+        self.rustc_snapshot_sysroot().join(libdir(self.config.build))\n     }\n \n     /// Returns the sysroot of the snapshot compiler.\n@@ -784,13 +788,13 @@ impl Build {\n     }\n \n     /// Returns the path to the C compiler for the target specified.\n-    fn cc(&self, target: Interned<String>) -> &Path {\n+    fn cc(&self, target: TargetSelection) -> &Path {\n         self.cc[&target].path()\n     }\n \n     /// Returns a list of flags to pass to the C compiler for the target\n     /// specified.\n-    fn cflags(&self, target: Interned<String>, which: GitRepo) -> Vec<String> {\n+    fn cflags(&self, target: TargetSelection, which: GitRepo) -> Vec<String> {\n         // Filter out -O and /O (the optimization flags) that we picked up from\n         // cc-rs because the build scripts will determine that for themselves.\n         let mut base = self.cc[&target]\n@@ -811,7 +815,7 @@ impl Build {\n         // Work around an apparently bad MinGW / GCC optimization,\n         // See: http://lists.llvm.org/pipermail/cfe-dev/2016-December/051980.html\n         // See: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78936\n-        if &*target == \"i686-pc-windows-gnu\" {\n+        if &*target.triple == \"i686-pc-windows-gnu\" {\n             base.push(\"-fno-omit-frame-pointer\".into());\n         }\n \n@@ -829,17 +833,17 @@ impl Build {\n     }\n \n     /// Returns the path to the `ar` archive utility for the target specified.\n-    fn ar(&self, target: Interned<String>) -> Option<&Path> {\n+    fn ar(&self, target: TargetSelection) -> Option<&Path> {\n         self.ar.get(&target).map(|p| &**p)\n     }\n \n     /// Returns the path to the `ranlib` utility for the target specified.\n-    fn ranlib(&self, target: Interned<String>) -> Option<&Path> {\n+    fn ranlib(&self, target: TargetSelection) -> Option<&Path> {\n         self.ranlib.get(&target).map(|p| &**p)\n     }\n \n     /// Returns the path to the C++ compiler for the target specified.\n-    fn cxx(&self, target: Interned<String>) -> Result<&Path, String> {\n+    fn cxx(&self, target: TargetSelection) -> Result<&Path, String> {\n         match self.cxx.get(&target) {\n             Some(p) => Ok(p.path()),\n             None => {\n@@ -849,12 +853,12 @@ impl Build {\n     }\n \n     /// Returns the path to the linker for the given target if it needs to be overridden.\n-    fn linker(&self, target: Interned<String>, can_use_lld: bool) -> Option<&Path> {\n+    fn linker(&self, target: TargetSelection, can_use_lld: bool) -> Option<&Path> {\n         if let Some(linker) = self.config.target_config.get(&target).and_then(|c| c.linker.as_ref())\n         {\n             Some(linker)\n         } else if target != self.config.build\n-            && util::use_host_linker(&target)\n+            && util::use_host_linker(target)\n             && !target.contains(\"msvc\")\n         {\n             Some(self.cc(target))\n@@ -866,7 +870,7 @@ impl Build {\n     }\n \n     /// Returns if this target should statically link the C runtime, if specified\n-    fn crt_static(&self, target: Interned<String>) -> Option<bool> {\n+    fn crt_static(&self, target: TargetSelection) -> Option<bool> {\n         if target.contains(\"pc-windows-msvc\") {\n             Some(true)\n         } else {\n@@ -875,7 +879,7 @@ impl Build {\n     }\n \n     /// Returns the \"musl root\" for this `target`, if defined\n-    fn musl_root(&self, target: Interned<String>) -> Option<&Path> {\n+    fn musl_root(&self, target: TargetSelection) -> Option<&Path> {\n         self.config\n             .target_config\n             .get(&target)\n@@ -885,7 +889,7 @@ impl Build {\n     }\n \n     /// Returns the \"musl libdir\" for this `target`.\n-    fn musl_libdir(&self, target: Interned<String>) -> Option<PathBuf> {\n+    fn musl_libdir(&self, target: TargetSelection) -> Option<PathBuf> {\n         let t = self.config.target_config.get(&target)?;\n         if let libdir @ Some(_) = &t.musl_libdir {\n             return libdir.clone();\n@@ -894,18 +898,18 @@ impl Build {\n     }\n \n     /// Returns the sysroot for the wasi target, if defined\n-    fn wasi_root(&self, target: Interned<String>) -> Option<&Path> {\n+    fn wasi_root(&self, target: TargetSelection) -> Option<&Path> {\n         self.config.target_config.get(&target).and_then(|t| t.wasi_root.as_ref()).map(|p| &**p)\n     }\n \n     /// Returns `true` if this is a no-std `target`, if defined\n-    fn no_std(&self, target: Interned<String>) -> Option<bool> {\n+    fn no_std(&self, target: TargetSelection) -> Option<bool> {\n         self.config.target_config.get(&target).map(|t| t.no_std)\n     }\n \n     /// Returns `true` if the target will be tested using the `remote-test-client`\n     /// and `remote-test-server` binaries.\n-    fn remote_tested(&self, target: Interned<String>) -> bool {\n+    fn remote_tested(&self, target: TargetSelection) -> bool {\n         self.qemu_rootfs(target).is_some()\n             || target.contains(\"android\")\n             || env::var_os(\"TEST_DEVICE_ADDR\").is_some()\n@@ -916,7 +920,7 @@ impl Build {\n     ///\n     /// If `Some` is returned then that means that tests for this target are\n     /// emulated with QEMU and binaries will need to be shipped to the emulator.\n-    fn qemu_rootfs(&self, target: Interned<String>) -> Option<&Path> {\n+    fn qemu_rootfs(&self, target: TargetSelection) -> Option<&Path> {\n         self.config.target_config.get(&target).and_then(|t| t.qemu_rootfs.as_ref()).map(|p| &**p)\n     }\n \n@@ -948,7 +952,7 @@ impl Build {\n     ///\n     /// When all of these conditions are met the build will lift artifacts from\n     /// the previous stage forward.\n-    fn force_use_stage1(&self, compiler: Compiler, target: Interned<String>) -> bool {\n+    fn force_use_stage1(&self, compiler: Compiler, target: TargetSelection) -> bool {\n         !self.config.full_bootstrap\n             && compiler.stage >= 2\n             && (self.hosts.iter().any(|h| *h == target) || target == self.build)\n@@ -1058,7 +1062,7 @@ impl Build {\n         self.rust_version()\n     }\n \n-    fn llvm_link_tools_dynamically(&self, target: Interned<String>) -> bool {\n+    fn llvm_link_tools_dynamically(&self, target: TargetSelection) -> bool {\n         target.contains(\"linux-gnu\") || target.contains(\"apple-darwin\")\n     }\n "}, {"sha": "48b2cc24d4cd8bfb22b62e84dab700b320e07046", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -19,8 +19,8 @@ use std::process::Command;\n use build_helper::{output, t};\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n-use crate::cache::Interned;\n use crate::channel;\n+use crate::config::TargetSelection;\n use crate::util::{self, exe};\n use crate::GitRepo;\n use build_helper::up_to_date;\n@@ -41,7 +41,7 @@ pub struct Meta {\n // if not).\n pub fn prebuilt_llvm_config(\n     builder: &Builder<'_>,\n-    target: Interned<String>,\n+    target: TargetSelection,\n ) -> Result<PathBuf, Meta> {\n     // If we're using a custom LLVM bail out here, but we can only use a\n     // custom LLVM for the build triple.\n@@ -54,13 +54,14 @@ pub fn prebuilt_llvm_config(\n \n     let root = \"src/llvm-project/llvm\";\n     let out_dir = builder.llvm_out(target);\n+\n     let mut llvm_config_ret_dir = builder.llvm_out(builder.config.build);\n     if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n         llvm_config_ret_dir.push(\"build\");\n     }\n     llvm_config_ret_dir.push(\"bin\");\n \n-    let build_llvm_config = llvm_config_ret_dir.join(exe(\"llvm-config\", &*builder.config.build));\n+    let build_llvm_config = llvm_config_ret_dir.join(exe(\"llvm-config\", builder.config.build));\n \n     let stamp = out_dir.join(\"llvm-finished-building\");\n     let stamp = HashStamp::new(stamp, builder.in_tree_llvm_info.sha());\n@@ -93,7 +94,7 @@ pub fn prebuilt_llvm_config(\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Llvm {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Llvm {\n@@ -115,9 +116,9 @@ impl Step for Llvm {\n         let target_native = if self.target.starts_with(\"riscv\") {\n             // RISC-V target triples in Rust is not named the same as C compiler target triples.\n             // This converts Rust RISC-V target triples to C compiler triples.\n-            let idx = target.find('-').unwrap();\n+            let idx = target.triple.find('-').unwrap();\n \n-            format!(\"riscv{}{}\", &target[5..7], &target[idx..])\n+            format!(\"riscv{}{}\", &target.triple[5..7], &target.triple[idx..])\n         } else {\n             target.to_string()\n         };\n@@ -359,7 +360,7 @@ fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n \n fn configure_cmake(\n     builder: &Builder<'_>,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     cfg: &mut cmake::Config,\n     use_compiler_launcher: bool,\n ) {\n@@ -375,7 +376,7 @@ fn configure_cmake(\n     if builder.config.ninja {\n         cfg.generator(\"Ninja\");\n     }\n-    cfg.target(&target).host(&builder.config.build);\n+    cfg.target(&target.triple).host(&builder.config.build.triple);\n \n     let sanitize_cc = |cc: &Path| {\n         if target.contains(\"msvc\") {\n@@ -405,7 +406,7 @@ fn configure_cmake(\n         cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&wrap_cc))\n             .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&wrap_cc));\n         cfg.env(\"SCCACHE_PATH\", builder.config.ccache.as_ref().unwrap())\n-            .env(\"SCCACHE_TARGET\", target)\n+            .env(\"SCCACHE_TARGET\", target.triple)\n             .env(\"SCCACHE_CC\", &cc)\n             .env(\"SCCACHE_CXX\", &cxx);\n \n@@ -505,7 +506,7 @@ fn configure_cmake(\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Lld {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Lld {\n@@ -578,8 +579,8 @@ impl Step for Lld {\n         // brittle and will break over time. If anyone knows better how to\n         // cross-compile LLD it would be much appreciated to fix this!\n         if target != builder.config.build {\n-            cfg.env(\"LLVM_CONFIG_SHIM_REPLACE\", &builder.config.build)\n-                .env(\"LLVM_CONFIG_SHIM_REPLACE_WITH\", &target)\n+            cfg.env(\"LLVM_CONFIG_SHIM_REPLACE\", &builder.config.build.triple)\n+                .env(\"LLVM_CONFIG_SHIM_REPLACE_WITH\", &target.triple)\n                 .define(\n                     \"LLVM_TABLEGEN_EXE\",\n                     llvm_config.with_file_name(\"llvm-tblgen\").with_extension(EXE_EXTENSION),\n@@ -599,7 +600,7 @@ impl Step for Lld {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct TestHelpers {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for TestHelpers {\n@@ -646,8 +647,8 @@ impl Step for TestHelpers {\n \n         cfg.cargo_metadata(false)\n             .out_dir(&dst)\n-            .target(&target)\n-            .host(&builder.config.build)\n+            .target(&target.triple)\n+            .host(&builder.config.build.triple)\n             .opt_level(0)\n             .warnings(false)\n             .debug(false)\n@@ -658,7 +659,7 @@ impl Step for TestHelpers {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Sanitizers {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Sanitizers {\n@@ -709,7 +710,7 @@ impl Step for Sanitizers {\n \n         let mut cfg = cmake::Config::new(&compiler_rt_dir);\n         cfg.profile(\"Release\");\n-        cfg.define(\"CMAKE_C_COMPILER_TARGET\", self.target);\n+        cfg.define(\"CMAKE_C_COMPILER_TARGET\", self.target.triple);\n         cfg.define(\"COMPILER_RT_BUILD_BUILTINS\", \"OFF\");\n         cfg.define(\"COMPILER_RT_BUILD_CRT\", \"OFF\");\n         cfg.define(\"COMPILER_RT_BUILD_LIBFUZZER\", \"OFF\");\n@@ -752,7 +753,7 @@ pub struct SanitizerRuntime {\n /// Returns sanitizers available on a given target.\n fn supported_sanitizers(\n     out_dir: &Path,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     channel: &str,\n ) -> Vec<SanitizerRuntime> {\n     let darwin_libs = |os: &str, components: &[&str]| -> Vec<SanitizerRuntime> {\n@@ -778,7 +779,7 @@ fn supported_sanitizers(\n             .collect()\n     };\n \n-    match &*target {\n+    match &*target.triple {\n         \"aarch64-fuchsia\" => common_libs(\"fuchsia\", \"aarch64\", &[\"asan\"]),\n         \"aarch64-unknown-linux-gnu\" => {\n             common_libs(\"linux\", \"aarch64\", &[\"asan\", \"lsan\", \"msan\", \"tsan\"])"}, {"sha": "f89bef50de982374352a826c163a0b3d70a27542", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -183,7 +183,11 @@ pub fn check(build: &mut Build) {\n             panic!(\"the iOS target is only supported on macOS\");\n         }\n \n-        build.config.target_config.entry(target.clone()).or_insert(Target::from_triple(target));\n+        build\n+            .config\n+            .target_config\n+            .entry(target.clone())\n+            .or_insert(Target::from_triple(&target.triple));\n \n         if target.contains(\"-none-\") || target.contains(\"nvptx\") {\n             if build.no_std(*target) == Some(false) {"}, {"sha": "b6641180c92c0fb9c421223c247637d406f1c0b2", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -16,6 +16,7 @@ use build_helper::{self, output, t};\n use crate::builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::compile;\n+use crate::config::TargetSelection;\n use crate::dist;\n use crate::flags::Subcommand;\n use crate::native;\n@@ -93,7 +94,7 @@ fn try_run_quiet(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Linkcheck {\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for Linkcheck {\n@@ -115,7 +116,7 @@ impl Step for Linkcheck {\n         let _time = util::timeit(&builder);\n         try_run(\n             builder,\n-            builder.tool_cmd(Tool::Linkchecker).arg(builder.out.join(host).join(\"doc\")),\n+            builder.tool_cmd(Tool::Linkchecker).arg(builder.out.join(host.triple).join(\"doc\")),\n         );\n     }\n \n@@ -132,7 +133,7 @@ impl Step for Linkcheck {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Cargotest {\n     stage: u32,\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for Cargotest {\n@@ -177,7 +178,7 @@ impl Step for Cargotest {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Cargo {\n     stage: u32,\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for Cargo {\n@@ -230,7 +231,7 @@ impl Step for Cargo {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rls {\n     stage: u32,\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for Rls {\n@@ -281,7 +282,7 @@ impl Step for Rls {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustfmt {\n     stage: u32,\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for Rustfmt {\n@@ -338,7 +339,7 @@ impl Step for Rustfmt {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Miri {\n     stage: u32,\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for Miri {\n@@ -464,7 +465,7 @@ impl Step for Miri {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CompiletestTest {\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for CompiletestTest {\n@@ -501,7 +502,7 @@ impl Step for CompiletestTest {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Clippy {\n     stage: u32,\n-    host: Interned<String>,\n+    host: TargetSelection,\n }\n \n impl Step for Clippy {\n@@ -542,8 +543,10 @@ impl Step for Clippy {\n         cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n         cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n         let host_libs = builder.stage_out(compiler, Mode::ToolRustc).join(builder.cargo_dir());\n-        let target_libs =\n-            builder.stage_out(compiler, Mode::ToolRustc).join(&self.host).join(builder.cargo_dir());\n+        let target_libs = builder\n+            .stage_out(compiler, Mode::ToolRustc)\n+            .join(&self.host.triple)\n+            .join(builder.cargo_dir());\n         cargo.env(\"HOST_LIBS\", host_libs);\n         cargo.env(\"TARGET_LIBS\", target_libs);\n         // clippy tests need to find the driver\n@@ -607,7 +610,7 @@ impl Step for RustdocTheme {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustdocJSStd {\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for RustdocJSStd {\n@@ -646,8 +649,8 @@ impl Step for RustdocJSStd {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustdocJSNotStd {\n-    pub host: Interned<String>,\n-    pub target: Interned<String>,\n+    pub host: TargetSelection,\n+    pub target: TargetSelection,\n     pub compiler: Compiler,\n }\n \n@@ -683,8 +686,8 @@ impl Step for RustdocJSNotStd {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustdocUi {\n-    pub host: Interned<String>,\n-    pub target: Interned<String>,\n+    pub host: TargetSelection,\n+    pub target: TargetSelection,\n     pub compiler: Compiler,\n }\n \n@@ -785,8 +788,8 @@ impl Step for ExpandYamlAnchors {\n     }\n }\n \n-fn testdir(builder: &Builder<'_>, host: Interned<String>) -> PathBuf {\n-    builder.out.join(host).join(\"test\")\n+fn testdir(builder: &Builder<'_>, host: TargetSelection) -> PathBuf {\n+    builder.out.join(host.triple).join(\"test\")\n }\n \n macro_rules! default_test {\n@@ -855,7 +858,7 @@ macro_rules! test_definitions {\n         #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n         pub struct $name {\n             pub compiler: Compiler,\n-            pub target: Interned<String>,\n+            pub target: TargetSelection,\n         }\n \n         impl Step for $name {\n@@ -943,7 +946,7 @@ default_test!(Assembly { path: \"src/test/assembly\", mode: \"assembly\", suite: \"as\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n struct Compiletest {\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     mode: &'static str,\n     suite: &'static str,\n     path: &'static str,\n@@ -1023,8 +1026,8 @@ impl Step for Compiletest {\n         cmd.arg(\"--build-base\").arg(testdir(builder, compiler.host).join(suite));\n         cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));\n         cmd.arg(\"--mode\").arg(mode);\n-        cmd.arg(\"--target\").arg(target);\n-        cmd.arg(\"--host\").arg(&*compiler.host);\n+        cmd.arg(\"--target\").arg(target.rustc_target_arg());\n+        cmd.arg(\"--host\").arg(&*compiler.host.triple);\n         cmd.arg(\"--llvm-filecheck\").arg(builder.llvm_filecheck(builder.config.build));\n \n         if builder.config.cmd.bless() {\n@@ -1543,7 +1546,7 @@ impl Step for RustcGuide {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CrateLibrustc {\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     test_kind: TestKind,\n     krate: Interned<String>,\n }\n@@ -1589,7 +1592,7 @@ impl Step for CrateLibrustc {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CrateNotDefault {\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     test_kind: TestKind,\n     krate: &'static str,\n }\n@@ -1638,7 +1641,7 @@ impl Step for CrateNotDefault {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Crate {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n     pub mode: Mode,\n     pub test_kind: TestKind,\n     pub krate: Interned<String>,\n@@ -1750,17 +1753,17 @@ impl Step for Crate {\n \n         if target.contains(\"emscripten\") {\n             cargo.env(\n-                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target.triple)),\n                 builder.config.nodejs.as_ref().expect(\"nodejs not configured\"),\n             );\n         } else if target.starts_with(\"wasm32\") {\n             let node = builder.config.nodejs.as_ref().expect(\"nodejs not configured\");\n             let runner =\n                 format!(\"{} {}/src/etc/wasm32-shim.js\", node.display(), builder.src.display());\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)), &runner);\n+            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target.triple)), &runner);\n         } else if builder.remote_tested(target) {\n             cargo.env(\n-                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target.triple)),\n                 format!(\"{} run 0\", builder.tool_exe(Tool::RemoteTestClient).display()),\n             );\n         }\n@@ -1776,7 +1779,7 @@ impl Step for Crate {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CrateRustdoc {\n-    host: Interned<String>,\n+    host: TargetSelection,\n     test_kind: TestKind,\n }\n \n@@ -1883,7 +1886,7 @@ impl Step for CrateRustdoc {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct RemoteCopyLibs {\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n }\n \n impl Step for RemoteCopyLibs {\n@@ -1911,7 +1914,7 @@ impl Step for RemoteCopyLibs {\n         // Spawn the emulator and wait for it to come online\n         let tool = builder.tool_exe(Tool::RemoteTestClient);\n         let mut cmd = Command::new(&tool);\n-        cmd.arg(\"spawn-emulator\").arg(target).arg(&server).arg(builder.out.join(\"tmp\"));\n+        cmd.arg(\"spawn-emulator\").arg(target.triple).arg(&server).arg(builder.out.join(\"tmp\"));\n         if let Some(rootfs) = builder.qemu_rootfs(target) {\n             cmd.arg(rootfs);\n         }\n@@ -1966,7 +1969,9 @@ impl Step for Distcheck {\n                 .current_dir(&dir),\n         );\n         builder.run(\n-            Command::new(build_helper::make(&builder.config.build)).arg(\"check\").current_dir(&dir),\n+            Command::new(build_helper::make(&builder.config.build.triple))\n+                .arg(\"check\")\n+                .current_dir(&dir),\n         );\n \n         // Now make sure that rust-src has all of libstd's dependencies"}, {"sha": "f66061975d64d1ecb8ef7e8d432f9e21de81987c", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -7,10 +7,10 @@ use std::process::{exit, Command};\n use build_helper::t;\n \n use crate::builder::{Builder, Cargo as CargoCommand, RunConfig, ShouldRun, Step};\n-use crate::cache::Interned;\n use crate::channel;\n use crate::channel::GitInfo;\n use crate::compile;\n+use crate::config::TargetSelection;\n use crate::toolstate::ToolState;\n use crate::util::{add_dylib_path, exe};\n use crate::Compiler;\n@@ -25,7 +25,7 @@ pub enum SourceType {\n #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n struct ToolBuild {\n     compiler: Compiler,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     tool: &'static str,\n     path: &'static str,\n     mode: Mode,\n@@ -111,7 +111,7 @@ impl Step for ToolBuild {\n                             .and_then(|p| p.file_name())\n                             .and_then(|p| p.to_str())\n                             .unwrap();\n-                        if maybe_target != &*target {\n+                        if maybe_target != &*target.triple {\n                             continue;\n                         }\n                     }\n@@ -208,8 +208,8 @@ impl Step for ToolBuild {\n             }\n         } else {\n             let cargo_out =\n-                builder.cargo_out(compiler, self.mode, target).join(exe(tool, &compiler.host));\n-            let bin = builder.tools_dir(compiler).join(exe(tool, &compiler.host));\n+                builder.cargo_out(compiler, self.mode, target).join(exe(tool, compiler.host));\n+            let bin = builder.tools_dir(compiler).join(exe(tool, compiler.host));\n             builder.copy(&cargo_out, &bin);\n             Some(bin)\n         }\n@@ -220,7 +220,7 @@ pub fn prepare_tool_cargo(\n     builder: &Builder<'_>,\n     compiler: Compiler,\n     mode: Mode,\n-    target: Interned<String>,\n+    target: TargetSelection,\n     command: &'static str,\n     path: &'static str,\n     source_type: SourceType,\n@@ -303,7 +303,7 @@ macro_rules! bootstrap_tool {\n             #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n             pub compiler: Compiler,\n-            pub target: Interned<String>,\n+            pub target: TargetSelection,\n         }\n \n         impl Step for $name {\n@@ -416,7 +416,7 @@ impl Step for ErrorIndex {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RemoteTestServer {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for RemoteTestServer {\n@@ -476,7 +476,7 @@ impl Step for Rustdoc {\n             if !target_compiler.is_snapshot(builder) {\n                 panic!(\"rustdoc in stage 0 must be snapshot rustdoc\");\n             }\n-            return builder.initial_rustc.with_file_name(exe(\"rustdoc\", &target_compiler.host));\n+            return builder.initial_rustc.with_file_name(exe(\"rustdoc\", target_compiler.host));\n         }\n         let target = target_compiler.host;\n         // Similar to `compile::Assemble`, build with the previous stage's compiler. Otherwise\n@@ -514,14 +514,14 @@ impl Step for Rustdoc {\n         // rustdoc a different name.\n         let tool_rustdoc = builder\n             .cargo_out(build_compiler, Mode::ToolRustc, target)\n-            .join(exe(\"rustdoc_tool_binary\", &target_compiler.host));\n+            .join(exe(\"rustdoc_tool_binary\", target_compiler.host));\n \n         // don't create a stage0-sysroot/bin directory.\n         if target_compiler.stage > 0 {\n             let sysroot = builder.sysroot(target_compiler);\n             let bindir = sysroot.join(\"bin\");\n             t!(fs::create_dir_all(&bindir));\n-            let bin_rustdoc = bindir.join(exe(\"rustdoc\", &*target_compiler.host));\n+            let bin_rustdoc = bindir.join(exe(\"rustdoc\", target_compiler.host));\n             let _ = fs::remove_file(&bin_rustdoc);\n             builder.copy(&tool_rustdoc, &bin_rustdoc);\n             bin_rustdoc\n@@ -534,7 +534,7 @@ impl Step for Rustdoc {\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Cargo {\n     pub compiler: Compiler,\n-    pub target: Interned<String>,\n+    pub target: TargetSelection,\n }\n \n impl Step for Cargo {\n@@ -583,7 +583,7 @@ macro_rules! tool_extended {\n             #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n             pub compiler: Compiler,\n-            pub target: Interned<String>,\n+            pub target: TargetSelection,\n             pub extra_features: Vec<String>,\n         }\n "}, {"sha": "a307ef39d03a8daba772d99b75f62e9958f30131", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -14,17 +14,16 @@ use std::time::Instant;\n use build_helper::t;\n \n use crate::builder::Builder;\n-use crate::cache::Interned;\n-use crate::config::Config;\n+use crate::config::{Config, TargetSelection};\n \n /// Returns the `name` as the filename of a static library for `target`.\n-pub fn staticlib(name: &str, target: &str) -> String {\n+pub fn staticlib(name: &str, target: TargetSelection) -> String {\n     if target.contains(\"windows\") { format!(\"{}.lib\", name) } else { format!(\"lib{}.a\", name) }\n }\n \n /// Given an executable called `name`, return the filename for the\n /// executable for a particular target.\n-pub fn exe(name: &str, target: &str) -> String {\n+pub fn exe(name: &str, target: TargetSelection) -> String {\n     if target.contains(\"windows\") { format!(\"{}.exe\", name) } else { name.to_string() }\n }\n \n@@ -35,7 +34,7 @@ pub fn is_dylib(name: &str) -> bool {\n \n /// Returns the corresponding relative library directory that the compiler's\n /// dylibs will be found in.\n-pub fn libdir(target: &str) -> &'static str {\n+pub fn libdir(target: TargetSelection) -> &'static str {\n     if target.contains(\"windows\") { \"bin\" } else { \"lib\" }\n }\n \n@@ -294,7 +293,7 @@ pub fn forcing_clang_based_tests() -> bool {\n     }\n }\n \n-pub fn use_host_linker(target: &Interned<String>) -> bool {\n+pub fn use_host_linker(target: TargetSelection) -> bool {\n     // FIXME: this information should be gotten by checking the linker flavor\n     // of the rustc target\n     !(target.contains(\"emscripten\")"}, {"sha": "0cf250576f176b402408a96585da795e04edeefc", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -573,7 +573,7 @@ impl<T: ?Sized> Arc<T> {\n \n     /// Provides a raw pointer to the data.\n     ///\n-    /// The counts are not affected in way and the `Arc` is not consumed. The pointer is valid for\n+    /// The counts are not affected in any way and the `Arc` is not consumed. The pointer is valid for\n     /// as long as there are strong counts in the `Arc`.\n     ///\n     /// # Examples"}, {"sha": "638e83c3b939da6d1996d73cf28fb337c353a242", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -324,7 +324,7 @@ impl<'a> Arguments<'a> {\n     #[doc(hidden)]\n     #[inline]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    pub fn new_v1(pieces: &'a [&'a str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+    pub fn new_v1(pieces: &'a [&'static str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n         Arguments { pieces, fmt: None, args }\n     }\n \n@@ -338,7 +338,7 @@ impl<'a> Arguments<'a> {\n     #[inline]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn new_v1_formatted(\n-        pieces: &'a [&'a str],\n+        pieces: &'a [&'static str],\n         args: &'a [ArgumentV1<'a>],\n         fmt: &'a [rt::v1::Argument],\n     ) -> Arguments<'a> {\n@@ -399,7 +399,7 @@ impl<'a> Arguments<'a> {\n #[derive(Copy, Clone)]\n pub struct Arguments<'a> {\n     // Format string pieces to print.\n-    pieces: &'a [&'a str],\n+    pieces: &'a [&'static str],\n \n     // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n     fmt: Option<&'a [rt::v1::Argument]>,\n@@ -409,6 +409,47 @@ pub struct Arguments<'a> {\n     args: &'a [ArgumentV1<'a>],\n }\n \n+impl<'a> Arguments<'a> {\n+    /// Get the formatted string, if it has no arguments to be formatted.\n+    ///\n+    /// This can be used to avoid allocations in the most trivial case.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(fmt_as_str)]\n+    ///\n+    /// use core::fmt::Arguments;\n+    ///\n+    /// fn write_str(_: &str) { /* ... */ }\n+    ///\n+    /// fn write_fmt(args: &Arguments) {\n+    ///     if let Some(s) = args.as_str() {\n+    ///         write_str(s)\n+    ///     } else {\n+    ///         write_str(&args.to_string());\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// #![feature(fmt_as_str)]\n+    ///\n+    /// assert_eq!(format_args!(\"hello\").as_str(), Some(\"hello\"));\n+    /// assert_eq!(format_args!(\"\").as_str(), Some(\"\"));\n+    /// assert_eq!(format_args!(\"{}\", 1).as_str(), None);\n+    /// ```\n+    #[unstable(feature = \"fmt_as_str\", issue = \"74442\")]\n+    #[inline]\n+    pub fn as_str(&self) -> Option<&'static str> {\n+        match (self.pieces, self.args) {\n+            ([], []) => Some(\"\"),\n+            ([s], []) => Some(s),\n+            _ => None,\n+        }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Debug for Arguments<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {"}, {"sha": "9b528cdbe30c4203c12aff07e1f66638b71b746b", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -39,11 +39,11 @@\n //! ```\n //!\n //! An iterator has a method, [`next`], which when called, returns an\n-//! [`Option`]`<Item>`. [`next`] will return `Some(Item)` as long as there\n+//! [`Option`]`<Item>`. [`next`] will return [`Some(Item)`] as long as there\n //! are elements, and once they've all been exhausted, will return `None` to\n //! indicate that iteration is finished. Individual iterators may choose to\n //! resume iteration, and so calling [`next`] again may or may not eventually\n-//! start returning `Some(Item)` again at some point (for example, see [`TryIter`]).\n+//! start returning [`Some(Item)`] again at some point (for example, see [`TryIter`]).\n //!\n //! [`Iterator`]'s full definition includes a number of other methods as well,\n //! but they are default methods, built on top of [`next`], and so you get\n@@ -53,9 +53,9 @@\n //! more complex forms of processing. See the [Adapters](#adapters) section\n //! below for more details.\n //!\n+//! [`Some(Item)`]: Some\n //! [`Iterator`]: trait.Iterator.html\n //! [`next`]: trait.Iterator.html#tymethod.next\n-//! [`Option`]: ../../std/option/enum.Option.html\n //! [`TryIter`]: ../../std/sync/mpsc/struct.TryIter.html\n //!\n //! # The three forms of iteration\n@@ -72,9 +72,9 @@\n //! # Implementing Iterator\n //!\n //! Creating an iterator of your own involves two steps: creating a `struct` to\n-//! hold the iterator's state, and then `impl`ementing [`Iterator`] for that\n-//! `struct`. This is why there are so many `struct`s in this module: there is\n-//! one for each iterator and iterator adapter.\n+//! hold the iterator's state, and then implementing [`Iterator`] for that `struct`.\n+//! This is why there are so many `struct`s in this module: there is one for\n+//! each iterator and iterator adapter.\n //!\n //! Let's make an iterator named `Counter` which counts from `1` to `5`:\n //!"}, {"sha": "494c75174ff831733c7bc312645229c4e1ea5541", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -9,9 +9,9 @@ use crate::ops::{Add, Mul};\n /// [`FromIterator`] this trait should rarely be called directly and instead\n /// interacted with through [`Iterator::sum`].\n ///\n-/// [`sum`]: ../../std/iter/trait.Sum.html#tymethod.sum\n-/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n-/// [`Iterator::sum`]: ../../std/iter/trait.Iterator.html#method.sum\n+/// [`sum`]: #tymethod.sum\n+/// [`FromIterator`]: crate::iter::FromIterator\n+/// [`Iterator::sum`]: crate::iter::Iterator::sum\n #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n pub trait Sum<A = Self>: Sized {\n     /// Method which takes an iterator and generates `Self` from the elements by\n@@ -28,9 +28,9 @@ pub trait Sum<A = Self>: Sized {\n /// [`FromIterator`] this trait should rarely be called directly and instead\n /// interacted with through [`Iterator::product`].\n ///\n-/// [`product`]: ../../std/iter/trait.Product.html#tymethod.product\n-/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n-/// [`Iterator::product`]: ../../std/iter/trait.Iterator.html#method.product\n+/// [`product`]: #tymethod.product\n+/// [`FromIterator`]: crate::iter::FromIterator\n+/// [`Iterator::product`]: crate::iter::Iterator::product\n #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n pub trait Product<A = Self>: Sized {\n     /// Method which takes an iterator and generates `Self` from the elements by"}, {"sha": "851a1e49a493b6d2d464ce5d07f43db52d5f934b", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -106,8 +106,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// `nth_back()` will return [`None`] if `n` is greater than or equal to the length of the\n     /// iterator.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`nth`]: ../../std/iter/trait.Iterator.html#method.nth\n+    /// [`nth`]: crate::iter::Iterator::nth\n     ///\n     /// # Examples\n     ///\n@@ -274,8 +273,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// argument is a double reference. You can see this effect in the\n     /// examples below, with `&&x`.\n     ///\n-    /// [`Some(element)`]: ../../std/option/enum.Option.html#variant.Some\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Some(element)`]: Some\n     ///\n     /// # Examples\n     ///"}, {"sha": "b8faeb488e72d3cf776f324498c170d1cc6f319d", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 23, "deletions": 60, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -106,8 +106,7 @@ pub trait Iterator {\n     /// again may or may not eventually start returning [`Some(Item)`] again at some\n     /// point.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`Some(Item)`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`Some(Item)`]: Some\n     ///\n     /// # Examples\n     ///\n@@ -160,9 +159,7 @@ pub trait Iterator {\n     /// The default implementation returns `(0, `[`None`]`)` which is correct for any\n     /// iterator.\n     ///\n-    /// [`usize`]: ../../std/primitive.usize.html\n-    /// [`Option`]: ../../std/option/enum.Option.html\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`usize`]: type@usize\n     ///\n     /// # Examples\n     ///\n@@ -214,8 +211,6 @@ pub trait Iterator {\n     /// called at least once even if the iterator does not have any elements.\n     ///\n     /// [`next`]: #tymethod.next\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n     ///\n     /// # Overflow Behavior\n     ///\n@@ -229,7 +224,7 @@ pub trait Iterator {\n     /// This function might panic if the iterator has more than [`usize::MAX`]\n     /// elements.\n     ///\n-    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n+    /// [`usize::MAX`]: crate::usize::MAX\n     ///\n     /// # Examples\n     ///\n@@ -263,8 +258,6 @@ pub trait Iterator {\n     /// doing so, it keeps track of the current element. After [`None`] is\n     /// returned, `last()` will then return the last element it saw.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -303,8 +296,6 @@ pub trait Iterator {\n     /// `nth()` will return [`None`] if `n` is greater than or equal to the length of the\n     /// iterator.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -537,9 +528,8 @@ pub trait Iterator {\n     /// assert_eq!((2, 'o'), zipper[2]);\n     /// ```\n     ///\n-    /// [`enumerate`]: trait.Iterator.html#method.enumerate\n-    /// [`next`]: ../../std/iter/trait.Iterator.html#tymethod.next\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`enumerate`]: #method.enumerate\n+    /// [`next`]: #tymethod.next\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter>\n@@ -568,7 +558,7 @@ pub trait Iterator {\n     /// more idiomatic to use [`for`] than `map()`.\n     ///\n     /// [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n-    /// [`FnMut`]: ../../std/ops/trait.FnMut.html\n+    /// [`FnMut`]: crate::ops::FnMut\n     ///\n     /// # Examples\n     ///\n@@ -756,30 +746,26 @@ pub trait Iterator {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// let a = [\"1\", \"lol\", \"3\", \"NaN\", \"5\"];\n+    /// let a = [\"1\", \"two\", \"NaN\", \"four\", \"5\"];\n     ///\n     /// let mut iter = a.iter().filter_map(|s| s.parse().ok());\n     ///\n     /// assert_eq!(iter.next(), Some(1));\n-    /// assert_eq!(iter.next(), Some(3));\n     /// assert_eq!(iter.next(), Some(5));\n     /// assert_eq!(iter.next(), None);\n     /// ```\n     ///\n     /// Here's the same example, but with [`filter`] and [`map`]:\n     ///\n     /// ```\n-    /// let a = [\"1\", \"lol\", \"3\", \"NaN\", \"5\"];\n+    /// let a = [\"1\", \"two\", \"NaN\", \"four\", \"5\"];\n     /// let mut iter = a.iter().map(|s| s.parse()).filter(|s| s.is_ok()).map(|s| s.unwrap());\n     /// assert_eq!(iter.next(), Some(1));\n-    /// assert_eq!(iter.next(), Some(3));\n     /// assert_eq!(iter.next(), Some(5));\n     /// assert_eq!(iter.next(), None);\n     /// ```\n     ///\n-    /// [`Option<T>`]: ../../std/option/enum.Option.html\n-    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Option<T>`]: Option\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F>\n@@ -812,8 +798,8 @@ pub trait Iterator {\n     /// The returned iterator might panic if the to-be-returned index would\n     /// overflow a [`usize`].\n     ///\n-    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n-    /// [`usize`]: ../../std/primitive.usize.html\n+    /// [`usize`]: type@usize\n+    /// [`usize::MAX`]: crate::usize::MAX\n     /// [`zip`]: #method.zip\n     ///\n     /// # Examples\n@@ -849,8 +835,8 @@ pub trait Iterator {\n     /// anything other than fetching the next value) of the [`next`] method\n     /// will occur.\n     ///\n-    /// [`peek`]: struct.Peekable.html#method.peek\n-    /// [`next`]: ../../std/iter/trait.Iterator.html#tymethod.next\n+    /// [`peek`]: crate::iter::Peekable::peek\n+    /// [`next`]: #tymethod.next\n     ///\n     /// # Examples\n     ///\n@@ -1116,8 +1102,6 @@ pub trait Iterator {\n     /// It is also not specified what this iterator returns after the first` None` is returned.\n     /// If you need fused iterator, use [`fuse`].\n     ///\n-    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     /// [`fuse`]: #method.fuse\n     #[inline]\n     #[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n@@ -1216,8 +1200,6 @@ pub trait Iterator {\n     /// iterator and the return value from the closure, an [`Option`], is\n     /// yielded by the iterator.\n     ///\n-    /// [`Option`]: ../../std/option/enum.Option.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1366,8 +1348,7 @@ pub trait Iterator {\n     /// [`Some(T)`] again. `fuse()` adapts an iterator, ensuring that after a\n     /// [`None`] is given, it will always return [`None`] forever.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`Some(T)`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`Some(T)`]: Some\n     ///\n     /// # Examples\n     ///\n@@ -1658,10 +1639,9 @@ pub trait Iterator {\n     /// assert_eq!(Ok(vec![1, 3]), result);\n     /// ```\n     ///\n-    /// [`iter`]: ../../std/iter/trait.Iterator.html#tymethod.next\n+    /// [`iter`]: #tymethod.next\n     /// [`String`]: ../../std/string/struct.String.html\n-    /// [`char`]: ../../std/primitive.char.html\n-    /// [`Result`]: ../../std/result/enum.Result.html\n+    /// [`char`]: type@char\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use = \"if you really need to exhaust the iterator, consider `.for_each(drop)` instead\"]\n@@ -2184,8 +2164,7 @@ pub trait Iterator {\n     /// argument is a double reference. You can see this effect in the\n     /// examples below, with `&&x`.\n     ///\n-    /// [`Some(element)`]: ../../std/option/enum.Option.html#variant.Some\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Some(element)`]: Some\n     ///\n     /// # Examples\n     ///\n@@ -2331,9 +2310,8 @@ pub trait Iterator {\n     /// This function might panic if the iterator has more than `usize::MAX`\n     /// non-matching elements.\n     ///\n-    /// [`Some(index)`]: ../../std/option/enum.Option.html#variant.Some\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n+    /// [`Some(index)`]: Some\n+    /// [`usize::MAX`]: crate::usize::MAX\n     ///\n     /// # Examples\n     ///\n@@ -2394,8 +2372,7 @@ pub trait Iterator {\n     /// `rposition()` is short-circuiting; in other words, it will stop\n     /// processing as soon as it finds a `true`.\n     ///\n-    /// [`Some(index)`]: ../../std/option/enum.Option.html#variant.Some\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Some(index)`]: Some\n     ///\n     /// # Examples\n     ///\n@@ -2449,8 +2426,6 @@ pub trait Iterator {\n     /// If several elements are equally maximum, the last element is\n     /// returned. If the iterator is empty, [`None`] is returned.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -2477,8 +2452,6 @@ pub trait Iterator {\n     /// If several elements are equally minimum, the first element is\n     /// returned. If the iterator is empty, [`None`] is returned.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -2506,8 +2479,6 @@ pub trait Iterator {\n     /// If several elements are equally maximum, the last element is\n     /// returned. If the iterator is empty, [`None`] is returned.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2541,8 +2512,6 @@ pub trait Iterator {\n     /// If several elements are equally maximum, the last element is\n     /// returned. If the iterator is empty, [`None`] is returned.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2570,8 +2539,6 @@ pub trait Iterator {\n     /// If several elements are equally minimum, the first element is\n     /// returned. If the iterator is empty, [`None`] is returned.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2605,8 +2572,6 @@ pub trait Iterator {\n     /// If several elements are equally minimum, the first element is\n     /// returned. If the iterator is empty, [`None`] is returned.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2747,7 +2712,7 @@ pub trait Iterator {\n     /// This is useful when you have an iterator over `&T`, but you need an\n     /// iterator over `T`.\n     ///\n-    /// [`clone`]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    /// [`clone`]: crate::clone::Clone::clone\n     ///\n     /// # Examples\n     ///\n@@ -2779,8 +2744,6 @@ pub trait Iterator {\n     /// from the beginning. After iterating again, it will start at the\n     /// beginning again. And again. And again. Forever.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -3233,7 +3196,7 @@ pub trait Iterator {\n     /// assert!(![0.0, 1.0, f32::NAN].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n     /// ```\n     ///\n-    /// [`is_sorted`]: trait.Iterator.html#method.is_sorted\n+    /// [`is_sorted`]: #method.is_sorted\n     #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n     fn is_sorted_by<F>(mut self, mut compare: F) -> bool\n     where\n@@ -3262,7 +3225,7 @@ pub trait Iterator {\n     /// the elements, as determined by `f`. Apart from that, it's equivalent to [`is_sorted`]; see\n     /// its documentation for more information.\n     ///\n-    /// [`is_sorted`]: trait.Iterator.html#method.is_sorted\n+    /// [`is_sorted`]: #method.is_sorted\n     ///\n     /// # Examples\n     ///"}, {"sha": "3c893c039923ead483300501fbf4d8046b60f2e3", "filename": "src/libcore/iter/traits/marker.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -9,9 +9,8 @@\n /// on the iterator. If the iterator is already fused, the additional [`Fuse`]\n /// wrapper will be a no-op with no performance penalty.\n ///\n-/// [`None`]: ../../std/option/enum.Option.html#variant.None\n-/// [`Iterator::fuse`]: ../../std/iter/trait.Iterator.html#method.fuse\n-/// [`Fuse`]: ../../std/iter/struct.Fuse.html\n+/// [`Iterator::fuse`]: crate::iter::Iterator::fuse\n+/// [`Fuse`]: crate::iter::Fuse\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n #[rustc_unsafe_specialization_marker]\n pub trait FusedIterator: Iterator {}\n@@ -35,9 +34,8 @@ impl<I: FusedIterator + ?Sized> FusedIterator for &mut I {}\n /// This trait must only be implemented when the contract is upheld.\n /// Consumers of this trait must inspect [`.size_hint`]\u2019s upper bound.\n ///\n-/// [`None`]: ../../std/option/enum.Option.html#variant.None\n-/// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n-/// [`.size_hint`]: ../../std/iter/trait.Iterator.html#method.size_hint\n+/// [`usize::MAX`]: crate::usize::MAX\n+/// [`.size_hint`]: crate::iter::Iterator::size_hint\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n #[rustc_unsafe_specialization_marker]\n pub unsafe trait TrustedLen: Iterator {}"}, {"sha": "2f2206a117cf7bfc05541f76382541bf14f5be93", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -83,6 +83,7 @@\n #![feature(const_panic)]\n #![feature(const_fn_union)]\n #![feature(const_generics)]\n+#![feature(const_option)]\n #![feature(const_ptr_offset)]\n #![feature(const_ptr_offset_from)]\n #![feature(const_raw_ptr_comparison)]\n@@ -150,6 +151,7 @@\n #![feature(slice_ptr_get)]\n #![feature(no_niche)] // rust-lang/rust#68303\n #![feature(unsafe_block_in_unsafe_fn)]\n+#![deny(intra_doc_link_resolution_failure)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n #[prelude_import]"}, {"sha": "4ac366ab16408eb3de7c8d60359a9cd5fb8dbd05", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -6,9 +6,12 @@ macro_rules! panic {\n     () => (\n         $crate::panic!(\"explicit panic\")\n     );\n-    ($msg:expr) => (\n+    ($msg:literal) => (\n         $crate::panicking::panic($msg)\n     );\n+    ($msg:expr) => (\n+        $crate::panic!(\"{}\", $crate::convert::identity::<&str>($msg))\n+    );\n     ($msg:expr,) => (\n         $crate::panic!($msg)\n     );"}, {"sha": "5932f8e5856a74c7aafb67e98a95f2ec0e8118fb", "filename": "src/libcore/option.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -179,8 +179,9 @@ impl<T> Option<T> {\n     /// [`Some`]: #variant.Some\n     #[must_use = \"if you intended to assert that this has a value, consider `.unwrap()` instead\"]\n     #[inline]\n+    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_some(&self) -> bool {\n+    pub const fn is_some(&self) -> bool {\n         matches!(*self, Some(_))\n     }\n \n@@ -200,8 +201,9 @@ impl<T> Option<T> {\n     #[must_use = \"if you intended to assert that this doesn't have a value, consider \\\n                   `.and_then(|| panic!(\\\"`Option` had a value when expected `None`\\\"))` instead\"]\n     #[inline]\n+    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_none(&self) -> bool {\n+    pub const fn is_none(&self) -> bool {\n         !self.is_some()\n     }\n \n@@ -259,8 +261,9 @@ impl<T> Option<T> {\n     /// println!(\"still can print text: {:?}\", text);\n     /// ```\n     #[inline]\n+    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn as_ref(&self) -> Option<&T> {\n+    pub const fn as_ref(&self) -> Option<&T> {\n         match *self {\n             Some(ref x) => Some(x),\n             None => None,\n@@ -580,8 +583,9 @@ impl<T> Option<T> {\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n+    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<'_, T> {\n+    pub const fn iter(&self) -> Iter<'_, T> {\n         Iter { inner: Item { opt: self.as_ref() } }\n     }\n "}, {"sha": "15fd638bef8ad738375efc715e8aabd0db7d3df0", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -36,7 +36,7 @@ use crate::panic::{Location, PanicInfo};\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n #[track_caller]\n #[lang = \"panic\"] // needed by codegen for panic on overflow and other `Assert` MIR terminators\n-pub fn panic(expr: &str) -> ! {\n+pub fn panic(expr: &'static str) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         super::intrinsics::abort()\n     }"}, {"sha": "6f40aac83eb9c7b7a1da4fbbd0867eaace7c3d63", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -28,7 +28,9 @@ use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor};\n pub fn disable_localization(linker: &mut Command) {\n     // No harm in setting both env vars simultaneously.\n     // Unix-style linkers.\n-    linker.env(\"LC_ALL\", \"C\");\n+    // We use an UTF-8 locale, as the generic C locale disables support for non-ASCII\n+    // bytes in filenames on some platforms.\n+    linker.env(\"LC_ALL\", \"en_US.UTF-8\");\n     // MSVC's `link.exe`.\n     linker.env(\"VSLANG\", \"1033\");\n }"}, {"sha": "5b648608b6b434aacc7b530546e41bd2b287fdac", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -235,13 +235,8 @@ pub fn get_codegen_backend(sess: &Session) -> Box<dyn CodegenBackend> {\n     static mut LOAD: fn() -> Box<dyn CodegenBackend> = || unreachable!();\n \n     INIT.call_once(|| {\n-        let codegen_name = sess\n-            .opts\n-            .debugging_opts\n-            .codegen_backend\n-            .as_ref()\n-            .unwrap_or(&sess.target.target.options.codegen_backend);\n-        let backend = match &codegen_name[..] {\n+        let codegen_name = sess.opts.debugging_opts.codegen_backend.as_deref().unwrap_or(\"llvm\");\n+        let backend = match codegen_name {\n             filename if filename.contains('.') => load_backend_from_dylib(filename.as_ref()),\n             codegen_name => get_builtin_codegen_backend(codegen_name),\n         };"}, {"sha": "5c4be715add79de0552f88b8f82909b74865fdeb", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -1922,6 +1922,14 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             None\n         }\n \n+        /// Test if this enum has several actually \"existing\" variants.\n+        /// Zero-sized uninhabited variants do not always have a tag assigned and thus do not \"exist\".\n+        fn is_multi_variant(adt: &ty::AdtDef) -> bool {\n+            // As an approximation, we only count dataless variants. Those are definitely inhabited.\n+            let existing_variants = adt.variants.iter().filter(|v| v.fields.is_empty()).count();\n+            existing_variants > 1\n+        }\n+\n         /// Return `Some` only if we are sure this type does *not*\n         /// allow zero initialization.\n         fn ty_find_init_error<'tcx>(\n@@ -1950,7 +1958,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 }\n                 // Recurse and checks for some compound types.\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n-                    // First check f this ADT has a layout attribute (like `NonNull` and friends).\n+                    // First check if this ADT has a layout attribute (like `NonNull` and friends).\n                     use std::ops::Bound;\n                     match tcx.layout_scalar_valid_range(adt_def.did) {\n                         // We exploit here that `layout_scalar_valid_range` will never\n@@ -2001,10 +2009,20 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                                 )\n                             })\n                         }\n-                        // Multi-variant enums are tricky: if all but one variant are\n-                        // uninhabited, we might actually do layout like for a single-variant\n-                        // enum, and then even leaving them uninitialized could be okay.\n-                        _ => None, // Conservative fallback for multi-variant enum.\n+                        // Multi-variant enum.\n+                        _ => {\n+                            if init == InitKind::Uninit && is_multi_variant(adt_def) {\n+                                let span = tcx.def_span(adt_def.did);\n+                                Some((\n+                                    \"enums have to be initialized to a variant\".to_string(),\n+                                    Some(span),\n+                                ))\n+                            } else {\n+                                // In principle, for zero-initialization we could figure out which variant corresponds\n+                                // to tag 0, and check that... but for now we just accept all zero-initializations.\n+                                None\n+                            }\n+                        }\n                     }\n                 }\n                 Tuple(..) => {"}, {"sha": "b014f3c8eb7949635854fa1618581e7e5b4a660a", "filename": "src/librustc_middle/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmod.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -4,6 +4,7 @@\n \n pub mod exports;\n pub mod map;\n+pub mod place;\n \n use crate::ich::StableHashingContext;\n use crate::ty::query::Providers;"}, {"sha": "d85165bcccfdc99cf38fc11348f60787bdc0a9b3", "filename": "src/librustc_middle/hir/place.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_middle%2Fhir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_middle%2Fhir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fplace.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -0,0 +1,115 @@\n+use crate::ty;\n+use crate::ty::Ty;\n+\n+use rustc_hir::HirId;\n+use rustc_target::abi::VariantIdx;\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum PlaceBase {\n+    /// A temporary variable\n+    Rvalue,\n+    /// A named `static` item\n+    StaticItem,\n+    /// A named local variable\n+    Local(HirId),\n+    /// An upvar referenced by closure env\n+    Upvar(ty::UpvarId),\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum ProjectionKind {\n+    /// A dereference of a pointer, reference or `Box<T>` of the given type\n+    Deref,\n+\n+    /// `B.F` where `B` is the base expression and `F` is\n+    /// the field. The field is identified by which variant\n+    /// it appears in along with a field index. The variant\n+    /// is used for enums.\n+    Field(u32, VariantIdx),\n+\n+    /// Some index like `B[x]`, where `B` is the base\n+    /// expression. We don't preserve the index `x` because\n+    /// we won't need it.\n+    Index,\n+\n+    /// A subslice covering a range of values like `B[x..y]`.\n+    Subslice,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct Projection<'tcx> {\n+    /// Type after the projection is being applied.\n+    pub ty: Ty<'tcx>,\n+\n+    /// Defines the type of access\n+    pub kind: ProjectionKind,\n+}\n+\n+/// A `Place` represents how a value is located in memory.\n+///\n+/// This is an HIR version of `mir::Place`\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct Place<'tcx> {\n+    /// The type of the `PlaceBase`\n+    pub base_ty: Ty<'tcx>,\n+    /// The \"outermost\" place that holds this value.\n+    pub base: PlaceBase,\n+    /// How this place is derived from the base place.\n+    pub projections: Vec<Projection<'tcx>>,\n+}\n+\n+/// A `PlaceWithHirId` represents how a value is located in memory.\n+///\n+/// This is an HIR version of `mir::Place`\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct PlaceWithHirId<'tcx> {\n+    /// `HirId` of the expression or pattern producing this value.\n+    pub hir_id: HirId,\n+\n+    /// Information about the `Place`\n+    pub place: Place<'tcx>,\n+}\n+\n+impl<'tcx> PlaceWithHirId<'tcx> {\n+    pub fn new(\n+        hir_id: HirId,\n+        base_ty: Ty<'tcx>,\n+        base: PlaceBase,\n+        projections: Vec<Projection<'tcx>>,\n+    ) -> PlaceWithHirId<'tcx> {\n+        PlaceWithHirId {\n+            hir_id: hir_id,\n+            place: Place { base_ty: base_ty, base: base, projections: projections },\n+        }\n+    }\n+}\n+\n+impl<'tcx> Place<'tcx> {\n+    /// Returns an iterator of the types that have to be dereferenced to access\n+    /// the `Place`.\n+    ///\n+    /// The types are in the reverse order that they are applied. So if\n+    /// `x: &*const u32` and the `Place` is `**x`, then the types returned are\n+    ///`*const u32` then `&*const u32`.\n+    pub fn deref_tys(&self) -> impl Iterator<Item = Ty<'tcx>> + '_ {\n+        self.projections.iter().enumerate().rev().filter_map(move |(index, proj)| {\n+            if ProjectionKind::Deref == proj.kind {\n+                Some(self.ty_before_projection(index))\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    /// Returns the type of this `Place` after all projections have been applied.\n+    pub fn ty(&self) -> Ty<'tcx> {\n+        self.projections.last().map_or_else(|| self.base_ty, |proj| proj.ty)\n+    }\n+\n+    /// Returns the type of this `Place` immediately before `projection_index`th projection\n+    /// is applied.\n+    pub fn ty_before_projection(&self, projection_index: usize) -> Ty<'tcx> {\n+        assert!(projection_index < self.projections.len());\n+        if projection_index == 0 { self.base_ty } else { self.projections[projection_index - 1].ty }\n+    }\n+}"}, {"sha": "36e277d1a88f3d3e4a49504ee92b4fe173b136eb", "filename": "src/librustc_middle/mir/traversal.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_middle%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_middle%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Ftraversal.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -292,3 +292,20 @@ impl<'a, 'tcx> Iterator for ReversePostorder<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ExactSizeIterator for ReversePostorder<'a, 'tcx> {}\n+\n+/// Returns an iterator over all basic blocks reachable from the `START_BLOCK` in no particular\n+/// order.\n+///\n+/// This is clearer than writing `preorder` in cases where the order doesn't matter.\n+pub fn reachable<'a, 'tcx>(\n+    body: &'a Body<'tcx>,\n+) -> impl 'a + Iterator<Item = (BasicBlock, &'a BasicBlockData<'tcx>)> {\n+    preorder(body)\n+}\n+\n+/// Returns a `BitSet` containing all basic blocks reachable from the `START_BLOCK`.\n+pub fn reachable_as_bitset(body: &Body<'tcx>) -> BitSet<BasicBlock> {\n+    let mut iter = preorder(body);\n+    (&mut iter).for_each(drop);\n+    iter.visited\n+}"}, {"sha": "4f5930dc3f5a209c9e3d6baccef11bdad4fcfcab", "filename": "src/librustc_mir/dataflow/framework/cursor.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -34,6 +34,9 @@ where\n     ///\n     /// When this flag is set, we need to reset to an entry set before doing a seek.\n     state_needs_reset: bool,\n+\n+    #[cfg(debug_assertions)]\n+    reachable_blocks: BitSet<BasicBlock>,\n }\n \n impl<'mir, 'tcx, A, R> ResultsCursor<'mir, 'tcx, A, R>\n@@ -55,6 +58,9 @@ where\n             state_needs_reset: true,\n             state: BitSet::new_empty(bits_per_block),\n             pos: CursorPosition::block_entry(mir::START_BLOCK),\n+\n+            #[cfg(debug_assertions)]\n+            reachable_blocks: mir::traversal::reachable_as_bitset(body),\n         }\n     }\n \n@@ -85,6 +91,9 @@ where\n     ///\n     /// For backward dataflow analyses, this is the dataflow state after the terminator.\n     pub(super) fn seek_to_block_entry(&mut self, block: BasicBlock) {\n+        #[cfg(debug_assertions)]\n+        assert!(self.reachable_blocks.contains(block));\n+\n         self.state.overwrite(&self.results.borrow().entry_set_for_block(block));\n         self.pos = CursorPosition::block_entry(block);\n         self.state_needs_reset = false;"}, {"sha": "003c40f290b8d02db5cf163d5dd4b1ce7322906c", "filename": "src/librustc_mir/dataflow/framework/engine.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -52,6 +52,15 @@ where\n         visit_results(body, blocks, self, vis)\n     }\n \n+    pub fn visit_reachable_with(\n+        &self,\n+        body: &'mir mir::Body<'tcx>,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n+    ) {\n+        let blocks = mir::traversal::reachable(body);\n+        visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n+    }\n+\n     pub fn visit_in_rpo_with(\n         &self,\n         body: &'mir mir::Body<'tcx>,\n@@ -204,15 +213,6 @@ where\n             }\n         }\n \n-        // Add blocks that are not reachable from START_BLOCK to the work queue. These blocks will\n-        // be processed after the ones added above.\n-        //\n-        // FIXME(ecstaticmorse): Is this actually necessary? In principle, we shouldn't need to\n-        // know the dataflow state in unreachable basic blocks.\n-        for bb in body.basic_blocks().indices() {\n-            dirty_queue.insert(bb);\n-        }\n-\n         let mut state = BitSet::new_empty(bits_per_block);\n         while let Some(bb) = dirty_queue.pop() {\n             let bb_data = &body[bb];"}, {"sha": "257f3cb9a6dd0ddd1026b1041fbe6babc3e13238", "filename": "src/librustc_mir/dataflow/framework/visitor.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -16,7 +16,13 @@ pub fn visit_results<F, V>(\n {\n     let mut state = results.new_flow_state(body);\n \n+    #[cfg(debug_assertions)]\n+    let reachable_blocks = mir::traversal::reachable_as_bitset(body);\n+\n     for block in blocks {\n+        #[cfg(debug_assertions)]\n+        assert!(reachable_blocks.contains(block));\n+\n         let block_data = &body[block];\n         V::Direction::visit_results_in_block(&mut state, block, block_data, results, vis);\n     }"}, {"sha": "8618cc126c563e336919ef366d306752ff1282ee", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -624,9 +624,7 @@ fn compute_storage_conflicts(\n         local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len()),\n     };\n \n-    // Visit only reachable basic blocks. The exact order is not important.\n-    let reachable_blocks = traversal::preorder(body).map(|(bb, _)| bb);\n-    requires_storage.visit_with(body, reachable_blocks, &mut visitor);\n+    requires_storage.visit_reachable_with(body, &mut visitor);\n \n     let local_conflicts = visitor.local_conflicts;\n "}, {"sha": "eaef6bb37faa591a40ee9b4e4bafbeabe52eb474", "filename": "src/librustc_mir_build/build/expr/into.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -188,10 +188,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let ptr_ty = ptr.ty;\n                     // Create an *internal* temp for the pointer, so that unsafety\n                     // checking won't complain about the raw pointer assignment.\n-                    let ptr_temp = this.local_decls.push(LocalDecl::with_source_info(\n-                        ptr_ty,\n-                        source_info,\n-                    ).internal());\n+                    let ptr_temp = this\n+                        .local_decls\n+                        .push(LocalDecl::with_source_info(ptr_ty, source_info).internal());\n                     let ptr_temp = Place::from(ptr_temp);\n                     let block = unpack!(this.into(ptr_temp, block, ptr));\n                     this.into(this.hir.tcx().mk_place_deref(ptr_temp), block, val)\n@@ -224,7 +223,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 Some((destination, success))\n                             },\n                             from_hir_call,\n-                            fn_span\n+                            fn_span,\n                         },\n                     );\n                     success.unit()\n@@ -387,15 +386,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // These cases don't actually need a destination\n             ExprKind::Assign { .. }\n             | ExprKind::AssignOp { .. }\n-            | ExprKind::Continue { .. }\n-            | ExprKind::Break { .. }\n-            | ExprKind::LlvmInlineAsm { .. }\n-            | ExprKind::Return { .. } => {\n+            | ExprKind::LlvmInlineAsm { .. } => {\n                 unpack!(block = this.stmt_expr(block, expr, None));\n                 this.cfg.push_assign_unit(block, source_info, destination, this.hir.tcx());\n                 block.unit()\n             }\n \n+            ExprKind::Continue { .. } | ExprKind::Break { .. } | ExprKind::Return { .. } => {\n+                unpack!(block = this.stmt_expr(block, expr, None));\n+                // No assign, as these have type `!`.\n+                block.unit()\n+            }\n+\n             // Avoid creating a temporary\n             ExprKind::VarRef { .. }\n             | ExprKind::SelfRef"}, {"sha": "231ab1ea68ded7d538114a32e755a868f4183b18", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -938,9 +938,6 @@ pub struct TargetOptions {\n     /// for this target unconditionally.\n     pub no_builtins: bool,\n \n-    /// The codegen backend to use for this target, typically \"llvm\"\n-    pub codegen_backend: String,\n-\n     /// The default visibility for symbols in this target should be \"hidden\"\n     /// rather than \"default\"\n     pub default_hidden_visibility: bool,\n@@ -1068,7 +1065,6 @@ impl Default for TargetOptions {\n             requires_lto: false,\n             singlethread: false,\n             no_builtins: false,\n-            codegen_backend: \"llvm\".to_string(),\n             default_hidden_visibility: false,\n             emit_debug_gdb_scripts: true,\n             requires_uwtable: false,\n@@ -1461,7 +1457,6 @@ impl Target {\n         key!(requires_lto, bool);\n         key!(singlethread, bool);\n         key!(no_builtins, bool);\n-        key!(codegen_backend);\n         key!(default_hidden_visibility, bool);\n         key!(emit_debug_gdb_scripts, bool);\n         key!(requires_uwtable, bool);\n@@ -1699,7 +1694,6 @@ impl ToJson for Target {\n         target_option_val!(requires_lto);\n         target_option_val!(singlethread);\n         target_option_val!(no_builtins);\n-        target_option_val!(codegen_backend);\n         target_option_val!(default_hidden_visibility);\n         target_option_val!(emit_debug_gdb_scripts);\n         target_option_val!(requires_uwtable);"}, {"sha": "b72152d1911f7dc5851f627149f7d5d1205335aa", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -82,6 +82,7 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::PatKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{self, RegionObligation, RegionckMode};\n+use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n use rustc_middle::ty::adjustment;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n@@ -442,7 +443,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn constrain_adjustments(\n         &mut self,\n         expr: &hir::Expr<'_>,\n-    ) -> mc::McResult<mc::PlaceWithHirId<'tcx>> {\n+    ) -> mc::McResult<PlaceWithHirId<'tcx>> {\n         debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n         let mut place = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n@@ -483,10 +484,10 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     fn check_safety_of_rvalue_destructor_if_necessary(\n         &mut self,\n-        place_with_id: &mc::PlaceWithHirId<'tcx>,\n+        place_with_id: &PlaceWithHirId<'tcx>,\n         span: Span,\n     ) {\n-        if let mc::PlaceBase::Rvalue = place_with_id.place.base {\n+        if let PlaceBase::Rvalue = place_with_id.place.base {\n             if place_with_id.place.projections.is_empty() {\n                 let typ = self.resolve_type(place_with_id.place.ty());\n                 let body_id = self.body_id;\n@@ -573,7 +574,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n-    fn link_pattern(&self, discr_cmt: mc::PlaceWithHirId<'tcx>, root_pat: &hir::Pat<'_>) {\n+    fn link_pattern(&self, discr_cmt: PlaceWithHirId<'tcx>, root_pat: &hir::Pat<'_>) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\", discr_cmt, root_pat);\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id }| {\n@@ -594,7 +595,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn link_autoref(\n         &self,\n         expr: &hir::Expr<'_>,\n-        expr_cmt: &mc::PlaceWithHirId<'tcx>,\n+        expr_cmt: &PlaceWithHirId<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {\n         debug!(\"link_autoref(autoref={:?}, expr_cmt={:?})\", autoref, expr_cmt);\n@@ -615,7 +616,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         span: Span,\n         id: hir::HirId,\n         mutbl: hir::Mutability,\n-        cmt_borrowed: &mc::PlaceWithHirId<'tcx>,\n+        cmt_borrowed: &PlaceWithHirId<'tcx>,\n     ) {\n         debug!(\n             \"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n@@ -638,7 +639,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         span: Span,\n         borrow_region: ty::Region<'tcx>,\n         borrow_kind: ty::BorrowKind,\n-        borrow_place: &mc::PlaceWithHirId<'tcx>,\n+        borrow_place: &PlaceWithHirId<'tcx>,\n     ) {\n         let origin = infer::DataBorrowed(borrow_place.place.ty(), span);\n         self.type_must_outlive(origin, borrow_place.place.ty(), borrow_region);\n@@ -659,7 +660,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                 _ => assert!(pointer_ty.is_box(), \"unexpected built-in deref type {}\", pointer_ty),\n             }\n         }\n-        if let mc::PlaceBase::Upvar(upvar_id) = borrow_place.place.base {\n+        if let PlaceBase::Upvar(upvar_id) = borrow_place.place.base {\n             self.link_upvar_region(span, borrow_region, upvar_id);\n         }\n     }"}, {"sha": "030c0ab668a8005db6a0a7bbf374697cbfabf06d", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -33,14 +33,13 @@\n use super::FnCtxt;\n \n use crate::expr_use_visitor as euv;\n-use crate::mem_categorization as mc;\n-use crate::mem_categorization::PlaceBase;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n+use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n use rustc_middle::ty::{self, Ty, TyCtxt, UpvarSubsts};\n use rustc_span::{Span, Symbol};\n \n@@ -276,7 +275,7 @@ struct InferBorrowKind<'a, 'tcx> {\n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n     fn adjust_upvar_borrow_kind_for_consume(\n         &mut self,\n-        place_with_id: &mc::PlaceWithHirId<'tcx>,\n+        place_with_id: &PlaceWithHirId<'tcx>,\n         mode: euv::ConsumeMode,\n     ) {\n         debug!(\n@@ -315,7 +314,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n     /// Indicates that `place_with_id` is being directly mutated (e.g., assigned\n     /// to). If the place is based on a by-ref upvar, this implies that\n     /// the upvar must be borrowed using an `&mut` borrow.\n-    fn adjust_upvar_borrow_kind_for_mut(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>) {\n+    fn adjust_upvar_borrow_kind_for_mut(&mut self, place_with_id: &PlaceWithHirId<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_mut(place_with_id={:?})\", place_with_id);\n \n         if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n@@ -340,7 +339,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         }\n     }\n \n-    fn adjust_upvar_borrow_kind_for_unique(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>) {\n+    fn adjust_upvar_borrow_kind_for_unique(&mut self, place_with_id: &PlaceWithHirId<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(place_with_id={:?})\", place_with_id);\n \n         if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n@@ -470,12 +469,12 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n-    fn consume(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, mode: euv::ConsumeMode) {\n+    fn consume(&mut self, place_with_id: &PlaceWithHirId<'tcx>, mode: euv::ConsumeMode) {\n         debug!(\"consume(place_with_id={:?},mode={:?})\", place_with_id, mode);\n         self.adjust_upvar_borrow_kind_for_consume(place_with_id, mode);\n     }\n \n-    fn borrow(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n+    fn borrow(&mut self, place_with_id: &PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n         debug!(\"borrow(place_with_id={:?}, bk={:?})\", place_with_id, bk);\n \n         match bk {\n@@ -489,7 +488,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         }\n     }\n \n-    fn mutate(&mut self, assignee_place: &mc::PlaceWithHirId<'tcx>) {\n+    fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>) {\n         debug!(\"mutate(assignee_place={:?})\", assignee_place);\n \n         self.adjust_upvar_borrow_kind_for_mut(assignee_place);"}, {"sha": "d1b386c9d4d47279ca3915cb5256f94a8b03d1be", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -5,14 +5,15 @@\n pub use self::ConsumeMode::*;\n \n // Export these here so that Clippy can use them.\n-pub use mc::{PlaceBase, PlaceWithHirId, Projection};\n+pub use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId, Projection};\n \n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::PatKind;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n+use rustc_middle::hir::place::ProjectionKind;\n use rustc_middle::ty::{self, adjustment, TyCtxt};\n use rustc_target::abi::VariantIdx;\n \n@@ -27,13 +28,13 @@ use rustc_span::Span;\n pub trait Delegate<'tcx> {\n     // The value found at `place` is either copied or moved, depending\n     // on mode.\n-    fn consume(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, mode: ConsumeMode);\n+    fn consume(&mut self, place_with_id: &PlaceWithHirId<'tcx>, mode: ConsumeMode);\n \n     // The value found at `place` is being borrowed with kind `bk`.\n-    fn borrow(&mut self, place_with_id: &mc::PlaceWithHirId<'tcx>, bk: ty::BorrowKind);\n+    fn borrow(&mut self, place_with_id: &PlaceWithHirId<'tcx>, bk: ty::BorrowKind);\n \n     // The path at `place_with_id` is being assigned to.\n-    fn mutate(&mut self, assignee_place: &mc::PlaceWithHirId<'tcx>);\n+    fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -398,7 +399,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                             &*with_expr,\n                             with_place.clone(),\n                             with_field.ty(self.tcx(), substs),\n-                            mc::ProjectionKind::Field(f_index as u32, VariantIdx::new(0)),\n+                            ProjectionKind::Field(f_index as u32, VariantIdx::new(0)),\n                         );\n                         self.delegate_consume(&field_place);\n                     }\n@@ -462,7 +463,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     fn walk_autoref(\n         &mut self,\n         expr: &hir::Expr<'_>,\n-        base_place: &mc::PlaceWithHirId<'tcx>,\n+        base_place: &PlaceWithHirId<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {\n         debug!(\n@@ -575,7 +576,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         closure_hir_id: hir::HirId,\n         closure_span: Span,\n         var_id: hir::HirId,\n-    ) -> mc::McResult<mc::PlaceWithHirId<'tcx>> {\n+    ) -> mc::McResult<PlaceWithHirId<'tcx>> {\n         // Create the place for the variable being borrowed, from the\n         // perspective of the creator (parent) of the closure.\n         let var_ty = self.mc.node_ty(var_id)?;"}, {"sha": "afc7cb346eb428299fec3bb7093a749d2916e30c", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 110, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -48,6 +48,7 @@\n //! result of `*x'`, effectively, where `x'` is a `Categorization::Upvar` reference\n //! tied to `x`. The type of `x'` will be a borrowed pointer.\n \n+use rustc_middle::hir::place::*;\n use rustc_middle::ty::adjustment;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -64,116 +65,6 @@ use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n-#[derive(Clone, Debug)]\n-pub enum PlaceBase {\n-    /// A temporary variable\n-    Rvalue,\n-    /// A named `static` item\n-    StaticItem,\n-    /// A named local variable\n-    Local(hir::HirId),\n-    /// An upvar referenced by closure env\n-    Upvar(ty::UpvarId),\n-}\n-\n-#[derive(Clone, Debug, Eq, PartialEq)]\n-pub enum ProjectionKind {\n-    /// A dereference of a pointer, reference or `Box<T>` of the given type\n-    Deref,\n-\n-    /// `B.F` where `B` is the base expression and `F` is\n-    /// the field. The field is identified by which variant\n-    /// it appears in along with a field index. The variant\n-    /// is used for enums.\n-    Field(u32, VariantIdx),\n-\n-    /// Some index like `B[x]`, where `B` is the base\n-    /// expression. We don't preserve the index `x` because\n-    /// we won't need it.\n-    Index,\n-\n-    /// A subslice covering a range of values like `B[x..y]`.\n-    Subslice,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct Projection<'tcx> {\n-    // Type after the projection is being applied.\n-    ty: Ty<'tcx>,\n-\n-    /// Defines the type of access\n-    kind: ProjectionKind,\n-}\n-\n-/// A `Place` represents how a value is located in memory.\n-///\n-/// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug)]\n-pub struct Place<'tcx> {\n-    /// The type of the `PlaceBase`\n-    pub base_ty: Ty<'tcx>,\n-    /// The \"outermost\" place that holds this value.\n-    pub base: PlaceBase,\n-    /// How this place is derived from the base place.\n-    pub projections: Vec<Projection<'tcx>>,\n-}\n-\n-/// A `PlaceWithHirId` represents how a value is located in memory.\n-///\n-/// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug)]\n-pub struct PlaceWithHirId<'tcx> {\n-    /// `HirId` of the expression or pattern producing this value.\n-    pub hir_id: hir::HirId,\n-\n-    /// Information about the `Place`\n-    pub place: Place<'tcx>,\n-}\n-\n-impl<'tcx> PlaceWithHirId<'tcx> {\n-    crate fn new(\n-        hir_id: hir::HirId,\n-        base_ty: Ty<'tcx>,\n-        base: PlaceBase,\n-        projections: Vec<Projection<'tcx>>,\n-    ) -> PlaceWithHirId<'tcx> {\n-        PlaceWithHirId {\n-            hir_id: hir_id,\n-            place: Place { base_ty: base_ty, base: base, projections: projections },\n-        }\n-    }\n-}\n-\n-impl<'tcx> Place<'tcx> {\n-    /// Returns an iterator of the types that have to be dereferenced to access\n-    /// the `Place`.\n-    ///\n-    /// The types are in the reverse order that they are applied. So if\n-    /// `x: &*const u32` and the `Place` is `**x`, then the types returned are\n-    ///`*const u32` then `&*const u32`.\n-    crate fn deref_tys(&self) -> impl Iterator<Item = Ty<'tcx>> + '_ {\n-        self.projections.iter().enumerate().rev().filter_map(move |(index, proj)| {\n-            if ProjectionKind::Deref == proj.kind {\n-                Some(self.ty_before_projection(index))\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    // Returns the type of this `Place` after all projections have been applied.\n-    pub fn ty(&self) -> Ty<'tcx> {\n-        self.projections.last().map_or_else(|| self.base_ty, |proj| proj.ty)\n-    }\n-\n-    // Returns the type of this `Place` immediately before `projection_index`th projection\n-    // is applied.\n-    crate fn ty_before_projection(&self, projection_index: usize) -> Ty<'tcx> {\n-        assert!(projection_index < self.projections.len());\n-        if projection_index == 0 { self.base_ty } else { self.projections[projection_index - 1].ty }\n-    }\n-}\n-\n crate trait HirNode {\n     fn hir_id(&self) -> hir::HirId;\n     fn span(&self) -> Span;"}, {"sha": "263909d5559d16bc93a04b354bb0888142f076e8", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -320,7 +320,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     let missing_doc_example = rustc_lint::builtin::MISSING_DOC_CODE_EXAMPLES.name;\n     let private_doc_tests = rustc_lint::builtin::PRIVATE_DOC_TESTS.name;\n     let no_crate_level_docs = rustc_lint::builtin::MISSING_CRATE_LEVEL_DOCS.name;\n-    let invalid_codeblock_attribute_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTES.name;\n+    let invalid_codeblock_attributes_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTES.name;\n \n     // In addition to those specific lints, we also need to allow those given through\n     // command line, otherwise they'll get ignored and we don't want that.\n@@ -330,12 +330,12 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         missing_doc_example.to_owned(),\n         private_doc_tests.to_owned(),\n         no_crate_level_docs.to_owned(),\n-        invalid_codeblock_attribute_name.to_owned(),\n+        invalid_codeblock_attributes_name.to_owned(),\n     ];\n \n     let (lint_opts, lint_caps) = init_lints(allowed_lints, lint_opts, |lint| {\n         if lint.name == intra_link_resolution_failure_name\n-            || lint.name == invalid_codeblock_attribute_name\n+            || lint.name == invalid_codeblock_attributes_name\n         {\n             None\n         } else {"}, {"sha": "0e0426279183f631fd297c1d4b4bb0c65b475457", "filename": "src/librustdoc/html/static/normalize.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fnormalize.css", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fnormalize.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fnormalize.css?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -1 +1,2 @@\n+/* ignore-tidy-linelength */\n /*! normalize.css v3.0.0 | MIT License | git.io/normalize */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=\"button\"],input[type=\"reset\"],input[type=\"submit\"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=\"checkbox\"],input[type=\"radio\"]{box-sizing:border-box;padding:0}input[type=\"number\"]::-webkit-inner-spin-button,input[type=\"number\"]::-webkit-outer-spin-button{height:auto}input[type=\"search\"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type=\"search\"]::-webkit-search-cancel-button,input[type=\"search\"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:bold}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}"}, {"sha": "38709b445efae9aa89649872aa167af0053942dd", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -49,9 +49,9 @@\n }\n \n * {\n-  -webkit-box-sizing: border-box;\n-\t -moz-box-sizing: border-box;\n-\t\t  box-sizing: border-box;\n+\t-webkit-box-sizing: border-box;\n+\t-moz-box-sizing: border-box;\n+\tbox-sizing: border-box;\n }\n \n /* This part handles the \"default\" theme being used depending on the system one. */\n@@ -91,7 +91,8 @@ h2 {\n h3 {\n \tfont-size: 1.3em;\n }\n-h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod):not(.important), h4:not(.method):not(.type):not(.tymethod):not(.associatedconstant) {\n+h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod):not(.important),\n+h4:not(.method):not(.type):not(.tymethod):not(.associatedconstant) {\n \tfont-weight: 500;\n \tmargin: 20px 0 15px 0;\n \tpadding-bottom: 6px;\n@@ -103,7 +104,8 @@ h1.fqn {\n h1.fqn > .in-band > a:hover {\n \ttext-decoration: underline;\n }\n-h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod):not(.associatedconstant) {\n+h2, h3:not(.impl):not(.method):not(.type):not(.tymethod),\n+h4:not(.method):not(.type):not(.tymethod):not(.associatedconstant) {\n \tborder-bottom: 1px solid;\n }\n h3.impl, h3.method, h4.method, h3.type, h4.type, h4.associatedconstant {\n@@ -1123,21 +1125,20 @@ h3 > .collapse-toggle, h4 > .collapse-toggle {\n \t/* The margin on the tooltip does not capture hover events,\n \t   this extends the area of hover enough so that mouse hover is not\n \t   lost when moving the mouse to the tooltip */\n-    content: \"\\00a0\\00a0\\00a0\";\n+\tcontent: \"\\00a0\\00a0\\00a0\";\n }\n \n .important-traits .important, .important-traits .docblock {\n \tmargin: 0;\n }\n \n .important-traits .docblock code.content{\n-    margin: 0;\n-    padding: 0;\n-    font-size: 20px;\n+\tmargin: 0;\n+\tpadding: 0;\n+\tfont-size: 20px;\n }\n \n-/* Example code has the \"Run\" button that\n-   needs to be positioned relative to the pre */\n+/* Example code has the \"Run\" button that needs to be positioned relative to the pre */\n pre.rust.rust-example-rendered {\n \tposition: relative;\n }"}, {"sha": "e0ab7170ea8772d0bc5816d6d557f03d6f3b551f", "filename": "src/librustdoc/html/static/themes/ayu.css", "status": "modified", "additions": 67, "deletions": 51, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -10,7 +10,8 @@ body {\n \tcolor: #c5c5c5;\n }\n \n-h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n+h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod),\n+h4:not(.method):not(.type):not(.tymethod) {\n \tcolor: white;\n }\n h1.fqn {\n@@ -41,13 +42,13 @@ h3 > code, h4 > code, h5 > code {\n \tcolor: #e6e1cf;\n }\n pre > code {\n-    color: #e6e1cf; \n+\tcolor: #e6e1cf;\n }\n span code {\n-    color: #e6e1cf;\n+\tcolor: #e6e1cf;\n }\n .docblock a > code {\n-    color: #39AFD7 !important;\n+\tcolor: #39AFD7 !important;\n }\n .docblock code, .docblock-short code {\n \tbackground-color: #191f26;\n@@ -100,11 +101,11 @@ pre {\n }\n \n .sidebar-elems .location {\n-    color: #ff7733;\n+\tcolor: #ff7733;\n }\n \n .sidebar-elems .location a {\n-    color: #fff;\n+\tcolor: #fff;\n }\n \n .sidebar .version {\n@@ -123,9 +124,9 @@ pre {\n \n .line-numbers span { color: #5c6773ab; }\n .line-numbers .line-highlighted {\n-    background-color: rgba(255, 236, 164, 0.06) !important;\n-    padding-right: 4px;\n-    border-right: 1px solid #ffb44c;\n+\tbackground-color: rgba(255, 236, 164, 0.06) !important;\n+\tpadding-right: 4px;\n+\tborder-right: 1px solid #ffb44c;\n }\n \n .docblock h1, .docblock h2, .docblock h3, .docblock h4, .docblock h5 {\n@@ -168,31 +169,31 @@ pre {\n .content span.keyword, .content a.keyword { color: #de5249; }\n \n .content span.externcrate, .content span.mod, .content a.mod {\n-    color: #acccf9;\n+\tcolor: #acccf9;\n }\n .content span.struct, .content a.struct {\n-    color: #ffa0a5;\n+\tcolor: #ffa0a5;\n }\n .content span.enum, .content a.enum {\n-    color: #99e0c9;\n+\tcolor: #99e0c9;\n }\n .content span.trait, .content a.trait {\n-    color: #39AFD7;\n+\tcolor: #39AFD7;\n }\n .content span.type, .content a.type {\n-    color: #cfbcf5;\n+\tcolor: #cfbcf5;\n }\n .content span.fn, .content a.fn, .content span.method,\n .content a.method, .content span.tymethod,\n .content a.tymethod, .content .fnname {\n-    color: #fdd687;\n+\tcolor: #fdd687;\n }\n .content span.attr, .content a.attr, .content span.derive,\n .content a.derive, .content span.macro, .content a.macro {\n-    color: #a37acc;\n+\tcolor: #a37acc;\n }\n \n-pre.rust .comment, pre.rust .doccomment { \n+pre.rust .comment, pre.rust .doccomment {\n \tcolor: #788797;\n \tfont-style: italic;\n }\n@@ -228,14 +229,24 @@ a {\n }\n \n .search-input {\n-    color: #ffffff;\n-    background-color: #141920;\n-    box-shadow: 0 0 0 1px #424c57,0 0 0 2px transparent;\n-    transition: box-shadow 150ms ease-in-out;\n+\tcolor: #ffffff;\n+\tbackground-color: #141920;\n+\tbox-shadow: 0 0 0 1px #424c57,0 0 0 2px transparent;\n+\ttransition: box-shadow 150ms ease-in-out;\n }\n \n #crate-search+.search-input:focus {\n-    box-shadow: 0 0 0 1px #148099,0 0 0 2px transparent;\n+\tbox-shadow: 0 0 0 1px #148099,0 0 0 2px transparent;\n+\tcolor: #ffffff;\n+\tbackground-color: #141920;\n+\tbox-shadow: none;\n+\ttransition: box-shadow 150ms ease-in-out;\n+\tborder-radius: 4px;\n+\tmargin-left: 8px;\n+}\n+\n+#crate-search+.search-input:focus {\n+\tbox-shadow: 0px 6px 20px 0px black;\n }\n \n .search-focus:disabled {\n@@ -249,7 +260,7 @@ a {\n .stab.unstable,\n .stab.deprecated,\n .stab.portability {\n-    color: #c5c5c5;\n+\tcolor: #c5c5c5;\n \tbackground: #314559 !important;\n \tborder-style: none !important;\n \tborder-radius: 4px;\n@@ -262,10 +273,10 @@ a {\n }\n \n #help > div {\n-    background: #14191f;\n-    box-shadow: 0px 6px 20px 0px black;\n-    border: none;\n-    border-radius: 4px;\n+\tbackground: #14191f;\n+\tbox-shadow: 0px 6px 20px 0px black;\n+\tborder: none;\n+\tborder-radius: 4px;\n }\n \n .since {\n@@ -288,14 +299,14 @@ pre.rust .question-mark {\n \tcolor: #ff9011;\n }\n pre.rust .self {\n-    color: #36a3d9;\n-    font-style: italic;\n+\tcolor: #36a3d9;\n+\tfont-style: italic;\n }\n pre.rust .attribute {\n-    color: #e6e1cf;\n+\tcolor: #e6e1cf;\n }\n pre.rust .attribute .ident, pre.rust .attribute .op {\n-    color: #e6e1cf;\n+\tcolor: #e6e1cf;\n }\n \n .example-wrap > pre.line-number {\n@@ -304,15 +315,15 @@ pre.rust .attribute .ident, pre.rust .attribute .op {\n }\n \n a.test-arrow {\n-    font-size: 100%;\n-    color: #788797;\n-    border-radius: 4px;\n-    background-color: rgba(255, 255, 255, 0);\n+\tfont-size: 100%;\n+\tcolor: #788797;\n+\tborder-radius: 4px;\n+\tbackground-color: rgba(255, 255, 255, 0);\n }\n \n a.test-arrow:hover {\n-    background-color: rgba(242, 151, 24, 0.05);\n-    color: #ffb44c;\n+\tbackground-color: rgba(242, 151, 24, 0.05);\n+\tcolor: #ffb44c;\n }\n \n .toggle-label {\n@@ -377,22 +388,22 @@ pre.ignore:hover, .information:hover + pre.ignore {\n }\n \n .tooltip .tooltiptext {\n-    background-color: #314559;\n-    color: #c5c5c5;\n-    border: 1px solid #5c6773;\n+\tbackground-color: #314559;\n+\tcolor: #c5c5c5;\n+\tborder: 1px solid #5c6773;\n }\n \n .tooltip .tooltiptext::after {\n \tborder-color: transparent #314559 transparent transparent;\n }\n \n .important-traits-tooltiptext {\n-    background-color: #314559;\n-    border-color: #5c6773;\n+\tbackground-color: #314559;\n+\tborder-color: #5c6773;\n }\n \n #titles > div.selected {\n-    background-color: #141920 !important;\n+\tbackground-color: #141920 !important;\n \tborder-bottom: 1px solid #ffb44c !important;\n \tborder-top: none;\n }\n@@ -403,7 +414,7 @@ pre.ignore:hover, .information:hover + pre.ignore {\n }\n \n #titles > div:hover {\n-    border-bottom: 1px solid rgba(242, 151, 24, 0.3);\n+\tborder-bottom: 1px solid rgba(242, 151, 24, 0.3);\n }\n \n #titles > div > div.count {\n@@ -413,12 +424,13 @@ pre.ignore:hover, .information:hover + pre.ignore {\n /* rules that this theme does not need to set, here to satisfy the rule checker */\n /* note that a lot of these are partially set in some way (meaning they are set\n individually rather than as a group) */\n-/* TODO: these rules should be at the bottom of the file but currently must be\n+/* FIXME: these rules should be at the bottom of the file but currently must be\n above the `@media (max-width: 700px)` rules due to a bug in the css checker */\n /* see https://github.com/rust-lang/rust/pull/71237#issuecomment-618170143 */\n .content .highlighted.mod, .content .highlighted.externcrate {}\n .search-input:focus {}\n-.content span.attr,.content a.attr,.block a.current.attr,.content span.derive,.content a.derive,.block a.current.derive,.content span.macro,.content a.macro,.block a.current.macro {}\n+.content span.attr,.content a.attr,.block a.current.attr,.content span.derive,.content a.derive,\n+.block a.current.derive,.content span.macro,.content a.macro,.block a.current.macro {}\n .content .highlighted.trait {}\n .content span.struct,.content a.struct,.block a.current.struct {}\n #titles>div:hover,#titles>div.selected {}\n@@ -433,16 +445,20 @@ pre.rust .lifetime {}\n .content .highlighted.fn,.content .highlighted.method,.content .highlighted.tymethod {}\n h2,h3:not(.impl):not(.method):not(.type):not(.tymethod),h4:not(.method):not(.type):not(.tymethod) {}\n .content span.enum,.content a.enum,.block a.current.enum {}\n-.content span.constant,.content a.constant,.block a.current.constant,.content span.static,.content a.static,.block a.current.static {}\n+.content span.constant,.content a.constant,.block a.current.constant,.content span.static,\n+.content a.static,.block a.current.static {}\n .content span.keyword,.content a.keyword,.block a.current.keyword {}\n pre.rust .comment {}\n .content .highlighted.enum {}\n .content .highlighted.struct {}\n .content .highlighted.keyword {}\n .content span.traitalias,.content a.traitalias,.block a.current.traitalias {}\n-.content span.fn,.content a.fn,.block a.current.fn,.content span.method,.content a.method,.block a.current.method,.content span.tymethod,.content a.tymethod,.block a.current.tymethod,.content .fnname {}\n+.content span.fn,.content a.fn,.block a.current.fn,.content span.method,.content a.method,\n+.block a.current.method,.content span.tymethod,.content a.tymethod,.block a.current.tymethod,\n+.content .fnname {}\n pre.rust .kw {}\n-pre.rust .self,pre.rust .bool-val,pre.rust .prelude-val,pre.rust .attribute,pre.rust .attribute .ident {}\n+pre.rust .self,pre.rust .bool-val,pre.rust .prelude-val,pre.rust .attribute,\n+pre.rust .attribute .ident {}\n .content span.foreigntype,.content a.foreigntype,.block a.current.foreigntype {}\n pre.rust .doccomment {}\n .stab.deprecated {}\n@@ -483,11 +499,11 @@ kbd {\n \n #theme-picker, #settings-menu {\n \tborder-color: #5c6773;\n-    background-color: #0f1419;\n+\tbackground-color: #0f1419;\n }\n \n #theme-picker > img, #settings-menu > img {\n-    filter: invert(100);\n+\tfilter: invert(100);\n }\n \n #theme-picker:hover, #theme-picker:focus,"}, {"sha": "33c0f885fa95b4afe9f136c299f4db23e9c59b1b", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -3,13 +3,15 @@ body {\n \tcolor: #ddd;\n }\n \n-h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n+h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod),\n+h4:not(.method):not(.type):not(.tymethod) {\n \tcolor: #ddd;\n }\n h1.fqn {\n \tborder-bottom-color: #d2d2d2;\n }\n-h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n+h2, h3:not(.impl):not(.method):not(.type):not(.tymethod),\n+h4:not(.method):not(.type):not(.tymethod) {\n \tborder-bottom-color: #d2d2d2;\n }\n "}, {"sha": "569ce7da2091f07d79c2499d6f7fe4335de6bdd6", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -5,13 +5,15 @@ body {\n \tcolor: black;\n }\n \n-h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n+h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod),\n+h4:not(.method):not(.type):not(.tymethod) {\n \tcolor: black;\n }\n h1.fqn {\n \tborder-bottom-color: #D5D5D5;\n }\n-h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n+h2, h3:not(.impl):not(.method):not(.type):not(.tymethod),\n+h4:not(.method):not(.type):not(.tymethod) {\n \tborder-bottom-color: #DDDDDD;\n }\n "}, {"sha": "e187b9251f71e5194d002060dbca21f94b2211e7", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -584,25 +584,18 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             let (res, fragment) = {\n                 let mut kind = None;\n                 let mut disambiguator = None;\n-                path_str = if let Some(prefix) = [\"struct@\", \"enum@\", \"type@\", \"trait@\", \"union@\"]\n-                    .iter()\n-                    .find(|p| link.starts_with(**p))\n+                path_str = if let Some(prefix) =\n+                    [\"struct@\", \"enum@\", \"type@\", \"trait@\", \"union@\", \"module@\", \"mod@\"]\n+                        .iter()\n+                        .find(|p| link.starts_with(**p))\n                 {\n                     kind = Some(TypeNS);\n                     disambiguator = Some(&prefix[..prefix.len() - 1]);\n                     link.trim_start_matches(prefix)\n-                } else if let Some(prefix) = [\n-                    \"const@\",\n-                    \"static@\",\n-                    \"value@\",\n-                    \"function@\",\n-                    \"mod@\",\n-                    \"fn@\",\n-                    \"module@\",\n-                    \"method@\",\n-                ]\n-                .iter()\n-                .find(|p| link.starts_with(**p))\n+                } else if let Some(prefix) =\n+                    [\"const@\", \"static@\", \"value@\", \"function@\", \"fn@\", \"method@\"]\n+                        .iter()\n+                        .find(|p| link.starts_with(**p))\n                 {\n                     kind = Some(ValueNS);\n                     disambiguator = Some(&prefix[..prefix.len() - 1]);"}, {"sha": "e8ea71997109ad31ec7c78047e201176b7775d5c", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -45,14 +45,14 @@ pub struct TestOptions {\n pub fn run(options: Options) -> Result<(), String> {\n     let input = config::Input::File(options.input.clone());\n \n-    let invalid_codeblock_attribute_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTES.name;\n+    let invalid_codeblock_attributes_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTES.name;\n \n     // In addition to those specific lints, we also need to allow those given through\n     // command line, otherwise they'll get ignored and we don't want that.\n-    let allowed_lints = vec![invalid_codeblock_attribute_name.to_owned()];\n+    let allowed_lints = vec![invalid_codeblock_attributes_name.to_owned()];\n \n     let (lint_opts, lint_caps) = init_lints(allowed_lints, options.lint_opts.clone(), |lint| {\n-        if lint.name == invalid_codeblock_attribute_name {\n+        if lint.name == invalid_codeblock_attributes_name {\n             None\n         } else {\n             Some((lint.name_lower(), lint::Allow))"}, {"sha": "918dc5ec38701789962880be5ce27c1919b049c6", "filename": "src/test/mir-opt/issue-49232/rustc.main.mir_map.0.mir", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fmir-opt%2Fissue-49232%2Frustc.main.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fmir-opt%2Fissue-49232%2Frustc.main.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-49232%2Frustc.main.mir_map.0.mir?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -79,13 +79,6 @@ fn main() -> () {\n     }\n \n     bb10: {\n-        _4 = const ();                   // scope 0 at $DIR/issue-49232.rs:10:25: 10:30\n-                                         // ty::Const\n-                                         // + ty: ()\n-                                         // + val: Value(Scalar(<ZST>))\n-                                         // mir::Constant\n-                                         // + span: $DIR/issue-49232.rs:10:25: 10:30\n-                                         // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n         unreachable;                     // scope 0 at $DIR/issue-49232.rs:10:25: 10:30\n     }\n "}, {"sha": "7739ef87fb9b712d5236c25cbddc6a83f61d751d", "filename": "src/test/mir-opt/issue-73223/32bit/rustc.main.SimplifyArmIdentity.diff", "status": "modified", "additions": 126, "deletions": 132, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fmir-opt%2Fissue-73223%2F32bit%2Frustc.main.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fmir-opt%2Fissue-73223%2F32bit%2Frustc.main.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-73223%2F32bit%2Frustc.main.SimplifyArmIdentity.diff?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -26,67 +26,61 @@\n       let mut _24: &[&str; 3];             // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n       let _25: &[&str; 3];                 // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n       let _26: [&str; 3];                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _27: &str;                   // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let _28: &str;                       // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _29: &str;                   // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let _30: &str;                       // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _31: &str;                   // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let _32: &str;                       // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _33: &[std::fmt::ArgumentV1]; // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n-      let mut _34: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n-      let _35: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n-      let _36: [std::fmt::ArgumentV1; 2];  // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n-      let mut _37: (&&i32, &&i32);         // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n-      let mut _38: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let _39: &i32;                       // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _40: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let _41: &i32;                       // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _44: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n-      let mut _45: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _46: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _47: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n-      let mut _48: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _49: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let mut _27: &[std::fmt::ArgumentV1]; // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n+      let mut _28: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n+      let _29: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n+      let _30: [std::fmt::ArgumentV1; 2];  // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n+      let mut _31: (&&i32, &&i32);         // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n+      let mut _32: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let _33: &i32;                       // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let mut _34: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let _35: &i32;                       // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let mut _38: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n+      let mut _39: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let mut _40: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let mut _41: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n+      let mut _42: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let mut _43: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n       scope 1 {\n           debug split => _1;               // in scope 1 at $DIR/issue-73223.rs:2:9: 2:14\n           let _6: std::option::Option<i32>; // in scope 1 at $DIR/issue-73223.rs:7:9: 7:14\n           scope 3 {\n               debug _prev => _6;           // in scope 3 at $DIR/issue-73223.rs:7:9: 7:14\n               let _13: &i32;               // in scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n               let _14: &i32;               // in scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-              let mut _51: &i32;           // in scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+              let mut _45: &i32;           // in scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n               scope 4 {\n                   debug left_val => _13;   // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                   debug right_val => _14;  // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-                  let _42: &&i32;          // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-                  let _43: &&i32;          // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-                  let mut _50: &[&str; 3]; // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+                  let _36: &&i32;          // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+                  let _37: &&i32;          // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+                  let mut _44: &[&str; 3]; // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                   scope 5 {\n-                      debug arg0 => _42;   // in scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-                      debug arg1 => _43;   // in scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+                      debug arg0 => _36;   // in scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+                      debug arg1 => _37;   // in scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                       scope 6 {\n-                          debug x => _45;  // in scope 6 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-                          debug f => _46;  // in scope 6 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-                          let mut _52: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                          let mut _53: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                          let mut _54: &core::fmt::Opaque; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                          let mut _55: &&i32; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          debug x => _39;  // in scope 6 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+                          debug f => _40;  // in scope 6 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+                          let mut _46: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          let mut _47: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          let mut _48: &core::fmt::Opaque; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          let mut _49: &&i32; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n                       }\n                       scope 8 {\n-                          debug x => _48;  // in scope 8 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-                          debug f => _49;  // in scope 8 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-                          let mut _56: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                          let mut _57: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                          let mut _58: &core::fmt::Opaque; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                          let mut _59: &&i32; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          debug x => _42;  // in scope 8 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+                          debug f => _43;  // in scope 8 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+                          let mut _50: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          let mut _51: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          let mut _52: &core::fmt::Opaque; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          let mut _53: &&i32; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n                       }\n                   }\n                   scope 10 {\n                       debug pieces => _23; // in scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-                      debug args => _33;   // in scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-                      let mut _60: &[&str]; // in scope 10 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                      let mut _61: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                      let mut _62: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                      debug args => _27;   // in scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+                      let mut _54: &[&str]; // in scope 10 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                      let mut _55: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                      let mut _56: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/libstd/macros.rs:LL:COL\n                   }\n               }\n           }\n@@ -150,14 +144,14 @@\n           StorageLive(_10);                // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           _10 = &_1;                       // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           StorageLive(_11);                // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _51 = const main::promoted[1];   // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _45 = const main::promoted[1];   // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: &i32\n                                            // + val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[1]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: &i32, val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[1])) }\n-          _11 = _51;                       // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _11 = _45;                       // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           (_9.0: &i32) = move _10;         // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           (_9.1: &i32) = move _11;         // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           StorageDead(_11);                // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n@@ -217,53 +211,53 @@\n           StorageLive(_23);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           StorageLive(_24);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           StorageLive(_25);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _50 = const main::promoted[0];   // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _44 = const main::promoted[0];   // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: &[&str; 3]\n                                            // + val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: &[&str; 3], val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[0])) }\n-          _25 = _50;                       // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _25 = _44;                       // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           _24 = _25;                       // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           _23 = move _24 as &[&str] (Pointer(Unsize)); // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           StorageDead(_24);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_33);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_34);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_35);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_36);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_37);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_38);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_39);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _39 = _13;                       // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _38 = &_39;                      // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_40);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_41);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _41 = _14;                       // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _40 = &_41;                      // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          (_37.0: &&i32) = move _38;       // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          (_37.1: &&i32) = move _40;       // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_40);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_38);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_42);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _42 = (_37.0: &&i32);            // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_43);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _43 = (_37.1: &&i32);            // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_44);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_45);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _45 = _42;                       // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_46);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _46 = const <&i32 as std::fmt::Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_27);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_28);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_29);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_30);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_31);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_32);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_33);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _33 = _13;                       // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _32 = &_33;                      // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_34);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_35);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _35 = _14;                       // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _34 = &_35;                      // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          (_31.0: &&i32) = move _32;       // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          (_31.1: &&i32) = move _34;       // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_34);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_32);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_36);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _36 = (_31.0: &&i32);            // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_37);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _37 = (_31.1: &&i32);            // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_38);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_39);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _39 = _36;                       // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_40);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _40 = const <&i32 as std::fmt::Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}\n                                            // + val: Value(Scalar(<ZST>))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}, val: Value(Scalar(<ZST>)) }\n-          StorageLive(_52);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_53);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _53 = _46;                       // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _52 = const std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _53) -> bb6; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_46);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_47);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _47 = _40;                       // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _46 = const std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _47) -> bb6; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: unsafe extern \"rust-intrinsic\" fn(for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) -> for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>}\n                                            // + val: Value(Scalar(<ZST>))\n@@ -273,11 +267,11 @@\n       }\n   \n       bb6: {\n-          StorageDead(_53);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_54);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_55);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _55 = _45;                       // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _54 = const std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>(move _55) -> bb7; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_47);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_48);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_49);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _49 = _39;                       // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _48 = const std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>(move _49) -> bb7; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: unsafe extern \"rust-intrinsic\" fn(&&i32) -> &core::fmt::Opaque {std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>}\n                                            // + val: Value(Scalar(<ZST>))\n@@ -287,28 +281,28 @@\n       }\n   \n       bb7: {\n-          StorageDead(_55);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          (_44.0: &core::fmt::Opaque) = move _54; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          (_44.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _52; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_54);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_52);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_46);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_45);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_47);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_48);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _48 = _43;                       // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_49);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _49 = const <&i32 as std::fmt::Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageDead(_49);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          (_38.0: &core::fmt::Opaque) = move _48; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          (_38.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _46; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_48);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_46);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_40);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_39);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_41);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_42);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _42 = _37;                       // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_43);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _43 = const <&i32 as std::fmt::Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}\n                                            // + val: Value(Scalar(<ZST>))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}, val: Value(Scalar(<ZST>)) }\n-          StorageLive(_56);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_57);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _57 = _49;                       // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _56 = const std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _57) -> bb8; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_50);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_51);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _51 = _43;                       // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _50 = const std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _51) -> bb8; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: unsafe extern \"rust-intrinsic\" fn(for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) -> for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>}\n                                            // + val: Value(Scalar(<ZST>))\n@@ -318,11 +312,11 @@\n       }\n   \n       bb8: {\n-          StorageDead(_57);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_58);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_59);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _59 = _48;                       // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _58 = const std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>(move _59) -> bb9; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_51);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_52);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_53);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _53 = _42;                       // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _52 = const std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>(move _53) -> bb9; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: unsafe extern \"rust-intrinsic\" fn(&&i32) -> &core::fmt::Opaque {std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>}\n                                            // + val: Value(Scalar(<ZST>))\n@@ -332,35 +326,35 @@\n       }\n   \n       bb9: {\n-          StorageDead(_59);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          (_47.0: &core::fmt::Opaque) = move _58; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          (_47.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _56; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_58);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_56);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_49);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_48);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          _36 = [move _44, move _47];      // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_47);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_44);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_43);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_42);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          _35 = &_36;                      // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          _34 = _35;                       // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          _33 = move _34 as &[std::fmt::ArgumentV1] (Pointer(Unsize)); // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_34);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_60);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _60 = _23;                       // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_61);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          discriminant(_61) = 0;           // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_62);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _62 = _33;                       // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          (_22.0: &[&str]) = move _60;     // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          (_22.1: std::option::Option<&[std::fmt::rt::v1::Argument]>) = move _61; // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          (_22.2: &[std::fmt::ArgumentV1]) = move _62; // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_62);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_61);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_60);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_33);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_53);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          (_41.0: &core::fmt::Opaque) = move _52; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          (_41.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _50; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_52);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_50);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_43);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_42);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          _30 = [move _38, move _41];      // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_41);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_38);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_37);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_36);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          _29 = &_30;                      // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          _28 = _29;                       // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          _27 = move _28 as &[std::fmt::ArgumentV1] (Pointer(Unsize)); // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_28);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_54);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _54 = _23;                       // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_55);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          discriminant(_55) = 0;           // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_56);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _56 = _27;                       // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          (_22.0: &[&str]) = move _54;     // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          (_22.1: std::option::Option<&[std::fmt::rt::v1::Argument]>) = move _55; // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          (_22.2: &[std::fmt::ArgumentV1]) = move _56; // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_56);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_55);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_54);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_27);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n           StorageDead(_23);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n           _21 = &_22;                      // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n           _20 = _21;                       // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL"}, {"sha": "c4d0a6f4bc6aa71dba4eedc9c8d5274839d798ba", "filename": "src/test/mir-opt/issue-73223/64bit/rustc.main.SimplifyArmIdentity.diff", "status": "modified", "additions": 126, "deletions": 132, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fmir-opt%2Fissue-73223%2F64bit%2Frustc.main.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fmir-opt%2Fissue-73223%2F64bit%2Frustc.main.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-73223%2F64bit%2Frustc.main.SimplifyArmIdentity.diff?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -26,67 +26,61 @@\n       let mut _24: &[&str; 3];             // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n       let _25: &[&str; 3];                 // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n       let _26: [&str; 3];                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _27: &str;                   // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let _28: &str;                       // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _29: &str;                   // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let _30: &str;                       // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _31: &str;                   // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let _32: &str;                       // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _33: &[std::fmt::ArgumentV1]; // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n-      let mut _34: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n-      let _35: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n-      let _36: [std::fmt::ArgumentV1; 2];  // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n-      let mut _37: (&&i32, &&i32);         // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n-      let mut _38: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let _39: &i32;                       // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _40: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let _41: &i32;                       // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _44: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n-      let mut _45: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _46: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _47: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n-      let mut _48: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-      let mut _49: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let mut _27: &[std::fmt::ArgumentV1]; // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n+      let mut _28: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n+      let _29: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n+      let _30: [std::fmt::ArgumentV1; 2];  // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n+      let mut _31: (&&i32, &&i32);         // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n+      let mut _32: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let _33: &i32;                       // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let mut _34: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let _35: &i32;                       // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let mut _38: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n+      let mut _39: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let mut _40: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let mut _41: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/libstd/macros.rs:LL:COL\n+      let mut _42: &&i32;                  // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+      let mut _43: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 0 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n       scope 1 {\n           debug split => _1;               // in scope 1 at $DIR/issue-73223.rs:2:9: 2:14\n           let _6: std::option::Option<i32>; // in scope 1 at $DIR/issue-73223.rs:7:9: 7:14\n           scope 3 {\n               debug _prev => _6;           // in scope 3 at $DIR/issue-73223.rs:7:9: 7:14\n               let _13: &i32;               // in scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n               let _14: &i32;               // in scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-              let mut _51: &i32;           // in scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+              let mut _45: &i32;           // in scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n               scope 4 {\n                   debug left_val => _13;   // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                   debug right_val => _14;  // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-                  let _42: &&i32;          // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-                  let _43: &&i32;          // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-                  let mut _50: &[&str; 3]; // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+                  let _36: &&i32;          // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+                  let _37: &&i32;          // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+                  let mut _44: &[&str; 3]; // in scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                   scope 5 {\n-                      debug arg0 => _42;   // in scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-                      debug arg1 => _43;   // in scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+                      debug arg0 => _36;   // in scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+                      debug arg1 => _37;   // in scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                       scope 6 {\n-                          debug x => _45;  // in scope 6 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-                          debug f => _46;  // in scope 6 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-                          let mut _52: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                          let mut _53: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                          let mut _54: &core::fmt::Opaque; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                          let mut _55: &&i32; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          debug x => _39;  // in scope 6 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+                          debug f => _40;  // in scope 6 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+                          let mut _46: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          let mut _47: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          let mut _48: &core::fmt::Opaque; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          let mut _49: &&i32; // in scope 6 at $SRC_DIR/libstd/macros.rs:LL:COL\n                       }\n                       scope 8 {\n-                          debug x => _48;  // in scope 8 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-                          debug f => _49;  // in scope 8 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-                          let mut _56: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                          let mut _57: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                          let mut _58: &core::fmt::Opaque; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                          let mut _59: &&i32; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          debug x => _42;  // in scope 8 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+                          debug f => _43;  // in scope 8 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+                          let mut _50: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          let mut _51: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          let mut _52: &core::fmt::Opaque; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                          let mut _53: &&i32; // in scope 8 at $SRC_DIR/libstd/macros.rs:LL:COL\n                       }\n                   }\n                   scope 10 {\n                       debug pieces => _23; // in scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-                      debug args => _33;   // in scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-                      let mut _60: &[&str]; // in scope 10 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                      let mut _61: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/libstd/macros.rs:LL:COL\n-                      let mut _62: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                      debug args => _27;   // in scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+                      let mut _54: &[&str]; // in scope 10 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                      let mut _55: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/libstd/macros.rs:LL:COL\n+                      let mut _56: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/libstd/macros.rs:LL:COL\n                   }\n               }\n           }\n@@ -150,14 +144,14 @@\n           StorageLive(_10);                // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           _10 = &_1;                       // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           StorageLive(_11);                // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _51 = const main::promoted[1];   // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _45 = const main::promoted[1];   // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: &i32\n                                            // + val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[1]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: &i32, val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[1])) }\n-          _11 = _51;                       // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _11 = _45;                       // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           (_9.0: &i32) = move _10;         // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           (_9.1: &i32) = move _11;         // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           StorageDead(_11);                // scope 3 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n@@ -217,53 +211,53 @@\n           StorageLive(_23);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           StorageLive(_24);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           StorageLive(_25);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _50 = const main::promoted[0];   // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _44 = const main::promoted[0];   // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: &[&str; 3]\n                                            // + val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: &[&str; 3], val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[0])) }\n-          _25 = _50;                       // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _25 = _44;                       // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           _24 = _25;                       // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           _23 = move _24 as &[&str] (Pointer(Unsize)); // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n           StorageDead(_24);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_33);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_34);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_35);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_36);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_37);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_38);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_39);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _39 = _13;                       // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _38 = &_39;                      // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_40);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_41);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _41 = _14;                       // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _40 = &_41;                      // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          (_37.0: &&i32) = move _38;       // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          (_37.1: &&i32) = move _40;       // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_40);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_38);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_42);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _42 = (_37.0: &&i32);            // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_43);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _43 = (_37.1: &&i32);            // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_44);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_45);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _45 = _42;                       // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_46);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _46 = const <&i32 as std::fmt::Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_27);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_28);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_29);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_30);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_31);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_32);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_33);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _33 = _13;                       // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _32 = &_33;                      // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_34);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_35);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _35 = _14;                       // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _34 = &_35;                      // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          (_31.0: &&i32) = move _32;       // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          (_31.1: &&i32) = move _34;       // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_34);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_32);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_36);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _36 = (_31.0: &&i32);            // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_37);                // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _37 = (_31.1: &&i32);            // scope 4 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_38);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_39);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _39 = _36;                       // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_40);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _40 = const <&i32 as std::fmt::Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}\n                                            // + val: Value(Scalar(<ZST>))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}, val: Value(Scalar(<ZST>)) }\n-          StorageLive(_52);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_53);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _53 = _46;                       // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _52 = const std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _53) -> bb6; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_46);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_47);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _47 = _40;                       // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _46 = const std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _47) -> bb6; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: unsafe extern \"rust-intrinsic\" fn(for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) -> for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>}\n                                            // + val: Value(Scalar(<ZST>))\n@@ -273,11 +267,11 @@\n       }\n   \n       bb6: {\n-          StorageDead(_53);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_54);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_55);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _55 = _45;                       // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _54 = const std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>(move _55) -> bb7; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_47);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_48);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_49);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _49 = _39;                       // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _48 = const std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>(move _49) -> bb7; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: unsafe extern \"rust-intrinsic\" fn(&&i32) -> &core::fmt::Opaque {std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>}\n                                            // + val: Value(Scalar(<ZST>))\n@@ -287,28 +281,28 @@\n       }\n   \n       bb7: {\n-          StorageDead(_55);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          (_44.0: &core::fmt::Opaque) = move _54; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          (_44.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _52; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_54);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_52);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_46);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_45);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_47);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_48);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _48 = _43;                       // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          StorageLive(_49);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n-          _49 = const <&i32 as std::fmt::Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageDead(_49);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          (_38.0: &core::fmt::Opaque) = move _48; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          (_38.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _46; // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_48);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_46);                // scope 7 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_40);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_39);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_41);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_42);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _42 = _37;                       // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          StorageLive(_43);                // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n+          _43 = const <&i32 as std::fmt::Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}\n                                            // + val: Value(Scalar(<ZST>))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/libcore/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}, val: Value(Scalar(<ZST>)) }\n-          StorageLive(_56);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_57);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _57 = _49;                       // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _56 = const std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _57) -> bb8; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_50);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_51);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _51 = _43;                       // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _50 = const std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _51) -> bb8; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: unsafe extern \"rust-intrinsic\" fn(for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) -> for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>}\n                                            // + val: Value(Scalar(<ZST>))\n@@ -318,11 +312,11 @@\n       }\n   \n       bb8: {\n-          StorageDead(_57);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_58);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_59);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _59 = _48;                       // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _58 = const std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>(move _59) -> bb9; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_51);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_52);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_53);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _53 = _42;                       // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _52 = const std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>(move _53) -> bb9; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: unsafe extern \"rust-intrinsic\" fn(&&i32) -> &core::fmt::Opaque {std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>}\n                                            // + val: Value(Scalar(<ZST>))\n@@ -332,35 +326,35 @@\n       }\n   \n       bb9: {\n-          StorageDead(_59);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          (_47.0: &core::fmt::Opaque) = move _58; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          (_47.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _56; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_58);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_56);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_49);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_48);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          _36 = [move _44, move _47];      // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_47);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_44);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_43);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_42);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          _35 = &_36;                      // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          _34 = _35;                       // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          _33 = move _34 as &[std::fmt::ArgumentV1] (Pointer(Unsize)); // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageDead(_34);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n-          StorageLive(_60);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _60 = _23;                       // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_61);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          discriminant(_61) = 0;           // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageLive(_62);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          _62 = _33;                       // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          (_22.0: &[&str]) = move _60;     // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          (_22.1: std::option::Option<&[std::fmt::rt::v1::Argument]>) = move _61; // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          (_22.2: &[std::fmt::ArgumentV1]) = move _62; // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_62);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_61);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_60);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n-          StorageDead(_33);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_53);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          (_41.0: &core::fmt::Opaque) = move _52; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          (_41.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _50; // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_52);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_50);                // scope 9 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_43);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_42);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          _30 = [move _38, move _41];      // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_41);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_38);                // scope 5 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_37);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_36);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          _29 = &_30;                      // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          _28 = _29;                       // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          _27 = move _28 as &[std::fmt::ArgumentV1] (Pointer(Unsize)); // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageDead(_28);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n+          StorageLive(_54);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _54 = _23;                       // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_55);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          discriminant(_55) = 0;           // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageLive(_56);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          _56 = _27;                       // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          (_22.0: &[&str]) = move _54;     // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          (_22.1: std::option::Option<&[std::fmt::rt::v1::Argument]>) = move _55; // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          (_22.2: &[std::fmt::ArgumentV1]) = move _56; // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_56);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_55);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_54);                // scope 10 at $SRC_DIR/libcore/fmt/mod.rs:LL:COL\n+          StorageDead(_27);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n           StorageDead(_23);                // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n           _21 = &_22;                      // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL\n           _20 = _21;                       // scope 4 at $SRC_DIR/libstd/macros.rs:LL:COL"}, {"sha": "0e45b6f04a8a47b1ad901697b2eb7ff2443151ec", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -34,27 +34,27 @@\n                            ((::alloc::fmt::format as\n                                 for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((::core::fmt::Arguments::new_v1\n                                                                                                                     as\n-                                                                                                                    fn(&[&str], &[std::fmt::ArgumentV1]) -> std::fmt::Arguments {std::fmt::Arguments::new_v1})((&([(\"test\"\n-                                                                                                                                                                                                                       as\n-                                                                                                                                                                                                                       &str)]\n-                                                                                                                                                                                                                     as\n-                                                                                                                                                                                                                     [&str; 1])\n-                                                                                                                                                                                                                   as\n-                                                                                                                                                                                                                   &[&str; 1]),\n-                                                                                                                                                                                                               (&(match (()\n-                                                                                                                                                                                                                            as\n-                                                                                                                                                                                                                            ())\n-                                                                                                                                                                                                                      {\n-                                                                                                                                                                                                                      ()\n-                                                                                                                                                                                                                      =>\n-                                                                                                                                                                                                                      ([]\n-                                                                                                                                                                                                                          as\n-                                                                                                                                                                                                                          [std::fmt::ArgumentV1; 0]),\n-                                                                                                                                                                                                                  }\n-                                                                                                                                                                                                                     as\n-                                                                                                                                                                                                                     [std::fmt::ArgumentV1; 0])\n-                                                                                                                                                                                                                   as\n-                                                                                                                                                                                                                   &[std::fmt::ArgumentV1; 0]))\n+                                                                                                                    fn(&[&'static str], &[std::fmt::ArgumentV1]) -> std::fmt::Arguments {std::fmt::Arguments::new_v1})((&([(\"test\"\n+                                                                                                                                                                                                                               as\n+                                                                                                                                                                                                                               &str)]\n+                                                                                                                                                                                                                             as\n+                                                                                                                                                                                                                             [&str; 1])\n+                                                                                                                                                                                                                           as\n+                                                                                                                                                                                                                           &[&str; 1]),\n+                                                                                                                                                                                                                       (&(match (()\n+                                                                                                                                                                                                                                    as\n+                                                                                                                                                                                                                                    ())\n+                                                                                                                                                                                                                              {\n+                                                                                                                                                                                                                              ()\n+                                                                                                                                                                                                                              =>\n+                                                                                                                                                                                                                              ([]\n+                                                                                                                                                                                                                                  as\n+                                                                                                                                                                                                                                  [std::fmt::ArgumentV1; 0]),\n+                                                                                                                                                                                                                          }\n+                                                                                                                                                                                                                             as\n+                                                                                                                                                                                                                             [std::fmt::ArgumentV1; 0])\n+                                                                                                                                                                                                                           as\n+                                                                                                                                                                                                                           &[std::fmt::ArgumentV1; 0]))\n                                                                                                                    as\n                                                                                                                    std::fmt::Arguments))\n                                as std::string::String);"}, {"sha": "0cf5d1855212d6ea064661ba22a0ba21168b188d", "filename": "src/test/run-make-fulldeps/compiler-rt-works-on-mingw/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Fcompiler-rt-works-on-mingw%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Fcompiler-rt-works-on-mingw%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcompiler-rt-works-on-mingw%2FMakefile?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -1,6 +1,6 @@\n -include ../tools.mk\n \n-# only-mingw\n+# only-windows-gnu\n \n all:\n \t$(CXX) foo.cpp -c -o $(TMPDIR)/foo.o"}, {"sha": "f91af88efe1b715a3dc9fdc183de419de76b90e5", "filename": "src/test/run-make-fulldeps/include_bytes_deps/Makefile", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Finclude_bytes_deps%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Finclude_bytes_deps%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finclude_bytes_deps%2FMakefile?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -1,10 +1,6 @@\n -include ../tools.mk\n \n-# ignore-windows\n # ignore-freebsd\n-# FIXME: on windows `rustc --dep-info` produces Makefile dependency with\n-# windows native paths (e.g. `c:\\path\\to\\libfoo.a`)\n-# but msys make seems to fail to recognize such paths, so test fails.\n \n all:\n \t$(RUSTC) --emit dep-info main.rs"}, {"sha": "2037728568e2409493a3cea9ef7bc2dfc232fe7e", "filename": "src/test/run-make-fulldeps/intrinsic-unreachable/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Fintrinsic-unreachable%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Fintrinsic-unreachable%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fintrinsic-unreachable%2FMakefile?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -1,6 +1,6 @@\n -include ../tools.mk\n \n-# ignore-windows\n+# ignore-windows-msvc\n #\n # Because of Windows exception handling, the code is not necessarily any shorter.\n # https://github.com/llvm-mirror/llvm/commit/64b2297786f7fd6f5fa24cdd4db0298fbf211466"}, {"sha": "ba3d3b7100745e0debe024ac76d776f86f7e868a", "filename": "src/test/run-make-fulldeps/issue-51671/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Fissue-51671%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Fissue-51671%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-51671%2FMakefile?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -1,6 +1,6 @@\n -include ../tools.mk\n \n-# ignore-windows\n+# ignore-windows-msvc\n \n all:\n \t$(RUSTC) --emit=obj app.rs"}, {"sha": "f31036ffa19591cea06c7bcb087ce9d8fc3b9292", "filename": "src/test/run-make-fulldeps/libs-search-path/Makefile", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Frun-make-fulldeps%2Flibs-search-path%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Frun-make-fulldeps%2Flibs-search-path%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibs-search-path%2FMakefile?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1,10 +0,0 @@\n--include ../tools.mk\n-\n-# only-mingw\n-\n-all: empty.rs\n-\tcp -r $(shell cygpath -u $(shell $(RUSTC) --print sysroot)) $(TMPDIR)/sysroot\n-\t$(RUSTC) --target $(TARGET) --sysroot $(TMPDIR)/sysroot -L$(TMPDIR)/obj -Z print-link-args empty.rs | $(CGREP) 'lib\\\\crt2.o'\n-\tmkdir -p $(TMPDIR)/obj\n-\tmv $(TMPDIR)/sysroot/lib/rustlib/$(TARGET)/lib/crt2.o $(TMPDIR)/obj/crt2.o\n-\t$(RUSTC) --target $(TARGET) --sysroot $(TMPDIR)/sysroot -L$(TMPDIR)/obj -Z print-link-args empty.rs | $(CGREP) 'obj\\\\crt2.o'"}, {"sha": "f328e4d9d04c31d0d70d16d21a07d1613be9d577", "filename": "src/test/run-make-fulldeps/libs-search-path/empty.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Frun-make-fulldeps%2Flibs-search-path%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d5a61f2e4e237123837f5162cc275c2fd7e625/src%2Ftest%2Frun-make-fulldeps%2Flibs-search-path%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibs-search-path%2Fempty.rs?ref=39d5a61f2e4e237123837f5162cc275c2fd7e625", "patch": "@@ -1 +0,0 @@\n-fn main() {}"}, {"sha": "8468d102bec8312a276df6de130368ef4d492891", "filename": "src/test/run-make-fulldeps/redundant-libs/Makefile", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Fredundant-libs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Fredundant-libs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fredundant-libs%2FMakefile?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -1,8 +1,6 @@\n -include ../tools.mk\n \n-ifdef IS_WINDOWS\n-all:\n-else\n+# ignore-windows-msvc\n \n # rustc will remove one of the two redundant references to foo below.  Depending\n # on which one gets removed, we'll get a linker error on SOME platforms (like\n@@ -23,5 +21,3 @@ RUSTC_FLAGS = \\\n all: $(call DYLIB,foo) $(call STATICLIB,bar) $(call STATICLIB,baz)\n \t$(RUSTC) $(RUSTC_FLAGS) main.rs\n \t$(call RUN,main)\n-\n-endif"}, {"sha": "dc55c947d89a2fef1017bee007cc63dbb2735e6a", "filename": "src/test/run-make-fulldeps/symbol-visibility/Makefile", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -1,9 +1,6 @@\n include ../tools.mk\n \n-# ignore-windows\n-#\n-# On MINGW the --version-script, --dynamic-list, and --retain-symbol args don't\n-# seem to work reliably.\n+# ignore-windows-msvc\n \n NM=nm -D\n CDYLIB_NAME=liba_cdylib.so\n@@ -19,6 +16,14 @@ EXE_NAME=an_executable\n COMBINED_CDYLIB_NAME=libcombined_rlib_dylib.dylib\n endif\n \n+ifdef IS_WINDOWS\n+NM=nm -g\n+CDYLIB_NAME=liba_cdylib.dll.a\n+RDYLIB_NAME=liba_rust_dylib.dll.a\n+EXE_NAME=an_executable.exe\n+COMBINED_CDYLIB_NAME=libcombined_rlib_dylib.dll.a\n+endif\n+\n # `grep` regex for symbols produced by either `legacy` or `v0` mangling\n RE_ANY_RUST_SYMBOL=\"_ZN.*h.*E\\|_R[a-zA-Z0-9_]+\"\n \n@@ -30,38 +35,38 @@ all:\n \t$(RUSTC) -Zshare-generics=no a_cdylib.rs --crate-name combined_rlib_dylib --crate-type=rlib,cdylib\n \n \t# Check that a cdylib exports its public #[no_mangle] functions\n-\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c public_c_function_from_cdylib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -v __imp_ | grep -c public_c_function_from_cdylib)\" -eq \"1\" ]\n \t# Check that a cdylib exports the public #[no_mangle] functions of dependencies\n-\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -v __imp_ | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n \t# Check that a cdylib DOES NOT export any public Rust functions\n-\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c $(RE_ANY_RUST_SYMBOL))\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -v __imp_ | grep -c $(RE_ANY_RUST_SYMBOL))\" -eq \"0\" ]\n \n \t# Check that a Rust dylib exports its monomorphic functions\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rust_dylib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rust_dylib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -v __imp_ | grep -c public_c_function_from_rust_dylib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -v __imp_ | grep -c public_rust_function_from_rust_dylib)\" -eq \"1\" ]\n \t# Check that a Rust dylib does not export generics if -Zshare-generics=no\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rust_dylib)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -v __imp_ | grep -c public_generic_function_from_rust_dylib)\" -eq \"0\" ]\n \n \n \t# Check that a Rust dylib exports the monomorphic functions from its dependencies\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rlib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -v __imp_ | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -v __imp_ | grep -c public_rust_function_from_rlib)\" -eq \"1\" ]\n \t# Check that a Rust dylib does not export generics if -Zshare-generics=no\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rlib)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -v __imp_ | grep -c public_generic_function_from_rlib)\" -eq \"0\" ]\n \n \t# Check that an executable does not export any dynamic symbols\n-\t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -c public_c_function_from_rlib)\" -eq \"0\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -c public_rust_function_from_exe)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -v __imp_ | grep -c public_c_function_from_rlib)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -v __imp_ | grep -c public_rust_function_from_exe)\" -eq \"0\" ]\n \n \n \t# Check the combined case, where we generate a cdylib and an rlib in the same\n \t# compilation session:\n \t# Check that a cdylib exports its public #[no_mangle] functions\n-\t[ \"$$($(NM) $(TMPDIR)/$(COMBINED_CDYLIB_NAME) | grep -c public_c_function_from_cdylib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(COMBINED_CDYLIB_NAME) | grep -v __imp_ | grep -c public_c_function_from_cdylib)\" -eq \"1\" ]\n \t# Check that a cdylib exports the public #[no_mangle] functions of dependencies\n-\t[ \"$$($(NM) $(TMPDIR)/$(COMBINED_CDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(COMBINED_CDYLIB_NAME) | grep -v __imp_ | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n \t# Check that a cdylib DOES NOT export any public Rust functions\n-\t[ \"$$($(NM) $(TMPDIR)/$(COMBINED_CDYLIB_NAME) | grep -c $(RE_ANY_RUST_SYMBOL))\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(COMBINED_CDYLIB_NAME) | grep -v __imp_ | grep -c $(RE_ANY_RUST_SYMBOL))\" -eq \"0\" ]\n \n \n \t$(RUSTC) -Zshare-generics=yes an_rlib.rs\n@@ -70,22 +75,22 @@ all:\n \t$(RUSTC) -Zshare-generics=yes an_executable.rs\n \n \t# Check that a cdylib exports its public #[no_mangle] functions\n-\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c public_c_function_from_cdylib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -v __imp_ | grep -c public_c_function_from_cdylib)\" -eq \"1\" ]\n \t# Check that a cdylib exports the public #[no_mangle] functions of dependencies\n-\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -v __imp_ | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n \t# Check that a cdylib DOES NOT export any public Rust functions\n-\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c $(RE_ANY_RUST_SYMBOL))\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -v __imp_ | grep -c $(RE_ANY_RUST_SYMBOL))\" -eq \"0\" ]\n \n \t# Check that a Rust dylib exports its monomorphic functions, including generics this time\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rust_dylib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rust_dylib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rust_dylib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -v __imp_ | grep -c public_c_function_from_rust_dylib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -v __imp_ | grep -c public_rust_function_from_rust_dylib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -v __imp_ | grep -c public_generic_function_from_rust_dylib)\" -eq \"1\" ]\n \n \t# Check that a Rust dylib exports the monomorphic functions from its dependencies\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rlib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rlib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -v __imp_ | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -v __imp_ | grep -c public_rust_function_from_rlib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -v __imp_ | grep -c public_generic_function_from_rlib)\" -eq \"1\" ]\n \n \t# Check that an executable does not export any dynamic symbols\n-\t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -c public_c_function_from_rlib)\" -eq \"0\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -c public_rust_function_from_exe)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -v __imp_ | grep -c public_c_function_from_rlib)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -v __imp_ | grep -c public_rust_function_from_exe)\" -eq \"0\" ]"}, {"sha": "1effa46e101eba906e392f2dd535ce3a1cf8353d", "filename": "src/test/run-make-fulldeps/tools.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -150,7 +150,7 @@ ifdef IS_MSVC\n \t$(CC) $< -link -dll -out:`cygpath -w $@`\n else\n %.dll: lib%.o\n-\t$(CC) -o $@ $< -shared\n+\t$(CC) -o $@ $< -shared -Wl,--out-implib=$@.a\n endif\n \n $(TMPDIR)/lib%.o: %.c"}, {"sha": "4d904472931ece12732a5a3e31b4684dbb0e6d0a", "filename": "src/test/run-make-fulldeps/used/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Fused%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make-fulldeps%2Fused%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fused%2FMakefile?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -1,6 +1,6 @@\n -include ../tools.mk\n \n-# ignore-windows\n+# ignore-windows-msvc\n \n all:\n \t$(RUSTC) -C opt-level=3 --emit=obj used.rs"}, {"sha": "96b17af46dfe9179a2474f957856966628d70ae0", "filename": "src/test/run-make/static-pie/test-aslr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make%2Fstatic-pie%2Ftest-aslr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frun-make%2Fstatic-pie%2Ftest-aslr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstatic-pie%2Ftest-aslr.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -29,7 +29,7 @@ fn main() {\n         }\n         Some(s) if s.eq(\"--test-aslr\") => {\n             let cnt = run_self(&arg0);\n-            if cnt != NUM_RUNS {\n+            if cnt == 1 {\n                 eprintln!(\"FAIL: {} most likely no ASLR\", arg0);\n                 std::process::exit(1);\n             }"}, {"sha": "65187f48539a4e8967e12f0c9ce92138de6ca6ec", "filename": "src/test/rustdoc/intra-doc-link-mod-ambiguity.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frustdoc%2Fintra-doc-link-mod-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Frustdoc%2Fintra-doc-link-mod-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-link-mod-ambiguity.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -0,0 +1,18 @@\n+// ignore-tidy-linelength\n+\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+\n+pub fn foo() {\n+\n+}\n+\n+pub mod foo {}\n+// @has intra_doc_link_mod_ambiguity/struct.A.html '//a/@href' '../intra_doc_link_mod_ambiguity/foo/index.html'\n+/// Module is [`module@foo`]\n+pub struct A;\n+\n+\n+// @has intra_doc_link_mod_ambiguity/struct.B.html '//a/@href' '../intra_doc_link_mod_ambiguity/fn.foo.html'\n+/// Function is [`fn@foo`]\n+pub struct B;"}, {"sha": "fbf20b9db67415434e49cdb1313922b870846efe", "filename": "src/test/ui/consts/const-option.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fui%2Fconsts%2Fconst-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fui%2Fconsts%2Fconst-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-option.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+\n+#![feature(const_option)]\n+\n+const X: Option<i32> = Some(32);\n+const Y: Option<&i32> = X.as_ref();\n+\n+const IS_SOME: bool = X.is_some();\n+const IS_NONE: bool = Y.is_none();\n+\n+fn main() {\n+    assert!(IS_SOME);\n+    assert!(!IS_NONE)\n+}"}, {"sha": "df1c99e8671e8ad894d39cddbd447c457f3d12c2", "filename": "src/test/ui/lazy_normalization_consts/trait-resolution-breakage.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fui%2Flazy_normalization_consts%2Ftrait-resolution-breakage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fui%2Flazy_normalization_consts%2Ftrait-resolution-breakage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy_normalization_consts%2Ftrait-resolution-breakage.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+trait Trait<T> {\n+    const ASSOC_CONST: usize = 0;\n+}\n+\n+impl Trait<()> for u8 {}\n+\n+// `u8::ASSOC_CONST` is resolved today, but will be ambiguous\n+// under lazy normalization.\n+fn foo<T, U>() -> [(T, U); u8::ASSOC_CONST]\n+where\n+    u8: Trait<T> + Trait<U>,\n+{\n+    todo!()\n+}\n+\n+fn main() {}"}, {"sha": "3f90d22ae2d221f1d4cf1592d92717c0e391f0f6", "filename": "src/test/ui/lazy_normalization_consts/unevaluated-consts.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fui%2Flazy_normalization_consts%2Funevaluated-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fui%2Flazy_normalization_consts%2Funevaluated-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy_normalization_consts%2Funevaluated-consts.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+// If we allow the parent generics here without using lazy normalization\n+// this results in a cycle error.\n+struct Foo<T, U>(T, U);\n+\n+impl<T> From<[u8; 1 + 1]> for Foo<T, [u8; 1 + 1]> {\n+    fn from(value: [u8; 1 + 1]) -> Foo<T, [u8; 1 + 1]> {\n+        todo!();\n+    }\n+}\n+\n+fn break_me<T>()\n+where\n+    [u8; 1 + 1]: From<[u8; 1 + 1]>\n+{}\n+\n+fn main() {}"}, {"sha": "78d3060886dd0e73cf33b5ab38af8b239570aed9", "filename": "src/test/ui/lint/uninitialized-zeroed.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -23,6 +23,18 @@ enum WrapEnum<T> { Wrapped(T) }\n #[repr(transparent)]\n pub(crate) struct NonBig(u64);\n \n+/// A two-variant enum, thus needs a tag and may not remain uninitialized.\n+enum Fruit {\n+    Apple,\n+    Banana,\n+}\n+\n+/// Looks like two variants but really only has one.\n+enum OneFruit {\n+    Apple(!),\n+    Banana,\n+}\n+\n #[allow(unused)]\n fn generic<T: 'static>() {\n     unsafe {\n@@ -80,6 +92,9 @@ fn main() {\n         let _val: NonBig = mem::zeroed();\n         let _val: NonBig = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: Fruit = mem::zeroed();\n+        let _val: Fruit = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         // Transmute-from-0\n         let _val: &'static i32 = mem::transmute(0usize); //~ ERROR: does not permit zero-initialization\n         let _val: &'static [i32] = mem::transmute((0usize, 0usize)); //~ ERROR: does not permit zero-initialization\n@@ -96,5 +111,9 @@ fn main() {\n         let _val: MaybeUninit<&'static i32> = mem::zeroed();\n         let _val: i32 = mem::zeroed();\n         let _val: bool = MaybeUninit::zeroed().assume_init();\n+        // Some things that happen to work due to rustc implementation details,\n+        // but are not guaranteed to keep working.\n+        let _val: i32 = mem::uninitialized();\n+        let _val: OneFruit = mem::uninitialized();\n     }\n }"}, {"sha": "3bf8a66ab0ae5268c2f4035de4eed89d32ee050e", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 54, "deletions": 36, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -1,5 +1,5 @@\n error: the type `&T` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:29:32\n+  --> $DIR/uninitialized-zeroed.rs:41:32\n    |\n LL |         let _val: &'static T = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -15,7 +15,7 @@ LL | #![deny(invalid_value)]\n    = note: references must be non-null\n \n error: the type `&T` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:30:32\n+  --> $DIR/uninitialized-zeroed.rs:42:32\n    |\n LL |         let _val: &'static T = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |         let _val: &'static T = mem::uninitialized();\n    = note: references must be non-null\n \n error: the type `Wrap<&T>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:32:38\n+  --> $DIR/uninitialized-zeroed.rs:44:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      ^^^^^^^^^^^^^\n@@ -41,7 +41,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<&T>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:33:38\n+  --> $DIR/uninitialized-zeroed.rs:45:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n@@ -56,7 +56,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `!` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:40:23\n+  --> $DIR/uninitialized-zeroed.rs:52:23\n    |\n LL |         let _val: ! = mem::zeroed();\n    |                       ^^^^^^^^^^^^^\n@@ -67,7 +67,7 @@ LL |         let _val: ! = mem::zeroed();\n    = note: the `!` type has no valid value\n \n error: the type `!` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:41:23\n+  --> $DIR/uninitialized-zeroed.rs:53:23\n    |\n LL |         let _val: ! = mem::uninitialized();\n    |                       ^^^^^^^^^^^^^^^^^^^^\n@@ -78,7 +78,7 @@ LL |         let _val: ! = mem::uninitialized();\n    = note: the `!` type has no valid value\n \n error: the type `(i32, !)` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:43:30\n+  --> $DIR/uninitialized-zeroed.rs:55:30\n    |\n LL |         let _val: (i32, !) = mem::zeroed();\n    |                              ^^^^^^^^^^^^^\n@@ -89,7 +89,7 @@ LL |         let _val: (i32, !) = mem::zeroed();\n    = note: the `!` type has no valid value\n \n error: the type `(i32, !)` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:44:30\n+  --> $DIR/uninitialized-zeroed.rs:56:30\n    |\n LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              ^^^^^^^^^^^^^^^^^^^^\n@@ -100,7 +100,7 @@ LL |         let _val: (i32, !) = mem::uninitialized();\n    = note: the `!` type has no valid value\n \n error: the type `Void` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:46:26\n+  --> $DIR/uninitialized-zeroed.rs:58:26\n    |\n LL |         let _val: Void = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -111,7 +111,7 @@ LL |         let _val: Void = mem::zeroed();\n    = note: enums with no variants have no valid value\n \n error: the type `Void` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:47:26\n+  --> $DIR/uninitialized-zeroed.rs:59:26\n    |\n LL |         let _val: Void = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -122,7 +122,7 @@ LL |         let _val: Void = mem::uninitialized();\n    = note: enums with no variants have no valid value\n \n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:49:34\n+  --> $DIR/uninitialized-zeroed.rs:61:34\n    |\n LL |         let _val: &'static i32 = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -133,7 +133,7 @@ LL |         let _val: &'static i32 = mem::zeroed();\n    = note: references must be non-null\n \n error: the type `&i32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:50:34\n+  --> $DIR/uninitialized-zeroed.rs:62:34\n    |\n LL |         let _val: &'static i32 = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -144,7 +144,7 @@ LL |         let _val: &'static i32 = mem::uninitialized();\n    = note: references must be non-null\n \n error: the type `Ref` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:52:25\n+  --> $DIR/uninitialized-zeroed.rs:64:25\n    |\n LL |         let _val: Ref = mem::zeroed();\n    |                         ^^^^^^^^^^^^^\n@@ -159,7 +159,7 @@ LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `Ref` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:53:25\n+  --> $DIR/uninitialized-zeroed.rs:65:25\n    |\n LL |         let _val: Ref = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -174,7 +174,7 @@ LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `fn()` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:55:26\n+  --> $DIR/uninitialized-zeroed.rs:67:26\n    |\n LL |         let _val: fn() = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -185,7 +185,7 @@ LL |         let _val: fn() = mem::zeroed();\n    = note: function pointers must be non-null\n \n error: the type `fn()` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:56:26\n+  --> $DIR/uninitialized-zeroed.rs:68:26\n    |\n LL |         let _val: fn() = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -196,7 +196,7 @@ LL |         let _val: fn() = mem::uninitialized();\n    = note: function pointers must be non-null\n \n error: the type `Wrap<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:58:32\n+  --> $DIR/uninitialized-zeroed.rs:70:32\n    |\n LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -211,7 +211,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:59:32\n+  --> $DIR/uninitialized-zeroed.rs:71:32\n    |\n LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -226,7 +226,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `WrapEnum<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:61:36\n+  --> $DIR/uninitialized-zeroed.rs:73:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n@@ -241,7 +241,7 @@ LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `WrapEnum<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:62:36\n+  --> $DIR/uninitialized-zeroed.rs:74:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n@@ -256,7 +256,7 @@ LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:64:42\n+  --> $DIR/uninitialized-zeroed.rs:76:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          ^^^^^^^^^^^^^\n@@ -271,7 +271,7 @@ LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:65:42\n+  --> $DIR/uninitialized-zeroed.rs:77:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          ^^^^^^^^^^^^^^^^^^^^\n@@ -286,7 +286,7 @@ LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `std::ptr::NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:67:34\n+  --> $DIR/uninitialized-zeroed.rs:79:34\n    |\n LL |         let _val: NonNull<i32> = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -297,7 +297,7 @@ LL |         let _val: NonNull<i32> = mem::zeroed();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `std::ptr::NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:68:34\n+  --> $DIR/uninitialized-zeroed.rs:80:34\n    |\n LL |         let _val: NonNull<i32> = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -308,7 +308,7 @@ LL |         let _val: NonNull<i32> = mem::uninitialized();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `*const dyn std::marker::Send` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:70:37\n+  --> $DIR/uninitialized-zeroed.rs:82:37\n    |\n LL |         let _val: *const dyn Send = mem::zeroed();\n    |                                     ^^^^^^^^^^^^^\n@@ -319,7 +319,7 @@ LL |         let _val: *const dyn Send = mem::zeroed();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `*const dyn std::marker::Send` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:71:37\n+  --> $DIR/uninitialized-zeroed.rs:83:37\n    |\n LL |         let _val: *const dyn Send = mem::uninitialized();\n    |                                     ^^^^^^^^^^^^^^^^^^^^\n@@ -330,7 +330,7 @@ LL |         let _val: *const dyn Send = mem::uninitialized();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:75:26\n+  --> $DIR/uninitialized-zeroed.rs:87:26\n    |\n LL |         let _val: bool = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -341,7 +341,7 @@ LL |         let _val: bool = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `Wrap<char>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:78:32\n+  --> $DIR/uninitialized-zeroed.rs:90:32\n    |\n LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -356,7 +356,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `NonBig` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:81:28\n+  --> $DIR/uninitialized-zeroed.rs:93:28\n    |\n LL |         let _val: NonBig = mem::uninitialized();\n    |                            ^^^^^^^^^^^^^^^^^^^^\n@@ -366,8 +366,26 @@ LL |         let _val: NonBig = mem::uninitialized();\n    |\n    = note: `NonBig` must be initialized inside its custom valid range\n \n+error: the type `Fruit` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:96:27\n+   |\n+LL |         let _val: Fruit = mem::uninitialized();\n+   |                           ^^^^^^^^^^^^^^^^^^^^\n+   |                           |\n+   |                           this code causes undefined behavior when executed\n+   |                           help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: enums have to be initialized to a variant\n+  --> $DIR/uninitialized-zeroed.rs:27:1\n+   |\n+LL | / enum Fruit {\n+LL | |     Apple,\n+LL | |     Banana,\n+LL | | }\n+   | |_^\n+\n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:84:34\n+  --> $DIR/uninitialized-zeroed.rs:99:34\n    |\n LL |         let _val: &'static i32 = mem::transmute(0usize);\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n@@ -378,7 +396,7 @@ LL |         let _val: &'static i32 = mem::transmute(0usize);\n    = note: references must be non-null\n \n error: the type `&[i32]` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:85:36\n+  --> $DIR/uninitialized-zeroed.rs:100:36\n    |\n LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -389,7 +407,7 @@ LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    = note: references must be non-null\n \n error: the type `std::num::NonZeroU32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:86:32\n+  --> $DIR/uninitialized-zeroed.rs:101:32\n    |\n LL |         let _val: NonZeroU32 = mem::transmute(0);\n    |                                ^^^^^^^^^^^^^^^^^\n@@ -400,7 +418,7 @@ LL |         let _val: NonZeroU32 = mem::transmute(0);\n    = note: `std::num::NonZeroU32` must be non-null\n \n error: the type `std::ptr::NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:89:34\n+  --> $DIR/uninitialized-zeroed.rs:104:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -411,7 +429,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `std::ptr::NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:90:34\n+  --> $DIR/uninitialized-zeroed.rs:105:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -422,7 +440,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:91:26\n+  --> $DIR/uninitialized-zeroed.rs:106:26\n    |\n LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -432,5 +450,5 @@ LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |\n    = note: booleans must be either `true` or `false`\n \n-error: aborting due to 35 previous errors\n+error: aborting due to 36 previous errors\n "}, {"sha": "d6e28e93c96676aaf5ba632d17916e40d06c4b2f", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -867,6 +867,7 @@ impl Config {\n             &self.target == name ||                             // triple\n             util::matches_os(&self.target, name) ||             // target\n             util::matches_env(&self.target, name) ||            // env\n+            self.target.ends_with(name) ||                      // target and env\n             name == util::get_arch(&self.target) ||             // architecture\n             name == util::get_pointer_width(&self.target) ||    // pointer width\n             name == self.stage_id.split('-').next().unwrap() || // stage"}, {"sha": "470fab496a442fa6dc65328896c3af6713d7593b", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "patch": "@@ -119,6 +119,7 @@ fn contains_ignore_directive(can_contain: bool, contents: &str, check: &str) ->\n     // Update `can_contain` when changing this\n     if contents.contains(&format!(\"// ignore-tidy-{}\", check))\n         || contents.contains(&format!(\"# ignore-tidy-{}\", check))\n+        || contents.contains(&format!(\"/* ignore-tidy-{} */\", check))\n     {\n         Directive::Ignore(false)\n     } else {\n@@ -136,15 +137,37 @@ macro_rules! suppressible_tidy_err {\n     };\n }\n \n+pub fn is_in(full_path: &Path, parent_folder_to_find: &str, folder_to_find: &str) -> bool {\n+    if let Some(parent) = full_path.parent() {\n+        if parent.file_name().map_or_else(\n+            || false,\n+            |f| {\n+                f.to_string_lossy() == folder_to_find\n+                    && parent\n+                        .parent()\n+                        .and_then(|f| f.file_name())\n+                        .map_or_else(|| false, |f| f == parent_folder_to_find)\n+            },\n+        ) {\n+            true\n+        } else {\n+            is_in(parent, parent_folder_to_find, folder_to_find)\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n pub fn check(path: &Path, bad: &mut bool) {\n     super::walk(path, &mut super::filter_dirs, &mut |entry, contents| {\n         let file = entry.path();\n         let filename = file.file_name().unwrap().to_string_lossy();\n-        let extensions = [\".rs\", \".py\", \".js\", \".sh\", \".c\", \".cpp\", \".h\", \".md\"];\n+        let extensions = [\".rs\", \".py\", \".js\", \".sh\", \".c\", \".cpp\", \".h\", \".md\", \".css\"];\n         if extensions.iter().all(|e| !filename.ends_with(e)) || filename.starts_with(\".#\") {\n             return;\n         }\n \n+        let is_style_file = filename.ends_with(\".css\");\n         let under_rustfmt = filename.ends_with(\".rs\") &&\n             // This list should ideally be sourced from rustfmt.toml but we don't want to add a toml\n             // parser to tidy.\n@@ -161,6 +184,10 @@ pub fn check(path: &Path, bad: &mut bool) {\n             // currently), just the long error code explanation ones.\n             return;\n         }\n+        if is_style_file && !is_in(file, \"src\", \"librustdoc\") {\n+            // We only check CSS files in rustdoc.\n+            return;\n+        }\n \n         if contents.is_empty() {\n             tidy_error!(bad, \"{}: empty file\", file.display());\n@@ -172,8 +199,9 @@ pub fn check(path: &Path, bad: &mut bool) {\n             COLS\n         };\n \n-        let can_contain =\n-            contents.contains(\"// ignore-tidy-\") || contents.contains(\"# ignore-tidy-\");\n+        let can_contain = contents.contains(\"// ignore-tidy-\")\n+            || contents.contains(\"# ignore-tidy-\")\n+            || contents.contains(\"/* ignore-tidy-\");\n         // Enable testing ICE's that require specific (untidy)\n         // file formats easily eg. `issue-1234-ignore-tidy.rs`\n         if filename.contains(\"ignore-tidy\") {\n@@ -208,12 +236,15 @@ pub fn check(path: &Path, bad: &mut bool) {\n                     &format!(\"line longer than {} chars\", max_columns)\n                 );\n             }\n-            if line.contains('\\t') {\n+            if !is_style_file && line.contains('\\t') {\n                 suppressible_tidy_err!(err, skip_tab, \"tab character\");\n             }\n             if line.ends_with(' ') || line.ends_with('\\t') {\n                 suppressible_tidy_err!(err, skip_end_whitespace, \"trailing whitespace\");\n             }\n+            if is_style_file && line.starts_with(' ') {\n+                err(\"CSS files use tabs for indent\");\n+            }\n             if line.contains('\\r') {\n                 suppressible_tidy_err!(err, skip_cr, \"CR character\");\n             }"}]}