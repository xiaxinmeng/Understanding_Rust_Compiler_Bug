{"sha": "79efed84a006620c6e4596088074f7ff195580fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZWZlZDg0YTAwNjYyMGM2ZTQ1OTYwODgwNzRmN2ZmMTk1NTgwZmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-15T21:28:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-01-02T22:35:05Z"}, "message": "remove wrapper functions that had no purpose", "tree": {"sha": "97d6247486c75fe1af86eddead127a40644602ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97d6247486c75fe1af86eddead127a40644602ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79efed84a006620c6e4596088074f7ff195580fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79efed84a006620c6e4596088074f7ff195580fe", "html_url": "https://github.com/rust-lang/rust/commit/79efed84a006620c6e4596088074f7ff195580fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79efed84a006620c6e4596088074f7ff195580fe/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f0fe8f093555c9f435dcb8ec0dfa6552ef0e492", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f0fe8f093555c9f435dcb8ec0dfa6552ef0e492", "html_url": "https://github.com/rust-lang/rust/commit/5f0fe8f093555c9f435dcb8ec0dfa6552ef0e492"}], "stats": {"total": 93, "additions": 37, "deletions": 56}, "files": [{"sha": "e7c01df3dca0a952c8e9f6a906b9c90f94bf3246", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 37, "deletions": 56, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/79efed84a006620c6e4596088074f7ff195580fe/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79efed84a006620c6e4596088074f7ff195580fe/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=79efed84a006620c6e4596088074f7ff195580fe", "patch": "@@ -29,8 +29,7 @@ use super::{\n \n use dep_graph::{DepKind, DepNodeIndex};\n use hir::def_id::DefId;\n-use infer;\n-use infer::{InferCtxt, InferOk, TypeFreshener};\n+use infer::{self, InferCtxt, InferOk, TypeFreshener};\n use middle::lang_items;\n use mir::interpret::GlobalId;\n use ty::fast_reject;\n@@ -531,24 +530,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n \n-    /// Wraps the inference context's in_snapshot s.t. snapshot handling is only from the selection\n-    /// context's self.\n-    fn in_snapshot<R, F>(&mut self, f: F) -> R\n-    where\n-        F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> R,\n-    {\n-        self.infcx.in_snapshot(|snapshot| f(self, snapshot))\n-    }\n-\n-    /// Wraps a probe s.t. obligations collected during it are ignored and old obligations are\n-    /// retained.\n-    fn probe<R, F>(&mut self, f: F) -> R\n-    where\n-        F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> R,\n-    {\n-        self.infcx.probe(|snapshot| f(self, snapshot))\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // Selection\n     //\n@@ -630,8 +611,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         &mut self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        self.probe(|this, _| {\n-            this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n+        self.infcx.probe(|_| {\n+            self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n         })\n     }\n \n@@ -1066,10 +1047,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             \"evaluate_candidate: depth={} candidate={:?}\",\n             stack.obligation.recursion_depth, candidate\n         );\n-        let result = self.probe(|this, _| {\n+        let result = self.infcx.probe(|_| {\n             let candidate = (*candidate).clone();\n-            match this.confirm_candidate(stack.obligation, candidate) {\n-                Ok(selection) => this.evaluate_predicates_recursively(\n+            match self.confirm_candidate(stack.obligation, candidate) {\n+                Ok(selection) => self.evaluate_predicates_recursively(\n                     stack.list(),\n                     selection.nested_obligations().iter(),\n                 ),\n@@ -1697,8 +1678,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             _ => return,\n         }\n \n-        let result = self.probe(|this, snapshot| {\n-            this.match_projection_obligation_against_definition_bounds(obligation, snapshot)\n+        let result = self.infcx.probe(|snapshot| {\n+            self.match_projection_obligation_against_definition_bounds(obligation, snapshot)\n         });\n \n         if result {\n@@ -1750,8 +1731,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let matching_bound = util::elaborate_predicates(self.tcx(), bounds.predicates)\n             .filter_to_traits()\n             .find(|bound| {\n-                self.probe(|this, _| {\n-                    this.match_projection(\n+                self.infcx.probe(|_| {\n+                    self.match_projection(\n                         obligation,\n                         bound.clone(),\n                         skol_trait_predicate.trait_ref.clone(),\n@@ -1853,10 +1834,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         stack: &TraitObligationStack<'o, 'tcx>,\n         where_clause_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        self.probe(move |this, _| {\n-            match this.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n+        self.infcx.probe(|_| {\n+            match self.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n-                    this.evaluate_predicates_recursively(stack.list(), obligations.iter())\n+                    self.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n                 Err(()) => Ok(EvaluatedToErr),\n             }\n@@ -2006,8 +1987,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             obligation.predicate.def_id(),\n             obligation.predicate.skip_binder().trait_ref.self_ty(),\n             |impl_def_id| {\n-                self.probe(|this, snapshot| {\n-                    if let Ok(placeholder_map) = this.match_impl(impl_def_id, obligation, snapshot)\n+                self.infcx.probe(|snapshot| {\n+                    if let Ok(placeholder_map) = self.match_impl(impl_def_id, obligation, snapshot)\n                     {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n \n@@ -2084,11 +2065,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             obligation.self_ty().skip_binder()\n         );\n \n-        self.probe(|this, _snapshot| {\n+        self.infcx.probe(|_snapshot| {\n             // The code below doesn't care about regions, and the\n             // self-ty here doesn't escape this probe, so just erase\n             // any LBR.\n-            let self_ty = this.tcx().erase_late_bound_regions(&obligation.self_ty());\n+            let self_ty = self.tcx().erase_late_bound_regions(&obligation.self_ty());\n             let poly_trait_ref = match self_ty.sty {\n                 ty::Dynamic(ref data, ..) => {\n                     if data.auto_traits()\n@@ -2102,7 +2083,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         return;\n                     }\n \n-                    data.principal().with_self_ty(this.tcx(), self_ty)\n+                    data.principal().with_self_ty(self.tcx(), self_ty)\n                 }\n                 ty::Infer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n@@ -2122,11 +2103,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // correct trait, but also the correct type parameters.\n             // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n             // but `Foo` is declared as `trait Foo : Bar<u32>`.\n-            let upcast_trait_refs = util::supertraits(this.tcx(), poly_trait_ref)\n+            let upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n                 .filter(|upcast_trait_ref| {\n-                    this.probe(|this, _| {\n+                    self.infcx.probe(|_| {\n                         let upcast_trait_ref = upcast_trait_ref.clone();\n-                        this.match_poly_trait_ref(obligation, upcast_trait_ref)\n+                        self.match_poly_trait_ref(obligation, upcast_trait_ref)\n                             .is_ok()\n                     })\n                 })\n@@ -2671,20 +2652,20 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // binder moved -\\\n                 let ty: ty::Binder<Ty<'tcx>> = ty::Binder::bind(ty); // <----/\n \n-                self.in_snapshot(|this, snapshot| {\n-                    let (skol_ty, placeholder_map) = this.infcx()\n+                self.infcx.in_snapshot(|snapshot| {\n+                    let (skol_ty, placeholder_map) = self.infcx\n                         .replace_bound_vars_with_placeholders(&ty);\n                     let Normalized {\n                         value: normalized_ty,\n                         mut obligations,\n                     } = project::normalize_with_depth(\n-                        this,\n+                        self,\n                         param_env,\n                         cause.clone(),\n                         recursion_depth,\n                         &skol_ty,\n                     );\n-                    let skol_obligation = this.tcx().predicate_for_trait_def(\n+                    let skol_obligation = self.tcx().predicate_for_trait_def(\n                         param_env,\n                         cause.clone(),\n                         trait_def_id,\n@@ -2693,7 +2674,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         &[],\n                     );\n                     obligations.push(skol_obligation);\n-                    this.infcx()\n+                    self.infcx\n                         .plug_leaks(placeholder_map, snapshot, obligations)\n                 })\n             })\n@@ -2785,9 +2766,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn confirm_projection_candidate(&mut self, obligation: &TraitObligation<'tcx>) {\n-        self.in_snapshot(|this, snapshot| {\n+        self.infcx.in_snapshot(|snapshot| {\n             let result =\n-                this.match_projection_obligation_against_definition_bounds(obligation, snapshot);\n+                self.match_projection_obligation_against_definition_bounds(obligation, snapshot);\n             assert!(result);\n         })\n     }\n@@ -2904,12 +2885,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             nested,\n         );\n \n-        let trait_obligations: Vec<PredicateObligation<'_>> = self.in_snapshot(|this, snapshot| {\n+        let trait_obligations: Vec<PredicateObligation<'_>> = self.infcx.in_snapshot(|snapshot| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-            let (trait_ref, placeholder_map) = this.infcx()\n+            let (trait_ref, placeholder_map) = self.infcx\n                 .replace_bound_vars_with_placeholders(&poly_trait_ref);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n-            this.impl_or_trait_obligations(\n+            self.impl_or_trait_obligations(\n                 cause,\n                 obligation.recursion_depth + 1,\n                 obligation.param_env,\n@@ -2941,11 +2922,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.in_snapshot(|this, snapshot| {\n-            let (substs, placeholder_map) = this.rematch_impl(impl_def_id, obligation, snapshot);\n+        self.infcx.in_snapshot(|snapshot| {\n+            let (substs, placeholder_map) = self.rematch_impl(impl_def_id, obligation, snapshot);\n             debug!(\"confirm_impl_candidate: substs={:?}\", substs);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n-            this.vtable_impl(\n+            self.vtable_impl(\n                 impl_def_id,\n                 substs,\n                 cause,\n@@ -3108,14 +3089,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             obligation, alias_def_id\n         );\n \n-        self.in_snapshot(|this, snapshot| {\n-            let (predicate, placeholder_map) = this.infcx()\n+        self.infcx.in_snapshot(|snapshot| {\n+            let (predicate, placeholder_map) = self.infcx\n                 .replace_bound_vars_with_placeholders(&obligation.predicate);\n             let trait_ref = predicate.trait_ref;\n             let trait_def_id = trait_ref.def_id;\n             let substs = trait_ref.substs;\n \n-            let trait_obligations = this.impl_or_trait_obligations(\n+            let trait_obligations = self.impl_or_trait_obligations(\n                 obligation.cause.clone(),\n                 obligation.recursion_depth,\n                 obligation.param_env,"}]}