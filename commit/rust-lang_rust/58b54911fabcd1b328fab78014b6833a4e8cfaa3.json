{"sha": "58b54911fabcd1b328fab78014b6833a4e8cfaa3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4YjU0OTExZmFiY2QxYjMyOGZhYjc4MDE0YjY4MzNhNGU4Y2ZhYTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-10T15:40:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-10T15:40:39Z"}, "message": "Auto merge of #59546 - sfanxiang:interminable-ub, r=nagisa\n\nAdd llvm.sideeffect to potential infinite loops and recursions\n\nLLVM assumes that a thread will eventually cause side effect. This is\nnot true in Rust if a loop or recursion does nothing in its body,\ncausing undefined behavior even in common cases like `loop {}`.\nInserting llvm.sideeffect fixes the undefined behavior.\n\nAs a micro-optimization, only insert llvm.sideeffect when jumping back\nin blocks or calling a function.\n\nA patch for LLVM is expected to allow empty non-terminate code by\ndefault and fix this issue from LLVM side.\n\nhttps://github.com/rust-lang/rust/issues/28728\n\n**UPDATE:** [Mentoring instructions here](https://github.com/rust-lang/rust/pull/59546#issuecomment-515072429) to unstall this PR", "tree": {"sha": "6f621f3f837f3fb915cccf5d47d6c768b07472d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f621f3f837f3fb915cccf5d47d6c768b07472d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58b54911fabcd1b328fab78014b6833a4e8cfaa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58b54911fabcd1b328fab78014b6833a4e8cfaa3", "html_url": "https://github.com/rust-lang/rust/commit/58b54911fabcd1b328fab78014b6833a4e8cfaa3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58b54911fabcd1b328fab78014b6833a4e8cfaa3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c588c1e2391c20c156814f7ae118f62e96a3976", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c588c1e2391c20c156814f7ae118f62e96a3976", "html_url": "https://github.com/rust-lang/rust/commit/9c588c1e2391c20c156814f7ae118f62e96a3976"}, {"sha": "e9acfa306f47a40be27e8cf72c55dbec35d94017", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9acfa306f47a40be27e8cf72c55dbec35d94017", "html_url": "https://github.com/rust-lang/rust/commit/e9acfa306f47a40be27e8cf72c55dbec35d94017"}], "stats": {"total": 108, "additions": 107, "deletions": 1}, "files": [{"sha": "25e68e6408de2893f84d5bf087c10d4ad983c00a", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=58b54911fabcd1b328fab78014b6833a4e8cfaa3", "patch": "@@ -1467,6 +1467,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"which mangling version to use for symbol names\"),\n     binary_dep_depinfo: bool = (false, parse_bool, [TRACKED],\n         \"include artifacts (sysroot, crate dependencies) used during compilation in dep-info\"),\n+    insert_sideeffect: bool = (false, parse_bool, [TRACKED],\n+        \"fix undefined behavior when a thread doesn't eventually make progress \\\n+         (such as entering an empty infinite loop) by inserting llvm.sideeffect\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "7ca226914a5a40dba903c59cca89c1769478bdef", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=58b54911fabcd1b328fab78014b6833a4e8cfaa3", "patch": "@@ -537,6 +537,7 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.trap\", fn() -> void);\n         ifn!(\"llvm.debugtrap\", fn() -> void);\n         ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);\n+        ifn!(\"llvm.sideeffect\", fn() -> void);\n \n         ifn!(\"llvm.powi.f32\", fn(t_f32, t_i32) -> t_f32);\n         ifn!(\"llvm.powi.v2f32\", fn(t_v2f32, t_i32) -> t_v2f32);"}, {"sha": "68d9af09c42b1f2f194f1c6168d98d696e195224", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=58b54911fabcd1b328fab78014b6833a4e8cfaa3", "patch": "@@ -724,6 +724,13 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call(expect, &[cond, self.const_bool(expected)], None)\n     }\n \n+    fn sideeffect(&mut self) {\n+        if self.tcx.sess.opts.debugging_opts.insert_sideeffect {\n+            let fnname = self.get_intrinsic(&(\"llvm.sideeffect\"));\n+            self.call(fnname, &[], None);\n+        }\n+    }\n+\n     fn va_start(&mut self, va_list: &'ll Value) -> &'ll Value {\n         let intrinsic = self.cx().get_intrinsic(\"llvm.va_start\");\n         self.call(intrinsic, &[va_list], None)\n@@ -810,6 +817,7 @@ fn codegen_msvc_try(\n ) {\n     let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n         bx.set_personality_fn(bx.eh_personality());\n+        bx.sideeffect();\n \n         let mut normal = bx.build_sibling_block(\"normal\");\n         let mut catchswitch = bx.build_sibling_block(\"catchswitch\");\n@@ -933,6 +941,8 @@ fn codegen_gnu_try(\n         // expected to be `*mut *mut u8` for this to actually work, but that's\n         // managed by the standard library.\n \n+        bx.sideeffect();\n+\n         let mut then = bx.build_sibling_block(\"then\");\n         let mut catch = bx.build_sibling_block(\"catch\");\n "}, {"sha": "b0df81ba1abea0a5b40688ddca34dc3d8792932a", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=58b54911fabcd1b328fab78014b6833a4e8cfaa3", "patch": "@@ -149,6 +149,26 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    // Generate sideeffect intrinsic if jumping to any of the targets can form\n+    // a loop.\n+    fn maybe_sideeffect<'b, 'tcx2: 'b, Bx: BuilderMethods<'b, 'tcx2>>(\n+        &self,\n+        mir: &'b mir::Body<'tcx>,\n+        bx: &mut Bx,\n+        targets: &[mir::BasicBlock],\n+    ) {\n+        if bx.tcx().sess.opts.debugging_opts.insert_sideeffect {\n+            if targets.iter().any(|target| {\n+                *target <= *self.bb\n+                    && target\n+                        .start_location()\n+                        .is_predecessor_of(self.bb.start_location(), mir)\n+            }) {\n+                bx.sideeffect();\n+            }\n+        }\n+    }\n }\n \n /// Codegen implementations for some terminator variants.\n@@ -197,6 +217,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let lltrue = helper.llblock(self, targets[0]);\n             let llfalse = helper.llblock(self, targets[1]);\n             if switch_ty == bx.tcx().types.bool {\n+                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n                 // Don't generate trivial icmps when switching on bool\n                 if let [0] = values[..] {\n                     bx.cond_br(discr.immediate(), llfalse, lltrue);\n@@ -210,9 +231,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 );\n                 let llval = bx.const_uint_big(switch_llty, values[0]);\n                 let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n+                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n                 bx.cond_br(cmp, lltrue, llfalse);\n             }\n         } else {\n+            helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n             let (otherwise, targets) = targets.split_last().unwrap();\n             bx.switch(\n                 discr.immediate(),\n@@ -308,6 +331,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n             // we don't actually need to drop anything.\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return\n         }\n@@ -338,6 +362,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                  FnType::of_instance(&bx, drop_fn))\n             }\n         };\n+        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         helper.do_call(self, &mut bx, fn_ty, drop_fn, args,\n                        Some((ReturnDest::Nothing, target)),\n                        unwind);\n@@ -373,6 +398,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Don't codegen the panic block if success if known.\n         if const_cond == Some(expected) {\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n@@ -383,6 +409,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Create the failure block and the conditional branch to it.\n         let lltarget = helper.llblock(self, target);\n         let panic_block = self.new_block(\"panic\");\n+        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block.llbb());\n         } else {\n@@ -486,6 +513,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             if let Some(destination_ref) = destination.as_ref() {\n                 let &(ref dest, target) = destination_ref;\n                 self.codegen_transmute(&mut bx, &args[0], dest);\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             } else {\n                 // If we are trying to transmute to an uninhabited type,\n@@ -513,6 +541,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             Some(ty::InstanceDef::DropGlue(_, None)) => {\n                 // Empty drop glue; a no-op.\n                 let &(_, target) = destination.as_ref().unwrap();\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n                 return;\n             }\n@@ -549,6 +578,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let fn_ty = FnType::of_instance(&bx, instance);\n                 let llfn = bx.get_fn(instance);\n \n+                if let Some((_, target)) = destination.as_ref() {\n+                    helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n+                }\n                 // Codegen the actual panic invoke/call.\n                 helper.do_call(\n                     self,\n@@ -561,7 +593,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 );\n             } else {\n                 // a NOP\n-                helper.funclet_br(self, &mut bx, destination.as_ref().unwrap().1)\n+                let target = destination.as_ref().unwrap().1;\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                helper.funclet_br(self, &mut bx, target);\n             }\n             return;\n         }\n@@ -670,6 +704,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             if let Some((_, target)) = *destination {\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             } else {\n                 bx.unreachable();\n@@ -762,6 +797,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             _ => span_bug!(span, \"no llfn for call\"),\n         };\n \n+        if let Some((_, target)) = destination.as_ref() {\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n+        }\n         helper.do_call(self, &mut bx, fn_ty, fn_ptr, &llargs,\n                        destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n                        cleanup);\n@@ -811,6 +849,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             }\n "}, {"sha": "d5612d7b072a63bd2726e90b950e3e65006a37e3", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=58b54911fabcd1b328fab78014b6833a4e8cfaa3", "patch": "@@ -200,6 +200,8 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         bx.set_personality_fn(cx.eh_personality());\n     }\n \n+    bx.sideeffect();\n+\n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it."}, {"sha": "2c484084c4a20e063bc0c67d51423501b16eb787", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=58b54911fabcd1b328fab78014b6833a4e8cfaa3", "patch": "@@ -20,6 +20,7 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     fn abort(&mut self);\n     fn assume(&mut self, val: Self::Value);\n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value;\n+    fn sideeffect(&mut self);\n     /// Trait method used to inject `va_start` on the \"spoofed\" `VaListImpl` in\n     /// Rust defined C-variadic functions.\n     fn va_start(&mut self, val: Self::Value) -> Self::Value;"}, {"sha": "56b360e0a7f4883ceff22ed802b83d46a95557c4", "filename": "src/test/codegen/non-terminate/infinite-loop-1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-1.rs?ref=58b54911fabcd1b328fab78014b6833a4e8cfaa3", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -C opt-level=3 -Z insert-sideeffect\n+\n+#![crate_type = \"lib\"]\n+\n+fn infinite_loop() -> u8 {\n+    loop {}\n+}\n+\n+// CHECK-LABEL: @test\n+#[no_mangle]\n+fn test() -> u8 {\n+    // CHECK-NOT: unreachable\n+    // CHECK: br label %{{.+}}\n+    // CHECK-NOT: unreachable\n+    let x = infinite_loop();\n+    x\n+}"}, {"sha": "2921ab6dc04af460d4cdc5629de2233bddd7bb58", "filename": "src/test/codegen/non-terminate/infinite-loop-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-2.rs?ref=58b54911fabcd1b328fab78014b6833a4e8cfaa3", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -C opt-level=3 -Z insert-sideeffect\n+\n+#![crate_type = \"lib\"]\n+\n+fn infinite_loop() -> u8 {\n+    let i = 2;\n+    while i > 1 {}\n+    1\n+}\n+\n+// CHECK-LABEL: @test\n+#[no_mangle]\n+fn test() -> u8 {\n+    // CHECK-NOT: unreachable\n+    // CHECK: br label %{{.+}}\n+    // CHECK-NOT: unreachable\n+    let x = infinite_loop();\n+    x\n+}"}, {"sha": "1f292ce379fc0ea8032fb84d056040af6c156712", "filename": "src/test/codegen/non-terminate/infinite-recursion.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b54911fabcd1b328fab78014b6833a4e8cfaa3/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-recursion.rs?ref=58b54911fabcd1b328fab78014b6833a4e8cfaa3", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -C opt-level=3 -Z insert-sideeffect\n+\n+#![crate_type = \"lib\"]\n+\n+#![allow(unconditional_recursion)]\n+\n+// CHECK-LABEL: @infinite_recursion\n+#[no_mangle]\n+fn infinite_recursion() -> u8 {\n+    // CHECK-NOT: ret i8 undef\n+    // CHECK: br label %{{.+}}\n+    // CHECK-NOT: ret i8 undef\n+    infinite_recursion()\n+}"}]}