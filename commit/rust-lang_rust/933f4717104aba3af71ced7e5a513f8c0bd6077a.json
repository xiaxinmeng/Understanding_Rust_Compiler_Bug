{"sha": "933f4717104aba3af71ced7e5a513f8c0bd6077a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzM2Y0NzE3MTA0YWJhM2FmNzFjZWQ3ZTVhNTEzZjhjMGJkNjA3N2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-01T18:56:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-01T18:56:51Z"}, "message": "Auto merge of #34494 - CensoredUsername:allow_sysV64_abi, r=nagisa\n\nAllow specification of the system V AMD64 ABI constraint.\n\nThis can be specified using `extern \"sysV64\" fn` on all platforms.\n\nThis ABI is used as the C ABI on unix platforms, but can only be specified there using extern \"C\". It was impossible to specify on other platforms. Meanwhile the win64 ABI, which was the extern \"C\" ABI on the windows platform could be specified on other platforms using extern \"win64\".\n\nThis pull request adds the the \"sysV64\" ABI constraint which exposes this calling convention on platforms where it is not the C ABI.", "tree": {"sha": "6a90d940e178680a5678c9fd92b0c92b4702bfb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a90d940e178680a5678c9fd92b0c92b4702bfb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/933f4717104aba3af71ced7e5a513f8c0bd6077a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/933f4717104aba3af71ced7e5a513f8c0bd6077a", "html_url": "https://github.com/rust-lang/rust/commit/933f4717104aba3af71ced7e5a513f8c0bd6077a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/933f4717104aba3af71ced7e5a513f8c0bd6077a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "147371f58f1a99e32524d61af1d86b2e1e0a503b", "url": "https://api.github.com/repos/rust-lang/rust/commits/147371f58f1a99e32524d61af1d86b2e1e0a503b", "html_url": "https://github.com/rust-lang/rust/commit/147371f58f1a99e32524d61af1d86b2e1e0a503b"}, {"sha": "3d766a077944f167dbd412538af4c6957943374d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d766a077944f167dbd412538af4c6957943374d", "html_url": "https://github.com/rust-lang/rust/commit/3d766a077944f167dbd412538af4c6957943374d"}], "stats": {"total": 528, "additions": 519, "deletions": 9}, "files": [{"sha": "1dea15311ce82aacf15cf2835318202778bc0ac6", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=933f4717104aba3af71ced7e5a513f8c0bd6077a", "patch": "@@ -539,6 +539,7 @@ This is currently hidden behind the `abi_vectorcall` gate and is subject to chan\n * `system`\n * `C`\n * `win64`\n+* `sysv64`\n \n Most of the abis in this list are self-explanatory, but the `system` abi may\n seem a little odd. This constraint selects whatever the appropriate ABI is for"}, {"sha": "ec2d3e2822e2062891f8c337293fbe7dc8f7899f", "filename": "src/doc/reference.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=933f4717104aba3af71ced7e5a513f8c0bd6077a", "patch": "@@ -1677,6 +1677,7 @@ There are also some platform-specific ABI strings:\n * `extern \"cdecl\"` -- The default for x86\\_32 C code.\n * `extern \"stdcall\"` -- The default for the Win32 API on x86\\_32.\n * `extern \"win64\"` -- The default for C code on x86\\_64 Windows.\n+* `extern \"sysv64\"` -- The default for C code on non-Windows x86\\_64.\n * `extern \"aapcs\"` -- The default for ARM.\n * `extern \"fastcall\"` -- The `fastcall` ABI -- corresponds to MSVC's\n   `__fastcall` and GCC and clang's `__attribute__((fastcall))`\n@@ -2485,6 +2486,9 @@ The currently implemented features of the reference compiler are:\n \n * - `dotdot_in_tuple_patterns` - Allows `..` in tuple (struct) patterns.\n \n+* - `abi_sysv64` - Allows the usage of the system V AMD64 calling convention\n+                             (e.g. `extern \"sysv64\" func fn_();`)\n+\n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled\n the new feature (because the directive is no longer necessary). However, if a"}, {"sha": "92fe568a72c578f553fc65e4b0299ce051fba5be", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=933f4717104aba3af71ced7e5a513f8c0bd6077a", "patch": "@@ -42,6 +42,7 @@ pub enum CallConv {\n     ColdCallConv = 9,\n     X86StdcallCallConv = 64,\n     X86FastcallCallConv = 65,\n+    X86_64_SysV = 78,\n     X86_64_Win64 = 79,\n     X86_VectorCall = 80\n }"}, {"sha": "7f209dde27db963179b306ad7ec4ddcb146ba2f3", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=933f4717104aba3af71ced7e5a513f8c0bd6077a", "patch": "@@ -269,6 +269,7 @@ impl FnType {\n             Vectorcall => llvm::X86_VectorCall,\n             C => llvm::CCallConv,\n             Win64 => llvm::X86_64_Win64,\n+            SysV64 => llvm::X86_64_SysV,\n \n             // These API constants ought to be more specific...\n             Cdecl => llvm::CCallConv,\n@@ -483,7 +484,9 @@ impl FnType {\n \n         match &ccx.sess().target.target.arch[..] {\n             \"x86\" => cabi_x86::compute_abi_info(ccx, self),\n-            \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n+            \"x86_64\" => if abi == Abi::SysV64 {\n+                cabi_x86_64::compute_abi_info(ccx, self);\n+            } else if abi == Abi::Win64 || ccx.sess().target.target.options.is_like_windows {\n                 cabi_x86_win64::compute_abi_info(ccx, self);\n             } else {\n                 cabi_x86_64::compute_abi_info(ccx, self);"}, {"sha": "64a71133a8c0235aadf0a94f68be2e45288630b8", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=933f4717104aba3af71ced7e5a513f8c0bd6077a", "patch": "@@ -39,6 +39,7 @@ pub enum Abi {\n     Vectorcall,\n     Aapcs,\n     Win64,\n+    SysV64,\n \n     // Multiplatform ABIs second\n     Rust,\n@@ -86,6 +87,7 @@ const AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: Abi::Vectorcall, name: \"vectorcall\"},\n     AbiData {abi: Abi::Aapcs, name: \"aapcs\" },\n     AbiData {abi: Abi::Win64, name: \"win64\" },\n+    AbiData {abi: Abi::SysV64, name: \"sysv64\" },\n \n     // Cross-platform ABIs\n     //"}, {"sha": "e224e30b1a2a4bb89db3dd52c4f5ff93816d6bd5", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=933f4717104aba3af71ced7e5a513f8c0bd6077a", "patch": "@@ -281,7 +281,11 @@ declare_features! (\n     (active, never_type, \"1.13.0\", Some(35121)),\n \n     // Allows all literals in attribute lists and values of key-value pairs.\n-    (active, attr_literals, \"1.13.0\", Some(34981))\n+    (active, attr_literals, \"1.13.0\", Some(34981)),\n+\n+    // Allows the sysV64 ABI to be specified on all platforms\n+    // instead of just the platforms on which it is the C ABI\n+    (active, abi_sysv64, \"1.13.0\", Some(36167))\n );\n \n declare_features! (\n@@ -811,21 +815,26 @@ macro_rules! gate_feature_post {\n impl<'a> PostExpansionVisitor<'a> {\n     fn check_abi(&self, abi: Abi, span: Span) {\n         match abi {\n-            Abi::RustIntrinsic =>\n+            Abi::RustIntrinsic => {\n                 gate_feature_post!(&self, intrinsics, span,\n-                                   \"intrinsics are subject to change\"),\n+                                   \"intrinsics are subject to change\");\n+            },\n             Abi::PlatformIntrinsic => {\n                 gate_feature_post!(&self, platform_intrinsics, span,\n-                                   \"platform intrinsics are experimental and possibly buggy\")\n+                                   \"platform intrinsics are experimental and possibly buggy\");\n             },\n             Abi::Vectorcall => {\n                 gate_feature_post!(&self, abi_vectorcall, span,\n-                                   \"vectorcall is experimental and subject to change\")\n-            }\n+                                   \"vectorcall is experimental and subject to change\");\n+            },\n             Abi::RustCall => {\n                 gate_feature_post!(&self, unboxed_closures, span,\n                                    \"rust-call ABI is subject to change\");\n-            }\n+            },\n+            Abi::SysV64 => {\n+                gate_feature_post!(&self, abi_sysv64, span,\n+                                   \"sysv64 ABI is experimental and subject to change\");\n+            },\n             _ => {}\n         }\n     }"}, {"sha": "2b8e8a1b6b2c79437ff0134c5f8972d1142d6048", "filename": "src/test/codegen/abi-sysv64.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Ftest%2Fcodegen%2Fabi-sysv64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Ftest%2Fcodegen%2Fabi-sysv64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fabi-sysv64.rs?ref=933f4717104aba3af71ced7e5a513f8c0bd6077a", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks if the correct annotation for the sysv64 ABI is passed to\n+// llvm. Also checks that the abi-sysv64 feature gate allows usage\n+// of the sysv64 abi.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+#![feature(abi_sysv64)]\n+\n+// CHECK: define x86_64_sysvcc i64 @has_sysv64_abi\n+#[no_mangle]\n+pub extern \"sysv64\" fn has_sysv64_abi(a: i64) -> i64 {\n+    a * 2\n+}"}, {"sha": "2a4aae8c06bbadda9c05782135ea9e4805e2d8a4", "filename": "src/test/compile-fail/feature-gate-abi-sysv64.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Ftest%2Fcompile-fail%2Ffeature-gate-abi-sysv64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Ftest%2Fcompile-fail%2Ffeature-gate-abi-sysv64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-abi-sysv64.rs?ref=933f4717104aba3af71ced7e5a513f8c0bd6077a", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the sysv64 ABI cannot be used when abi-sysv64 feature\n+// gate is not used.\n+\n+extern \"sysv64\" fn foo() {}\n+//~^ ERROR sysv64 ABI is experimental and subject to change\n+\n+fn main() {\n+    foo();\n+}"}, {"sha": "989155bdfd98bb7bc67610bb9a516487390c4f65", "filename": "src/test/run-pass/abi-sysv64-arg-passing.rs", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Ftest%2Frun-pass%2Fabi-sysv64-arg-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Ftest%2Frun-pass%2Fabi-sysv64-arg-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fabi-sysv64-arg-passing.rs?ref=933f4717104aba3af71ced7e5a513f8c0bd6077a", "patch": "@@ -0,0 +1,341 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks if the \"sysv64\" calling convention behaves the same as the\n+// \"C\" calling convention on platforms where both should be the same\n+\n+// This file contains versions of the following run-pass tests with\n+// the calling convention changed to \"sysv64\"\n+\n+// cabi-int-widening\n+// extern-pass-char\n+// extern-pass-u32\n+// extern-pass-u64\n+// extern-pass-double\n+// extern-pass-empty\n+// extern-pass-TwoU8s\n+// extern-pass-TwoU16s\n+// extern-pass-TwoU32s\n+// extern-pass-TwoU64s\n+// extern-return-TwoU8s\n+// extern-return-TwoU16s\n+// extern-return-TwoU32s\n+// extern-return-TwoU64s\n+// foreign-fn-with-byval\n+// issue-28676\n+// struct-return\n+\n+// ignore-android\n+// ignore-arm\n+// ignore-aarch64\n+// ignore-windows\n+\n+// note: windows is ignored as rust_test_helpers does not have the sysv64 abi on windows\n+\n+#![feature(abi_sysv64)]\n+#[allow(dead_code)]\n+#[allow(improper_ctypes)]\n+\n+#[cfg(target_arch = \"x86_64\")]\n+mod tests {\n+    #[repr(C)]\n+    #[derive(Copy, Clone, PartialEq, Debug)]\n+    pub struct TwoU8s {\n+        one: u8, two: u8\n+    }\n+\n+    #[repr(C)]\n+    #[derive(Copy, Clone, PartialEq, Debug)]\n+    pub struct TwoU16s {\n+        one: u16, two: u16\n+    }\n+\n+    #[repr(C)]\n+    #[derive(Copy, Clone, PartialEq, Debug)]\n+    pub struct TwoU32s {\n+        one: u32, two: u32\n+    }\n+\n+    #[repr(C)]\n+    #[derive(Copy, Clone, PartialEq, Debug)]\n+    pub struct TwoU64s {\n+        one: u64, two: u64\n+    }\n+\n+    #[repr(C)]\n+    pub struct ManyInts {\n+        arg1: i8,\n+        arg2: i16,\n+        arg3: i32,\n+        arg4: i16,\n+        arg5: i8,\n+        arg6: TwoU8s,\n+    }\n+\n+    #[repr(C)]\n+    pub struct Empty;\n+\n+    #[repr(C)]\n+    #[derive(Copy, Clone)]\n+    pub struct S {\n+        x: u64,\n+        y: u64,\n+        z: u64,\n+    }\n+\n+    #[repr(C)]\n+    #[derive(Copy, Clone)]\n+    pub struct Quad { a: u64, b: u64, c: u64, d: u64 }\n+\n+    #[repr(C)]\n+    #[derive(Copy, Clone)]\n+    pub struct Floats { a: f64, b: u8, c: f64 }\n+\n+    #[link(name = \"rust_test_helpers\")]\n+    extern \"sysv64\" {\n+        pub fn rust_int8_to_int32(_: i8) -> i32;\n+        pub fn rust_dbg_extern_identity_u8(v: u8) -> u8;\n+        pub fn rust_dbg_extern_identity_u32(v: u32) -> u32;\n+        pub fn rust_dbg_extern_identity_u64(v: u64) -> u64;\n+        pub fn rust_dbg_extern_identity_double(v: f64) -> f64;\n+        pub fn rust_dbg_extern_empty_struct(v1: ManyInts, e: Empty, v2: ManyInts);\n+        pub fn rust_dbg_extern_identity_TwoU8s(v: TwoU8s) -> TwoU8s;\n+        pub fn rust_dbg_extern_identity_TwoU16s(v: TwoU16s) -> TwoU16s;\n+        pub fn rust_dbg_extern_identity_TwoU32s(v: TwoU32s) -> TwoU32s;\n+        pub fn rust_dbg_extern_identity_TwoU64s(v: TwoU64s) -> TwoU64s;\n+        pub fn rust_dbg_extern_return_TwoU8s() -> TwoU8s;\n+        pub fn rust_dbg_extern_return_TwoU16s() -> TwoU16s;\n+        pub fn rust_dbg_extern_return_TwoU32s() -> TwoU32s;\n+        pub fn rust_dbg_extern_return_TwoU64s() -> TwoU64s;\n+        pub fn get_x(x: S) -> u64;\n+        pub fn get_y(x: S) -> u64;\n+        pub fn get_z(x: S) -> u64;\n+        pub fn get_c_many_params(_: *const (), _: *const (),\n+                                 _: *const (), _: *const (), f: Quad) -> u64;\n+        pub fn rust_dbg_abi_1(q: Quad) -> Quad;\n+        pub fn rust_dbg_abi_2(f: Floats) -> Floats;\n+    }\n+\n+    pub fn cabi_int_widening() {\n+        let x = unsafe {\n+            rust_int8_to_int32(-1)\n+        };\n+\n+        assert!(x == -1);\n+    }\n+\n+    pub fn extern_pass_char() {\n+        unsafe {\n+            assert_eq!(22, rust_dbg_extern_identity_u8(22));\n+        }\n+    }\n+\n+    pub fn extern_pass_u32() {\n+        unsafe {\n+            assert_eq!(22, rust_dbg_extern_identity_u32(22));\n+        }\n+    }\n+\n+    pub fn extern_pass_u64() {\n+        unsafe {\n+            assert_eq!(22, rust_dbg_extern_identity_u64(22));\n+        }\n+    }\n+\n+    pub fn extern_pass_double() {\n+        unsafe {\n+            assert_eq!(22.0_f64, rust_dbg_extern_identity_double(22.0_f64));\n+        }\n+    }\n+\n+    pub fn extern_pass_empty() {\n+        unsafe {\n+            let x = ManyInts {\n+                arg1: 2,\n+                arg2: 3,\n+                arg3: 4,\n+                arg4: 5,\n+                arg5: 6,\n+                arg6: TwoU8s { one: 7, two: 8, }\n+            };\n+            let y = ManyInts {\n+                arg1: 1,\n+                arg2: 2,\n+                arg3: 3,\n+                arg4: 4,\n+                arg5: 5,\n+                arg6: TwoU8s { one: 6, two: 7, }\n+            };\n+            let empty = Empty;\n+            rust_dbg_extern_empty_struct(x, empty, y);\n+        }\n+    }\n+\n+    pub fn extern_pass_twou8s() {\n+        unsafe {\n+            let x = TwoU8s {one: 22, two: 23};\n+            let y = rust_dbg_extern_identity_TwoU8s(x);\n+            assert_eq!(x, y);\n+        }\n+    }\n+\n+    pub fn extern_pass_twou16s() {\n+        unsafe {\n+            let x = TwoU16s {one: 22, two: 23};\n+            let y = rust_dbg_extern_identity_TwoU16s(x);\n+            assert_eq!(x, y);\n+        }\n+    }\n+\n+    pub fn extern_pass_twou32s() {\n+        unsafe {\n+            let x = TwoU32s {one: 22, two: 23};\n+            let y = rust_dbg_extern_identity_TwoU32s(x);\n+            assert_eq!(x, y);\n+        }\n+    }\n+\n+    pub fn extern_pass_twou64s() {\n+        unsafe {\n+            let x = TwoU64s {one: 22, two: 23};\n+            let y = rust_dbg_extern_identity_TwoU64s(x);\n+            assert_eq!(x, y);\n+        }\n+    }\n+\n+    pub fn extern_return_twou8s() {\n+        unsafe {\n+            let y = rust_dbg_extern_return_TwoU8s();\n+            assert_eq!(y.one, 10);\n+            assert_eq!(y.two, 20);\n+        }\n+    }\n+\n+    pub fn extern_return_twou16s() {\n+        unsafe {\n+            let y = rust_dbg_extern_return_TwoU16s();\n+            assert_eq!(y.one, 10);\n+            assert_eq!(y.two, 20);\n+        }\n+    }\n+\n+    pub fn extern_return_twou32s() {\n+        unsafe {\n+            let y = rust_dbg_extern_return_TwoU32s();\n+            assert_eq!(y.one, 10);\n+            assert_eq!(y.two, 20);\n+        }\n+    }\n+\n+    pub fn extern_return_twou64s() {\n+        unsafe {\n+            let y = rust_dbg_extern_return_TwoU64s();\n+            assert_eq!(y.one, 10);\n+            assert_eq!(y.two, 20);\n+        }\n+    }\n+\n+    #[inline(never)]\n+    fn indirect_call(func: unsafe extern \"sysv64\" fn(s: S) -> u64, s: S) -> u64 {\n+        unsafe {\n+            func(s)\n+        }\n+    }\n+\n+    pub fn foreign_fn_with_byval() {\n+        let s = S { x: 1, y: 2, z: 3 };\n+        assert_eq!(s.x, indirect_call(get_x, s));\n+        assert_eq!(s.y, indirect_call(get_y, s));\n+        assert_eq!(s.z, indirect_call(get_z, s));\n+    }\n+\n+    fn test() {\n+        use std::ptr;\n+        unsafe {\n+            let null = ptr::null();\n+            let q = Quad {\n+                a: 1,\n+                b: 2,\n+                c: 3,\n+                d: 4\n+            };\n+            assert_eq!(get_c_many_params(null, null, null, null, q), q.c);\n+        }\n+    }\n+\n+    pub fn issue_28676() {\n+        test();\n+    }\n+\n+    fn test1() {\n+        unsafe {\n+            let q = Quad { a: 0xaaaa_aaaa_aaaa_aaaa,\n+                     b: 0xbbbb_bbbb_bbbb_bbbb,\n+                     c: 0xcccc_cccc_cccc_cccc,\n+                     d: 0xdddd_dddd_dddd_dddd };\n+            let qq = rust_dbg_abi_1(q);\n+            println!(\"a: {:x}\", qq.a as usize);\n+            println!(\"b: {:x}\", qq.b as usize);\n+            println!(\"c: {:x}\", qq.c as usize);\n+            println!(\"d: {:x}\", qq.d as usize);\n+            assert_eq!(qq.a, q.c + 1);\n+            assert_eq!(qq.b, q.d - 1);\n+            assert_eq!(qq.c, q.a + 1);\n+            assert_eq!(qq.d, q.b - 1);\n+        }\n+    }\n+\n+    fn test2() {\n+        unsafe {\n+            let f = Floats { a: 1.234567890e-15_f64,\n+                     b: 0b_1010_1010,\n+                     c: 1.0987654321e-15_f64 };\n+            let ff = rust_dbg_abi_2(f);\n+            println!(\"a: {}\", ff.a as f64);\n+            println!(\"b: {}\", ff.b as usize);\n+            println!(\"c: {}\", ff.c as f64);\n+            assert_eq!(ff.a, f.c + 1.0f64);\n+            assert_eq!(ff.b, 0xff);\n+            assert_eq!(ff.c, f.a - 1.0f64);\n+        }\n+    }\n+\n+    pub fn struct_return() {\n+        test1();\n+        test2();\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+fn main() {\n+    use tests::*;\n+    cabi_int_widening();\n+    extern_pass_char();\n+    extern_pass_u32();\n+    extern_pass_u64();\n+    extern_pass_double();\n+    extern_pass_empty();\n+    extern_pass_twou8s();\n+    extern_pass_twou16s();\n+    extern_pass_twou32s();\n+    extern_pass_twou64s();\n+    extern_return_twou8s();\n+    extern_return_twou16s();\n+    extern_return_twou32s();\n+    extern_return_twou64s();\n+    foreign_fn_with_byval();\n+    issue_28676();\n+    struct_return();\n+}\n+\n+#[cfg(not(target_arch = \"x86_64\"))]\n+fn main() {\n+\n+}"}, {"sha": "7e3b32122ac23a9d6db7366f08adb104d4629964", "filename": "src/test/run-pass/abi-sysv64-register-usage.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Ftest%2Frun-pass%2Fabi-sysv64-register-usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Ftest%2Frun-pass%2Fabi-sysv64-register-usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fabi-sysv64-register-usage.rs?ref=933f4717104aba3af71ced7e5a513f8c0bd6077a", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks if the correct registers are being used to pass arguments\n+// when the sysv64 ABI is specified.\n+\n+// ignore-android\n+// ignore-arm\n+// ignore-aarch64\n+\n+#![feature(abi_sysv64)]\n+#![feature(asm)]\n+\n+#[cfg(target_arch = \"x86_64\")]\n+pub extern \"sysv64\" fn all_the_registers(rdi: i64, rsi: i64, rdx: i64,\n+                                         rcx: i64, r8 : i64, r9 : i64,\n+                                         xmm0: f32, xmm1: f32, xmm2: f32,\n+                                         xmm3: f32, xmm4: f32, xmm5: f32,\n+                                         xmm6: f32, xmm7: f32) -> i64 {\n+    assert_eq!(rdi, 1);\n+    assert_eq!(rsi, 2);\n+    assert_eq!(rdx, 3);\n+    assert_eq!(rcx, 4);\n+    assert_eq!(r8,  5);\n+    assert_eq!(r9,  6);\n+    assert_eq!(xmm0, 1.0f32);\n+    assert_eq!(xmm1, 2.0f32);\n+    assert_eq!(xmm2, 4.0f32);\n+    assert_eq!(xmm3, 8.0f32);\n+    assert_eq!(xmm4, 16.0f32);\n+    assert_eq!(xmm5, 32.0f32);\n+    assert_eq!(xmm6, 64.0f32);\n+    assert_eq!(xmm7, 128.0f32);\n+    42\n+}\n+\n+// this struct contains 8 i64's, while only 6 can be passed in registers.\n+#[cfg(target_arch = \"x86_64\")]\n+#[derive(PartialEq, Eq, Debug)]\n+pub struct LargeStruct(i64, i64, i64, i64, i64, i64, i64, i64);\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[inline(never)]\n+pub extern \"sysv64\" fn large_struct_by_val(mut foo: LargeStruct) -> LargeStruct {\n+    foo.0 *= 1;\n+    foo.1 *= 2;\n+    foo.2 *= 3;\n+    foo.3 *= 4;\n+    foo.4 *= 5;\n+    foo.5 *= 6;\n+    foo.6 *= 7;\n+    foo.7 *= 8;\n+    foo\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+pub fn main() {\n+    let result: i64;\n+    unsafe {\n+        asm!(\"mov rdi, 1;\n+              mov rsi, 2;\n+              mov rdx, 3;\n+              mov rcx, 4;\n+              mov r8,  5;\n+              mov r9,  6;\n+              mov eax, 0x3F800000;\n+              movd xmm0, eax;\n+              mov eax, 0x40000000;\n+              movd xmm1, eax;\n+              mov eax, 0x40800000;\n+              movd xmm2, eax;\n+              mov eax, 0x41000000;\n+              movd xmm3, eax;\n+              mov eax, 0x41800000;\n+              movd xmm4, eax;\n+              mov eax, 0x42000000;\n+              movd xmm5, eax;\n+              mov eax, 0x42800000;\n+              movd xmm6, eax;\n+              mov eax, 0x43000000;\n+              movd xmm7, eax;\n+              call r10\n+              \"\n+            : \"={rax}\"(result)\n+            : \"{r10}\"(all_the_registers as usize)\n+            : \"rdi\", \"rsi\", \"rdx\", \"rcx\", \"r8\", \"r9\", \"r11\", \"cc\", \"memory\"\n+            : \"intel\", \"alignstack\"\n+        )\n+    }\n+    assert_eq!(result, 42);\n+\n+    assert_eq!(\n+        large_struct_by_val(LargeStruct(1, 2, 3, 4, 5, 6, 7, 8)),\n+        LargeStruct(1, 4, 9, 16, 25, 36, 49, 64)\n+    );\n+}\n+\n+#[cfg(not(target_arch = \"x86_64\"))]\n+pub fn main() {}\n\\ No newline at end of file"}, {"sha": "a748e13ecf102bf9207afbb3f409938f5549f278", "filename": "src/test/ui/codemap_tests/unicode.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/933f4717104aba3af71ced7e5a513f8c0bd6077a/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr?ref=933f4717104aba3af71ced7e5a513f8c0bd6077a", "patch": "@@ -1,4 +1,4 @@\n-error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n+error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n   --> $DIR/unicode.rs:11:8\n    |\n 11 | extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}"}]}