{"sha": "90449abcb30ed8b0fd1bab84f45630769f668247", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwNDQ5YWJjYjMwZWQ4YjBmZDFiYWI4NGY0NTYzMDc2OWY2NjgyNDc=", "commit": {"author": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2014-05-04T22:16:16Z"}, "committer": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2014-05-05T12:17:59Z"}, "message": "Adjust codegen logic for range and guarded arms\n\nBy carefully distinguishing falling back to the default arm from moving\non to the next pattern, this patch adjusts the codegen logic for range\nand guarded arms of pattern matching expression. It is a more\nappropriate way of fixing #12582 and #13027 without causing regressions\nsuch as #13867.\n\nCloses #13867", "tree": {"sha": "2f79c88226113a85a0980b3199d42ed08e42dd56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f79c88226113a85a0980b3199d42ed08e42dd56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90449abcb30ed8b0fd1bab84f45630769f668247", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90449abcb30ed8b0fd1bab84f45630769f668247", "html_url": "https://github.com/rust-lang/rust/commit/90449abcb30ed8b0fd1bab84f45630769f668247", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90449abcb30ed8b0fd1bab84f45630769f668247/comments", "author": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7adc48527fa0505a0cda6eaf1b6cafb01e434170", "url": "https://api.github.com/repos/rust-lang/rust/commits/7adc48527fa0505a0cda6eaf1b6cafb01e434170", "html_url": "https://github.com/rust-lang/rust/commit/7adc48527fa0505a0cda6eaf1b6cafb01e434170"}], "stats": {"total": 193, "additions": 154, "deletions": 39}, "files": [{"sha": "7206f3f03f5e6e3c6303d41e767818efe96d72b8", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 81, "deletions": 39, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/90449abcb30ed8b0fd1bab84f45630769f668247/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90449abcb30ed8b0fd1bab84f45630769f668247/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=90449abcb30ed8b0fd1bab84f45630769f668247", "patch": "@@ -526,7 +526,7 @@ fn enter_default<'a, 'b>(\n     // Collect all of the matches that can match against anything.\n     let matches = enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n-          ast::PatWild | ast::PatWildMulti | ast::PatTup(_) => Some(Vec::new()),\n+          ast::PatWild | ast::PatWildMulti => Some(Vec::new()),\n           ast::PatIdent(_, _, None) if pat_is_binding(dm, p) => Some(Vec::new()),\n           _ => None\n         }\n@@ -712,18 +712,7 @@ fn enter_opt<'a, 'b>(\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n-                // In most cases, a binding/wildcard match be\n-                // considered to match against any Opt. However, when\n-                // doing vector pattern matching, submatches are\n-                // considered even if the eventual match might be from\n-                // a different submatch. Thus, when a submatch fails\n-                // when doing a vector match, we proceed to the next\n-                // submatch. Thus, including a default match would\n-                // cause the default match to fire spuriously.\n-                match *opt {\n-                    vec_len(..) => None,\n-                    _ => Some(Vec::from_elem(variant_size, dummy))\n-                }\n+                Some(Vec::from_elem(variant_size, dummy))\n             }\n         };\n         i += 1;\n@@ -1363,7 +1352,8 @@ fn compile_guard<'a, 'b>(\n                  data: &ArmData,\n                  m: &'a [Match<'a, 'b>],\n                  vals: &[ValueRef],\n-                 chk: &FailureHandler)\n+                 chk: &FailureHandler,\n+                 has_genuine_default: bool)\n                  -> &'b Block<'b> {\n     debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n            bcx.to_str(),\n@@ -1394,7 +1384,17 @@ fn compile_guard<'a, 'b>(\n         // Guard does not match: free the values we copied,\n         // and remove all bindings from the lllocals table\n         let bcx = drop_bindings(bcx, data);\n-        compile_submatch(bcx, m, vals, chk);\n+        match chk {\n+            // If the default arm is the only one left, move on to the next\n+            // condition explicitly rather than (possibly) falling back to\n+            // the default arm.\n+            &JumpToBasicBlock(_) if m.len() == 1 && has_genuine_default => {\n+                Br(bcx, chk.handle_fail());\n+            }\n+            _ => {\n+                compile_submatch(bcx, m, vals, chk, has_genuine_default);\n+            }\n+        };\n         bcx\n     });\n \n@@ -1418,7 +1418,8 @@ fn compile_submatch<'a, 'b>(\n                     bcx: &'b Block<'b>,\n                     m: &'a [Match<'a, 'b>],\n                     vals: &[ValueRef],\n-                    chk: &FailureHandler) {\n+                    chk: &FailureHandler,\n+                    has_genuine_default: bool) {\n     debug!(\"compile_submatch(bcx={}, m={}, vals={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -1448,7 +1449,8 @@ fn compile_submatch<'a, 'b>(\n                                     m[0].data,\n                                     m.slice(1, m.len()),\n                                     vals,\n-                                    chk);\n+                                    chk,\n+                                    has_genuine_default);\n             }\n             _ => ()\n         }\n@@ -1466,9 +1468,10 @@ fn compile_submatch<'a, 'b>(\n                                   vals,\n                                   chk,\n                                   col,\n-                                  val)\n+                                  val,\n+                                  has_genuine_default)\n     } else {\n-        compile_submatch_continue(bcx, m, vals, chk, col, val)\n+        compile_submatch_continue(bcx, m, vals, chk, col, val, has_genuine_default)\n     }\n }\n \n@@ -1478,7 +1481,8 @@ fn compile_submatch_continue<'a, 'b>(\n                              vals: &[ValueRef],\n                              chk: &FailureHandler,\n                              col: uint,\n-                             val: ValueRef) {\n+                             val: ValueRef,\n+                             has_genuine_default: bool) {\n     let fcx = bcx.fcx;\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n@@ -1512,7 +1516,7 @@ fn compile_submatch_continue<'a, 'b>(\n                                             rec_fields.as_slice(),\n                                             val).as_slice(),\n                         rec_vals.append(vals_left.as_slice()).as_slice(),\n-                        chk);\n+                        chk, has_genuine_default);\n             });\n             return;\n         }\n@@ -1537,7 +1541,7 @@ fn compile_submatch_continue<'a, 'b>(\n                                    val,\n                                    n_tup_elts).as_slice(),\n                          tup_vals.append(vals_left.as_slice()).as_slice(),\n-                         chk);\n+                         chk, has_genuine_default);\n         return;\n     }\n \n@@ -1562,7 +1566,7 @@ fn compile_submatch_continue<'a, 'b>(\n                          enter_tuple_struct(bcx, dm, m, col, val,\n                                             struct_element_count).as_slice(),\n                          llstructvals.append(vals_left.as_slice()).as_slice(),\n-                         chk);\n+                         chk, has_genuine_default);\n         return;\n     }\n \n@@ -1571,7 +1575,7 @@ fn compile_submatch_continue<'a, 'b>(\n         compile_submatch(bcx,\n                          enter_uniq(bcx, dm, m, col, val).as_slice(),\n                          (vec!(llbox)).append(vals_left.as_slice()).as_slice(),\n-                         chk);\n+                         chk, has_genuine_default);\n         return;\n     }\n \n@@ -1580,7 +1584,7 @@ fn compile_submatch_continue<'a, 'b>(\n         compile_submatch(bcx,\n                          enter_region(bcx, dm, m, col, val).as_slice(),\n                          (vec!(loaded_val)).append(vals_left.as_slice()).as_slice(),\n-                         chk);\n+                         chk, has_genuine_default);\n         return;\n     }\n \n@@ -1637,9 +1641,9 @@ fn compile_submatch_continue<'a, 'b>(\n \n     // Compile subtrees for each option\n     for (i, opt) in opts.iter().enumerate() {\n-        // In some cases in vector pattern matching, we need to override\n-        // the failure case so that instead of failing, it proceeds to\n-        // try more matching. branch_chk, then, is the proper failure case\n+        // In some cases of range and vector pattern matching, we need to\n+        // override the failure case so that instead of failing, it proceeds\n+        // to try more matching. branch_chk, then, is the proper failure case\n         // for the current conditional branch.\n         let mut branch_chk = None;\n         let mut opt_cx = else_cx;\n@@ -1689,6 +1693,16 @@ fn compile_submatch_continue<'a, 'b>(\n                       }\n                   };\n                   bcx = fcx.new_temp_block(\"compare_next\");\n+\n+                  // If none of the sub-cases match, and the current condition\n+                  // is guarded or has multiple patterns, move on to the next\n+                  // condition, if there is any, rather than falling back to\n+                  // the default.\n+                  let guarded = m[i].data.arm.guard.is_some();\n+                  let multi_pats = m[i].pats.len() > 1;\n+                  if i+1 < len && (guarded || multi_pats) {\n+                      branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n+                  }\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n               compare_vec_len => {\n@@ -1726,8 +1740,10 @@ fn compile_submatch_continue<'a, 'b>(\n                   bcx = fcx.new_temp_block(\"compare_vec_len_next\");\n \n                   // If none of these subcases match, move on to the\n-                  // next condition.\n-                  branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n+                  // next condition if there is any.\n+                  if i+1 < len {\n+                      branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n+                  }\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n               _ => ()\n@@ -1767,27 +1783,38 @@ fn compile_submatch_continue<'a, 'b>(\n                 compile_submatch(opt_cx,\n                                  opt_ms.as_slice(),\n                                  opt_vals.as_slice(),\n-                                 chk)\n+                                 chk,\n+                                 has_genuine_default)\n             }\n             Some(branch_chk) => {\n                 compile_submatch(opt_cx,\n                                  opt_ms.as_slice(),\n                                  opt_vals.as_slice(),\n-                                 &branch_chk)\n+                                 &branch_chk,\n+                                 has_genuine_default)\n             }\n         }\n     }\n \n     // Compile the fall-through case, if any\n-    if !exhaustive {\n+    if !exhaustive && kind != single {\n         if kind == compare || kind == compare_vec_len {\n             Br(bcx, else_cx.llbb);\n         }\n-        if kind != single {\n-            compile_submatch(else_cx,\n-                             defaults.as_slice(),\n-                             vals_left.as_slice(),\n-                             chk);\n+        match chk {\n+            // If there is only one default arm left, move on to the next\n+            // condition explicitly rather than (eventually) falling back to\n+            // the last default arm.\n+            &JumpToBasicBlock(_) if defaults.len() == 1 && has_genuine_default => {\n+                Br(else_cx, chk.handle_fail());\n+            }\n+            _ => {\n+                compile_submatch(else_cx,\n+                                 defaults.as_slice(),\n+                                 vals_left.as_slice(),\n+                                 chk,\n+                                 has_genuine_default);\n+            }\n         }\n     }\n }\n@@ -1892,7 +1919,22 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         }));\n     }\n \n-    compile_submatch(bcx, matches.as_slice(), [discr_datum.val], &chk);\n+    // `compile_submatch` works one column of arm patterns a time and\n+    // then peels that column off. So as we progress, it may become\n+    // impossible to know whether we have a genuine default arm, i.e.\n+    // `_ => foo` or not. Sometimes it is important to know that in order\n+    // to decide whether moving on to the next condition or falling back\n+    // to the default arm.\n+    let has_default = arms.len() > 0 && {\n+        let ref pats = arms.last().unwrap().pats;\n+\n+        pats.len() == 1\n+        && match pats.last().unwrap().node {\n+            ast::PatWild => true, _ => false\n+        }\n+    };\n+\n+    compile_submatch(bcx, matches.as_slice(), [discr_datum.val], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in arm_datas.iter() {"}, {"sha": "fc3b1c7cb1ab24d620c683c8c42cbc8cd53aad16", "filename": "src/test/run-pass/issue-13027.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/90449abcb30ed8b0fd1bab84f45630769f668247/src%2Ftest%2Frun-pass%2Fissue-13027.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90449abcb30ed8b0fd1bab84f45630769f668247/src%2Ftest%2Frun-pass%2Fissue-13027.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13027.rs?ref=90449abcb30ed8b0fd1bab84f45630769f668247", "patch": "@@ -23,6 +23,7 @@ pub fn main() {\n     multi_pats_shadow_range();\n     lit_shadow_multi_pats();\n     range_shadow_multi_pats();\n+    misc();\n }\n \n fn lit_shadow_range() {\n@@ -168,3 +169,18 @@ fn range_shadow_multi_pats() {\n         _ => 3,\n     });\n }\n+\n+fn misc() {\n+    enum Foo {\n+        Bar(uint, bool)\n+    }\n+    // This test basically mimics how trace_macros! macro is implemented,\n+    // which is a rare combination of vector patterns, multiple wild-card\n+    // patterns and guard functions.\n+    let r = match [Bar(0, false)].as_slice() {\n+        [Bar(_, pred)] if pred => 1,\n+        [Bar(_, pred)] if !pred => 2,\n+        _ => 0,\n+    };\n+    assert_eq!(2, r);\n+}"}, {"sha": "fb76dbf2f6905af0dfd5aa111b63ef6ccb6236a1", "filename": "src/test/run-pass/issue-13867.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/90449abcb30ed8b0fd1bab84f45630769f668247/src%2Ftest%2Frun-pass%2Fissue-13867.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90449abcb30ed8b0fd1bab84f45630769f668247/src%2Ftest%2Frun-pass%2Fissue-13867.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13867.rs?ref=90449abcb30ed8b0fd1bab84f45630769f668247", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that codegen works correctly when there are multiple refutable\n+// patterns in match expression.\n+\n+enum Foo {\n+    FooUint(uint),\n+    FooNullary,\n+}\n+\n+fn main() {\n+    let r = match (FooNullary, 'a') {\n+        (FooUint(..), 'a'..'z') => 1,\n+        (FooNullary, 'x') => 2,\n+        _ => 0\n+    };\n+    assert_eq!(r, 0);\n+\n+    let r = match (FooUint(0), 'a') {\n+        (FooUint(1), 'a'..'z') => 1,\n+        (FooUint(..), 'x') => 2,\n+        (FooNullary, 'a') => 3,\n+        _ => 0\n+    };\n+    assert_eq!(r, 0);\n+\n+    let r = match ('a', FooUint(0)) {\n+        ('a'..'z', FooUint(1)) => 1,\n+        ('x', FooUint(..)) => 2,\n+        ('a', FooNullary) => 3,\n+        _ => 0\n+    };\n+    assert_eq!(r, 0);\n+\n+    let r = match ('a', 'a') {\n+        ('a'..'z', 'b') => 1,\n+        ('x', 'a'..'z') => 2,\n+        _ => 0\n+    };\n+    assert_eq!(r, 0);\n+\n+    let r = match ('a', 'a') {\n+        ('a'..'z', 'b') => 1,\n+        ('x', 'a'..'z') => 2,\n+        ('a', 'a') => 3,\n+        _ => 0\n+    };\n+    assert_eq!(r, 3);\n+}"}]}