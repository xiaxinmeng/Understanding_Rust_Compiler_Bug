{"sha": "6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875", "node_id": "C_kwDOAAsO6NoAKDZkYmQ5YTI5YzIxZGI2M2UyYzcyZjVlN2Y0ZjhiNWJhNTgwMjM4NzU", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-06-04T23:23:15Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-09-20T06:24:34Z"}, "message": "Optimize `array::IntoIter`\n\n`.into_iter()` on arrays was slower than it needed to be (especially compared to slice iterator) since it uses `Range<usize>`, which needs to handle degenerate ranges like `10..4`.\n\nThis PR adds an internal `IndexRange` type that's like `Range<usize>` but with a safety invariant that means it doesn't need to worry about those cases -- it only handles `start <= end` -- and thus can give LLVM more information to optimize better.\n\nI added one simple demonstration of the improvement as a codegen test.", "tree": {"sha": "983bdd8ac2914903d10871843668fa61cf28fdc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/983bdd8ac2914903d10871843668fa61cf28fdc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875", "html_url": "https://github.com/rust-lang/rust/commit/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c773c134c949661874d76313280e76cc3dd60975", "url": "https://api.github.com/repos/rust-lang/rust/commits/c773c134c949661874d76313280e76cc3dd60975", "html_url": "https://github.com/rust-lang/rust/commit/c773c134c949661874d76313280e76cc3dd60975"}], "stats": {"total": 313, "additions": 282, "deletions": 31}, "files": [{"sha": "b3b26040067185424a28641cabb7d7557a316aff", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875", "patch": "@@ -1,10 +1,10 @@\n //! Defines the `IntoIter` owned iterator for arrays.\n \n use crate::{\n-    cmp, fmt,\n+    fmt,\n     iter::{self, ExactSizeIterator, FusedIterator, TrustedLen},\n     mem::{self, MaybeUninit},\n-    ops::Range,\n+    ops::{IndexRange, Range},\n     ptr,\n };\n \n@@ -29,9 +29,10 @@ pub struct IntoIter<T, const N: usize> {\n     /// The elements in `data` that have not been yielded yet.\n     ///\n     /// Invariants:\n-    /// - `alive.start <= alive.end`\n     /// - `alive.end <= N`\n-    alive: Range<usize>,\n+    ///\n+    /// (And the `IndexRange` type requires `alive.start <= alive.end`.)\n+    alive: IndexRange,\n }\n \n // Note: the `#[rustc_skip_array_during_method_dispatch]` on `trait IntoIterator`\n@@ -69,7 +70,7 @@ impl<T, const N: usize> IntoIterator for [T; N] {\n         // Until then, we can use `mem::transmute_copy` to create a bitwise copy\n         // as a different type, then forget `array` so that it is not dropped.\n         unsafe {\n-            let iter = IntoIter { data: mem::transmute_copy(&self), alive: 0..N };\n+            let iter = IntoIter { data: mem::transmute_copy(&self), alive: IndexRange::zero_to(N) };\n             mem::forget(self);\n             iter\n         }\n@@ -147,7 +148,9 @@ impl<T, const N: usize> IntoIter<T, N> {\n         buffer: [MaybeUninit<T>; N],\n         initialized: Range<usize>,\n     ) -> Self {\n-        Self { data: buffer, alive: initialized }\n+        // SAFETY: one of our safety conditions is that the range is canonical.\n+        let alive = unsafe { IndexRange::new_unchecked(initialized.start, initialized.end) };\n+        Self { data: buffer, alive }\n     }\n \n     /// Creates an iterator over `T` which returns no elements.\n@@ -283,24 +286,19 @@ impl<T, const N: usize> Iterator for IntoIter<T, N> {\n     }\n \n     fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n-        let len = self.len();\n-\n-        // The number of elements to drop.  Always in-bounds by construction.\n-        let delta = cmp::min(n, len);\n-\n-        let range_to_drop = self.alive.start..(self.alive.start + delta);\n+        let original_len = self.len();\n \n-        // Moving the start marks them as conceptually \"dropped\", so if anything\n-        // goes bad then our drop impl won't double-free them.\n-        self.alive.start += delta;\n+        // This also moves the start, which marks them as conceptually \"dropped\",\n+        // so if anything goes bad then our drop impl won't double-free them.\n+        let range_to_drop = self.alive.take_prefix(n);\n \n         // SAFETY: These elements are currently initialized, so it's fine to drop them.\n         unsafe {\n             let slice = self.data.get_unchecked_mut(range_to_drop);\n             ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(slice));\n         }\n \n-        if n > len { Err(len) } else { Ok(()) }\n+        if n > original_len { Err(original_len) } else { Ok(()) }\n     }\n }\n \n@@ -338,24 +336,19 @@ impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, N> {\n     }\n \n     fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n-        let len = self.len();\n-\n-        // The number of elements to drop.  Always in-bounds by construction.\n-        let delta = cmp::min(n, len);\n-\n-        let range_to_drop = (self.alive.end - delta)..self.alive.end;\n+        let original_len = self.len();\n \n-        // Moving the end marks them as conceptually \"dropped\", so if anything\n-        // goes bad then our drop impl won't double-free them.\n-        self.alive.end -= delta;\n+        // This also moves the end, which marks them as conceptually \"dropped\",\n+        // so if anything goes bad then our drop impl won't double-free them.\n+        let range_to_drop = self.alive.take_suffix(n);\n \n         // SAFETY: These elements are currently initialized, so it's fine to drop them.\n         unsafe {\n             let slice = self.data.get_unchecked_mut(range_to_drop);\n             ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(slice));\n         }\n \n-        if n > len { Err(len) } else { Ok(()) }\n+        if n > original_len { Err(original_len) } else { Ok(()) }\n     }\n }\n \n@@ -372,9 +365,7 @@ impl<T, const N: usize> Drop for IntoIter<T, N> {\n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T, const N: usize> ExactSizeIterator for IntoIter<T, N> {\n     fn len(&self) -> usize {\n-        // Will never underflow due to the invariant `alive.start <=\n-        // alive.end`.\n-        self.alive.end - self.alive.start\n+        self.alive.len()\n     }\n     fn is_empty(&self) -> bool {\n         self.alive.is_empty()\n@@ -396,14 +387,15 @@ impl<T: Clone, const N: usize> Clone for IntoIter<T, N> {\n     fn clone(&self) -> Self {\n         // Note, we don't really need to match the exact same alive range, so\n         // we can just clone into offset 0 regardless of where `self` is.\n-        let mut new = Self { data: MaybeUninit::uninit_array(), alive: 0..0 };\n+        let mut new = Self { data: MaybeUninit::uninit_array(), alive: IndexRange::zero_to(0) };\n \n         // Clone all alive elements.\n         for (src, dst) in iter::zip(self.as_slice(), &mut new.data) {\n             // Write a clone into the new array, then update its alive range.\n             // If cloning panics, we'll correctly drop the previous items.\n             dst.write(src.clone());\n-            new.alive.end += 1;\n+            // This addition cannot overflow as we're iterating a slice\n+            new.alive = IndexRange::zero_to(new.alive.end() + 1);\n         }\n \n         new"}, {"sha": "9955ec2d52876aad26b0a427aa10e4be62c980f0", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875", "patch": "@@ -114,6 +114,7 @@\n #![feature(const_fmt_arguments_new)]\n #![feature(const_heap)]\n #![feature(const_convert)]\n+#![feature(const_index_range_slice_index)]\n #![feature(const_inherent_unchecked_arith)]\n #![feature(const_int_unchecked_arith)]\n #![feature(const_intrinsic_forget)]"}, {"sha": "41ffe11f610dd78c027487a59e8360c2317f9318", "filename": "library/core/src/ops/index_range.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs?ref=6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875", "patch": "@@ -0,0 +1,166 @@\n+use crate::intrinsics::{assert_unsafe_precondition, unchecked_add, unchecked_sub};\n+use crate::iter::{FusedIterator, TrustedLen};\n+\n+/// Like a `Range<usize>`, but with a safety invariant that `start <= end`.\n+///\n+/// This means that `end - start` cannot overflow, allowing some \u03bcoptimizations.\n+///\n+/// (Normal `Range` code needs to handle degenerate ranges like `10..0`,\n+///  which takes extra checks compared to only handling the canonical form.)\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) struct IndexRange {\n+    start: usize,\n+    end: usize,\n+}\n+\n+impl IndexRange {\n+    /// # Safety\n+    /// - `start <= end`\n+    #[inline]\n+    pub const unsafe fn new_unchecked(start: usize, end: usize) -> Self {\n+        // SAFETY: comparisons on usize are pure\n+        unsafe { assert_unsafe_precondition!((start: usize, end: usize) => start <= end) };\n+        IndexRange { start, end }\n+    }\n+\n+    #[inline]\n+    pub const fn zero_to(end: usize) -> Self {\n+        IndexRange { start: 0, end }\n+    }\n+\n+    #[inline]\n+    pub const fn start(&self) -> usize {\n+        self.start\n+    }\n+\n+    #[inline]\n+    pub const fn end(&self) -> usize {\n+        self.end\n+    }\n+\n+    #[inline]\n+    pub const fn len(&self) -> usize {\n+        // SAFETY: By invariant, this cannot wrap\n+        unsafe { unchecked_sub(self.end, self.start) }\n+    }\n+\n+    /// # Safety\n+    /// - Can only be called when `start < end`, aka when `len > 0`.\n+    #[inline]\n+    unsafe fn next_unchecked(&mut self) -> usize {\n+        debug_assert!(self.start < self.end);\n+\n+        let value = self.start;\n+        // SAFETY: The range isn't empty, so this cannot overflow\n+        self.start = unsafe { unchecked_add(value, 1) };\n+        value\n+    }\n+\n+    /// # Safety\n+    /// - Can only be called when `start < end`, aka when `len > 0`.\n+    #[inline]\n+    unsafe fn next_back_unchecked(&mut self) -> usize {\n+        debug_assert!(self.start < self.end);\n+\n+        // SAFETY: The range isn't empty, so this cannot overflow\n+        let value = unsafe { unchecked_sub(self.end, 1) };\n+        self.end = value;\n+        value\n+    }\n+\n+    /// Removes the first `n` items from this range, returning them as an `IndexRange`.\n+    /// If there are fewer than `n`, then the whole range is returned and\n+    /// `self` is left empty.\n+    ///\n+    /// This is designed to help implement `Iterator::advance_by`.\n+    #[inline]\n+    pub fn take_prefix(&mut self, n: usize) -> Self {\n+        let mid = if n <= self.len() {\n+            // SAFETY: We just checked that this will be between start and end,\n+            // and thus the addition cannot overflow.\n+            unsafe { unchecked_add(self.start, n) }\n+        } else {\n+            self.end\n+        };\n+        let prefix = Self { start: self.start, end: mid };\n+        self.start = mid;\n+        prefix\n+    }\n+\n+    /// Removes the last `n` items from this range, returning them as an `IndexRange`.\n+    /// If there are fewer than `n`, then the whole range is returned and\n+    /// `self` is left empty.\n+    ///\n+    /// This is designed to help implement `Iterator::advance_back_by`.\n+    #[inline]\n+    pub fn take_suffix(&mut self, n: usize) -> Self {\n+        let mid = if n <= self.len() {\n+            // SAFETY: We just checked that this will be between start and end,\n+            // and thus the addition cannot overflow.\n+            unsafe { unchecked_sub(self.end, n) }\n+        } else {\n+            self.start\n+        };\n+        let suffix = Self { start: mid, end: self.end };\n+        self.end = mid;\n+        suffix\n+    }\n+}\n+\n+impl Iterator for IndexRange {\n+    type Item = usize;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<usize> {\n+        if self.len() > 0 {\n+            // SAFETY: We just checked that the range is non-empty\n+            unsafe { Some(self.next_unchecked()) }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.len();\n+        (len, Some(len))\n+    }\n+\n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let original_len = self.len();\n+        self.take_prefix(n);\n+        if n > original_len { Err(original_len) } else { Ok(()) }\n+    }\n+}\n+\n+impl DoubleEndedIterator for IndexRange {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<usize> {\n+        if self.len() > 0 {\n+            // SAFETY: We just checked that the range is non-empty\n+            unsafe { Some(self.next_back_unchecked()) }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let original_len = self.len();\n+        self.take_suffix(n);\n+        if n > original_len { Err(original_len) } else { Ok(()) }\n+    }\n+}\n+\n+impl ExactSizeIterator for IndexRange {\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.len()\n+    }\n+}\n+\n+// SAFETY: Because we only deal in `usize`, our `len` is always perfect.\n+unsafe impl TrustedLen for IndexRange {}\n+\n+impl FusedIterator for IndexRange {}"}, {"sha": "a5e5b13b33674ca1eaad2375281e9a74dfe5e048", "filename": "library/core/src/ops/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fmod.rs?ref=6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875", "patch": "@@ -146,6 +146,7 @@ mod drop;\n mod function;\n mod generator;\n mod index;\n+mod index_range;\n mod range;\n mod try_trait;\n mod unsize;\n@@ -178,6 +179,8 @@ pub use self::index::{Index, IndexMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n \n+pub(crate) use self::index_range::IndexRange;\n+\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub use self::range::{Bound, RangeBounds, RangeInclusive, RangeToInclusive};\n "}, {"sha": "3ec6bd93e15c2c95399edf3f37218b22f5d1dc5d", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875", "patch": "@@ -139,6 +139,8 @@ mod private_slice_index {\n     impl Sealed for ops::RangeToInclusive<usize> {}\n     #[stable(feature = \"slice_index_with_ops_bound_pair\", since = \"1.53.0\")]\n     impl Sealed for (ops::Bound<usize>, ops::Bound<usize>) {}\n+\n+    impl Sealed for ops::IndexRange {}\n }\n \n /// A helper trait used for indexing operations.\n@@ -257,6 +259,79 @@ unsafe impl<T> const SliceIndex<[T]> for usize {\n     }\n }\n \n+/// Because `IndexRange` guarantees `start <= end`, fewer checks are needed here\n+/// than there are for a general `Range<usize>` (which might be `100..3`).\n+#[rustc_const_unstable(feature = \"const_index_range_slice_index\", issue = \"none\")]\n+unsafe impl<T> const SliceIndex<[T]> for ops::IndexRange {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        if self.end() <= slice.len() {\n+            // SAFETY: `self` is checked to be valid and in bounds above.\n+            unsafe { Some(&*self.get_unchecked(slice)) }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        if self.end() <= slice.len() {\n+            // SAFETY: `self` is checked to be valid and in bounds above.\n+            unsafe { Some(&mut *self.get_unchecked_mut(slice)) }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        let end = self.end();\n+        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n+        // cannot be longer than `isize::MAX`. They also guarantee that\n+        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n+        // so the call to `add` is safe.\n+\n+        unsafe {\n+            assert_unsafe_precondition!([T](end: usize, slice: *const [T]) =>\n+                end <= slice.len());\n+            ptr::slice_from_raw_parts(slice.as_ptr().add(self.start()), self.len())\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n+        let end = self.end();\n+        // SAFETY: see comments for `get_unchecked` above.\n+        unsafe {\n+            assert_unsafe_precondition!([T](end: usize, slice: *mut [T]) =>\n+                end <= slice.len());\n+            ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start()), self.len())\n+        }\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        if self.end() <= slice.len() {\n+            // SAFETY: `self` is checked to be valid and in bounds above.\n+            unsafe { &*self.get_unchecked(slice) }\n+        } else {\n+            slice_end_index_len_fail(self.end(), slice.len())\n+        }\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        if self.end() <= slice.len() {\n+            // SAFETY: `self` is checked to be valid and in bounds above.\n+            unsafe { &mut *self.get_unchecked_mut(slice) }\n+        } else {\n+            slice_end_index_len_fail(self.end(), slice.len())\n+        }\n+    }\n+}\n+\n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {"}, {"sha": "1124028253ded2df0f5283e923c9b53008e7e9f1", "filename": "src/test/codegen/slice-iter-len-eq-zero.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875/src%2Ftest%2Fcodegen%2Fslice-iter-len-eq-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875/src%2Ftest%2Fcodegen%2Fslice-iter-len-eq-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-iter-len-eq-zero.rs?ref=6dbd9a29c21db63e2c72f5e7f4f8b5ba58023875", "patch": "@@ -1,5 +1,6 @@\n // no-system-llvm\n // compile-flags: -O\n+// ignore-debug: the debug assertions add extra comparisons\n #![crate_type = \"lib\"]\n \n type Demo = [u8; 3];\n@@ -12,3 +13,16 @@ pub fn slice_iter_len_eq_zero(y: std::slice::Iter<'_, Demo>) -> bool {\n     // CHECK: ret i1 %2\n     y.len() == 0\n }\n+\n+// CHECK-LABEL: @array_into_iter_len_eq_zero\n+#[no_mangle]\n+pub fn array_into_iter_len_eq_zero(y: std::array::IntoIter<Demo, 123>) -> bool {\n+    // This should be able to just check that the indexes are equal, and not\n+    // need any subtractions or comparisons to handle `start > end`.\n+\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: sub\n+    // CHECK: %1 = icmp eq {{i16|i32|i64}}\n+    // CHECK: ret i1 %1\n+    y.len() == 0\n+}"}]}