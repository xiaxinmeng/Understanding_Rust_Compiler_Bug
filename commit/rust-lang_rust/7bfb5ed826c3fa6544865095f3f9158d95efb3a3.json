{"sha": "7bfb5ed826c3fa6544865095f3f9158d95efb3a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiZmI1ZWQ4MjZjM2ZhNjU0NDg2NTA5NWYzZjkxNThkOTVlZmIzYTM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-29T06:14:37Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-29T06:56:13Z"}, "message": "Reviewer changes", "tree": {"sha": "a7402c55535c0d0c9f797f74f519a5f62b4b41cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7402c55535c0d0c9f797f74f519a5f62b4b41cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bfb5ed826c3fa6544865095f3f9158d95efb3a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bfb5ed826c3fa6544865095f3f9158d95efb3a3", "html_url": "https://github.com/rust-lang/rust/commit/7bfb5ed826c3fa6544865095f3f9158d95efb3a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bfb5ed826c3fa6544865095f3f9158d95efb3a3/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb26aadaf3497089e9264266455d1c53391a41c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb26aadaf3497089e9264266455d1c53391a41c0", "html_url": "https://github.com/rust-lang/rust/commit/bb26aadaf3497089e9264266455d1c53391a41c0"}], "stats": {"total": 4940, "additions": 2454, "deletions": 2486}, "files": [{"sha": "1145be8002467f30c7f93fea5e1ed5ea149a85e8", "filename": "src/librustc_trans/trans/debuginfo/adt.rs", "status": "removed", "additions": 0, "deletions": 824, "changes": 824, "blob_url": "https://github.com/rust-lang/rust/blob/bb26aadaf3497089e9264266455d1c53391a41c0/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb26aadaf3497089e9264266455d1c53391a41c0/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fadt.rs?ref=bb26aadaf3497089e9264266455d1c53391a41c0", "patch": "@@ -1,824 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Common facilities for record-like types (structs, enums, tuples)\n-\n-use self::MemberDescriptionFactory::*;\n-use self::EnumDiscriminantInfo::*;\n-use self::MemberOffset::*;\n-\n-use super::{UNKNOWN_FILE_METADATA, UNKNOWN_SCOPE_METADATA, UNKNOWN_LINE_NUMBER,\n-            UniqueTypeId, FLAGS_NONE, create_and_register_recursive_type_forward_declaration};\n-use super::utils::{debug_context, DIB, span_start, bytes_to_bits,\n-                   size_and_align_of, get_namespace_and_span_for_item};\n-use super::create::create_DIArray;\n-use super::types::compute_debuginfo_type_name;\n-use super::metadata::{type_metadata, file_metadata};\n-\n-use super::RecursiveTypeDescription::{self, FinalMetadata};\n-\n-use llvm;\n-use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType};\n-use metadata::csearch;\n-use middle::subst::{self, Substs};\n-use trans::{adt, machine, type_of};\n-use trans::common::CrateContext;\n-use trans::monomorphize;\n-use trans::type_::Type;\n-use middle::ty::{self, Ty, ClosureTyper};\n-\n-use libc::c_uint;\n-use std::ffi::CString;\n-use std::ptr;\n-use std::rc::Rc;\n-use syntax::codemap::Span;\n-use syntax::{ast, codemap};\n-use syntax::parse::token::{self, special_idents};\n-\n-\n-pub enum MemberOffset {\n-    FixedMemberOffset { bytes: usize },\n-    // For ComputedMemberOffset, the offset is read from the llvm type definition.\n-    ComputedMemberOffset\n-}\n-\n-// Description of a type member, which can either be a regular field (as in\n-// structs or tuples) or an enum variant.\n-pub struct MemberDescription {\n-    pub name: String,\n-    pub llvm_type: Type,\n-    pub type_metadata: DIType,\n-    pub offset: MemberOffset,\n-    pub flags: c_uint\n-}\n-\n-// A factory for MemberDescriptions. It produces a list of member descriptions\n-// for some record-like type. MemberDescriptionFactories are used to defer the\n-// creation of type member descriptions in order to break cycles arising from\n-// recursive type definitions.\n-pub enum MemberDescriptionFactory<'tcx> {\n-    StructMDF(StructMemberDescriptionFactory<'tcx>),\n-    TupleMDF(TupleMemberDescriptionFactory<'tcx>),\n-    EnumMDF(EnumMemberDescriptionFactory<'tcx>),\n-    VariantMDF(VariantMemberDescriptionFactory<'tcx>)\n-}\n-\n-impl<'tcx> MemberDescriptionFactory<'tcx> {\n-    pub fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n-                                          -> Vec<MemberDescription> {\n-        match *self {\n-            StructMDF(ref this) => {\n-                this.create_member_descriptions(cx)\n-            }\n-            TupleMDF(ref this) => {\n-                this.create_member_descriptions(cx)\n-            }\n-            EnumMDF(ref this) => {\n-                this.create_member_descriptions(cx)\n-            }\n-            VariantMDF(ref this) => {\n-                this.create_member_descriptions(cx)\n-            }\n-        }\n-    }\n-}\n-\n-//=-----------------------------------------------------------------------------\n-// Structs\n-//=-----------------------------------------------------------------------------\n-\n-// Creates MemberDescriptions for the fields of a struct\n-struct StructMemberDescriptionFactory<'tcx> {\n-    fields: Vec<ty::field<'tcx>>,\n-    is_simd: bool,\n-    span: Span,\n-}\n-\n-impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n-        if self.fields.is_empty() {\n-            return Vec::new();\n-        }\n-\n-        let field_size = if self.is_simd {\n-            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields[0].mt.ty)) as usize\n-        } else {\n-            0xdeadbeef\n-        };\n-\n-        self.fields.iter().enumerate().map(|(i, field)| {\n-            let name = if field.name == special_idents::unnamed_field.name {\n-                format!(\"__{}\", i)\n-            } else {\n-                token::get_name(field.name).to_string()\n-            };\n-\n-            let offset = if self.is_simd {\n-                assert!(field_size != 0xdeadbeef);\n-                FixedMemberOffset { bytes: i * field_size }\n-            } else {\n-                ComputedMemberOffset\n-            };\n-\n-            MemberDescription {\n-                name: name,\n-                llvm_type: type_of::type_of(cx, field.mt.ty),\n-                type_metadata: type_metadata(cx, field.mt.ty, self.span),\n-                offset: offset,\n-                flags: FLAGS_NONE,\n-            }\n-        }).collect()\n-    }\n-}\n-\n-\n-pub fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                         struct_type: Ty<'tcx>,\n-                                         def_id: ast::DefId,\n-                                         substs: &subst::Substs<'tcx>,\n-                                         unique_type_id: UniqueTypeId,\n-                                         span: Span)\n-                                         -> RecursiveTypeDescription<'tcx> {\n-    let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n-    let struct_llvm_type = type_of::type_of(cx, struct_type);\n-\n-    let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n-\n-    let struct_metadata_stub = create_struct_stub(cx,\n-                                                  struct_llvm_type,\n-                                                  &struct_name[..],\n-                                                  unique_type_id,\n-                                                  containing_scope);\n-\n-    let mut fields = ty::struct_fields(cx.tcx(), def_id, substs);\n-\n-    // The `Ty` values returned by `ty::struct_fields` can still contain\n-    // `ty_projection` variants, so normalize those away.\n-    for field in &mut fields {\n-        field.mt.ty = monomorphize::normalize_associated_type(cx.tcx(), &field.mt.ty);\n-    }\n-\n-    create_and_register_recursive_type_forward_declaration(\n-        cx,\n-        struct_type,\n-        unique_type_id,\n-        struct_metadata_stub,\n-        struct_llvm_type,\n-        StructMDF(StructMemberDescriptionFactory {\n-            fields: fields,\n-            is_simd: ty::type_is_simd(cx.tcx(), struct_type),\n-            span: span,\n-        })\n-    )\n-}\n-\n-\n-//=-----------------------------------------------------------------------------\n-// Tuples\n-//=-----------------------------------------------------------------------------\n-\n-// Creates MemberDescriptions for the fields of a tuple\n-struct TupleMemberDescriptionFactory<'tcx> {\n-    component_types: Vec<Ty<'tcx>>,\n-    span: Span,\n-}\n-\n-impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n-        self.component_types\n-            .iter()\n-            .enumerate()\n-            .map(|(i, &component_type)| {\n-            MemberDescription {\n-                name: format!(\"__{}\", i),\n-                llvm_type: type_of::type_of(cx, component_type),\n-                type_metadata: type_metadata(cx, component_type, self.span),\n-                offset: ComputedMemberOffset,\n-                flags: FLAGS_NONE,\n-            }\n-        }).collect()\n-    }\n-}\n-\n-pub fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                        tuple_type: Ty<'tcx>,\n-                                        component_types: &[Ty<'tcx>],\n-                                        unique_type_id: UniqueTypeId,\n-                                        span: Span)\n-                                        -> RecursiveTypeDescription<'tcx> {\n-    let tuple_name = compute_debuginfo_type_name(cx, tuple_type, false);\n-    let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n-\n-    create_and_register_recursive_type_forward_declaration(\n-        cx,\n-        tuple_type,\n-        unique_type_id,\n-        create_struct_stub(cx,\n-                           tuple_llvm_type,\n-                           &tuple_name[..],\n-                           unique_type_id,\n-                           UNKNOWN_SCOPE_METADATA),\n-        tuple_llvm_type,\n-        TupleMDF(TupleMemberDescriptionFactory {\n-            component_types: component_types.to_vec(),\n-            span: span,\n-        })\n-    )\n-}\n-\n-\n-//=-----------------------------------------------------------------------------\n-// Enums\n-//=-----------------------------------------------------------------------------\n-\n-// Describes the members of an enum value: An enum is described as a union of\n-// structs in DWARF. This MemberDescriptionFactory provides the description for\n-// the members of this union; so for every variant of the given enum, this\n-// factory will produce one MemberDescription (all with no name and a fixed\n-// offset of zero bytes).\n-struct EnumMemberDescriptionFactory<'tcx> {\n-    enum_type: Ty<'tcx>,\n-    type_rep: Rc<adt::Repr<'tcx>>,\n-    variants: Rc<Vec<Rc<ty::VariantInfo<'tcx>>>>,\n-    discriminant_type_metadata: Option<DIType>,\n-    containing_scope: DIScope,\n-    file_metadata: DIFile,\n-    span: Span,\n-}\n-\n-impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n-        match *self.type_rep {\n-            adt::General(_, ref struct_defs, _) => {\n-                let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n-                    .expect(\"\"));\n-\n-                struct_defs\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, struct_def)| {\n-                        let (variant_type_metadata,\n-                             variant_llvm_type,\n-                             member_desc_factory) =\n-                            describe_enum_variant(cx,\n-                                                  self.enum_type,\n-                                                  struct_def,\n-                                                  &*(*self.variants)[i],\n-                                                  discriminant_info,\n-                                                  self.containing_scope,\n-                                                  self.span);\n-\n-                        let member_descriptions = member_desc_factory\n-                            .create_member_descriptions(cx);\n-\n-                        set_members_of_composite_type(cx,\n-                                                      variant_type_metadata,\n-                                                      variant_llvm_type,\n-                                                      &member_descriptions[..]);\n-                        MemberDescription {\n-                            name: \"\".to_string(),\n-                            llvm_type: variant_llvm_type,\n-                            type_metadata: variant_type_metadata,\n-                            offset: FixedMemberOffset { bytes: 0 },\n-                            flags: FLAGS_NONE\n-                        }\n-                    }).collect()\n-            },\n-            adt::Univariant(ref struct_def, _) => {\n-                assert!(self.variants.len() <= 1);\n-\n-                if self.variants.is_empty() {\n-                    vec![]\n-                } else {\n-                    let (variant_type_metadata,\n-                         variant_llvm_type,\n-                         member_description_factory) =\n-                        describe_enum_variant(cx,\n-                                              self.enum_type,\n-                                              struct_def,\n-                                              &*(*self.variants)[0],\n-                                              NoDiscriminant,\n-                                              self.containing_scope,\n-                                              self.span);\n-\n-                    let member_descriptions =\n-                        member_description_factory.create_member_descriptions(cx);\n-\n-                    set_members_of_composite_type(cx,\n-                                                  variant_type_metadata,\n-                                                  variant_llvm_type,\n-                                                  &member_descriptions[..]);\n-                    vec![\n-                        MemberDescription {\n-                            name: \"\".to_string(),\n-                            llvm_type: variant_llvm_type,\n-                            type_metadata: variant_type_metadata,\n-                            offset: FixedMemberOffset { bytes: 0 },\n-                            flags: FLAGS_NONE\n-                        }\n-                    ]\n-                }\n-            }\n-            adt::RawNullablePointer { nndiscr: non_null_variant_index, nnty, .. } => {\n-                // As far as debuginfo is concerned, the pointer this enum\n-                // represents is still wrapped in a struct. This is to make the\n-                // DWARF representation of enums uniform.\n-\n-                // First create a description of the artificial wrapper struct:\n-                let non_null_variant = &(*self.variants)[non_null_variant_index as usize];\n-                let non_null_variant_name = token::get_name(non_null_variant.name);\n-\n-                // The llvm type and metadata of the pointer\n-                let non_null_llvm_type = type_of::type_of(cx, nnty);\n-                let non_null_type_metadata = type_metadata(cx, nnty, self.span);\n-\n-                // The type of the artificial struct wrapping the pointer\n-                let artificial_struct_llvm_type = Type::struct_(cx,\n-                                                                &[non_null_llvm_type],\n-                                                                false);\n-\n-                // For the metadata of the wrapper struct, we need to create a\n-                // MemberDescription of the struct's single field.\n-                let sole_struct_member_description = MemberDescription {\n-                    name: match non_null_variant.arg_names {\n-                        Some(ref names) => token::get_name(names[0]).to_string(),\n-                        None => \"__0\".to_string()\n-                    },\n-                    llvm_type: non_null_llvm_type,\n-                    type_metadata: non_null_type_metadata,\n-                    offset: FixedMemberOffset { bytes: 0 },\n-                    flags: FLAGS_NONE\n-                };\n-\n-                let unique_type_id = debug_context(cx).type_map\n-                                                      .borrow_mut()\n-                                                      .get_unique_type_id_of_enum_variant(\n-                                                          cx,\n-                                                          self.enum_type,\n-                                                          &non_null_variant_name);\n-\n-                // Now we can create the metadata of the artificial struct\n-                let artificial_struct_metadata =\n-                    composite_type_metadata(cx,\n-                                            artificial_struct_llvm_type,\n-                                            &non_null_variant_name,\n-                                            unique_type_id,\n-                                            &[sole_struct_member_description],\n-                                            self.containing_scope,\n-                                            self.file_metadata,\n-                                            codemap::DUMMY_SP);\n-\n-                // Encode the information about the null variant in the union\n-                // member's name.\n-                let null_variant_index = (1 - non_null_variant_index) as usize;\n-                let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n-                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n-                                                0,\n-                                                null_variant_name);\n-\n-                // Finally create the (singleton) list of descriptions of union\n-                // members.\n-                vec![\n-                    MemberDescription {\n-                        name: union_member_name,\n-                        llvm_type: artificial_struct_llvm_type,\n-                        type_metadata: artificial_struct_metadata,\n-                        offset: FixedMemberOffset { bytes: 0 },\n-                        flags: FLAGS_NONE\n-                    }\n-                ]\n-            },\n-            adt::StructWrappedNullablePointer { nonnull: ref struct_def,\n-                                                nndiscr,\n-                                                ref discrfield, ..} => {\n-                // Create a description of the non-null variant\n-                let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n-                    describe_enum_variant(cx,\n-                                          self.enum_type,\n-                                          struct_def,\n-                                          &*(*self.variants)[nndiscr as usize],\n-                                          OptimizedDiscriminant,\n-                                          self.containing_scope,\n-                                          self.span);\n-\n-                let variant_member_descriptions =\n-                    member_description_factory.create_member_descriptions(cx);\n-\n-                set_members_of_composite_type(cx,\n-                                              variant_type_metadata,\n-                                              variant_llvm_type,\n-                                              &variant_member_descriptions[..]);\n-\n-                // Encode the information about the null variant in the union\n-                // member's name.\n-                let null_variant_index = (1 - nndiscr) as usize;\n-                let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n-                let discrfield = discrfield.iter()\n-                                           .skip(1)\n-                                           .map(|x| x.to_string())\n-                                           .collect::<Vec<_>>().connect(\"$\");\n-                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n-                                                discrfield,\n-                                                null_variant_name);\n-\n-                // Create the (singleton) list of descriptions of union members.\n-                vec![\n-                    MemberDescription {\n-                        name: union_member_name,\n-                        llvm_type: variant_llvm_type,\n-                        type_metadata: variant_type_metadata,\n-                        offset: FixedMemberOffset { bytes: 0 },\n-                        flags: FLAGS_NONE\n-                    }\n-                ]\n-            },\n-            adt::CEnum(..) => cx.sess().span_bug(self.span, \"This should be unreachable.\")\n-        }\n-    }\n-}\n-\n-// Creates MemberDescriptions for the fields of a single enum variant.\n-struct VariantMemberDescriptionFactory<'tcx> {\n-    args: Vec<(String, Ty<'tcx>)>,\n-    discriminant_type_metadata: Option<DIType>,\n-    span: Span,\n-}\n-\n-impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n-                                      -> Vec<MemberDescription> {\n-        self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n-            MemberDescription {\n-                name: name.to_string(),\n-                llvm_type: type_of::type_of(cx, ty),\n-                type_metadata: match self.discriminant_type_metadata {\n-                    Some(metadata) if i == 0 => metadata,\n-                    _ => type_metadata(cx, ty, self.span)\n-                },\n-                offset: ComputedMemberOffset,\n-                flags: FLAGS_NONE\n-            }\n-        }).collect()\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-enum EnumDiscriminantInfo {\n-    RegularDiscriminant(DIType),\n-    OptimizedDiscriminant,\n-    NoDiscriminant\n-}\n-\n-// Returns a tuple of (1) type_metadata_stub of the variant, (2) the llvm_type\n-// of the variant, and (3) a MemberDescriptionFactory for producing the\n-// descriptions of the fields of the variant. This is a rudimentary version of a\n-// full RecursiveTypeDescription.\n-fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                   enum_type: Ty<'tcx>,\n-                                   struct_def: &adt::Struct<'tcx>,\n-                                   variant_info: &ty::VariantInfo<'tcx>,\n-                                   discriminant_info: EnumDiscriminantInfo,\n-                                   containing_scope: DIScope,\n-                                   span: Span)\n-                                   -> (DICompositeType, Type, MemberDescriptionFactory<'tcx>) {\n-    let variant_llvm_type =\n-        Type::struct_(cx, &struct_def.fields\n-                                    .iter()\n-                                    .map(|&t| type_of::type_of(cx, t))\n-                                    .collect::<Vec<_>>()\n-                                    ,\n-                      struct_def.packed);\n-    // Could do some consistency checks here: size, align, field count, discr type\n-\n-    let variant_name = token::get_name(variant_info.name);\n-    let variant_name = &variant_name;\n-    let unique_type_id = debug_context(cx).type_map\n-                                          .borrow_mut()\n-                                          .get_unique_type_id_of_enum_variant(\n-                                              cx,\n-                                              enum_type,\n-                                              variant_name);\n-\n-    let metadata_stub = create_struct_stub(cx,\n-                                           variant_llvm_type,\n-                                           variant_name,\n-                                           unique_type_id,\n-                                           containing_scope);\n-\n-    // Get the argument names from the enum variant info\n-    let mut arg_names: Vec<_> = match variant_info.arg_names {\n-        Some(ref names) => {\n-            names.iter()\n-                 .map(|&name| token::get_name(name).to_string())\n-                 .collect()\n-        }\n-        None => {\n-            variant_info.args\n-                        .iter()\n-                        .enumerate()\n-                        .map(|(i, _)| format!(\"__{}\", i))\n-                        .collect()\n-        }\n-    };\n-\n-    // If this is not a univariant enum, there is also the discriminant field.\n-    match discriminant_info {\n-        RegularDiscriminant(_) => arg_names.insert(0, \"RUST$ENUM$DISR\".to_string()),\n-        _ => { /* do nothing */ }\n-    };\n-\n-    // Build an array of (field name, field type) pairs to be captured in the factory closure.\n-    let args: Vec<(String, Ty)> = arg_names.iter()\n-        .zip(struct_def.fields.iter())\n-        .map(|(s, &t)| (s.to_string(), t))\n-        .collect();\n-\n-    let member_description_factory =\n-        VariantMDF(VariantMemberDescriptionFactory {\n-            args: args,\n-            discriminant_type_metadata: match discriminant_info {\n-                RegularDiscriminant(discriminant_type_metadata) => {\n-                    Some(discriminant_type_metadata)\n-                }\n-                _ => None\n-            },\n-            span: span,\n-        });\n-\n-    (metadata_stub, variant_llvm_type, member_description_factory)\n-}\n-\n-pub fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                       enum_type: Ty<'tcx>,\n-                                       enum_def_id: ast::DefId,\n-                                       unique_type_id: UniqueTypeId,\n-                                       span: Span)\n-                                       -> RecursiveTypeDescription<'tcx> {\n-    let enum_name = compute_debuginfo_type_name(cx, enum_type, false);\n-\n-    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n-    let loc = span_start(cx, definition_span);\n-    let file_metadata = file_metadata(cx, &loc.file.name);\n-\n-    let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n-\n-    let enumerators_metadata: Vec<DIDescriptor> = variants\n-        .iter()\n-        .map(|v| {\n-            let token = token::get_name(v.name);\n-            let name = CString::new(token.as_bytes()).unwrap();\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateEnumerator(\n-                    DIB(cx),\n-                    name.as_ptr(),\n-                    v.disr_val as u64)\n-            }\n-        })\n-        .collect();\n-\n-    let discriminant_type_metadata = |inttype| {\n-        // We can reuse the type of the discriminant for all monomorphized\n-        // instances of an enum because it doesn't depend on any type\n-        // parameters. The def_id, uniquely identifying the enum's polytype acts\n-        // as key in this cache.\n-        let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n-                                                                 .borrow()\n-                                                                 .get(&enum_def_id).cloned();\n-        match cached_discriminant_type_metadata {\n-            Some(discriminant_type_metadata) => discriminant_type_metadata,\n-            None => {\n-                let discriminant_llvm_type = adt::ll_inttype(cx, inttype);\n-                let (discriminant_size, discriminant_align) =\n-                    size_and_align_of(cx, discriminant_llvm_type);\n-                let discriminant_base_type_metadata =\n-                    type_metadata(cx,\n-                                  adt::ty_of_inttype(cx.tcx(), inttype),\n-                                  codemap::DUMMY_SP);\n-                let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n-\n-                let name = CString::new(discriminant_name.as_bytes()).unwrap();\n-                let discriminant_type_metadata = unsafe {\n-                    llvm::LLVMDIBuilderCreateEnumerationType(\n-                        DIB(cx),\n-                        containing_scope,\n-                        name.as_ptr(),\n-                        UNKNOWN_FILE_METADATA,\n-                        UNKNOWN_LINE_NUMBER,\n-                        bytes_to_bits(discriminant_size),\n-                        bytes_to_bits(discriminant_align),\n-                        create_DIArray(DIB(cx), &enumerators_metadata),\n-                        discriminant_base_type_metadata)\n-                };\n-\n-                debug_context(cx).created_enum_disr_types\n-                                 .borrow_mut()\n-                                 .insert(enum_def_id, discriminant_type_metadata);\n-\n-                discriminant_type_metadata\n-            }\n-        }\n-    };\n-\n-    let type_rep = adt::represent_type(cx, enum_type);\n-\n-    let discriminant_type_metadata = match *type_rep {\n-        adt::CEnum(inttype, _, _) => {\n-            return FinalMetadata(discriminant_type_metadata(inttype))\n-        },\n-        adt::RawNullablePointer { .. }           |\n-        adt::StructWrappedNullablePointer { .. } |\n-        adt::Univariant(..)                      => None,\n-        adt::General(inttype, _, _) => Some(discriminant_type_metadata(inttype)),\n-    };\n-\n-    let enum_llvm_type = type_of::type_of(cx, enum_type);\n-    let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n-\n-    let unique_type_id_str = debug_context(cx)\n-                             .type_map\n-                             .borrow()\n-                             .get_unique_type_id_as_string(unique_type_id);\n-\n-    let enum_name = CString::new(enum_name).unwrap();\n-    let unique_type_id_str = CString::new(unique_type_id_str.as_bytes()).unwrap();\n-    let enum_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateUnionType(\n-        DIB(cx),\n-        containing_scope,\n-        enum_name.as_ptr(),\n-        UNKNOWN_FILE_METADATA,\n-        UNKNOWN_LINE_NUMBER,\n-        bytes_to_bits(enum_type_size),\n-        bytes_to_bits(enum_type_align),\n-        0, // Flags\n-        ptr::null_mut(),\n-        0, // RuntimeLang\n-        unique_type_id_str.as_ptr())\n-    };\n-\n-    return create_and_register_recursive_type_forward_declaration(\n-        cx,\n-        enum_type,\n-        unique_type_id,\n-        enum_metadata,\n-        enum_llvm_type,\n-        EnumMDF(EnumMemberDescriptionFactory {\n-            enum_type: enum_type,\n-            type_rep: type_rep.clone(),\n-            variants: variants,\n-            discriminant_type_metadata: discriminant_type_metadata,\n-            containing_scope: containing_scope,\n-            file_metadata: file_metadata,\n-            span: span,\n-        }),\n-    );\n-\n-    fn get_enum_discriminant_name(cx: &CrateContext,\n-                                  def_id: ast::DefId)\n-                                  -> token::InternedString {\n-        let name = if def_id.krate == ast::LOCAL_CRATE {\n-            cx.tcx().map.get_path_elem(def_id.node).name()\n-        } else {\n-            csearch::get_item_path(cx.tcx(), def_id).last().unwrap().name()\n-        };\n-\n-        token::get_name(name)\n-    }\n-}\n-\n-/// Creates debug information for a composite type, that is, anything that\n-/// results in a LLVM struct.\n-///\n-/// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n-pub fn composite_type_metadata(cx: &CrateContext,\n-                               composite_llvm_type: Type,\n-                               composite_type_name: &str,\n-                               composite_type_unique_id: UniqueTypeId,\n-                               member_descriptions: &[MemberDescription],\n-                               containing_scope: DIScope,\n-\n-                               // Ignore source location information as long as it\n-                               // can't be reconstructed for non-local crates.\n-                               _file_metadata: DIFile,\n-                               _definition_span: Span)\n-                               -> DICompositeType {\n-    // Create the (empty) struct metadata node ...\n-    let composite_type_metadata = create_struct_stub(cx,\n-                                                     composite_llvm_type,\n-                                                     composite_type_name,\n-                                                     composite_type_unique_id,\n-                                                     containing_scope);\n-    // ... and immediately create and add the member descriptions.\n-    set_members_of_composite_type(cx,\n-                                  composite_type_metadata,\n-                                  composite_llvm_type,\n-                                  member_descriptions);\n-\n-    return composite_type_metadata;\n-}\n-\n-pub fn set_members_of_composite_type(cx: &CrateContext,\n-                                     composite_type_metadata: DICompositeType,\n-                                     composite_llvm_type: Type,\n-                                     member_descriptions: &[MemberDescription]) {\n-    // In some rare cases LLVM metadata uniquing would lead to an existing type\n-    // description being used instead of a new one created in\n-    // create_struct_stub. This would cause a hard to trace assertion in\n-    // DICompositeType::SetTypeArray(). The following check makes sure that we\n-    // get a better error message if this should happen again due to some\n-    // regression.\n-    {\n-        let mut composite_types_completed =\n-            debug_context(cx).composite_types_completed.borrow_mut();\n-        if composite_types_completed.contains(&composite_type_metadata) {\n-            cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n-                           Already completed forward declaration re-encountered.\");\n-        } else {\n-            composite_types_completed.insert(composite_type_metadata);\n-        }\n-    }\n-\n-    let member_metadata: Vec<DIDescriptor> = member_descriptions\n-        .iter()\n-        .enumerate()\n-        .map(|(i, member_description)| {\n-            let (member_size, member_align) = size_and_align_of(cx, member_description.llvm_type);\n-            let member_offset = match member_description.offset {\n-                FixedMemberOffset { bytes } => bytes as u64,\n-                ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n-            };\n-\n-            let member_name = member_description.name.as_bytes();\n-            let member_name = CString::new(member_name).unwrap();\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateMemberType(\n-                    DIB(cx),\n-                    composite_type_metadata,\n-                    member_name.as_ptr(),\n-                    UNKNOWN_FILE_METADATA,\n-                    UNKNOWN_LINE_NUMBER,\n-                    bytes_to_bits(member_size),\n-                    bytes_to_bits(member_align),\n-                    bytes_to_bits(member_offset),\n-                    member_description.flags,\n-                    member_description.type_metadata)\n-            }\n-        })\n-        .collect();\n-\n-    unsafe {\n-        let type_array = create_DIArray(DIB(cx), &member_metadata[..]);\n-        llvm::LLVMDICompositeTypeSetTypeArray(DIB(cx), composite_type_metadata, type_array);\n-    }\n-}\n-\n-// A convenience wrapper around LLVMDIBuilderCreateStructType(). Does not do any\n-// caching, does not add any fields to the struct. This can be done later with\n-// set_members_of_composite_type().\n-fn create_struct_stub(cx: &CrateContext,\n-                      struct_llvm_type: Type,\n-                      struct_type_name: &str,\n-                      unique_type_id: UniqueTypeId,\n-                      containing_scope: DIScope)\n-                   -> DICompositeType {\n-    let (struct_size, struct_align) = size_and_align_of(cx, struct_llvm_type);\n-\n-    let unique_type_id_str = debug_context(cx).type_map\n-                                              .borrow()\n-                                              .get_unique_type_id_as_string(unique_type_id);\n-    let name = CString::new(struct_type_name).unwrap();\n-    let unique_type_id = CString::new(unique_type_id_str.as_bytes()).unwrap();\n-    let metadata_stub = unsafe {\n-        // LLVMDIBuilderCreateStructType() wants an empty array. A null\n-        // pointer will lead to hard to trace and debug LLVM assertions\n-        // later on in llvm/lib/IR/Value.cpp.\n-        let empty_array = create_DIArray(DIB(cx), &[]);\n-\n-        llvm::LLVMDIBuilderCreateStructType(\n-            DIB(cx),\n-            containing_scope,\n-            name.as_ptr(),\n-            UNKNOWN_FILE_METADATA,\n-            UNKNOWN_LINE_NUMBER,\n-            bytes_to_bits(struct_size),\n-            bytes_to_bits(struct_align),\n-            0,\n-            ptr::null_mut(),\n-            empty_array,\n-            0,\n-            ptr::null_mut(),\n-            unique_type_id.as_ptr())\n-    };\n-\n-    return metadata_stub;\n-}"}, {"sha": "e031cd4efa1fd11a378b8063570154d97a856e6a", "filename": "src/librustc_trans/trans/debuginfo/create.rs", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/bb26aadaf3497089e9264266455d1c53391a41c0/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb26aadaf3497089e9264266455d1c53391a41c0/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate.rs?ref=bb26aadaf3497089e9264266455d1c53391a41c0", "patch": "@@ -1,125 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Module-Internal debug info creation functions.\n-\n-use super::utils::{span_start, DIB};\n-use super::metadata::{type_metadata, file_metadata};\n-\n-use super::{set_debug_location, DW_TAG_auto_variable, DW_TAG_arg_variable};\n-use super::VariableKind::{self, ArgumentVariable, CapturedVariable, LocalVariable};\n-use super::VariableAccess::{self, DirectVariable, IndirectVariable};\n-use super::InternalDebugLocation::{self, UnknownLocation};\n-\n-use llvm;\n-use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n-\n-use trans;\n-use trans::common::{CrateContext, Block};\n-use middle::ty::Ty;\n-use session::config;\n-\n-use libc::c_uint;\n-use std::ffi::CString;\n-use syntax::codemap::{Span, Pos};\n-use syntax::ast;\n-use syntax::parse::token;\n-\n-pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n-{\n-    // The is_local_to_unit flag indicates whether a function is local to the\n-    // current compilation unit (i.e. if it is *static* in the C-sense). The\n-    // *reachable* set should provide a good approximation of this, as it\n-    // contains everything that might leak out of the current crate (by being\n-    // externally visible or by being inlined into something externally\n-    // visible). It might better to use the `exported_items` set from\n-    // `driver::CrateAnalysis` in the future, but (atm) this set is not\n-    // available in the translation pass.\n-    !cx.reachable().contains(&node_id)\n-}\n-\n-#[allow(non_snake_case)]\n-pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n-    return unsafe {\n-        llvm::LLVMDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n-    };\n-}\n-\n-pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 variable_name: ast::Name,\n-                                 variable_type: Ty<'tcx>,\n-                                 scope_metadata: DIScope,\n-                                 variable_access: VariableAccess,\n-                                 variable_kind: VariableKind,\n-                                 span: Span) {\n-    let cx: &CrateContext = bcx.ccx();\n-\n-    let filename = span_start(cx, span).file.name.clone();\n-    let file_metadata = file_metadata(cx, &filename[..]);\n-\n-    let name = token::get_name(variable_name);\n-    let loc = span_start(cx, span);\n-    let type_metadata = type_metadata(cx, variable_type, span);\n-\n-    let (argument_index, dwarf_tag) = match variable_kind {\n-        ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n-        LocalVariable    |\n-        CapturedVariable => (0, DW_TAG_auto_variable)\n-    };\n-\n-    let name = CString::new(name.as_bytes()).unwrap();\n-    match (variable_access, &[][..]) {\n-        (DirectVariable { alloca }, address_operations) |\n-        (IndirectVariable {alloca, address_operations}, _) => {\n-            let metadata = unsafe {\n-                llvm::LLVMDIBuilderCreateVariable(\n-                    DIB(cx),\n-                    dwarf_tag,\n-                    scope_metadata,\n-                    name.as_ptr(),\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    type_metadata,\n-                    cx.sess().opts.optimize != config::No,\n-                    0,\n-                    address_operations.as_ptr(),\n-                    address_operations.len() as c_uint,\n-                    argument_index)\n-            };\n-            set_debug_location(cx, InternalDebugLocation::new(scope_metadata,\n-                                                      loc.line,\n-                                                      loc.col.to_usize()));\n-            unsafe {\n-                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-                    DIB(cx),\n-                    alloca,\n-                    metadata,\n-                    address_operations.as_ptr(),\n-                    address_operations.len() as c_uint,\n-                    bcx.llbb);\n-\n-                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n-            }\n-        }\n-    }\n-\n-    match variable_kind {\n-        ArgumentVariable(_) | CapturedVariable => {\n-            assert!(!bcx.fcx\n-                        .debug_context\n-                        .get_ref(cx, span)\n-                        .source_locations_enabled\n-                        .get());\n-            set_debug_location(cx, UnknownLocation);\n-        }\n-        _ => { /* nothing to do */ }\n-    }\n-}\n-"}, {"sha": "9af22b788b77beaf0160dfa8cabe2f5e82762937", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "added", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/7bfb5ed826c3fa6544865095f3f9158d95efb3a3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfb5ed826c3fa6544865095f3f9158d95efb3a3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=7bfb5ed826c3fa6544865095f3f9158d95efb3a3", "patch": "@@ -0,0 +1,514 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::metadata::file_metadata;\n+use super::utils::DIB;\n+\n+use llvm;\n+use llvm::debuginfo::{DIScope, DISubprogram};\n+use trans::common::CrateContext;\n+use middle::pat_util;\n+use util::nodemap::NodeMap;\n+\n+use libc::c_uint;\n+use syntax::codemap::{Span, Pos};\n+use syntax::{ast, codemap, ast_util};\n+\n+// This procedure builds the *scope map* for a given function, which maps any\n+// given ast::NodeId in the function's AST to the correct DIScope metadata instance.\n+//\n+// This builder procedure walks the AST in execution order and keeps track of\n+// what belongs to which scope, creating DIScope DIEs along the way, and\n+// introducing *artificial* lexical scope descriptors where necessary. These\n+// artificial scopes allow GDB to correctly handle name shadowing.\n+pub fn create_scope_map(cx: &CrateContext,\n+                        args: &[ast::Arg],\n+                        fn_entry_block: &ast::Block,\n+                        fn_metadata: DISubprogram,\n+                        fn_ast_id: ast::NodeId)\n+                        -> NodeMap<DIScope> {\n+    let mut scope_map = NodeMap();\n+\n+    let def_map = &cx.tcx().def_map;\n+\n+    let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata, name: None });\n+    scope_map.insert(fn_ast_id, fn_metadata);\n+\n+    // Push argument identifiers onto the stack so arguments integrate nicely\n+    // with variable shadowing.\n+    for arg in args {\n+        pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, _, path1| {\n+            scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n+                                               name: Some(path1.node.name) });\n+            scope_map.insert(node_id, fn_metadata);\n+        })\n+    }\n+\n+    // Clang creates a separate scope for function bodies, so let's do this too.\n+    with_new_scope(cx,\n+                   fn_entry_block.span,\n+                   &mut scope_stack,\n+                   &mut scope_map,\n+                   |cx, scope_stack, scope_map| {\n+        walk_block(cx, fn_entry_block, scope_stack, scope_map);\n+    });\n+\n+    return scope_map;\n+}\n+\n+// local helper functions for walking the AST.\n+fn with_new_scope<F>(cx: &CrateContext,\n+                     scope_span: Span,\n+                     scope_stack: &mut Vec<ScopeStackEntry> ,\n+                     scope_map: &mut NodeMap<DIScope>,\n+                     inner_walk: F) where\n+    F: FnOnce(&CrateContext, &mut Vec<ScopeStackEntry>, &mut NodeMap<DIScope>),\n+{\n+    // Create a new lexical scope and push it onto the stack\n+    let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n+    let parent_scope = scope_stack.last().unwrap().scope_metadata;\n+\n+    let scope_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateLexicalBlock(\n+            DIB(cx),\n+            parent_scope,\n+            file_metadata,\n+            loc.line as c_uint,\n+            loc.col.to_usize() as c_uint)\n+    };\n+\n+    scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata, name: None });\n+\n+    inner_walk(cx, scope_stack, scope_map);\n+\n+    // pop artificial scopes\n+    while scope_stack.last().unwrap().name.is_some() {\n+        scope_stack.pop();\n+    }\n+\n+    if scope_stack.last().unwrap().scope_metadata != scope_metadata {\n+        cx.sess().span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n+    }\n+\n+    scope_stack.pop();\n+}\n+\n+struct ScopeStackEntry {\n+    scope_metadata: DIScope,\n+    name: Option<ast::Name>\n+}\n+\n+fn walk_block(cx: &CrateContext,\n+              block: &ast::Block,\n+              scope_stack: &mut Vec<ScopeStackEntry> ,\n+              scope_map: &mut NodeMap<DIScope>) {\n+    scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n+\n+    // The interesting things here are statements and the concluding expression.\n+    for statement in &block.stmts {\n+        scope_map.insert(ast_util::stmt_id(&**statement),\n+                         scope_stack.last().unwrap().scope_metadata);\n+\n+        match statement.node {\n+            ast::StmtDecl(ref decl, _) =>\n+                walk_decl(cx, &**decl, scope_stack, scope_map),\n+            ast::StmtExpr(ref exp, _) |\n+            ast::StmtSemi(ref exp, _) =>\n+                walk_expr(cx, &**exp, scope_stack, scope_map),\n+            ast::StmtMac(..) => () // Ignore macros (which should be expanded anyway).\n+        }\n+    }\n+\n+    if let Some(ref exp) = block.expr {\n+        walk_expr(cx, &**exp, scope_stack, scope_map);\n+    }\n+}\n+\n+fn walk_decl(cx: &CrateContext,\n+             decl: &ast::Decl,\n+             scope_stack: &mut Vec<ScopeStackEntry> ,\n+             scope_map: &mut NodeMap<DIScope>) {\n+    match *decl {\n+        codemap::Spanned { node: ast::DeclLocal(ref local), .. } => {\n+            scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            walk_pattern(cx, &*local.pat, scope_stack, scope_map);\n+\n+            if let Some(ref exp) = local.init {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+        }\n+        _ => ()\n+    }\n+}\n+\n+fn walk_pattern(cx: &CrateContext,\n+                pat: &ast::Pat,\n+                scope_stack: &mut Vec<ScopeStackEntry> ,\n+                scope_map: &mut NodeMap<DIScope>) {\n+\n+    let def_map = &cx.tcx().def_map;\n+\n+    // Unfortunately, we cannot just use pat_util::pat_bindings() or\n+    // ast_util::walk_pat() here because we have to visit *all* nodes in\n+    // order to put them into the scope map. The above functions don't do that.\n+    match pat.node {\n+        ast::PatIdent(_, ref path1, ref sub_pat_opt) => {\n+\n+            // Check if this is a binding. If so we need to put it on the\n+            // scope stack and maybe introduce an artificial scope\n+            if pat_util::pat_is_binding(def_map, &*pat) {\n+\n+                let name = path1.node.name;\n+\n+                // LLVM does not properly generate 'DW_AT_start_scope' fields\n+                // for variable DIEs. For this reason we have to introduce\n+                // an artificial scope at bindings whenever a variable with\n+                // the same name is declared in *any* parent scope.\n+                //\n+                // Otherwise the following error occurs:\n+                //\n+                // let x = 10;\n+                //\n+                // do_something(); // 'gdb print x' correctly prints 10\n+                //\n+                // {\n+                //     do_something(); // 'gdb print x' prints 0, because it\n+                //                     // already reads the uninitialized 'x'\n+                //                     // from the next line...\n+                //     let x = 100;\n+                //     do_something(); // 'gdb print x' correctly prints 100\n+                // }\n+\n+                // Is there already a binding with that name?\n+                // N.B.: this comparison must be UNhygienic... because\n+                // gdb knows nothing about the context, so any two\n+                // variables with the same name will cause the problem.\n+                let need_new_scope = scope_stack\n+                    .iter()\n+                    .any(|entry| entry.name == Some(name));\n+\n+                if need_new_scope {\n+                    // Create a new lexical scope and push it onto the stack\n+                    let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n+                    let file_metadata = file_metadata(cx, &loc.file.name);\n+                    let parent_scope = scope_stack.last().unwrap().scope_metadata;\n+\n+                    let scope_metadata = unsafe {\n+                        llvm::LLVMDIBuilderCreateLexicalBlock(\n+                            DIB(cx),\n+                            parent_scope,\n+                            file_metadata,\n+                            loc.line as c_uint,\n+                            loc.col.to_usize() as c_uint)\n+                    };\n+\n+                    scope_stack.push(ScopeStackEntry {\n+                        scope_metadata: scope_metadata,\n+                        name: Some(name)\n+                    });\n+\n+                } else {\n+                    // Push a new entry anyway so the name can be found\n+                    let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n+                    scope_stack.push(ScopeStackEntry {\n+                        scope_metadata: prev_metadata,\n+                        name: Some(name)\n+                    });\n+                }\n+            }\n+\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            if let Some(ref sub_pat) = *sub_pat_opt {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatWild(_) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+        }\n+\n+        ast::PatEnum(_, ref sub_pats_opt) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            if let Some(ref sub_pats) = *sub_pats_opt {\n+                for p in sub_pats {\n+                    walk_pattern(cx, &**p, scope_stack, scope_map);\n+                }\n+            }\n+        }\n+\n+        ast::PatQPath(..) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+        }\n+\n+        ast::PatStruct(_, ref field_pats, _) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            for &codemap::Spanned {\n+                node: ast::FieldPat { pat: ref sub_pat, .. },\n+                ..\n+            } in field_pats.iter() {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatTup(ref sub_pats) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            for sub_pat in sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatBox(ref sub_pat) | ast::PatRegion(ref sub_pat, _) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+        }\n+\n+        ast::PatLit(ref exp) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            walk_expr(cx, &**exp, scope_stack, scope_map);\n+        }\n+\n+        ast::PatRange(ref exp1, ref exp2) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            walk_expr(cx, &**exp1, scope_stack, scope_map);\n+            walk_expr(cx, &**exp2, scope_stack, scope_map);\n+        }\n+\n+        ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n+            scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+\n+            for sub_pat in front_sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+\n+            if let Some(ref sub_pat) = *middle_sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+\n+            for sub_pat in back_sub_pats {\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::PatMac(_) => {\n+            cx.sess().span_bug(pat.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded macro.\");\n+        }\n+    }\n+}\n+\n+fn walk_expr(cx: &CrateContext,\n+             exp: &ast::Expr,\n+             scope_stack: &mut Vec<ScopeStackEntry> ,\n+             scope_map: &mut NodeMap<DIScope>) {\n+\n+    scope_map.insert(exp.id, scope_stack.last().unwrap().scope_metadata);\n+\n+    match exp.node {\n+        ast::ExprLit(_)   |\n+        ast::ExprBreak(_) |\n+        ast::ExprAgain(_) |\n+        ast::ExprPath(..) => {}\n+\n+        ast::ExprCast(ref sub_exp, _)     |\n+        ast::ExprAddrOf(_, ref sub_exp)  |\n+        ast::ExprField(ref sub_exp, _) |\n+        ast::ExprTupField(ref sub_exp, _) |\n+        ast::ExprParen(ref sub_exp) =>\n+            walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n+\n+        ast::ExprBox(ref place, ref sub_expr) => {\n+            place.as_ref().map(\n+                |e| walk_expr(cx, &**e, scope_stack, scope_map));\n+            walk_expr(cx, &**sub_expr, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprRet(ref exp_opt) => match *exp_opt {\n+            Some(ref sub_exp) => walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n+            None => ()\n+        },\n+\n+        ast::ExprUnary(_, ref sub_exp) => {\n+            walk_expr(cx, &**sub_exp, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprAssignOp(_, ref lhs, ref rhs) |\n+        ast::ExprIndex(ref lhs, ref rhs) |\n+        ast::ExprBinary(_, ref lhs, ref rhs)    => {\n+            walk_expr(cx, &**lhs, scope_stack, scope_map);\n+            walk_expr(cx, &**rhs, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprRange(ref start, ref end) => {\n+            start.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n+            end.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n+        }\n+\n+        ast::ExprVec(ref init_expressions) |\n+        ast::ExprTup(ref init_expressions) => {\n+            for ie in init_expressions {\n+                walk_expr(cx, &**ie, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::ExprAssign(ref sub_exp1, ref sub_exp2) |\n+        ast::ExprRepeat(ref sub_exp1, ref sub_exp2) => {\n+            walk_expr(cx, &**sub_exp1, scope_stack, scope_map);\n+            walk_expr(cx, &**sub_exp2, scope_stack, scope_map);\n+        }\n+\n+        ast::ExprIf(ref cond_exp, ref then_block, ref opt_else_exp) => {\n+            walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n+\n+            with_new_scope(cx,\n+                           then_block.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                walk_block(cx, &**then_block, scope_stack, scope_map);\n+            });\n+\n+            match *opt_else_exp {\n+                Some(ref else_exp) =>\n+                    walk_expr(cx, &**else_exp, scope_stack, scope_map),\n+                _ => ()\n+            }\n+        }\n+\n+        ast::ExprIfLet(..) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded if-let.\");\n+        }\n+\n+        ast::ExprWhile(ref cond_exp, ref loop_body, _) => {\n+            walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n+\n+            with_new_scope(cx,\n+                           loop_body.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                walk_block(cx, &**loop_body, scope_stack, scope_map);\n+            })\n+        }\n+\n+        ast::ExprWhileLet(..) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded while-let.\");\n+        }\n+\n+        ast::ExprForLoop(..) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded for loop.\");\n+        }\n+\n+        ast::ExprMac(_) => {\n+            cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n+                                          Found unexpanded macro.\");\n+        }\n+\n+        ast::ExprLoop(ref block, _) |\n+        ast::ExprBlock(ref block)   => {\n+            with_new_scope(cx,\n+                           block.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                walk_block(cx, &**block, scope_stack, scope_map);\n+            })\n+        }\n+\n+        ast::ExprClosure(_, ref decl, ref block) => {\n+            with_new_scope(cx,\n+                           block.span,\n+                           scope_stack,\n+                           scope_map,\n+                           |cx, scope_stack, scope_map| {\n+                for &ast::Arg { pat: ref pattern, .. } in &decl.inputs {\n+                    walk_pattern(cx, &**pattern, scope_stack, scope_map);\n+                }\n+\n+                walk_block(cx, &**block, scope_stack, scope_map);\n+            })\n+        }\n+\n+        ast::ExprCall(ref fn_exp, ref args) => {\n+            walk_expr(cx, &**fn_exp, scope_stack, scope_map);\n+\n+            for arg_exp in args {\n+                walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::ExprMethodCall(_, _, ref args) => {\n+            for arg_exp in args {\n+                walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n+            }\n+        }\n+\n+        ast::ExprMatch(ref discriminant_exp, ref arms, _) => {\n+            walk_expr(cx, &**discriminant_exp, scope_stack, scope_map);\n+\n+            // For each arm we have to first walk the pattern as these might\n+            // introduce new artificial scopes. It should be sufficient to\n+            // walk only one pattern per arm, as they all must contain the\n+            // same binding names.\n+\n+            for arm_ref in arms {\n+                let arm_span = arm_ref.pats[0].span;\n+\n+                with_new_scope(cx,\n+                               arm_span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n+                    for pat in &arm_ref.pats {\n+                        walk_pattern(cx, &**pat, scope_stack, scope_map);\n+                    }\n+\n+                    if let Some(ref guard_exp) = arm_ref.guard {\n+                        walk_expr(cx, &**guard_exp, scope_stack, scope_map)\n+                    }\n+\n+                    walk_expr(cx, &*arm_ref.body, scope_stack, scope_map);\n+                })\n+            }\n+        }\n+\n+        ast::ExprStruct(_, ref fields, ref base_exp) => {\n+            for &ast::Field { expr: ref exp, .. } in fields {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+\n+            match *base_exp {\n+                Some(ref exp) => walk_expr(cx, &**exp, scope_stack, scope_map),\n+                None => ()\n+            }\n+        }\n+\n+        ast::ExprInlineAsm(ast::InlineAsm { ref inputs,\n+                                            ref outputs,\n+                                            .. }) => {\n+            // inputs, outputs: Vec<(String, P<Expr>)>\n+            for &(_, ref exp) in inputs {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+\n+            for &(_, ref exp, _) in outputs {\n+                walk_expr(cx, &**exp, scope_stack, scope_map);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "9ff69e7f9dd294c2f43ba57f0dd28130e4fee0c5", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 1564, "deletions": 17, "changes": 1581, "blob_url": "https://github.com/rust-lang/rust/blob/7bfb5ed826c3fa6544865095f3f9158d95efb3a3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfb5ed826c3fa6544865095f3f9158d95efb3a3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=7bfb5ed826c3fa6544865095f3f9158d95efb3a3", "patch": "@@ -8,32 +8,43 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use self::RecursiveTypeDescription::*;\n+use self::MemberOffset::*;\n+use self::MemberDescriptionFactory::*;\n+use self::EnumDiscriminantInfo::*;\n+\n use super::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n-                   get_namespace_and_span_for_item};\n-use super::{UNKNOWN_FILE_METADATA, UNKNOWN_SCOPE_METADATA,\n-            UniqueTypeId, FLAGS_NONE};\n-use super::types::compute_debuginfo_type_name;\n-use super::create::create_DIArray;\n-use super::adt::{prepare_struct_metadata, prepare_tuple_metadata, prepare_enum_metadata,\n-                 composite_type_metadata, MemberDescription};\n-use super::adt::MemberOffset::ComputedMemberOffset;\n-\n-use llvm;\n-use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor};\n-use trans::type_of;\n-use trans::common::{CrateContext, FunctionContext, NormalizingClosureTyper};\n+                   get_namespace_and_span_for_item, create_DIArray,\n+                   fn_should_be_ignored, is_node_local_to_unit};\n+use super::namespace::namespace_for_item;\n+use super::type_names::{compute_debuginfo_type_name, push_debuginfo_type_name};\n+use super::{declare_local, VariableKind, VariableAccess};\n+\n+use llvm::{self, ValueRef};\n+use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType};\n+\n+use metadata::csearch;\n+use middle::pat_util;\n+use middle::subst::{self, Substs};\n+use trans::{type_of, adt, machine, monomorphize};\n+use trans::common::{self, CrateContext, FunctionContext, NormalizingClosureTyper, Block};\n+use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use trans::type_::Type;\n use middle::ty::{self, Ty, ClosureTyper};\n-use session::config;\n+use session::config::{self, FullDebugInfo};\n+use util::nodemap::FnvHashMap;\n use util::ppaux;\n use util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n use std::path::Path;\n use std::ptr;\n+use std::rc::Rc;\n+use syntax::util::interner::Interner;\n use syntax::codemap::Span;\n-use syntax::{ast, codemap};\n+use syntax::{ast, codemap, ast_util, ast_map};\n+use syntax::parse::token::{self, special_idents};\n \n \n const DW_LANG_RUST: c_uint = 0x9000;\n@@ -48,6 +59,457 @@ const DW_ATE_unsigned: c_uint = 0x07;\n #[allow(non_upper_case_globals)]\n const DW_ATE_unsigned_char: c_uint = 0x08;\n \n+pub const UNKNOWN_LINE_NUMBER: c_uint = 0;\n+pub const UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n+\n+// ptr::null() doesn't work :(\n+const UNKNOWN_FILE_METADATA: DIFile = (0 as DIFile);\n+const UNKNOWN_SCOPE_METADATA: DIScope = (0 as DIScope);\n+\n+const FLAGS_NONE: c_uint = 0;\n+\n+#[derive(Copy, Debug, Hash, Eq, PartialEq, Clone)]\n+pub struct UniqueTypeId(ast::Name);\n+\n+// The TypeMap is where the CrateDebugContext holds the type metadata nodes\n+// created so far. The metadata nodes are indexed by UniqueTypeId, and, for\n+// faster lookup, also by Ty. The TypeMap is responsible for creating\n+// UniqueTypeIds.\n+pub struct TypeMap<'tcx> {\n+    // The UniqueTypeIds created so far\n+    unique_id_interner: Interner<Rc<String>>,\n+    // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n+    unique_id_to_metadata: FnvHashMap<UniqueTypeId, DIType>,\n+    // A map from types to debuginfo metadata. This is a N:1 mapping.\n+    type_to_metadata: FnvHashMap<Ty<'tcx>, DIType>,\n+    // A map from types to UniqueTypeId. This is a N:1 mapping.\n+    type_to_unique_id: FnvHashMap<Ty<'tcx>, UniqueTypeId>\n+}\n+\n+impl<'tcx> TypeMap<'tcx> {\n+    pub fn new() -> TypeMap<'tcx> {\n+        TypeMap {\n+            unique_id_interner: Interner::new(),\n+            type_to_metadata: FnvHashMap(),\n+            unique_id_to_metadata: FnvHashMap(),\n+            type_to_unique_id: FnvHashMap(),\n+        }\n+    }\n+\n+    // Adds a Ty to metadata mapping to the TypeMap. The method will fail if\n+    // the mapping already exists.\n+    fn register_type_with_metadata<'a>(&mut self,\n+                                       cx: &CrateContext<'a, 'tcx>,\n+                                       type_: Ty<'tcx>,\n+                                       metadata: DIType) {\n+        if self.type_to_metadata.insert(type_, metadata).is_some() {\n+            cx.sess().bug(&format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n+                                   ppaux::ty_to_string(cx.tcx(), type_)));\n+        }\n+    }\n+\n+    // Adds a UniqueTypeId to metadata mapping to the TypeMap. The method will\n+    // fail if the mapping already exists.\n+    fn register_unique_id_with_metadata(&mut self,\n+                                        cx: &CrateContext,\n+                                        unique_type_id: UniqueTypeId,\n+                                        metadata: DIType) {\n+        if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n+            let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n+            cx.sess().bug(&format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n+                                  &unique_type_id_str[..]));\n+        }\n+    }\n+\n+    fn find_metadata_for_type(&self, type_: Ty<'tcx>) -> Option<DIType> {\n+        self.type_to_metadata.get(&type_).cloned()\n+    }\n+\n+    fn find_metadata_for_unique_id(&self, unique_type_id: UniqueTypeId) -> Option<DIType> {\n+        self.unique_id_to_metadata.get(&unique_type_id).cloned()\n+    }\n+\n+    // Get the string representation of a UniqueTypeId. This method will fail if\n+    // the id is unknown.\n+    fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> Rc<String> {\n+        let UniqueTypeId(interner_key) = unique_type_id;\n+        self.unique_id_interner.get(interner_key)\n+    }\n+\n+    // Get the UniqueTypeId for the given type. If the UniqueTypeId for the given\n+    // type has been requested before, this is just a table lookup. Otherwise an\n+    // ID will be generated and stored for later lookup.\n+    fn get_unique_type_id_of_type<'a>(&mut self, cx: &CrateContext<'a, 'tcx>,\n+                                      type_: Ty<'tcx>) -> UniqueTypeId {\n+\n+        // basic type           -> {:name of the type:}\n+        // tuple                -> {tuple_(:param-uid:)*}\n+        // struct               -> {struct_:svh: / :node-id:_<(:param-uid:),*> }\n+        // enum                 -> {enum_:svh: / :node-id:_<(:param-uid:),*> }\n+        // enum variant         -> {variant_:variant-name:_:enum-uid:}\n+        // reference (&)        -> {& :pointee-uid:}\n+        // mut reference (&mut) -> {&mut :pointee-uid:}\n+        // ptr (*)              -> {* :pointee-uid:}\n+        // mut ptr (*mut)       -> {*mut :pointee-uid:}\n+        // unique ptr (~)       -> {~ :pointee-uid:}\n+        // @-ptr (@)            -> {@ :pointee-uid:}\n+        // sized vec ([T; x])   -> {[:size:] :element-uid:}\n+        // unsized vec ([T])    -> {[] :element-uid:}\n+        // trait (T)            -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n+        // closure              -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n+        //                             :return-type-uid: : (:bounds:)*}\n+        // function             -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n+        //                             :return-type-uid:}\n+        // unique vec box (~[]) -> {HEAP_VEC_BOX<:pointee-uid:>}\n+        // gc box               -> {GC_BOX<:pointee-uid:>}\n+\n+        match self.type_to_unique_id.get(&type_).cloned() {\n+            Some(unique_type_id) => return unique_type_id,\n+            None => { /* generate one */}\n+        };\n+\n+        let mut unique_type_id = String::with_capacity(256);\n+        unique_type_id.push('{');\n+\n+        match type_.sty {\n+            ty::ty_bool     |\n+            ty::ty_char     |\n+            ty::ty_str      |\n+            ty::ty_int(_)   |\n+            ty::ty_uint(_)  |\n+            ty::ty_float(_) => {\n+                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n+            },\n+            ty::ty_enum(def_id, substs) => {\n+                unique_type_id.push_str(\"enum \");\n+                from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n+            },\n+            ty::ty_struct(def_id, substs) => {\n+                unique_type_id.push_str(\"struct \");\n+                from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n+            },\n+            ty::ty_tup(ref component_types) if component_types.is_empty() => {\n+                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n+            },\n+            ty::ty_tup(ref component_types) => {\n+                unique_type_id.push_str(\"tuple \");\n+                for &component_type in component_types {\n+                    let component_type_id =\n+                        self.get_unique_type_id_of_type(cx, component_type);\n+                    let component_type_id =\n+                        self.get_unique_type_id_as_string(component_type_id);\n+                    unique_type_id.push_str(&component_type_id[..]);\n+                }\n+            },\n+            ty::ty_uniq(inner_type) => {\n+                unique_type_id.push('~');\n+                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n+                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n+                unique_type_id.push_str(&inner_type_id[..]);\n+            },\n+            ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n+                unique_type_id.push('*');\n+                if mutbl == ast::MutMutable {\n+                    unique_type_id.push_str(\"mut\");\n+                }\n+\n+                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n+                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n+                unique_type_id.push_str(&inner_type_id[..]);\n+            },\n+            ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n+                unique_type_id.push('&');\n+                if mutbl == ast::MutMutable {\n+                    unique_type_id.push_str(\"mut\");\n+                }\n+\n+                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n+                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n+                unique_type_id.push_str(&inner_type_id[..]);\n+            },\n+            ty::ty_vec(inner_type, optional_length) => {\n+                match optional_length {\n+                    Some(len) => {\n+                        unique_type_id.push_str(&format!(\"[{}]\", len));\n+                    }\n+                    None => {\n+                        unique_type_id.push_str(\"[]\");\n+                    }\n+                };\n+\n+                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n+                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n+                unique_type_id.push_str(&inner_type_id[..]);\n+            },\n+            ty::ty_trait(ref trait_data) => {\n+                unique_type_id.push_str(\"trait \");\n+\n+                let principal =\n+                    ty::erase_late_bound_regions(cx.tcx(),\n+                                                 &trait_data.principal);\n+\n+                from_def_id_and_substs(self,\n+                                       cx,\n+                                       principal.def_id,\n+                                       principal.substs,\n+                                       &mut unique_type_id);\n+            },\n+            ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+                if unsafety == ast::Unsafety::Unsafe {\n+                    unique_type_id.push_str(\"unsafe \");\n+                }\n+\n+                unique_type_id.push_str(abi.name());\n+\n+                unique_type_id.push_str(\" fn(\");\n+\n+                let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+\n+                for &parameter_type in &sig.inputs {\n+                    let parameter_type_id =\n+                        self.get_unique_type_id_of_type(cx, parameter_type);\n+                    let parameter_type_id =\n+                        self.get_unique_type_id_as_string(parameter_type_id);\n+                    unique_type_id.push_str(&parameter_type_id[..]);\n+                    unique_type_id.push(',');\n+                }\n+\n+                if sig.variadic {\n+                    unique_type_id.push_str(\"...\");\n+                }\n+\n+                unique_type_id.push_str(\")->\");\n+                match sig.output {\n+                    ty::FnConverging(ret_ty) => {\n+                        let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n+                        let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n+                        unique_type_id.push_str(&return_type_id[..]);\n+                    }\n+                    ty::FnDiverging => {\n+                        unique_type_id.push_str(\"!\");\n+                    }\n+                }\n+            },\n+            ty::ty_closure(def_id, substs) => {\n+                let typer = NormalizingClosureTyper::new(cx.tcx());\n+                let closure_ty = typer.closure_type(def_id, substs);\n+                self.get_unique_type_id_of_closure_type(cx,\n+                                                        closure_ty,\n+                                                        &mut unique_type_id);\n+            },\n+            _ => {\n+                cx.sess().bug(&format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n+                                      &ppaux::ty_to_string(cx.tcx(), type_),\n+                                      type_.sty))\n+            }\n+        };\n+\n+        unique_type_id.push('}');\n+\n+        // Trim to size before storing permanently\n+        unique_type_id.shrink_to_fit();\n+\n+        let key = self.unique_id_interner.intern(Rc::new(unique_type_id));\n+        self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n+\n+        return UniqueTypeId(key);\n+\n+        fn from_def_id_and_substs<'a, 'tcx>(type_map: &mut TypeMap<'tcx>,\n+                                            cx: &CrateContext<'a, 'tcx>,\n+                                            def_id: ast::DefId,\n+                                            substs: &subst::Substs<'tcx>,\n+                                            output: &mut String) {\n+            // First, find out the 'real' def_id of the type. Items inlined from\n+            // other crates have to be mapped back to their source.\n+            let source_def_id = if def_id.krate == ast::LOCAL_CRATE {\n+                match cx.external_srcs().borrow().get(&def_id.node).cloned() {\n+                    Some(source_def_id) => {\n+                        // The given def_id identifies the inlined copy of a\n+                        // type definition, let's take the source of the copy.\n+                        source_def_id\n+                    }\n+                    None => def_id\n+                }\n+            } else {\n+                def_id\n+            };\n+\n+            // Get the crate hash as first part of the identifier.\n+            let crate_hash = if source_def_id.krate == ast::LOCAL_CRATE {\n+                cx.link_meta().crate_hash.clone()\n+            } else {\n+                cx.sess().cstore.get_crate_hash(source_def_id.krate)\n+            };\n+\n+            output.push_str(crate_hash.as_str());\n+            output.push_str(\"/\");\n+            output.push_str(&format!(\"{:x}\", def_id.node));\n+\n+            // Maybe check that there is no self type here.\n+\n+            let tps = substs.types.get_slice(subst::TypeSpace);\n+            if !tps.is_empty() {\n+                output.push('<');\n+\n+                for &type_parameter in tps {\n+                    let param_type_id =\n+                        type_map.get_unique_type_id_of_type(cx, type_parameter);\n+                    let param_type_id =\n+                        type_map.get_unique_type_id_as_string(param_type_id);\n+                    output.push_str(&param_type_id[..]);\n+                    output.push(',');\n+                }\n+\n+                output.push('>');\n+            }\n+        }\n+    }\n+\n+    fn get_unique_type_id_of_closure_type<'a>(&mut self,\n+                                              cx: &CrateContext<'a, 'tcx>,\n+                                              closure_ty: ty::ClosureTy<'tcx>,\n+                                              unique_type_id: &mut String) {\n+        let ty::ClosureTy { unsafety,\n+                            ref sig,\n+                            abi: _ } = closure_ty;\n+\n+        if unsafety == ast::Unsafety::Unsafe {\n+            unique_type_id.push_str(\"unsafe \");\n+        }\n+\n+        unique_type_id.push_str(\"|\");\n+\n+        let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+\n+        for &parameter_type in &sig.inputs {\n+            let parameter_type_id =\n+                self.get_unique_type_id_of_type(cx, parameter_type);\n+            let parameter_type_id =\n+                self.get_unique_type_id_as_string(parameter_type_id);\n+            unique_type_id.push_str(&parameter_type_id[..]);\n+            unique_type_id.push(',');\n+        }\n+\n+        if sig.variadic {\n+            unique_type_id.push_str(\"...\");\n+        }\n+\n+        unique_type_id.push_str(\"|->\");\n+\n+        match sig.output {\n+            ty::FnConverging(ret_ty) => {\n+                let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n+                let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n+                unique_type_id.push_str(&return_type_id[..]);\n+            }\n+            ty::FnDiverging => {\n+                unique_type_id.push_str(\"!\");\n+            }\n+        }\n+    }\n+\n+    // Get the UniqueTypeId for an enum variant. Enum variants are not really\n+    // types of their own, so they need special handling. We still need a\n+    // UniqueTypeId for them, since to debuginfo they *are* real types.\n+    fn get_unique_type_id_of_enum_variant<'a>(&mut self,\n+                                              cx: &CrateContext<'a, 'tcx>,\n+                                              enum_type: Ty<'tcx>,\n+                                              variant_name: &str)\n+                                              -> UniqueTypeId {\n+        let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n+        let enum_variant_type_id = format!(\"{}::{}\",\n+                                           &self.get_unique_type_id_as_string(enum_type_id),\n+                                           variant_name);\n+        let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n+        UniqueTypeId(interner_key)\n+    }\n+}\n+\n+// A description of some recursive type. It can either be already finished (as\n+// with FinalMetadata) or it is not yet finished, but contains all information\n+// needed to generate the missing parts of the description. See the\n+// documentation section on Recursive Types at the top of this file for more\n+// information.\n+enum RecursiveTypeDescription<'tcx> {\n+    UnfinishedMetadata {\n+        unfinished_type: Ty<'tcx>,\n+        unique_type_id: UniqueTypeId,\n+        metadata_stub: DICompositeType,\n+        llvm_type: Type,\n+        member_description_factory: MemberDescriptionFactory<'tcx>,\n+    },\n+    FinalMetadata(DICompositeType)\n+}\n+\n+fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n+    cx: &CrateContext<'a, 'tcx>,\n+    unfinished_type: Ty<'tcx>,\n+    unique_type_id: UniqueTypeId,\n+    metadata_stub: DICompositeType,\n+    llvm_type: Type,\n+    member_description_factory: MemberDescriptionFactory<'tcx>)\n+ -> RecursiveTypeDescription<'tcx> {\n+\n+    // Insert the stub into the TypeMap in order to allow for recursive references\n+    let mut type_map = debug_context(cx).type_map.borrow_mut();\n+    type_map.register_unique_id_with_metadata(cx, unique_type_id, metadata_stub);\n+    type_map.register_type_with_metadata(cx, unfinished_type, metadata_stub);\n+\n+    UnfinishedMetadata {\n+        unfinished_type: unfinished_type,\n+        unique_type_id: unique_type_id,\n+        metadata_stub: metadata_stub,\n+        llvm_type: llvm_type,\n+        member_description_factory: member_description_factory,\n+    }\n+}\n+\n+impl<'tcx> RecursiveTypeDescription<'tcx> {\n+    // Finishes up the description of the type in question (mostly by providing\n+    // descriptions of the fields of the given type) and returns the final type\n+    // metadata.\n+    fn finalize<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> MetadataCreationResult {\n+        match *self {\n+            FinalMetadata(metadata) => MetadataCreationResult::new(metadata, false),\n+            UnfinishedMetadata {\n+                unfinished_type,\n+                unique_type_id,\n+                metadata_stub,\n+                llvm_type,\n+                ref member_description_factory,\n+                ..\n+            } => {\n+                // Make sure that we have a forward declaration of the type in\n+                // the TypeMap so that recursive references are possible. This\n+                // will always be the case if the RecursiveTypeDescription has\n+                // been properly created through the\n+                // create_and_register_recursive_type_forward_declaration()\n+                // function.\n+                {\n+                    let type_map = debug_context(cx).type_map.borrow();\n+                    if type_map.find_metadata_for_unique_id(unique_type_id).is_none() ||\n+                       type_map.find_metadata_for_type(unfinished_type).is_none() {\n+                        cx.sess().bug(&format!(\"Forward declaration of potentially recursive type \\\n+                                              '{}' was not found in TypeMap!\",\n+                                              ppaux::ty_to_string(cx.tcx(), unfinished_type))\n+                                      );\n+                    }\n+                }\n+\n+                // ... then create the member descriptions ...\n+                let member_descriptions =\n+                    member_description_factory.create_member_descriptions(cx);\n+\n+                // ... and attach them to the stub to complete it.\n+                set_members_of_composite_type(cx,\n+                                              metadata_stub,\n+                                              llvm_type,\n+                                              &member_descriptions[..]);\n+                return MetadataCreationResult::new(metadata_stub, true);\n+            }\n+        }\n+    }\n+}\n \n // Returns from the enclosing function if the type metadata with the given\n // unique id can be found in the type map\n@@ -584,16 +1046,1101 @@ pub fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n     }\n }\n \n-pub struct MetadataCreationResult {\n+struct MetadataCreationResult {\n     metadata: DIType,\n     already_stored_in_typemap: bool\n }\n \n impl MetadataCreationResult {\n-    pub fn new(metadata: DIType, already_stored_in_typemap: bool) -> MetadataCreationResult {\n+    fn new(metadata: DIType, already_stored_in_typemap: bool) -> MetadataCreationResult {\n         MetadataCreationResult {\n             metadata: metadata,\n             already_stored_in_typemap: already_stored_in_typemap\n         }\n     }\n }\n+\n+enum MemberOffset {\n+    FixedMemberOffset { bytes: usize },\n+    // For ComputedMemberOffset, the offset is read from the llvm type definition.\n+    ComputedMemberOffset\n+}\n+\n+// Description of a type member, which can either be a regular field (as in\n+// structs or tuples) or an enum variant.\n+struct MemberDescription {\n+    name: String,\n+    llvm_type: Type,\n+    type_metadata: DIType,\n+    offset: MemberOffset,\n+    flags: c_uint\n+}\n+\n+// A factory for MemberDescriptions. It produces a list of member descriptions\n+// for some record-like type. MemberDescriptionFactories are used to defer the\n+// creation of type member descriptions in order to break cycles arising from\n+// recursive type definitions.\n+enum MemberDescriptionFactory<'tcx> {\n+    StructMDF(StructMemberDescriptionFactory<'tcx>),\n+    TupleMDF(TupleMemberDescriptionFactory<'tcx>),\n+    EnumMDF(EnumMemberDescriptionFactory<'tcx>),\n+    VariantMDF(VariantMemberDescriptionFactory<'tcx>)\n+}\n+\n+impl<'tcx> MemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n+        match *self {\n+            StructMDF(ref this) => {\n+                this.create_member_descriptions(cx)\n+            }\n+            TupleMDF(ref this) => {\n+                this.create_member_descriptions(cx)\n+            }\n+            EnumMDF(ref this) => {\n+                this.create_member_descriptions(cx)\n+            }\n+            VariantMDF(ref this) => {\n+                this.create_member_descriptions(cx)\n+            }\n+        }\n+    }\n+}\n+\n+//=-----------------------------------------------------------------------------\n+// Structs\n+//=-----------------------------------------------------------------------------\n+\n+// Creates MemberDescriptions for the fields of a struct\n+struct StructMemberDescriptionFactory<'tcx> {\n+    fields: Vec<ty::field<'tcx>>,\n+    is_simd: bool,\n+    span: Span,\n+}\n+\n+impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n+        if self.fields.is_empty() {\n+            return Vec::new();\n+        }\n+\n+        let field_size = if self.is_simd {\n+            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields[0].mt.ty)) as usize\n+        } else {\n+            0xdeadbeef\n+        };\n+\n+        self.fields.iter().enumerate().map(|(i, field)| {\n+            let name = if field.name == special_idents::unnamed_field.name {\n+                format!(\"__{}\", i)\n+            } else {\n+                token::get_name(field.name).to_string()\n+            };\n+\n+            let offset = if self.is_simd {\n+                assert!(field_size != 0xdeadbeef);\n+                FixedMemberOffset { bytes: i * field_size }\n+            } else {\n+                ComputedMemberOffset\n+            };\n+\n+            MemberDescription {\n+                name: name,\n+                llvm_type: type_of::type_of(cx, field.mt.ty),\n+                type_metadata: type_metadata(cx, field.mt.ty, self.span),\n+                offset: offset,\n+                flags: FLAGS_NONE,\n+            }\n+        }).collect()\n+    }\n+}\n+\n+\n+fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                     struct_type: Ty<'tcx>,\n+                                     def_id: ast::DefId,\n+                                     substs: &subst::Substs<'tcx>,\n+                                     unique_type_id: UniqueTypeId,\n+                                     span: Span)\n+                                     -> RecursiveTypeDescription<'tcx> {\n+    let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n+    let struct_llvm_type = type_of::type_of(cx, struct_type);\n+\n+    let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n+\n+    let struct_metadata_stub = create_struct_stub(cx,\n+                                                  struct_llvm_type,\n+                                                  &struct_name[..],\n+                                                  unique_type_id,\n+                                                  containing_scope);\n+\n+    let mut fields = ty::struct_fields(cx.tcx(), def_id, substs);\n+\n+    // The `Ty` values returned by `ty::struct_fields` can still contain\n+    // `ty_projection` variants, so normalize those away.\n+    for field in &mut fields {\n+        field.mt.ty = monomorphize::normalize_associated_type(cx.tcx(), &field.mt.ty);\n+    }\n+\n+    create_and_register_recursive_type_forward_declaration(\n+        cx,\n+        struct_type,\n+        unique_type_id,\n+        struct_metadata_stub,\n+        struct_llvm_type,\n+        StructMDF(StructMemberDescriptionFactory {\n+            fields: fields,\n+            is_simd: ty::type_is_simd(cx.tcx(), struct_type),\n+            span: span,\n+        })\n+    )\n+}\n+\n+\n+//=-----------------------------------------------------------------------------\n+// Tuples\n+//=-----------------------------------------------------------------------------\n+\n+// Creates MemberDescriptions for the fields of a tuple\n+struct TupleMemberDescriptionFactory<'tcx> {\n+    component_types: Vec<Ty<'tcx>>,\n+    span: Span,\n+}\n+\n+impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n+        self.component_types\n+            .iter()\n+            .enumerate()\n+            .map(|(i, &component_type)| {\n+            MemberDescription {\n+                name: format!(\"__{}\", i),\n+                llvm_type: type_of::type_of(cx, component_type),\n+                type_metadata: type_metadata(cx, component_type, self.span),\n+                offset: ComputedMemberOffset,\n+                flags: FLAGS_NONE,\n+            }\n+        }).collect()\n+    }\n+}\n+\n+fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                    tuple_type: Ty<'tcx>,\n+                                    component_types: &[Ty<'tcx>],\n+                                    unique_type_id: UniqueTypeId,\n+                                    span: Span)\n+                                    -> RecursiveTypeDescription<'tcx> {\n+    let tuple_name = compute_debuginfo_type_name(cx, tuple_type, false);\n+    let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n+\n+    create_and_register_recursive_type_forward_declaration(\n+        cx,\n+        tuple_type,\n+        unique_type_id,\n+        create_struct_stub(cx,\n+                           tuple_llvm_type,\n+                           &tuple_name[..],\n+                           unique_type_id,\n+                           UNKNOWN_SCOPE_METADATA),\n+        tuple_llvm_type,\n+        TupleMDF(TupleMemberDescriptionFactory {\n+            component_types: component_types.to_vec(),\n+            span: span,\n+        })\n+    )\n+}\n+\n+\n+//=-----------------------------------------------------------------------------\n+// Enums\n+//=-----------------------------------------------------------------------------\n+\n+// Describes the members of an enum value: An enum is described as a union of\n+// structs in DWARF. This MemberDescriptionFactory provides the description for\n+// the members of this union; so for every variant of the given enum, this\n+// factory will produce one MemberDescription (all with no name and a fixed\n+// offset of zero bytes).\n+struct EnumMemberDescriptionFactory<'tcx> {\n+    enum_type: Ty<'tcx>,\n+    type_rep: Rc<adt::Repr<'tcx>>,\n+    variants: Rc<Vec<Rc<ty::VariantInfo<'tcx>>>>,\n+    discriminant_type_metadata: Option<DIType>,\n+    containing_scope: DIScope,\n+    file_metadata: DIFile,\n+    span: Span,\n+}\n+\n+impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n+        match *self.type_rep {\n+            adt::General(_, ref struct_defs, _) => {\n+                let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n+                    .expect(\"\"));\n+\n+                struct_defs\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, struct_def)| {\n+                        let (variant_type_metadata,\n+                             variant_llvm_type,\n+                             member_desc_factory) =\n+                            describe_enum_variant(cx,\n+                                                  self.enum_type,\n+                                                  struct_def,\n+                                                  &*(*self.variants)[i],\n+                                                  discriminant_info,\n+                                                  self.containing_scope,\n+                                                  self.span);\n+\n+                        let member_descriptions = member_desc_factory\n+                            .create_member_descriptions(cx);\n+\n+                        set_members_of_composite_type(cx,\n+                                                      variant_type_metadata,\n+                                                      variant_llvm_type,\n+                                                      &member_descriptions[..]);\n+                        MemberDescription {\n+                            name: \"\".to_string(),\n+                            llvm_type: variant_llvm_type,\n+                            type_metadata: variant_type_metadata,\n+                            offset: FixedMemberOffset { bytes: 0 },\n+                            flags: FLAGS_NONE\n+                        }\n+                    }).collect()\n+            },\n+            adt::Univariant(ref struct_def, _) => {\n+                assert!(self.variants.len() <= 1);\n+\n+                if self.variants.is_empty() {\n+                    vec![]\n+                } else {\n+                    let (variant_type_metadata,\n+                         variant_llvm_type,\n+                         member_description_factory) =\n+                        describe_enum_variant(cx,\n+                                              self.enum_type,\n+                                              struct_def,\n+                                              &*(*self.variants)[0],\n+                                              NoDiscriminant,\n+                                              self.containing_scope,\n+                                              self.span);\n+\n+                    let member_descriptions =\n+                        member_description_factory.create_member_descriptions(cx);\n+\n+                    set_members_of_composite_type(cx,\n+                                                  variant_type_metadata,\n+                                                  variant_llvm_type,\n+                                                  &member_descriptions[..]);\n+                    vec![\n+                        MemberDescription {\n+                            name: \"\".to_string(),\n+                            llvm_type: variant_llvm_type,\n+                            type_metadata: variant_type_metadata,\n+                            offset: FixedMemberOffset { bytes: 0 },\n+                            flags: FLAGS_NONE\n+                        }\n+                    ]\n+                }\n+            }\n+            adt::RawNullablePointer { nndiscr: non_null_variant_index, nnty, .. } => {\n+                // As far as debuginfo is concerned, the pointer this enum\n+                // represents is still wrapped in a struct. This is to make the\n+                // DWARF representation of enums uniform.\n+\n+                // First create a description of the artificial wrapper struct:\n+                let non_null_variant = &(*self.variants)[non_null_variant_index as usize];\n+                let non_null_variant_name = token::get_name(non_null_variant.name);\n+\n+                // The llvm type and metadata of the pointer\n+                let non_null_llvm_type = type_of::type_of(cx, nnty);\n+                let non_null_type_metadata = type_metadata(cx, nnty, self.span);\n+\n+                // The type of the artificial struct wrapping the pointer\n+                let artificial_struct_llvm_type = Type::struct_(cx,\n+                                                                &[non_null_llvm_type],\n+                                                                false);\n+\n+                // For the metadata of the wrapper struct, we need to create a\n+                // MemberDescription of the struct's single field.\n+                let sole_struct_member_description = MemberDescription {\n+                    name: match non_null_variant.arg_names {\n+                        Some(ref names) => token::get_name(names[0]).to_string(),\n+                        None => \"__0\".to_string()\n+                    },\n+                    llvm_type: non_null_llvm_type,\n+                    type_metadata: non_null_type_metadata,\n+                    offset: FixedMemberOffset { bytes: 0 },\n+                    flags: FLAGS_NONE\n+                };\n+\n+                let unique_type_id = debug_context(cx).type_map\n+                                                      .borrow_mut()\n+                                                      .get_unique_type_id_of_enum_variant(\n+                                                          cx,\n+                                                          self.enum_type,\n+                                                          &non_null_variant_name);\n+\n+                // Now we can create the metadata of the artificial struct\n+                let artificial_struct_metadata =\n+                    composite_type_metadata(cx,\n+                                            artificial_struct_llvm_type,\n+                                            &non_null_variant_name,\n+                                            unique_type_id,\n+                                            &[sole_struct_member_description],\n+                                            self.containing_scope,\n+                                            self.file_metadata,\n+                                            codemap::DUMMY_SP);\n+\n+                // Encode the information about the null variant in the union\n+                // member's name.\n+                let null_variant_index = (1 - non_null_variant_index) as usize;\n+                let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n+                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n+                                                0,\n+                                                null_variant_name);\n+\n+                // Finally create the (singleton) list of descriptions of union\n+                // members.\n+                vec![\n+                    MemberDescription {\n+                        name: union_member_name,\n+                        llvm_type: artificial_struct_llvm_type,\n+                        type_metadata: artificial_struct_metadata,\n+                        offset: FixedMemberOffset { bytes: 0 },\n+                        flags: FLAGS_NONE\n+                    }\n+                ]\n+            },\n+            adt::StructWrappedNullablePointer { nonnull: ref struct_def,\n+                                                nndiscr,\n+                                                ref discrfield, ..} => {\n+                // Create a description of the non-null variant\n+                let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n+                    describe_enum_variant(cx,\n+                                          self.enum_type,\n+                                          struct_def,\n+                                          &*(*self.variants)[nndiscr as usize],\n+                                          OptimizedDiscriminant,\n+                                          self.containing_scope,\n+                                          self.span);\n+\n+                let variant_member_descriptions =\n+                    member_description_factory.create_member_descriptions(cx);\n+\n+                set_members_of_composite_type(cx,\n+                                              variant_type_metadata,\n+                                              variant_llvm_type,\n+                                              &variant_member_descriptions[..]);\n+\n+                // Encode the information about the null variant in the union\n+                // member's name.\n+                let null_variant_index = (1 - nndiscr) as usize;\n+                let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n+                let discrfield = discrfield.iter()\n+                                           .skip(1)\n+                                           .map(|x| x.to_string())\n+                                           .collect::<Vec<_>>().connect(\"$\");\n+                let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n+                                                discrfield,\n+                                                null_variant_name);\n+\n+                // Create the (singleton) list of descriptions of union members.\n+                vec![\n+                    MemberDescription {\n+                        name: union_member_name,\n+                        llvm_type: variant_llvm_type,\n+                        type_metadata: variant_type_metadata,\n+                        offset: FixedMemberOffset { bytes: 0 },\n+                        flags: FLAGS_NONE\n+                    }\n+                ]\n+            },\n+            adt::CEnum(..) => cx.sess().span_bug(self.span, \"This should be unreachable.\")\n+        }\n+    }\n+}\n+\n+// Creates MemberDescriptions for the fields of a single enum variant.\n+struct VariantMemberDescriptionFactory<'tcx> {\n+    args: Vec<(String, Ty<'tcx>)>,\n+    discriminant_type_metadata: Option<DIType>,\n+    span: Span,\n+}\n+\n+impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n+        self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n+            MemberDescription {\n+                name: name.to_string(),\n+                llvm_type: type_of::type_of(cx, ty),\n+                type_metadata: match self.discriminant_type_metadata {\n+                    Some(metadata) if i == 0 => metadata,\n+                    _ => type_metadata(cx, ty, self.span)\n+                },\n+                offset: ComputedMemberOffset,\n+                flags: FLAGS_NONE\n+            }\n+        }).collect()\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+enum EnumDiscriminantInfo {\n+    RegularDiscriminant(DIType),\n+    OptimizedDiscriminant,\n+    NoDiscriminant\n+}\n+\n+// Returns a tuple of (1) type_metadata_stub of the variant, (2) the llvm_type\n+// of the variant, and (3) a MemberDescriptionFactory for producing the\n+// descriptions of the fields of the variant. This is a rudimentary version of a\n+// full RecursiveTypeDescription.\n+fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                   enum_type: Ty<'tcx>,\n+                                   struct_def: &adt::Struct<'tcx>,\n+                                   variant_info: &ty::VariantInfo<'tcx>,\n+                                   discriminant_info: EnumDiscriminantInfo,\n+                                   containing_scope: DIScope,\n+                                   span: Span)\n+                                   -> (DICompositeType, Type, MemberDescriptionFactory<'tcx>) {\n+    let variant_llvm_type =\n+        Type::struct_(cx, &struct_def.fields\n+                                    .iter()\n+                                    .map(|&t| type_of::type_of(cx, t))\n+                                    .collect::<Vec<_>>()\n+                                    ,\n+                      struct_def.packed);\n+    // Could do some consistency checks here: size, align, field count, discr type\n+\n+    let variant_name = token::get_name(variant_info.name);\n+    let variant_name = &variant_name;\n+    let unique_type_id = debug_context(cx).type_map\n+                                          .borrow_mut()\n+                                          .get_unique_type_id_of_enum_variant(\n+                                              cx,\n+                                              enum_type,\n+                                              variant_name);\n+\n+    let metadata_stub = create_struct_stub(cx,\n+                                           variant_llvm_type,\n+                                           variant_name,\n+                                           unique_type_id,\n+                                           containing_scope);\n+\n+    // Get the argument names from the enum variant info\n+    let mut arg_names: Vec<_> = match variant_info.arg_names {\n+        Some(ref names) => {\n+            names.iter()\n+                 .map(|&name| token::get_name(name).to_string())\n+                 .collect()\n+        }\n+        None => {\n+            variant_info.args\n+                        .iter()\n+                        .enumerate()\n+                        .map(|(i, _)| format!(\"__{}\", i))\n+                        .collect()\n+        }\n+    };\n+\n+    // If this is not a univariant enum, there is also the discriminant field.\n+    match discriminant_info {\n+        RegularDiscriminant(_) => arg_names.insert(0, \"RUST$ENUM$DISR\".to_string()),\n+        _ => { /* do nothing */ }\n+    };\n+\n+    // Build an array of (field name, field type) pairs to be captured in the factory closure.\n+    let args: Vec<(String, Ty)> = arg_names.iter()\n+        .zip(struct_def.fields.iter())\n+        .map(|(s, &t)| (s.to_string(), t))\n+        .collect();\n+\n+    let member_description_factory =\n+        VariantMDF(VariantMemberDescriptionFactory {\n+            args: args,\n+            discriminant_type_metadata: match discriminant_info {\n+                RegularDiscriminant(discriminant_type_metadata) => {\n+                    Some(discriminant_type_metadata)\n+                }\n+                _ => None\n+            },\n+            span: span,\n+        });\n+\n+    (metadata_stub, variant_llvm_type, member_description_factory)\n+}\n+\n+fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                   enum_type: Ty<'tcx>,\n+                                   enum_def_id: ast::DefId,\n+                                   unique_type_id: UniqueTypeId,\n+                                   span: Span)\n+                                   -> RecursiveTypeDescription<'tcx> {\n+    let enum_name = compute_debuginfo_type_name(cx, enum_type, false);\n+\n+    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n+    let loc = span_start(cx, definition_span);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n+\n+    let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n+\n+    let enumerators_metadata: Vec<DIDescriptor> = variants\n+        .iter()\n+        .map(|v| {\n+            let token = token::get_name(v.name);\n+            let name = CString::new(token.as_bytes()).unwrap();\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateEnumerator(\n+                    DIB(cx),\n+                    name.as_ptr(),\n+                    v.disr_val as u64)\n+            }\n+        })\n+        .collect();\n+\n+    let discriminant_type_metadata = |inttype| {\n+        // We can reuse the type of the discriminant for all monomorphized\n+        // instances of an enum because it doesn't depend on any type\n+        // parameters. The def_id, uniquely identifying the enum's polytype acts\n+        // as key in this cache.\n+        let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n+                                                                 .borrow()\n+                                                                 .get(&enum_def_id).cloned();\n+        match cached_discriminant_type_metadata {\n+            Some(discriminant_type_metadata) => discriminant_type_metadata,\n+            None => {\n+                let discriminant_llvm_type = adt::ll_inttype(cx, inttype);\n+                let (discriminant_size, discriminant_align) =\n+                    size_and_align_of(cx, discriminant_llvm_type);\n+                let discriminant_base_type_metadata =\n+                    type_metadata(cx,\n+                                  adt::ty_of_inttype(cx.tcx(), inttype),\n+                                  codemap::DUMMY_SP);\n+                let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n+\n+                let name = CString::new(discriminant_name.as_bytes()).unwrap();\n+                let discriminant_type_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateEnumerationType(\n+                        DIB(cx),\n+                        containing_scope,\n+                        name.as_ptr(),\n+                        UNKNOWN_FILE_METADATA,\n+                        UNKNOWN_LINE_NUMBER,\n+                        bytes_to_bits(discriminant_size),\n+                        bytes_to_bits(discriminant_align),\n+                        create_DIArray(DIB(cx), &enumerators_metadata),\n+                        discriminant_base_type_metadata)\n+                };\n+\n+                debug_context(cx).created_enum_disr_types\n+                                 .borrow_mut()\n+                                 .insert(enum_def_id, discriminant_type_metadata);\n+\n+                discriminant_type_metadata\n+            }\n+        }\n+    };\n+\n+    let type_rep = adt::represent_type(cx, enum_type);\n+\n+    let discriminant_type_metadata = match *type_rep {\n+        adt::CEnum(inttype, _, _) => {\n+            return FinalMetadata(discriminant_type_metadata(inttype))\n+        },\n+        adt::RawNullablePointer { .. }           |\n+        adt::StructWrappedNullablePointer { .. } |\n+        adt::Univariant(..)                      => None,\n+        adt::General(inttype, _, _) => Some(discriminant_type_metadata(inttype)),\n+    };\n+\n+    let enum_llvm_type = type_of::type_of(cx, enum_type);\n+    let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n+\n+    let unique_type_id_str = debug_context(cx)\n+                             .type_map\n+                             .borrow()\n+                             .get_unique_type_id_as_string(unique_type_id);\n+\n+    let enum_name = CString::new(enum_name).unwrap();\n+    let unique_type_id_str = CString::new(unique_type_id_str.as_bytes()).unwrap();\n+    let enum_metadata = unsafe {\n+        llvm::LLVMDIBuilderCreateUnionType(\n+        DIB(cx),\n+        containing_scope,\n+        enum_name.as_ptr(),\n+        UNKNOWN_FILE_METADATA,\n+        UNKNOWN_LINE_NUMBER,\n+        bytes_to_bits(enum_type_size),\n+        bytes_to_bits(enum_type_align),\n+        0, // Flags\n+        ptr::null_mut(),\n+        0, // RuntimeLang\n+        unique_type_id_str.as_ptr())\n+    };\n+\n+    return create_and_register_recursive_type_forward_declaration(\n+        cx,\n+        enum_type,\n+        unique_type_id,\n+        enum_metadata,\n+        enum_llvm_type,\n+        EnumMDF(EnumMemberDescriptionFactory {\n+            enum_type: enum_type,\n+            type_rep: type_rep.clone(),\n+            variants: variants,\n+            discriminant_type_metadata: discriminant_type_metadata,\n+            containing_scope: containing_scope,\n+            file_metadata: file_metadata,\n+            span: span,\n+        }),\n+    );\n+\n+    fn get_enum_discriminant_name(cx: &CrateContext,\n+                                  def_id: ast::DefId)\n+                                  -> token::InternedString {\n+        let name = if def_id.krate == ast::LOCAL_CRATE {\n+            cx.tcx().map.get_path_elem(def_id.node).name()\n+        } else {\n+            csearch::get_item_path(cx.tcx(), def_id).last().unwrap().name()\n+        };\n+\n+        token::get_name(name)\n+    }\n+}\n+\n+/// Creates debug information for a composite type, that is, anything that\n+/// results in a LLVM struct.\n+///\n+/// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n+fn composite_type_metadata(cx: &CrateContext,\n+                           composite_llvm_type: Type,\n+                           composite_type_name: &str,\n+                           composite_type_unique_id: UniqueTypeId,\n+                           member_descriptions: &[MemberDescription],\n+                           containing_scope: DIScope,\n+\n+                           // Ignore source location information as long as it\n+                           // can't be reconstructed for non-local crates.\n+                           _file_metadata: DIFile,\n+                           _definition_span: Span)\n+                           -> DICompositeType {\n+    // Create the (empty) struct metadata node ...\n+    let composite_type_metadata = create_struct_stub(cx,\n+                                                     composite_llvm_type,\n+                                                     composite_type_name,\n+                                                     composite_type_unique_id,\n+                                                     containing_scope);\n+    // ... and immediately create and add the member descriptions.\n+    set_members_of_composite_type(cx,\n+                                  composite_type_metadata,\n+                                  composite_llvm_type,\n+                                  member_descriptions);\n+\n+    return composite_type_metadata;\n+}\n+\n+fn set_members_of_composite_type(cx: &CrateContext,\n+                                 composite_type_metadata: DICompositeType,\n+                                 composite_llvm_type: Type,\n+                                 member_descriptions: &[MemberDescription]) {\n+    // In some rare cases LLVM metadata uniquing would lead to an existing type\n+    // description being used instead of a new one created in\n+    // create_struct_stub. This would cause a hard to trace assertion in\n+    // DICompositeType::SetTypeArray(). The following check makes sure that we\n+    // get a better error message if this should happen again due to some\n+    // regression.\n+    {\n+        let mut composite_types_completed =\n+            debug_context(cx).composite_types_completed.borrow_mut();\n+        if composite_types_completed.contains(&composite_type_metadata) {\n+            cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n+                           Already completed forward declaration re-encountered.\");\n+        } else {\n+            composite_types_completed.insert(composite_type_metadata);\n+        }\n+    }\n+\n+    let member_metadata: Vec<DIDescriptor> = member_descriptions\n+        .iter()\n+        .enumerate()\n+        .map(|(i, member_description)| {\n+            let (member_size, member_align) = size_and_align_of(cx, member_description.llvm_type);\n+            let member_offset = match member_description.offset {\n+                FixedMemberOffset { bytes } => bytes as u64,\n+                ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n+            };\n+\n+            let member_name = member_description.name.as_bytes();\n+            let member_name = CString::new(member_name).unwrap();\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateMemberType(\n+                    DIB(cx),\n+                    composite_type_metadata,\n+                    member_name.as_ptr(),\n+                    UNKNOWN_FILE_METADATA,\n+                    UNKNOWN_LINE_NUMBER,\n+                    bytes_to_bits(member_size),\n+                    bytes_to_bits(member_align),\n+                    bytes_to_bits(member_offset),\n+                    member_description.flags,\n+                    member_description.type_metadata)\n+            }\n+        })\n+        .collect();\n+\n+    unsafe {\n+        let type_array = create_DIArray(DIB(cx), &member_metadata[..]);\n+        llvm::LLVMDICompositeTypeSetTypeArray(DIB(cx), composite_type_metadata, type_array);\n+    }\n+}\n+\n+// A convenience wrapper around LLVMDIBuilderCreateStructType(). Does not do any\n+// caching, does not add any fields to the struct. This can be done later with\n+// set_members_of_composite_type().\n+fn create_struct_stub(cx: &CrateContext,\n+                      struct_llvm_type: Type,\n+                      struct_type_name: &str,\n+                      unique_type_id: UniqueTypeId,\n+                      containing_scope: DIScope)\n+                   -> DICompositeType {\n+    let (struct_size, struct_align) = size_and_align_of(cx, struct_llvm_type);\n+\n+    let unique_type_id_str = debug_context(cx).type_map\n+                                              .borrow()\n+                                              .get_unique_type_id_as_string(unique_type_id);\n+    let name = CString::new(struct_type_name).unwrap();\n+    let unique_type_id = CString::new(unique_type_id_str.as_bytes()).unwrap();\n+    let metadata_stub = unsafe {\n+        // LLVMDIBuilderCreateStructType() wants an empty array. A null\n+        // pointer will lead to hard to trace and debug LLVM assertions\n+        // later on in llvm/lib/IR/Value.cpp.\n+        let empty_array = create_DIArray(DIB(cx), &[]);\n+\n+        llvm::LLVMDIBuilderCreateStructType(\n+            DIB(cx),\n+            containing_scope,\n+            name.as_ptr(),\n+            UNKNOWN_FILE_METADATA,\n+            UNKNOWN_LINE_NUMBER,\n+            bytes_to_bits(struct_size),\n+            bytes_to_bits(struct_align),\n+            0,\n+            ptr::null_mut(),\n+            empty_array,\n+            0,\n+            ptr::null_mut(),\n+            unique_type_id.as_ptr())\n+    };\n+\n+    return metadata_stub;\n+}\n+\n+/// Creates debug information for the given global variable.\n+///\n+/// Adds the created metadata nodes directly to the crate's IR.\n+pub fn create_global_var_metadata(cx: &CrateContext,\n+                                  node_id: ast::NodeId,\n+                                  global: ValueRef) {\n+    if cx.dbg_cx().is_none() {\n+        return;\n+    }\n+\n+    // Don't create debuginfo for globals inlined from other crates. The other\n+    // crate should already contain debuginfo for it. More importantly, the\n+    // global might not even exist in un-inlined form anywhere which would lead\n+    // to a linker errors.\n+    if cx.external_srcs().borrow().contains_key(&node_id) {\n+        return;\n+    }\n+\n+    let var_item = cx.tcx().map.get(node_id);\n+\n+    let (name, span) = match var_item {\n+        ast_map::NodeItem(item) => {\n+            match item.node {\n+                ast::ItemStatic(..) => (item.ident.name, item.span),\n+                ast::ItemConst(..) => (item.ident.name, item.span),\n+                _ => {\n+                    cx.sess()\n+                      .span_bug(item.span,\n+                                &format!(\"debuginfo::\\\n+                                         create_global_var_metadata() -\n+                                         Captured var-id refers to \\\n+                                         unexpected ast_item variant: {:?}\",\n+                                        var_item))\n+                }\n+            }\n+        },\n+        _ => cx.sess().bug(&format!(\"debuginfo::create_global_var_metadata() \\\n+                                    - Captured var-id refers to unexpected \\\n+                                    ast_map variant: {:?}\",\n+                                   var_item))\n+    };\n+\n+    let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n+        let loc = span_start(cx, span);\n+        (file_metadata(cx, &loc.file.name), loc.line as c_uint)\n+    } else {\n+        (UNKNOWN_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n+    };\n+\n+    let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n+    let variable_type = ty::node_id_to_type(cx.tcx(), node_id);\n+    let type_metadata = type_metadata(cx, variable_type, span);\n+    let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n+    let var_name = token::get_name(name).to_string();\n+    let linkage_name =\n+        namespace_node.mangled_name_of_contained_item(&var_name[..]);\n+    let var_scope = namespace_node.scope;\n+\n+    let var_name = CString::new(var_name).unwrap();\n+    let linkage_name = CString::new(linkage_name).unwrap();\n+    unsafe {\n+        llvm::LLVMDIBuilderCreateStaticVariable(DIB(cx),\n+                                                var_scope,\n+                                                var_name.as_ptr(),\n+                                                linkage_name.as_ptr(),\n+                                                file_metadata,\n+                                                line_number,\n+                                                type_metadata,\n+                                                is_local_to_unit,\n+                                                global,\n+                                                ptr::null_mut());\n+    }\n+}\n+\n+/// Creates debug information for the given local variable.\n+///\n+/// This function assumes that there's a datum for each pattern component of the\n+/// local in `bcx.fcx.lllocals`.\n+/// Adds the created metadata nodes directly to the crate's IR.\n+pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n+    if bcx.unreachable.get() ||\n+       fn_should_be_ignored(bcx.fcx) ||\n+       bcx.sess().opts.debuginfo != FullDebugInfo  {\n+        return;\n+    }\n+\n+    let cx = bcx.ccx();\n+    let def_map = &cx.tcx().def_map;\n+    let locals = bcx.fcx.lllocals.borrow();\n+\n+    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, var_ident| {\n+        let datum = match locals.get(&node_id) {\n+            Some(datum) => datum,\n+            None => {\n+                bcx.sess().span_bug(span,\n+                    &format!(\"no entry in lllocals table for {}\",\n+                            node_id));\n+            }\n+        };\n+\n+        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n+            cx.sess().span_bug(span, \"debuginfo::create_local_var_metadata() - \\\n+                                      Referenced variable location is not an alloca!\");\n+        }\n+\n+        let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n+\n+        declare_local(bcx,\n+                      var_ident.node.name,\n+                      datum.ty,\n+                      scope_metadata,\n+                      VariableAccess::DirectVariable { alloca: datum.val },\n+                      VariableKind::LocalVariable,\n+                      span);\n+    })\n+}\n+\n+/// Creates debug information for a variable captured in a closure.\n+///\n+/// Adds the created metadata nodes directly to the crate's IR.\n+pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                                node_id: ast::NodeId,\n+                                                env_pointer: ValueRef,\n+                                                env_index: usize,\n+                                                captured_by_ref: bool,\n+                                                span: Span) {\n+    if bcx.unreachable.get() ||\n+       fn_should_be_ignored(bcx.fcx) ||\n+       bcx.sess().opts.debuginfo != FullDebugInfo {\n+        return;\n+    }\n+\n+    let cx = bcx.ccx();\n+\n+    let ast_item = cx.tcx().map.find(node_id);\n+\n+    let variable_name = match ast_item {\n+        None => {\n+            cx.sess().span_bug(span, \"debuginfo::create_captured_var_metadata: node not found\");\n+        }\n+        Some(ast_map::NodeLocal(pat)) | Some(ast_map::NodeArg(pat)) => {\n+            match pat.node {\n+                ast::PatIdent(_, ref path1, _) => {\n+                    path1.node.name\n+                }\n+                _ => {\n+                    cx.sess()\n+                      .span_bug(span,\n+                                &format!(\n+                                \"debuginfo::create_captured_var_metadata() - \\\n+                                 Captured var-id refers to unexpected \\\n+                                 ast_map variant: {:?}\",\n+                                 ast_item));\n+                }\n+            }\n+        }\n+        _ => {\n+            cx.sess()\n+              .span_bug(span,\n+                        &format!(\"debuginfo::create_captured_var_metadata() - \\\n+                                 Captured var-id refers to unexpected \\\n+                                 ast_map variant: {:?}\",\n+                                ast_item));\n+        }\n+    };\n+\n+    let variable_type = common::node_id_type(bcx, node_id);\n+    let scope_metadata = bcx.fcx.debug_context.get_ref(cx, span).fn_metadata;\n+\n+    // env_pointer is the alloca containing the pointer to the environment,\n+    // so it's type is **EnvironmentType. In order to find out the type of\n+    // the environment we have to \"dereference\" two times.\n+    let llvm_env_data_type = common::val_ty(env_pointer).element_type()\n+                                                        .element_type();\n+    let byte_offset_of_var_in_env = machine::llelement_offset(cx,\n+                                                              llvm_env_data_type,\n+                                                              env_index);\n+\n+    let address_operations = unsafe {\n+        [llvm::LLVMDIBuilderCreateOpDeref(),\n+         llvm::LLVMDIBuilderCreateOpPlus(),\n+         byte_offset_of_var_in_env as i64,\n+         llvm::LLVMDIBuilderCreateOpDeref()]\n+    };\n+\n+    let address_op_count = if captured_by_ref {\n+        address_operations.len()\n+    } else {\n+        address_operations.len() - 1\n+    };\n+\n+    let variable_access = VariableAccess::IndirectVariable {\n+        alloca: env_pointer,\n+        address_operations: &address_operations[..address_op_count]\n+    };\n+\n+    declare_local(bcx,\n+                  variable_name,\n+                  variable_type,\n+                  scope_metadata,\n+                  variable_access,\n+                  VariableKind::CapturedVariable,\n+                  span);\n+}\n+\n+/// Creates debug information for a local variable introduced in the head of a\n+/// match-statement arm.\n+///\n+/// Adds the created metadata nodes directly to the crate's IR.\n+pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                                 variable_name: ast::Name,\n+                                                 binding: BindingInfo<'tcx>) {\n+    if bcx.unreachable.get() ||\n+       fn_should_be_ignored(bcx.fcx) ||\n+       bcx.sess().opts.debuginfo != FullDebugInfo {\n+        return;\n+    }\n+\n+    let scope_metadata = scope_metadata(bcx.fcx, binding.id, binding.span);\n+    let aops = unsafe {\n+        [llvm::LLVMDIBuilderCreateOpDeref()]\n+    };\n+    // Regardless of the actual type (`T`) we're always passed the stack slot\n+    // (alloca) for the binding. For ByRef bindings that's a `T*` but for ByMove\n+    // bindings we actually have `T**`. So to get the actual variable we need to\n+    // dereference once more. For ByCopy we just use the stack slot we created\n+    // for the binding.\n+    let var_access = match binding.trmode {\n+        TrByCopy(llbinding) => VariableAccess::DirectVariable {\n+            alloca: llbinding\n+        },\n+        TrByMove => VariableAccess::IndirectVariable {\n+            alloca: binding.llmatch,\n+            address_operations: &aops\n+        },\n+        TrByRef => VariableAccess::DirectVariable {\n+            alloca: binding.llmatch\n+        }\n+    };\n+\n+    declare_local(bcx,\n+                  variable_name,\n+                  binding.ty,\n+                  scope_metadata,\n+                  var_access,\n+                  VariableKind::LocalVariable,\n+                  binding.span);\n+}\n+\n+/// Creates debug information for the given function argument.\n+///\n+/// This function assumes that there's a datum for each pattern component of the\n+/// argument in `bcx.fcx.lllocals`.\n+/// Adds the created metadata nodes directly to the crate's IR.\n+pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n+    if bcx.unreachable.get() ||\n+       fn_should_be_ignored(bcx.fcx) ||\n+       bcx.sess().opts.debuginfo != FullDebugInfo {\n+        return;\n+    }\n+\n+    let def_map = &bcx.tcx().def_map;\n+    let scope_metadata = bcx\n+                         .fcx\n+                         .debug_context\n+                         .get_ref(bcx.ccx(), arg.pat.span)\n+                         .fn_metadata;\n+    let locals = bcx.fcx.lllocals.borrow();\n+\n+    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, var_ident| {\n+        let datum = match locals.get(&node_id) {\n+            Some(v) => v,\n+            None => {\n+                bcx.sess().span_bug(span,\n+                    &format!(\"no entry in lllocals table for {}\",\n+                            node_id));\n+            }\n+        };\n+\n+        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n+            bcx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n+                                       Referenced variable location is not an alloca!\");\n+        }\n+\n+        let argument_index = {\n+            let counter = &bcx\n+                          .fcx\n+                          .debug_context\n+                          .get_ref(bcx.ccx(), span)\n+                          .argument_counter;\n+            let argument_index = counter.get();\n+            counter.set(argument_index + 1);\n+            argument_index\n+        };\n+\n+        declare_local(bcx,\n+                      var_ident.node.name,\n+                      datum.ty,\n+                      scope_metadata,\n+                      VariableAccess::DirectVariable { alloca: datum.val },\n+                      VariableKind::ArgumentVariable(argument_index),\n+                      span);\n+    })\n+}"}, {"sha": "e4312b669ad98d2cce97fbb5b57944cddb729033", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 123, "deletions": 1020, "changes": 1143, "blob_url": "https://github.com/rust-lang/rust/blob/7bfb5ed826c3fa6544865095f3f9158d95efb3a3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfb5ed826c3fa6544865095f3f9158d95efb3a3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=7bfb5ed826c3fa6544865095f3f9158d95efb3a3", "patch": "@@ -13,431 +13,59 @@ mod doc;\n \n use self::VariableAccess::*;\n use self::VariableKind::*;\n-use self::InternalDebugLocation::*;\n-use self::RecursiveTypeDescription::*;\n \n-use self::utils::{debug_context, DIB, span_start,\n-                  assert_type_for_node_id, fn_should_be_ignored,\n-                  contains_nodebug_attribute, create_scope_map};\n-use self::create::{declare_local, create_DIArray, is_node_local_to_unit};\n+use self::utils::{DIB, span_start, assert_type_for_node_id, contains_nodebug_attribute,\n+                  create_DIArray, is_node_local_to_unit};\n use self::namespace::{namespace_for_item, NamespaceTreeNode};\n-use self::types::{compute_debuginfo_type_name, push_debuginfo_type_name};\n-use self::metadata::{type_metadata, file_metadata, scope_metadata,\n-                     compile_unit_metadata, MetadataCreationResult};\n-use self::adt::{MemberDescriptionFactory, set_members_of_composite_type};\n+use self::type_names::compute_debuginfo_type_name;\n+use self::metadata::{type_metadata, file_metadata, scope_metadata, TypeMap, compile_unit_metadata};\n+use self::source_loc::InternalDebugLocation;\n \n use llvm;\n use llvm::{ModuleRef, ContextRef, ValueRef};\n-use llvm::debuginfo::*;\n+use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray,\n+                      DIDescriptor, FlagPrototyped};\n use middle::subst::{self, Substs};\n-use trans::machine;\n-use trans::common::{self, NodeIdAndSpan, CrateContext, FunctionContext, Block,\n-                    NormalizingClosureTyper};\n-use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n+use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n+use trans;\n use trans::monomorphize;\n-use trans::type_::Type;\n use middle::ty::{self, Ty, ClosureTyper};\n-use middle::pat_util;\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n-use util::ppaux;\n \n use libc::c_uint;\n use std::cell::{Cell, RefCell};\n use std::ffi::CString;\n use std::ptr;\n use std::rc::Rc;\n-use syntax::util::interner::Interner;\n use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap, ast_util, ast_map};\n use syntax::parse::token::{self, special_idents};\n \n pub mod gdb;\n mod utils;\n-mod create;\n mod namespace;\n-mod types;\n+mod type_names;\n mod metadata;\n-mod adt;\n-\n+mod create_scope_map;\n+mod source_loc;\n+\n+pub use self::source_loc::set_source_location;\n+pub use self::source_loc::clear_source_location;\n+pub use self::source_loc::start_emitting_source_locations;\n+pub use self::source_loc::get_cleanup_debug_loc_for_ast_node;\n+pub use self::source_loc::with_source_location_override;\n+pub use self::metadata::create_match_binding_metadata;\n+pub use self::metadata::create_argument_metadata;\n+pub use self::metadata::create_captured_var_metadata;\n+pub use self::metadata::create_global_var_metadata;\n+pub use self::metadata::create_local_var_metadata;\n \n #[allow(non_upper_case_globals)]\n const DW_TAG_auto_variable: c_uint = 0x100;\n #[allow(non_upper_case_globals)]\n const DW_TAG_arg_variable: c_uint = 0x101;\n \n-const UNKNOWN_LINE_NUMBER: c_uint = 0;\n-const UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n-\n-// ptr::null() doesn't work :(\n-const UNKNOWN_FILE_METADATA: DIFile = (0 as DIFile);\n-const UNKNOWN_SCOPE_METADATA: DIScope = (0 as DIScope);\n-\n-const FLAGS_NONE: c_uint = 0;\n-\n-//=-----------------------------------------------------------------------------\n-//  Public Interface of debuginfo module\n-//=-----------------------------------------------------------------------------\n-\n-#[derive(Copy, Debug, Hash, Eq, PartialEq, Clone)]\n-pub struct UniqueTypeId(ast::Name);\n-\n-// The TypeMap is where the CrateDebugContext holds the type metadata nodes\n-// created so far. The metadata nodes are indexed by UniqueTypeId, and, for\n-// faster lookup, also by Ty. The TypeMap is responsible for creating\n-// UniqueTypeIds.\n-struct TypeMap<'tcx> {\n-    // The UniqueTypeIds created so far\n-    unique_id_interner: Interner<Rc<String>>,\n-    // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n-    unique_id_to_metadata: FnvHashMap<UniqueTypeId, DIType>,\n-    // A map from types to debuginfo metadata. This is a N:1 mapping.\n-    type_to_metadata: FnvHashMap<Ty<'tcx>, DIType>,\n-    // A map from types to UniqueTypeId. This is a N:1 mapping.\n-    type_to_unique_id: FnvHashMap<Ty<'tcx>, UniqueTypeId>\n-}\n-\n-impl<'tcx> TypeMap<'tcx> {\n-\n-    fn new() -> TypeMap<'tcx> {\n-        TypeMap {\n-            unique_id_interner: Interner::new(),\n-            type_to_metadata: FnvHashMap(),\n-            unique_id_to_metadata: FnvHashMap(),\n-            type_to_unique_id: FnvHashMap(),\n-        }\n-    }\n-\n-    // Adds a Ty to metadata mapping to the TypeMap. The method will fail if\n-    // the mapping already exists.\n-    fn register_type_with_metadata<'a>(&mut self,\n-                                       cx: &CrateContext<'a, 'tcx>,\n-                                       type_: Ty<'tcx>,\n-                                       metadata: DIType) {\n-        if self.type_to_metadata.insert(type_, metadata).is_some() {\n-            cx.sess().bug(&format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n-                                   ppaux::ty_to_string(cx.tcx(), type_)));\n-        }\n-    }\n-\n-    // Adds a UniqueTypeId to metadata mapping to the TypeMap. The method will\n-    // fail if the mapping already exists.\n-    fn register_unique_id_with_metadata(&mut self,\n-                                        cx: &CrateContext,\n-                                        unique_type_id: UniqueTypeId,\n-                                        metadata: DIType) {\n-        if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n-            let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n-            cx.sess().bug(&format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                                  &unique_type_id_str[..]));\n-        }\n-    }\n-\n-    fn find_metadata_for_type(&self, type_: Ty<'tcx>) -> Option<DIType> {\n-        self.type_to_metadata.get(&type_).cloned()\n-    }\n-\n-    fn find_metadata_for_unique_id(&self, unique_type_id: UniqueTypeId) -> Option<DIType> {\n-        self.unique_id_to_metadata.get(&unique_type_id).cloned()\n-    }\n-\n-    // Get the string representation of a UniqueTypeId. This method will fail if\n-    // the id is unknown.\n-    fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> Rc<String> {\n-        let UniqueTypeId(interner_key) = unique_type_id;\n-        self.unique_id_interner.get(interner_key)\n-    }\n-\n-    // Get the UniqueTypeId for the given type. If the UniqueTypeId for the given\n-    // type has been requested before, this is just a table lookup. Otherwise an\n-    // ID will be generated and stored for later lookup.\n-    fn get_unique_type_id_of_type<'a>(&mut self, cx: &CrateContext<'a, 'tcx>,\n-                                      type_: Ty<'tcx>) -> UniqueTypeId {\n-\n-        // basic type           -> {:name of the type:}\n-        // tuple                -> {tuple_(:param-uid:)*}\n-        // struct               -> {struct_:svh: / :node-id:_<(:param-uid:),*> }\n-        // enum                 -> {enum_:svh: / :node-id:_<(:param-uid:),*> }\n-        // enum variant         -> {variant_:variant-name:_:enum-uid:}\n-        // reference (&)        -> {& :pointee-uid:}\n-        // mut reference (&mut) -> {&mut :pointee-uid:}\n-        // ptr (*)              -> {* :pointee-uid:}\n-        // mut ptr (*mut)       -> {*mut :pointee-uid:}\n-        // unique ptr (~)       -> {~ :pointee-uid:}\n-        // @-ptr (@)            -> {@ :pointee-uid:}\n-        // sized vec ([T; x])   -> {[:size:] :element-uid:}\n-        // unsized vec ([T])    -> {[] :element-uid:}\n-        // trait (T)            -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n-        // closure              -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n-        //                             :return-type-uid: : (:bounds:)*}\n-        // function             -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n-        //                             :return-type-uid:}\n-        // unique vec box (~[]) -> {HEAP_VEC_BOX<:pointee-uid:>}\n-        // gc box               -> {GC_BOX<:pointee-uid:>}\n-\n-        match self.type_to_unique_id.get(&type_).cloned() {\n-            Some(unique_type_id) => return unique_type_id,\n-            None => { /* generate one */}\n-        };\n-\n-        let mut unique_type_id = String::with_capacity(256);\n-        unique_type_id.push('{');\n-\n-        match type_.sty {\n-            ty::ty_bool     |\n-            ty::ty_char     |\n-            ty::ty_str      |\n-            ty::ty_int(_)   |\n-            ty::ty_uint(_)  |\n-            ty::ty_float(_) => {\n-                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n-            },\n-            ty::ty_enum(def_id, substs) => {\n-                unique_type_id.push_str(\"enum \");\n-                from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n-            },\n-            ty::ty_struct(def_id, substs) => {\n-                unique_type_id.push_str(\"struct \");\n-                from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n-            },\n-            ty::ty_tup(ref component_types) if component_types.is_empty() => {\n-                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n-            },\n-            ty::ty_tup(ref component_types) => {\n-                unique_type_id.push_str(\"tuple \");\n-                for &component_type in component_types {\n-                    let component_type_id =\n-                        self.get_unique_type_id_of_type(cx, component_type);\n-                    let component_type_id =\n-                        self.get_unique_type_id_as_string(component_type_id);\n-                    unique_type_id.push_str(&component_type_id[..]);\n-                }\n-            },\n-            ty::ty_uniq(inner_type) => {\n-                unique_type_id.push('~');\n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n-                unique_type_id.push('*');\n-                if mutbl == ast::MutMutable {\n-                    unique_type_id.push_str(\"mut\");\n-                }\n-\n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n-                unique_type_id.push('&');\n-                if mutbl == ast::MutMutable {\n-                    unique_type_id.push_str(\"mut\");\n-                }\n-\n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::ty_vec(inner_type, optional_length) => {\n-                match optional_length {\n-                    Some(len) => {\n-                        unique_type_id.push_str(&format!(\"[{}]\", len));\n-                    }\n-                    None => {\n-                        unique_type_id.push_str(\"[]\");\n-                    }\n-                };\n-\n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::ty_trait(ref trait_data) => {\n-                unique_type_id.push_str(\"trait \");\n-\n-                let principal =\n-                    ty::erase_late_bound_regions(cx.tcx(),\n-                                                 &trait_data.principal);\n-\n-                from_def_id_and_substs(self,\n-                                       cx,\n-                                       principal.def_id,\n-                                       principal.substs,\n-                                       &mut unique_type_id);\n-            },\n-            ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n-                if unsafety == ast::Unsafety::Unsafe {\n-                    unique_type_id.push_str(\"unsafe \");\n-                }\n-\n-                unique_type_id.push_str(abi.name());\n-\n-                unique_type_id.push_str(\" fn(\");\n-\n-                let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n-\n-                for &parameter_type in &sig.inputs {\n-                    let parameter_type_id =\n-                        self.get_unique_type_id_of_type(cx, parameter_type);\n-                    let parameter_type_id =\n-                        self.get_unique_type_id_as_string(parameter_type_id);\n-                    unique_type_id.push_str(&parameter_type_id[..]);\n-                    unique_type_id.push(',');\n-                }\n-\n-                if sig.variadic {\n-                    unique_type_id.push_str(\"...\");\n-                }\n-\n-                unique_type_id.push_str(\")->\");\n-                match sig.output {\n-                    ty::FnConverging(ret_ty) => {\n-                        let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n-                        let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                        unique_type_id.push_str(&return_type_id[..]);\n-                    }\n-                    ty::FnDiverging => {\n-                        unique_type_id.push_str(\"!\");\n-                    }\n-                }\n-            },\n-            ty::ty_closure(def_id, substs) => {\n-                let typer = NormalizingClosureTyper::new(cx.tcx());\n-                let closure_ty = typer.closure_type(def_id, substs);\n-                self.get_unique_type_id_of_closure_type(cx,\n-                                                        closure_ty,\n-                                                        &mut unique_type_id);\n-            },\n-            _ => {\n-                cx.sess().bug(&format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n-                                      &ppaux::ty_to_string(cx.tcx(), type_),\n-                                      type_.sty))\n-            }\n-        };\n-\n-        unique_type_id.push('}');\n-\n-        // Trim to size before storing permanently\n-        unique_type_id.shrink_to_fit();\n-\n-        let key = self.unique_id_interner.intern(Rc::new(unique_type_id));\n-        self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n-\n-        return UniqueTypeId(key);\n-\n-        fn from_def_id_and_substs<'a, 'tcx>(type_map: &mut TypeMap<'tcx>,\n-                                            cx: &CrateContext<'a, 'tcx>,\n-                                            def_id: ast::DefId,\n-                                            substs: &subst::Substs<'tcx>,\n-                                            output: &mut String) {\n-            // First, find out the 'real' def_id of the type. Items inlined from\n-            // other crates have to be mapped back to their source.\n-            let source_def_id = if def_id.krate == ast::LOCAL_CRATE {\n-                match cx.external_srcs().borrow().get(&def_id.node).cloned() {\n-                    Some(source_def_id) => {\n-                        // The given def_id identifies the inlined copy of a\n-                        // type definition, let's take the source of the copy.\n-                        source_def_id\n-                    }\n-                    None => def_id\n-                }\n-            } else {\n-                def_id\n-            };\n-\n-            // Get the crate hash as first part of the identifier.\n-            let crate_hash = if source_def_id.krate == ast::LOCAL_CRATE {\n-                cx.link_meta().crate_hash.clone()\n-            } else {\n-                cx.sess().cstore.get_crate_hash(source_def_id.krate)\n-            };\n-\n-            output.push_str(crate_hash.as_str());\n-            output.push_str(\"/\");\n-            output.push_str(&format!(\"{:x}\", def_id.node));\n-\n-            // Maybe check that there is no self type here.\n-\n-            let tps = substs.types.get_slice(subst::TypeSpace);\n-            if !tps.is_empty() {\n-                output.push('<');\n-\n-                for &type_parameter in tps {\n-                    let param_type_id =\n-                        type_map.get_unique_type_id_of_type(cx, type_parameter);\n-                    let param_type_id =\n-                        type_map.get_unique_type_id_as_string(param_type_id);\n-                    output.push_str(&param_type_id[..]);\n-                    output.push(',');\n-                }\n-\n-                output.push('>');\n-            }\n-        }\n-    }\n-\n-    fn get_unique_type_id_of_closure_type<'a>(&mut self,\n-                                              cx: &CrateContext<'a, 'tcx>,\n-                                              closure_ty: ty::ClosureTy<'tcx>,\n-                                              unique_type_id: &mut String) {\n-        let ty::ClosureTy { unsafety,\n-                            ref sig,\n-                            abi: _ } = closure_ty;\n-\n-        if unsafety == ast::Unsafety::Unsafe {\n-            unique_type_id.push_str(\"unsafe \");\n-        }\n-\n-        unique_type_id.push_str(\"|\");\n-\n-        let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n-\n-        for &parameter_type in &sig.inputs {\n-            let parameter_type_id =\n-                self.get_unique_type_id_of_type(cx, parameter_type);\n-            let parameter_type_id =\n-                self.get_unique_type_id_as_string(parameter_type_id);\n-            unique_type_id.push_str(&parameter_type_id[..]);\n-            unique_type_id.push(',');\n-        }\n-\n-        if sig.variadic {\n-            unique_type_id.push_str(\"...\");\n-        }\n-\n-        unique_type_id.push_str(\"|->\");\n-\n-        match sig.output {\n-            ty::FnConverging(ret_ty) => {\n-                let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n-                let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                unique_type_id.push_str(&return_type_id[..]);\n-            }\n-            ty::FnDiverging => {\n-                unique_type_id.push_str(\"!\");\n-            }\n-        }\n-    }\n-\n-    // Get the UniqueTypeId for an enum variant. Enum variants are not really\n-    // types of their own, so they need special handling. We still need a\n-    // UniqueTypeId for them, since to debuginfo they *are* real types.\n-    fn get_unique_type_id_of_enum_variant<'a>(&mut self,\n-                                              cx: &CrateContext<'a, 'tcx>,\n-                                              enum_type: Ty<'tcx>,\n-                                              variant_name: &str)\n-                                              -> UniqueTypeId {\n-        let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n-        let enum_variant_type_id = format!(\"{}::{}\",\n-                                           &self.get_unique_type_id_as_string(enum_type_id),\n-                                           variant_name);\n-        let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n-        UniqueTypeId(interner_key)\n-    }\n-}\n-\n-\n /// A context object for maintaining all state needed by the debuginfo module.\n pub struct CrateDebugContext<'tcx> {\n     llcontext: ContextRef,\n@@ -463,7 +91,7 @@ impl<'tcx> CrateDebugContext<'tcx> {\n         return CrateDebugContext {\n             llcontext: llcontext,\n             builder: builder,\n-            current_debug_location: Cell::new(UnknownLocation),\n+            current_debug_location: Cell::new(InternalDebugLocation::UnknownLocation),\n             created_files: RefCell::new(FnvHashMap()),\n             created_enum_disr_types: RefCell::new(DefIdMap()),\n             type_map: RefCell::new(TypeMap::new()),\n@@ -569,509 +197,6 @@ pub fn finalize(cx: &CrateContext) {\n     };\n }\n \n-/// Creates debug information for the given global variable.\n-///\n-/// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_global_var_metadata(cx: &CrateContext,\n-                                  node_id: ast::NodeId,\n-                                  global: ValueRef) {\n-    if cx.dbg_cx().is_none() {\n-        return;\n-    }\n-\n-    // Don't create debuginfo for globals inlined from other crates. The other\n-    // crate should already contain debuginfo for it. More importantly, the\n-    // global might not even exist in un-inlined form anywhere which would lead\n-    // to a linker errors.\n-    if cx.external_srcs().borrow().contains_key(&node_id) {\n-        return;\n-    }\n-\n-    let var_item = cx.tcx().map.get(node_id);\n-\n-    let (name, span) = match var_item {\n-        ast_map::NodeItem(item) => {\n-            match item.node {\n-                ast::ItemStatic(..) => (item.ident.name, item.span),\n-                ast::ItemConst(..) => (item.ident.name, item.span),\n-                _ => {\n-                    cx.sess()\n-                      .span_bug(item.span,\n-                                &format!(\"debuginfo::\\\n-                                         create_global_var_metadata() -\n-                                         Captured var-id refers to \\\n-                                         unexpected ast_item variant: {:?}\",\n-                                        var_item))\n-                }\n-            }\n-        },\n-        _ => cx.sess().bug(&format!(\"debuginfo::create_global_var_metadata() \\\n-                                    - Captured var-id refers to unexpected \\\n-                                    ast_map variant: {:?}\",\n-                                   var_item))\n-    };\n-\n-    let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n-        let loc = span_start(cx, span);\n-        (file_metadata(cx, &loc.file.name), loc.line as c_uint)\n-    } else {\n-        (UNKNOWN_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n-    };\n-\n-    let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = ty::node_id_to_type(cx.tcx(), node_id);\n-    let type_metadata = type_metadata(cx, variable_type, span);\n-    let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n-    let var_name = token::get_name(name).to_string();\n-    let linkage_name =\n-        namespace_node.mangled_name_of_contained_item(&var_name[..]);\n-    let var_scope = namespace_node.scope;\n-\n-    let var_name = CString::new(var_name).unwrap();\n-    let linkage_name = CString::new(linkage_name).unwrap();\n-    unsafe {\n-        llvm::LLVMDIBuilderCreateStaticVariable(DIB(cx),\n-                                                var_scope,\n-                                                var_name.as_ptr(),\n-                                                linkage_name.as_ptr(),\n-                                                file_metadata,\n-                                                line_number,\n-                                                type_metadata,\n-                                                is_local_to_unit,\n-                                                global,\n-                                                ptr::null_mut());\n-    }\n-}\n-\n-/// Creates debug information for the given local variable.\n-///\n-/// This function assumes that there's a datum for each pattern component of the\n-/// local in `bcx.fcx.lllocals`.\n-/// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n-    if bcx.unreachable.get() ||\n-       fn_should_be_ignored(bcx.fcx) ||\n-       bcx.sess().opts.debuginfo != FullDebugInfo  {\n-        return;\n-    }\n-\n-    let cx = bcx.ccx();\n-    let def_map = &cx.tcx().def_map;\n-    let locals = bcx.fcx.lllocals.borrow();\n-\n-    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, var_ident| {\n-        let datum = match locals.get(&node_id) {\n-            Some(datum) => datum,\n-            None => {\n-                bcx.sess().span_bug(span,\n-                    &format!(\"no entry in lllocals table for {}\",\n-                            node_id));\n-            }\n-        };\n-\n-        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            cx.sess().span_bug(span, \"debuginfo::create_local_var_metadata() - \\\n-                                      Referenced variable location is not an alloca!\");\n-        }\n-\n-        let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n-\n-        declare_local(bcx,\n-                      var_ident.node.name,\n-                      datum.ty,\n-                      scope_metadata,\n-                      DirectVariable { alloca: datum.val },\n-                      LocalVariable,\n-                      span);\n-    })\n-}\n-\n-/// Creates debug information for a variable captured in a closure.\n-///\n-/// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                node_id: ast::NodeId,\n-                                                env_pointer: ValueRef,\n-                                                env_index: usize,\n-                                                captured_by_ref: bool,\n-                                                span: Span) {\n-    if bcx.unreachable.get() ||\n-       fn_should_be_ignored(bcx.fcx) ||\n-       bcx.sess().opts.debuginfo != FullDebugInfo {\n-        return;\n-    }\n-\n-    let cx = bcx.ccx();\n-\n-    let ast_item = cx.tcx().map.find(node_id);\n-\n-    let variable_name = match ast_item {\n-        None => {\n-            cx.sess().span_bug(span, \"debuginfo::create_captured_var_metadata: node not found\");\n-        }\n-        Some(ast_map::NodeLocal(pat)) | Some(ast_map::NodeArg(pat)) => {\n-            match pat.node {\n-                ast::PatIdent(_, ref path1, _) => {\n-                    path1.node.name\n-                }\n-                _ => {\n-                    cx.sess()\n-                      .span_bug(span,\n-                                &format!(\n-                                \"debuginfo::create_captured_var_metadata() - \\\n-                                 Captured var-id refers to unexpected \\\n-                                 ast_map variant: {:?}\",\n-                                 ast_item));\n-                }\n-            }\n-        }\n-        _ => {\n-            cx.sess()\n-              .span_bug(span,\n-                        &format!(\"debuginfo::create_captured_var_metadata() - \\\n-                                 Captured var-id refers to unexpected \\\n-                                 ast_map variant: {:?}\",\n-                                ast_item));\n-        }\n-    };\n-\n-    let variable_type = common::node_id_type(bcx, node_id);\n-    let scope_metadata = bcx.fcx.debug_context.get_ref(cx, span).fn_metadata;\n-\n-    // env_pointer is the alloca containing the pointer to the environment,\n-    // so it's type is **EnvironmentType. In order to find out the type of\n-    // the environment we have to \"dereference\" two times.\n-    let llvm_env_data_type = common::val_ty(env_pointer).element_type()\n-                                                        .element_type();\n-    let byte_offset_of_var_in_env = machine::llelement_offset(cx,\n-                                                              llvm_env_data_type,\n-                                                              env_index);\n-\n-    let address_operations = unsafe {\n-        [llvm::LLVMDIBuilderCreateOpDeref(),\n-         llvm::LLVMDIBuilderCreateOpPlus(),\n-         byte_offset_of_var_in_env as i64,\n-         llvm::LLVMDIBuilderCreateOpDeref()]\n-    };\n-\n-    let address_op_count = if captured_by_ref {\n-        address_operations.len()\n-    } else {\n-        address_operations.len() - 1\n-    };\n-\n-    let variable_access = IndirectVariable {\n-        alloca: env_pointer,\n-        address_operations: &address_operations[..address_op_count]\n-    };\n-\n-    declare_local(bcx,\n-                  variable_name,\n-                  variable_type,\n-                  scope_metadata,\n-                  variable_access,\n-                  CapturedVariable,\n-                  span);\n-}\n-\n-/// Creates debug information for a local variable introduced in the head of a\n-/// match-statement arm.\n-///\n-/// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                 variable_name: ast::Name,\n-                                                 binding: BindingInfo<'tcx>) {\n-    if bcx.unreachable.get() ||\n-       fn_should_be_ignored(bcx.fcx) ||\n-       bcx.sess().opts.debuginfo != FullDebugInfo {\n-        return;\n-    }\n-\n-    let scope_metadata = scope_metadata(bcx.fcx, binding.id, binding.span);\n-    let aops = unsafe {\n-        [llvm::LLVMDIBuilderCreateOpDeref()]\n-    };\n-    // Regardless of the actual type (`T`) we're always passed the stack slot\n-    // (alloca) for the binding. For ByRef bindings that's a `T*` but for ByMove\n-    // bindings we actually have `T**`. So to get the actual variable we need to\n-    // dereference once more. For ByCopy we just use the stack slot we created\n-    // for the binding.\n-    let var_access = match binding.trmode {\n-        TrByCopy(llbinding) => DirectVariable {\n-            alloca: llbinding\n-        },\n-        TrByMove => IndirectVariable {\n-            alloca: binding.llmatch,\n-            address_operations: &aops\n-        },\n-        TrByRef => DirectVariable {\n-            alloca: binding.llmatch\n-        }\n-    };\n-\n-    declare_local(bcx,\n-                  variable_name,\n-                  binding.ty,\n-                  scope_metadata,\n-                  var_access,\n-                  LocalVariable,\n-                  binding.span);\n-}\n-\n-/// Creates debug information for the given function argument.\n-///\n-/// This function assumes that there's a datum for each pattern component of the\n-/// argument in `bcx.fcx.lllocals`.\n-/// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n-    if bcx.unreachable.get() ||\n-       fn_should_be_ignored(bcx.fcx) ||\n-       bcx.sess().opts.debuginfo != FullDebugInfo {\n-        return;\n-    }\n-\n-    let def_map = &bcx.tcx().def_map;\n-    let scope_metadata = bcx\n-                         .fcx\n-                         .debug_context\n-                         .get_ref(bcx.ccx(), arg.pat.span)\n-                         .fn_metadata;\n-    let locals = bcx.fcx.lllocals.borrow();\n-\n-    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, var_ident| {\n-        let datum = match locals.get(&node_id) {\n-            Some(v) => v,\n-            None => {\n-                bcx.sess().span_bug(span,\n-                    &format!(\"no entry in lllocals table for {}\",\n-                            node_id));\n-            }\n-        };\n-\n-        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            bcx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n-                                       Referenced variable location is not an alloca!\");\n-        }\n-\n-        let argument_index = {\n-            let counter = &bcx\n-                          .fcx\n-                          .debug_context\n-                          .get_ref(bcx.ccx(), span)\n-                          .argument_counter;\n-            let argument_index = counter.get();\n-            counter.set(argument_index + 1);\n-            argument_index\n-        };\n-\n-        declare_local(bcx,\n-                      var_ident.node.name,\n-                      datum.ty,\n-                      scope_metadata,\n-                      DirectVariable { alloca: datum.val },\n-                      ArgumentVariable(argument_index),\n-                      span);\n-    })\n-}\n-\n-pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                                    node_id: ast::NodeId,\n-                                                    node_span: Span,\n-                                                    is_block: bool)\n-                                                 -> NodeIdAndSpan {\n-    // A debug location needs two things:\n-    // (1) A span (of which only the beginning will actually be used)\n-    // (2) An AST node-id which will be used to look up the lexical scope\n-    //     for the location in the functions scope-map\n-    //\n-    // This function will calculate the debug location for compiler-generated\n-    // cleanup calls that are executed when control-flow leaves the\n-    // scope identified by `node_id`.\n-    //\n-    // For everything but block-like things we can simply take id and span of\n-    // the given expression, meaning that from a debugger's view cleanup code is\n-    // executed at the same source location as the statement/expr itself.\n-    //\n-    // Blocks are a special case. Here we want the cleanup to be linked to the\n-    // closing curly brace of the block. The *scope* the cleanup is executed in\n-    // is up to debate: It could either still be *within* the block being\n-    // cleaned up, meaning that locals from the block are still visible in the\n-    // debugger.\n-    // Or it could be in the scope that the block is contained in, so any locals\n-    // from within the block are already considered out-of-scope and thus not\n-    // accessible in the debugger anymore.\n-    //\n-    // The current implementation opts for the second option: cleanup of a block\n-    // already happens in the parent scope of the block. The main reason for\n-    // this decision is that scoping becomes controlflow dependent when variable\n-    // shadowing is involved and it's impossible to decide statically which\n-    // scope is actually left when the cleanup code is executed.\n-    // In practice it shouldn't make much of a difference.\n-\n-    let mut cleanup_span = node_span;\n-\n-    if is_block {\n-        // Not all blocks actually have curly braces (e.g. simple closure\n-        // bodies), in which case we also just want to return the span of the\n-        // whole expression.\n-        let code_snippet = cx.sess().codemap().span_to_snippet(node_span);\n-        if let Ok(code_snippet) = code_snippet {\n-            let bytes = code_snippet.as_bytes();\n-\n-            if !bytes.is_empty() && &bytes[bytes.len()-1..] == b\"}\" {\n-                cleanup_span = Span {\n-                    lo: node_span.hi - codemap::BytePos(1),\n-                    hi: node_span.hi,\n-                    expn_id: node_span.expn_id\n-                };\n-            }\n-        }\n-    }\n-\n-    NodeIdAndSpan {\n-        id: node_id,\n-        span: cleanup_span\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum DebugLoc {\n-    At(ast::NodeId, Span),\n-    None\n-}\n-\n-impl DebugLoc {\n-    pub fn apply(&self, fcx: &FunctionContext) {\n-        match *self {\n-            DebugLoc::At(node_id, span) => {\n-                set_source_location(fcx, node_id, span);\n-            }\n-            DebugLoc::None => {\n-                clear_source_location(fcx);\n-            }\n-        }\n-    }\n-}\n-\n-pub trait ToDebugLoc {\n-    fn debug_loc(&self) -> DebugLoc;\n-}\n-\n-impl ToDebugLoc for ast::Expr {\n-    fn debug_loc(&self) -> DebugLoc {\n-        DebugLoc::At(self.id, self.span)\n-    }\n-}\n-\n-impl ToDebugLoc for NodeIdAndSpan {\n-    fn debug_loc(&self) -> DebugLoc {\n-        DebugLoc::At(self.id, self.span)\n-    }\n-}\n-\n-impl ToDebugLoc for Option<NodeIdAndSpan> {\n-    fn debug_loc(&self) -> DebugLoc {\n-        match *self {\n-            Some(NodeIdAndSpan { id, span }) => DebugLoc::At(id, span),\n-            None => DebugLoc::None\n-        }\n-    }\n-}\n-\n-/// Sets the current debug location at the beginning of the span.\n-///\n-/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id\n-/// parameter is used to reliably find the correct visibility scope for the code\n-/// position.\n-pub fn set_source_location(fcx: &FunctionContext,\n-                           node_id: ast::NodeId,\n-                           span: Span) {\n-    match fcx.debug_context {\n-        FunctionDebugContext::DebugInfoDisabled => return,\n-        FunctionDebugContext::FunctionWithoutDebugInfo => {\n-            set_debug_location(fcx.ccx, UnknownLocation);\n-            return;\n-        }\n-        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n-            if function_debug_context.source_location_override.get() {\n-                // Just ignore any attempts to set a new debug location while\n-                // the override is active.\n-                return;\n-            }\n-\n-            let cx = fcx.ccx;\n-\n-            debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n-\n-            if function_debug_context.source_locations_enabled.get() {\n-                let loc = span_start(cx, span);\n-                let scope = scope_metadata(fcx, node_id, span);\n-\n-                set_debug_location(cx, InternalDebugLocation::new(scope,\n-                                                                  loc.line,\n-                                                                  loc.col.to_usize()));\n-            } else {\n-                set_debug_location(cx, UnknownLocation);\n-            }\n-        }\n-    }\n-}\n-\n-/// This function makes sure that all debug locations emitted while executing\n-/// `wrapped_function` are set to the given `debug_loc`.\n-pub fn with_source_location_override<F, R>(fcx: &FunctionContext,\n-                                           debug_loc: DebugLoc,\n-                                           wrapped_function: F) -> R\n-    where F: FnOnce() -> R\n-{\n-    match fcx.debug_context {\n-        FunctionDebugContext::DebugInfoDisabled => {\n-            wrapped_function()\n-        }\n-        FunctionDebugContext::FunctionWithoutDebugInfo => {\n-            set_debug_location(fcx.ccx, UnknownLocation);\n-            wrapped_function()\n-        }\n-        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n-            if function_debug_context.source_location_override.get() {\n-                wrapped_function()\n-            } else {\n-                debug_loc.apply(fcx);\n-                function_debug_context.source_location_override.set(true);\n-                let result = wrapped_function();\n-                function_debug_context.source_location_override.set(false);\n-                result\n-            }\n-        }\n-    }\n-}\n-\n-/// Clears the current debug location.\n-///\n-/// Instructions generated hereafter won't be assigned a source location.\n-pub fn clear_source_location(fcx: &FunctionContext) {\n-    if fn_should_be_ignored(fcx) {\n-        return;\n-    }\n-\n-    set_debug_location(fcx.ccx, UnknownLocation);\n-}\n-\n-/// Enables emitting source locations for the given functions.\n-///\n-/// Since we don't want source locations to be emitted for the function prelude,\n-/// they are disabled when beginning to translate a new function. This functions\n-/// switches source location emitting on and must therefore be called before the\n-/// first real statement/expression of the function is translated.\n-pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n-    match fcx.debug_context {\n-        FunctionDebugContext::RegularContext(box ref data) => {\n-            data.source_locations_enabled.set(true)\n-        },\n-        _ => { /* safe to ignore */ }\n-    }\n-}\n-\n /// Creates the function-specific debug context.\n ///\n /// Returns the FunctionDebugContext for the function which holds state needed\n@@ -1088,7 +213,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Clear the debug location so we don't assign them in the function prelude.\n     // Do this here already, in case we do an early exit from this function.\n-    set_debug_location(cx, UnknownLocation);\n+    source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n \n     if fn_ast_id == ast::DUMMY_NODE_ID {\n         // This is a function not linked to any source location, so don't\n@@ -1254,11 +379,11 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             ptr::null_mut())\n     };\n \n-    let scope_map = create_scope_map(cx,\n-                                     &fn_decl.inputs,\n-                                     &*top_level_block,\n-                                     fn_metadata,\n-                                     fn_ast_id);\n+    let scope_map = create_scope_map::create_scope_map(cx,\n+                                                       &fn_decl.inputs,\n+                                                       &*top_level_block,\n+                                                       fn_metadata,\n+                                                       fn_ast_id);\n \n     // Initialize fn debug context (including scope map and namespace map)\n     let fn_debug_context = box FunctionDebugContextData {\n@@ -1410,139 +535,117 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-// A description of some recursive type. It can either be already finished (as\n-// with FinalMetadata) or it is not yet finished, but contains all information\n-// needed to generate the missing parts of the description. See the\n-// documentation section on Recursive Types at the top of this file for more\n-// information.\n-pub enum RecursiveTypeDescription<'tcx> {\n-    UnfinishedMetadata {\n-        unfinished_type: Ty<'tcx>,\n-        unique_type_id: UniqueTypeId,\n-        metadata_stub: DICompositeType,\n-        llvm_type: Type,\n-        member_description_factory: MemberDescriptionFactory<'tcx>,\n-    },\n-    FinalMetadata(DICompositeType)\n-}\n+fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             variable_name: ast::Name,\n+                             variable_type: Ty<'tcx>,\n+                             scope_metadata: DIScope,\n+                             variable_access: VariableAccess,\n+                             variable_kind: VariableKind,\n+                             span: Span) {\n+    let cx: &CrateContext = bcx.ccx();\n \n-fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n-    cx: &CrateContext<'a, 'tcx>,\n-    unfinished_type: Ty<'tcx>,\n-    unique_type_id: UniqueTypeId,\n-    metadata_stub: DICompositeType,\n-    llvm_type: Type,\n-    member_description_factory: MemberDescriptionFactory<'tcx>)\n- -> RecursiveTypeDescription<'tcx> {\n-\n-    // Insert the stub into the TypeMap in order to allow for recursive references\n-    let mut type_map = debug_context(cx).type_map.borrow_mut();\n-    type_map.register_unique_id_with_metadata(cx, unique_type_id, metadata_stub);\n-    type_map.register_type_with_metadata(cx, unfinished_type, metadata_stub);\n-\n-    UnfinishedMetadata {\n-        unfinished_type: unfinished_type,\n-        unique_type_id: unique_type_id,\n-        metadata_stub: metadata_stub,\n-        llvm_type: llvm_type,\n-        member_description_factory: member_description_factory,\n-    }\n-}\n+    let filename = span_start(cx, span).file.name.clone();\n+    let file_metadata = file_metadata(cx, &filename[..]);\n \n-impl<'tcx> RecursiveTypeDescription<'tcx> {\n-    // Finishes up the description of the type in question (mostly by providing\n-    // descriptions of the fields of the given type) and returns the final type\n-    // metadata.\n-    fn finalize<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> MetadataCreationResult {\n-        match *self {\n-            FinalMetadata(metadata) => MetadataCreationResult::new(metadata, false),\n-            UnfinishedMetadata {\n-                unfinished_type,\n-                unique_type_id,\n-                metadata_stub,\n-                llvm_type,\n-                ref member_description_factory,\n-                ..\n-            } => {\n-                // Make sure that we have a forward declaration of the type in\n-                // the TypeMap so that recursive references are possible. This\n-                // will always be the case if the RecursiveTypeDescription has\n-                // been properly created through the\n-                // create_and_register_recursive_type_forward_declaration()\n-                // function.\n-                {\n-                    let type_map = debug_context(cx).type_map.borrow();\n-                    if type_map.find_metadata_for_unique_id(unique_type_id).is_none() ||\n-                       type_map.find_metadata_for_type(unfinished_type).is_none() {\n-                        cx.sess().bug(&format!(\"Forward declaration of potentially recursive type \\\n-                                              '{}' was not found in TypeMap!\",\n-                                              ppaux::ty_to_string(cx.tcx(), unfinished_type))\n-                                      );\n-                    }\n-                }\n+    let name = token::get_name(variable_name);\n+    let loc = span_start(cx, span);\n+    let type_metadata = type_metadata(cx, variable_type, span);\n \n-                // ... then create the member descriptions ...\n-                let member_descriptions =\n-                    member_description_factory.create_member_descriptions(cx);\n+    let (argument_index, dwarf_tag) = match variable_kind {\n+        ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n+        LocalVariable    |\n+        CapturedVariable => (0, DW_TAG_auto_variable)\n+    };\n \n-                // ... and attach them to the stub to complete it.\n-                set_members_of_composite_type(cx,\n-                                              metadata_stub,\n-                                              llvm_type,\n-                                              &member_descriptions[..]);\n-                return MetadataCreationResult::new(metadata_stub, true);\n+    let name = CString::new(name.as_bytes()).unwrap();\n+    match (variable_access, &[][..]) {\n+        (DirectVariable { alloca }, address_operations) |\n+        (IndirectVariable {alloca, address_operations}, _) => {\n+            let metadata = unsafe {\n+                llvm::LLVMDIBuilderCreateVariable(\n+                    DIB(cx),\n+                    dwarf_tag,\n+                    scope_metadata,\n+                    name.as_ptr(),\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    type_metadata,\n+                    cx.sess().opts.optimize != config::No,\n+                    0,\n+                    address_operations.as_ptr(),\n+                    address_operations.len() as c_uint,\n+                    argument_index)\n+            };\n+            source_loc::set_debug_location(cx, InternalDebugLocation::new(scope_metadata,\n+                                                                          loc.line,\n+                                                                          loc.col.to_usize()));\n+            unsafe {\n+                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+                    DIB(cx),\n+                    alloca,\n+                    metadata,\n+                    address_operations.as_ptr(),\n+                    address_operations.len() as c_uint,\n+                    bcx.llbb);\n+\n+                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n             }\n         }\n     }\n+\n+    match variable_kind {\n+        ArgumentVariable(_) | CapturedVariable => {\n+            assert!(!bcx.fcx\n+                        .debug_context\n+                        .get_ref(cx, span)\n+                        .source_locations_enabled\n+                        .get());\n+            source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n+        }\n+        _ => { /* nothing to do */ }\n+    }\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n-enum InternalDebugLocation {\n-    KnownLocation { scope: DIScope, line: usize, col: usize },\n-    UnknownLocation\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum DebugLoc {\n+    At(ast::NodeId, Span),\n+    None\n }\n \n-impl InternalDebugLocation {\n-    fn new(scope: DIScope, line: usize, col: usize) -> InternalDebugLocation {\n-        KnownLocation {\n-            scope: scope,\n-            line: line,\n-            col: col,\n+impl DebugLoc {\n+    pub fn apply(&self, fcx: &FunctionContext) {\n+        match *self {\n+            DebugLoc::At(node_id, span) => {\n+                source_loc::set_source_location(fcx, node_id, span);\n+            }\n+            DebugLoc::None => {\n+                source_loc::clear_source_location(fcx);\n+            }\n         }\n     }\n }\n \n-fn set_debug_location(cx: &CrateContext, debug_location: InternalDebugLocation) {\n-    if debug_location == debug_context(cx).current_debug_location.get() {\n-        return;\n-    }\n+pub trait ToDebugLoc {\n+    fn debug_loc(&self) -> DebugLoc;\n+}\n \n-    let metadata_node;\n+impl ToDebugLoc for ast::Expr {\n+    fn debug_loc(&self) -> DebugLoc {\n+        DebugLoc::At(self.id, self.span)\n+    }\n+}\n \n-    match debug_location {\n-        KnownLocation { scope, line, .. } => {\n-            // Always set the column to zero like Clang and GCC\n-            let col = UNKNOWN_COLUMN_NUMBER;\n-            debug!(\"setting debug location to {} {}\", line, col);\n+impl ToDebugLoc for NodeIdAndSpan {\n+    fn debug_loc(&self) -> DebugLoc {\n+        DebugLoc::At(self.id, self.span)\n+    }\n+}\n \n-            unsafe {\n-                metadata_node = llvm::LLVMDIBuilderCreateDebugLocation(\n-                    debug_context(cx).llcontext,\n-                    line as c_uint,\n-                    col as c_uint,\n-                    scope,\n-                    ptr::null_mut());\n-            }\n-        }\n-        UnknownLocation => {\n-            debug!(\"clearing debug location \");\n-            metadata_node = ptr::null_mut();\n+impl ToDebugLoc for Option<NodeIdAndSpan> {\n+    fn debug_loc(&self) -> DebugLoc {\n+        match *self {\n+            Some(NodeIdAndSpan { id, span }) => DebugLoc::At(id, span),\n+            None => DebugLoc::None\n         }\n-    };\n-\n-    unsafe {\n-        llvm::LLVMSetCurrentDebugLocation(cx.raw_builder(), metadata_node);\n     }\n-\n-    debug_context(cx).current_debug_location.set(debug_location);\n }"}, {"sha": "981a23fd664a91380c3376c9b3c55738d9d9caf0", "filename": "src/librustc_trans/trans/debuginfo/source_loc.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/7bfb5ed826c3fa6544865095f3f9158d95efb3a3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfb5ed826c3fa6544865095f3f9158d95efb3a3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fsource_loc.rs?ref=7bfb5ed826c3fa6544865095f3f9158d95efb3a3", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self::InternalDebugLocation::*;\n+\n+use super::utils::{debug_context, span_start, fn_should_be_ignored};\n+use super::metadata::{scope_metadata,UNKNOWN_COLUMN_NUMBER};\n+use super::{FunctionDebugContext, DebugLoc};\n+\n+use llvm;\n+use llvm::debuginfo::DIScope;\n+use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext};\n+\n+use libc::c_uint;\n+use std::ptr;\n+use syntax::codemap::{Span, Pos};\n+use syntax::{ast, codemap};\n+\n+pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                                    node_id: ast::NodeId,\n+                                                    node_span: Span,\n+                                                    is_block: bool)\n+                                                 -> NodeIdAndSpan {\n+    // A debug location needs two things:\n+    // (1) A span (of which only the beginning will actually be used)\n+    // (2) An AST node-id which will be used to look up the lexical scope\n+    //     for the location in the functions scope-map\n+    //\n+    // This function will calculate the debug location for compiler-generated\n+    // cleanup calls that are executed when control-flow leaves the\n+    // scope identified by `node_id`.\n+    //\n+    // For everything but block-like things we can simply take id and span of\n+    // the given expression, meaning that from a debugger's view cleanup code is\n+    // executed at the same source location as the statement/expr itself.\n+    //\n+    // Blocks are a special case. Here we want the cleanup to be linked to the\n+    // closing curly brace of the block. The *scope* the cleanup is executed in\n+    // is up to debate: It could either still be *within* the block being\n+    // cleaned up, meaning that locals from the block are still visible in the\n+    // debugger.\n+    // Or it could be in the scope that the block is contained in, so any locals\n+    // from within the block are already considered out-of-scope and thus not\n+    // accessible in the debugger anymore.\n+    //\n+    // The current implementation opts for the second option: cleanup of a block\n+    // already happens in the parent scope of the block. The main reason for\n+    // this decision is that scoping becomes controlflow dependent when variable\n+    // shadowing is involved and it's impossible to decide statically which\n+    // scope is actually left when the cleanup code is executed.\n+    // In practice it shouldn't make much of a difference.\n+\n+    let mut cleanup_span = node_span;\n+\n+    if is_block {\n+        // Not all blocks actually have curly braces (e.g. simple closure\n+        // bodies), in which case we also just want to return the span of the\n+        // whole expression.\n+        let code_snippet = cx.sess().codemap().span_to_snippet(node_span);\n+        if let Ok(code_snippet) = code_snippet {\n+            let bytes = code_snippet.as_bytes();\n+\n+            if !bytes.is_empty() && &bytes[bytes.len()-1..] == b\"}\" {\n+                cleanup_span = Span {\n+                    lo: node_span.hi - codemap::BytePos(1),\n+                    hi: node_span.hi,\n+                    expn_id: node_span.expn_id\n+                };\n+            }\n+        }\n+    }\n+\n+    NodeIdAndSpan {\n+        id: node_id,\n+        span: cleanup_span\n+    }\n+}\n+\n+\n+/// Sets the current debug location at the beginning of the span.\n+///\n+/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id\n+/// parameter is used to reliably find the correct visibility scope for the code\n+/// position.\n+pub fn set_source_location(fcx: &FunctionContext,\n+                           node_id: ast::NodeId,\n+                           span: Span) {\n+    match fcx.debug_context {\n+        FunctionDebugContext::DebugInfoDisabled => return,\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {\n+            set_debug_location(fcx.ccx, UnknownLocation);\n+            return;\n+        }\n+        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n+            if function_debug_context.source_location_override.get() {\n+                // Just ignore any attempts to set a new debug location while\n+                // the override is active.\n+                return;\n+            }\n+\n+            let cx = fcx.ccx;\n+\n+            debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n+\n+            if function_debug_context.source_locations_enabled.get() {\n+                let loc = span_start(cx, span);\n+                let scope = scope_metadata(fcx, node_id, span);\n+\n+                set_debug_location(cx, InternalDebugLocation::new(scope,\n+                                                                  loc.line,\n+                                                                  loc.col.to_usize()));\n+            } else {\n+                set_debug_location(cx, UnknownLocation);\n+            }\n+        }\n+    }\n+}\n+\n+/// This function makes sure that all debug locations emitted while executing\n+/// `wrapped_function` are set to the given `debug_loc`.\n+pub fn with_source_location_override<F, R>(fcx: &FunctionContext,\n+                                           debug_loc: DebugLoc,\n+                                           wrapped_function: F) -> R\n+    where F: FnOnce() -> R\n+{\n+    match fcx.debug_context {\n+        FunctionDebugContext::DebugInfoDisabled => {\n+            wrapped_function()\n+        }\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {\n+            set_debug_location(fcx.ccx, UnknownLocation);\n+            wrapped_function()\n+        }\n+        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n+            if function_debug_context.source_location_override.get() {\n+                wrapped_function()\n+            } else {\n+                debug_loc.apply(fcx);\n+                function_debug_context.source_location_override.set(true);\n+                let result = wrapped_function();\n+                function_debug_context.source_location_override.set(false);\n+                result\n+            }\n+        }\n+    }\n+}\n+\n+/// Clears the current debug location.\n+///\n+/// Instructions generated hereafter won't be assigned a source location.\n+pub fn clear_source_location(fcx: &FunctionContext) {\n+    if fn_should_be_ignored(fcx) {\n+        return;\n+    }\n+\n+    set_debug_location(fcx.ccx, UnknownLocation);\n+}\n+\n+/// Enables emitting source locations for the given functions.\n+///\n+/// Since we don't want source locations to be emitted for the function prelude,\n+/// they are disabled when beginning to translate a new function. This functions\n+/// switches source location emitting on and must therefore be called before the\n+/// first real statement/expression of the function is translated.\n+pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(box ref data) => {\n+            data.source_locations_enabled.set(true)\n+        },\n+        _ => { /* safe to ignore */ }\n+    }\n+}\n+\n+\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum InternalDebugLocation {\n+    KnownLocation { scope: DIScope, line: usize, col: usize },\n+    UnknownLocation\n+}\n+\n+impl InternalDebugLocation {\n+    pub fn new(scope: DIScope, line: usize, col: usize) -> InternalDebugLocation {\n+        KnownLocation {\n+            scope: scope,\n+            line: line,\n+            col: col,\n+        }\n+    }\n+}\n+\n+pub fn set_debug_location(cx: &CrateContext, debug_location: InternalDebugLocation) {\n+    if debug_location == debug_context(cx).current_debug_location.get() {\n+        return;\n+    }\n+\n+    let metadata_node;\n+\n+    match debug_location {\n+        KnownLocation { scope, line, .. } => {\n+            // Always set the column to zero like Clang and GCC\n+            let col = UNKNOWN_COLUMN_NUMBER;\n+            debug!(\"setting debug location to {} {}\", line, col);\n+\n+            unsafe {\n+                metadata_node = llvm::LLVMDIBuilderCreateDebugLocation(\n+                    debug_context(cx).llcontext,\n+                    line as c_uint,\n+                    col as c_uint,\n+                    scope,\n+                    ptr::null_mut());\n+            }\n+        }\n+        UnknownLocation => {\n+            debug!(\"clearing debug location \");\n+            metadata_node = ptr::null_mut();\n+        }\n+    };\n+\n+    unsafe {\n+        llvm::LLVMSetCurrentDebugLocation(cx.raw_builder(), metadata_node);\n+    }\n+\n+    debug_context(cx).current_debug_location.set(debug_location);\n+}"}, {"sha": "2d0003d93a5d25a8a63e332fc42418331e8973a8", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bfb5ed826c3fa6544865095f3f9158d95efb3a3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfb5ed826c3fa6544865095f3f9158d95efb3a3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=7bfb5ed826c3fa6544865095f3f9158d95efb3a3", "previous_filename": "src/librustc_trans/trans/debuginfo/types.rs"}, {"sha": "0c12f6ed095f1b9a36b648053a8dae0fa7e1363b", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "modified", "additions": 22, "deletions": 500, "changes": 522, "blob_url": "https://github.com/rust-lang/rust/blob/7bfb5ed826c3fa6544865095f3f9158d95efb3a3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bfb5ed826c3fa6544865095f3f9158d95efb3a3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=7bfb5ed826c3fa6544865095f3f9158d95efb3a3", "patch": "@@ -12,20 +12,35 @@\n \n use super::{FunctionDebugContext, CrateDebugContext};\n use super::namespace::namespace_for_item;\n-use super::metadata::file_metadata;\n \n use llvm;\n-use llvm::debuginfo::{DIScope, DISubprogram, DIBuilderRef};\n+use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n use trans::machine;\n use trans::common::{CrateContext, FunctionContext};\n use trans::type_::Type;\n-use middle::pat_util;\n-use util::nodemap::NodeMap;\n \n-use libc::c_uint;\n-use syntax::codemap::{Span, Pos};\n-use syntax::{ast, codemap, ast_util};\n+use syntax::codemap::Span;\n+use syntax::{ast, codemap};\n+\n+pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n+{\n+    // The is_local_to_unit flag indicates whether a function is local to the\n+    // current compilation unit (i.e. if it is *static* in the C-sense). The\n+    // *reachable* set should provide a good approximation of this, as it\n+    // contains everything that might leak out of the current crate (by being\n+    // externally visible or by being inlined into something externally\n+    // visible). It might better to use the `exported_items` set from\n+    // `driver::CrateAnalysis` in the future, but (atm) this set is not\n+    // available in the translation pass.\n+    !cx.reachable().contains(&node_id)\n+}\n \n+#[allow(non_snake_case)]\n+pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n+    return unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n+    };\n+}\n \n pub fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n     attributes.iter().any(|attr| {\n@@ -91,496 +106,3 @@ pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n \n     (containing_scope, definition_span)\n }\n-\n-// This procedure builds the *scope map* for a given function, which maps any\n-// given ast::NodeId in the function's AST to the correct DIScope metadata instance.\n-//\n-// This builder procedure walks the AST in execution order and keeps track of\n-// what belongs to which scope, creating DIScope DIEs along the way, and\n-// introducing *artificial* lexical scope descriptors where necessary. These\n-// artificial scopes allow GDB to correctly handle name shadowing.\n-pub fn create_scope_map(cx: &CrateContext,\n-                        args: &[ast::Arg],\n-                        fn_entry_block: &ast::Block,\n-                        fn_metadata: DISubprogram,\n-                        fn_ast_id: ast::NodeId)\n-                        -> NodeMap<DIScope> {\n-    let mut scope_map = NodeMap();\n-\n-    let def_map = &cx.tcx().def_map;\n-\n-    struct ScopeStackEntry {\n-        scope_metadata: DIScope,\n-        name: Option<ast::Name>\n-    }\n-\n-    let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata, name: None });\n-    scope_map.insert(fn_ast_id, fn_metadata);\n-\n-    // Push argument identifiers onto the stack so arguments integrate nicely\n-    // with variable shadowing.\n-    for arg in args {\n-        pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, _, path1| {\n-            scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n-                                               name: Some(path1.node.name) });\n-            scope_map.insert(node_id, fn_metadata);\n-        })\n-    }\n-\n-    // Clang creates a separate scope for function bodies, so let's do this too.\n-    with_new_scope(cx,\n-                   fn_entry_block.span,\n-                   &mut scope_stack,\n-                   &mut scope_map,\n-                   |cx, scope_stack, scope_map| {\n-        walk_block(cx, fn_entry_block, scope_stack, scope_map);\n-    });\n-\n-    return scope_map;\n-\n-\n-    // local helper functions for walking the AST.\n-    fn with_new_scope<F>(cx: &CrateContext,\n-                         scope_span: Span,\n-                         scope_stack: &mut Vec<ScopeStackEntry> ,\n-                         scope_map: &mut NodeMap<DIScope>,\n-                         inner_walk: F) where\n-        F: FnOnce(&CrateContext, &mut Vec<ScopeStackEntry>, &mut NodeMap<DIScope>),\n-    {\n-        // Create a new lexical scope and push it onto the stack\n-        let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n-        let file_metadata = file_metadata(cx, &loc.file.name);\n-        let parent_scope = scope_stack.last().unwrap().scope_metadata;\n-\n-        let scope_metadata = unsafe {\n-            llvm::LLVMDIBuilderCreateLexicalBlock(\n-                DIB(cx),\n-                parent_scope,\n-                file_metadata,\n-                loc.line as c_uint,\n-                loc.col.to_usize() as c_uint)\n-        };\n-\n-        scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata, name: None });\n-\n-        inner_walk(cx, scope_stack, scope_map);\n-\n-        // pop artificial scopes\n-        while scope_stack.last().unwrap().name.is_some() {\n-            scope_stack.pop();\n-        }\n-\n-        if scope_stack.last().unwrap().scope_metadata != scope_metadata {\n-            cx.sess().span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n-        }\n-\n-        scope_stack.pop();\n-    }\n-\n-    fn walk_block(cx: &CrateContext,\n-                  block: &ast::Block,\n-                  scope_stack: &mut Vec<ScopeStackEntry> ,\n-                  scope_map: &mut NodeMap<DIScope>) {\n-        scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n-\n-        // The interesting things here are statements and the concluding expression.\n-        for statement in &block.stmts {\n-            scope_map.insert(ast_util::stmt_id(&**statement),\n-                             scope_stack.last().unwrap().scope_metadata);\n-\n-            match statement.node {\n-                ast::StmtDecl(ref decl, _) =>\n-                    walk_decl(cx, &**decl, scope_stack, scope_map),\n-                ast::StmtExpr(ref exp, _) |\n-                ast::StmtSemi(ref exp, _) =>\n-                    walk_expr(cx, &**exp, scope_stack, scope_map),\n-                ast::StmtMac(..) => () // Ignore macros (which should be expanded anyway).\n-            }\n-        }\n-\n-        if let Some(ref exp) = block.expr {\n-            walk_expr(cx, &**exp, scope_stack, scope_map);\n-        }\n-    }\n-\n-    fn walk_decl(cx: &CrateContext,\n-                 decl: &ast::Decl,\n-                 scope_stack: &mut Vec<ScopeStackEntry> ,\n-                 scope_map: &mut NodeMap<DIScope>) {\n-        match *decl {\n-            codemap::Spanned { node: ast::DeclLocal(ref local), .. } => {\n-                scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n-\n-                walk_pattern(cx, &*local.pat, scope_stack, scope_map);\n-\n-                if let Some(ref exp) = local.init {\n-                    walk_expr(cx, &**exp, scope_stack, scope_map);\n-                }\n-            }\n-            _ => ()\n-        }\n-    }\n-\n-    fn walk_pattern(cx: &CrateContext,\n-                    pat: &ast::Pat,\n-                    scope_stack: &mut Vec<ScopeStackEntry> ,\n-                    scope_map: &mut NodeMap<DIScope>) {\n-\n-        let def_map = &cx.tcx().def_map;\n-\n-        // Unfortunately, we cannot just use pat_util::pat_bindings() or\n-        // ast_util::walk_pat() here because we have to visit *all* nodes in\n-        // order to put them into the scope map. The above functions don't do that.\n-        match pat.node {\n-            ast::PatIdent(_, ref path1, ref sub_pat_opt) => {\n-\n-                // Check if this is a binding. If so we need to put it on the\n-                // scope stack and maybe introduce an artificial scope\n-                if pat_util::pat_is_binding(def_map, &*pat) {\n-\n-                    let name = path1.node.name;\n-\n-                    // LLVM does not properly generate 'DW_AT_start_scope' fields\n-                    // for variable DIEs. For this reason we have to introduce\n-                    // an artificial scope at bindings whenever a variable with\n-                    // the same name is declared in *any* parent scope.\n-                    //\n-                    // Otherwise the following error occurs:\n-                    //\n-                    // let x = 10;\n-                    //\n-                    // do_something(); // 'gdb print x' correctly prints 10\n-                    //\n-                    // {\n-                    //     do_something(); // 'gdb print x' prints 0, because it\n-                    //                     // already reads the uninitialized 'x'\n-                    //                     // from the next line...\n-                    //     let x = 100;\n-                    //     do_something(); // 'gdb print x' correctly prints 100\n-                    // }\n-\n-                    // Is there already a binding with that name?\n-                    // N.B.: this comparison must be UNhygienic... because\n-                    // gdb knows nothing about the context, so any two\n-                    // variables with the same name will cause the problem.\n-                    let need_new_scope = scope_stack\n-                        .iter()\n-                        .any(|entry| entry.name == Some(name));\n-\n-                    if need_new_scope {\n-                        // Create a new lexical scope and push it onto the stack\n-                        let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n-                        let file_metadata = file_metadata(cx, &loc.file.name);\n-                        let parent_scope = scope_stack.last().unwrap().scope_metadata;\n-\n-                        let scope_metadata = unsafe {\n-                            llvm::LLVMDIBuilderCreateLexicalBlock(\n-                                DIB(cx),\n-                                parent_scope,\n-                                file_metadata,\n-                                loc.line as c_uint,\n-                                loc.col.to_usize() as c_uint)\n-                        };\n-\n-                        scope_stack.push(ScopeStackEntry {\n-                            scope_metadata: scope_metadata,\n-                            name: Some(name)\n-                        });\n-\n-                    } else {\n-                        // Push a new entry anyway so the name can be found\n-                        let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n-                        scope_stack.push(ScopeStackEntry {\n-                            scope_metadata: prev_metadata,\n-                            name: Some(name)\n-                        });\n-                    }\n-                }\n-\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-                if let Some(ref sub_pat) = *sub_pat_opt {\n-                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n-                }\n-            }\n-\n-            ast::PatWild(_) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-            }\n-\n-            ast::PatEnum(_, ref sub_pats_opt) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-                if let Some(ref sub_pats) = *sub_pats_opt {\n-                    for p in sub_pats {\n-                        walk_pattern(cx, &**p, scope_stack, scope_map);\n-                    }\n-                }\n-            }\n-\n-            ast::PatQPath(..) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-            }\n-\n-            ast::PatStruct(_, ref field_pats, _) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-                for &codemap::Spanned {\n-                    node: ast::FieldPat { pat: ref sub_pat, .. },\n-                    ..\n-                } in field_pats.iter() {\n-                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n-                }\n-            }\n-\n-            ast::PatTup(ref sub_pats) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-                for sub_pat in sub_pats {\n-                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n-                }\n-            }\n-\n-            ast::PatBox(ref sub_pat) | ast::PatRegion(ref sub_pat, _) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n-            }\n-\n-            ast::PatLit(ref exp) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-                walk_expr(cx, &**exp, scope_stack, scope_map);\n-            }\n-\n-            ast::PatRange(ref exp1, ref exp2) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-                walk_expr(cx, &**exp1, scope_stack, scope_map);\n-                walk_expr(cx, &**exp2, scope_stack, scope_map);\n-            }\n-\n-            ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n-                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-\n-                for sub_pat in front_sub_pats {\n-                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n-                }\n-\n-                if let Some(ref sub_pat) = *middle_sub_pats {\n-                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n-                }\n-\n-                for sub_pat in back_sub_pats {\n-                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n-                }\n-            }\n-\n-            ast::PatMac(_) => {\n-                cx.sess().span_bug(pat.span, \"debuginfo::create_scope_map() - \\\n-                                              Found unexpanded macro.\");\n-            }\n-        }\n-    }\n-\n-    fn walk_expr(cx: &CrateContext,\n-                 exp: &ast::Expr,\n-                 scope_stack: &mut Vec<ScopeStackEntry> ,\n-                 scope_map: &mut NodeMap<DIScope>) {\n-\n-        scope_map.insert(exp.id, scope_stack.last().unwrap().scope_metadata);\n-\n-        match exp.node {\n-            ast::ExprLit(_)   |\n-            ast::ExprBreak(_) |\n-            ast::ExprAgain(_) |\n-            ast::ExprPath(..) => {}\n-\n-            ast::ExprCast(ref sub_exp, _)     |\n-            ast::ExprAddrOf(_, ref sub_exp)  |\n-            ast::ExprField(ref sub_exp, _) |\n-            ast::ExprTupField(ref sub_exp, _) |\n-            ast::ExprParen(ref sub_exp) =>\n-                walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n-\n-            ast::ExprBox(ref place, ref sub_expr) => {\n-                place.as_ref().map(\n-                    |e| walk_expr(cx, &**e, scope_stack, scope_map));\n-                walk_expr(cx, &**sub_expr, scope_stack, scope_map);\n-            }\n-\n-            ast::ExprRet(ref exp_opt) => match *exp_opt {\n-                Some(ref sub_exp) => walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n-                None => ()\n-            },\n-\n-            ast::ExprUnary(_, ref sub_exp) => {\n-                walk_expr(cx, &**sub_exp, scope_stack, scope_map);\n-            }\n-\n-            ast::ExprAssignOp(_, ref lhs, ref rhs) |\n-            ast::ExprIndex(ref lhs, ref rhs) |\n-            ast::ExprBinary(_, ref lhs, ref rhs)    => {\n-                walk_expr(cx, &**lhs, scope_stack, scope_map);\n-                walk_expr(cx, &**rhs, scope_stack, scope_map);\n-            }\n-\n-            ast::ExprRange(ref start, ref end) => {\n-                start.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n-                end.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n-            }\n-\n-            ast::ExprVec(ref init_expressions) |\n-            ast::ExprTup(ref init_expressions) => {\n-                for ie in init_expressions {\n-                    walk_expr(cx, &**ie, scope_stack, scope_map);\n-                }\n-            }\n-\n-            ast::ExprAssign(ref sub_exp1, ref sub_exp2) |\n-            ast::ExprRepeat(ref sub_exp1, ref sub_exp2) => {\n-                walk_expr(cx, &**sub_exp1, scope_stack, scope_map);\n-                walk_expr(cx, &**sub_exp2, scope_stack, scope_map);\n-            }\n-\n-            ast::ExprIf(ref cond_exp, ref then_block, ref opt_else_exp) => {\n-                walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n-\n-                with_new_scope(cx,\n-                               then_block.span,\n-                               scope_stack,\n-                               scope_map,\n-                               |cx, scope_stack, scope_map| {\n-                    walk_block(cx, &**then_block, scope_stack, scope_map);\n-                });\n-\n-                match *opt_else_exp {\n-                    Some(ref else_exp) =>\n-                        walk_expr(cx, &**else_exp, scope_stack, scope_map),\n-                    _ => ()\n-                }\n-            }\n-\n-            ast::ExprIfLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n-                                              Found unexpanded if-let.\");\n-            }\n-\n-            ast::ExprWhile(ref cond_exp, ref loop_body, _) => {\n-                walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n-\n-                with_new_scope(cx,\n-                               loop_body.span,\n-                               scope_stack,\n-                               scope_map,\n-                               |cx, scope_stack, scope_map| {\n-                    walk_block(cx, &**loop_body, scope_stack, scope_map);\n-                })\n-            }\n-\n-            ast::ExprWhileLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n-                                              Found unexpanded while-let.\");\n-            }\n-\n-            ast::ExprForLoop(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n-                                              Found unexpanded for loop.\");\n-            }\n-\n-            ast::ExprMac(_) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n-                                              Found unexpanded macro.\");\n-            }\n-\n-            ast::ExprLoop(ref block, _) |\n-            ast::ExprBlock(ref block)   => {\n-                with_new_scope(cx,\n-                               block.span,\n-                               scope_stack,\n-                               scope_map,\n-                               |cx, scope_stack, scope_map| {\n-                    walk_block(cx, &**block, scope_stack, scope_map);\n-                })\n-            }\n-\n-            ast::ExprClosure(_, ref decl, ref block) => {\n-                with_new_scope(cx,\n-                               block.span,\n-                               scope_stack,\n-                               scope_map,\n-                               |cx, scope_stack, scope_map| {\n-                    for &ast::Arg { pat: ref pattern, .. } in &decl.inputs {\n-                        walk_pattern(cx, &**pattern, scope_stack, scope_map);\n-                    }\n-\n-                    walk_block(cx, &**block, scope_stack, scope_map);\n-                })\n-            }\n-\n-            ast::ExprCall(ref fn_exp, ref args) => {\n-                walk_expr(cx, &**fn_exp, scope_stack, scope_map);\n-\n-                for arg_exp in args {\n-                    walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n-                }\n-            }\n-\n-            ast::ExprMethodCall(_, _, ref args) => {\n-                for arg_exp in args {\n-                    walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n-                }\n-            }\n-\n-            ast::ExprMatch(ref discriminant_exp, ref arms, _) => {\n-                walk_expr(cx, &**discriminant_exp, scope_stack, scope_map);\n-\n-                // For each arm we have to first walk the pattern as these might\n-                // introduce new artificial scopes. It should be sufficient to\n-                // walk only one pattern per arm, as they all must contain the\n-                // same binding names.\n-\n-                for arm_ref in arms {\n-                    let arm_span = arm_ref.pats[0].span;\n-\n-                    with_new_scope(cx,\n-                                   arm_span,\n-                                   scope_stack,\n-                                   scope_map,\n-                                   |cx, scope_stack, scope_map| {\n-                        for pat in &arm_ref.pats {\n-                            walk_pattern(cx, &**pat, scope_stack, scope_map);\n-                        }\n-\n-                        if let Some(ref guard_exp) = arm_ref.guard {\n-                            walk_expr(cx, &**guard_exp, scope_stack, scope_map)\n-                        }\n-\n-                        walk_expr(cx, &*arm_ref.body, scope_stack, scope_map);\n-                    })\n-                }\n-            }\n-\n-            ast::ExprStruct(_, ref fields, ref base_exp) => {\n-                for &ast::Field { expr: ref exp, .. } in fields {\n-                    walk_expr(cx, &**exp, scope_stack, scope_map);\n-                }\n-\n-                match *base_exp {\n-                    Some(ref exp) => walk_expr(cx, &**exp, scope_stack, scope_map),\n-                    None => ()\n-                }\n-            }\n-\n-            ast::ExprInlineAsm(ast::InlineAsm { ref inputs,\n-                                                ref outputs,\n-                                                .. }) => {\n-                // inputs, outputs: Vec<(String, P<Expr>)>\n-                for &(_, ref exp) in inputs {\n-                    walk_expr(cx, &**exp, scope_stack, scope_map);\n-                }\n-\n-                for &(_, ref exp, _) in outputs {\n-                    walk_expr(cx, &**exp, scope_stack, scope_map);\n-                }\n-            }\n-        }\n-    }\n-}"}]}