{"sha": "42d7174bbc6f89f15a233d663f212e5e731f4722", "node_id": "C_kwDOAAsO6NoAKDQyZDcxNzRiYmM2Zjg5ZjE1YTIzM2Q2NjNmMjEyZTVlNzMxZjQ3MjI", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-11-03T18:52:26Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-11-23T20:17:47Z"}, "message": "Extract suggestion logic to its own method", "tree": {"sha": "ca2aad7ae6f706ba48fcd23c340e936804b4b07f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca2aad7ae6f706ba48fcd23c340e936804b4b07f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42d7174bbc6f89f15a233d663f212e5e731f4722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42d7174bbc6f89f15a233d663f212e5e731f4722", "html_url": "https://github.com/rust-lang/rust/commit/42d7174bbc6f89f15a233d663f212e5e731f4722", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42d7174bbc6f89f15a233d663f212e5e731f4722/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14a3d572e62dd1b7a69495ab5b4a04798b2bdc51", "url": "https://api.github.com/repos/rust-lang/rust/commits/14a3d572e62dd1b7a69495ab5b4a04798b2bdc51", "html_url": "https://github.com/rust-lang/rust/commit/14a3d572e62dd1b7a69495ab5b4a04798b2bdc51"}], "stats": {"total": 296, "additions": 156, "deletions": 140}, "files": [{"sha": "3b888940c2d85bf28036f83025d4fcc5ad365da4", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 156, "deletions": 140, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/42d7174bbc6f89f15a233d663f212e5e731f4722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42d7174bbc6f89f15a233d663f212e5e731f4722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=42d7174bbc6f89f15a233d663f212e5e731f4722", "patch": "@@ -192,146 +192,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     is_loop_move = true;\n                 }\n \n-                struct ExpressionFinder<'hir> {\n-                    expr_span: Span,\n-                    expr: Option<&'hir hir::Expr<'hir>>,\n-                    pat: Option<&'hir hir::Pat<'hir>>,\n-                }\n-                impl<'hir> Visitor<'hir> for ExpressionFinder<'hir> {\n-                    fn visit_expr(&mut self, e: &'hir hir::Expr<'hir>) {\n-                        if e.span == self.expr_span {\n-                            self.expr = Some(e);\n-                        }\n-                        hir::intravisit::walk_expr(self, e);\n-                    }\n-                    fn visit_pat(&mut self, p: &'hir hir::Pat<'hir>) {\n-                        if p.span == self.expr_span {\n-                            self.pat = Some(p);\n-                        }\n-                        if let hir::PatKind::Binding(hir::BindingAnnotation::NONE, _, i, _) = p.kind\n-                            && i.span == self.expr_span\n-                        {\n-                            self.pat = Some(p);\n-                        }\n-                        hir::intravisit::walk_pat(self, p);\n-                    }\n-                }\n-\n-                let hir = self.infcx.tcx.hir();\n-                if let Some(hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Fn(_, _, body_id),\n-                    ..\n-                })) = hir.find(hir.local_def_id_to_hir_id(self.mir_def_id()))\n-                    && let Some(hir::Node::Expr(expr)) = hir.find(body_id.hir_id)\n-                {\n-                    let place = &self.move_data.move_paths[mpi].place;\n-                    let span = place.as_local()\n-                        .map(|local| self.body.local_decls[local].source_info.span);\n-                    let mut finder = ExpressionFinder {\n-                        expr_span: move_span,\n-                        expr: None,\n-                        pat: None,\n-                    };\n-                    finder.visit_expr(expr);\n-                    if let Some(span) = span && let Some(expr) = finder.expr {\n-                        for (_, expr) in hir.parent_iter(expr.hir_id) {\n-                            if let hir::Node::Expr(expr) = expr {\n-                                if expr.span.contains(span) {\n-                                    // If the let binding occurs within the same loop, then that\n-                                    // loop isn't relevant, like in the following, the outermost `loop`\n-                                    // doesn't play into `x` being moved.\n-                                    // ```\n-                                    // loop {\n-                                    //     let x = String::new();\n-                                    //     loop {\n-                                    //         foo(x);\n-                                    //     }\n-                                    // }\n-                                    // ```\n-                                    break;\n-                                }\n-                                if let hir::ExprKind::Loop(.., loop_span) = expr.kind {\n-                                    err.span_label(loop_span, \"inside of this loop\");\n-                                }\n-                            }\n-                        }\n-                        let typeck = self.infcx.tcx.typeck(self.mir_def_id());\n-                        let hir_id = hir.get_parent_node(expr.hir_id);\n-                        if let Some(parent) = hir.find(hir_id) {\n-                            if let hir::Node::Expr(parent_expr) = parent\n-                                && let hir::ExprKind::MethodCall(_, _, args, _) = parent_expr.kind\n-                                && let Some(def_id) = typeck.type_dependent_def_id(parent_expr.hir_id)\n-                                && let Some(def_id) = def_id.as_local()\n-                                && let Some(node) = hir.find(hir.local_def_id_to_hir_id(def_id))\n-                                && let Some(fn_sig) = node.fn_sig()\n-                                && let Some(ident) = node.ident()\n-                                && let Some(pos) = args.iter()\n-                                    .position(|arg| arg.hir_id == expr.hir_id)\n-                                && let Some(arg) = fn_sig.decl.inputs.get(pos + 1)\n-                            {\n-                                let mut span: MultiSpan = arg.span.into();\n-                                span.push_span_label(\n-                                    arg.span,\n-                                    \"this type parameter takes ownership of the value\".to_string(),\n-                                );\n-                                span.push_span_label(\n-                                    ident.span,\n-                                    \"in this method\".to_string(),\n-                                );\n-                                err.span_note(\n-                                    span,\n-                                    format!(\n-                                        \"consider changing this parameter type in `{}` to borrow \\\n-                                         instead if ownering the value isn't necessary\",\n-                                        ident,\n-                                    ),\n-                                );\n-                            }\n-                            if let hir::Node::Expr(parent_expr) = parent\n-                                && let hir::ExprKind::Call(call, args) = parent_expr.kind\n-                                && let ty::FnDef(def_id, _) = typeck.node_type(call.hir_id).kind()\n-                                && let Some(def_id) = def_id.as_local()\n-                                && let Some(node) = hir.find(hir.local_def_id_to_hir_id(def_id))\n-                                && let Some(fn_sig) = node.fn_sig()\n-                                && let Some(ident) = node.ident()\n-                                && let Some(pos) = args.iter()\n-                                    .position(|arg| arg.hir_id == expr.hir_id)\n-                                && let Some(arg) = fn_sig.decl.inputs.get(pos)\n-                            {\n-                                let mut span: MultiSpan = arg.span.into();\n-                                span.push_span_label(\n-                                    arg.span,\n-                                    \"this type parameter takes ownership of the value\".to_string(),\n-                                );\n-                                span.push_span_label(\n-                                    ident.span,\n-                                    \"in this function\".to_string(),\n-                                );\n-                                err.span_note(\n-                                    span,\n-                                    format!(\n-                                        \"consider changing this parameter type in `{}` to borrow \\\n-                                         instead if ownering the value isn't necessary\",\n-                                        ident,\n-                                    ),\n-                                );\n-                            }\n-                            let place = &self.move_data.move_paths[mpi].place;\n-                            let ty = place.ty(self.body, self.infcx.tcx).ty;\n-                            self.suggest_cloning(&mut err, ty, move_span);\n-                        }\n-                    }\n-                    if let Some(pat) = finder.pat && !seen_spans.contains(&pat.span) {\n-                        in_pattern = true;\n-                        err.span_suggestion_verbose(\n-                            pat.span.shrink_to_lo(),\n-                            \"borrow this binding in the pattern to avoid moving the value\",\n-                            \"ref \".to_string(),\n-                            Applicability::MachineApplicable,\n-                        );\n-                        seen_spans.insert(pat.span);\n-                    }\n-                }\n+                self.suggest_ref_or_clone(\n+                    mpi,\n+                    move_span,\n+                    &mut err,\n+                    &mut seen_spans,\n+                    &mut in_pattern,\n+                );\n \n                 self.explain_captures(\n                     &mut err,\n@@ -440,6 +307,155 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    fn suggest_ref_or_clone(\n+        &mut self,\n+        mpi: MovePathIndex,\n+        move_span: Span,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        seen_spans: &mut FxHashSet<Span>,\n+        in_pattern: &mut bool,\n+    ) {\n+        struct ExpressionFinder<'hir> {\n+            expr_span: Span,\n+            expr: Option<&'hir hir::Expr<'hir>>,\n+            pat: Option<&'hir hir::Pat<'hir>>,\n+        }\n+        impl<'hir> Visitor<'hir> for ExpressionFinder<'hir> {\n+            fn visit_expr(&mut self, e: &'hir hir::Expr<'hir>) {\n+                if e.span == self.expr_span {\n+                    self.expr = Some(e);\n+                }\n+                hir::intravisit::walk_expr(self, e);\n+            }\n+            fn visit_pat(&mut self, p: &'hir hir::Pat<'hir>) {\n+                if p.span == self.expr_span {\n+                    self.pat = Some(p);\n+                }\n+                if let hir::PatKind::Binding(hir::BindingAnnotation::NONE, _, i, _) = p.kind\n+                    && i.span == self.expr_span\n+                {\n+                    self.pat = Some(p);\n+                }\n+                hir::intravisit::walk_pat(self, p);\n+            }\n+        }\n+        let hir = self.infcx.tcx.hir();\n+        if let Some(hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(_, _, body_id),\n+            ..\n+        })) = hir.find(hir.local_def_id_to_hir_id(self.mir_def_id()))\n+            && let Some(hir::Node::Expr(expr)) = hir.find(body_id.hir_id)\n+        {\n+            let place = &self.move_data.move_paths[mpi].place;\n+            let span = place.as_local()\n+                .map(|local| self.body.local_decls[local].source_info.span);\n+            let mut finder = ExpressionFinder {\n+                expr_span: move_span,\n+                expr: None,\n+                pat: None,\n+            };\n+            finder.visit_expr(expr);\n+            if let Some(span) = span && let Some(expr) = finder.expr {\n+                for (_, expr) in hir.parent_iter(expr.hir_id) {\n+                    if let hir::Node::Expr(expr) = expr {\n+                        if expr.span.contains(span) {\n+                            // If the let binding occurs within the same loop, then that\n+                            // loop isn't relevant, like in the following, the outermost `loop`\n+                            // doesn't play into `x` being moved.\n+                            // ```\n+                            // loop {\n+                            //     let x = String::new();\n+                            //     loop {\n+                            //         foo(x);\n+                            //     }\n+                            // }\n+                            // ```\n+                            break;\n+                        }\n+                        if let hir::ExprKind::Loop(.., loop_span) = expr.kind {\n+                            err.span_label(loop_span, \"inside of this loop\");\n+                        }\n+                    }\n+                }\n+                let typeck = self.infcx.tcx.typeck(self.mir_def_id());\n+                let hir_id = hir.get_parent_node(expr.hir_id);\n+                if let Some(parent) = hir.find(hir_id) {\n+                    if let hir::Node::Expr(parent_expr) = parent\n+                        && let hir::ExprKind::MethodCall(_, _, args, _) = parent_expr.kind\n+                        && let Some(def_id) = typeck.type_dependent_def_id(parent_expr.hir_id)\n+                        && let Some(def_id) = def_id.as_local()\n+                        && let Some(node) = hir.find(hir.local_def_id_to_hir_id(def_id))\n+                        && let Some(fn_sig) = node.fn_sig()\n+                        && let Some(ident) = node.ident()\n+                        && let Some(pos) = args.iter()\n+                            .position(|arg| arg.hir_id == expr.hir_id)\n+                        && let Some(arg) = fn_sig.decl.inputs.get(pos + 1)\n+                    {\n+                        let mut span: MultiSpan = arg.span.into();\n+                        span.push_span_label(\n+                            arg.span,\n+                            \"this type parameter takes ownership of the value\".to_string(),\n+                        );\n+                        span.push_span_label(\n+                            ident.span,\n+                            \"in this method\".to_string(),\n+                        );\n+                        err.span_note(\n+                            span,\n+                            format!(\n+                                \"consider changing this parameter type in `{}` to borrow instead \\\n+                                 if ownering the value isn't necessary\",\n+                                ident,\n+                            ),\n+                        );\n+                    }\n+                    if let hir::Node::Expr(parent_expr) = parent\n+                        && let hir::ExprKind::Call(call, args) = parent_expr.kind\n+                        && let ty::FnDef(def_id, _) = typeck.node_type(call.hir_id).kind()\n+                        && let Some(def_id) = def_id.as_local()\n+                        && let Some(node) = hir.find(hir.local_def_id_to_hir_id(def_id))\n+                        && let Some(fn_sig) = node.fn_sig()\n+                        && let Some(ident) = node.ident()\n+                        && let Some(pos) = args.iter()\n+                            .position(|arg| arg.hir_id == expr.hir_id)\n+                        && let Some(arg) = fn_sig.decl.inputs.get(pos)\n+                    {\n+                        let mut span: MultiSpan = arg.span.into();\n+                        span.push_span_label(\n+                            arg.span,\n+                            \"this type parameter takes ownership of the value\".to_string(),\n+                        );\n+                        span.push_span_label(\n+                            ident.span,\n+                            \"in this function\".to_string(),\n+                        );\n+                        err.span_note(\n+                            span,\n+                            format!(\n+                                \"consider changing this parameter type in `{}` to borrow instead \\\n+                                 if ownering the value isn't necessary\",\n+                                ident,\n+                            ),\n+                        );\n+                    }\n+                    let place = &self.move_data.move_paths[mpi].place;\n+                    let ty = place.ty(self.body, self.infcx.tcx).ty;\n+                    self.suggest_cloning(err, ty, move_span);\n+                }\n+            }\n+            if let Some(pat) = finder.pat && !seen_spans.contains(&pat.span) {\n+                *in_pattern = true;\n+                err.span_suggestion_verbose(\n+                    pat.span.shrink_to_lo(),\n+                    \"borrow this binding in the pattern to avoid moving the value\",\n+                    \"ref \".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+                seen_spans.insert(pat.span);\n+            }\n+        }\n+    }\n+\n     fn report_use_of_uninitialized(\n         &self,\n         mpi: MovePathIndex,"}]}