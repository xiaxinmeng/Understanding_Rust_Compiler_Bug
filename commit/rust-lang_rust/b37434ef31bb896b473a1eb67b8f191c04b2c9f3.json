{"sha": "b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNzQzNGVmMzFiYjg5NmI0NzNhMWViNjdiOGYxOTFjMDRiMmM5ZjM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-07-01T10:16:49Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-07-01T10:40:46Z"}, "message": "Remove `token::FlattenGroup`", "tree": {"sha": "f6ed654cdfabff9abe81dfe4198b85ffc0bf1aca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6ed654cdfabff9abe81dfe4198b85ffc0bf1aca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "html_url": "https://github.com/rust-lang/rust/commit/b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5764de00b8d953a4071c9318a31628fa0549982", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5764de00b8d953a4071c9318a31628fa0549982", "html_url": "https://github.com/rust-lang/rust/commit/a5764de00b8d953a4071c9318a31628fa0549982"}], "stats": {"total": 106, "additions": 42, "deletions": 64}, "files": [{"sha": "b812f2dadf6d40321e22740da1c7dad7047c3471", "filename": "src/librustc_ast/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fattr%2Fmod.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -475,7 +475,7 @@ impl MetaItem {\n                 let span = span.with_hi(segments.last().unwrap().ident.span.hi());\n                 Path { span, segments }\n             }\n-            Some(TokenTree::Token(Token { kind: token::Interpolated(nt, _), .. })) => match *nt {\n+            Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. })) => match *nt {\n                 token::Nonterminal::NtMeta(ref item) => return item.meta(item.path.span),\n                 token::Nonterminal::NtPath(ref path) => path.clone(),\n                 _ => return None,"}, {"sha": "54f81ef106fe14e39424e5f26fcb4c74212aa43b", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -656,7 +656,7 @@ pub fn noop_visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n             *span = ident.span;\n             return; // Avoid visiting the span for the second time.\n         }\n-        token::Interpolated(nt, _) => {\n+        token::Interpolated(nt) => {\n             let mut nt = Lrc::make_mut(nt);\n             vis.visit_interpolated(&mut nt);\n         }"}, {"sha": "0f0428574de0f99adb9371553f299572b4fa13b7", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -182,15 +182,6 @@ fn ident_can_begin_type(name: Symbol, span: Span, is_raw: bool) -> bool {\n             .contains(&name)\n }\n \n-/// A hack used to pass AST fragments to attribute and derive macros\n-/// as a single nonterminal token instead of a token stream.\n-/// FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n-pub enum FlattenGroup {\n-    Yes,\n-    No,\n-}\n-\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum TokenKind {\n     /* Expression-operator symbols. */\n@@ -245,7 +236,7 @@ pub enum TokenKind {\n     /// treat regular and interpolated lifetime identifiers in the same way.\n     Lifetime(Symbol),\n \n-    Interpolated(Lrc<Nonterminal>, FlattenGroup),\n+    Interpolated(Lrc<Nonterminal>),\n \n     // Can be expanded into several tokens.\n     /// A doc comment.\n@@ -352,7 +343,7 @@ impl Token {\n     /// if they keep spans or perform edition checks.\n     pub fn uninterpolated_span(&self) -> Span {\n         match &self.kind {\n-            Interpolated(nt, _) => nt.span(),\n+            Interpolated(nt) => nt.span(),\n             _ => self.span,\n         }\n     }\n@@ -391,7 +382,7 @@ impl Token {\n             ModSep                            | // global path\n             Lifetime(..)                      | // labeled loop\n             Pound                             => true, // expression attributes\n-            Interpolated(ref nt, _) => match **nt {\n+            Interpolated(ref nt) => match **nt {\n                 NtLiteral(..) |\n                 NtExpr(..)    |\n                 NtBlock(..)   |\n@@ -417,7 +408,7 @@ impl Token {\n             Lifetime(..)                | // lifetime bound in trait object\n             Lt | BinOp(Shl)             | // associated path\n             ModSep                      => true, // global path\n-            Interpolated(ref nt, _) => match **nt {\n+            Interpolated(ref nt) => match **nt {\n                 NtTy(..) | NtPath(..) => true,\n                 _ => false,\n             },\n@@ -429,7 +420,7 @@ impl Token {\n     pub fn can_begin_const_arg(&self) -> bool {\n         match self.kind {\n             OpenDelim(Brace) => true,\n-            Interpolated(ref nt, _) => match **nt {\n+            Interpolated(ref nt) => match **nt {\n                 NtExpr(..) | NtBlock(..) | NtLiteral(..) => true,\n                 _ => false,\n             },\n@@ -464,7 +455,7 @@ impl Token {\n         match self.uninterpolate().kind {\n             Literal(..) | BinOp(Minus) => true,\n             Ident(name, false) if name.is_bool_lit() => true,\n-            Interpolated(ref nt, _) => match &**nt {\n+            Interpolated(ref nt) => match &**nt {\n                 NtLiteral(_) => true,\n                 NtExpr(e) => match &e.kind {\n                     ast::ExprKind::Lit(_) => true,\n@@ -485,7 +476,7 @@ impl Token {\n     // otherwise returns the original token.\n     pub fn uninterpolate(&self) -> Cow<'_, Token> {\n         match &self.kind {\n-            Interpolated(nt, _) => match **nt {\n+            Interpolated(nt) => match **nt {\n                 NtIdent(ident, is_raw) => {\n                     Cow::Owned(Token::new(Ident(ident.name, is_raw), ident.span))\n                 }\n@@ -532,7 +523,7 @@ impl Token {\n \n     /// Returns `true` if the token is an interpolated path.\n     fn is_path(&self) -> bool {\n-        if let Interpolated(ref nt, _) = self.kind {\n+        if let Interpolated(ref nt) = self.kind {\n             if let NtPath(..) = **nt {\n                 return true;\n             }\n@@ -544,7 +535,7 @@ impl Token {\n     /// That is, is this a pre-parsed expression dropped into the token stream\n     /// (which happens while parsing the result of macro expansion)?\n     pub fn is_whole_expr(&self) -> bool {\n-        if let Interpolated(ref nt, _) = self.kind {\n+        if let Interpolated(ref nt) = self.kind {\n             if let NtExpr(_) | NtLiteral(_) | NtPath(_) | NtIdent(..) | NtBlock(_) = **nt {\n                 return true;\n             }\n@@ -555,7 +546,7 @@ impl Token {\n \n     // Is the token an interpolated block (`$b:block`)?\n     pub fn is_whole_block(&self) -> bool {\n-        if let Interpolated(ref nt, _) = self.kind {\n+        if let Interpolated(ref nt) = self.kind {\n             if let NtBlock(..) = **nt {\n                 return true;\n             }"}, {"sha": "4428d09902b92d6b8a3360e130737b33eb66b32d", "filename": "src/librustc_ast/util/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fliteral.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -205,7 +205,7 @@ impl Lit {\n                 token::Lit::new(token::Bool, name, None)\n             }\n             token::Literal(lit) => lit,\n-            token::Interpolated(ref nt, _) => {\n+            token::Interpolated(ref nt) => {\n                 if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt {\n                     if let ast::ExprKind::Lit(lit) = &expr.kind {\n                         return Ok(lit.clone());"}, {"sha": "0ad74a8e2056af20abd18b59e016941045fa7b92", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -1027,7 +1027,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn lower_token(&mut self, token: Token) -> TokenStream {\n         match token.kind {\n-            token::Interpolated(nt, _) => {\n+            token::Interpolated(nt) => {\n                 let tts = (self.nt_to_tokenstream)(&nt, &self.sess.parse_sess, token.span);\n                 self.lower_token_stream(tts)\n             }"}, {"sha": "d7e816cec901ef8929dd88244313e53124750eb4", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -278,7 +278,7 @@ fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>)\n         token::Shebang(s) => format!(\"/* shebang: {}*/\", s),\n         token::Unknown(s) => s.to_string(),\n \n-        token::Interpolated(ref nt, _) => nonterminal_to_string(nt),\n+        token::Interpolated(ref nt) => nonterminal_to_string(nt),\n     }\n }\n "}, {"sha": "db9293bddeb7d446f6ba50e06d544fd6662ecbe4", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -371,7 +371,7 @@ where\n         impl MutVisitor for AvoidInterpolatedIdents {\n             fn visit_tt(&mut self, tt: &mut tokenstream::TokenTree) {\n                 if let tokenstream::TokenTree::Token(token) = tt {\n-                    if let token::Interpolated(nt, _) = &token.kind {\n+                    if let token::Interpolated(nt) = &token.kind {\n                         if let token::NtIdent(ident, is_raw) = **nt {\n                             *tt = tokenstream::TokenTree::token(\n                                 token::Ident(ident.name, is_raw),"}, {"sha": "3c15a81c67f6748af6fa10849c90916984e09d72", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -790,7 +790,7 @@ fn may_begin_with(token: &Token, name: Symbol) -> bool {\n         },\n         sym::block => match token.kind {\n             token::OpenDelim(token::Brace) => true,\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtItem(_)\n                 | token::NtPat(_)\n                 | token::NtTy(_)\n@@ -804,7 +804,7 @@ fn may_begin_with(token: &Token, name: Symbol) -> bool {\n         },\n         sym::path | sym::meta => match token.kind {\n             token::ModSep | token::Ident(..) => true,\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtPath(_) | token::NtMeta(_) => true,\n                 _ => may_be_ident(&nt),\n             },\n@@ -823,12 +823,12 @@ fn may_begin_with(token: &Token, name: Symbol) -> bool {\n             token::ModSep |                     // path\n             token::Lt |                         // path (UFCS constant)\n             token::BinOp(token::Shl) => true,   // path (double UFCS)\n-            token::Interpolated(ref nt, _) => may_be_ident(nt),\n+            token::Interpolated(ref nt) => may_be_ident(nt),\n             _ => false,\n         },\n         sym::lifetime => match token.kind {\n             token::Lifetime(_) => true,\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtLifetime(_) | token::NtTT(_) => true,\n                 _ => false,\n             },"}, {"sha": "e2d3d5c4d644e04076ac1fbb31ac672bdfa7f29e", "filename": "src/librustc_expand/mbe/transcribe.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -4,7 +4,7 @@ use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n \n use rustc_ast::ast::MacCall;\n use rustc_ast::mut_visit::{self, MutVisitor};\n-use rustc_ast::token::{self, FlattenGroup, NtTT, Token};\n+use rustc_ast::token::{self, NtTT, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -240,10 +240,7 @@ pub(super) fn transcribe<'a>(\n                             result.push(tt.clone().into());\n                         } else {\n                             marker.visit_span(&mut sp);\n-                            let token = TokenTree::token(\n-                                token::Interpolated(nt.clone(), FlattenGroup::No),\n-                                sp,\n-                            );\n+                            let token = TokenTree::token(token::Interpolated(nt.clone()), sp);\n                             result.push(token.into());\n                         }\n                     } else {"}, {"sha": "54012d62a72a7a54c68dade7752ae5c9724ea079", "filename": "src/librustc_expand/proc_macro.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -2,7 +2,7 @@ use crate::base::{self, *};\n use crate::proc_macro_server;\n \n use rustc_ast::ast::{self, ItemKind, MetaItemKind, NestedMetaItem};\n-use rustc_ast::token::{self, FlattenGroup};\n+use rustc_ast::token;\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, ErrorReported};\n@@ -105,8 +105,7 @@ impl MultiItemModifier for ProcMacroDerive {\n \n         let item = token::NtItem(item);\n         let input = if item.pretty_printing_compatibility_hack() {\n-            TokenTree::token(token::Interpolated(Lrc::new(item), FlattenGroup::Yes), DUMMY_SP)\n-                .into()\n+            TokenTree::token(token::Interpolated(Lrc::new(item)), DUMMY_SP).into()\n         } else {\n             nt_to_tokenstream(&item, ecx.parse_sess, DUMMY_SP)\n         };"}, {"sha": "663bc508143d6748fa8fc9b3b288045976193d93", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -1,7 +1,7 @@\n use crate::base::ExtCtxt;\n \n use rustc_ast::ast;\n-use rustc_ast::token::{self, FlattenGroup};\n+use rustc_ast::token;\n use rustc_ast::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n use rustc_ast::util::comments;\n use rustc_ast_pretty::pprust;\n@@ -60,12 +60,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n         let Token { kind, span } = match tree {\n             tokenstream::TokenTree::Delimited(span, delim, tts) => {\n                 let delimiter = Delimiter::from_internal(delim);\n-                return TokenTree::Group(Group {\n-                    delimiter,\n-                    stream: tts,\n-                    span,\n-                    flatten: FlattenGroup::No,\n-                });\n+                return TokenTree::Group(Group { delimiter, stream: tts, span, flatten: false });\n             }\n             tokenstream::TokenTree::Token(token) => token,\n         };\n@@ -172,25 +167,21 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n                     delimiter: Delimiter::Bracket,\n                     stream,\n                     span: DelimSpan::from_single(span),\n-                    flatten: FlattenGroup::No,\n+                    flatten: false,\n                 }));\n                 if style == ast::AttrStyle::Inner {\n                     stack.push(tt!(Punct::new('!', false)));\n                 }\n                 tt!(Punct::new('#', false))\n             }\n \n-            Interpolated(nt, _) => {\n+            Interpolated(nt) => {\n                 let stream = nt_to_tokenstream(&nt, sess, span);\n                 TokenTree::Group(Group {\n                     delimiter: Delimiter::None,\n                     stream,\n                     span: DelimSpan::from_single(span),\n-                    flatten: if nt.pretty_printing_compatibility_hack() {\n-                        FlattenGroup::Yes\n-                    } else {\n-                        FlattenGroup::No\n-                    },\n+                    flatten: nt.pretty_printing_compatibility_hack(),\n                 })\n             }\n \n@@ -297,7 +288,7 @@ pub struct Group {\n     /// A hack used to pass AST fragments to attribute and derive macros\n     /// as a single nonterminal token instead of a token stream.\n     /// FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n-    flatten: FlattenGroup,\n+    flatten: bool,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n@@ -457,7 +448,7 @@ impl server::TokenStreamIter for Rustc<'_> {\n             // Such token needs to be \"unwrapped\" and not represented as a delimited group.\n             // FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n             if let TokenTree::Group(ref group) = tree {\n-                if matches!(group.flatten, FlattenGroup::Yes) {\n+                if group.flatten {\n                     iter.cursor.append(group.stream.clone());\n                     continue;\n                 }\n@@ -473,7 +464,7 @@ impl server::Group for Rustc<'_> {\n             delimiter,\n             stream,\n             span: DelimSpan::from_single(server::Span::call_site(self)),\n-            flatten: FlattenGroup::No,\n+            flatten: false,\n         }\n     }\n     fn delimiter(&mut self, group: &Self::Group) -> Delimiter {"}, {"sha": "803f14a2a228a6789915694fe27ee9ec38541dbb", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -155,7 +155,7 @@ impl<'a> Parser<'a> {\n     /// The delimiters or `=` are still put into the resulting token stream.\n     pub fn parse_attr_item(&mut self) -> PResult<'a, ast::AttrItem> {\n         let item = match self.token.kind {\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 Nonterminal::NtMeta(ref item) => Some(item.clone().into_inner()),\n                 _ => None,\n             },\n@@ -254,7 +254,7 @@ impl<'a> Parser<'a> {\n     ///     meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n     pub fn parse_meta_item(&mut self) -> PResult<'a, ast::MetaItem> {\n         let nt_meta = match self.token.kind {\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtMeta(ref e) => Some(e.clone()),\n                 _ => None,\n             },"}, {"sha": "49a5c8801766c5521de580d6d8d170bbd52a81a2", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -26,7 +26,7 @@ use std::mem;\n /// `token::Interpolated` tokens.\n macro_rules! maybe_whole_expr {\n     ($p:expr) => {\n-        if let token::Interpolated(nt, _) = &$p.token.kind {\n+        if let token::Interpolated(nt) = &$p.token.kind {\n             match &**nt {\n                 token::NtExpr(e) | token::NtLiteral(e) => {\n                     let e = e.clone();"}, {"sha": "6f13d7994d17d257ec0fecb132f5d8baad5253cd", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -1780,7 +1780,7 @@ impl<'a> Parser<'a> {\n \n     fn is_named_param(&self) -> bool {\n         let offset = match self.token.kind {\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n                 _ => 0,\n             },"}, {"sha": "7811d5fb741b27d946b6ce57c6856d8d2b4977d5", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -54,7 +54,7 @@ enum BlockMode {\n #[macro_export]\n macro_rules! maybe_whole {\n     ($p:expr, $constructor:ident, |$x:ident| $e:expr) => {\n-        if let token::Interpolated(nt, _) = &$p.token.kind {\n+        if let token::Interpolated(nt) = &$p.token.kind {\n             if let token::$constructor(x) = &**nt {\n                 let $x = x.clone();\n                 $p.bump();\n@@ -69,7 +69,7 @@ macro_rules! maybe_whole {\n macro_rules! maybe_recover_from_interpolated_ty_qpath {\n     ($self: expr, $allow_qpath_recovery: expr) => {\n         if $allow_qpath_recovery && $self.look_ahead(1, |t| t == &token::ModSep) {\n-            if let token::Interpolated(nt, _) = &$self.token.kind {\n+            if let token::Interpolated(nt) = &$self.token.kind {\n                 if let token::NtTy(ty) = &**nt {\n                     let ty = ty.clone();\n                     $self.bump();\n@@ -922,7 +922,7 @@ impl<'a> Parser<'a> {\n                 if self.eat(&token::Eq) {\n                     let eq_span = self.prev_token.span;\n                     let mut is_interpolated_expr = false;\n-                    if let token::Interpolated(nt, _) = &self.token.kind {\n+                    if let token::Interpolated(nt) = &self.token.kind {\n                         if let token::NtExpr(..) = **nt {\n                             is_interpolated_expr = true;\n                         }"}, {"sha": "6603d0afc0248d6cf52ad3d147c3cf8a05d95d7d", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -515,7 +515,7 @@ impl<'a> Parser<'a> {\n         self.recover_additional_muts();\n \n         // Make sure we don't allow e.g. `let mut $p;` where `$p:pat`.\n-        if let token::Interpolated(ref nt, _) = self.token.kind {\n+        if let token::Interpolated(ref nt) = self.token.kind {\n             if let token::NtPat(_) = **nt {\n                 self.expected_ident_found().emit();\n             }"}, {"sha": "bca65c63e91986c476325156d3efa231869746e8", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -1325,7 +1325,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_token(&mut self, t: Token) {\n-        if let token::Interpolated(nt, _) = t.kind {\n+        if let token::Interpolated(nt) = t.kind {\n             if let token::NtExpr(ref expr) = *nt {\n                 if let ast::ExprKind::MacCall(..) = expr.kind {\n                     self.visit_invoc(expr.id);"}, {"sha": "32af920020ce6438ea15b5761d08627042d9d6bb", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b37434ef31bb896b473a1eb67b8f191c04b2c9f3/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=b37434ef31bb896b473a1eb67b8f191c04b2c9f3", "patch": "@@ -256,7 +256,7 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n     }\n \n     fn visit_token(&mut self, t: Token) {\n-        if let token::Interpolated(nt, _) = t.kind {\n+        if let token::Interpolated(nt) = t.kind {\n             if let token::NtExpr(ref expr) = *nt {\n                 if let ExprKind::MacCall(..) = expr.kind {\n                     self.visit_macro_invoc(expr.id);"}]}