{"sha": "a9329d3aa3974cfe7fda57a67b3898434f410131", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MzI5ZDNhYTM5NzRjZmU3ZmRhNTdhNjdiMzg5ODQzNGY0MTAxMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-31T11:13:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-31T11:13:20Z"}, "message": "Auto merge of #40737 - nagisa:safe-slicing-strs, r=BurntSushi\n\nChecked slicing for strings\n\ncc https://github.com/rust-lang/rust/issues/39932", "tree": {"sha": "86ec25840f85cee30b0093f391d2f06fa297bcc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86ec25840f85cee30b0093f391d2f06fa297bcc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9329d3aa3974cfe7fda57a67b3898434f410131", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9329d3aa3974cfe7fda57a67b3898434f410131", "html_url": "https://github.com/rust-lang/rust/commit/a9329d3aa3974cfe7fda57a67b3898434f410131", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9329d3aa3974cfe7fda57a67b3898434f410131/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "474f7a91eec8cba83b7eb7a578a7adb70614f877", "url": "https://api.github.com/repos/rust-lang/rust/commits/474f7a91eec8cba83b7eb7a578a7adb70614f877", "html_url": "https://github.com/rust-lang/rust/commit/474f7a91eec8cba83b7eb7a578a7adb70614f877"}, {"sha": "53a36923f12d6c9b7ef9cb0fe73cda50385b1f70", "url": "https://api.github.com/repos/rust-lang/rust/commits/53a36923f12d6c9b7ef9cb0fe73cda50385b1f70", "html_url": "https://github.com/rust-lang/rust/commit/53a36923f12d6c9b7ef9cb0fe73cda50385b1f70"}], "stats": {"total": 511, "additions": 448, "deletions": 63}, "files": [{"sha": "00448b6abb2cf3937ab36f2c8416bea36f1e31ca", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=a9329d3aa3974cfe7fda57a67b3898434f410131", "patch": "@@ -60,6 +60,7 @@\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(untagged_unions)]\n+#![cfg_attr(not(test), feature(str_checked_slicing))]\n #![cfg_attr(test, feature(rand, test))]\n \n #![no_std]"}, {"sha": "6f8843c2374bc1b1cb9c0bdf52bded19948b3529", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=a9329d3aa3974cfe7fda57a67b3898434f410131", "patch": "@@ -362,7 +362,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn get<I>(&self, index: I) -> Option<&I::Output>\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<Self>\n     {\n         core_slice::SliceExt::get(self, index)\n     }\n@@ -385,7 +385,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<Self>\n     {\n         core_slice::SliceExt::get_mut(self, index)\n     }\n@@ -405,7 +405,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<Self>\n     {\n         core_slice::SliceExt::get_unchecked(self, index)\n     }\n@@ -427,7 +427,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<Self>\n     {\n         core_slice::SliceExt::get_unchecked_mut(self, index)\n     }"}, {"sha": "72db452093fc2880104381f3adfe60955d8ad52c", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 109, "deletions": 1, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=a9329d3aa3974cfe7fda57a67b3898434f410131", "patch": "@@ -51,7 +51,7 @@ use borrow::{Borrow, ToOwned};\n use string::String;\n use std_unicode;\n use vec::Vec;\n-use slice::SliceConcatExt;\n+use slice::{SliceConcatExt, SliceIndex};\n use boxed::Box;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -310,6 +310,114 @@ impl str {\n         core_str::StrExt::as_ptr(self)\n     }\n \n+    /// Returns a subslice of `str`.\n+    ///\n+    /// This is the non-panicking alternative to indexing the `str`. Returns `None` whenever\n+    /// equivalent indexing operation would panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n+    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get(0..4));\n+    /// assert!(v.get(1..).is_none());\n+    /// assert!(v.get(..8).is_none());\n+    /// assert!(v.get(..42).is_none());\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    #[inline]\n+    pub fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n+        core_str::StrExt::get(self, i)\n+    }\n+\n+    /// Returns a mutable subslice of `str`.\n+    ///\n+    /// This is the non-panicking alternative to indexing the `str`. Returns `None` whenever\n+    /// equivalent indexing operation would panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get_mut(0..4).map(|v| &*v));\n+    /// assert!(v.get_mut(1..).is_none());\n+    /// assert!(v.get_mut(..8).is_none());\n+    /// assert!(v.get_mut(..42).is_none());\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    #[inline]\n+    pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n+        core_str::StrExt::get_mut(self, i)\n+    }\n+\n+    /// Returns a unchecked subslice of `str`.\n+    ///\n+    /// This is the unchecked alternative to indexing the `str`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that these preconditions are\n+    /// satisfied:\n+    ///\n+    /// * The starting index must come before the ending index;\n+    /// * Indexes must be within bounds of the original slice;\n+    /// * Indexes must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// Failing that, the returned string slice may reference invalid memory or\n+    /// violate the invariants communicated by the `str` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n+    /// unsafe {\n+    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked(0..4));\n+    ///     assert_eq!(\"\u2208\", v.get_unchecked(4..7));\n+    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked(7..11));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n+        core_str::StrExt::get_unchecked(self, i)\n+    }\n+\n+    /// Returns a mutable, unchecked subslice of `str`.\n+    ///\n+    /// This is the unchecked alternative to indexing the `str`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that these preconditions are\n+    /// satisfied:\n+    ///\n+    /// * The starting index must come before the ending index;\n+    /// * Indexes must be within bounds of the original slice;\n+    /// * Indexes must lie on UTF-8 sequence boundaries.\n+    ///\n+    /// Failing that, the returned string slice may reference invalid memory or\n+    /// violate the invariants communicated by the `str` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(str_checked_slicing)]\n+    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    /// unsafe {\n+    ///     assert_eq!(\"\ud83d\uddfb\", v.get_unchecked_mut(0..4));\n+    ///     assert_eq!(\"\u2208\", v.get_unchecked_mut(4..7));\n+    ///     assert_eq!(\"\ud83c\udf0f\", v.get_unchecked_mut(7..11));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n+        core_str::StrExt::get_unchecked_mut(self, i)\n+    }\n+\n     /// Creates a string slice from another string slice, bypassing safety\n     /// checks.\n     ///"}, {"sha": "45667bb42993da8568246b7409321be821f8e464", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=a9329d3aa3974cfe7fda57a67b3898434f410131", "patch": "@@ -97,8 +97,7 @@ pub trait SliceExt {\n \n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn get<I>(&self, index: I) -> Option<&I::Output>\n-        where I: SliceIndex<Self::Item>;\n-\n+        where I: SliceIndex<Self>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn first(&self) -> Option<&Self::Item>;\n \n@@ -113,8 +112,7 @@ pub trait SliceExt {\n \n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n-        where I: SliceIndex<Self::Item>;\n-\n+        where I: SliceIndex<Self>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_ptr(&self) -> *const Self::Item;\n \n@@ -141,8 +139,7 @@ pub trait SliceExt {\n \n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n-        where I: SliceIndex<Self::Item>;\n-\n+        where I: SliceIndex<Self>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn iter_mut(&mut self) -> IterMut<Self::Item>;\n \n@@ -184,8 +181,7 @@ pub trait SliceExt {\n \n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n-        where I: SliceIndex<Self::Item>;\n-\n+        where I: SliceIndex<Self>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_mut_ptr(&mut self) -> *mut Self::Item;\n \n@@ -337,7 +333,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn get<I>(&self, index: I) -> Option<&I::Output>\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<[T]>\n     {\n         index.get(self)\n     }\n@@ -365,7 +361,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<[T]>\n     {\n         index.get_unchecked(self)\n     }\n@@ -406,7 +402,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<[T]>\n     {\n         index.get_mut(self)\n     }\n@@ -538,7 +534,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n-        where I: SliceIndex<T>\n+        where I: SliceIndex<[T]>\n     {\n         index.get_unchecked_mut(self)\n     }\n@@ -631,7 +627,7 @@ impl<T> SliceExt for [T] {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n impl<T, I> ops::Index<I> for [T]\n-    where I: SliceIndex<T>\n+    where I: SliceIndex<[T]>\n {\n     type Output = I::Output;\n \n@@ -644,7 +640,7 @@ impl<T, I> ops::Index<I> for [T]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n impl<T, I> ops::IndexMut<I> for [T]\n-    where I: SliceIndex<T>\n+    where I: SliceIndex<[T]>\n {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut I::Output {\n@@ -667,37 +663,37 @@ fn slice_index_order_fail(index: usize, end: usize) -> ! {\n /// A helper trait used for indexing operations.\n #[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n #[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n-pub trait SliceIndex<T> {\n+pub trait SliceIndex<T: ?Sized> {\n     /// The output type returned by methods.\n     type Output: ?Sized;\n \n     /// Returns a shared reference to the output at this location, if in\n     /// bounds.\n-    fn get(self, slice: &[T]) -> Option<&Self::Output>;\n+    fn get(self, slice: &T) -> Option<&Self::Output>;\n \n     /// Returns a mutable reference to the output at this location, if in\n     /// bounds.\n-    fn get_mut(self, slice: &mut [T]) -> Option<&mut Self::Output>;\n+    fn get_mut(self, slice: &mut T) -> Option<&mut Self::Output>;\n \n     /// Returns a shared reference to the output at this location, without\n     /// performing any bounds checking.\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &Self::Output;\n+    unsafe fn get_unchecked(self, slice: &T) -> &Self::Output;\n \n     /// Returns a mutable reference to the output at this location, without\n     /// performing any bounds checking.\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut Self::Output;\n+    unsafe fn get_unchecked_mut(self, slice: &mut T) -> &mut Self::Output;\n \n     /// Returns a shared reference to the output at this location, panicking\n     /// if out of bounds.\n-    fn index(self, slice: &[T]) -> &Self::Output;\n+    fn index(self, slice: &T) -> &Self::Output;\n \n     /// Returns a mutable reference to the output at this location, panicking\n     /// if out of bounds.\n-    fn index_mut(self, slice: &mut [T]) -> &mut Self::Output;\n+    fn index_mut(self, slice: &mut T) -> &mut Self::Output;\n }\n \n #[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<T> for usize {\n+impl<T> SliceIndex<[T]> for usize {\n     type Output = T;\n \n     #[inline]\n@@ -746,7 +742,7 @@ impl<T> SliceIndex<T> for usize {\n }\n \n #[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<T> for  ops::Range<usize> {\n+impl<T> SliceIndex<[T]> for  ops::Range<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -807,7 +803,7 @@ impl<T> SliceIndex<T> for  ops::Range<usize> {\n }\n \n #[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<T> for ops::RangeTo<usize> {\n+impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -842,7 +838,7 @@ impl<T> SliceIndex<T> for ops::RangeTo<usize> {\n }\n \n #[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<T> for ops::RangeFrom<usize> {\n+impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -877,7 +873,7 @@ impl<T> SliceIndex<T> for ops::RangeFrom<usize> {\n }\n \n #[stable(feature = \"slice-get-slice-impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<T> for ops::RangeFull {\n+impl<T> SliceIndex<[T]> for ops::RangeFull {\n     type Output = [T];\n \n     #[inline]\n@@ -913,7 +909,7 @@ impl<T> SliceIndex<T> for ops::RangeFull {\n \n \n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<T> SliceIndex<T> for ops::RangeInclusive<usize> {\n+impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -976,7 +972,7 @@ impl<T> SliceIndex<T> for ops::RangeInclusive<usize> {\n }\n \n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<T> SliceIndex<T> for ops::RangeToInclusive<usize> {\n+impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n     type Output = [T];\n \n     #[inline]"}, {"sha": "5056adeaeeec3b3d668d217892e037c4ecc274ef", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 303, "deletions": 23, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=a9329d3aa3974cfe7fda57a67b3898434f410131", "patch": "@@ -22,7 +22,7 @@ use convert::TryFrom;\n use fmt;\n use iter::{Map, Cloned, FusedIterator};\n use mem;\n-use slice;\n+use slice::{self, SliceIndex};\n \n pub mod pattern;\n \n@@ -1445,6 +1445,8 @@ Section: Trait implementations\n mod traits {\n     use cmp::Ordering;\n     use ops;\n+    use mem;\n+    use slice::{self, SliceIndex};\n     use str::eq_slice;\n \n     /// Implements ordering of strings.\n@@ -1527,14 +1529,7 @@ mod traits {\n         type Output = str;\n         #[inline]\n         fn index(&self, index: ops::Range<usize>) -> &str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if index.start <= index.end &&\n-               self.is_char_boundary(index.start) &&\n-               self.is_char_boundary(index.end) {\n-                unsafe { self.slice_unchecked(index.start, index.end) }\n-            } else {\n-                super::slice_error_fail(self, index.start, index.end)\n-            }\n+            index.index(self)\n         }\n     }\n \n@@ -1556,14 +1551,7 @@ mod traits {\n     impl ops::IndexMut<ops::Range<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::Range<usize>) -> &mut str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if index.start <= index.end &&\n-               self.is_char_boundary(index.start) &&\n-               self.is_char_boundary(index.end) {\n-                unsafe { self.slice_mut_unchecked(index.start, index.end) }\n-            } else {\n-                super::slice_error_fail(self, index.start, index.end)\n-            }\n+            index.index_mut(self)\n         }\n     }\n \n@@ -1731,8 +1719,276 @@ mod traits {\n             self.index_mut(0...index.end)\n         }\n     }\n+\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    impl SliceIndex<str> for ops::RangeFull {\n+        type Output = str;\n+        #[inline]\n+        fn get(self, slice: &str) -> Option<&Self::Output> {\n+            Some(slice)\n+        }\n+        #[inline]\n+        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+            Some(slice)\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+            slice\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+            slice\n+        }\n+        #[inline]\n+        fn index(self, slice: &str) -> &Self::Output {\n+            slice\n+        }\n+        #[inline]\n+        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            slice\n+        }\n+    }\n+\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    impl SliceIndex<str> for ops::Range<usize> {\n+        type Output = str;\n+        #[inline]\n+        fn get(self, slice: &str) -> Option<&Self::Output> {\n+            if self.start <= self.end &&\n+               slice.is_char_boundary(self.start) &&\n+               slice.is_char_boundary(self.end) {\n+                Some(unsafe { self.get_unchecked(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+            if self.start <= self.end &&\n+               slice.is_char_boundary(self.start) &&\n+               slice.is_char_boundary(self.end) {\n+                Some(unsafe { self.get_unchecked_mut(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+            let ptr = slice.as_ptr().offset(self.start as isize);\n+            let len = self.end - self.start;\n+            super::from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+            let ptr = slice.as_ptr().offset(self.start as isize);\n+            let len = self.end - self.start;\n+            mem::transmute(slice::from_raw_parts_mut(ptr as *mut u8, len))\n+        }\n+        #[inline]\n+        fn index(self, slice: &str) -> &Self::Output {\n+            let (start, end) = (self.start, self.end);\n+            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, start, end))\n+        }\n+        #[inline]\n+        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            // canot reuse `get` as above, because of NLL trouble\n+            if self.start <= self.end &&\n+               slice.is_char_boundary(self.start) &&\n+               slice.is_char_boundary(self.end) {\n+                unsafe { self.get_unchecked_mut(slice) }\n+            } else {\n+                super::slice_error_fail(slice, self.start, self.end)\n+            }\n+        }\n+    }\n+\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    impl SliceIndex<str> for ops::RangeTo<usize> {\n+        type Output = str;\n+        #[inline]\n+        fn get(self, slice: &str) -> Option<&Self::Output> {\n+            if slice.is_char_boundary(self.end) {\n+                Some(unsafe { self.get_unchecked(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+            if slice.is_char_boundary(self.end) {\n+                Some(unsafe { self.get_unchecked_mut(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+            let ptr = slice.as_ptr();\n+            super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end))\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+            let ptr = slice.as_ptr();\n+            mem::transmute(slice::from_raw_parts_mut(ptr as *mut u8, self.end))\n+        }\n+        #[inline]\n+        fn index(self, slice: &str) -> &Self::Output {\n+            let end = self.end;\n+            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, 0, end))\n+        }\n+        #[inline]\n+        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            if slice.is_char_boundary(self.end) {\n+                unsafe { self.get_unchecked_mut(slice) }\n+            } else {\n+                super::slice_error_fail(slice, 0, self.end)\n+            }\n+        }\n+    }\n+\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    impl SliceIndex<str> for ops::RangeFrom<usize> {\n+        type Output = str;\n+        #[inline]\n+        fn get(self, slice: &str) -> Option<&Self::Output> {\n+            if slice.is_char_boundary(self.start) {\n+                Some(unsafe { self.get_unchecked(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+            if slice.is_char_boundary(self.start) {\n+                Some(unsafe { self.get_unchecked_mut(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+            let ptr = slice.as_ptr().offset(self.start as isize);\n+            let len = slice.len() - self.start;\n+            super::from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+            let ptr = slice.as_ptr().offset(self.start as isize);\n+            let len = slice.len() - self.start;\n+            mem::transmute(slice::from_raw_parts_mut(ptr as *mut u8, len))\n+        }\n+        #[inline]\n+        fn index(self, slice: &str) -> &Self::Output {\n+            let (start, end) = (self.start, slice.len());\n+            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, start, end))\n+        }\n+        #[inline]\n+        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            if slice.is_char_boundary(self.start) {\n+                unsafe { self.get_unchecked_mut(slice) }\n+            } else {\n+                super::slice_error_fail(slice, self.start, slice.len())\n+            }\n+        }\n+    }\n+\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    impl SliceIndex<str> for ops::RangeInclusive<usize> {\n+        type Output = str;\n+        #[inline]\n+        fn get(self, slice: &str) -> Option<&Self::Output> {\n+            match self {\n+                ops::RangeInclusive::Empty { .. } => 0..0,\n+                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n+            }.get(slice)\n+        }\n+        #[inline]\n+        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+            match self {\n+                ops::RangeInclusive::Empty { .. } => 0..0,\n+                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n+            }.get_mut(slice)\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+            match self {\n+                ops::RangeInclusive::Empty { .. } => 0..0,\n+                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n+            }.get_unchecked(slice)\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+            match self {\n+                ops::RangeInclusive::Empty { .. } => 0..0,\n+                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n+            }.get_unchecked_mut(slice)\n+        }\n+        #[inline]\n+        fn index(self, slice: &str) -> &Self::Output {\n+            match self {\n+                ops::RangeInclusive::Empty { .. } => 0..0,\n+                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n+            }.index(slice)\n+        }\n+        #[inline]\n+        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            match self {\n+                ops::RangeInclusive::Empty { .. } => 0..0,\n+                ops::RangeInclusive::NonEmpty { start, end } => start..end+1,\n+            }.index_mut(slice)\n+        }\n+    }\n+\n+\n+\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n+        type Output = str;\n+        #[inline]\n+        fn get(self, slice: &str) -> Option<&Self::Output> {\n+            if slice.is_char_boundary(self.end + 1) {\n+                Some(unsafe { self.get_unchecked(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+            if slice.is_char_boundary(self.end + 1) {\n+                Some(unsafe { self.get_unchecked_mut(slice) })\n+            } else {\n+                None\n+            }\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+            let ptr = slice.as_ptr();\n+            super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end + 1))\n+        }\n+        #[inline]\n+        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+            let ptr = slice.as_ptr();\n+            mem::transmute(slice::from_raw_parts_mut(ptr as *mut u8, self.end + 1))\n+        }\n+        #[inline]\n+        fn index(self, slice: &str) -> &Self::Output {\n+            let end = self.end + 1;\n+            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, 0, end))\n+        }\n+        #[inline]\n+        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+            if slice.is_char_boundary(self.end) {\n+                unsafe { self.get_unchecked_mut(slice) }\n+            } else {\n+                super::slice_error_fail(slice, 0, self.end + 1)\n+            }\n+        }\n+    }\n+\n }\n \n+\n /// Methods for string slices\n #[allow(missing_docs)]\n #[doc(hidden)]\n@@ -1782,6 +2038,14 @@ pub trait StrExt {\n     #[rustc_deprecated(since = \"1.6.0\", reason = \"use lines() instead now\")]\n     #[allow(deprecated)]\n     fn lines_any(&self) -> LinesAny;\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output>;\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output>;\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output;\n+    #[unstable(feature = \"str_checked_slicing\", issue = \"39932\")]\n+    unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -1971,18 +2235,34 @@ impl StrExt for str {\n         LinesAny(self.lines())\n     }\n \n+    #[inline]\n+    fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n+        i.get(self)\n+    }\n+\n+    #[inline]\n+    fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n+        i.get_mut(self)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n+        i.get_unchecked(self)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n+        i.get_unchecked_mut(self)\n+    }\n+\n     #[inline]\n     unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        let ptr = self.as_ptr().offset(begin as isize);\n-        let len = end - begin;\n-        from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n+        (begin..end).get_unchecked(self)\n     }\n \n     #[inline]\n     unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        let ptr = self.as_ptr().offset(begin as isize);\n-        let len = end - begin;\n-        mem::transmute(slice::from_raw_parts_mut(ptr as *mut u8, len))\n+        (begin..end).get_unchecked_mut(self)\n     }\n \n     #[inline]"}, {"sha": "624944f7344cbd204314e29844e66c75e1f91d2c", "filename": "src/test/compile-fail/indexing-requires-a-uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs?ref=a9329d3aa3974cfe7fda57a67b3898434f410131", "patch": "@@ -13,7 +13,7 @@\n \n fn main() {\n     fn bar<T>(_: T) {}\n-    [0][0u8]; //~ ERROR: the trait bound `u8: std::slice::SliceIndex<{integer}>` is not satisfied\n+    [0][0u8]; //~ ERROR: the trait bound `u8: std::slice::SliceIndex<[{integer}]>` is not satisfied\n \n     [0][0]; // should infer to be a usize\n "}, {"sha": "659b08b55a00aeb03f4e82ef11324acba633a0a2", "filename": "src/test/compile-fail/integral-indexing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs?ref=a9329d3aa3974cfe7fda57a67b3898434f410131", "patch": "@@ -19,8 +19,8 @@ pub fn main() {\n     v[3i32]; //~ERROR : std::ops::Index<i32>` is not satisfied\n     s.as_bytes()[3_usize];\n     s.as_bytes()[3];\n-    s.as_bytes()[3u8];  //~ERROR : std::slice::SliceIndex<u8>` is not satisfied\n-    s.as_bytes()[3i8];  //~ERROR : std::slice::SliceIndex<u8>` is not satisfied\n-    s.as_bytes()[3u32]; //~ERROR : std::slice::SliceIndex<u8>` is not satisfied\n-    s.as_bytes()[3i32]; //~ERROR : std::slice::SliceIndex<u8>` is not satisfied\n+    s.as_bytes()[3u8];  //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n+    s.as_bytes()[3i8];  //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n+    s.as_bytes()[3u32]; //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n+    s.as_bytes()[3i32]; //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n }"}, {"sha": "1a9ed2dd6e4dcd957c4350c44b1af6ed61bec546", "filename": "src/test/compile-fail/on-unimplemented/slice-index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fslice-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9329d3aa3974cfe7fda57a67b3898434f410131/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fslice-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fslice-index.rs?ref=a9329d3aa3974cfe7fda57a67b3898434f410131", "patch": "@@ -20,10 +20,10 @@ fn main() {\n     let x = &[1, 2, 3] as &[i32];\n     x[1i32]; //~ ERROR E0277\n              //~| NOTE slice indices are of type `usize` or ranges of `usize`\n-             //~| NOTE trait `std::slice::SliceIndex<i32>` is not implemented for `i32`\n+             //~| NOTE trait `std::slice::SliceIndex<[i32]>` is not implemented for `i32`\n              //~| NOTE required because of the requirements on the impl of `std::ops::Index<i32>`\n     x[..1i32]; //~ ERROR E0277\n                //~| NOTE slice indices are of type `usize` or ranges of `usize`\n-               //~| NOTE trait `std::slice::SliceIndex<i32>` is not implemented for `std::ops::RangeTo<i32>`\n+               //~| NOTE trait `std::slice::SliceIndex<[i32]>` is not implemented for `std::ops::RangeTo<i32>`\n                //~| NOTE requirements on the impl of `std::ops::Index<std::ops::RangeTo<i32>>`\n }"}]}