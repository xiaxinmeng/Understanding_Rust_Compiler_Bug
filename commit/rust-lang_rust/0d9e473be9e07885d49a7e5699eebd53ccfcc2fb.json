{"sha": "0d9e473be9e07885d49a7e5699eebd53ccfcc2fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkOWU0NzNiZTllMDc4ODVkNDlhN2U1Njk5ZWViZDUzY2NmY2MyZmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-17T22:11:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-24T21:27:22Z"}, "message": "Comprehence cycle detection in `collect`. In some cases, the cycles we\nreport are not *necessary* cycles, but we'll work on refactoring them\nover time. This overlaps with the cycle detection that astconv already\ndoes: I left that code in because it gives a more targeted error\nmessage, though perhaps less helpful in that it doesn't give the full\ndetails of the cycle.", "tree": {"sha": "ce0b6064ea31234fada951719ebca959af5169eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce0b6064ea31234fada951719ebca959af5169eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb", "html_url": "https://github.com/rust-lang/rust/commit/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15ef2c2e6b94e8430d718a13c9845e33989a50d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/15ef2c2e6b94e8430d718a13c9845e33989a50d6", "html_url": "https://github.com/rust-lang/rust/commit/15ef2c2e6b94e8430d718a13c9845e33989a50d6"}], "stats": {"total": 350, "additions": 282, "deletions": 68}, "files": [{"sha": "20a0c35d8e0217c8849923fbdec09841a196e7b9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0d9e473be9e07885d49a7e5699eebd53ccfcc2fb", "patch": "@@ -2546,6 +2546,13 @@ impl<'tcx> ctxt<'tcx> {\n     {\n         self.closure_tys.borrow()[def_id].subst(self, substs)\n     }\n+\n+    pub fn type_parameter_def(&self,\n+                              node_id: ast::NodeId)\n+                              -> TypeParameterDef<'tcx>\n+    {\n+        self.ty_param_defs.borrow()[node_id].clone()\n+    }\n }\n \n // Interns a type/name combination, stores the resulting box in cx.interner,"}, {"sha": "48928516a6022e820f80db9e6b5065b8cca9e2ed", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0d9e473be9e07885d49a7e5699eebd53ccfcc2fb", "patch": "@@ -53,7 +53,7 @@ use middle::const_eval;\n use middle::def;\n use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n-use middle::subst::{FnSpace, ParamSpace, TypeSpace, SelfSpace, Subst, Substs};\n+use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::traits;\n use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n@@ -73,11 +73,14 @@ use syntax::print::pprust;\n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n \n-    fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx>;\n+    fn get_item_type_scheme(&self, span: Span, id: ast::DefId)\n+                            -> Result<ty::TypeScheme<'tcx>, ErrorReported>;\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>>;\n+    fn get_trait_def(&self, span: Span, id: ast::DefId)\n+                     -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>;\n \n-    fn get_type_parameter_bounds(&self, space: ParamSpace, index: u32) -> Vec<ty::PolyTraitRef<'tcx>>;\n+    fn get_type_parameter_bounds(&self, span: Span, def_id: ast::NodeId)\n+                                 -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>;\n \n     /// Return an (optional) substitution to convert bound type parameters that\n     /// are in scope into free ones. This function should only return Some\n@@ -685,7 +688,14 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n     -> Rc<ty::TraitRef<'tcx>>\n {\n     debug!(\"ast_path_to_trait_ref {:?}\", trait_segment);\n-    let trait_def = this.get_trait_def(trait_def_id);\n+    let trait_def = match this.get_trait_def(path.span, trait_def_id) {\n+        Ok(trait_def) => trait_def,\n+        Err(ErrorReported) => {\n+            // No convenient way to recover from a cycle here. Just bail. Sorry!\n+            this.tcx().sess.abort_if_errors();\n+            this.tcx().sess.bug(\"ErrorReported returned, but no errors reports?\")\n+        }\n+    };\n \n     let (regions, types, assoc_bindings) = match trait_segment.parameters {\n         ast::AngleBracketedParameters(ref data) => {\n@@ -862,14 +872,17 @@ fn ast_path_to_ty<'tcx>(\n     item_segment: &ast::PathSegment)\n     -> Ty<'tcx>\n {\n-    let ty::TypeScheme {\n-        generics,\n-        ty: decl_ty\n-    } = this.get_item_type_scheme(did);\n-\n-    let substs = ast_path_substs_for_ty(this, rscope,\n-                                        span, param_mode,\n-                                        &generics, item_segment);\n+    let tcx = this.tcx();\n+    let substs = match this.get_item_type_scheme(path.span, did) {\n+        Ok(ty::TypeScheme { generics,  ty: decl_ty }) => {\n+            ast_path_substs_for_ty(this, rscope,\n+                                   span, param_mode,\n+                                   &generics, item_segment)\n+        }\n+        Err(ErrorReported) => {\n+            return TypeAndSubsts { substs: Substs::empty(), ty: tcx.types.err };\n+        }\n+    };\n \n     // FIXME(#12938): This is a hack until we have full support for DST.\n     if Some(did) == this.tcx().lang_items.owned_box() {\n@@ -1003,22 +1016,17 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         return (tcx.types.err, ty_path_def);\n     };\n \n-    let mut suitable_bounds: Vec<_>;\n-    let ty_param_name: ast::Name;\n-    { // contain scope of refcell:\n-        let ty_param_defs = tcx.ty_param_defs.borrow();\n-        let ty_param_def = &ty_param_defs[ty_param_node_id];\n-        ty_param_name = ty_param_def.name;\n-\n-\n-        // FIXME(#20300) -- search where clauses, not bounds\n-        suitable_bounds =\n-            traits::transitive_bounds(tcx,\n-                                      &this.get_type_parameter_bounds(ty_param_def.space,\n-                                                                      ty_param_def.index))\n-            .filter(|b| trait_defines_associated_type_named(this, b.def_id(), assoc_name))\n-            .collect();\n-    }\n+    let ty_param_name = tcx.ty_param_defs.borrow()[ty_param_node_id].name;\n+\n+    // FIXME(#20300) -- search where clauses, not bounds\n+    let bounds =\n+        this.get_type_parameter_bounds(ast_ty.span, ty_param_ndoe_id)\n+            .unwrap_or(Vec::new());\n+\n+    let mut suitable_bounds: Vec<_> =\n+        traits::transitive_bounds(tcx, &bounds)\n+        .filter(|b| trait_defines_associated_type_named(this, b.def_id(), assoc_name))\n+        .collect();\n \n     if suitable_bounds.len() == 0 {\n         span_err!(tcx.sess, span, E0220,"}, {"sha": "43edb4f09cc12c494262634ee689babc97886913", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0d9e473be9e07885d49a7e5699eebd53ccfcc2fb", "patch": "@@ -106,7 +106,7 @@ use session::Session;\n use {CrateCtxt, lookup_full_def, require_same_types};\n use TypeAndSubsts;\n use lint;\n-use util::common::{block_query, indenter, loop_query};\n+use util::common::{block_query, ErrorReported, indenter, loop_query};\n use util::ppaux::{self, Repr};\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use util::lev_distance::lev_distance;\n@@ -1206,40 +1206,46 @@ fn check_cast<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx> {\n-        ty::lookup_item_type(self.tcx(), id)\n+    fn get_item_type_scheme(&self, _: Span, id: ast::DefId)\n+                            -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n+    {\n+        Ok(ty::lookup_item_type(self.tcx(), id))\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        ty::lookup_trait_def(self.tcx(), id)\n+    fn get_trait_def(&self, _: Span, id: ast::DefId)\n+                     -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>\n+    {\n+        Ok(ty::lookup_trait_def(self.tcx(), id))\n     }\n \n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n         Some(&self.inh.param_env.free_substs)\n     }\n \n     fn get_type_parameter_bounds(&self,\n-                                 space: ParamSpace,\n-                                 index: u32)\n-                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+                                 _: Span,\n+                                 node_id: ast::NodeId)\n+                                 -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n     {\n-        self.inh.param_env.caller_bounds\n-                          .iter()\n-                          .filter_map(|predicate| {\n-                              match *predicate {\n-                                  ty::Predicate::Trait(ref data) => {\n-                                      if data.0.self_ty().is_param(space, index) {\n-                                          Some(data.to_poly_trait_ref())\n-                                      } else {\n-                                          None\n+        let def = self.tcx().type_parameter_def(node_id);\n+        let r = self.inh.param_env.caller_bounds\n+                                  .iter()\n+                                  .filter_map(|predicate| {\n+                                      match *predicate {\n+                                          ty::Predicate::Trait(ref data) => {\n+                                              if data.0.self_ty().is_param(def.space, def.index) {\n+                                                  Some(data.to_poly_trait_ref())\n+                                              } else {\n+                                                  None\n+                                              }\n+                                          }\n+                                          _ => {\n+                                              None\n+                                          }\n                                       }\n-                                  }\n-                                  _ => {\n-                                      None\n-                                  }\n-                              }\n-                          })\n-                          .collect()\n+                                  })\n+                                  .collect();\n+        Ok(r)\n     }\n \n     fn ty_infer(&self, _span: Span) -> Ty<'tcx> {"}, {"sha": "cef7f83840b4a1ddab56dfdec391629722ac840f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 127, "deletions": 15, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0d9e473be9e07885d49a7e5699eebd53ccfcc2fb", "patch": "@@ -98,12 +98,13 @@ use middle::ty::{self, RegionEscape, Ty, TypeScheme};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::infer;\n use rscope::*;\n-use util::common::memoized;\n+use util::common::{ErrorReported, memoized};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux;\n use util::ppaux::{Repr,UserString};\n use write_ty_to_tcx;\n \n+use std::cell::RefCell;\n use std::collections::HashSet;\n use std::rc::Rc;\n \n@@ -121,7 +122,7 @@ use syntax::visit;\n // Main entry point\n \n pub fn collect_item_types(tcx: &ty::ctxt) {\n-    let ccx = &CrateCtxt { tcx: tcx };\n+    let ccx = &CrateCtxt { tcx: tcx, stack: RefCell::new(Vec::new()) };\n \n     match ccx.tcx.lang_items.ty_desc() {\n         Some(id) => { collect_intrinsic_type(ccx, id); }\n@@ -143,13 +144,24 @@ pub fn collect_item_types(tcx: &ty::ctxt) {\n \n struct CrateCtxt<'a,'tcx:'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n+\n+    // This stack is used to identify cycles in the user's source.\n+    // Note that these cycles can cross multiple items.\n+    stack: RefCell<Vec<AstConvRequest>>,\n }\n \n struct ItemCtxt<'a,'tcx:'a> {\n     ccx: &'a CrateCtxt<'a,'tcx>,\n     generics: &'a ty::Generics<'tcx>,\n }\n \n+#[derive(Copy, PartialEq, Eq)]\n+enum AstConvRequest {\n+    GetItemTypeScheme(ast::DefId),\n+    GetTraitDef(ast::DefId),\n+    GetTypeParameterBounds(ast::NodeId),\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Zeroth phase: collect types of intrinsics\n \n@@ -217,6 +229,94 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n             }\n         }\n     }\n+\n+    fn cycle_check<F,R>(&self,\n+                        span: Span,\n+                        request: AstConvRequest,\n+                        code: F)\n+                        -> Result<R,ErrorReported>\n+        where F: FnOnce() -> R\n+    {\n+        {\n+            let mut stack = self.stack.borrow_mut();\n+            match stack.iter().enumerate().rev().find(|&(_, r)| *r == request) {\n+                None => { }\n+                Some((i, _)) => {\n+                    let cycle = &stack[i..];\n+                    self.report_cycle(span, cycle);\n+                    return Err(ErrorReported);\n+                }\n+            }\n+            stack.push(request);\n+        }\n+\n+        let result = code();\n+\n+        self.stack.borrow_mut().pop();\n+        Ok(result)\n+    }\n+\n+    fn report_cycle(&self,\n+                    span: Span,\n+                    cycle: &[AstConvRequest])\n+    {\n+        assert!(!cycle.is_empty());\n+        let tcx = self.tcx;\n+\n+        tcx.sess.span_err(\n+            span,\n+            &format!(\"unsupported cyclic reference between types/traits detected\"));\n+\n+        match cycle[0] {\n+            AstConvRequest::GetItemTypeScheme(def_id) |\n+            AstConvRequest::GetTraitDef(def_id) => {\n+                tcx.sess.note(\n+                    &format!(\"the cycle begins when processing `{}`...\",\n+                             ty::item_path_str(tcx, def_id)));\n+            }\n+            AstConvRequest::GetTypeParameterBounds(id) => {\n+                let def = tcx.type_parameter_def(id);\n+                tcx.sess.note(\n+                    &format!(\"the cycle begins when computing the bounds \\\n+                              for type parameter `{}`...\",\n+                             def.name.user_string(tcx)));\n+            }\n+        }\n+\n+        for request in cycle[1..].iter() {\n+            match *request {\n+                AstConvRequest::GetItemTypeScheme(def_id) |\n+                AstConvRequest::GetTraitDef(def_id) => {\n+                    tcx.sess.note(\n+                        &format!(\"...which then requires processing `{}`...\",\n+                                 ty::item_path_str(tcx, def_id)));\n+                }\n+                AstConvRequest::GetTypeParameterBounds(id) => {\n+                    let def = tcx.type_parameter_def(id);\n+                    tcx.sess.note(\n+                        &format!(\"...which then requires computing the bounds \\\n+                                  for type parameter `{}`...\",\n+                                 def.name.user_string(tcx)));\n+                }\n+            }\n+        }\n+\n+        match cycle[0] {\n+            AstConvRequest::GetItemTypeScheme(def_id) |\n+            AstConvRequest::GetTraitDef(def_id) => {\n+                tcx.sess.note(\n+                    &format!(\"...which then again requires processing `{}`, completing the cycle.\",\n+                             ty::item_path_str(tcx, def_id)));\n+            }\n+            AstConvRequest::GetTypeParameterBounds(id) => {\n+                let def = tcx.type_parameter_def(id);\n+                tcx.sess.note(\n+                    &format!(\"...which then again requires computing the bounds \\\n+                              for type parameter `{}`, completing the cycle.\",\n+                             def.name.user_string(tcx)));\n+            }\n+        }\n+    }\n }\n \n pub trait ToTy<'tcx> {\n@@ -232,25 +332,37 @@ impl<'a,'tcx> ToTy<'tcx> for ItemCtxt<'a,'tcx> {\n impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx> {\n-        type_scheme_of_def_id(self.ccx, id)\n+    fn get_item_type_scheme(&self, span: Span, id: ast::DefId)\n+                            -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n+    {\n+        self.ccx.cycle_check(span, AstConvRequest::GetItemTypeScheme(id), || {\n+            type_scheme_of_def_id(self.ccx, id)\n+        })\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        get_trait_def(self.ccx, id)\n+    fn get_trait_def(&self, span: Span, id: ast::DefId)\n+                     -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>\n+    {\n+        self.ccx.cycle_check(span, AstConvRequest::GetTraitDef(id), || {\n+            get_trait_def(self.ccx, id)\n+        })\n     }\n \n     fn get_type_parameter_bounds(&self,\n-                                 param: subst::ParamSpace,\n-                                 index: u32)\n-                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+                                 span: Span,\n+                                 node_id: ast::NodeId)\n+                                 -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n     {\n-        // TODO out of range indices can occur when you have something\n-        // like fn foo<T:U::X,U>() { }\n-        match self.generics.types.opt_get(param, index as usize) {\n-            Some(def) => def.bounds.trait_bounds.clone(),\n-            None => Vec::new(),\n-        }\n+        self.ccx.cycle_check(span, AstConvRequest::GetTypeParameterBounds(node_id), || {\n+            let def = self.tcx().type_parameter_def(node_id);\n+\n+            // TODO out of range indices can occur when you have something\n+            // like fn foo<T:U::X,U>() { }\n+            match self.generics.types.opt_get(def.space, def.index as usize) {\n+                Some(def) => def.bounds.trait_bounds.clone(),\n+                None => Vec::new(),\n+            }\n+        })\n     }\n \n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {"}, {"sha": "51fee683a81c9c2484403677268843ddcfde2b89", "filename": "src/test/compile-fail/cycle-generic-bound.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Ftest%2Fcompile-fail%2Fcycle-generic-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Ftest%2Fcompile-fail%2Fcycle-generic-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-generic-bound.rs?ref=0d9e473be9e07885d49a7e5699eebd53ccfcc2fb", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #15477. This test should pass, vs reporting an\n+// error as it does now, but at least this test shows it doesn't\n+// segfault.\n+\n+trait Chromosome<X: Chromosome> {\n+    //~^ ERROR cyclic reference detected\n+}\n+\n+fn main() { }"}, {"sha": "836b581d2bfb33b2330849fd5c60da4cef3c0ba0", "filename": "src/test/compile-fail/cycle-trait-supertrait-direct.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-direct.rs?ref=0d9e473be9e07885d49a7e5699eebd53ccfcc2fb", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a supertrait cycle where a trait extends itself.\n+\n+trait Chromosome: Chromosome {\n+    //~^ ERROR cyclic reference detected\n+}\n+\n+fn main() { }"}, {"sha": "68553462036f274336331168814946c4f6a0ce7e", "filename": "src/test/compile-fail/cycle-trait-supertrait-indirect.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs?ref=0d9e473be9e07885d49a7e5699eebd53ccfcc2fb", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a supertrait cycle where the first trait we find (`A`) is not\n+// a direct participant in the cycle.\n+\n+trait A: B {\n+}\n+\n+trait B: C { }\n+    //~^ ERROR cyclic reference detected\n+\n+trait C: B { }\n+\n+fn main() { }"}, {"sha": "912961120c21a3a01d14fa059d93786c12bee61a", "filename": "src/test/compile-fail/cycle-trait-type-trait.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Ftest%2Fcompile-fail%2Fcycle-trait-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9e473be9e07885d49a7e5699eebd53ccfcc2fb/src%2Ftest%2Fcompile-fail%2Fcycle-trait-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-type-trait.rs?ref=0d9e473be9e07885d49a7e5699eebd53ccfcc2fb", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a supertrait cycle where a trait extends itself.\n+\n+trait Chromosome: Get<Struct> {\n+    //~^ ERROR cyclic reference detected\n+}\n+\n+trait Get<A> {\n+    fn get(&self) -> A;\n+}\n+\n+struct Struct<C:Chromosome> { c: C }\n+\n+fn main() { }"}]}