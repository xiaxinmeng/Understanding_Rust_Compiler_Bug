{"sha": "84bed9769b5d15871481b657860ad6a7d0a62f42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0YmVkOTc2OWI1ZDE1ODcxNDgxYjY1Nzg2MGFkNmE3ZDBhNjJmNDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-12T23:25:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-12T23:25:34Z"}, "message": "auto merge of #7091 : msullivan/rust/default-methods, r=graydon\n\nr? @nikomatsakis", "tree": {"sha": "88072cec4f6b589a31531cec6b13d2b12cce0a2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88072cec4f6b589a31531cec6b13d2b12cce0a2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84bed9769b5d15871481b657860ad6a7d0a62f42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84bed9769b5d15871481b657860ad6a7d0a62f42", "html_url": "https://github.com/rust-lang/rust/commit/84bed9769b5d15871481b657860ad6a7d0a62f42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84bed9769b5d15871481b657860ad6a7d0a62f42/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26a5c9768b149a53c8b587b2416829b2595d520f", "url": "https://api.github.com/repos/rust-lang/rust/commits/26a5c9768b149a53c8b587b2416829b2595d520f", "html_url": "https://github.com/rust-lang/rust/commit/26a5c9768b149a53c8b587b2416829b2595d520f"}, {"sha": "36e3d64c3e6030d661d48bf881ed2fef58170be6", "url": "https://api.github.com/repos/rust-lang/rust/commits/36e3d64c3e6030d661d48bf881ed2fef58170be6", "html_url": "https://github.com/rust-lang/rust/commit/36e3d64c3e6030d661d48bf881ed2fef58170be6"}], "stats": {"total": 234, "additions": 109, "deletions": 125}, "files": [{"sha": "855782f3a82a8523d4f577382cee8064b73d1c81", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=84bed9769b5d15871481b657860ad6a7d0a62f42", "patch": "@@ -506,9 +506,11 @@ pub fn get_res_dtor(ccx: @CrateContext,\n             did\n         };\n         assert_eq!(did.crate, ast::local_crate);\n+        let tsubsts = ty::substs { self_r: None, self_ty: None,\n+                                  tps: /*bad*/ substs.to_owned() };\n         let (val, _) = monomorphize::monomorphic_fn(ccx,\n                                                     did,\n-                                                    substs,\n+                                                    &tsubsts,\n                                                     None,\n                                                     None,\n                                                     None);"}, {"sha": "2ef751579202f3af7cca0bc4ca93f736bd18cca7", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 71, "deletions": 6, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=84bed9769b5d15871481b657860ad6a7d0a62f42", "patch": "@@ -41,6 +41,7 @@ use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::type_of;\n use middle::ty;\n+use middle::subst::Subst;\n use middle::typeck;\n use util::ppaux::Repr;\n \n@@ -230,11 +231,75 @@ pub fn trans_fn_ref_with_vtables(\n     // Polytype of the function item (may have type params)\n     let fn_tpt = ty::lookup_item_type(tcx, def_id);\n \n-    // Modify the def_id if this is a default method; we want to be\n-    // monomorphizing the trait's code.\n-    let (def_id, opt_impl_did) = match tcx.provided_method_sources.find(&def_id) {\n-        None => (def_id, None),\n-        Some(source) => (source.method_id, Some(source.impl_id))\n+    let substs = ty::substs { self_r: None, self_ty: None,\n+                              tps: /*bad*/ type_params.to_owned() };\n+\n+\n+    // We need to do a bunch of special handling for default methods.\n+    // We need to modify the def_id and our substs in order to monomorphize\n+    // the function.\n+    let (def_id, opt_impl_did, substs) = match tcx.provided_method_sources.find(&def_id) {\n+        None => (def_id, None, substs),\n+        Some(source) => {\n+            // There are two relevant substitutions when compiling\n+            // default methods. First, there is the substitution for\n+            // the type parameters of the impl we are using and the\n+            // method we are calling. This substitution is the substs\n+            // argument we already have.\n+            // In order to compile a default method, though, we need\n+            // to consider another substitution: the substitution for\n+            // the type parameters on trait; the impl we are using\n+            // implements the trait at some particular type\n+            // parameters, and we need to substitute for those first.\n+            // So, what we need to do is find this substitution and\n+            // compose it with the one we already have.\n+\n+            // In order to find the substitution for the trait params,\n+            // we look up the impl in the ast map, find its trait_ref\n+            // id, then look up its trait ref. I feel like there\n+            // should be a better way.\n+            let map_node = session::expect(\n+                ccx.sess,\n+                ccx.tcx.items.find_copy(&source.impl_id.node),\n+                || fmt!(\"couldn't find node while monomorphizing \\\n+                         default method: %?\", source.impl_id.node));\n+            let item = match map_node {\n+                ast_map::node_item(item, _) => item,\n+                _ => ccx.tcx.sess.bug(\"Not an item\")\n+            };\n+            let ast_trait_ref = match copy item.node {\n+                ast::item_impl(_, Some(tr), _, _) => tr,\n+                _ => ccx.tcx.sess.bug(\"Not an impl with trait_ref\")\n+            };\n+            let trait_ref = ccx.tcx.trait_refs.get(&ast_trait_ref.ref_id);\n+\n+            // The substs from the trait_ref only substitues for the\n+            // trait parameters. Our substitution also needs to be\n+            // able to substitute for the actual method type\n+            // params. To do this, we figure out how many method\n+            // parameters there are and pad out the substitution with\n+            // substitution for the variables.\n+            let item_ty = ty::lookup_item_type(tcx, source.method_id);\n+            let num_params = item_ty.generics.type_param_defs.len() -\n+                trait_ref.substs.tps.len();\n+            let id_subst = do vec::from_fn(num_params) |i| {\n+                ty::mk_param(tcx, i, ast::def_id {crate: 0, node: 0})\n+            };\n+            // Merge the two substitions together now.\n+            let first_subst = ty::substs {tps: trait_ref.substs.tps + id_subst,\n+                                          .. trait_ref.substs};\n+\n+            // And compose them.\n+            let new_substs = first_subst.subst(tcx, &substs);\n+            debug!(\"trans_fn_with_vtables - default method: \\\n+                    substs = %s, id_subst = %s, trait_subst = %s, \\\n+                    first_subst = %s, new_subst = %s\",\n+                   substs.repr(tcx),\n+                   id_subst.repr(tcx), trait_ref.substs.repr(tcx),\n+                   first_subst.repr(tcx), new_substs.repr(tcx));\n+\n+            (source.method_id, Some(source.impl_id), new_substs)\n+        }\n     };\n \n     // Check whether this fn has an inlined copy and, if so, redirect\n@@ -279,7 +344,7 @@ pub fn trans_fn_ref_with_vtables(\n         assert_eq!(def_id.crate, ast::local_crate);\n \n         let mut (val, must_cast) =\n-            monomorphize::monomorphic_fn(ccx, def_id, type_params,\n+            monomorphize::monomorphic_fn(ccx, def_id, &substs,\n                                          vtables, opt_impl_did, Some(ref_id));\n         if must_cast && ref_id != 0 {\n             // Monotype of the REFERENCE to the function (type params"}, {"sha": "9d8ef2e603b47242d885ce58bd0bfdf6cfb0866e", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 22, "deletions": 47, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=84bed9769b5d15871481b657860ad6a7d0a62f42", "patch": "@@ -207,7 +207,9 @@ pub fn trans_method_callee(bcx: block,\n             let method_name =\n                 ty::trait_method(tcx, trait_id, method_index).ident;\n             let method_id =\n-                method_with_name(bcx.ccx(), impl_def_id, method_name);\n+                method_with_name_or_default(bcx.ccx(),\n+                                            impl_def_id,\n+                                            method_name);\n             origin = typeck::method_static(method_id);\n         }\n         typeck::method_super(trait_id, method_index) => {\n@@ -229,9 +231,10 @@ pub fn trans_method_callee(bcx: block,\n                 ty::method(tcx, supertrait_method_def_ids[method_index]).ident;\n             // Now that we know the impl ID, we can look up the method\n             // ID from its name\n-            origin = typeck::method_static(method_with_name(bcx.ccx(),\n-                                                            impl_id,\n-                                                            method_name));\n+            origin = typeck::method_static(\n+                method_with_name_or_default(bcx.ccx(),\n+                                            impl_id,\n+                                            method_name));\n         }\n         typeck::method_static(*) | typeck::method_param(*) |\n         typeck::method_trait(*) => {}\n@@ -345,7 +348,9 @@ pub fn trans_static_method_callee(bcx: block,\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n             assert!(rcvr_substs.all(|t| !ty::type_needs_infer(*t)));\n \n-            let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n+            let mth_id = method_with_name_or_default(bcx.ccx(),\n+                                                     impl_did,\n+                                                     mname);\n             let callee_substs = combine_impl_and_methods_tps(\n                 bcx, mth_id, impl_did, callee_id, *rcvr_substs);\n             let callee_origins = combine_impl_and_methods_origins(\n@@ -374,23 +379,6 @@ pub fn method_from_methods(ms: &[@ast::method], name: ast::ident)\n     ms.find(|m| m.ident == name).map(|m| ast_util::local_def(m.id))\n }\n \n-pub fn method_with_name(ccx: @CrateContext, impl_id: ast::def_id,\n-                        name: ast::ident) -> ast::def_id {\n-    if impl_id.crate == ast::local_crate {\n-        match ccx.tcx.items.get_copy(&impl_id.node) {\n-          ast_map::node_item(@ast::item {\n-                node: ast::item_impl(_, _, _, ref ms),\n-                _\n-            }, _) => {\n-            method_from_methods(*ms, name).get()\n-          }\n-          _ => fail!(\"method_with_name\")\n-        }\n-    } else {\n-        csearch::get_impl_method(ccx.sess.cstore, impl_id, name)\n-    }\n-}\n-\n pub fn method_with_name_or_default(ccx: @CrateContext,\n                                    impl_id: ast::def_id,\n                                    name: ast::ident) -> ast::def_id {\n@@ -770,17 +758,17 @@ pub fn vtable_id(ccx: @CrateContext,\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n-pub fn get_vtable(ccx: @CrateContext,\n+pub fn get_vtable(bcx: block,\n                   self_ty: ty::t,\n                   origin: typeck::vtable_origin)\n                   -> ValueRef {\n-    let hash_id = vtable_id(ccx, &origin);\n-    match ccx.vtables.find(&hash_id) {\n+    let hash_id = vtable_id(bcx.ccx(), &origin);\n+    match bcx.ccx().vtables.find(&hash_id) {\n         Some(&val) => val,\n         None => {\n             match origin {\n                 typeck::vtable_static(id, substs, sub_vtables) => {\n-                    make_impl_vtable(ccx, id, self_ty, substs, sub_vtables)\n+                    make_impl_vtable(bcx, id, self_ty, substs, sub_vtables)\n                 }\n                 _ => fail!(\"get_vtable: expected a static origin\"),\n             }\n@@ -814,12 +802,13 @@ pub fn make_vtable(ccx: @CrateContext,\n }\n \n /// Generates a dynamic vtable for objects.\n-pub fn make_impl_vtable(ccx: @CrateContext,\n+pub fn make_impl_vtable(bcx: block,\n                         impl_id: ast::def_id,\n                         self_ty: ty::t,\n                         substs: ~[ty::t],\n                         vtables: typeck::vtable_res)\n                         -> ValueRef {\n+    let ccx = bcx.ccx();\n     let _icx = ccx.insn_ctxt(\"impl::make_impl_vtable\");\n     let tcx = ccx.tcx;\n \n@@ -829,9 +818,6 @@ pub fn make_impl_vtable(ccx: @CrateContext,\n                                     make a vtable for a type impl!\")\n     };\n \n-    let has_tps =\n-        !ty::lookup_item_type(ccx.tcx, impl_id).generics.type_param_defs.is_empty();\n-\n     let trait_method_def_ids = ty::trait_method_def_ids(tcx, trt_id);\n     let methods = do trait_method_def_ids.map |method_def_id| {\n         let im = ty::method(tcx, *method_def_id);\n@@ -846,22 +832,11 @@ pub fn make_impl_vtable(ccx: @CrateContext,\n         } else {\n             debug!(\"(making impl vtable) adding method to vtable: %s\",\n                    *tcx.sess.str_of(im.ident));\n-            let mut m_id = method_with_name(ccx, impl_id, im.ident);\n-            if has_tps {\n-                // If the method is in another crate, need to make an inlined\n-                // copy first\n-                if m_id.crate != ast::local_crate {\n-                    // XXX: Set impl ID here?\n-                    m_id = inline::maybe_instantiate_inline(ccx, m_id, true);\n-                }\n-                let (val, _) = monomorphize::monomorphic_fn(ccx, m_id, substs,\n-                                Some(vtables), None, None);\n-                val\n-            } else if m_id.crate == ast::local_crate {\n-                get_item_val(ccx, m_id.node)\n-            } else {\n-                trans_external_path(ccx, m_id, fty)\n-            }\n+            let m_id = method_with_name_or_default(ccx, impl_id, im.ident);\n+\n+            trans_fn_ref_with_vtables(bcx, m_id, 0,\n+                                      substs, Some(vtables)).llfn\n+\n         }\n     };\n \n@@ -903,7 +878,7 @@ pub fn trans_trait_cast(bcx: block,\n     // Store the vtable into the pair or triple.\n     let orig = /*bad*/copy ccx.maps.vtable_map.get(&id)[0];\n     let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n-    let vtable = get_vtable(bcx.ccx(), v_ty, orig);\n+    let vtable = get_vtable(bcx, v_ty, orig);\n     Store(bcx, vtable, PointerCast(bcx,\n                                    GEPi(bcx, lldest, [0u, abi::trt_field_vtable]),\n                                    T_ptr(val_ty(vtable))));"}, {"sha": "35ff3a56df4e745265a333507269923e0f2dbbf7", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=84bed9769b5d15871481b657860ad6a7d0a62f42", "patch": "@@ -43,7 +43,7 @@ use syntax::abi::AbiSet;\n \n pub fn monomorphic_fn(ccx: @CrateContext,\n                       fn_id: ast::def_id,\n-                      real_substs: &[ty::t],\n+                      real_substs: &ty::substs,\n                       vtables: Option<typeck::vtable_res>,\n                       impl_did_opt: Option<ast::def_id>,\n                       ref_id: Option<ast::node_id>)\n@@ -61,17 +61,17 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n            impl_did_opt.repr(ccx.tcx),\n            ref_id);\n \n-    assert!(real_substs.all(|t| !ty::type_needs_infer(*t)));\n+    assert!(real_substs.tps.all(|t| !ty::type_needs_infer(*t)));\n     let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n-    let substs = vec::map(real_substs, |t| {\n+    let substs = vec::map(real_substs.tps, |t| {\n         match normalize_for_monomorphization(ccx.tcx, *t) {\n           Some(t) => { must_cast = true; t }\n           None => *t\n         }\n     });\n \n-    for real_substs.each() |s| { assert!(!ty::type_has_params(*s)); }\n+    for real_substs.tps.each() |s| { assert!(!ty::type_has_params(*s)); }\n     for substs.each() |s| { assert!(!ty::type_has_params(*s)); }\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n     let hash_id = make_mono_id(ccx, fn_id, substs, vtables, impl_did_opt,\n@@ -145,17 +145,8 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n       ast_map::node_struct_ctor(_, i, pt) => (pt, i.ident, i.span)\n     };\n \n-    // Look up the impl type if we're translating a default method.\n-    // XXX: Generics.\n-    let impl_ty_opt;\n-    match impl_did_opt {\n-        None => impl_ty_opt = None,\n-        Some(impl_did) => {\n-            impl_ty_opt = Some(ty::lookup_item_type(ccx.tcx, impl_did).ty);\n-        }\n-    }\n-\n-    let mono_ty = ty::subst_tps(ccx.tcx, substs, impl_ty_opt, llitem_ty);\n+    let mono_ty = ty::subst_tps(ccx.tcx, substs,\n+                                real_substs.self_ty, llitem_ty);\n     let llfty = type_of_fn_from_ty(ccx, mono_ty);\n \n     ccx.stats.n_monos += 1;\n@@ -186,7 +177,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         tys: substs,\n         vtables: vtables,\n         type_param_defs: tpt.generics.type_param_defs,\n-        self_ty: impl_ty_opt\n+        self_ty: real_substs.self_ty\n     });\n \n     let lldecl = match map_node {"}, {"sha": "b2c9d27241d438e9d039caab2c64a7e22fcde98a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 49, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=84bed9769b5d15871481b657860ad6a7d0a62f42", "patch": "@@ -192,7 +192,7 @@ impl<'self> LookupContext<'self> {\n \n         // Prepare the list of candidates\n         self.push_inherent_candidates(self_ty);\n-        self.push_extension_candidates(self_ty);\n+        self.push_extension_candidates();\n \n         let mut enum_dids = ~[];\n         let mut self_ty = self_ty;\n@@ -326,7 +326,7 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn push_extension_candidates(&self, self_ty: ty::t) {\n+    pub fn push_extension_candidates(&self) {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n@@ -343,17 +343,8 @@ impl<'self> LookupContext<'self> {\n                     for impl_infos.each |impl_info| {\n                         self.push_candidates_from_impl(\n                             self.extension_candidates, *impl_info);\n-                    }\n-                }\n \n-                // Look for default methods.\n-                match self.tcx().provided_methods.find(trait_did) {\n-                    Some(&methods) => {\n-                        self.push_candidates_from_provided_methods(\n-                            self.extension_candidates, self_ty, *trait_did,\n-                            methods);\n                     }\n-                    None => {}\n                 }\n             }\n         }\n@@ -580,44 +571,6 @@ impl<'self> LookupContext<'self> {\n         });\n     }\n \n-    pub fn push_candidates_from_provided_methods(&self,\n-                                                 candidates:\n-                                                 &mut ~[Candidate],\n-                                                 self_ty: ty::t,\n-                                                 trait_def_id: def_id,\n-                                                 methods:\n-                                                 &mut ~[@ProvidedMethodInfo])\n-                                                 {\n-        debug!(\"(pushing candidates from provided methods) considering trait \\\n-                id %d:%d\",\n-               trait_def_id.crate,\n-               trait_def_id.node);\n-\n-        for methods.each |provided_method_info| {\n-            if provided_method_info.method_info.ident != self.m_name { loop; }\n-\n-            debug!(\"(pushing candidates from provided methods) adding \\\n-                    candidate\");\n-\n-            let method = ty::method(self.tcx(),\n-                                    provided_method_info.method_info.did);\n-\n-            // FIXME #4099 (?) Needs to support generics.\n-            let dummy_substs = substs {\n-                self_r: None,\n-                self_ty: None,\n-                tps: ~[]\n-            };\n-\n-            candidates.push(Candidate {\n-                rcvr_ty: self_ty,\n-                rcvr_substs: dummy_substs,\n-                method_ty: method,\n-                origin: method_static(provided_method_info.method_info.did)\n-            });\n-        }\n-    }\n-\n     // ______________________________________________________________________\n     // Candidate selection (see comment at start of file)\n "}, {"sha": "adabafc082a0c2d71adf74f03e2c3c4c19cddefd", "filename": "src/test/run-pass/trait-default-method-bound-subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst.rs?ref=84bed9769b5d15871481b657860ad6a7d0a62f42", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n+#[allow(default_methods)];\n \n trait A<T> {\n-    fn g<U>(x: T, y: U) -> (T, U) { (x, y) }\n+    fn g<U>(&self, x: T, y: U) -> (T, U) { (x, y) }\n }\n \n impl A<int> for int { }"}, {"sha": "dee9782d5ae707e29e79c95982b335c062c75b5d", "filename": "src/test/run-pass/trait-default-method-bound-subst2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst2.rs?ref=84bed9769b5d15871481b657860ad6a7d0a62f42", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n+#[allow(default_methods)];\n \n trait A<T> {\n     fn g(&self, x: T) -> T { x }"}, {"sha": "65009bb716d638fc279267884a9e98ef86429f05", "filename": "src/test/run-pass/traits-default-method-self.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Ftest%2Frun-pass%2Ftraits-default-method-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bed9769b5d15871481b657860ad6a7d0a62f42/src%2Ftest%2Frun-pass%2Ftraits-default-method-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-default-method-self.rs?ref=84bed9769b5d15871481b657860ad6a7d0a62f42", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//xfail-test\n-\n-// Currently failing with an ICE in trans.  (FIXME: #4350)\n+#[allow(default_methods)];\n \n trait Cat {\n     fn meow(&self) -> bool;"}]}