{"sha": "2a5487afb47aa01c7ee1446bae616bd2e34ec6ad", "node_id": "C_kwDOAAsO6NoAKDJhNTQ4N2FmYjQ3YWEwMWM3ZWUxNDQ2YmFlNjE2YmQyZTM0ZWM2YWQ", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-20T03:00:43Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-20T03:46:11Z"}, "message": "Merge `TokenStreamBuilder::push` into `TokenStreamBuilder::build`.\n\nBoth functions do some modifying of streams using `make_mut`:\n- `push` sometimes glues the first token of the next stream to the last\n  token of the first stream.\n- `build` appends tokens to the first stream.\n\nBy doing all of this in the one place, things are simpler. The first\nstream can be modified in both ways (if necessary) in the one place, and\nany next stream with the first token removed doesn't need to be stored.", "tree": {"sha": "2b58b5607c6b33ff07a0366252b90eeb0078fa6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b58b5607c6b33ff07a0366252b90eeb0078fa6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a5487afb47aa01c7ee1446bae616bd2e34ec6ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a5487afb47aa01c7ee1446bae616bd2e34ec6ad", "html_url": "https://github.com/rust-lang/rust/commit/2a5487afb47aa01c7ee1446bae616bd2e34ec6ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a5487afb47aa01c7ee1446bae616bd2e34ec6ad/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6b57883e0cd4ba5f1bfd8d4484778c5852ce585", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6b57883e0cd4ba5f1bfd8d4484778c5852ce585", "html_url": "https://github.com/rust-lang/rust/commit/f6b57883e0cd4ba5f1bfd8d4484778c5852ce585"}], "stats": {"total": 85, "additions": 32, "deletions": 53}, "files": [{"sha": "37de90d64c774409d4ecdb353fdfb1f7d5e052e3", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 32, "deletions": 53, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2a5487afb47aa01c7ee1446bae616bd2e34ec6ad/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5487afb47aa01c7ee1446bae616bd2e34ec6ad/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=2a5487afb47aa01c7ee1446bae616bd2e34ec6ad", "patch": "@@ -523,46 +523,7 @@ impl TokenStreamBuilder {\n     }\n \n     pub fn push<T: Into<TokenStream>>(&mut self, stream: T) {\n-        let mut stream = stream.into();\n-\n-        // If `self` is not empty and the last tree within the last stream is a\n-        // token tree marked with `Joint`...\n-        if let Some(TokenStream(ref mut last_stream_lrc)) = self.0.last_mut()\n-            && let Some((TokenTree::Token(last_token), Spacing::Joint)) = last_stream_lrc.last()\n-            // ...and `stream` is not empty and the first tree within it is\n-            // a token tree...\n-            && let TokenStream(ref mut stream_lrc) = stream\n-            && let Some((TokenTree::Token(token), spacing)) = stream_lrc.first()\n-            // ...and the two tokens can be glued together...\n-            && let Some(glued_tok) = last_token.glue(&token)\n-        {\n-            // ...then do so, by overwriting the last token\n-            // tree in `self` and removing the first token tree\n-            // from `stream`. This requires using `make_mut()`\n-            // on the last stream in `self` and on `stream`,\n-            // and in practice this doesn't cause cloning 99.9%\n-            // of the time.\n-\n-            // Overwrite the last token tree with the merged\n-            // token.\n-            let last_vec_mut = Lrc::make_mut(last_stream_lrc);\n-            *last_vec_mut.last_mut().unwrap() = (TokenTree::Token(glued_tok), *spacing);\n-\n-            // Remove the first token tree from `stream`. (This\n-            // is almost always the only tree in `stream`.)\n-            let stream_vec_mut = Lrc::make_mut(stream_lrc);\n-            stream_vec_mut.remove(0);\n-\n-            // Don't push `stream` if it's empty -- that could\n-            // block subsequent token gluing, by getting\n-            // between two token trees that should be glued\n-            // together.\n-            if !stream.is_empty() {\n-                self.0.push(stream);\n-            }\n-            return;\n-        }\n-        self.0.push(stream);\n+        self.0.push(stream.into());\n     }\n \n     pub fn build(self) -> TokenStream {\n@@ -571,9 +532,9 @@ impl TokenStreamBuilder {\n             0 => TokenStream::default(),\n             1 => streams.pop().unwrap(),\n             _ => {\n-                // We are going to extend the first stream in `streams` with\n-                // the elements from the subsequent streams. This requires\n-                // using `make_mut()` on the first stream, and in practice this\n+                // We will extend the first stream in `streams` with the\n+                // elements from the subsequent streams. This requires using\n+                // `make_mut()` on the first stream, and in practice this\n                 // doesn't cause cloning 99.9% of the time.\n                 //\n                 // One very common use case is when `streams` has two elements,\n@@ -586,21 +547,39 @@ impl TokenStreamBuilder {\n                 // reallocations (#57735).\n                 let num_appends = streams.iter().skip(1).map(|ts| ts.len()).sum();\n \n-                // Get the first stream. If it's `None`, create an empty\n-                // stream.\n+                // Get the first stream, which will become the result stream.\n+                // If it's `None`, create an empty stream.\n                 let mut iter = streams.drain(..);\n-                let mut first_stream_lrc = iter.next().unwrap().0;\n+                let mut res_stream_lrc = iter.next().unwrap().0;\n \n-                // Append the elements to the first stream, after reserving\n-                // space for them.\n-                let first_vec_mut = Lrc::make_mut(&mut first_stream_lrc);\n-                first_vec_mut.reserve(num_appends);\n+                // Append the subsequent elements to the result stream, after\n+                // reserving space for them.\n+                let res_vec_mut = Lrc::make_mut(&mut res_stream_lrc);\n+                res_vec_mut.reserve(num_appends);\n                 for stream in iter {\n-                    first_vec_mut.extend(stream.0.iter().cloned());\n+                    let stream_iter = stream.0.iter().cloned();\n+\n+                    // If (a) `res_mut_vec` is not empty and the last tree\n+                    // within it is a token tree marked with `Joint`, and (b)\n+                    // `stream` is not empty and the first tree within it is a\n+                    // token tree, and (c) the two tokens can be glued\n+                    // together...\n+                    if let Some((TokenTree::Token(last_tok), Spacing::Joint)) = res_vec_mut.last()\n+                        && let Some((TokenTree::Token(tok), spacing)) = stream.0.first()\n+                        && let Some(glued_tok) = last_tok.glue(&tok)\n+                    {\n+                        // ...then overwrite the last token tree in\n+                        // `res_vec_mut` with the glued token, and skip the\n+                        // first token tree from `stream`.\n+                        *res_vec_mut.last_mut().unwrap() = (TokenTree::Token(glued_tok), *spacing);\n+                        res_vec_mut.extend(stream_iter.skip(1));\n+                    } else {\n+                        // Append all of `stream`.\n+                        res_vec_mut.extend(stream_iter);\n+                    }\n                 }\n \n-                // Create the final `TokenStream`.\n-                TokenStream(first_stream_lrc)\n+                TokenStream(res_stream_lrc)\n             }\n         }\n     }"}]}