{"sha": "c6b3f687d5d9917b626f80a730552a185052ff28", "node_id": "C_kwDOAAsO6NoAKGM2YjNmNjg3ZDVkOTkxN2I2MjZmODBhNzMwNTUyYTE4NTA1MmZmMjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-01T23:47:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-01T23:47:10Z"}, "message": "Auto merge of #1991 - RalfJung:rustup, r=RalfJung\n\nRustup: simd_select\n\nCc https://github.com/rust-lang/rust/issues/94474", "tree": {"sha": "c615937851effcf47d638c0c4951570886ae486d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c615937851effcf47d638c0c4951570886ae486d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6b3f687d5d9917b626f80a730552a185052ff28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6b3f687d5d9917b626f80a730552a185052ff28", "html_url": "https://github.com/rust-lang/rust/commit/c6b3f687d5d9917b626f80a730552a185052ff28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6b3f687d5d9917b626f80a730552a185052ff28/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e05a543f74dbdd0580b2bd35ddb7f8e144d9edda", "url": "https://api.github.com/repos/rust-lang/rust/commits/e05a543f74dbdd0580b2bd35ddb7f8e144d9edda", "html_url": "https://github.com/rust-lang/rust/commit/e05a543f74dbdd0580b2bd35ddb7f8e144d9edda"}, {"sha": "363236e2d493b8a29d6ed7e849279ecf22c732ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/363236e2d493b8a29d6ed7e849279ecf22c732ce", "html_url": "https://github.com/rust-lang/rust/commit/363236e2d493b8a29d6ed7e849279ecf22c732ce"}], "stats": {"total": 78, "additions": 55, "deletions": 23}, "files": [{"sha": "cab2da408db439968d98d78038f8ec44ef8291d2", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3f687d5d9917b626f80a730552a185052ff28/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3f687d5d9917b626f80a730552a185052ff28/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=c6b3f687d5d9917b626f80a730552a185052ff28", "patch": "@@ -1 +1 @@\n-6a705566166debf5eff88c57140df607fa409aaa\n+f0c4da49983aa699f715caf681e3154b445fb60b"}, {"sha": "2f1c74a0587ec07ba0a5aefc3836dfa7b2d020e3", "filename": "src/helpers.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3f687d5d9917b626f80a730552a185052ff28/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3f687d5d9917b626f80a730552a185052ff28/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=c6b3f687d5d9917b626f80a730552a185052ff28", "patch": "@@ -758,3 +758,18 @@ pub fn immty_from_uint_checked<'tcx>(\n         err_unsup_format!(\"unsigned value {:#x} does not fit in {} bits\", int, layout.size.bits())\n     })?)\n }\n+\n+pub fn bool_to_simd_element(b: bool, size: Size) -> Scalar<Tag> {\n+    // SIMD uses all-1 as pattern for \"true\"\n+    let val = if b { -1 } else { 0 };\n+    Scalar::from_int(val, size)\n+}\n+\n+pub fn simd_element_to_bool<'tcx>(elem: ImmTy<'tcx, Tag>) -> InterpResult<'tcx, bool> {\n+    let val = elem.to_scalar()?.to_int(elem.layout.size)?;\n+    Ok(match val {\n+        0 => false,\n+        -1 => true,\n+        _ => throw_ub_format!(\"each element of a SIMD mask must be all-0-bits or all-1-bits\"),\n+    })\n+}"}, {"sha": "e84923314186ce01d0d30cac341755b89c1b9281", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3f687d5d9917b626f80a730552a185052ff28/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3f687d5d9917b626f80a730552a185052ff28/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=c6b3f687d5d9917b626f80a730552a185052ff28", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::{mir, mir::BinOp, ty, ty::FloatTy};\n use rustc_target::abi::{Align, Integer};\n \n use crate::*;\n-use helpers::check_arg_count;\n+use helpers::{bool_to_simd_element, check_arg_count, simd_element_to_bool};\n \n pub enum AtomicOp {\n     MirOp(mir::BinOp, bool),\n@@ -365,8 +365,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         // Special handling for boolean-returning operations\n                         assert_eq!(ty, this.tcx.types.bool);\n                         let val = val.to_bool().unwrap();\n-                        let val = if val { -1 } else { 0 }; // SIMD uses all-1 as pattern for \"true\"\n-                        let val = Scalar::from_int(val, dest.layout.size);\n+                        let val = bool_to_simd_element(val, dest.layout.size);\n                         this.write_scalar(val, &dest.into())?;\n                     } else {\n                         assert_eq!(ty, dest.layout.ty);\n@@ -381,21 +380,34 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let mut res = false; // the neutral element\n                 for i in 0..arg_len {\n                     let op = this.read_immediate(&this.mplace_index(&arg, i)?.into())?;\n-                    // We convert it to a *signed* integer and expect either 0 or -1 (the latter means all bits were set).\n-                    let val = op.to_scalar()?.to_int(op.layout.size)?;\n-                    let val = match val {\n-                        0 => false,\n-                        -1 => true,\n-                        _ =>\n-                            throw_ub_format!(\n-                                \"each element of a simd_reduce_any operand must be all-0-bits or all-1-bits\"\n-                            ),\n-                    };\n+                    let val = simd_element_to_bool(op)?;\n                     res = res | val;\n                 }\n \n                 this.write_scalar(Scalar::from_bool(res), dest)?;\n             }\n+            \"simd_select\" => {\n+                let &[ref mask, ref yes, ref no] = check_arg_count(args)?;\n+                let (mask, mask_len) = this.operand_to_simd(mask)?;\n+                let (yes, yes_len) = this.operand_to_simd(yes)?;\n+                let (no, no_len) = this.operand_to_simd(no)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, mask_len);\n+                assert_eq!(dest_len, yes_len);\n+                assert_eq!(dest_len, no_len);\n+\n+                for i in 0..dest_len {\n+                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n+                    let yes = this.read_immediate(&this.mplace_index(&yes, i)?.into())?;\n+                    let no = this.read_immediate(&this.mplace_index(&no, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let mask = simd_element_to_bool(mask)?;\n+                    let val = if mask { yes } else { no };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+            }\n \n             // Atomic operations\n             \"atomic_load\" => this.atomic_load(args, dest, AtomicReadOp::SeqCst)?,"}, {"sha": "98d5b65e3e68c0ea5bb97ff5006dbb321b3e16ff", "filename": "tests/run-pass/portable-simd.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c6b3f687d5d9917b626f80a730552a185052ff28/tests%2Frun-pass%2Fportable-simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b3f687d5d9917b626f80a730552a185052ff28/tests%2Frun-pass%2Fportable-simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fportable-simd.rs?ref=c6b3f687d5d9917b626f80a730552a185052ff28", "patch": "@@ -20,7 +20,9 @@ fn simd_ops_i32() {\n     assert_eq!(a * b, i32x4::from_array([10, 20, 30, 40]));\n     assert_eq!(a / b, i32x4::from_array([10, 5, 3, 2]));\n     assert_eq!(a / i32x4::splat(2), i32x4::splat(5));\n+    assert_eq!(i32x2::splat(i32::MIN) / i32x2::splat(-1), i32x2::splat(i32::MIN));\n     assert_eq!(a % b, i32x4::from_array([0, 0, 1, 2]));\n+    assert_eq!(i32x2::splat(i32::MIN) % i32x2::splat(-1), i32x2::splat(0));\n     assert_eq!(b << i32x4::splat(2), i32x4::from_array([4, 8, 12, 16]));\n     assert_eq!(b >> i32x4::splat(1), i32x4::from_array([0, 1, 1, 2]));\n     assert_eq!(b & i32x4::splat(2), i32x4::from_array([0, 2, 2, 0]));\n@@ -29,19 +31,22 @@ fn simd_ops_i32() {\n \n fn simd_intrinsics() {\n     extern \"platform-intrinsic\" {\n-        pub(crate) fn simd_eq<T, U>(x: T, y: T) -> U;\n-        pub(crate) fn simd_reduce_any<T>(x: T) -> bool;\n+        fn simd_eq<T, U>(x: T, y: T) -> U;\n+        fn simd_reduce_any<T>(x: T) -> bool;\n+        fn simd_select<M, T>(m: M, yes: T, no: T) -> T;\n     }\n-\n-    // Make sure simd_eq returns all-1 for `true`\n-    let a = i32x4::splat(10);\n-    let b = i32x4::from_array([1, 2, 10, 4]);\n-    let c: i32x4 = unsafe { simd_eq(a, b) };\n-    assert_eq!(c, i32x4::from_array([0, 0, -1, 0]));\n-\n     unsafe {\n+        // Make sure simd_eq returns all-1 for `true`\n+        let a = i32x4::splat(10);\n+        let b = i32x4::from_array([1, 2, 10, 4]);\n+        let c: i32x4 = simd_eq(a, b);\n+        assert_eq!(c, i32x4::from_array([0, 0, -1, 0]));\n+\n         assert!(!simd_reduce_any(i32x4::splat(0)));\n         assert!(simd_reduce_any(i32x4::splat(-1)));\n+\n+        assert_eq!(simd_select(i8x4::from_array([0, -1, -1, 0]), a, b), i32x4::from_array([1, 10, 10, 4]));\n+        assert_eq!(simd_select(i8x4::from_array([0, -1, -1, 0]), b, a), i32x4::from_array([10, 2, 10, 10]));\n     }\n }\n "}]}