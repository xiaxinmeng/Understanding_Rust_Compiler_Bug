{"sha": "3b7c713af34e199ab125e068add4d2657180e42b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiN2M3MTNhZjM0ZTE5OWFiMTI1ZTA2OGFkZDRkMjY1NzE4MGU0MmI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-08T15:12:08Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-08T15:56:34Z"}, "message": "Implement if_to_bool_then assist", "tree": {"sha": "fe27e37933c12979923cb5c860e141540b84b20b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe27e37933c12979923cb5c860e141540b84b20b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b7c713af34e199ab125e068add4d2657180e42b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b7c713af34e199ab125e068add4d2657180e42b", "html_url": "https://github.com/rust-lang/rust/commit/3b7c713af34e199ab125e068add4d2657180e42b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b7c713af34e199ab125e068add4d2657180e42b/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0d32591a68ecacd61a59aaa9df924890d0212d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0d32591a68ecacd61a59aaa9df924890d0212d7", "html_url": "https://github.com/rust-lang/rust/commit/f0d32591a68ecacd61a59aaa9df924890d0212d7"}], "stats": {"total": 391, "additions": 386, "deletions": 5}, "files": [{"sha": "b7b0f0b0e6bf8ccc04e7dcd90a17394b5d68b520", "filename": "crates/hir_expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b7c713af34e199ab125e068add4d2657180e42b/crates%2Fhir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7c713af34e199ab125e068add4d2657180e42b/crates%2Fhir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fname.rs?ref=3b7c713af34e199ab125e068add4d2657180e42b", "patch": "@@ -200,6 +200,7 @@ pub mod known {\n         Range,\n         Neg,\n         Not,\n+        None,\n         Index,\n         // Components of known path (function name)\n         filter_map,"}, {"sha": "1840b2d75678f0b6ead3c3c1d7152b06347a5a93", "filename": "crates/ide_assists/src/handlers/convert_bool_then.rs", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/3b7c713af34e199ab125e068add4d2657180e42b/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7c713af34e199ab125e068add4d2657180e42b/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs?ref=3b7c713af34e199ab125e068add4d2657180e42b", "patch": "@@ -0,0 +1,352 @@\n+use hir::{known, Semantics};\n+use ide_db::{\n+    helpers::{for_each_tail_expr, FamousDefs},\n+    RootDatabase,\n+};\n+use syntax::{\n+    ast::{self, make, ArgListOwner},\n+    ted, AstNode, SyntaxNode,\n+};\n+\n+use crate::{\n+    utils::{invert_boolean_expression, unwrap_trivial_block},\n+    AssistContext, AssistId, AssistKind, Assists,\n+};\n+\n+// Assist: convert_if_to_bool_then\n+//\n+// Converts an if expression into a corresponding `bool::then` call.\n+//\n+// ```\n+// # //- minicore: option\n+// fn main() {\n+//     if$0 cond {\n+//         Some(val)\n+//     } else {\n+//         None\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     cond.then(|| val)\n+// }\n+// ```\n+pub(crate) fn convert_if_to_bool_then(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    // todo, applies to match as well\n+    let expr = ctx.find_node_at_offset::<ast::IfExpr>()?;\n+    if !expr.if_token()?.text_range().contains_inclusive(ctx.offset()) {\n+        return None;\n+    }\n+\n+    let cond = expr.condition().filter(|cond| !cond.is_pattern_cond())?;\n+    let cond = cond.expr()?;\n+    let then = expr.then_branch()?;\n+    let else_ = match expr.else_branch()? {\n+        ast::ElseBranch::Block(b) => b,\n+        ast::ElseBranch::IfExpr(_) => {\n+            cov_mark::hit!(convert_if_to_bool_then_chain);\n+            return None;\n+        }\n+    };\n+\n+    let (none_variant, some_variant) = option_variants(&ctx.sema, expr.syntax())?;\n+\n+    let (invert_cond, closure_body) = match (\n+        block_is_none_variant(&ctx.sema, &then, none_variant),\n+        block_is_none_variant(&ctx.sema, &else_, none_variant),\n+    ) {\n+        (invert @ true, false) => (invert, ast::Expr::BlockExpr(else_)),\n+        (invert @ false, true) => (invert, ast::Expr::BlockExpr(then)),\n+        _ => return None,\n+    };\n+\n+    if is_invalid_body(&ctx.sema, some_variant, &closure_body) {\n+        cov_mark::hit!(convert_if_to_bool_then_pattern_invalid_body);\n+        return None;\n+    }\n+\n+    let target = expr.syntax().text_range();\n+    acc.add(\n+        AssistId(\"convert_if_to_bool_then\", AssistKind::RefactorRewrite),\n+        \"Convert `if` expression to `bool::then` call\",\n+        target,\n+        |builder| {\n+            let closure_body = closure_body.clone_for_update();\n+            // Rewrite all `Some(e)` in tail position to `e`\n+            for_each_tail_expr(&closure_body, &mut |e| {\n+                let e = match e {\n+                    ast::Expr::BreakExpr(e) => e.expr(),\n+                    e @ ast::Expr::CallExpr(_) => Some(e.clone()),\n+                    _ => None,\n+                };\n+                if let Some(ast::Expr::CallExpr(call)) = e {\n+                    if let Some(arg_list) = call.arg_list() {\n+                        if let Some(arg) = arg_list.args().next() {\n+                            ted::replace(call.syntax(), arg.syntax());\n+                        }\n+                    }\n+                }\n+            });\n+            let closure_body = match closure_body {\n+                ast::Expr::BlockExpr(block) => unwrap_trivial_block(block),\n+                e => e,\n+            };\n+\n+            let cond = if invert_cond { invert_boolean_expression(&ctx.sema, cond) } else { cond };\n+            let arg_list = make::arg_list(Some(make::expr_closure(None, closure_body)));\n+            let mcall = make::expr_method_call(cond, make::name_ref(\"then\"), arg_list);\n+            builder.replace(target, mcall.to_string());\n+        },\n+    )\n+}\n+\n+fn option_variants(\n+    sema: &Semantics<RootDatabase>,\n+    expr: &SyntaxNode,\n+) -> Option<(hir::Variant, hir::Variant)> {\n+    let fam = FamousDefs(&sema, sema.scope(expr).krate());\n+    let option_variants = fam.core_option_Option()?.variants(sema.db);\n+    match &*option_variants {\n+        &[variant0, variant1] => Some(if variant0.name(sema.db) == known::None {\n+            (variant0, variant1)\n+        } else {\n+            (variant1, variant0)\n+        }),\n+        _ => None,\n+    }\n+}\n+\n+/// Traverses the expression checking if it contains `return` or `?` expressions or if any tail is not a `Some(expr)` expression.\n+/// If any of these conditions are met it is impossible to rewrite this as a `bool::then` call.\n+fn is_invalid_body(\n+    sema: &Semantics<RootDatabase>,\n+    some_variant: hir::Variant,\n+    expr: &ast::Expr,\n+) -> bool {\n+    let mut invalid = false;\n+    expr.preorder(&mut |e| {\n+        invalid |=\n+            matches!(e, syntax::WalkEvent::Enter(ast::Expr::TryExpr(_) | ast::Expr::ReturnExpr(_)));\n+        invalid\n+    });\n+    if !invalid {\n+        for_each_tail_expr(&expr, &mut |e| {\n+            if invalid {\n+                return;\n+            }\n+            let e = match e {\n+                ast::Expr::BreakExpr(e) => e.expr(),\n+                e @ ast::Expr::CallExpr(_) => Some(e.clone()),\n+                _ => None,\n+            };\n+            if let Some(ast::Expr::CallExpr(call)) = e {\n+                if let Some(ast::Expr::PathExpr(p)) = call.expr() {\n+                    let res = p.path().and_then(|p| sema.resolve_path(&p));\n+                    if let Some(hir::PathResolution::Def(hir::ModuleDef::Variant(v))) = res {\n+                        return invalid |= v != some_variant;\n+                    }\n+                }\n+            }\n+            invalid = true\n+        });\n+    }\n+    invalid\n+}\n+\n+fn block_is_none_variant(\n+    sema: &Semantics<RootDatabase>,\n+    block: &ast::BlockExpr,\n+    none_variant: hir::Variant,\n+) -> bool {\n+    block.as_lone_tail().and_then(|e| match e {\n+        ast::Expr::PathExpr(pat) => match sema.resolve_path(&pat.path()?)? {\n+            hir::PathResolution::Def(hir::ModuleDef::Variant(v)) => Some(v),\n+            _ => None,\n+        },\n+        _ => None,\n+    }) == Some(none_variant)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn convert_if_to_bool_then_simple() {\n+        check_assist(\n+            convert_if_to_bool_then,\n+            r\"\n+//- minicore:option\n+fn main() {\n+    if$0 true {\n+        Some(15)\n+    } else {\n+        None\n+    }\n+}\n+\",\n+            r\"\n+fn main() {\n+    true.then(|| 15)\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_if_to_bool_then_invert() {\n+        check_assist(\n+            convert_if_to_bool_then,\n+            r\"\n+//- minicore:option\n+fn main() {\n+    if$0 true {\n+        None\n+    } else {\n+        Some(15)\n+    }\n+}\n+\",\n+            r\"\n+fn main() {\n+    false.then(|| 15)\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_if_to_bool_then_none_none() {\n+        check_assist_not_applicable(\n+            convert_if_to_bool_then,\n+            r\"\n+//- minicore:option\n+fn main() {\n+    if$0 true {\n+        None\n+    } else {\n+        None\n+    }\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_if_to_bool_then_some_some() {\n+        check_assist_not_applicable(\n+            convert_if_to_bool_then,\n+            r\"\n+//- minicore:option\n+fn main() {\n+    if$0 true {\n+        Some(15)\n+    } else {\n+        Some(15)\n+    }\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_if_to_bool_then_mixed() {\n+        check_assist_not_applicable(\n+            convert_if_to_bool_then,\n+            r\"\n+//- minicore:option\n+fn main() {\n+    if$0 true {\n+        if true {\n+            Some(15)\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_if_to_bool_then_chain() {\n+        cov_mark::check!(convert_if_to_bool_then_chain);\n+        check_assist_not_applicable(\n+            convert_if_to_bool_then,\n+            r\"\n+//- minicore:option\n+fn main() {\n+    if$0 true {\n+        Some(15)\n+    } else if true {\n+        None\n+    } else {\n+        None\n+    }\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_if_to_bool_then_pattern_cond() {\n+        check_assist_not_applicable(\n+            convert_if_to_bool_then,\n+            r\"\n+//- minicore:option\n+fn main() {\n+    if$0 let true = true {\n+        Some(15)\n+    } else {\n+        None\n+    }\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_if_to_bool_then_pattern_invalid_body() {\n+        cov_mark::check_count!(convert_if_to_bool_then_pattern_invalid_body, 2);\n+        check_assist_not_applicable(\n+            convert_if_to_bool_then,\n+            r\"\n+//- minicore:option\n+fn make_me_an_option() -> Option<i32> { None }\n+fn main() {\n+    if$0 true {\n+        if true {\n+            make_me_an_option()\n+        } else {\n+            Some(15)\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\",\n+        );\n+        check_assist_not_applicable(\n+            convert_if_to_bool_then,\n+            r\"\n+//- minicore:option\n+fn main() {\n+    if$0 true {\n+        if true {\n+            return;\n+        }\n+        Some(15)\n+    } else {\n+        None\n+    }\n+}\n+\",\n+        );\n+    }\n+}"}, {"sha": "71a200860951bd0575b9b7a8c706cd9f46a807f6", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b7c713af34e199ab125e068add4d2657180e42b/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7c713af34e199ab125e068add4d2657180e42b/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=3b7c713af34e199ab125e068add4d2657180e42b", "patch": "@@ -55,10 +55,11 @@ mod handlers {\n     mod apply_demorgan;\n     mod auto_import;\n     mod change_visibility;\n-    mod convert_integer_literal;\n+    mod convert_bool_then;\n     mod convert_comment_block;\n-    mod convert_iter_for_each_to_for;\n+    mod convert_integer_literal;\n     mod convert_into_to_from;\n+    mod convert_iter_for_each_to_for;\n     mod convert_tuple_struct_to_named_struct;\n     mod early_return;\n     mod expand_glob_import;\n@@ -73,7 +74,6 @@ mod handlers {\n     mod flip_trait_bound;\n     mod generate_default_from_enum_variant;\n     mod generate_default_from_new;\n-    mod generate_is_empty_from_len;\n     mod generate_deref;\n     mod generate_derive;\n     mod generate_enum_is_method;\n@@ -82,6 +82,7 @@ mod handlers {\n     mod generate_function;\n     mod generate_getter;\n     mod generate_impl;\n+    mod generate_is_empty_from_len;\n     mod generate_new;\n     mod generate_setter;\n     mod infer_function_return_type;\n@@ -124,10 +125,11 @@ mod handlers {\n             apply_demorgan::apply_demorgan,\n             auto_import::auto_import,\n             change_visibility::change_visibility,\n-            convert_integer_literal::convert_integer_literal,\n+            convert_bool_then::convert_if_to_bool_then,\n             convert_comment_block::convert_comment_block,\n-            convert_iter_for_each_to_for::convert_iter_for_each_to_for,\n+            convert_integer_literal::convert_integer_literal,\n             convert_into_to_from::convert_into_to_from,\n+            convert_iter_for_each_to_for::convert_iter_for_each_to_for,\n             convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n             early_return::convert_to_guarded_return,\n             expand_glob_import::expand_glob_import,"}, {"sha": "cb67b77168d8200480bcba5a2129ae7b8b639e7e", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3b7c713af34e199ab125e068add4d2657180e42b/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7c713af34e199ab125e068add4d2657180e42b/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=3b7c713af34e199ab125e068add4d2657180e42b", "patch": "@@ -191,6 +191,28 @@ pub(crate) fn frobnicate() {}\n     )\n }\n \n+#[test]\n+fn doctest_convert_if_to_bool_then() {\n+    check_doc_test(\n+        \"convert_if_to_bool_then\",\n+        r#####\"\n+//- minicore: option\n+fn main() {\n+    if$0 cond {\n+        Some(val)\n+    } else {\n+        None\n+    }\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    cond.then(|| val)\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_convert_integer_literal() {\n     check_doc_test("}, {"sha": "99ef5c264fe9b4593d097ddf237477a99e9bcd92", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b7c713af34e199ab125e068add4d2657180e42b/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7c713af34e199ab125e068add4d2657180e42b/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=3b7c713af34e199ab125e068add4d2657180e42b", "patch": "@@ -56,6 +56,10 @@ impl ast::BlockExpr {\n     pub fn is_empty(&self) -> bool {\n         self.statements().next().is_none() && self.tail_expr().is_none()\n     }\n+\n+    pub fn as_lone_tail(&self) -> Option<ast::Expr> {\n+        self.statements().next().is_none().then(|| self.tail_expr()).flatten()\n+    }\n }\n \n impl ast::Pat {"}]}