{"sha": "b86e6755b982bafc36133d9016e7d5a4cd0de0e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NmU2NzU1Yjk4MmJhZmMzNjEzM2Q5MDE2ZTdkNWE0Y2QwZGUwZTg=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-15T18:55:21Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-25T21:41:22Z"}, "message": "Add StorageDead statements for `while` conditions", "tree": {"sha": "f5b52d2ae8e1577e8f0b3a0000695444a41968b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5b52d2ae8e1577e8f0b3a0000695444a41968b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b86e6755b982bafc36133d9016e7d5a4cd0de0e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b86e6755b982bafc36133d9016e7d5a4cd0de0e8", "html_url": "https://github.com/rust-lang/rust/commit/b86e6755b982bafc36133d9016e7d5a4cd0de0e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be23bd47b771de902d6c0b79ef1dfbdb869b7109", "url": "https://api.github.com/repos/rust-lang/rust/commits/be23bd47b771de902d6c0b79ef1dfbdb869b7109", "html_url": "https://github.com/rust-lang/rust/commit/be23bd47b771de902d6c0b79ef1dfbdb869b7109"}], "stats": {"total": 300, "additions": 172, "deletions": 128}, "files": [{"sha": "0a2ea78bfd7abfe1a5aa898001299a67393993fc", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=b86e6755b982bafc36133d9016e7d5a4cd0de0e8", "patch": "@@ -179,19 +179,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         // conduct the test, if necessary\n                         let body_block;\n                         if let Some(cond_expr) = opt_cond_expr {\n-                            let loop_block_end;\n-                            let cond = unpack!(\n-                                loop_block_end = this.as_local_operand(loop_block, cond_expr)\n-                            );\n-                            body_block = this.cfg.start_new_block();\n-                            let false_block = this.cfg.start_new_block();\n-                            let term = TerminatorKind::if_(\n-                                this.hir.tcx(),\n-                                cond,\n-                                body_block,\n-                                false_block,\n-                            );\n-                            this.cfg.terminate(loop_block_end, source_info, term);\n+                            let cond_expr = this.hir.mirror(cond_expr);\n+                            let (true_block, false_block)\n+                                = this.test_bool(loop_block, cond_expr, source_info);\n+                            body_block = true_block;\n \n                             // if the test is false, there's no `break` to assign `destination`, so\n                             // we have to do it"}, {"sha": "cebfa681b5c47caea515c4df9ded2ec3032e4d3f", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=b86e6755b982bafc36133d9016e7d5a4cd0de0e8", "patch": "@@ -1490,15 +1490,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             };\n             let source_info = self.source_info(guard.span);\n             let guard_end = self.source_info(tcx.sess.source_map().end_point(guard.span));\n-            let cond = unpack!(block = self.as_local_operand(block, guard));\n+            let (post_guard_block, otherwise_post_guard_block)\n+                = self.test_bool(block, guard, source_info);\n             let guard_frame = self.guard_context.pop().unwrap();\n             debug!(\n                 \"Exiting guard building context with locals: {:?}\",\n                 guard_frame\n             );\n \n             for &(_, temp) in fake_borrows {\n-                self.cfg.push(block, Statement {\n+                self.cfg.push(post_guard_block, Statement {\n                     source_info: guard_end,\n                     kind: StatementKind::FakeRead(\n                         FakeReadCause::ForMatchGuard,\n@@ -1507,6 +1508,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 });\n             }\n \n+            self.exit_scope(\n+                source_info.span,\n+                region_scope,\n+                otherwise_post_guard_block,\n+                candidate.otherwise_block.unwrap(),\n+            );\n+\n             // We want to ensure that the matched candidates are bound\n             // after we have confirmed this candidate *and* any\n             // associated guard; Binding them on `block` is too soon,\n@@ -1533,41 +1541,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // ```\n             //\n             // and that is clearly not correct.\n-            let post_guard_block = self.cfg.start_new_block();\n-            let otherwise_post_guard_block = self.cfg.start_new_block();\n-            self.cfg.terminate(\n-                block,\n-                source_info,\n-                TerminatorKind::if_(\n-                    self.hir.tcx(),\n-                    cond.clone(),\n-                    post_guard_block,\n-                    otherwise_post_guard_block,\n-                ),\n-            );\n-\n-            self.exit_scope(\n-                source_info.span,\n-                region_scope,\n-                otherwise_post_guard_block,\n-                candidate.otherwise_block.unwrap(),\n-            );\n-\n-            if let Operand::Copy(cond_place) | Operand::Move(cond_place) = cond {\n-                if let Place::Base(PlaceBase::Local(cond_temp)) = cond_place {\n-                    // We will call `clear_top_scope` if there's another guard. So\n-                    // we have to drop this variable now or it will be \"storage\n-                    // leaked\".\n-                    self.pop_variable(\n-                        post_guard_block,\n-                        region_scope.0,\n-                        cond_temp\n-                    );\n-                } else {\n-                    bug!(\"Expected as_local_operand to produce a temporary\");\n-                }\n-            }\n-\n             let by_value_bindings = candidate.bindings.iter().filter(|binding| {\n                 if let BindingMode::ByValue = binding.binding_mode { true } else { false }\n             });\n@@ -1577,7 +1550,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let local_id = self.var_local_id(binding.var_id, RefWithinGuard);\n                     let place = Place::from(local_id);\n                 self.cfg.push(\n-                    block,\n+                    post_guard_block,\n                     Statement {\n                         source_info: guard_end,\n                         kind: StatementKind::FakeRead(FakeReadCause::ForGuardBinding, place),"}, {"sha": "ec2e970906c79515fa6b836d62f871734fa649e2", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 73, "deletions": 52, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=b86e6755b982bafc36133d9016e7d5a4cd0de0e8", "patch": "@@ -83,7 +83,7 @@ should go to.\n */\n \n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n-use crate::hair::{ExprRef, LintLevel};\n+use crate::hair::{Expr, ExprRef, LintLevel};\n use rustc::middle::region;\n use rustc::ty::Ty;\n use rustc::hir;\n@@ -829,6 +829,78 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     // Other\n     // =====\n+    /// Branch based on a boolean condition.\n+    ///\n+    /// This is a special case because the temporary for the condition needs to\n+    /// be dropped on both the true and the false arm.\n+    pub fn test_bool(\n+        &mut self,\n+        mut block: BasicBlock,\n+        condition: Expr<'tcx>,\n+        source_info: SourceInfo,\n+    ) -> (BasicBlock, BasicBlock) {\n+        let cond = unpack!(block = self.as_local_operand(block, condition));\n+        let true_block = self.cfg.start_new_block();\n+        let false_block = self.cfg.start_new_block();\n+        let term = TerminatorKind::if_(\n+            self.hir.tcx(),\n+            cond.clone(),\n+            true_block,\n+            false_block,\n+        );\n+        self.cfg.terminate(block, source_info, term);\n+\n+        match cond {\n+            // Don't try to drop a constant\n+            Operand::Constant(_) => (),\n+            // If constants and statics, we don't generate StorageLive for this\n+            // temporary, so don't try to generate StorageDead for it either.\n+            _ if self.local_scope().is_none() => (),\n+            Operand::Copy(Place::Base(PlaceBase::Local(cond_temp)))\n+            | Operand::Move(Place::Base(PlaceBase::Local(cond_temp))) => {\n+                // Manually drop the condition on both branches.\n+                let top_scope = self.scopes.scopes.last_mut().unwrap();\n+                let top_drop_data = top_scope.drops.pop().unwrap();\n+\n+                match top_drop_data.kind {\n+                    DropKind::Value { .. } => {\n+                        bug!(\"Drop scheduled on top of condition variable\")\n+                    }\n+                    DropKind::Storage => {\n+                        // Drop the storage for both value and storage drops.\n+                        // Only temps and vars need their storage dead.\n+                        match top_drop_data.location {\n+                            Place::Base(PlaceBase::Local(index)) => {\n+                                let source_info = top_scope.source_info(top_drop_data.span);\n+                                assert_eq!(index, cond_temp, \"Drop scheduled on top of condition\");\n+                                self.cfg.push(\n+                                    true_block,\n+                                    Statement {\n+                                        source_info,\n+                                        kind: StatementKind::StorageDead(index)\n+                                    },\n+                                );\n+                                self.cfg.push(\n+                                    false_block,\n+                                    Statement {\n+                                        source_info,\n+                                        kind: StatementKind::StorageDead(index)\n+                                    },\n+                                );\n+                            }\n+                            _ => unreachable!(),\n+                        }\n+                    }\n+                }\n+\n+                top_scope.invalidate_cache(true, self.is_generator, true);\n+            }\n+            _ => bug!(\"Expected as_local_operand to produce a temporary\"),\n+        }\n+\n+        (true_block, false_block)\n+    }\n+\n     /// Creates a path that performs all required cleanup for unwinding.\n     ///\n     /// This path terminates in Resume. Returns the start of the path.\n@@ -942,57 +1014,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         top_scope.drops.clear();\n         top_scope.invalidate_cache(false, self.is_generator, true);\n     }\n-\n-    /// Drops the single variable provided\n-    ///\n-    /// * The scope must be the top scope.\n-    /// * The variable must be in that scope.\n-    /// * The variable must be at the top of that scope: it's the next thing\n-    ///   scheduled to drop.\n-    /// * The drop must be of `DropKind::Storage`.\n-    ///\n-    /// This is used for the boolean holding the result of the match guard. We\n-    /// do this because:\n-    ///\n-    /// * The boolean is different for each pattern\n-    /// * There is only one exit for the arm scope\n-    /// * The guard expression scope is too short, it ends just before the\n-    ///   boolean is tested.\n-    pub(crate) fn pop_variable(\n-        &mut self,\n-        block: BasicBlock,\n-        region_scope: region::Scope,\n-        variable: Local,\n-    ) {\n-        let top_scope = self.scopes.scopes.last_mut().unwrap();\n-\n-        assert_eq!(top_scope.region_scope, region_scope);\n-\n-        let top_drop_data = top_scope.drops.pop().unwrap();\n-\n-        match top_drop_data.kind {\n-            DropKind::Value { .. } => {\n-                bug!(\"Should not be calling pop_top_variable on non-copy type!\")\n-            }\n-            DropKind::Storage => {\n-                // Drop the storage for both value and storage drops.\n-                // Only temps and vars need their storage dead.\n-                match top_drop_data.location {\n-                    Place::Base(PlaceBase::Local(index)) => {\n-                        let source_info = top_scope.source_info(top_drop_data.span);\n-                        assert_eq!(index, variable);\n-                        self.cfg.push(block, Statement {\n-                            source_info,\n-                            kind: StatementKind::StorageDead(index)\n-                        });\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            }\n-        }\n-\n-        top_scope.invalidate_cache(true, self.is_generator, true);\n-    }\n }\n \n /// Builds drops for pop_scope and exit_scope."}, {"sha": "18e0642eb34274fff3b22a1b59207119060dfbf5", "filename": "src/test/mir-opt/match-arm-scopes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs?ref=b86e6755b982bafc36133d9016e7d5a4cd0de0e8", "patch": "@@ -103,10 +103,6 @@ fn main() {\n // bb10: {                              // `else` block - first time\n //     _9 = (*_6);\n //     StorageDead(_10);\n-//     FakeRead(ForMatchGuard, _3);\n-//     FakeRead(ForMatchGuard, _4);\n-//     FakeRead(ForGuardBinding, _6);\n-//     FakeRead(ForGuardBinding, _8);\n //     switchInt(move _9) -> [false: bb16, otherwise: bb15];\n // }\n // bb11: {                              // `return 3` - first time\n@@ -128,6 +124,10 @@ fn main() {\n // }\n // bb15: {\n //     StorageDead(_9);\n+//     FakeRead(ForMatchGuard, _3);\n+//     FakeRead(ForMatchGuard, _4);\n+//     FakeRead(ForGuardBinding, _6);\n+//     FakeRead(ForGuardBinding, _8);\n //     StorageLive(_5);\n //     _5 = (_2.1: bool);\n //     StorageLive(_7);\n@@ -159,10 +159,6 @@ fn main() {\n // bb19: {                              // `else` block - second time\n //     _12 = (*_6);\n //     StorageDead(_13);\n-//     FakeRead(ForMatchGuard, _3);\n-//     FakeRead(ForMatchGuard, _4);\n-//     FakeRead(ForGuardBinding, _6);\n-//     FakeRead(ForGuardBinding, _8);\n //     switchInt(move _12) -> [false: bb22, otherwise: bb21];\n // }\n // bb20: {\n@@ -175,6 +171,10 @@ fn main() {\n // }\n // bb21: {                              // bindings for arm 1\n //     StorageDead(_12);\n+//     FakeRead(ForMatchGuard, _3);\n+//     FakeRead(ForMatchGuard, _4);\n+//     FakeRead(ForGuardBinding, _6);\n+//     FakeRead(ForGuardBinding, _8);\n //     StorageLive(_5);\n //     _5 = (_2.0: bool);\n //     StorageLive(_7);"}, {"sha": "b275c06e05cd3d6f03699feb6c51363f433d9e32", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=b86e6755b982bafc36133d9016e7d5a4cd0de0e8", "patch": "@@ -71,12 +71,12 @@ fn main() {\n //      _7 = const guard() -> [return: bb7, unwind: bb1];\n //  }\n //  bb7: { // end of guard\n-//      FakeRead(ForMatchGuard, _4);\n-//      FakeRead(ForGuardBinding, _6);\n //      switchInt(move _7) -> [false: bb9, otherwise: bb8];\n //  }\n //  bb8: { // arm1\n //      StorageDead(_7);\n+//      FakeRead(ForMatchGuard, _4);\n+//      FakeRead(ForGuardBinding, _6);\n //      StorageLive(_5);\n //      _5 = ((_2 as Some).0: i32);\n //      StorageLive(_8);\n@@ -138,12 +138,12 @@ fn main() {\n //      _7 = const guard() -> [return: bb6, unwind: bb1];\n //  }\n //  bb6: { // end of guard\n-//      FakeRead(ForMatchGuard, _4);\n-//      FakeRead(ForGuardBinding, _6);\n //      switchInt(move _7) -> [false: bb8, otherwise: bb7];\n //  }\n //  bb7: {\n //      StorageDead(_7);\n+//      FakeRead(ForMatchGuard, _4);\n+//      FakeRead(ForGuardBinding, _6);\n //      StorageLive(_5);\n //      _5 = ((_2 as Some).0: i32);\n //      StorageLive(_8);\n@@ -209,12 +209,12 @@ fn main() {\n //      _8 = const guard() -> [return: bb6, unwind: bb1];\n //  }\n //  bb6: { //end of guard1\n-//      FakeRead(ForMatchGuard, _5);\n-//      FakeRead(ForGuardBinding, _7);\n //      switchInt(move _8) -> [false: bb8, otherwise: bb7];\n //  }\n //  bb7: {\n //      StorageDead(_8);\n+//      FakeRead(ForMatchGuard, _5);\n+//      FakeRead(ForGuardBinding, _7);\n //      StorageLive(_6);\n //      _6 = ((_2 as Some).0: i32);\n //      _1 = const 1i32;\n@@ -245,12 +245,12 @@ fn main() {\n //  }\n //  bb11: { // end of guard2\n //      StorageDead(_13);\n-//      FakeRead(ForMatchGuard, _5);\n-//      FakeRead(ForGuardBinding, _11);\n //      switchInt(move _12) -> [false: bb13, otherwise: bb12];\n //  }\n //  bb12: { // binding4 & arm4\n //      StorageDead(_12);\n+//      FakeRead(ForMatchGuard, _5);\n+//      FakeRead(ForGuardBinding, _11);\n //      StorageLive(_10);\n //      _10 = ((_2 as Some).0: i32);\n //      _1 = const 3i32;"}, {"sha": "1ca75b100410b51a05b1d0d6e28364bdf4e3dbd7", "filename": "src/test/mir-opt/match_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_test.rs?ref=b86e6755b982bafc36133d9016e7d5a4cd0de0e8", "patch": "@@ -54,11 +54,11 @@ fn main() {\n //        _8 = &shallow _1;\n //        StorageLive(_9);\n //        _9 = _2;\n-//        FakeRead(ForMatchGuard, _8);\n //        switchInt(move _9) -> [false: bb11, otherwise: bb10];\n //    }\n //    bb10: {\n //        StorageDead(_9);\n+//        FakeRead(ForMatchGuard, _8);\n //        _3 = const 0i32;\n //        goto -> bb14;\n //    }"}, {"sha": "3245d38b2580bd20a03a44463524eee16b645ca9", "filename": "src/test/mir-opt/remove_fake_borrows.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs?ref=b86e6755b982bafc36133d9016e7d5a4cd0de0e8", "patch": "@@ -38,14 +38,14 @@ fn main() {\n //     _7 = &shallow (*(*((_1 as Some).0: &'<empty> &'<empty> i32)));\n //     StorageLive(_8);\n //     _8 = _2;\n-//     FakeRead(ForMatchGuard, _4);\n-//     FakeRead(ForMatchGuard, _5);\n-//     FakeRead(ForMatchGuard, _6);\n-//     FakeRead(ForMatchGuard, _7);\n //     switchInt(move _8) -> [false: bb6, otherwise: bb5];\n // }\n // bb5: {\n //     StorageDead(_8);\n+//     FakeRead(ForMatchGuard, _4);\n+//     FakeRead(ForMatchGuard, _5);\n+//     FakeRead(ForMatchGuard, _6);\n+//     FakeRead(ForMatchGuard, _7);\n //     _0 = const 0i32;\n //     goto -> bb7;\n // }\n@@ -84,14 +84,14 @@ fn main() {\n //     nop;\n //     StorageLive(_8);\n //     _8 = _2;\n-//     nop;\n-//     nop;\n-//     nop;\n-//     nop;\n //     switchInt(move _8) -> [false: bb6, otherwise: bb5];\n // }\n // bb5: {\n //     StorageDead(_8);\n+//     nop;\n+//     nop;\n+//     nop;\n+//     nop;\n //     _0 = const 0i32;\n //     goto -> bb7;\n // }"}, {"sha": "a486bd49a77d00401ac550f8e16409939aaefcfa", "filename": "src/test/mir-opt/while-storage.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Ftest%2Fmir-opt%2Fwhile-storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86e6755b982bafc36133d9016e7d5a4cd0de0e8/src%2Ftest%2Fmir-opt%2Fwhile-storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fwhile-storage.rs?ref=b86e6755b982bafc36133d9016e7d5a4cd0de0e8", "patch": "@@ -0,0 +1,59 @@\n+// Test that we correctly generate StorageDead statements for while loop\n+// conditions on all branches\n+\n+fn get_bool(c: bool) -> bool {\n+    c\n+}\n+\n+fn while_loop(c: bool) {\n+    while get_bool(c) {\n+        if get_bool(c) {\n+            break;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    while_loop(false);\n+}\n+\n+// END RUST SOURCE\n+\n+// START rustc.while_loop.PreCodegen.after.mir\n+// bb0: {\n+//     StorageLive(_2);\n+//     StorageLive(_3);\n+//     _3 = _1;\n+//     _2 = const get_bool(move _3) -> bb2;\n+// }\n+// bb1: {\n+//     return;\n+// }\n+// bb2: {\n+//     StorageDead(_3);\n+//     switchInt(move _2) -> [false: bb4, otherwise: bb3];\n+// }\n+// bb3: {\n+//     StorageDead(_2);\n+//     StorageLive(_4);\n+//     StorageLive(_5);\n+//     _5 = _1;\n+//     _4 = const get_bool(move _5) -> bb5;\n+// }\n+// bb4: {\n+//     StorageDead(_2);\n+//     goto -> bb1;\n+// }\n+// bb5: {\n+//     StorageDead(_5);\n+//     switchInt(_4) -> [false: bb6, otherwise: bb7];\n+// }\n+// bb6: {\n+//     StorageDead(_4);\n+//     goto -> bb0;\n+// }\n+// bb7: {\n+//     StorageDead(_4);\n+//     goto -> bb1;\n+// }\n+// END rustc.while_loop.PreCodegen.after.mir"}]}