{"sha": "7fc89f573dbc43ffaf09e5931661209d20208a09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmYzg5ZjU3M2RiYzQzZmZhZjA5ZTU5MzE2NjEyMDlkMjAyMDhhMDk=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-18T02:07:23Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-18T02:09:18Z"}, "message": "Restructure the \"checking\" pass in typestate\n\nI noticed that typestate was being lazier than it should be,\nbecause it was only checking typestate for statements and\ntop-level expression (that is, the expression in a stmt_expr, but\nnot any subexpressions). So I rewrote the checks in tstate/ck.rs\nto use walk, which exposed a few bugs in typestate that I fixed.\n\nAlso added some more test cases for if-check.", "tree": {"sha": "b45c61487b9dfded2964c902ba4be2a41a98083b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b45c61487b9dfded2964c902ba4be2a41a98083b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fc89f573dbc43ffaf09e5931661209d20208a09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fc89f573dbc43ffaf09e5931661209d20208a09", "html_url": "https://github.com/rust-lang/rust/commit/7fc89f573dbc43ffaf09e5931661209d20208a09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fc89f573dbc43ffaf09e5931661209d20208a09/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4eb6630f333e227da86dca4a59be218c05b719d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4eb6630f333e227da86dca4a59be218c05b719d", "html_url": "https://github.com/rust-lang/rust/commit/a4eb6630f333e227da86dca4a59be218c05b719d"}], "stats": {"total": 503, "additions": 383, "deletions": 120}, "files": [{"sha": "a1b5508e2a2d6d9f08b321f4e3a07eb206b21e26", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=7fc89f573dbc43ffaf09e5931661209d20208a09", "patch": "@@ -168,14 +168,22 @@ fn extend_poststate(&poststate p, &poststate new) -> bool {\n     ret bitv::union(p, new);\n }\n \n-\n // Clears the given bit in p\n fn relax_prestate(uint i, &prestate p) -> bool {\n     auto was_set = bitv::get(p, i);\n     bitv::set(p, i, false);\n     ret was_set;\n }\n \n+// Clears the given bit in p\n+fn relax_poststate(uint i, &poststate p) -> bool {\n+    ret relax_prestate(i, p);\n+}\n+\n+// Clears the given bit in p\n+fn relax_precond(uint i, &precond p) {\n+    relax_prestate(i, p);\n+}\n \n // Clears all the bits in p\n fn clear(&precond p) { bitv::clear(p); }"}, {"sha": "e7013752ded45337984a5d0c24e2352ca8c755df", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=7fc89f573dbc43ffaf09e5931661209d20208a09", "patch": "@@ -358,10 +358,18 @@ fn stmt_poststate(&crate_ctxt ccx, &stmt s) -> poststate {\n     ret stmt_states(ccx, s).poststate;\n }\n \n+fn block_precond(&crate_ctxt ccx, &block b) -> precond {\n+    ret block_pp(ccx, b).precondition;\n+}\n+\n fn block_postcond(&crate_ctxt ccx, &block b) -> postcond {\n     ret block_pp(ccx, b).postcondition;\n }\n \n+fn block_prestate(&crate_ctxt ccx, &block b) -> prestate {\n+    ret block_states(ccx, b).prestate;\n+}\n+\n fn block_poststate(&crate_ctxt ccx, &block b) -> poststate {\n     ret block_states(ccx, b).poststate;\n }\n@@ -402,11 +410,15 @@ fn set_pre_and_post(&crate_ctxt ccx, &ann a, &precond pre, &postcond post) {\n fn copy_pre_post(&crate_ctxt ccx, &ann a, &@expr sub) {\n     log \"set_pre_and_post\";\n     auto p = expr_pp(ccx, sub);\n-    auto t = ann_to_ts_ann(ccx, a);\n-    set_precondition(t, p.precondition);\n-    set_postcondition(t, p.postcondition);\n+    copy_pre_post_(ccx, a, p.precondition, p.postcondition);\n }\n \n+fn copy_pre_post_(&crate_ctxt ccx, &ann a, &prestate pre, &poststate post) {\n+    log \"set_pre_and_post\";\n+    auto t = ann_to_ts_ann(ccx, a);\n+    set_precondition(t, pre);\n+    set_postcondition(t, post);\n+}\n \n /* sets all bits to *1* */\n fn set_postcond_false(&crate_ctxt ccx, &ann a) {\n@@ -548,7 +560,9 @@ fn expr_to_constr_arg(ty::ctxt tcx, &@expr e) -> @constr_arg_use {\n         }\n         case (expr_lit(?l, _)) { ret @respan(e.span, carg_lit(l)); }\n         case (_) {\n-            tcx.sess.bug(\"exprs_to_constr_args: ill-formed pred arg\");\n+            tcx.sess.span_err(e.span,\n+                              \"Arguments to constrained functions must be \"\n+                              + \"literals or local variables\");\n         }\n     }\n }\n@@ -626,6 +640,11 @@ fn path_to_ident(&ty::ctxt cx, &path p) -> ident {\n         case (some(?i)) { ret i; }\n     }\n }\n+\n+tag if_ty { \n+    if_check;\n+    plain_if;\n+}\n //\n // Local Variables:\n // mode: rust"}, {"sha": "850add38d5e1be3a4753af1f3c63074d6e173a3a", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=7fc89f573dbc43ffaf09e5931661209d20208a09", "patch": "@@ -15,13 +15,21 @@ import aux::npred;\n import aux::pred_desc;\n import aux::match_args;\n import aux::constr_;\n+import aux::block_precond;\n+import aux::stmt_precond;\n+import aux::expr_precond;\n+import aux::block_prestate;\n+import aux::expr_prestate;\n+import aux::stmt_prestate;\n import tstate::aux::ann_to_ts_ann;\n import tstate::ann::pre_and_post;\n import tstate::ann::precond;\n import tstate::ann::postcond;\n import tstate::ann::prestate;\n import tstate::ann::poststate;\n import tstate::ann::relax_prestate;\n+import tstate::ann::relax_precond;\n+import tstate::ann::relax_poststate;\n import tstate::ann::pps_len;\n import tstate::ann::true_precond;\n import tstate::ann::empty_prestate;\n@@ -136,9 +144,46 @@ fn gen(&fn_ctxt fcx, &ann a, &constr_ c) -> bool {\n fn declare_var(&fn_ctxt fcx, &constr_ c, prestate pre) -> prestate {\n     auto res = clone(pre);\n     relax_prestate(bit_num(fcx, c), res);\n+    // idea is this is scoped\n+    relax_poststate(bit_num(fcx, c), res);\n     ret res;\n }\n \n+fn relax_precond_block_non_recursive(&fn_ctxt fcx, uint i, &block b) {\n+    relax_precond(i, block_precond(fcx.ccx, b));\n+}\n+\n+fn relax_precond_expr(&fn_ctxt fcx, uint i, &@expr e) {\n+    relax_precond(i, expr_precond(fcx.ccx, e));\n+}\n+\n+fn relax_precond_stmt(&fn_ctxt fcx, uint i, &@stmt s) {\n+    relax_precond(i, stmt_precond(fcx.ccx, *s));\n+}\n+\n+fn relax_precond_block(&fn_ctxt fcx, uint i, &block b) {\n+    relax_precond_block_non_recursive(fcx, i, b);\n+    // FIXME: should use visit instead\n+    // could at least generalize this pattern \n+    // (also seen in ck::check_states_against_conditions)\n+    let @mutable bool keepgoing = @mutable true;\n+\n+    fn quit(@mutable bool keepgoing, &@item i) {\n+        *keepgoing = false;\n+    }\n+    fn kg(@mutable bool keepgoing) -> bool { ret *keepgoing; }\n+\n+    auto v = rec(visit_block_pre = bind\n+                    relax_precond_block_non_recursive(fcx, i, _),\n+                 visit_expr_pre  = bind relax_precond_expr(fcx, i, _),\n+                 visit_stmt_pre  = bind relax_precond_stmt(fcx, i, _),\n+                  visit_item_pre=bind quit(keepgoing, _),\n+                  keep_going=bind kg(keepgoing)\n+\n+                   with walk::default_visitor());\n+    walk::walk_block(v, b);\n+}\n+\n fn gen_poststate(&fn_ctxt fcx, &ann a, &constr_ c) -> bool {\n     log \"gen_poststate\";\n     ret set_in_poststate(bit_num(fcx, c), ann_to_ts_ann(fcx.ccx, a).states);"}, {"sha": "ce170fb1db9e15be27392afa40c7c292b7ff67f9", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 53, "deletions": 33, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=7fc89f573dbc43ffaf09e5931661209d20208a09", "patch": "@@ -61,9 +61,19 @@ import collect_locals::mk_f_to_fn_info;\n import pre_post_conditions::fn_pre_post;\n import states::find_pre_post_state_fn;\n \n-fn check_states_expr(&fn_ctxt fcx, @expr e) {\n+fn check_states_expr(&fn_ctxt fcx, &@expr e) {\n     let precond prec = expr_precond(fcx.ccx, e);\n     let prestate pres = expr_prestate(fcx.ccx, e);\n+\n+    /*\n+    log_err(\"check_states_expr:\");\n+      util::common::log_expr_err(*e);\n+      log_err(\"prec = \");\n+      log_bitv_err(fcx, prec);\n+      log_err(\"pres = \");\n+      log_bitv_err(fcx, pres);\n+    */\n+\n     if (!implies(pres, prec)) {\n         auto s = \"\";\n         auto diff = first_difference_string(fcx, prec, pres);\n@@ -79,26 +89,27 @@ fn check_states_expr(&fn_ctxt fcx, @expr e) {\n     }\n }\n \n-fn check_states_stmt(&fn_ctxt fcx, &stmt s) {\n-    auto a = stmt_to_ann(fcx.ccx, s);\n+fn check_states_stmt(&fn_ctxt fcx, &@stmt s) {\n+    auto a = stmt_to_ann(fcx.ccx, *s);\n     let precond prec = ann_precond(a);\n     let prestate pres = ann_prestate(a);\n \n-    /*    \n+    /*\n       log_err(\"check_states_stmt:\");\n-      log_stmt_err(s);\n+      log_stmt_err(*s);\n       log_err(\"prec = \");\n-      log_bitv_err(fcx.enclosing, prec);\n+      log_bitv_err(fcx, prec);\n       log_err(\"pres = \");\n-      log_bitv_err(fcx.enclosing, pres);\n+      log_bitv_err(fcx, pres);\n     */\n+\n     if (!implies(pres, prec)) {\n         auto ss = \"\";\n         auto diff = first_difference_string(fcx, prec, pres);\n         ss +=\n             \"Unsatisfied precondition constraint (for example, \" + diff +\n                 \") for statement:\\n\";\n-        ss += pretty::pprust::stmt_to_str(s);\n+        ss += pretty::pprust::stmt_to_str(*s);\n         ss += \"\\nPrecondition:\\n\";\n         ss += bitv_to_str(fcx, prec);\n         ss += \"\\nPrestate: \\n\";\n@@ -107,42 +118,50 @@ fn check_states_stmt(&fn_ctxt fcx, &stmt s) {\n     }\n }\n \n-fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) {\n-    auto enclosing = fcx.enclosing;\n-    auto nv = num_constraints(enclosing);\n-    auto post = @mutable empty_poststate(nv);\n-    fn do_one_(fn_ctxt fcx, &@stmt s, @mutable poststate post) {\n-        check_states_stmt(fcx, *s);\n-        *post = stmt_poststate(fcx.ccx, *s);\n+fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a,\n+                                   &span sp, &ident i, &def_id d) {\n+    /* Postorder traversal instead of pre is important\n+       because we want the smallest possible erroneous statement\n+       or expression. */\n+\n+    let @mutable bool keepgoing = @mutable true;\n+    \n+    /* TODO probably should use visit instead */\n+\n+    fn quit(@mutable bool keepgoing, &@ast::item i) {\n+        *keepgoing = false;\n     }\n-    auto do_one = bind do_one_(fcx, _, post);\n-    vec::map[@stmt, ()](do_one, f.body.node.stmts);\n-    fn do_inner_(fn_ctxt fcx, &@expr e, @mutable poststate post) {\n-        check_states_expr(fcx, e);\n-        *post = expr_poststate(fcx.ccx, e);\n+    fn kg(@mutable bool keepgoing) -> bool { \n+        ret *keepgoing;\n     }\n-    auto do_inner = bind do_inner_(fcx, _, post);\n-    option::map[@expr, ()](do_inner, f.body.node.expr);\n-    auto cf = fcx.enclosing.cf;\n-    /* Finally, check that the return value is initialized */\n \n+    auto v = rec (visit_stmt_post=bind check_states_stmt(fcx, _),\n+                  visit_expr_post=bind check_states_expr(fcx, _),\n+                  visit_item_pre=bind quit(keepgoing, _),\n+                  keep_going=bind kg(keepgoing)\n+                  with walk::default_visitor());\n+\n+    walk::walk_fn(v, f, sp, i, d, a);\n+\n+    /* Finally, check that the return value is initialized */\n+    auto post = aux::block_poststate(fcx.ccx, f.body);\n     let aux::constr_ ret_c = rec(id=fcx.id, c=aux::ninit(fcx.name));\n-    if (f.proto == ast::proto_fn && !promises(fcx, { *post }, ret_c) &&\n+    if (f.proto == ast::proto_fn && !promises(fcx, post, ret_c) &&\n             !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, a)) &&\n-            cf == return) {\n+            f.decl.cf == return) {\n         fcx.ccx.tcx.sess.span_note(f.body.span,\n                                    \"In function \" + fcx.name +\n                                        \", not all control paths \\\n                                         return a value\");\n         fcx.ccx.tcx.sess.span_err(f.decl.output.span,\n                                   \"see declared return type of '\" +\n                                       ty_to_str(*f.decl.output) + \"'\");\n-    } else if (cf == noreturn) {\n+    } else if (f.decl.cf == noreturn) {\n \n         // check that this really always fails\n         // the fcx.id bit means \"returns\" for a returning fn,\n         // \"diverges\" for a non-returning fn\n-        if (!promises(fcx, { *post }, ret_c)) {\n+        if (!promises(fcx, post, ret_c)) {\n             fcx.ccx.tcx.sess.span_err(f.body.span,\n                                       \"In non-returning function \" + fcx.name\n                                           +\n@@ -152,15 +171,16 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) {\n     }\n }\n \n-fn check_fn_states(&fn_ctxt fcx, &_fn f, &ann a) {\n+fn check_fn_states(&fn_ctxt fcx, &_fn f, &ann a, &span sp, &ident i,\n+                   &def_id d) {\n     /* Compute the pre- and post-states for this function */\n \n     auto g = find_pre_post_state_fn;\n     fixed_point_states(fcx, g, f);\n     /* Now compare each expr's pre-state to its precondition\n        and post-state to its postcondition */\n \n-    check_states_against_conditions(fcx, f, a);\n+    check_states_against_conditions(fcx, f, a, sp, i, d);\n }\n \n fn fn_states(&crate_ctxt ccx, &_fn f, &span sp, &ident i, &def_id id,\n@@ -170,7 +190,7 @@ fn fn_states(&crate_ctxt ccx, &_fn f, &span sp, &ident i, &def_id id,\n     assert (ccx.fm.contains_key(id));\n     auto f_info = ccx.fm.get(id);\n     auto fcx = rec(enclosing=f_info, id=id, name=i, ccx=ccx);\n-    check_fn_states(fcx, f, a);\n+    check_fn_states(fcx, f, a, sp, i, id);\n }\n \n fn check_crate(ty::ctxt cx, @crate crate) {\n@@ -185,15 +205,15 @@ fn check_crate(ty::ctxt cx, @crate crate) {\n \n     auto do_pre_post = walk::default_visitor();\n     do_pre_post =\n-        rec(visit_fn_pre=bind fn_pre_post(ccx, _, _, _, _, _)\n+        rec(visit_fn_post=bind fn_pre_post(ccx, _, _, _, _, _)\n             with do_pre_post);\n     walk::walk_crate(do_pre_post, *crate);\n     /* Check the pre- and postcondition against the pre- and poststate\n        for every expression */\n \n     auto do_states = walk::default_visitor();\n     do_states =\n-        rec(visit_fn_pre=bind fn_states(ccx, _, _, _, _, _) with do_states);\n+        rec(visit_fn_post=bind fn_states(ccx, _, _, _, _, _) with do_states);\n     walk::walk_crate(do_states, *crate);\n }\n //"}, {"sha": "42b12323437ff8b261ea5bbd16d076a69c374c48", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 48, "deletions": 28, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=7fc89f573dbc43ffaf09e5931661209d20208a09", "patch": "@@ -32,6 +32,7 @@ import aux::clear_pp;\n import aux::clear_precond;\n import aux::set_pre_and_post;\n import aux::copy_pre_post;\n+import aux::copy_pre_post_;\n import aux::expr_precond;\n import aux::expr_postcond;\n import aux::expr_prestate;\n@@ -45,8 +46,10 @@ import aux::ann_to_ts_ann;\n import aux::set_postcond_false;\n import aux::controlflow_expr;\n import aux::expr_to_constr;\n+import aux::if_ty;\n+import aux::if_check;\n+import aux::plain_if;\n \n-//import aux::constr_to_constr_occ;\n import aux::constraints_expr;\n import aux::substitute_constr_args;\n import aux::ninit;\n@@ -55,9 +58,9 @@ import aux::path_to_ident;\n import bitvectors::seq_preconds;\n import bitvectors::union_postconds;\n import bitvectors::intersect_postconds;\n-import bitvectors::declare_var;\n import bitvectors::bit_num;\n import bitvectors::gen;\n+import bitvectors::relax_precond_block;\n import front::ast::*;\n import middle::ty::expr_ann;\n import util::common::new_def_hash;\n@@ -161,26 +164,37 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n                       &ann a) {\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n+    auto v_init = rec(id=l.node.id, c=ninit(l.node.ident));\n+    relax_precond_block(fcx, bit_num(fcx, v_init), body);\n+\n     auto loop_precond =\n-        declare_var(fcx, rec(id=l.node.id, c=ninit(l.node.ident)),\n-                    seq_preconds(fcx,\n-                                 [expr_pp(fcx.ccx, index),\n-                                  block_pp(fcx.ccx, body)]));\n+        seq_preconds(fcx,\n+                     [expr_pp(fcx.ccx, index),\n+                      block_pp(fcx.ccx, body)]);\n     auto loop_postcond =\n         intersect_postconds([expr_postcond(fcx.ccx, index),\n                              block_postcond(fcx.ccx, body)]);\n-    set_pre_and_post(fcx.ccx, a, loop_precond, loop_postcond);\n+    copy_pre_post_(fcx.ccx, a, loop_precond, loop_postcond);\n }\n \n // Generates a pre/post assuming that a is the \n // annotation for an if-expression with consequent conseq\n // and alternative maybe_alt\n fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n-                  &option::t[@expr] maybe_alt, &ann a) {\n+                  &option::t[@expr] maybe_alt, &ann a, &if_ty chck) {\n     auto num_local_vars = num_constraints(fcx.enclosing);\n+    find_pre_post_expr(fcx, antec);\n     find_pre_post_block(fcx, conseq);\n     alt (maybe_alt) {\n         case (none) {\n+            alt (chck) {\n+                case (if_check) {\n+                    let aux::constr c = expr_to_constr(fcx.ccx.tcx, antec);\n+                    gen(fcx, expr_ann(antec), c.node);\n+                }\n+                case (_) {}\n+            }\n+\n             auto precond_res =\n                 seq_preconds(fcx,\n                              [expr_pp(fcx.ccx, antec),\n@@ -189,15 +203,12 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                              expr_poststate(fcx.ccx, antec));\n         }\n         case (some(?altern)) {\n+            /*\n+              if check = if_check, then\n+              be sure that the predicate implied by antec\n+              is *not* true in the alternative\n+             */\n             find_pre_post_expr(fcx, altern);\n-            auto precond_true_case =\n-                seq_preconds(fcx,\n-                             [expr_pp(fcx.ccx, antec),\n-                              block_pp(fcx.ccx, conseq)]);\n-            auto postcond_true_case =\n-                union_postconds(num_local_vars,\n-                                [expr_postcond(fcx.ccx, antec),\n-                                 block_postcond(fcx.ccx, conseq)]);\n             auto precond_false_case =\n                 seq_preconds(fcx,\n                              [expr_pp(fcx.ccx, antec),\n@@ -206,6 +217,25 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                 union_postconds(num_local_vars,\n                                 [expr_postcond(fcx.ccx, antec),\n                                  expr_postcond(fcx.ccx, altern)]);\n+\n+            /* Be sure to set the bit for the check condition here,\n+             so that it's *not* set in the alternative. */\n+            alt (chck) {\n+                case (if_check) {\n+                    let aux::constr c = expr_to_constr(fcx.ccx.tcx, antec);\n+                    gen(fcx, expr_ann(antec), c.node);\n+                }\n+                case (_) {}\n+            }\n+            auto precond_true_case =\n+                seq_preconds(fcx,\n+                             [expr_pp(fcx.ccx, antec),\n+                              block_pp(fcx.ccx, conseq)]);\n+            auto postcond_true_case =\n+                union_postconds(num_local_vars,\n+                                [expr_postcond(fcx.ccx, antec),\n+                                 block_postcond(fcx.ccx, conseq)]);\n+\n             auto precond_res =\n                 union_postconds(num_local_vars,\n                                 [precond_true_case,\n@@ -396,8 +426,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                              false_postcond(num_local_vars));\n         }\n         case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n-            find_pre_post_expr(fcx, antec);\n-            join_then_else(fcx, antec, conseq, maybe_alt, a);\n+            join_then_else(fcx, antec, conseq, maybe_alt, a, plain_if);\n         }\n         case (expr_binary(?bop, ?l, ?r, ?a)) {\n             /* *unless* bop is lazy (e.g. and, or)? \n@@ -504,16 +533,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             gen(fcx, a, c.node);\n         }\n         case (expr_if_check(?p, ?conseq, ?maybe_alt, ?a)) {\n-            find_pre_post_expr(fcx, p);\n-            copy_pre_post(fcx.ccx, a, p);\n-            /* the typestate for the whole expression */\n-            join_then_else(fcx, p, conseq, maybe_alt, a);\n-\n-            /* predicate p holds inside the \"thn\" expression */\n-            /* (so far, the negation of p does *not* hold inside\n-             the \"elsopt\" expression) */\n-            let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n-            gen(fcx, conseq.node.a, c.node);\n+            join_then_else(fcx, p, conseq, maybe_alt, a, if_check);\n         }\n \n         case (expr_bind(?operator, ?maybe_args, ?a)) {"}, {"sha": "b7c710e85c2a11146a13753d08677901d83beb67", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 146, "deletions": 53, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=7fc89f573dbc43ffaf09e5931661209d20208a09", "patch": "@@ -32,26 +32,38 @@ import aux::stmt_pp;\n import aux::block_pp;\n import aux::set_pre_and_post;\n import aux::expr_prestate;\n+import aux::expr_precond;\n+import aux::expr_postcond;\n import aux::stmt_poststate;\n import aux::expr_poststate;\n+import aux::block_prestate;\n import aux::block_poststate;\n+import aux::block_precond;\n+import aux::block_postcond;\n import aux::fn_info;\n import aux::log_pp;\n+import aux::log_pp_err;\n import aux::extend_prestate_ann;\n import aux::extend_poststate_ann;\n import aux::set_prestate_ann;\n import aux::set_poststate_ann;\n import aux::pure_exp;\n import aux::log_bitv;\n+import aux::log_bitv_err;\n import aux::stmt_to_ann;\n import aux::log_states;\n+import aux::log_states_err;\n import aux::block_states;\n import aux::controlflow_expr;\n import aux::ann_to_def;\n import aux::expr_to_constr;\n import aux::ninit;\n import aux::npred;\n import aux::path_to_ident;\n+import aux::if_ty;\n+import aux::if_check;\n+import aux::plain_if;\n+\n import bitvectors::seq_preconds;\n import bitvectors::union_postconds;\n import bitvectors::intersect_postconds;\n@@ -69,11 +81,13 @@ import util::common::new_def_hash;\n import util::common::uistr;\n import util::common::log_expr;\n import util::common::log_block;\n+import util::common::log_block_err;\n import util::common::log_fn;\n import util::common::elt_exprs;\n import util::common::field_exprs;\n import util::common::has_nonlocal_exits;\n import util::common::log_stmt;\n+import util::common::log_stmt_err;\n import util::common::log_expr_err;\n \n fn seq_states(&fn_ctxt fcx, prestate pres, vec[@expr] exprs) ->\n@@ -111,6 +125,11 @@ fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@local l,\n     changed =\n         find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, index), body)\n             || changed;\n+\n+    if (has_nonlocal_exits(body)) { \n+        changed = set_poststate_ann(fcx.ccx, a, pres) || changed;\n+    }\n+\n     auto res_p =\n         intersect_postconds([expr_poststate(fcx.ccx, index),\n                              block_poststate(fcx.ccx, body)]);\n@@ -130,14 +149,35 @@ fn gen_if_local(&fn_ctxt fcx, &ann a_new_var, &ann a, &path p) -> bool {\n }\n \n fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n-                  &option::t[@expr] maybe_alt, &ann a) -> bool {\n+                  &option::t[@expr] maybe_alt, &ann a, &if_ty chk,\n+                  &prestate pres) -> bool {\n     auto changed = false;\n \n-    changed =\n-        find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, antec),\n-                                  conseq) || changed;\n+    changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+    changed = find_pre_post_state_expr(fcx, pres, antec) || changed;\n+    \n+    /*\n+    log_err(\"join_then_else:\");\n+    log_expr_err(*antec);\n+    log_bitv_err(fcx, expr_prestate(fcx.ccx, antec));\n+    log_bitv_err(fcx, expr_poststate(fcx.ccx, antec));\n+    log_block_err(conseq);\n+    log_bitv_err(fcx, block_prestate(fcx.ccx, conseq));\n+    log_bitv_err(fcx, block_poststate(fcx.ccx, conseq));\n+    log_err(\"****\");\n+    log_bitv_err(fcx, expr_precond(fcx.ccx, antec));\n+    log_bitv_err(fcx, expr_postcond(fcx.ccx, antec));\n+    log_bitv_err(fcx, block_precond(fcx.ccx, conseq));\n+    log_bitv_err(fcx, block_postcond(fcx.ccx, conseq));\n+    */\n+\n     alt (maybe_alt) {\n         case (none) {\n+\n+            changed =\n+                find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, antec),\n+                                  conseq) || changed;\n+   \n             changed =\n                 extend_poststate_ann(fcx.ccx, a,\n                                      expr_poststate(fcx.ccx, antec))\n@@ -149,10 +189,35 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                                          expr_poststate(fcx.ccx,\n                                                         antec),\n                                          altern) || changed;\n+\n+            auto conseq_prestate = expr_poststate(fcx.ccx, antec);\n+            alt (chk) {\n+                case (if_check) {\n+                    let aux::constr c = expr_to_constr(fcx.ccx.tcx, antec);\n+                    conseq_prestate = bitv::clone(conseq_prestate);\n+                    bitv::set(conseq_prestate, bit_num(fcx, c.node), true);\n+                }\n+                case (_) {}\n+            }\n+\n+\n+            changed =\n+                find_pre_post_state_block(fcx, conseq_prestate, conseq)\n+                || changed;\n+   \n             auto poststate_res =\n                 intersect_postconds([block_poststate(fcx.ccx, conseq),\n                                      expr_poststate(fcx.ccx,\n                                                     altern)]);\n+            /*   fcx.ccx.tcx.sess.span_note(antec.span,\n+               \"poststate_res = \" + aux::bitv_to_str(fcx, poststate_res));\n+            fcx.ccx.tcx.sess.span_note(antec.span,\n+               \"altern poststate = \" +\n+                aux::bitv_to_str(fcx, expr_poststate(fcx.ccx, altern)));\n+            fcx.ccx.tcx.sess.span_note(antec.span,\n+            \"conseq poststate = \" + aux::bitv_to_str(fcx,\n+               block_poststate(fcx.ccx, conseq))); */\n+\n             changed =\n                 extend_poststate_ann(fcx.ccx, a, poststate_res) ||\n                 changed;\n@@ -164,10 +229,10 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n     auto changed = false;\n     auto num_local_vars = num_constraints(fcx.enclosing);\n-\n-    /*  \n+    /*\n     log_err(\"states:\");\n     log_expr_err(*e);\n+    aux::log_bitv_err(fcx, expr_prestate(fcx.ccx, e));\n     aux::log_bitv_err(fcx, expr_poststate(fcx.ccx, e));\n     */\n \n@@ -182,6 +247,10 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         case (expr_call(?operator, ?operands, ?a)) {\n             /* do the prestate for the rator */\n \n+            /*            fcx.ccx.tcx.sess.span_note(operator.span, \n+                         \"pres = \" + aux::bitv_to_str(fcx, pres));\n+            */\n+\n             changed =\n                 find_pre_post_state_expr(fcx, pres, operator) || changed;\n             /* rands go left-to-right */\n@@ -201,6 +270,10 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                 }\n                 case (_) { }\n             }\n+\n+            /*            fcx.ccx.tcx.sess.span_note(operator.span, \n+               \"pres = \" + aux::bitv_to_str(fcx, expr_poststate(fcx.ccx, e)));\n+            */\n             ret changed;\n         }\n         case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n@@ -436,9 +509,8 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             ret changed;\n         }\n         case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-            changed = find_pre_post_state_expr(fcx, pres, antec) || changed;\n-            changed = join_then_else(fcx, antec, conseq, maybe_alt, a)\n+            changed = join_then_else(fcx, antec, conseq, maybe_alt, a,\n+                                     plain_if, pres)\n                 || changed;\n \n             ret changed;\n@@ -495,6 +567,12 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             changed =\n                 find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, test),\n                                           body) || changed;\n+            /* conservative approximation: if a loop contains a break\n+               or cont, we assume nothing about the poststate */\n+            if (has_nonlocal_exits(body)) { \n+                changed = set_poststate_ann(fcx.ccx, a, pres) || changed;\n+            }\n+\n             changed =\n                 {\n                     auto e_post = expr_poststate(fcx.ccx, test);\n@@ -508,22 +586,35 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         }\n         case (expr_do_while(?body, ?test, ?a)) {\n             changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            auto changed0 = changed;\n             changed = find_pre_post_state_block(fcx, pres, body) || changed;\n-            changed =\n-                find_pre_post_state_expr(fcx, block_poststate(fcx.ccx, body),\n-                                         test) || changed;\n             /* conservative approximination: if the body of the loop\n                could break or cont, we revert to the prestate\n                (TODO: could treat cont differently from break, since\n                if there's a cont, the test will execute) */\n \n-            if (has_nonlocal_exits(body)) {\n-                changed = set_poststate_ann(fcx.ccx, a, pres) || changed;\n-            } else {\n-                changed =\n-                    extend_poststate_ann(fcx.ccx, a,\n-                                         expr_poststate(fcx.ccx, test)) ||\n-                        changed;\n+            auto breaks = has_nonlocal_exits(body);\n+            if (breaks) {\n+                // this should probably be true_poststate and not pres,\n+                // b/c the body could invalidate stuff\n+                // FIXME\n+                 // This doesn't set \"changed\", as if the previous state\n+                // was different, this might come back true every time\n+                set_poststate_ann(fcx.ccx, body.node.a, pres);\n+                changed = changed0;\n+            }\n+\n+            changed =\n+                find_pre_post_state_expr(fcx, block_poststate(fcx.ccx, body),\n+                                         test) || changed;\n+\n+            if (breaks) {\n+                set_poststate_ann(fcx.ccx, a, pres);\n+            }\n+            else {\n+                changed =  extend_poststate_ann(fcx.ccx, a,\n+                                            expr_poststate(fcx.ccx, test)) ||\n+                    changed;\n             }\n             ret changed;\n         }\n@@ -605,7 +696,12 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                     || changed;\n             ret changed;\n         }\n-        case (expr_assert(?p, ?a)) { ret pure_exp(fcx.ccx, a, pres); }\n+        case (expr_assert(?p, ?a)) {\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n+            changed = extend_poststate_ann(fcx.ccx, a, pres) || changed;\n+            ret changed;\n+        }\n         case (expr_check(?p, ?a)) {\n             changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n@@ -617,13 +713,10 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             ret changed;\n         }\n         case (expr_if_check(?p, ?conseq, ?maybe_alt, ?a)) {\n-            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-            changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n-            let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n-            changed = gen_poststate(fcx, expr_ann(p), c.node) || changed;\n-            \n-            changed = join_then_else(fcx, p, conseq, maybe_alt, a)\n+            changed = join_then_else(fcx, p, conseq, maybe_alt, a, if_check,\n+                                     pres)\n                 || changed;\n+\n             ret changed;\n         }\n         case (expr_break(?a)) { ret pure_exp(fcx.ccx, a, pres); }\n@@ -651,14 +744,18 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n     auto changed = false;\n     auto stmt_ann = stmt_to_ann(fcx.ccx, *s);\n-    log \"*At beginning: stmt = \";\n-    log_stmt(*s);\n-    log \"*prestate = \";\n-    log bitv::to_str(stmt_ann.states.prestate);\n-    log \"*poststate =\";\n-    log bitv::to_str(stmt_ann.states.poststate);\n-    log \"*changed =\";\n-    log changed;\n+\n+    /*\n+    log_err \"*At beginning: stmt = \";\n+    log_stmt_err(*s);\n+    log_err \"*prestate = \";\n+    log_err bitv::to_str(stmt_ann.states.prestate);\n+    log_err \"*poststate =\";\n+    log_err bitv::to_str(stmt_ann.states.poststate);\n+    log_err \"*changed =\";\n+    log_err changed;\n+    */\n+\n     alt (s.node) {\n         case (stmt_decl(?adecl, ?a)) {\n             alt (adecl.node) {\n@@ -770,27 +867,21 @@ fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b) ->\n             post = expr_poststate(fcx.ccx, e);\n         }\n     }\n+\n+    set_prestate_ann(fcx.ccx, b.node.a, pres0);\n+    set_poststate_ann(fcx.ccx, b.node.a, post);\n+    \n     /*\n-    log_err(\"block:\");\n+    log_err \"For block:\";\n     log_block_err(b);\n-    log_err(\"has non-local exits?\");\n-    log_err(has_nonlocal_exits(b));\n+    log_err \"poststate = \";\n+    log_states_err(block_states(fcx.ccx, b));\n+    log_err \"pres0:\";\n+    log_bitv_err(fcx, pres0);\n+    log_err \"post:\";\n+    log_bitv_err(fcx, post);\n     */\n \n-    /* conservative approximation: if a block contains a break\n-       or cont, we assume nothing about the poststate */\n-\n-    if (has_nonlocal_exits(b)) { post = pres0; }\n-    set_prestate_ann(fcx.ccx, b.node.a, pres0);\n-    set_poststate_ann(fcx.ccx, b.node.a, post);\n-    log \"For block:\";\n-    log_block(b);\n-    log \"poststate = \";\n-    log_states(block_states(fcx.ccx, b));\n-    log \"pres0:\";\n-    log_bitv(fcx, pres0);\n-    log \"post:\";\n-    log_bitv(fcx, post);\n     ret changed;\n }\n \n@@ -812,8 +903,10 @@ fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n             // function with some other return type\n             if (!type_is_nil(fcx.ccx.tcx, tailty) &&\n                     !type_is_bot(fcx.ccx.tcx, tailty)) {\n-                set_poststate_ann(fcx.ccx, tailann,\n-                                  false_postcond(num_local_vars));\n+                auto p = false_postcond(num_local_vars);\n+                set_poststate_ann(fcx.ccx, tailann, p);\n+                // be sure to set the block poststate to the same thing\n+                set_poststate_ann(fcx.ccx, f.body.node.a, p);\n                 alt (fcx.enclosing.cf) {\n                     case (noreturn) {\n                         kill_poststate(fcx, tailann,"}, {"sha": "e6c93db358c7813069495045f3b3be5eae00f25c", "filename": "src/test/compile-fail/if-check-precond-fail.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs?ref=7fc89f573dbc43ffaf09e5931661209d20208a09", "patch": "@@ -0,0 +1,30 @@\n+// xfail-stage0\n+// error-pattern:Unsatisfied precondition constraint\n+pred even(uint x) -> bool {\n+  if (x < 2u) {\n+    ret false;\n+  }\n+  else if (x == 2u) {\n+    ret true;\n+  }\n+  else {\n+    ret even(x - 2u);\n+  }\n+}\n+\n+fn print_even(uint x) : even(x) {\n+  log x;\n+}\n+\n+fn foo(uint x) -> () {\n+  if check(even(x)) { \n+      fail;\n+    }\n+  else {\n+    print_even(x);\n+  }\n+}\n+\n+fn main() {\n+  foo(3u);\n+}"}, {"sha": "20a6090eb2a07442a653319935979e6fe69ac83e", "filename": "src/test/run-pass/if-check-precond.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Ftest%2Frun-pass%2Fif-check-precond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Ftest%2Frun-pass%2Fif-check-precond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fif-check-precond.rs?ref=7fc89f573dbc43ffaf09e5931661209d20208a09", "patch": "@@ -0,0 +1,29 @@\n+// xfail-stage0\n+pred even(uint x) -> bool {\n+  if (x < 2u) {\n+    ret false;\n+  }\n+  else if (x == 2u) {\n+    ret true;\n+  }\n+  else {\n+    ret even(x - 2u);\n+  }\n+}\n+\n+fn print_even(uint x) : even(x) {\n+  log x;\n+}\n+\n+fn foo(uint x) -> () {\n+  if check(even(x)) { \n+      print_even(x);\n+    }\n+  else {\n+    fail;\n+  }\n+}\n+\n+fn main() {\n+  foo(2u);\n+}"}, {"sha": "c647054abec7cfdf0b1bcfbdaada042ace1e5f7d", "filename": "src/test/run-pass/if-check.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Ftest%2Frun-pass%2Fif-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fc89f573dbc43ffaf09e5931661209d20208a09/src%2Ftest%2Frun-pass%2Fif-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fif-check.rs?ref=7fc89f573dbc43ffaf09e5931661209d20208a09", "patch": "@@ -1,5 +1,4 @@\n // xfail-stage0\n-\n pred even(uint x) -> bool {\n   if (x < 2u) {\n     ret false;"}]}