{"sha": "f89779e52fade071f2fc1227dc8113b3e44304e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4OTc3OWU1MmZhZGUwNzFmMmZjMTIyN2RjODExM2IzZTQ0MzA0ZTc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-19T13:00:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-19T13:00:57Z"}, "message": "Merge #9633\n\n9633: internal: Add `TreeId` to identify `ItemTree`s r=jonas-schievink a=jonas-schievink\n\nWith per-block `ItemTree`s, the file ID will not be enough to identify an `ItemTree`.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "ed7345c7264545cabb57f6ba870d6e8c368bd2a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed7345c7264545cabb57f6ba870d6e8c368bd2a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f89779e52fade071f2fc1227dc8113b3e44304e7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg9XeJCRBK7hj4Ov3rIwAALCYIAAiOj1EVjV2Yy72rHaiGWnUS\nwG4Iqi3cnyhKsUIpADZypymhdkj4C/3x7iK9lsf+2Lo9pXDQf/xdoquBczg9MoqV\ns1CjG1sIZdaC6YKSAeX/ixaR8mYhtjddW375H9KZBhearqXzRZUpS4w2HFibShP2\nMmWuAlEHIhA8o2g+0/X72QqlUOsp/m6YsCSK1bI/43A4JyNx6hRtnVBXcdBMLFi/\nhjEqW/epBE/Ru9/C5UBIKLjrvFStNJvD6U4bq4NdC3UKUhqhHEYwUwrkMLclUARC\nbiz4olIF9m1fgqmvuJZS7LWKDj13+9AZD1nUjbMYFanKbxdnE5+a4Y9I9MSzH5U=\n=Hp6p\n-----END PGP SIGNATURE-----\n", "payload": "tree ed7345c7264545cabb57f6ba870d6e8c368bd2a4\nparent 64bf67c5aa096eb6a059d6bb8304981ecb90318e\nparent 66311e12626f19d8b11473e0faebfa3c940200c8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1626699657 +0000\ncommitter GitHub <noreply@github.com> 1626699657 +0000\n\nMerge #9633\n\n9633: internal: Add `TreeId` to identify `ItemTree`s r=jonas-schievink a=jonas-schievink\n\nWith per-block `ItemTree`s, the file ID will not be enough to identify an `ItemTree`.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f89779e52fade071f2fc1227dc8113b3e44304e7", "html_url": "https://github.com/rust-lang/rust/commit/f89779e52fade071f2fc1227dc8113b3e44304e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f89779e52fade071f2fc1227dc8113b3e44304e7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64bf67c5aa096eb6a059d6bb8304981ecb90318e", "url": "https://api.github.com/repos/rust-lang/rust/commits/64bf67c5aa096eb6a059d6bb8304981ecb90318e", "html_url": "https://github.com/rust-lang/rust/commit/64bf67c5aa096eb6a059d6bb8304981ecb90318e"}, {"sha": "66311e12626f19d8b11473e0faebfa3c940200c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/66311e12626f19d8b11473e0faebfa3c940200c8", "html_url": "https://github.com/rust-lang/rust/commit/66311e12626f19d8b11473e0faebfa3c940200c8"}], "stats": {"total": 138, "additions": 87, "deletions": 51}, "files": [{"sha": "985aa568f22e24e67bd0c6586b76a3e614243a73", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f89779e52fade071f2fc1227dc8113b3e44304e7/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89779e52fade071f2fc1227dc8113b3e44304e7/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=f89779e52fade071f2fc1227dc8113b3e44304e7", "patch": "@@ -10,7 +10,7 @@ use crate::{\n     body::Expander,\n     db::DefDatabase,\n     intern::Interned,\n-    item_tree::{AssocItem, FnFlags, ItemTreeId, ModItem, Param},\n+    item_tree::{self, AssocItem, FnFlags, ItemTreeId, ModItem, Param},\n     type_ref::{TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n     AssocContainerId, AssocItemId, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n@@ -171,7 +171,7 @@ impl TraitData {\n             module_id,\n             &mut expander,\n             tr_def.items.iter().copied(),\n-            tr_loc.id.file_id(),\n+            tr_loc.id.tree_id(),\n             container,\n             100,\n         );\n@@ -228,7 +228,7 @@ impl ImplData {\n             module_id,\n             &mut expander,\n             impl_def.items.iter().copied(),\n-            impl_loc.id.file_id(),\n+            impl_loc.id.tree_id(),\n             container,\n             100,\n         );\n@@ -290,15 +290,15 @@ fn collect_items(\n     module: ModuleId,\n     expander: &mut Expander,\n     assoc_items: impl Iterator<Item = AssocItem>,\n-    file_id: crate::HirFileId,\n+    tree_id: item_tree::TreeId,\n     container: AssocContainerId,\n     limit: usize,\n ) -> Vec<(Name, AssocItemId)> {\n     if limit == 0 {\n         return Vec::new();\n     }\n \n-    let item_tree = db.file_item_tree(file_id);\n+    let item_tree = tree_id.item_tree(db);\n     let crate_graph = db.crate_graph();\n     let cfg_options = &crate_graph[module.krate].cfg_options;\n \n@@ -312,7 +312,7 @@ fn collect_items(\n         match item {\n             AssocItem::Function(id) => {\n                 let item = &item_tree[id];\n-                let def = FunctionLoc { container, id: ItemTreeId::new(file_id, id) }.intern(db);\n+                let def = FunctionLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(db);\n                 items.push((item.name.clone(), def.into()));\n             }\n             AssocItem::Const(id) => {\n@@ -321,33 +321,34 @@ fn collect_items(\n                     Some(name) => name,\n                     None => continue,\n                 };\n-                let def = ConstLoc { container, id: ItemTreeId::new(file_id, id) }.intern(db);\n+                let def = ConstLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(db);\n                 items.push((name, def.into()));\n             }\n             AssocItem::TypeAlias(id) => {\n                 let item = &item_tree[id];\n-                let def = TypeAliasLoc { container, id: ItemTreeId::new(file_id, id) }.intern(db);\n+                let def = TypeAliasLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(db);\n                 items.push((item.name.clone(), def.into()));\n             }\n             AssocItem::MacroCall(call) => {\n                 let call = &item_tree[call];\n-                let ast_id_map = db.ast_id_map(file_id);\n-                let root = db.parse_or_expand(file_id).unwrap();\n+                let ast_id_map = db.ast_id_map(tree_id.file_id());\n+                let root = db.parse_or_expand(tree_id.file_id()).unwrap();\n                 let call = ast_id_map.get(call.ast_id).to_node(&root);\n                 let res = expander.enter_expand(db, call);\n \n                 if let Ok(res) = res {\n                     if let Some((mark, mac)) = res.value {\n                         let src: InFile<ast::MacroItems> = expander.to_source(mac);\n-                        let item_tree = db.file_item_tree(src.file_id);\n+                        let tree_id = item_tree::TreeId::new(src.file_id, None);\n+                        let item_tree = tree_id.item_tree(db);\n                         let iter =\n                             item_tree.top_level_items().iter().filter_map(ModItem::as_assoc_item);\n                         items.extend(collect_items(\n                             db,\n                             module,\n                             expander,\n                             iter,\n-                            src.file_id,\n+                            tree_id,\n                             container,\n                             limit - 1,\n                         ));"}, {"sha": "aa462f2b97606b697c5730f063343e574cddd456", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f89779e52fade071f2fc1227dc8113b3e44304e7/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89779e52fade071f2fc1227dc8113b3e44304e7/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=f89779e52fade071f2fc1227dc8113b3e44304e7", "patch": "@@ -67,6 +67,7 @@ use crate::{\n     path::{path, AssociatedTypeBinding, GenericArgs, ImportAlias, ModPath, Path, PathKind},\n     type_ref::{Mutability, TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n+    BlockId,\n };\n \n #[derive(Copy, Clone, Eq, PartialEq)]\n@@ -374,23 +375,51 @@ impl<N: ItemTreeNode> fmt::Debug for FileItemTreeId<N> {\n     }\n }\n \n+/// Identifies a particular [`ItemTree`].\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]\n+pub struct TreeId {\n+    file: HirFileId,\n+    block: Option<BlockId>,\n+}\n+\n+impl TreeId {\n+    pub(crate) fn new(file: HirFileId, block: Option<BlockId>) -> Self {\n+        Self { file, block }\n+    }\n+\n+    pub(crate) fn item_tree(&self, db: &dyn DefDatabase) -> Arc<ItemTree> {\n+        match self.block {\n+            Some(_) => unreachable!(\"per-block ItemTrees are not yet implemented\"),\n+            None => db.file_item_tree(self.file),\n+        }\n+    }\n+\n+    pub(crate) fn file_id(self) -> HirFileId {\n+        self.file\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct ItemTreeId<N: ItemTreeNode> {\n-    file: HirFileId,\n+    tree: TreeId,\n     pub value: FileItemTreeId<N>,\n }\n \n impl<N: ItemTreeNode> ItemTreeId<N> {\n-    pub fn new(file: HirFileId, idx: FileItemTreeId<N>) -> Self {\n-        Self { file, value: idx }\n+    pub fn new(tree: TreeId, idx: FileItemTreeId<N>) -> Self {\n+        Self { tree, value: idx }\n     }\n \n     pub fn file_id(self) -> HirFileId {\n-        self.file\n+        self.tree.file\n+    }\n+\n+    pub fn tree_id(self) -> TreeId {\n+        self.tree\n     }\n \n     pub fn item_tree(self, db: &dyn DefDatabase) -> Arc<ItemTree> {\n-        db.file_item_tree(self.file)\n+        self.tree.item_tree(db)\n     }\n }\n \n@@ -403,15 +432,15 @@ impl<N: ItemTreeNode> Clone for ItemTreeId<N> {\n \n impl<N: ItemTreeNode> PartialEq for ItemTreeId<N> {\n     fn eq(&self, other: &Self) -> bool {\n-        self.file == other.file && self.value == other.value\n+        self.tree == other.tree && self.value == other.value\n     }\n }\n \n impl<N: ItemTreeNode> Eq for ItemTreeId<N> {}\n \n impl<N: ItemTreeNode> Hash for ItemTreeId<N> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.file.hash(state);\n+        self.tree.hash(state);\n         self.value.hash(state);\n     }\n }"}, {"sha": "74362bb1a4c7a8c2b490368b8b1009b7b44b0b1a", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f89779e52fade071f2fc1227dc8113b3e44304e7/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89779e52fade071f2fc1227dc8113b3e44304e7/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=f89779e52fade071f2fc1227dc8113b3e44304e7", "patch": "@@ -31,7 +31,7 @@ use crate::{\n     item_scope::{ImportType, PerNsGlobImports},\n     item_tree::{\n         self, Fields, FileItemTreeId, ImportKind, ItemTree, ItemTreeId, MacroCall, MacroDef,\n-        MacroRules, Mod, ModItem, ModKind,\n+        MacroRules, Mod, ModItem, ModKind, TreeId,\n     },\n     macro_call_as_call_id,\n     nameres::{\n@@ -311,7 +311,7 @@ impl DefCollector<'_> {\n                 def_collector: &mut *self,\n                 macro_depth: 0,\n                 module_id,\n-                file_id: file_id.into(),\n+                tree_id: TreeId::new(file_id.into(), None),\n                 item_tree: &item_tree,\n                 mod_dir: ModDir::root(),\n             }\n@@ -331,7 +331,8 @@ impl DefCollector<'_> {\n                 def_collector: &mut *self,\n                 macro_depth: 0,\n                 module_id,\n-                file_id: block.file_id,\n+                // FIXME: populate block once we have per-block ItemTrees\n+                tree_id: TreeId::new(block.file_id, None),\n                 item_tree: &item_tree,\n                 mod_dir: ModDir::root(),\n             }\n@@ -427,7 +428,7 @@ impl DefCollector<'_> {\n                     def_collector: &mut *self,\n                     macro_depth: directive.depth,\n                     module_id: directive.module_id,\n-                    file_id,\n+                    tree_id: TreeId::new(file_id, None),\n                     item_tree: &item_tree,\n                     mod_dir,\n                 }\n@@ -1066,7 +1067,7 @@ impl DefCollector<'_> {\n                                     def_collector: &mut *self,\n                                     macro_depth: directive.depth,\n                                     module_id: directive.module_id,\n-                                    file_id,\n+                                    tree_id: TreeId::new(file_id, None),\n                                     item_tree: &item_tree,\n                                     mod_dir,\n                                 }\n@@ -1113,7 +1114,7 @@ impl DefCollector<'_> {\n                                         def_collector: &mut *self,\n                                         macro_depth: directive.depth,\n                                         module_id: directive.module_id,\n-                                        file_id,\n+                                        tree_id: TreeId::new(file_id, None),\n                                         item_tree: &item_tree,\n                                         mod_dir,\n                                     }\n@@ -1200,7 +1201,7 @@ impl DefCollector<'_> {\n         ModCollector {\n             def_collector: &mut *self,\n             macro_depth: depth,\n-            file_id,\n+            tree_id: TreeId::new(file_id, None),\n             module_id,\n             item_tree: &item_tree,\n             mod_dir,\n@@ -1295,7 +1296,7 @@ struct ModCollector<'a, 'b> {\n     def_collector: &'a mut DefCollector<'b>,\n     macro_depth: usize,\n     module_id: LocalModuleId,\n-    file_id: HirFileId,\n+    tree_id: TreeId,\n     item_tree: &'a ItemTree,\n     mod_dir: ModDir,\n }\n@@ -1362,7 +1363,7 @@ impl ModCollector<'_, '_> {\n                         self.def_collector.db,\n                         krate,\n                         self.item_tree,\n-                        ItemTreeId::new(self.file_id, import_id),\n+                        ItemTreeId::new(self.tree_id, import_id),\n                     );\n                     self.def_collector.unresolved_imports.extend(imports.into_iter().map(\n                         |import| ImportDirective {\n@@ -1379,7 +1380,7 @@ impl ModCollector<'_, '_> {\n                             self.def_collector.db,\n                             krate,\n                             self.item_tree,\n-                            ItemTreeId::new(self.file_id, import_id),\n+                            ItemTreeId::new(self.tree_id, import_id),\n                         ),\n                         status: PartialResolvedImport::Unresolved,\n                     })\n@@ -1391,20 +1392,20 @@ impl ModCollector<'_, '_> {\n                 ModItem::Impl(imp) => {\n                     let module = self.def_collector.def_map.module_id(self.module_id);\n                     let impl_id =\n-                        ImplLoc { container: module, id: ItemTreeId::new(self.file_id, imp) }\n+                        ImplLoc { container: module, id: ItemTreeId::new(self.tree_id, imp) }\n                             .intern(self.def_collector.db);\n                     self.def_collector.def_map.modules[self.module_id].scope.define_impl(impl_id)\n                 }\n                 ModItem::Function(id) => {\n                     let func = &self.item_tree[id];\n \n-                    let ast_id = InFile::new(self.file_id, func.ast_id);\n+                    let ast_id = InFile::new(self.file_id(), func.ast_id);\n                     self.collect_proc_macro_def(&func.name, ast_id, &attrs);\n \n                     def = Some(DefData {\n                         id: FunctionLoc {\n                             container: module.into(),\n-                            id: ItemTreeId::new(self.file_id, id),\n+                            id: ItemTreeId::new(self.tree_id, id),\n                         }\n                         .intern(self.def_collector.db)\n                         .into(),\n@@ -1417,7 +1418,7 @@ impl ModCollector<'_, '_> {\n                     let it = &self.item_tree[id];\n \n                     def = Some(DefData {\n-                        id: StructLoc { container: module, id: ItemTreeId::new(self.file_id, id) }\n+                        id: StructLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n                             .intern(self.def_collector.db)\n                             .into(),\n                         name: &it.name,\n@@ -1429,7 +1430,7 @@ impl ModCollector<'_, '_> {\n                     let it = &self.item_tree[id];\n \n                     def = Some(DefData {\n-                        id: UnionLoc { container: module, id: ItemTreeId::new(self.file_id, id) }\n+                        id: UnionLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n                             .intern(self.def_collector.db)\n                             .into(),\n                         name: &it.name,\n@@ -1441,7 +1442,7 @@ impl ModCollector<'_, '_> {\n                     let it = &self.item_tree[id];\n \n                     def = Some(DefData {\n-                        id: EnumLoc { container: module, id: ItemTreeId::new(self.file_id, id) }\n+                        id: EnumLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n                             .intern(self.def_collector.db)\n                             .into(),\n                         name: &it.name,\n@@ -1453,7 +1454,7 @@ impl ModCollector<'_, '_> {\n                     let it = &self.item_tree[id];\n                     let const_id = ConstLoc {\n                         container: module.into(),\n-                        id: ItemTreeId::new(self.file_id, id),\n+                        id: ItemTreeId::new(self.tree_id, id),\n                     }\n                     .intern(self.def_collector.db);\n \n@@ -1478,7 +1479,7 @@ impl ModCollector<'_, '_> {\n                     let it = &self.item_tree[id];\n \n                     def = Some(DefData {\n-                        id: StaticLoc { container: module, id: ItemTreeId::new(self.file_id, id) }\n+                        id: StaticLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n                             .intern(self.def_collector.db)\n                             .into(),\n                         name: &it.name,\n@@ -1490,7 +1491,7 @@ impl ModCollector<'_, '_> {\n                     let it = &self.item_tree[id];\n \n                     def = Some(DefData {\n-                        id: TraitLoc { container: module, id: ItemTreeId::new(self.file_id, id) }\n+                        id: TraitLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n                             .intern(self.def_collector.db)\n                             .into(),\n                         name: &it.name,\n@@ -1504,7 +1505,7 @@ impl ModCollector<'_, '_> {\n                     def = Some(DefData {\n                         id: TypeAliasLoc {\n                             container: module.into(),\n-                            id: ItemTreeId::new(self.file_id, id),\n+                            id: ItemTreeId::new(self.tree_id, id),\n                         }\n                         .intern(self.def_collector.db)\n                         .into(),\n@@ -1540,7 +1541,7 @@ impl ModCollector<'_, '_> {\n             ModKind::Inline { items } => {\n                 let module_id = self.push_child_module(\n                     module.name.clone(),\n-                    AstId::new(self.file_id, module.ast_id),\n+                    AstId::new(self.file_id(), module.ast_id),\n                     None,\n                     &self.item_tree[module.visibility],\n                 );\n@@ -1551,7 +1552,7 @@ impl ModCollector<'_, '_> {\n                         def_collector: &mut *self.def_collector,\n                         macro_depth: self.macro_depth,\n                         module_id,\n-                        file_id: self.file_id,\n+                        tree_id: self.tree_id,\n                         item_tree: self.item_tree,\n                         mod_dir,\n                     }\n@@ -1563,9 +1564,10 @@ impl ModCollector<'_, '_> {\n             }\n             // out of line module, resolve, parse and recurse\n             ModKind::Outline {} => {\n-                let ast_id = AstId::new(self.file_id, module.ast_id);\n+                let ast_id = AstId::new(self.tree_id.file_id(), module.ast_id);\n                 let db = self.def_collector.db;\n-                match self.mod_dir.resolve_declaration(db, self.file_id, &module.name, path_attr) {\n+                match self.mod_dir.resolve_declaration(db, self.file_id(), &module.name, path_attr)\n+                {\n                     Ok((file_id, is_mod_rs, mod_dir)) => {\n                         let item_tree = db.file_item_tree(file_id.into());\n                         if item_tree\n@@ -1585,7 +1587,7 @@ impl ModCollector<'_, '_> {\n                                 def_collector: &mut *self.def_collector,\n                                 macro_depth: self.macro_depth,\n                                 module_id,\n-                                file_id: file_id.into(),\n+                                tree_id: TreeId::new(file_id.into(), None),\n                                 item_tree: &item_tree,\n                                 mod_dir,\n                             }\n@@ -1656,7 +1658,7 @@ impl ModCollector<'_, '_> {\n     /// assumed to be resolved already.\n     fn resolve_attributes(&mut self, attrs: &Attrs, mod_item: ModItem) -> Result<(), ()> {\n         let mut ignore_up_to =\n-            self.def_collector.skip_attrs.get(&InFile::new(self.file_id, mod_item)).copied();\n+            self.def_collector.skip_attrs.get(&InFile::new(self.file_id(), mod_item)).copied();\n         let iter = attrs\n             .iter()\n             .dedup_by(|a, b| {\n@@ -1686,7 +1688,7 @@ impl ModCollector<'_, '_> {\n                 log::debug!(\"non-builtin attribute {}\", attr.path);\n \n                 let ast_id = AstIdWithPath::new(\n-                    self.file_id,\n+                    self.file_id(),\n                     mod_item.ast_id(self.item_tree),\n                     attr.path.as_ref().clone(),\n                 );\n@@ -1749,7 +1751,7 @@ impl ModCollector<'_, '_> {\n         match attr.parse_derive() {\n             Some(derive_macros) => {\n                 for path in derive_macros {\n-                    let ast_id = AstIdWithPath::new(self.file_id, ast_id, path);\n+                    let ast_id = AstIdWithPath::new(self.file_id(), ast_id, path);\n                     self.def_collector.unresolved_macros.push(MacroDirective {\n                         module_id: self.module_id,\n                         depth: self.macro_depth + 1,\n@@ -1776,7 +1778,7 @@ impl ModCollector<'_, '_> {\n         let krate = self.def_collector.def_map.krate;\n         let mac = &self.item_tree[id];\n         let attrs = self.item_tree.attrs(self.def_collector.db, krate, ModItem::from(id).into());\n-        let ast_id = InFile::new(self.file_id, mac.ast_id.upcast());\n+        let ast_id = InFile::new(self.file_id(), mac.ast_id.upcast());\n \n         let export_attr = attrs.by_key(\"macro_export\");\n \n@@ -1841,7 +1843,7 @@ impl ModCollector<'_, '_> {\n     fn collect_macro_def(&mut self, id: FileItemTreeId<MacroDef>) {\n         let krate = self.def_collector.def_map.krate;\n         let mac = &self.item_tree[id];\n-        let ast_id = InFile::new(self.file_id, mac.ast_id.upcast());\n+        let ast_id = InFile::new(self.file_id(), mac.ast_id.upcast());\n \n         // Case 1: bulitin macros\n         let attrs = self.item_tree.attrs(self.def_collector.db, krate, ModItem::from(id).into());\n@@ -1885,7 +1887,7 @@ impl ModCollector<'_, '_> {\n     }\n \n     fn collect_macro_call(&mut self, mac: &MacroCall) {\n-        let mut ast_id = AstIdWithPath::new(self.file_id, mac.ast_id, (*mac.path).clone());\n+        let mut ast_id = AstIdWithPath::new(self.file_id(), mac.ast_id, (*mac.path).clone());\n \n         // Case 1: try to resolve in legacy scope and expand macro_rules\n         let mut error = None;\n@@ -1962,14 +1964,18 @@ impl ModCollector<'_, '_> {\n     fn emit_unconfigured_diagnostic(&mut self, item: ModItem, cfg: &CfgExpr) {\n         let ast_id = item.ast_id(self.item_tree);\n \n-        let ast_id = InFile::new(self.file_id, ast_id);\n+        let ast_id = InFile::new(self.file_id(), ast_id);\n         self.def_collector.def_map.diagnostics.push(DefDiagnostic::unconfigured_code(\n             self.module_id,\n             ast_id,\n             cfg.clone(),\n             self.def_collector.cfg_options.clone(),\n         ));\n     }\n+\n+    fn file_id(&self) -> HirFileId {\n+        self.tree_id.file_id()\n+    }\n }\n \n #[cfg(test)]"}]}