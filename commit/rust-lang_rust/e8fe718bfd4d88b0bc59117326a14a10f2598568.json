{"sha": "e8fe718bfd4d88b0bc59117326a14a10f2598568", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZmU3MThiZmQ0ZDg4YjBiYzU5MTE3MzI2YTE0YTEwZjI1OTg1Njg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-26T23:27:12Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-27T03:15:23Z"}, "message": "core: Replace map/map_default with map_ref/map_default_ref", "tree": {"sha": "5fdc1f4bfbd51f490ee30a846491f4c0e6dfac4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fdc1f4bfbd51f490ee30a846491f4c0e6dfac4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8fe718bfd4d88b0bc59117326a14a10f2598568", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8fe718bfd4d88b0bc59117326a14a10f2598568", "html_url": "https://github.com/rust-lang/rust/commit/e8fe718bfd4d88b0bc59117326a14a10f2598568", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8fe718bfd4d88b0bc59117326a14a10f2598568/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64de6d638da71f7b3a55d663b194b95f7f06d6c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/64de6d638da71f7b3a55d663b194b95f7f06d6c8", "html_url": "https://github.com/rust-lang/rust/commit/64de6d638da71f7b3a55d663b194b95f7f06d6c8"}], "stats": {"total": 176, "additions": 79, "deletions": 97}, "files": [{"sha": "264ee61018bf15ae5850744ce79bed295ecdc2b6", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -58,7 +58,7 @@ fn parse_config(args: ~[~str]) -> config {\n              } else { option::None },\n          logfile: option::map(&getopts::opt_maybe_str(matches,\n                                                      ~\"logfile\"),\n-                              |s| Path(s)),\n+                              |s| Path(*s)),\n          runtool: getopts::opt_maybe_str(matches, ~\"runtool\"),\n          rustcflags: getopts::opt_maybe_str(matches, ~\"rustcflags\"),\n          jit: getopts::opt_present(matches, ~\"jit\"),"}, {"sha": "d72a9d65e05929c9f9d0ae1fd62aa4ef3c618cd4", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -103,7 +103,7 @@ fn parse_compile_flags(line: ~str) -> Option<~str> {\n fn parse_exec_env(line: ~str) -> Option<(~str, ~str)> {\n     do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n-        let strs = str::splitn_char(nv, '=', 1u);\n+        let strs = str::splitn_char(*nv, '=', 1u);\n         match strs.len() {\n           1u => (strs[0], ~\"\"),\n           2u => (strs[0], strs[1]),"}, {"sha": "fcf8146200da5665156e06507d82067b88bcebf4", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -275,13 +275,13 @@ impl<T> DList<T> {\n     /// Remove a node from the head of the list. O(1).\n     fn pop_n() -> Option<DListNode<T>> {\n         let hd = self.peek_n();\n-        hd.map(|nobe| self.unlink(nobe));\n+        hd.map(|nobe| self.unlink(*nobe));\n         hd\n     }\n     /// Remove a node from the tail of the list. O(1).\n     fn pop_tail_n() -> Option<DListNode<T>> {\n         let tl = self.peek_tail_n();\n-        tl.map(|nobe| self.unlink(nobe));\n+        tl.map(|nobe| self.unlink(*nobe));\n         tl\n     }\n     /// Get the node at the list's head. O(1)."}, {"sha": "bc1955698fc3c6b303048ec1e0214ab6812fceb5", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -290,7 +290,7 @@ pure fn from_elem<T: Copy,BT: Buildable<T>>(n_elts: uint, t: T) -> BT {\n pure fn append<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n     lhs: IT, rhs: IT) -> BT {\n     let size_opt = lhs.size_hint().chain(\n-        |sz1| rhs.size_hint().map(|sz2| sz1+sz2));\n+        |sz1| rhs.size_hint().map(|sz2| sz1+*sz2));\n     do build_sized_opt(size_opt) |push| {\n         for lhs.each |x| { push(*x); }\n         for rhs.each |x| { push(*x); }"}, {"sha": "ae28c6db0834525c18d7a18a26489a130ec55b7a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -61,13 +61,7 @@ pure fn expect<T: Copy>(opt: &Option<T>, +reason: ~str) -> T {\n     match *opt { Some(x) => x, None => fail reason }\n }\n \n-pure fn map<T, U>(opt: &Option<T>, f: fn(T) -> U) -> Option<U> {\n-    //! Maps a `some` value from one type to another\n-\n-    match *opt { Some(x) => Some(f(x)), None => None }\n-}\n-\n-pure fn map_ref<T, U>(opt: &Option<T>, f: fn(x: &T) -> U) -> Option<U> {\n+pure fn map<T, U>(opt: &Option<T>, f: fn(x: &T) -> U) -> Option<U> {\n     //! Maps a `some` value by reference from one type to another\n \n     match *opt { Some(ref x) => Some(f(x)), None => None }\n@@ -138,14 +132,7 @@ pure fn get_default<T: Copy>(opt: &Option<T>, +def: T) -> T {\n     match *opt { Some(x) => x, None => def }\n }\n \n-pure fn map_default<T, U>(opt: &Option<T>, +def: U, f: fn(T) -> U) -> U {\n-    //! Applies a function to the contained value or returns a default\n-\n-    match *opt { None => move def, Some(t) => f(t) }\n-}\n-\n-// This should replace map_default.\n-pure fn map_default_ref<T, U>(opt: &Option<T>, +def: U,\n+pure fn map_default<T, U>(opt: &Option<T>, +def: U,\n                               f: fn(x: &T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n@@ -200,17 +187,12 @@ impl<T> Option<T> {\n      * function that returns an option.\n      */\n     pure fn chain<U>(f: fn(T) -> Option<U>) -> Option<U> { chain(&self, f) }\n-    /// Applies a function to the contained value or returns a default\n-    pure fn map_default<U>(+def: U, f: fn(T) -> U) -> U\n-        { map_default(&self, move def, f) }\n     /// Performs an operation on the contained value or does nothing\n     pure fn iter(f: fn(T)) { iter(&self, f) }\n     /// Returns true if the option equals `none`\n     pure fn is_none() -> bool { is_none(&self) }\n     /// Returns true if the option contains some value\n     pure fn is_some() -> bool { is_some(&self) }\n-    /// Maps a `some` value from one type to another\n-    pure fn map<U>(f: fn(T) -> U) -> Option<U> { map(&self, f) }\n }\n \n impl<T> &Option<T> {\n@@ -222,12 +204,12 @@ impl<T> &Option<T> {\n         chain_ref(self, f)\n     }\n     /// Applies a function to the contained value or returns a default\n-    pure fn map_default_ref<U>(+def: U, f: fn(x: &T) -> U) -> U\n-        { map_default_ref(self, move def, f) }\n+    pure fn map_default<U>(+def: U, f: fn(x: &T) -> U) -> U\n+        { map_default(self, move def, f) }\n     /// Performs an operation on the contained value by reference\n     pure fn iter_ref(f: fn(x: &T)) { iter_ref(self, f) }\n     /// Maps a `some` value from one type to another by reference\n-    pure fn map_ref<U>(f: fn(x: &T) -> U) -> Option<U> { map_ref(self, f) }\n+    pure fn map<U>(f: fn(x: &T) -> U) -> Option<U> { map(self, f) }\n     /// Gets an immutable reference to the value inside a `some`.\n     pure fn get_ref() -> &self/T { get_ref(self) }\n }"}, {"sha": "7803783ea662a3f9a52fd1062cba92aecc4c10fb", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -439,7 +439,7 @@ fn self_exe_path() -> Option<Path> {\n     }\n \n     do load_self().map |pth| {\n-        Path(pth).dir_path()\n+        Path(*pth).dir_path()\n     }\n }\n "}, {"sha": "31369c47c64c3a788754bb1d2ecf6ec133822c11", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -75,8 +75,8 @@ unsafe fn local_data_lookup<T: Owned>(\n     );\n     do map_pos.map |index| {\n         // .get() is guaranteed because of \"None { false }\" above.\n-        let (_, data_ptr, _) = (*map)[index].get();\n-        (index, data_ptr)\n+        let (_, data_ptr, _) = (*map)[*index].get();\n+        (*index, data_ptr)\n     }\n }\n \n@@ -91,7 +91,7 @@ unsafe fn local_get_helper<T: Owned>(\n         // was referenced in the local_data box, though, not here, so before\n         // overwriting the local_data_box we need to give an extra reference.\n         // We must also give an extra reference when not removing.\n-        let (index, data_ptr) = result;\n+        let (index, data_ptr) = *result;\n         let data: @T = cast::transmute(move data_ptr);\n         cast::bump_box_refcount(data);\n         if do_pop {"}, {"sha": "f25684143928d8eb7a849a152849bde59da75fb0", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -200,7 +200,7 @@ fn each_ancestor(list:        &mut AncestorList,\n         // the end of the list, which doesn't make sense to coalesce.\n         return do (**ancestors).map_default((None,false)) |ancestor_arc| {\n             // NB: Takes a lock! (this ancestor node)\n-            do access_ancestors(&ancestor_arc) |nobe| {\n+            do access_ancestors(ancestor_arc) |nobe| {\n                 // Check monotonicity\n                 assert last_generation > nobe.generation;\n                 /*##########################################################*"}, {"sha": "a0516116bdfcbf60d7bcc4ce7978d9eea7804bf2", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -969,7 +969,7 @@ pure fn find<T: Copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n  */\n pure fn find_between<T: Copy>(v: &[T], start: uint, end: uint,\n                       f: fn(T) -> bool) -> Option<T> {\n-    position_between(v, start, end, f).map(|i| v[i])\n+    position_between(v, start, end, f).map(|i| v[*i])\n }\n \n /**\n@@ -992,7 +992,7 @@ pure fn rfind<T: Copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n  */\n pure fn rfind_between<T: Copy>(v: &[T], start: uint, end: uint,\n                                f: fn(T) -> bool) -> Option<T> {\n-    rposition_between(v, start, end, f).map(|i| v[i])\n+    rposition_between(v, start, end, f).map(|i| v[*i])\n }\n \n /// Find the first index containing a matching value"}, {"sha": "1c12397568da884f84894cf2dc267a6339d39843", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -262,7 +262,7 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n     do option::iter(&sp.expn_info) |ei| {\n         let ss = option::map_default(&ei.callie.span, @~\"\",\n-                                     |span| @codemap::span_to_str(span, cm));\n+                                     |span| @codemap::span_to_str(*span, cm));\n         print_diagnostic(*ss, note,\n                          fmt!(\"in expansion of #%s\", ei.callie.name));\n         let ss = codemap::span_to_str(ei.call_site, cm);"}, {"sha": "3d9234df41e73621449b58ef07b131c7b9f16811", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -114,7 +114,7 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n              match m.node {\n                mac_invoc(pth, arg, body) => {\n                  mac_invoc(fld.fold_path(pth),\n-                           option::map(&arg, |x| fld.fold_expr(x)), body)\n+                           option::map(&arg, |x| fld.fold_expr(*x)), body)\n                }\n                mac_invoc_tt(*) => m.node,\n                mac_ellipsis => mac_ellipsis,\n@@ -243,7 +243,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                 variants: vec::map(enum_definition.variants,\n                                    |x| fld.fold_variant(*x)),\n                 common: option::map(&enum_definition.common,\n-                                    |x| fold_struct_def(x, fld))\n+                                    |x| fold_struct_def(*x, fld))\n             }), fold_ty_params(typms, fld))\n           }\n           item_class(struct_def, typms) => {\n@@ -252,7 +252,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           }\n           item_impl(tps, ifce, ty, methods) => {\n               item_impl(fold_ty_params(tps, fld),\n-                        ifce.map(|p| fold_trait_ref(p, fld)),\n+                        ifce.map(|p| fold_trait_ref(*p, fld)),\n                         fld.fold_ty(ty),\n                         vec::map(methods, |x| fld.fold_method(*x)))\n           }\n@@ -292,7 +292,7 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n         let dtor_id   = fld.new_id(dtor.node.id);\n         {node: {body: dtor_body,\n                 id: dtor_id,.. dtor.node},\n-            .. dtor}};\n+            .. *dtor}};\n     return @{\n         traits: vec::map(struct_def.traits, |p| fold_trait_ref(*p, fld)),\n         fields: vec::map(struct_def.fields, |f| fold_struct_field(*f, fld)),\n@@ -332,7 +332,7 @@ fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n     return {view_items: vec::map(b.view_items, |x| fld.fold_view_item(*x)),\n          stmts: vec::map(b.stmts, |x| fld.fold_stmt(*x)),\n-         expr: option::map(&b.expr, |x| fld.fold_expr(x)),\n+         expr: option::map(&b.expr, |x| fld.fold_expr(*x)),\n          id: fld.new_id(b.id),\n          rules: b.rules};\n }\n@@ -347,7 +347,7 @@ fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n \n fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n     return {pats: vec::map(a.pats, |x| fld.fold_pat(*x)),\n-         guard: option::map(&a.guard, |x| fld.fold_expr(x)),\n+         guard: option::map(&a.guard, |x| fld.fold_expr(*x)),\n          body: fld.fold_block(a.body)};\n }\n \n@@ -357,12 +357,12 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           pat_ident(binding_mode, pth, sub) => {\n             pat_ident(binding_mode,\n                       fld.fold_path(pth),\n-                      option::map(&sub, |x| fld.fold_pat(x)))\n+                      option::map(&sub, |x| fld.fold_pat(*x)))\n           }\n           pat_lit(e) => pat_lit(fld.fold_expr(e)),\n           pat_enum(pth, pats) => {\n               pat_enum(fld.fold_path(pth), option::map(&pats,\n-                       |pats| vec::map(pats, |x| fld.fold_pat(*x))))\n+                       |pats| vec::map(*pats, |x| fld.fold_pat(*x))))\n           }\n           pat_rec(fields, etc) => {\n             let mut fs = ~[];\n@@ -432,7 +432,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_repeat(fld.fold_expr(expr), fld.fold_expr(count), mutt),\n           expr_rec(fields, maybe_expr) => {\n             expr_rec(vec::map(fields, |x| fold_field(*x)),\n-                     option::map(&maybe_expr, |x| fld.fold_expr(x)))\n+                     option::map(&maybe_expr, |x| fld.fold_expr(*x)))\n           }\n           expr_tup(elts) => expr_tup(vec::map(elts, |x| fld.fold_expr(*x))),\n           expr_call(f, args, blk) => {\n@@ -451,14 +451,14 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_addr_of(m, ohs) => expr_addr_of(m, fld.fold_expr(ohs)),\n           expr_if(cond, tr, fl) => {\n             expr_if(fld.fold_expr(cond), fld.fold_block(tr),\n-                    option::map(&fl, |x| fld.fold_expr(x)))\n+                    option::map(&fl, |x| fld.fold_expr(*x)))\n           }\n           expr_while(cond, body) => {\n             expr_while(fld.fold_expr(cond), fld.fold_block(body))\n           }\n           expr_loop(body, opt_ident) => {\n               expr_loop(fld.fold_block(body),\n-                        option::map(&opt_ident, |x| fld.fold_ident(x)))\n+                        option::map(&opt_ident, |x| fld.fold_ident(*x)))\n           }\n           expr_match(expr, arms) => {\n             expr_match(fld.fold_expr(expr),\n@@ -500,20 +500,20 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_index(fld.fold_expr(el), fld.fold_expr(er))\n           }\n           expr_path(pth) => expr_path(fld.fold_path(pth)),\n-          expr_fail(e) => expr_fail(option::map(&e, |x| fld.fold_expr(x))),\n+          expr_fail(e) => expr_fail(option::map(&e, |x| fld.fold_expr(*x))),\n           expr_break(opt_ident) =>\n-            expr_break(option::map(&opt_ident, |x| fld.fold_ident(x))),\n+            expr_break(option::map(&opt_ident, |x| fld.fold_ident(*x))),\n           expr_again(opt_ident) =>\n-            expr_again(option::map(&opt_ident, |x| fld.fold_ident(x))),\n-          expr_ret(e) => expr_ret(option::map(&e, |x| fld.fold_expr(x))),\n+            expr_again(option::map(&opt_ident, |x| fld.fold_ident(*x))),\n+          expr_ret(e) => expr_ret(option::map(&e, |x| fld.fold_expr(*x))),\n           expr_log(i, lv, e) => expr_log(i, fld.fold_expr(lv),\n                                          fld.fold_expr(e)),\n           expr_assert(e) => expr_assert(fld.fold_expr(e)),\n           expr_mac(mac) => expr_mac(fold_mac(mac)),\n           expr_struct(path, fields, maybe_expr) => {\n             expr_struct(fld.fold_path(path),\n                         vec::map(fields, |x| fold_field(*x)),\n-                        option::map(&maybe_expr, |x| fld.fold_expr(x)))\n+                        option::map(&maybe_expr, |x| fld.fold_expr(*x)))\n           }\n         }\n }\n@@ -577,7 +577,7 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n                 let dtor_id   = fld.new_id(dtor.node.id);\n                 {node: {body: dtor_body,\n                         id: dtor_id,.. dtor.node},\n-                    .. dtor}};\n+                    .. *dtor}};\n             kind = struct_variant_kind(@{\n                 traits: ~[],\n                 fields: vec::map(struct_def.fields,\n@@ -593,7 +593,7 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n             let variants = vec::map(enum_definition.variants,\n                                     |x| fld.fold_variant(*x));\n             let common = option::map(&enum_definition.common,\n-                                     |x| fold_struct_def(x, fld));\n+                                     |x| fold_struct_def(*x, fld));\n             kind = enum_variant_kind(ast::enum_def({ variants: variants,\n                                                      common: common }));\n         }"}, {"sha": "2c04b2a14190c6a5d6b84e45abb7bb36382ae8ad", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -73,7 +73,7 @@ fn parse_crate_from_crate_file(input: &Path, cfg: ast::crate_cfg,\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n     let cx = @{sess: sess, cfg: /* FIXME (#2543) */ copy p.cfg};\n-    let companionmod = input.filestem().map(|s| Path(s));\n+    let companionmod = input.filestem().map(|s| Path(*s));\n     let (m, attrs) = eval::eval_crate_directives_to_mod(\n         cx, cdirs, &prefix, &companionmod);\n     let mut hi = p.span.hi;"}, {"sha": "f8ad6c541f640d4eba0fb9b28aa870f3032b8c17", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -2758,7 +2758,7 @@ impl parser {\n         }\n \n         let actual_dtor = do the_dtor.map |dtor| {\n-            let (d_body, d_attrs, d_s) = dtor;\n+            let (d_body, d_attrs, d_s) = *dtor;\n             {node: {id: self.get_id(),\n                     attrs: d_attrs,\n                     self_id: self.get_id(),\n@@ -3126,7 +3126,7 @@ impl parser {\n         }\n         self.bump();\n         let mut actual_dtor = do the_dtor.map |dtor| {\n-            let (d_body, d_attrs, d_s) = dtor;\n+            let (d_body, d_attrs, d_s) = *dtor;\n             {node: {id: self.get_id(),\n                     attrs: d_attrs,\n                     self_id: self.get_id(),"}, {"sha": "93ef95086101c3b5591b00f3c5a31274f0de6a07", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -395,7 +395,7 @@ fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n     match m.node {\n       ast::mac_invoc(_, arg, _) => {\n-        option::map(&arg, |arg| v.visit_expr(arg, e, v)); }\n+        option::map(&arg, |arg| v.visit_expr(*arg, e, v)); }\n       ast::mac_invoc_tt(*) => { /* no user-serviceable parts inside */ }\n       ast::mac_ellipsis => (),\n       ast::mac_aq(*) => { /* FIXME: maybe visit (Issue #2340) */ }"}, {"sha": "e389f3a4bdf7dfc3e92a390155cb0d80b6bc3dba", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -507,7 +507,7 @@ fn build_session_options(binary: ~str,\n     let extra_debuginfo = opt_present(matches, ~\"xg\");\n     let debuginfo = opt_present(matches, ~\"g\") || extra_debuginfo;\n     let sysroot_opt = getopts::opt_maybe_str(matches, ~\"sysroot\");\n-    let sysroot_opt = sysroot_opt.map(|m| Path(m));\n+    let sysroot_opt = sysroot_opt.map(|m| Path(*m));\n     let target_opt = getopts::opt_maybe_str(matches, ~\"target\");\n     let save_temps = getopts::opt_present(matches, ~\"save-temps\");\n     match output_type {"}, {"sha": "38ce7a4fbac66d548f6780312834c4369840c28c", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -172,14 +172,14 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n     let sopts = build_session_options(binary, matches, demitter);\n     let sess = build_session(sopts, demitter);\n     let odir = getopts::opt_maybe_str(matches, ~\"out-dir\");\n-    let odir = odir.map(|o| Path(o));\n+    let odir = odir.map(|o| Path(*o));\n     let ofile = getopts::opt_maybe_str(matches, ~\"o\");\n-    let ofile = ofile.map(|o| Path(o));\n+    let ofile = ofile.map(|o| Path(*o));\n     let cfg = build_configuration(sess, binary, input);\n     let pretty =\n         option::map(&getopts::opt_default(matches, ~\"pretty\",\n                                          ~\"normal\"),\n-                    |a| parse_pretty(sess, a) );\n+                    |a| parse_pretty(sess, *a) );\n     match pretty {\n       Some::<pp_mode>(ppm) => {\n         pretty_print_input(sess, cfg, input, ppm);"}, {"sha": "7e0d9ec2e8685d213e6fc4f2147d725635970f83", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -104,7 +104,7 @@ fn fold_block(cx: ctxt, b: ast::blk_, fld: fold::ast_fold) ->\n     let filtered_stmts = vec::filter_map(b.stmts, filter);\n     return {view_items: b.view_items,\n          stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(*x)),\n-         expr: option::map(&b.expr, |x| fld.fold_expr(x)),\n+         expr: option::map(&b.expr, |x| fld.fold_expr(*x)),\n          id: b.id,\n          rules: b.rules};\n }"}, {"sha": "49e79e009daf3572107a9bd9e6d128eb2e23c313", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -177,7 +177,7 @@ fn get_dep_hashes(cstore: cstore) -> ~[~str] {\n \n fn get_path(cstore: cstore, d: ast::def_id) -> ~[~str] {\n     option::map_default(&p(cstore).mod_path_map.find(d), ~[],\n-                        |ds| str::split_str(*ds, ~\"::\"))\n+                        |ds| str::split_str(**ds, ~\"::\"))\n }\n // Local Variables:\n // mode: rust"}, {"sha": "bebf8344c08567f5e7dac56c9869eebb1d8e5b40", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -196,7 +196,7 @@ fn field_mutability(d: ebml::Doc) -> ast::class_mutability {\n         &ebml::maybe_get_doc(d, tag_class_mut),\n         ast::class_immutable,\n         |d| {\n-            match ebml::doc_as_u8(d) as char {\n+            match ebml::doc_as_u8(*d) as char {\n               'm' => ast::class_mutable,\n               _   => ast::class_immutable\n             }\n@@ -246,7 +246,7 @@ fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n \n fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n     ebml::maybe_get_doc(item, tag_region_param).map(|doc| {\n-        let d = ebml::ebml_deserializer(doc);\n+        let d = ebml::ebml_deserializer(*doc);\n         ty::deserialize_region_variance(d)\n     })\n }"}, {"sha": "841d54c6b0d2ed34193de641037667a22cbb5963", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -183,7 +183,7 @@ impl check_loan_ctxt {\n         debug!(\"check_pure_callee_or_arg(pc=%?, expr=%?, \\\n                 callee_id=%d, ty=%s)\",\n                pc,\n-               opt_expr.map(|e| pprust::expr_to_str(e, tcx.sess.intr()) ),\n+               opt_expr.map(|e| pprust::expr_to_str(*e, tcx.sess.intr()) ),\n                callee_id,\n                ty_to_str(self.tcx(), ty::node_id_to_type(tcx, callee_id)));\n "}, {"sha": "ce998378fe50f846f3a3ff82b0d5791975f05039", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -659,7 +659,7 @@ impl Liveness {\n           expr_path(_) => {\n             let def = self.tcx.def_map.get(expr.id);\n             relevant_def(def).map(\n-                |rdef| self.variable_from_rdef(rdef, expr.span)\n+                |rdef| self.variable_from_rdef(*rdef, expr.span)\n             )\n           }\n           _ => None\n@@ -675,7 +675,7 @@ impl Liveness {\n         match self.tcx.def_map.find(node_id) {\n           Some(def) => {\n             relevant_def(def).map(\n-                |rdef| self.variable_from_rdef(rdef, span)\n+                |rdef| self.variable_from_rdef(*rdef, span)\n             )\n           }\n           None => {\n@@ -1396,7 +1396,7 @@ impl Liveness {\n                 // Note: the field_map is empty unless we are in a ctor\n                 return self.ir.field_map.find(fld).map(|var| {\n                     let ln = self.live_node(expr.id, expr.span);\n-                    (ln, var)\n+                    (ln, *var)\n                 });\n               }\n               _ => return None"}, {"sha": "a9f4c19576527730ea5c92967e82f56b89add991", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -612,7 +612,7 @@ impl &mem_categorization_ctxt {\n                                 cmt: cmt) -> cmt {\n         @{id: arg.id(), span: arg.span(),\n           cat: cat_comp(cmt, comp_variant(enum_did)),\n-          lp: cmt.lp.map(|l| @lp_comp(l, comp_variant(enum_did)) ),\n+          lp: cmt.lp.map(|l| @lp_comp(*l, comp_variant(enum_did)) ),\n           mutbl: cmt.mutbl, // imm iff in an immutable context\n           ty: self.tcx.ty(arg)}\n     }\n@@ -649,7 +649,7 @@ impl &mem_categorization_ctxt {\n         };\n         let m = self.inherited_mutability(base_cmt.mutbl, f_mutbl);\n         let f_comp = comp_field(f_name, f_mutbl);\n-        let lp = base_cmt.lp.map(|lp| @lp_comp(lp, f_comp) );\n+        let lp = base_cmt.lp.map(|lp| @lp_comp(*lp, f_comp) );\n         @{id: node.id(), span: node.span(),\n           cat: cat_comp(base_cmt, f_comp), lp:lp,\n           mutbl: m, ty: self.tcx.ty(node)}\n@@ -699,7 +699,7 @@ impl &mem_categorization_ctxt {\n             }\n \n             deref_comp(comp) => {\n-                let lp = base_cmt.lp.map(|l| @lp_comp(l, comp) );\n+                let lp = base_cmt.lp.map(|l| @lp_comp(*l, comp) );\n                 let m = self.inherited_mutability(base_cmt.mutbl, mt.mutbl);\n                 @{id:node.id(), span:node.span(),\n                   cat:cat_comp(base_cmt, comp), lp:lp,\n@@ -724,7 +724,7 @@ impl &mem_categorization_ctxt {\n             // (a) the contents are loanable if the base is loanable\n             // and this is a *unique* vector\n             let deref_lp = match ptr {\n-              uniq_ptr => {base_cmt.lp.map(|lp| @lp_deref(lp, uniq_ptr))}\n+              uniq_ptr => {base_cmt.lp.map(|lp| @lp_deref(*lp, uniq_ptr))}\n               _ => {None}\n             };\n \n@@ -756,7 +756,7 @@ impl &mem_categorization_ctxt {\n         fn comp(expr: @ast::expr, of_cmt: cmt,\n                 vect: ty::t, mutbl: ast::mutability, ty: ty::t) -> cmt {\n             let comp = comp_index(vect, mutbl);\n-            let index_lp = of_cmt.lp.map(|lp| @lp_comp(lp, comp) );\n+            let index_lp = of_cmt.lp.map(|lp| @lp_comp(*lp, comp) );\n             @{id:expr.id, span:expr.span,\n               cat:cat_comp(of_cmt, comp), lp:index_lp,\n               mutbl:mutbl, ty:ty}\n@@ -766,7 +766,7 @@ impl &mem_categorization_ctxt {\n     fn cat_tuple_elt<N: ast_node>(elt: N, cmt: cmt) -> cmt {\n         @{id: elt.id(), span: elt.span(),\n           cat: cat_comp(cmt, comp_tuple),\n-          lp: cmt.lp.map(|l| @lp_comp(l, comp_tuple) ),\n+          lp: cmt.lp.map(|l| @lp_comp(*l, comp_tuple) ),\n           mutbl: cmt.mutbl, // imm iff in an immutable context\n           ty: self.tcx.ty(elt)}\n     }\n@@ -958,7 +958,7 @@ impl &mem_categorization_ctxt {\n              self.cat_to_repr(cmt.cat),\n              cmt.id,\n              self.mut_to_str(cmt.mutbl),\n-             cmt.lp.map_default(~\"none\", |p| self.lp_to_str(p) ),\n+             cmt.lp.map_default(~\"none\", |p| self.lp_to_str(*p) ),\n              ty_to_str(self.tcx, cmt.ty))\n     }\n "}, {"sha": "e7b4dd171e316b4650fa5b4ad117ef7ffca79116", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -537,7 +537,7 @@ fn trans_arg_expr(bcx: block,\n             ret_flag=%?)\",\n            formal_ty.mode, bcx.ty_to_str(formal_ty.ty),\n            bcx.expr_to_str(arg_expr),\n-           ret_flag.map(|v| bcx.val_str(v)));\n+           ret_flag.map(|v| bcx.val_str(*v)));\n     let _indenter = indenter();\n \n     // translate the arg expr to a datum"}, {"sha": "6f14b22d7780fc4c4e13c1a89f609c936c6cd62e", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -1222,7 +1222,7 @@ fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n fn node_vtables(bcx: block, id: ast::node_id) -> Option<typeck::vtable_res> {\n     let raw_vtables = bcx.ccx().maps.vtable_map.find(id);\n     raw_vtables.map(\n-        |vts| meth::resolve_vtables_in_fn_ctxt(bcx.fcx, vts))\n+        |vts| meth::resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n }\n \n fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)"}, {"sha": "a8a750cd4be4091b50de83acae25188d8deb8408", "filename": "src/rustc/middle/trans/glue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -192,16 +192,16 @@ fn lazily_emit_simplified_tydesc_glue(ccx: @crate_ctxt, field: uint,\n         lazily_emit_tydesc_glue(ccx, field, simpl_ti);\n         if field == abi::tydesc_field_take_glue {\n             ti.take_glue =\n-                simpl_ti.take_glue.map(|v| cast_glue(ccx, ti, v));\n+                simpl_ti.take_glue.map(|v| cast_glue(ccx, ti, *v));\n         } else if field == abi::tydesc_field_drop_glue {\n             ti.drop_glue =\n-                simpl_ti.drop_glue.map(|v| cast_glue(ccx, ti, v));\n+                simpl_ti.drop_glue.map(|v| cast_glue(ccx, ti, *v));\n         } else if field == abi::tydesc_field_free_glue {\n             ti.free_glue =\n-                simpl_ti.free_glue.map(|v| cast_glue(ccx, ti, v));\n+                simpl_ti.free_glue.map(|v| cast_glue(ccx, ti, *v));\n         } else if field == abi::tydesc_field_visit_glue {\n             ti.visit_glue =\n-                simpl_ti.visit_glue.map(|v| cast_glue(ccx, ti, v));\n+                simpl_ti.visit_glue.map(|v| cast_glue(ccx, ti, *v));\n         }\n         return true;\n     }\n@@ -398,7 +398,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_class(did, ref substs) => {\n         // Call the dtor if there is one\n         do option::map_default(&ty::ty_dtor(bcx.tcx(), did), bcx) |dt_id| {\n-            trans_class_drop(bcx, v, dt_id, did, substs)\n+            trans_class_drop(bcx, v, *dt_id, did, substs)\n         }\n       }\n       _ => bcx"}, {"sha": "06eb26ec4e714a75b16389d36b0d7cd225308610", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -1177,7 +1177,7 @@ fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: fn(t) -> t) -> t {\n fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n     fn fold_substs(substs: &substs, fldop: fn(t) -> t) -> substs {\n         {self_r: substs.self_r,\n-         self_ty: substs.self_ty.map(|t| fldop(t)),\n+         self_ty: substs.self_ty.map(|t| fldop(*t)),\n          tps: substs.tps.map(|t| fldop(*t))}\n     }\n \n@@ -1273,8 +1273,8 @@ fn fold_regions_and_ty(\n         fldr: fn(r: region) -> region,\n         fldt: fn(t: t) -> t) -> substs {\n \n-        {self_r: substs.self_r.map(|r| fldr(r)),\n-         self_ty: substs.self_ty.map(|t| fldt(t)),\n+        {self_r: substs.self_r.map(|r| fldr(*r)),\n+         self_ty: substs.self_ty.map(|t| fldt(*t)),\n          tps: substs.tps.map(|t| fldt(*t))}\n     }\n \n@@ -1403,8 +1403,8 @@ fn substs_is_noop(substs: &substs) -> bool {\n \n fn substs_to_str(cx: ctxt, substs: &substs) -> ~str {\n     fmt!(\"substs(self_r=%s, self_ty=%s, tps=%?)\",\n-         substs.self_r.map_default(~\"none\", |r| region_to_str(cx, r)),\n-         substs.self_ty.map_default(~\"none\", |t| ty_to_str(cx, t)),\n+         substs.self_r.map_default(~\"none\", |r| region_to_str(cx, *r)),\n+         substs.self_ty.map_default(~\"none\", |t| ty_to_str(cx, *t)),\n          tys_to_str(cx, substs.tps))\n }\n "}, {"sha": "29d4e9927ff8dc84354cf2d841f3a9b6aa2ed4f1", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -37,7 +37,7 @@ fn replace_bound_regions_in_fn_ty(\n \n     debug!(\"replace_bound_regions_in_fn_ty(self_info.self_ty=%?, fn_ty=%s, \\\n                 all_tys=%?)\",\n-           self_ty.map(|t| ty_to_str(tcx, t)),\n+           self_ty.map(|t| ty_to_str(tcx, *t)),\n            ty_to_str(tcx, ty::mk_fn(tcx, *fn_ty)),\n            all_tys.map(|t| ty_to_str(tcx, *t)));\n     let _i = indenter();\n@@ -50,11 +50,11 @@ fn replace_bound_regions_in_fn_ty(\n     let t_fn = ty::fold_sty_to_ty(tcx, &ty_fn, |t| {\n         replace_bound_regions(tcx, isr, t)\n     });\n-    let t_self = self_ty.map(|t| replace_bound_regions(tcx, isr, t));\n+    let t_self = self_ty.map(|t| replace_bound_regions(tcx, isr, *t));\n \n     debug!(\"result of replace_bound_regions_in_fn_ty: self_info.self_ty=%?, \\\n                 fn_ty=%s\",\n-           t_self.map(|t| ty_to_str(tcx, t)),\n+           t_self.map(|t| ty_to_str(tcx, *t)),\n            ty_to_str(tcx, t_fn));\n \n "}, {"sha": "38ca571dae537c4dd57c787e39cd17f506db2148", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -69,7 +69,7 @@ fn fixup_substs(fcx: @fn_ctxt, expr: @ast::expr,\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx, id, substs, ty::vstore_slice(ty::re_static));\n     do fixup_ty(fcx, expr, t, is_early).map |t_f| {\n-        match ty::get(t_f).sty {\n+        match ty::get(*t_f).sty {\n           ty::ty_trait(_, substs_f, _) => substs_f,\n           _ => fail ~\"t_f should be a trait\"\n         }"}, {"sha": "c57e712c0206de5594e418dca4588732f0b85f34", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -141,7 +141,7 @@ fn config_from_opts(\n     let result = result::Ok(config);\n     let result = do result::chain(result) |config| {\n         let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n-        let output_dir = output_dir.map(|s| Path(s));\n+        let output_dir = output_dir.map(|s| Path(*s));\n         result::Ok({\n             output_dir: output_dir.get_default(config.output_dir),\n             .. config\n@@ -152,7 +152,7 @@ fn config_from_opts(\n             matches, opt_output_format());\n         do output_format.map_default(result::Ok(config))\n             |output_format| {\n-            do result::chain(parse_output_format(output_format))\n+            do result::chain(parse_output_format(*output_format))\n                 |output_format| {\n \n                 result::Ok({\n@@ -167,7 +167,7 @@ fn config_from_opts(\n             getopts::opt_maybe_str(matches, opt_output_style());\n         do output_style.map_default(result::Ok(config))\n             |output_style| {\n-            do result::chain(parse_output_style(output_style))\n+            do result::chain(parse_output_style(*output_style))\n                 |output_style| {\n                 result::Ok({\n                     output_style: output_style,"}, {"sha": "0da3491c3641c81e4cc949dd0ce9306822786fe1", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fe718bfd4d88b0bc59117326a14a10f2598568/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=e8fe718bfd4d88b0bc59117326a14a10f2598568", "patch": "@@ -32,7 +32,7 @@ fn run(\n }\n \n fn maybe_apply_op(op: Op, s: Option<~str>) -> Option<~str> {\n-    s.map(|s| op(s) )\n+    s.map(|s| op(*s) )\n }\n \n fn fold_item(fold: fold::Fold<Op>, doc: doc::ItemDoc) -> doc::ItemDoc {"}]}