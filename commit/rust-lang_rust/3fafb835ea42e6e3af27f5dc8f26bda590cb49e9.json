{"sha": "3fafb835ea42e6e3af27f5dc8f26bda590cb49e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYWZiODM1ZWE0MmU2ZTNhZjI3ZjVkYzhmMjZiZGE1OTBjYjQ5ZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-03T15:49:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-03T15:49:15Z"}, "message": "Auto merge of #1570 - RalfJung:syscalls, r=RalfJung\n\ncheck that all syscall arguments are scalars\n\n`@m-ou-se` do you think this check makes sense?\n\nThe `abi` of a layout contains everything needed for the calling convention (as far as I know), so this should ensure that all the ignored arguments are passed like integers and do not otherwise mess up argument passing.\n\nThe one thing I am not sure about is what happens when more arguments are passed than fit in registers. The `syscall` man page says that all calling conventions support at least 6 arguments, except for \"mips/o32\" where it says that\n```\n       [1] The mips/o32 system call convention passes arguments 5 through 8 on the user stack.\n```\nIf we assume that passing these extra arguments to futex is legal even with that calling convention, that would mean that those user stack arguments are just silently ignored as well, which seems plausible to me -- but I know very little about calling conventions.", "tree": {"sha": "d1b5664292961e45419f01c04f0187ecfc8d7f80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1b5664292961e45419f01c04f0187ecfc8d7f80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fafb835ea42e6e3af27f5dc8f26bda590cb49e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fafb835ea42e6e3af27f5dc8f26bda590cb49e9", "html_url": "https://github.com/rust-lang/rust/commit/3fafb835ea42e6e3af27f5dc8f26bda590cb49e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fafb835ea42e6e3af27f5dc8f26bda590cb49e9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5620ad015d66aea9fe1c13bbecb8ecf7b5e644e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5620ad015d66aea9fe1c13bbecb8ecf7b5e644e5", "html_url": "https://github.com/rust-lang/rust/commit/5620ad015d66aea9fe1c13bbecb8ecf7b5e644e5"}, {"sha": "2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156", "html_url": "https://github.com/rust-lang/rust/commit/2b2a3a0cc11c40a8fd6d8015d0b7fb11b30d8156"}], "stats": {"total": 44, "additions": 23, "deletions": 21}, "files": [{"sha": "7b417990af86754e56d2ad7396bd4d772987824b", "filename": "src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fafb835ea42e6e3af27f5dc8f26bda590cb49e9/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fafb835ea42e6e3af27f5dc8f26bda590cb49e9/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=3fafb835ea42e6e3af27f5dc8f26bda590cb49e9", "patch": "@@ -221,7 +221,7 @@ fn main() {\n                             ),\n                             FromHexError::OddLength =>\n                                 panic!(\"-Zmiri-seed should have an even number of digits\"),\n-                            err => panic!(\"Unknown error decoding -Zmiri-seed as hex: {:?}\", err),\n+                            err => panic!(\"unknown error decoding -Zmiri-seed as hex: {:?}\", err),\n                         });\n                     if seed_raw.len() > 8 {\n                         panic!(format!("}, {"sha": "04efa79b9d93fc61ff6d8e12ec3beb500650b6b2", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3fafb835ea42e6e3af27f5dc8f26bda590cb49e9/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fafb835ea42e6e3af27f5dc8f26bda590cb49e9/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=3fafb835ea42e6e3af27f5dc8f26bda590cb49e9", "patch": "@@ -113,16 +113,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Dynamically invoked syscalls\n             \"syscall\" => {\n-                // FIXME: The libc syscall() function is a variadic function.\n-                // It's valid to call it with more arguments than a syscall\n-                // needs, so none of these syscalls should use check_arg_count.\n-                // It's even valid to call it with the wrong type of arguments,\n-                // as long as they'd end up in the same place with the calling\n-                // convention used. (E.g. using a `usize` instead of a pointer.)\n-                // It's not directly clear which number, size, and type of arguments\n-                // are acceptable in which cases and which aren't. (E.g. some\n-                // types might take up the space of two registers.)\n-                // So this needs to be researched first.\n+                // The syscall variadic function is legal to call with more arguments than needed,\n+                // extra arguments are simply ignored. However, all arguments need to be scalars;\n+                // other types might be treated differently by the calling convention.\n+                for arg in args {\n+                    if !matches!(arg.layout.abi, rustc_target::abi::Abi::Scalar(_)) {\n+                        throw_ub_format!(\"`syscall` arguments must all have scalar layout, but {} does not\", arg.layout.ty);\n+                    }\n+                }\n \n                 let sys_getrandom = this\n                     .eval_libc(\"SYS_getrandom\")?\n@@ -144,22 +142,26 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n                     id if id == sys_getrandom => {\n                         // The first argument is the syscall id, so skip over it.\n-                        let &[_, ptr, len, flags] = check_arg_count(args)?;\n-                        getrandom(this, ptr, len, flags, dest)?;\n+                        if args.len() < 4 {\n+                            throw_ub_format!(\"incorrect number of arguments for `getrandom` syscall: got {}, expected at least 4\", args.len());\n+                        }\n+                        getrandom(this, args[1], args[2], args[3], dest)?;\n                     }\n                     // `statx` is used by `libstd` to retrieve metadata information on `linux`\n                     // instead of using `stat`,`lstat` or `fstat` as on `macos`.\n                     id if id == sys_statx => {\n                         // The first argument is the syscall id, so skip over it.\n-                        let &[_, dirfd, pathname, flags, mask, statxbuf] = check_arg_count(args)?;\n-                        let result = this.linux_statx(dirfd, pathname, flags, mask, statxbuf)?;\n+                        if args.len() < 6 {\n+                            throw_ub_format!(\"incorrect number of arguments for `statx` syscall: got {}, expected at least 6\", args.len());\n+                        }\n+                        let result = this.linux_statx(args[1], args[2], args[3], args[4], args[5])?;\n                         this.write_scalar(Scalar::from_machine_isize(result.into(), this), dest)?;\n                     }\n                     // `futex` is used by some synchonization primitives.\n                     id if id == sys_futex => {\n                         futex(this, args, dest)?;\n                     }\n-                    id => throw_unsup_format!(\"miri does not support syscall ID {}\", id),\n+                    id => throw_unsup_format!(\"Miri does not support syscall ID {}\", id),\n                 }\n             }\n "}, {"sha": "9d124872f5cc9b60c6d80b13e7dcf2309e8125c3", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fafb835ea42e6e3af27f5dc8f26bda590cb49e9/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fafb835ea42e6e3af27f5dc8f26bda590cb49e9/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=3fafb835ea42e6e3af27f5dc8f26bda590cb49e9", "patch": "@@ -17,8 +17,8 @@ pub fn futex<'tcx>(\n     // may or may not be left out from the `syscall()` call.\n     // Therefore we don't use `check_arg_count` here, but only check for the\n     // number of arguments to fall within a range.\n-    if !(4..=7).contains(&args.len()) {\n-        throw_ub_format!(\"incorrect number of arguments for futex syscall: got {}, expected between 4 and 7 (inclusive)\", args.len());\n+    if args.len() < 4 {\n+        throw_ub_format!(\"incorrect number of arguments for `futex` syscall: got {}, expected at least 4\", args.len());\n     }\n \n     // The first three arguments (after the syscall number itself) are the same to all futex operations:\n@@ -49,13 +49,13 @@ pub fn futex<'tcx>(\n         // or *timeout expires. `timeout == null` for an infinite timeout.\n         op if op & !futex_realtime == futex_wait => {\n             if args.len() < 5 {\n-                throw_ub_format!(\"incorrect number of arguments for FUTEX_WAIT syscall: got {}, expected at least 5\", args.len());\n+                throw_ub_format!(\"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT`: got {}, expected at least 5\", args.len());\n             }\n             let timeout = args[4];\n             let timeout_time = if this.is_null(this.read_scalar(timeout)?.check_init()?)? {\n                 None\n             } else {\n-                this.check_no_isolation(\"`syscall(SYS_FUTEX, op=FUTEX_WAIT)` with timeout\")?;\n+                this.check_no_isolation(\"`futex` syscall with `op=FUTEX_WAIT` and non-null timeout\")?;\n                 let duration = match this.read_timespec(timeout)? {\n                     Some(duration) => duration,\n                     None => {\n@@ -126,7 +126,7 @@ pub fn futex<'tcx>(\n             }\n             this.write_scalar(Scalar::from_machine_isize(n, this), dest)?;\n         }\n-        op => throw_unsup_format!(\"miri does not support SYS_futex operation {}\", op),\n+        op => throw_unsup_format!(\"Miri does not support `futex` syscall with op={}\", op),\n     }\n \n     Ok(())"}]}