{"sha": "82bb41bdab6d6d5611573883bea5779ed43ca184", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyYmI0MWJkYWI2ZDZkNTYxMTU3Mzg4M2JlYTU3NzllZDQzY2ExODQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-03-23T14:31:15Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-03-23T17:16:40Z"}, "message": "Merge branch 'master' of https://github.com/Lymia/rust into rollup", "tree": {"sha": "9e9aae42ae9d4bfbf97cc7fa263a33064e471c06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e9aae42ae9d4bfbf97cc7fa263a33064e471c06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82bb41bdab6d6d5611573883bea5779ed43ca184", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82bb41bdab6d6d5611573883bea5779ed43ca184", "html_url": "https://github.com/rust-lang/rust/commit/82bb41bdab6d6d5611573883bea5779ed43ca184", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82bb41bdab6d6d5611573883bea5779ed43ca184/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d58abe75bbb00f6cf3287a5d490afd518962ae54", "url": "https://api.github.com/repos/rust-lang/rust/commits/d58abe75bbb00f6cf3287a5d490afd518962ae54", "html_url": "https://github.com/rust-lang/rust/commit/d58abe75bbb00f6cf3287a5d490afd518962ae54"}, {"sha": "57f9c4d6d9ba7d48b9f64193dd037a54e11ef7b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/57f9c4d6d9ba7d48b9f64193dd037a54e11ef7b4", "html_url": "https://github.com/rust-lang/rust/commit/57f9c4d6d9ba7d48b9f64193dd037a54e11ef7b4"}], "stats": {"total": 664, "additions": 519, "deletions": 145}, "files": [{"sha": "d6e679bad48b75b5ff751bfff86c9f3467f5f71c", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -681,7 +681,8 @@ impl TokenTree {\n             Dollar => op!('$'),\n             Question => op!('?'),\n \n-            Ident(ident) | Lifetime(ident) => TokenNode::Term(Term(ident.name)),\n+            Ident(ident, false) | Lifetime(ident) => TokenNode::Term(Term(ident.name)),\n+            Ident(ident, true) => TokenNode::Term(Term(Symbol::intern(&format!(\"r#{}\", ident)))),\n             Literal(..) | DocComment(..) => TokenNode::Literal(self::Literal(token)),\n \n             Interpolated(_) => {\n@@ -713,8 +714,14 @@ impl TokenTree {\n             },\n             TokenNode::Term(symbol) => {\n                 let ident = ast::Ident { name: symbol.0, ctxt: self.span.0.ctxt() };\n+                let sym_str = symbol.0.as_str();\n                 let token =\n-                    if symbol.0.as_str().starts_with(\"'\") { Lifetime(ident) } else { Ident(ident) };\n+                    if sym_str.starts_with(\"'\") { Lifetime(ident) }\n+                    else if sym_str.starts_with(\"r#\") {\n+                        let name = Symbol::intern(&sym_str[2..]);\n+                        let ident = ast::Ident { name, ctxt: self.span.0.ctxt() };\n+                        Ident(ident, true)\n+                    } else { Ident(ident, false) };\n                 return TokenTree::Token(self.span.0, token).into();\n             }\n             TokenNode::Literal(token) => return TokenTree::Token(self.span.0, token.0).into(),"}, {"sha": "0b037964981c936ff6604ecec4875af797b3d228", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -318,7 +318,10 @@ fn hash_token<'a, 'gcx, W: StableHasherResult>(\n             opt_name.hash_stable(hcx, hasher);\n         }\n \n-        token::Token::Ident(ident) |\n+        token::Token::Ident(ident, is_raw) => {\n+            ident.name.hash_stable(hcx, hasher);\n+            is_raw.hash_stable(hcx, hasher);\n+        }\n         token::Token::Lifetime(ident) => ident.name.hash_stable(hcx, hasher),\n \n         token::Token::Interpolated(_) => {"}, {"sha": "37274d1fc4479f538185c0288acdcc22229e5004", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -41,13 +41,13 @@ impl<'a> AstValidator<'a> {\n                            keywords::StaticLifetime.name(),\n                            keywords::Invalid.name()];\n         if !valid_names.contains(&lifetime.ident.name) &&\n-            token::Ident(lifetime.ident.without_first_quote()).is_reserved_ident() {\n+            token::is_reserved_ident(lifetime.ident.without_first_quote()) {\n             self.err_handler().span_err(lifetime.span, \"lifetimes cannot use keyword names\");\n         }\n     }\n \n     fn check_label(&self, label: Ident, span: Span) {\n-        if token::Ident(label.without_first_quote()).is_reserved_ident() {\n+        if token::is_reserved_ident(label.without_first_quote()) {\n             self.err_handler().span_err(span, &format!(\"invalid label name `{}`\", label.name));\n         }\n     }"}, {"sha": "2cb2c76c6320b4b30a9f078e477732de83d1298d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -3206,7 +3206,7 @@ impl<'a> Resolver<'a> {\n                     // `$crate::a::b`\n                     module = Some(self.resolve_crate_root(ident.node.ctxt, true));\n                     continue\n-                } else if i == 1 && !token::Ident(ident.node).is_path_segment_keyword() {\n+                } else if i == 1 && !token::is_path_segment_keyword(ident.node) {\n                     let prev_name = path[0].node.name;\n                     if prev_name == keywords::Extern.name() ||\n                        prev_name == keywords::CrateRoot.name() &&"}, {"sha": "0692a1e0d7f8afbf396dfd48f904db4083cbcd70", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -268,7 +268,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                                 if k > 0 {\n                                     tokens.push(TokenTree::Token(path.span, Token::ModSep).into());\n                                 }\n-                                let tok = Token::Ident(segment.identifier);\n+                                let tok = Token::from_ast_ident(segment.identifier);\n                                 tokens.push(TokenTree::Token(path.span, tok).into());\n                             }\n                         }"}, {"sha": "7036bdd0e2b07f6edff00b380bca860b6751bc90", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -625,7 +625,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         } else {\n                             Some(self.resolve_crate_root(source.ctxt.modern(), false))\n                         }\n-                    } else if is_extern && !token::Ident(source).is_path_segment_keyword() {\n+                    } else if is_extern && !token::is_path_segment_keyword(source) {\n                         let crate_id =\n                             self.crate_loader.resolve_crate_from_path(source.name, directive.span);\n                         let crate_root =\n@@ -667,7 +667,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n             PathResult::Failed(span, msg, true) => {\n                 let (mut self_path, mut self_result) = (module_path.clone(), None);\n-                let is_special = |ident| token::Ident(ident).is_path_segment_keyword() &&\n+                let is_special = |ident| token::is_path_segment_keyword(ident) &&\n                                          ident.name != keywords::CrateRoot.name();\n                 if !self_path.is_empty() && !is_special(self_path[0].node) &&\n                    !(self_path.len() > 1 && is_special(self_path[1].node)) {"}, {"sha": "cfa3f5a4e0b4f259ac03990b0892c0b0822377b0", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -323,12 +323,12 @@ impl<'a> Classifier<'a> {\n             }\n \n             // Keywords are also included in the identifier set.\n-            token::Ident(ident) => {\n+            token::Ident(ident, is_raw) => {\n                 match &*ident.name.as_str() {\n-                    \"ref\" | \"mut\" => Class::RefKeyWord,\n+                    \"ref\" | \"mut\" if !is_raw => Class::RefKeyWord,\n \n-                    \"self\" |\"Self\" => Class::Self_,\n-                    \"false\" | \"true\" => Class::Bool,\n+                    \"self\" | \"Self\" => Class::Self_,\n+                    \"false\" | \"true\" if !is_raw => Class::Bool,\n \n                     \"Option\" | \"Result\" => Class::PreludeTy,\n                     \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,"}, {"sha": "a3af6b247ee2f96b463644e1737603ac23aac77a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -112,7 +112,7 @@ impl Path {\n     // or starts with something like `self`/`super`/`$crate`/etc.\n     pub fn make_root(&self) -> Option<PathSegment> {\n         if let Some(ident) = self.segments.get(0).map(|seg| seg.identifier) {\n-            if ::parse::token::Ident(ident).is_path_segment_keyword() &&\n+            if ::parse::token::is_path_segment_keyword(ident) &&\n                ident.name != keywords::Crate.name() {\n                 return None;\n             }"}, {"sha": "5954b9eb2747552aa323085bcab5222e6375ce27", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -1106,17 +1106,18 @@ impl IntType {\n \n impl MetaItem {\n     fn tokens(&self) -> TokenStream {\n-        let ident = TokenTree::Token(self.span, Token::Ident(Ident::with_empty_ctxt(self.name)));\n+        let ident = TokenTree::Token(self.span,\n+                                     Token::from_ast_ident(Ident::with_empty_ctxt(self.name)));\n         TokenStream::concat(vec![ident.into(), self.node.tokens(self.span)])\n     }\n \n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n         where I: Iterator<Item = TokenTree>,\n     {\n         let (span, name) = match tokens.next() {\n-            Some(TokenTree::Token(span, Token::Ident(ident))) => (span, ident.name),\n+            Some(TokenTree::Token(span, Token::Ident(ident, _))) => (span, ident.name),\n             Some(TokenTree::Token(_, Token::Interpolated(ref nt))) => match nt.0 {\n-                token::Nonterminal::NtIdent(ident) => (ident.span, ident.node.name),\n+                token::Nonterminal::NtIdent(ident, _) => (ident.span, ident.node.name),\n                 token::Nonterminal::NtMeta(ref meta) => return Some(meta.clone()),\n                 _ => return None,\n             },\n@@ -1269,14 +1270,14 @@ impl LitKind {\n                 \"true\"\n             } else {\n                 \"false\"\n-            }))),\n+            })), false),\n         }\n     }\n \n     fn from_token(token: Token) -> Option<LitKind> {\n         match token {\n-            Token::Ident(ident) if ident.name == \"true\" => Some(LitKind::Bool(true)),\n-            Token::Ident(ident) if ident.name == \"false\" => Some(LitKind::Bool(false)),\n+            Token::Ident(ident, false) if ident.name == \"true\" => Some(LitKind::Bool(true)),\n+            Token::Ident(ident, false) if ident.name == \"false\" => Some(LitKind::Bool(false)),\n             Token::Interpolated(ref nt) => match nt.0 {\n                 token::NtExpr(ref v) => match v.node {\n                     ExprKind::Lit(ref lit) => Some(lit.node.clone()),"}, {"sha": "aecf32ab6afb773d19b90327b934c6ee6267f5aa", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -44,7 +44,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n                                    token_tree: &[TokenTree])\n                                    -> Box<MacResult+'cx> {\n     let code = match (token_tree.len(), token_tree.get(0)) {\n-        (1, Some(&TokenTree::Token(_, token::Ident(code)))) => code,\n+        (1, Some(&TokenTree::Token(_, token::Ident(code, _)))) => code,\n         _ => unreachable!()\n     };\n \n@@ -82,10 +82,10 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n         token_tree.get(1),\n         token_tree.get(2)\n     ) {\n-        (1, Some(&TokenTree::Token(_, token::Ident(ref code))), None, None) => {\n+        (1, Some(&TokenTree::Token(_, token::Ident(ref code, _))), None, None) => {\n             (code, None)\n         },\n-        (3, Some(&TokenTree::Token(_, token::Ident(ref code))),\n+        (3, Some(&TokenTree::Token(_, token::Ident(ref code, _))),\n             Some(&TokenTree::Token(_, token::Comma)),\n             Some(&TokenTree::Token(_, token::Literal(token::StrRaw(description, _), None)))) => {\n             (code, Some(description))\n@@ -150,9 +150,9 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n     let (crate_name, name) = match (&token_tree[0], &token_tree[2]) {\n         (\n             // Crate name.\n-            &TokenTree::Token(_, token::Ident(ref crate_name)),\n+            &TokenTree::Token(_, token::Ident(ref crate_name, _)),\n             // DIAGNOSTICS ident.\n-            &TokenTree::Token(_, token::Ident(ref name))\n+            &TokenTree::Token(_, token::Ident(ref name, _))\n         ) => (*&crate_name, name),\n         _ => unreachable!()\n     };"}, {"sha": "c3ae0fd2ca863469101f8c3918228889d445383e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -229,8 +229,9 @@ impl<F> TTMacroExpander for F\n         impl Folder for AvoidInterpolatedIdents {\n             fn fold_tt(&mut self, tt: tokenstream::TokenTree) -> tokenstream::TokenTree {\n                 if let tokenstream::TokenTree::Token(_, token::Interpolated(ref nt)) = tt {\n-                    if let token::NtIdent(ident) = nt.0 {\n-                        return tokenstream::TokenTree::Token(ident.span, token::Ident(ident.node));\n+                    if let token::NtIdent(ident, is_raw) = nt.0 {\n+                        return tokenstream::TokenTree::Token(ident.span,\n+                                                             token::Ident(ident.node, is_raw));\n                     }\n                 }\n                 fold::noop_fold_tt(tt, self)"}, {"sha": "540a03ff032ffef2527e5395d99cad058fb08975", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -75,7 +75,7 @@ pub mod rt {\n \n     impl ToTokens for ast::Ident {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(DUMMY_SP, token::Ident(*self))]\n+            vec![TokenTree::Token(DUMMY_SP, Token::from_ast_ident(*self))]\n         }\n     }\n \n@@ -238,7 +238,9 @@ pub mod rt {\n                 if i > 0 {\n                     inner.push(TokenTree::Token(self.span, token::Colon).into());\n                 }\n-                inner.push(TokenTree::Token(self.span, token::Ident(segment.identifier)).into());\n+                inner.push(TokenTree::Token(\n+                    self.span, token::Token::from_ast_ident(segment.identifier)\n+                ).into());\n             }\n             inner.push(self.tokens.clone());\n \n@@ -658,10 +660,10 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         token::Literal(token::ByteStr(i), suf) => return mk_lit!(\"ByteStr\", suf, i),\n         token::Literal(token::ByteStrRaw(i, n), suf) => return mk_lit!(\"ByteStrRaw\", suf, i, n),\n \n-        token::Ident(ident) => {\n+        token::Ident(ident, is_raw) => {\n             return cx.expr_call(sp,\n                                 mk_token_path(cx, sp, \"Ident\"),\n-                                vec![mk_ident(cx, sp, ident)]);\n+                                vec![mk_ident(cx, sp, ident), cx.expr_bool(sp, is_raw)]);\n         }\n \n         token::Lifetime(ident) => {\n@@ -720,7 +722,7 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n \n fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, quoted: bool) -> Vec<ast::Stmt> {\n     match *tt {\n-        TokenTree::Token(sp, token::Ident(ident)) if quoted => {\n+        TokenTree::Token(sp, token::Ident(ident, _)) if quoted => {\n             // tt.extend($ident.to_tokens(ext_cx))\n \n             let e_to_toks ="}, {"sha": "8cb331c65da2871c5ffca5f7a7d178bff1a08c0b", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -364,8 +364,8 @@ pub fn parse_failure_msg(tok: Token) -> String {\n \n /// Perform a token equality check, ignoring syntax context (that is, an unhygienic comparison)\n fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n-    if let (Some(id1), Some(id2)) = (t1.ident(), t2.ident()) {\n-        id1.name == id2.name\n+    if let (Some((id1, is_raw1)), Some((id2, is_raw2))) = (t1.ident(), t2.ident()) {\n+        id1.name == id2.name && is_raw1 == is_raw2\n     } else if let (&token::Lifetime(id1), &token::Lifetime(id2)) = (t1, t2) {\n         id1.name == id2.name\n     } else {\n@@ -711,9 +711,10 @@ pub fn parse(\n \n /// The token is an identifier, but not `_`.\n /// We prohibit passing `_` to macros expecting `ident` for now.\n-fn get_macro_ident(token: &Token) -> Option<Ident> {\n+fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n     match *token {\n-        token::Ident(ident) if ident.name != keywords::Underscore.name() => Some(ident),\n+        token::Ident(ident, is_raw) if ident.name != keywords::Underscore.name() =>\n+            Some((ident, is_raw)),\n         _ => None,\n     }\n }\n@@ -737,7 +738,7 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n         \"ident\" => get_macro_ident(token).is_some(),\n         \"vis\" => match *token {\n             // The follow-set of :vis + \"priv\" keyword + interpolated\n-            Token::Comma | Token::Ident(_) | Token::Interpolated(_) => true,\n+            Token::Comma | Token::Ident(..) | Token::Interpolated(_) => true,\n             _ => token.can_begin_type(),\n         },\n         \"block\" => match *token {\n@@ -746,7 +747,7 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n                 token::NtItem(_)\n                 | token::NtPat(_)\n                 | token::NtTy(_)\n-                | token::NtIdent(_)\n+                | token::NtIdent(..)\n                 | token::NtMeta(_)\n                 | token::NtPath(_)\n                 | token::NtVis(_) => false, // none of these may start with '{'.\n@@ -755,15 +756,15 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n             _ => false,\n         },\n         \"path\" | \"meta\" => match *token {\n-            Token::ModSep | Token::Ident(_) => true,\n+            Token::ModSep | Token::Ident(..) => true,\n             Token::Interpolated(ref nt) => match nt.0 {\n                 token::NtPath(_) | token::NtMeta(_) => true,\n                 _ => may_be_ident(&nt.0),\n             },\n             _ => false,\n         },\n         \"pat\" => match *token {\n-            Token::Ident(_) |               // box, ref, mut, and other identifiers (can stricten)\n+            Token::Ident(..) |               // box, ref, mut, and other identifiers (can stricten)\n             Token::OpenDelim(token::Paren) |    // tuple pattern\n             Token::OpenDelim(token::Bracket) |  // slice pattern\n             Token::BinOp(token::And) |          // reference\n@@ -823,9 +824,9 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         \"expr\" => token::NtExpr(panictry!(p.parse_expr())),\n         \"ty\" => token::NtTy(panictry!(p.parse_ty())),\n         // this could be handled like a token, since it is one\n-        \"ident\" => if let Some(ident) = get_macro_ident(&p.token) {\n+        \"ident\" => if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n             p.bump();\n-            token::NtIdent(respan(p.prev_span, ident))\n+            token::NtIdent(respan(p.prev_span, ident), is_raw)\n         } else {\n             let token_str = pprust::token_to_string(&p.token);\n             p.fatal(&format!(\"expected ident, found {}\", &token_str)).emit();"}, {"sha": "10e5926eb9e36d45667f31fcb038d5e610873419", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -831,7 +831,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n             \"pat\" => match *tok {\n                 TokenTree::Token(_, ref tok) => match *tok {\n                     FatArrow | Comma | Eq | BinOp(token::Or) => Ok(true),\n-                    Ident(i) if i.name == \"if\" || i.name == \"in\" => Ok(true),\n+                    Ident(i, false) if i.name == \"if\" || i.name == \"in\" => Ok(true),\n                     _ => Ok(false)\n                 },\n                 _ => Ok(false),\n@@ -840,7 +840,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n                 TokenTree::Token(_, ref tok) => match *tok {\n                     OpenDelim(token::DelimToken::Brace) | OpenDelim(token::DelimToken::Bracket) |\n                     Comma | FatArrow | Colon | Eq | Gt | Semi | BinOp(token::Or) => Ok(true),\n-                    Ident(i) if i.name == \"as\" || i.name == \"where\" => Ok(true),\n+                    Ident(i, false) if i.name == \"as\" || i.name == \"where\" => Ok(true),\n                     _ => Ok(false)\n                 },\n                 TokenTree::MetaVarDecl(_, _, frag) if frag.name == \"block\" => Ok(true),\n@@ -860,7 +860,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n                 match *tok {\n                     TokenTree::Token(_, ref tok) => match *tok {\n                         Comma => Ok(true),\n-                        Ident(i) if i.name != \"priv\" => Ok(true),\n+                        Ident(i, is_raw) if is_raw || i.name != \"priv\" => Ok(true),\n                         ref tok => Ok(tok.can_begin_type())\n                     },\n                     TokenTree::MetaVarDecl(_, _, frag) if frag.name == \"ident\""}, {"sha": "f324edeb1178ad49db4d4fc6e9f9cda20dc56be6", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -200,7 +200,7 @@ pub fn parse(\n                 let span = match trees.next() {\n                     Some(tokenstream::TokenTree::Token(span, token::Colon)) => match trees.next() {\n                         Some(tokenstream::TokenTree::Token(end_sp, ref tok)) => match tok.ident() {\n-                            Some(kind) => {\n+                            Some((kind, _)) => {\n                                 let span = end_sp.with_lo(start_sp.lo());\n                                 result.push(TokenTree::MetaVarDecl(span, ident, kind));\n                                 continue;\n@@ -289,14 +289,14 @@ where\n             // `tree` is followed by an `ident`. This could be `$meta_var` or the `$crate` special\n             // metavariable that names the crate of the invokation.\n             Some(tokenstream::TokenTree::Token(ident_span, ref token)) if token.is_ident() => {\n-                let ident = token.ident().unwrap();\n+                let (ident, _) = token.ident().unwrap();\n                 let span = ident_span.with_lo(span.lo());\n                 if ident.name == keywords::Crate.name() {\n                     let ident = ast::Ident {\n                         name: keywords::DollarCrate.name(),\n                         ..ident\n                     };\n-                    TokenTree::Token(span, token::Ident(ident))\n+                    TokenTree::Token(span, token::Ident(ident, false))\n                 } else {\n                     TokenTree::MetaVar(span, ident)\n                 }"}, {"sha": "3f01d5ec6dd876e1117ea9c030206968d1f3ffbc", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -169,7 +169,7 @@ pub fn transcribe(cx: &ExtCtxt,\n                         Ident { ctxt: ident.ctxt.apply_mark(cx.current_expansion.mark), ..ident };\n                     sp = sp.with_ctxt(sp.ctxt().apply_mark(cx.current_expansion.mark));\n                     result.push(TokenTree::Token(sp, token::Dollar).into());\n-                    result.push(TokenTree::Token(sp, token::Ident(ident)).into());\n+                    result.push(TokenTree::Token(sp, token::Token::from_ast_ident(ident)).into());\n                 }\n             }\n             quoted::TokenTree::Delimited(mut span, delimited) => {"}, {"sha": "f6403def83b10c064423aba41a3bceb27b8be140", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -457,6 +457,9 @@ declare_features! (\n \n     // The #![wasm_import_module] attribute\n     (active, wasm_import_module, \"1.26.0\", None, None),\n+\n+    // Allows keywords to be escaped for use as identifiers\n+    (active, raw_identifiers, \"1.26.0\", Some(48589), None),\n );\n \n declare_features! (\n@@ -1941,6 +1944,17 @@ pub fn check_crate(krate: &ast::Crate,\n         parse_sess: sess,\n         plugin_attributes,\n     };\n+\n+    if !features.raw_identifiers {\n+        for &span in sess.raw_identifier_spans.borrow().iter() {\n+            if !span.allows_unstable() {\n+                gate_feature!(&ctx, raw_identifiers, span,\n+                    \"raw identifiers are experimental and subject to change\"\n+                );\n+            }\n+        }\n+    }\n+\n     let visitor = &mut PostExpansionVisitor { context: &ctx };\n     visitor.whole_crate_feature_gates(krate);\n     visit::walk_crate(visitor, krate);"}, {"sha": "05a3150c139c92a753fbe87cf67b08372f150e01", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -578,7 +578,7 @@ pub fn noop_fold_tts<T: Folder>(tts: TokenStream, fld: &mut T) -> TokenStream {\n // apply ident folder if it's an ident, apply other folds to interpolated nodes\n pub fn noop_fold_token<T: Folder>(t: token::Token, fld: &mut T) -> token::Token {\n     match t {\n-        token::Ident(id) => token::Ident(fld.fold_ident(id)),\n+        token::Ident(id, is_raw) => token::Ident(fld.fold_ident(id), is_raw),\n         token::Lifetime(id) => token::Lifetime(fld.fold_ident(id)),\n         token::Interpolated(nt) => {\n             let nt = match Lrc::try_unwrap(nt) {\n@@ -630,7 +630,8 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n-        token::NtIdent(id) => token::NtIdent(Spanned::<Ident>{node: fld.fold_ident(id.node), ..id}),\n+        token::NtIdent(id, is_raw) =>\n+            token::NtIdent(Spanned::<Ident>{node: fld.fold_ident(id.node), ..id}, is_raw),\n         token::NtMeta(meta) => token::NtMeta(fld.fold_meta_item(meta)),\n         token::NtPath(path) => token::NtPath(fld.fold_path(path)),\n         token::NtTT(tt) => token::NtTT(fld.fold_tt(tt)),"}, {"sha": "068929c8948df983ef3eb17bc2573922bebab8d1", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 51, "deletions": 23, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -14,7 +14,7 @@ use codemap::{CodeMap, FilePathMapping};\n use errors::{FatalError, DiagnosticBuilder};\n use parse::{token, ParseSess};\n use str::char_at;\n-use symbol::Symbol;\n+use symbol::{Symbol, keywords};\n use std_unicode::property::Pattern_White_Space;\n \n use std::borrow::Cow;\n@@ -1115,26 +1115,53 @@ impl<'a> StringReader<'a> {\n     /// token, and updates the interner\n     fn next_token_inner(&mut self) -> Result<token::Token, ()> {\n         let c = self.ch;\n-        if ident_start(c) &&\n-           match (c.unwrap(), self.nextch(), self.nextnextch()) {\n-            // Note: r as in r\" or r#\" is part of a raw string literal,\n-            // b as in b' is part of a byte literal.\n-            // They are not identifiers, and are handled further down.\n-            ('r', Some('\"'), _) |\n-            ('r', Some('#'), _) |\n-            ('b', Some('\"'), _) |\n-            ('b', Some('\\''), _) |\n-            ('b', Some('r'), Some('\"')) |\n-            ('b', Some('r'), Some('#')) => false,\n-            _ => true,\n-        } {\n-            let start = self.pos;\n-            while ident_continue(self.ch) {\n-                self.bump();\n-            }\n \n-            // FIXME: perform NFKC normalization here. (Issue #2253)\n-            return Ok(self.with_str_from(start, |string| token::Ident(self.mk_ident(string))));\n+        if ident_start(c) {\n+            let (is_ident_start, is_raw_ident) =\n+                match (c.unwrap(), self.nextch(), self.nextnextch()) {\n+                    // r# followed by an identifier starter is a raw identifier.\n+                    // This is an exception to the r# case below.\n+                    ('r', Some('#'), x) if ident_start(x) => (true, true),\n+                    // r as in r\" or r#\" is part of a raw string literal.\n+                    // b as in b' is part of a byte literal.\n+                    // They are not identifiers, and are handled further down.\n+                    ('r', Some('\"'), _) |\n+                    ('r', Some('#'), _) |\n+                    ('b', Some('\"'), _) |\n+                    ('b', Some('\\''), _) |\n+                    ('b', Some('r'), Some('\"')) |\n+                    ('b', Some('r'), Some('#')) => (false, false),\n+                    _ => (true, false),\n+                };\n+            if is_ident_start {\n+                let raw_start = self.pos;\n+                if is_raw_ident {\n+                    // Consume the 'r#' characters.\n+                    self.bump();\n+                    self.bump();\n+                }\n+\n+                let start = self.pos;\n+                while ident_continue(self.ch) {\n+                    self.bump();\n+                }\n+\n+                return Ok(self.with_str_from(start, |string| {\n+                    // FIXME: perform NFKC normalization here. (Issue #2253)\n+                    let ident = self.mk_ident(string);\n+                    if is_raw_ident && (token::is_path_segment_keyword(ident) ||\n+                                        ident.name == keywords::Underscore.name()) {\n+                        self.fatal_span_(raw_start, self.pos,\n+                            &format!(\"`r#{}` is not currently supported.\", ident.name)\n+                        ).raise();\n+                    }\n+                    if is_raw_ident {\n+                        let span = self.mk_sp(raw_start, self.pos);\n+                        self.sess.raw_identifier_spans.borrow_mut().push(span);\n+                    }\n+                    token::Ident(ident, is_raw_ident)\n+                }));\n+            }\n         }\n \n         if is_dec_digit(c) {\n@@ -1773,6 +1800,7 @@ mod tests {\n             included_mod_stack: RefCell::new(Vec::new()),\n             code_map: cm,\n             missing_fragment_specifiers: RefCell::new(HashSet::new()),\n+            raw_identifier_spans: RefCell::new(Vec::new()),\n             registered_diagnostics: Lock::new(ErrorMap::new()),\n             non_modrs_mods: RefCell::new(vec![]),\n         }\n@@ -1801,7 +1829,7 @@ mod tests {\n             assert_eq!(string_reader.next_token().tok, token::Whitespace);\n             let tok1 = string_reader.next_token();\n             let tok2 = TokenAndSpan {\n-                tok: token::Ident(id),\n+                tok: token::Ident(id, false),\n                 sp: Span::new(BytePos(21), BytePos(23), NO_EXPANSION),\n             };\n             assert_eq!(tok1, tok2);\n@@ -1811,7 +1839,7 @@ mod tests {\n             // read another token:\n             let tok3 = string_reader.next_token();\n             let tok4 = TokenAndSpan {\n-                tok: token::Ident(Ident::from_str(\"main\")),\n+                tok: mk_ident(\"main\"),\n                 sp: Span::new(BytePos(24), BytePos(28), NO_EXPANSION),\n             };\n             assert_eq!(tok3, tok4);\n@@ -1830,7 +1858,7 @@ mod tests {\n \n     // make the identifier by looking up the string in the interner\n     fn mk_ident(id: &str) -> token::Token {\n-        token::Ident(Ident::from_str(id))\n+        token::Token::from_ast_ident(Ident::from_str(id))\n     }\n \n     #[test]"}, {"sha": "7b39db16ac2c84ff9758ee3b0415332b020c0a58", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -48,6 +48,9 @@ pub struct ParseSess {\n     pub unstable_features: UnstableFeatures,\n     pub config: CrateConfig,\n     pub missing_fragment_specifiers: RefCell<HashSet<Span>>,\n+    /// Places where raw identifiers were used. This is used for feature gating\n+    /// raw identifiers\n+    pub raw_identifier_spans: RefCell<Vec<Span>>,\n     /// The registered diagnostics codes\n     pub registered_diagnostics: Lock<ErrorMap>,\n     // Spans where a `mod foo;` statement was included in a non-mod.rs file.\n@@ -74,6 +77,7 @@ impl ParseSess {\n             unstable_features: UnstableFeatures::from_environment(),\n             config: HashSet::new(),\n             missing_fragment_specifiers: RefCell::new(HashSet::new()),\n+            raw_identifier_spans: RefCell::new(Vec::new()),\n             registered_diagnostics: Lock::new(ErrorMap::new()),\n             included_mod_stack: RefCell::new(vec![]),\n             code_map,\n@@ -739,9 +743,9 @@ mod tests {\n             match (tts.len(), tts.get(0), tts.get(1), tts.get(2), tts.get(3)) {\n                 (\n                     4,\n-                    Some(&TokenTree::Token(_, token::Ident(name_macro_rules))),\n+                    Some(&TokenTree::Token(_, token::Ident(name_macro_rules, false))),\n                     Some(&TokenTree::Token(_, token::Not)),\n-                    Some(&TokenTree::Token(_, token::Ident(name_zip))),\n+                    Some(&TokenTree::Token(_, token::Ident(name_zip, false))),\n                     Some(&TokenTree::Delimited(_, ref macro_delimed)),\n                 )\n                 if name_macro_rules.name == \"macro_rules\"\n@@ -760,7 +764,7 @@ mod tests {\n                                 (\n                                     2,\n                                     Some(&TokenTree::Token(_, token::Dollar)),\n-                                    Some(&TokenTree::Token(_, token::Ident(ident))),\n+                                    Some(&TokenTree::Token(_, token::Ident(ident, false))),\n                                 )\n                                 if first_delimed.delim == token::Paren && ident.name == \"a\" => {},\n                                 _ => panic!(\"value 3: {:?}\", *first_delimed),\n@@ -770,7 +774,7 @@ mod tests {\n                                 (\n                                     2,\n                                     Some(&TokenTree::Token(_, token::Dollar)),\n-                                    Some(&TokenTree::Token(_, token::Ident(ident))),\n+                                    Some(&TokenTree::Token(_, token::Ident(ident, false))),\n                                 )\n                                 if second_delimed.delim == token::Paren\n                                 && ident.name == \"a\" => {},\n@@ -791,25 +795,27 @@ mod tests {\n             let tts = string_to_stream(\"fn a (b : i32) { b; }\".to_string());\n \n             let expected = TokenStream::concat(vec![\n-                TokenTree::Token(sp(0, 2), token::Ident(Ident::from_str(\"fn\"))).into(),\n-                TokenTree::Token(sp(3, 4), token::Ident(Ident::from_str(\"a\"))).into(),\n+                TokenTree::Token(sp(0, 2), token::Ident(Ident::from_str(\"fn\"), false)).into(),\n+                TokenTree::Token(sp(3, 4), token::Ident(Ident::from_str(\"a\"), false)).into(),\n                 TokenTree::Delimited(\n                     sp(5, 14),\n                     tokenstream::Delimited {\n                         delim: token::DelimToken::Paren,\n                         tts: TokenStream::concat(vec![\n-                            TokenTree::Token(sp(6, 7), token::Ident(Ident::from_str(\"b\"))).into(),\n+                            TokenTree::Token(sp(6, 7),\n+                                             token::Ident(Ident::from_str(\"b\"), false)).into(),\n                             TokenTree::Token(sp(8, 9), token::Colon).into(),\n                             TokenTree::Token(sp(10, 13),\n-                                             token::Ident(Ident::from_str(\"i32\"))).into(),\n+                                             token::Ident(Ident::from_str(\"i32\"), false)).into(),\n                         ]).into(),\n                     }).into(),\n                 TokenTree::Delimited(\n                     sp(15, 21),\n                     tokenstream::Delimited {\n                         delim: token::DelimToken::Brace,\n                         tts: TokenStream::concat(vec![\n-                            TokenTree::Token(sp(17, 18), token::Ident(Ident::from_str(\"b\"))).into(),\n+                            TokenTree::Token(sp(17, 18),\n+                                             token::Ident(Ident::from_str(\"b\"), false)).into(),\n                             TokenTree::Token(sp(18, 19), token::Semi).into(),\n                         ]).into(),\n                     }).into()"}, {"sha": "a07279acae2d3f9286c6a84c7cbf611df8211ba7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -358,7 +358,7 @@ impl TokenCursor {\n \n         let body = TokenTree::Delimited(sp, Delimited {\n             delim: token::Bracket,\n-            tts: [TokenTree::Token(sp, token::Ident(ast::Ident::from_str(\"doc\"))),\n+            tts: [TokenTree::Token(sp, token::Ident(ast::Ident::from_str(\"doc\"), false)),\n                   TokenTree::Token(sp, token::Eq),\n                   TokenTree::Token(sp, token::Literal(\n                       token::StrRaw(Symbol::intern(&stripped), num_of_hashes), None))]\n@@ -784,7 +784,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, ast::Ident> {\n         match self.token {\n-            token::Ident(i) => {\n+            token::Ident(i, _) => {\n                 if self.token.is_reserved_ident() {\n                     let mut err = self.expected_ident_found();\n                     if recover {\n@@ -1925,7 +1925,7 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_path_segment_ident(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token {\n-            token::Ident(sid) if self.token.is_path_segment_keyword() => {\n+            token::Ident(sid, _) if self.token.is_path_segment_keyword() => {\n                 self.bump();\n                 Ok(sid)\n             }\n@@ -2740,11 +2740,14 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn process_potential_macro_variable(&mut self) {\n-        let ident = match self.token {\n+        let (ident, is_raw) = match self.token {\n             token::Dollar if self.span.ctxt() != syntax_pos::hygiene::SyntaxContext::empty() &&\n                              self.look_ahead(1, |t| t.is_ident()) => {\n                 self.bump();\n-                let name = match self.token { token::Ident(ident) => ident, _ => unreachable!() };\n+                let name = match self.token {\n+                    token::Ident(ident, _) => ident,\n+                    _ => unreachable!()\n+                };\n                 let mut err = self.fatal(&format!(\"unknown macro variable `{}`\", name));\n                 err.span_label(self.span, \"unknown macro variable\");\n                 err.emit();\n@@ -2753,13 +2756,13 @@ impl<'a> Parser<'a> {\n             token::Interpolated(ref nt) => {\n                 self.meta_var_span = Some(self.span);\n                 match nt.0 {\n-                    token::NtIdent(ident) => ident,\n+                    token::NtIdent(ident, is_raw) => (ident, is_raw),\n                     _ => return,\n                 }\n             }\n             _ => return,\n         };\n-        self.token = token::Ident(ident.node);\n+        self.token = token::Ident(ident.node, is_raw);\n         self.span = ident.span;\n     }\n \n@@ -4245,7 +4248,7 @@ impl<'a> Parser<'a> {\n                      -> PResult<'a, Option<P<Item>>> {\n         let token_lo = self.span;\n         let (ident, def) = match self.token {\n-            token::Ident(ident) if ident.name == keywords::Macro.name() => {\n+            token::Ident(ident, false) if ident.name == keywords::Macro.name() => {\n                 self.bump();\n                 let ident = self.parse_ident()?;\n                 let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n@@ -4273,7 +4276,7 @@ impl<'a> Parser<'a> {\n \n                 (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n             }\n-            token::Ident(ident) if ident.name == \"macro_rules\" &&\n+            token::Ident(ident, _) if ident.name == \"macro_rules\" &&\n                                    self.look_ahead(1, |t| *t == token::Not) => {\n                 let prev_span = self.prev_span;\n                 self.complain_if_pub_macro(&vis.node, prev_span);\n@@ -5078,7 +5081,9 @@ impl<'a> Parser<'a> {\n     fn parse_self_arg(&mut self) -> PResult<'a, Option<Arg>> {\n         let expect_ident = |this: &mut Self| match this.token {\n             // Preserve hygienic context.\n-            token::Ident(ident) => { let sp = this.span; this.bump(); codemap::respan(sp, ident) }\n+            token::Ident(ident, _) => {\n+                let sp = this.span; this.bump(); codemap::respan(sp, ident)\n+            }\n             _ => unreachable!()\n         };\n         let isolated_self = |this: &mut Self, n| {\n@@ -5375,7 +5380,7 @@ impl<'a> Parser<'a> {\n             VisibilityKind::Inherited => Ok(()),\n             _ => {\n                 let is_macro_rules: bool = match self.token {\n-                    token::Ident(sid) => sid.name == Symbol::intern(\"macro_rules\"),\n+                    token::Ident(sid, _) => sid.name == Symbol::intern(\"macro_rules\"),\n                     _ => false,\n                 };\n                 if is_macro_rules {\n@@ -7016,7 +7021,7 @@ impl<'a> Parser<'a> {\n     fn parse_rename(&mut self) -> PResult<'a, Option<Ident>> {\n         if self.eat_keyword(keywords::As) {\n             match self.token {\n-                token::Ident(ident) if ident.name == keywords::Underscore.name() => {\n+                token::Ident(ident, false) if ident.name == keywords::Underscore.name() => {\n                     self.bump(); // `_`\n                     Ok(Some(Ident { name: ident.name.gensymed(), ..ident }))\n                 }"}, {"sha": "7798a7a77ee6c8c63e96cd47895759427b6d213b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 61, "deletions": 26, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -91,8 +91,8 @@ impl Lit {\n     }\n }\n \n-fn ident_can_begin_expr(ident: ast::Ident) -> bool {\n-    let ident_token: Token = Ident(ident);\n+fn ident_can_begin_expr(ident: ast::Ident, is_raw: bool) -> bool {\n+    let ident_token: Token = Ident(ident, is_raw);\n \n     !ident_token.is_reserved_ident() ||\n     ident_token.is_path_segment_keyword() ||\n@@ -116,8 +116,8 @@ fn ident_can_begin_expr(ident: ast::Ident) -> bool {\n     ].contains(&ident.name)\n }\n \n-fn ident_can_begin_type(ident: ast::Ident) -> bool {\n-    let ident_token: Token = Ident(ident);\n+fn ident_can_begin_type(ident: ast::Ident, is_raw: bool) -> bool {\n+    let ident_token: Token = Ident(ident, is_raw);\n \n     !ident_token.is_reserved_ident() ||\n     ident_token.is_path_segment_keyword() ||\n@@ -132,6 +132,37 @@ fn ident_can_begin_type(ident: ast::Ident) -> bool {\n     ].contains(&ident.name)\n }\n \n+pub fn is_path_segment_keyword(id: ast::Ident) -> bool {\n+    id.name == keywords::Super.name() ||\n+    id.name == keywords::SelfValue.name() ||\n+    id.name == keywords::SelfType.name() ||\n+    id.name == keywords::Extern.name() ||\n+    id.name == keywords::Crate.name() ||\n+    id.name == keywords::CrateRoot.name() ||\n+    id.name == keywords::DollarCrate.name()\n+}\n+\n+// Returns true for reserved identifiers used internally for elided lifetimes,\n+// unnamed method parameters, crate root module, error recovery etc.\n+pub fn is_special_ident(id: ast::Ident) -> bool {\n+    id.name <= keywords::Underscore.name()\n+}\n+\n+/// Returns `true` if the token is a keyword used in the language.\n+pub fn is_used_keyword(id: ast::Ident) -> bool {\n+    id.name >= keywords::As.name() && id.name <= keywords::While.name()\n+}\n+\n+/// Returns `true` if the token is a keyword reserved for possible future use.\n+pub fn is_unused_keyword(id: ast::Ident) -> bool {\n+    id.name >= keywords::Abstract.name() && id.name <= keywords::Yield.name()\n+}\n+\n+/// Returns `true` if the token is either a special identifier or a keyword.\n+pub fn is_reserved_ident(id: ast::Ident) -> bool {\n+    is_special_ident(id) || is_used_keyword(id) || is_unused_keyword(id)\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug)]\n pub enum Token {\n     /* Expression-operator symbols. */\n@@ -175,7 +206,7 @@ pub enum Token {\n     Literal(Lit, Option<ast::Name>),\n \n     /* Name components */\n-    Ident(ast::Ident),\n+    Ident(ast::Ident, /* is_raw */ bool),\n     Lifetime(ast::Ident),\n \n     // The `LazyTokenStream` is a pure function of the `Nonterminal`,\n@@ -203,6 +234,11 @@ impl Token {\n         Token::Interpolated(Lrc::new((nt, LazyTokenStream::new())))\n     }\n \n+    /// Recovers a `Token` from an `ast::Ident`. This creates a raw identifier if necessary.\n+    pub fn from_ast_ident(ident: ast::Ident) -> Token {\n+        Ident(ident, is_reserved_ident(ident) && !is_path_segment_keyword(ident))\n+    }\n+\n     /// Returns `true` if the token starts with '>'.\n     pub fn is_like_gt(&self) -> bool {\n         match *self {\n@@ -214,7 +250,8 @@ impl Token {\n     /// Returns `true` if the token can appear at the start of an expression.\n     pub fn can_begin_expr(&self) -> bool {\n         match *self {\n-            Ident(ident)                => ident_can_begin_expr(ident), // value name or keyword\n+            Ident(ident, is_raw)              =>\n+                ident_can_begin_expr(ident, is_raw), // value name or keyword\n             OpenDelim(..)                     | // tuple, array or block\n             Literal(..)                       | // literal\n             Not                               | // operator not\n@@ -239,7 +276,8 @@ impl Token {\n     /// Returns `true` if the token can appear at the start of a type.\n     pub fn can_begin_type(&self) -> bool {\n         match *self {\n-            Ident(ident)                => ident_can_begin_type(ident), // type name or keyword\n+            Ident(ident, is_raw)        =>\n+                ident_can_begin_type(ident, is_raw), // type name or keyword\n             OpenDelim(Paren)            | // tuple\n             OpenDelim(Bracket)          | // array\n             Not                         | // never\n@@ -272,11 +310,11 @@ impl Token {\n         }\n     }\n \n-    pub fn ident(&self) -> Option<ast::Ident> {\n+    pub fn ident(&self) -> Option<(ast::Ident, bool)> {\n         match *self {\n-            Ident(ident) => Some(ident),\n+            Ident(ident, is_raw) => Some((ident, is_raw)),\n             Interpolated(ref nt) => match nt.0 {\n-                NtIdent(ident) => Some(ident.node),\n+                NtIdent(ident, is_raw) => Some((ident.node, is_raw)),\n                 _ => None,\n             },\n             _ => None,\n@@ -351,43 +389,37 @@ impl Token {\n \n     /// Returns `true` if the token is a given keyword, `kw`.\n     pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n-        self.ident().map(|ident| ident.name == kw.name()).unwrap_or(false)\n+        self.ident().map(|(ident, is_raw)| ident.name == kw.name() && !is_raw).unwrap_or(false)\n     }\n \n     pub fn is_path_segment_keyword(&self) -> bool {\n         match self.ident() {\n-            Some(id) => id.name == keywords::Super.name() ||\n-                        id.name == keywords::SelfValue.name() ||\n-                        id.name == keywords::SelfType.name() ||\n-                        id.name == keywords::Extern.name() ||\n-                        id.name == keywords::Crate.name() ||\n-                        id.name == keywords::CrateRoot.name() ||\n-                        id.name == keywords::DollarCrate.name(),\n-            None => false,\n+            Some((id, false)) => is_path_segment_keyword(id),\n+            _ => false,\n         }\n     }\n \n     // Returns true for reserved identifiers used internally for elided lifetimes,\n     // unnamed method parameters, crate root module, error recovery etc.\n     pub fn is_special_ident(&self) -> bool {\n         match self.ident() {\n-            Some(id) => id.name <= keywords::Underscore.name(),\n+            Some((id, false)) => is_special_ident(id),\n             _ => false,\n         }\n     }\n \n     /// Returns `true` if the token is a keyword used in the language.\n     pub fn is_used_keyword(&self) -> bool {\n         match self.ident() {\n-            Some(id) => id.name >= keywords::As.name() && id.name <= keywords::While.name(),\n+            Some((id, false)) => is_used_keyword(id),\n             _ => false,\n         }\n     }\n \n     /// Returns `true` if the token is a keyword reserved for possible future use.\n     pub fn is_unused_keyword(&self) -> bool {\n         match self.ident() {\n-            Some(id) => id.name >= keywords::Abstract.name() && id.name <= keywords::Yield.name(),\n+            Some((id, false)) => is_unused_keyword(id),\n             _ => false,\n         }\n     }\n@@ -460,7 +492,10 @@ impl Token {\n \n     /// Returns `true` if the token is either a special identifier or a keyword.\n     pub fn is_reserved_ident(&self) -> bool {\n-        self.is_special_ident() || self.is_used_keyword() || self.is_unused_keyword()\n+        match self.ident() {\n+            Some((id, false)) => is_reserved_ident(id),\n+            _ => false,\n+        }\n     }\n \n     pub fn interpolated_to_tokenstream(&self, sess: &ParseSess, span: Span)\n@@ -496,8 +531,8 @@ impl Token {\n             Nonterminal::NtImplItem(ref item) => {\n                 tokens = prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span);\n             }\n-            Nonterminal::NtIdent(ident) => {\n-                let token = Token::Ident(ident.node);\n+            Nonterminal::NtIdent(ident, is_raw) => {\n+                let token = Token::Ident(ident.node, is_raw);\n                 tokens = Some(TokenTree::Token(ident.span, token).into());\n             }\n             Nonterminal::NtLifetime(lifetime) => {\n@@ -529,7 +564,7 @@ pub enum Nonterminal {\n     NtPat(P<ast::Pat>),\n     NtExpr(P<ast::Expr>),\n     NtTy(P<ast::Ty>),\n-    NtIdent(ast::SpannedIdent),\n+    NtIdent(ast::SpannedIdent, /* is_raw */ bool),\n     /// Stuff inside brackets for attributes\n     NtMeta(ast::MetaItem),\n     NtPath(ast::Path),"}, {"sha": "50577a26abf41a1d2bc341d08998059455d2ff38", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -250,7 +250,8 @@ pub fn token_to_string(tok: &Token) -> String {\n         }\n \n         /* Name components */\n-        token::Ident(s)             => s.to_string(),\n+        token::Ident(s, false)      => s.to_string(),\n+        token::Ident(s, true)       => format!(\"r#{}\", s),\n         token::Lifetime(s)          => s.to_string(),\n \n         /* Other */\n@@ -261,24 +262,25 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Shebang(s)           => format!(\"/* shebang: {}*/\", s),\n \n         token::Interpolated(ref nt) => match nt.0 {\n-            token::NtExpr(ref e)        => expr_to_string(e),\n-            token::NtMeta(ref e)        => meta_item_to_string(e),\n-            token::NtTy(ref e)          => ty_to_string(e),\n-            token::NtPath(ref e)        => path_to_string(e),\n-            token::NtItem(ref e)        => item_to_string(e),\n-            token::NtBlock(ref e)       => block_to_string(e),\n-            token::NtStmt(ref e)        => stmt_to_string(e),\n-            token::NtPat(ref e)         => pat_to_string(e),\n-            token::NtIdent(ref e)       => ident_to_string(e.node),\n-            token::NtTT(ref tree)       => tt_to_string(tree.clone()),\n-            token::NtArm(ref e)         => arm_to_string(e),\n-            token::NtImplItem(ref e)    => impl_item_to_string(e),\n-            token::NtTraitItem(ref e)   => trait_item_to_string(e),\n-            token::NtGenerics(ref e)    => generic_params_to_string(&e.params),\n-            token::NtWhereClause(ref e) => where_clause_to_string(e),\n-            token::NtArg(ref e)         => arg_to_string(e),\n-            token::NtVis(ref e)         => vis_to_string(e),\n-            token::NtLifetime(ref e)    => lifetime_to_string(e),\n+            token::NtExpr(ref e)         => expr_to_string(e),\n+            token::NtMeta(ref e)         => meta_item_to_string(e),\n+            token::NtTy(ref e)           => ty_to_string(e),\n+            token::NtPath(ref e)         => path_to_string(e),\n+            token::NtItem(ref e)         => item_to_string(e),\n+            token::NtBlock(ref e)        => block_to_string(e),\n+            token::NtStmt(ref e)         => stmt_to_string(e),\n+            token::NtPat(ref e)          => pat_to_string(e),\n+            token::NtIdent(ref e, false) => ident_to_string(e.node),\n+            token::NtIdent(ref e, true)  => format!(\"r#{}\", ident_to_string(e.node)),\n+            token::NtTT(ref tree)        => tt_to_string(tree.clone()),\n+            token::NtArm(ref e)          => arm_to_string(e),\n+            token::NtImplItem(ref e)     => impl_item_to_string(e),\n+            token::NtTraitItem(ref e)    => trait_item_to_string(e),\n+            token::NtGenerics(ref e)     => generic_params_to_string(&e.params),\n+            token::NtWhereClause(ref e)  => where_clause_to_string(e),\n+            token::NtArg(ref e)          => arg_to_string(e),\n+            token::NtVis(ref e)          => vis_to_string(e),\n+            token::NtLifetime(ref e)     => lifetime_to_string(e),\n         }\n     }\n }"}, {"sha": "3a7a1b9a66966f322d5367bd6458be389e57f4f0", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -684,7 +684,7 @@ mod tests {\n         with_globals(|| {\n             let test0: TokenStream = Vec::<TokenTree>::new().into_iter().collect();\n             let test1: TokenStream =\n-                TokenTree::Token(sp(0, 1), Token::Ident(Ident::from_str(\"a\"))).into();\n+                TokenTree::Token(sp(0, 1), Token::Ident(Ident::from_str(\"a\"), false)).into();\n             let test2 = string_to_ts(\"foo(bar::baz)\");\n \n             assert_eq!(test0.is_empty(), true);"}, {"sha": "d513008f0e2d388a92aad7c1da6989b8b2cd67ff", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -44,7 +44,8 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n             }\n         } else {\n             match *e {\n-                TokenTree::Token(_, token::Ident(ident)) => res_str.push_str(&ident.name.as_str()),\n+                TokenTree::Token(_, token::Ident(ident, _)) =>\n+                    res_str.push_str(&ident.name.as_str()),\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! requires ident args.\");\n                     return DummyResult::expr(sp);"}, {"sha": "d9c68e3167bd68cc3f983d72b4899ff55f5bdf02", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -149,7 +149,7 @@ fn parse_args(ecx: &mut ExtCtxt,\n         if named || (p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq)) {\n             named = true;\n             let ident = match p.token {\n-                token::Ident(i) => {\n+                token::Ident(i, _) => {\n                     p.bump();\n                     i\n                 }"}, {"sha": "8c0027287deceea029275286e3f8d9615509f151", "filename": "src/test/parse-fail/raw-str-delim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fparse-fail%2Fraw-str-delim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fparse-fail%2Fraw-str-delim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fraw-str-delim.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -11,5 +11,5 @@\n // compile-flags: -Z parse-only\n \n static s: &'static str =\n-    r#x\"#\"x# //~ ERROR found invalid character; only `#` is allowed in raw string delimitation\n+    r#~\"#\"~# //~ ERROR found invalid character; only `#` is allowed in raw string delimitation\n ;"}, {"sha": "dc6f33bad99792a348e2b0a5b6786648a54dcdb8", "filename": "src/test/run-pass-fulldeps/auxiliary/roman_numerals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Froman_numerals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Froman_numerals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Froman_numerals.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -48,7 +48,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n     }\n \n     let text = match args[0] {\n-        TokenTree::Token(_, token::Ident(s)) => s.to_string(),\n+        TokenTree::Token(_, token::Ident(s, _)) => s.to_string(),\n         _ => {\n             cx.span_err(sp, \"argument should be a single identifier\");\n             return DummyResult::any(sp);"}, {"sha": "6cea75cf1d11e9a83daa59481c62a90d8f60d9cf", "filename": "src/test/run-pass/rfc-2151-raw-identifiers/attr.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Frun-pass%2Frfc-2151-raw-identifiers%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Frun-pass%2Frfc-2151-raw-identifiers%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2151-raw-identifiers%2Fattr.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(raw_identifiers)]\n+\n+use std::mem;\n+\n+#[r#repr(r#C, r#packed)]\n+struct Test {\n+    a: bool, b: u64\n+}\n+\n+#[r#derive(r#Debug)]\n+struct Test2(u32);\n+\n+pub fn main() {\n+    assert_eq!(mem::size_of::<Test>(), 9);\n+    assert_eq!(\"Test2(123)\", format!(\"{:?}\", Test2(123)));\n+}"}, {"sha": "5d495c4e9e557eca33006318ca3ffd6af05b9bd7", "filename": "src/test/run-pass/rfc-2151-raw-identifiers/basic.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Frun-pass%2Frfc-2151-raw-identifiers%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Frun-pass%2Frfc-2151-raw-identifiers%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2151-raw-identifiers%2Fbasic.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(raw_identifiers)]\n+\n+fn r#fn(r#match: u32) -> u32 {\n+    r#match\n+}\n+\n+pub fn main() {\n+    let r#struct = 1;\n+    assert_eq!(1, r#struct);\n+\n+    let foo = 2;\n+    assert_eq!(2, r#foo);\n+\n+    let r#bar = 3;\n+    assert_eq!(3, bar);\n+\n+    assert_eq!(4, r#fn(4));\n+\n+    let r#true = false;\n+    assert_eq!(r#true, false);\n+}"}, {"sha": "256bd263d38d42c1d5c182310ccbdf50c48e4518", "filename": "src/test/run-pass/rfc-2151-raw-identifiers/items.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Frun-pass%2Frfc-2151-raw-identifiers%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Frun-pass%2Frfc-2151-raw-identifiers%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2151-raw-identifiers%2Fitems.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(raw_identifiers)]\n+\n+#[derive(Debug, PartialEq, Eq)]\n+struct IntWrapper(u32);\n+\n+#[derive(Debug, Ord, PartialOrd, PartialEq, Eq, Hash, Copy, Clone, Default)]\n+struct HasKeywordField {\n+    r#struct: u32,\n+}\n+\n+struct Generic<r#T>(T);\n+\n+trait Trait {\n+    fn r#trait(&self) -> u32;\n+}\n+impl Trait for Generic<u32> {\n+    fn r#trait(&self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+pub fn main() {\n+    assert_eq!(IntWrapper(1), r#IntWrapper(1));\n+\n+    match IntWrapper(2) {\n+        r#IntWrapper(r#struct) => assert_eq!(2, r#struct),\n+    }\n+\n+    assert_eq!(\"HasKeywordField { struct: 3 }\", format!(\"{:?}\", HasKeywordField { r#struct: 3 }));\n+\n+    assert_eq!(4, Generic(4).0);\n+    assert_eq!(5, Generic(5).r#trait());\n+}"}, {"sha": "4bd16ded52fbdf6b39ba4e5d86aaa8deadd7207f", "filename": "src/test/run-pass/rfc-2151-raw-identifiers/macros.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Frun-pass%2Frfc-2151-raw-identifiers%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Frun-pass%2Frfc-2151-raw-identifiers%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2151-raw-identifiers%2Fmacros.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro)]\n+#![feature(raw_identifiers)]\n+\n+r#macro_rules! r#struct {\n+    ($r#struct:expr) => { $r#struct }\n+}\n+\n+macro_rules! old_macro {\n+    ($a:expr) => {$a}\n+}\n+\n+macro r#decl_macro($r#fn:expr) {\n+    $r#fn\n+}\n+\n+macro passthrough($id:ident) {\n+    $id\n+}\n+\n+macro_rules! test_pat_match {\n+    (a) => { 6 };\n+    (r#a) => { 7 };\n+}\n+\n+pub fn main() {\n+    r#println!(\"{struct}\", r#struct = 1);\n+    assert_eq!(2, r#struct!(2));\n+    assert_eq!(3, r#old_macro!(3));\n+    assert_eq!(4, decl_macro!(4));\n+\n+    let r#match = 5;\n+    assert_eq!(5, passthrough!(r#match));\n+\n+    assert_eq!(\"r#struct\", stringify!(r#struct));\n+\n+    assert_eq!(6, test_pat_match!(a));\n+    assert_eq!(7, test_pat_match!(r#a));\n+}"}, {"sha": "38024feb432d9f31587a2f8787b895d8b9169763", "filename": "src/test/ui/feature-gate-raw-identifiers.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Ffeature-gate-raw-identifiers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Ffeature-gate-raw-identifiers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-raw-identifiers.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let r#foo = 3; //~ ERROR raw identifiers are experimental and subject to change\n+    println!(\"{}\", foo);\n+}"}, {"sha": "02eff7247c47bf6f1e705f11ae9d0855cb451987", "filename": "src/test/ui/feature-gate-raw-identifiers.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Ffeature-gate-raw-identifiers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Ffeature-gate-raw-identifiers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-raw-identifiers.stderr?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: raw identifiers are experimental and subject to change (see issue #48589)\n+  --> $DIR/feature-gate-raw-identifiers.rs:12:9\n+   |\n+LL |     let r#foo = 3; //~ ERROR raw identifiers are experimental and subject to change\n+   |         ^^^^^\n+   |\n+   = help: add #![feature(raw_identifiers)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "9b28aa0b15116d9549b56ac0bf908f52b01a34bf", "filename": "src/test/ui/raw-literal-keywords.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Fraw-literal-keywords.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Fraw-literal-keywords.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-literal-keywords.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+#![feature(dyn_trait)]\n+#![feature(raw_identifiers)]\n+\n+fn test_if() {\n+    r#if true { } //~ ERROR found `true`\n+}\n+\n+fn test_struct() {\n+    r#struct Test; //~ ERROR found `Test`\n+}\n+\n+fn test_union() {\n+    r#union Test; //~ ERROR found `Test`\n+}"}, {"sha": "3758568323cc0ac0a3e10a348bee33266e6a1d2d", "filename": "src/test/ui/raw-literal-keywords.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Fraw-literal-keywords.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Fraw-literal-keywords.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-literal-keywords.stderr?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -0,0 +1,20 @@\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `true`\n+  --> $DIR/raw-literal-keywords.rs:17:10\n+   |\n+LL |     r#if true { } //~ ERROR found `true`\n+   |          ^^^^ expected one of 8 possible tokens here\n+\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `Test`\n+  --> $DIR/raw-literal-keywords.rs:21:14\n+   |\n+LL |     r#struct Test; //~ ERROR found `Test`\n+   |              ^^^^ expected one of 8 possible tokens here\n+\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `Test`\n+  --> $DIR/raw-literal-keywords.rs:25:13\n+   |\n+LL |     r#union Test; //~ ERROR found `Test`\n+   |             ^^^^ expected one of 8 possible tokens here\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "f88d6cf9a67bd635df468f0697e9f965dba7cce5", "filename": "src/test/ui/raw-literal-self.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Fraw-literal-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Fraw-literal-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-literal-self.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+#![feature(raw_identifiers)]\n+\n+fn self_test(r#self: u32) {\n+    //~^ ERROR `r#self` is not currently supported.\n+}"}, {"sha": "e3345847aa895367624496deb0981c21de063e1f", "filename": "src/test/ui/raw-literal-self.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Fraw-literal-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Fraw-literal-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-literal-self.stderr?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -0,0 +1,8 @@\n+error: `r#self` is not currently supported.\n+  --> $DIR/raw-literal-self.rs:15:14\n+   |\n+LL | fn self_test(r#self: u32) {\n+   |              ^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "ec33e4861958e883a2ae08fb49707c2ee7547c83", "filename": "src/test/ui/raw-literal-underscore.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Fraw-literal-underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Fraw-literal-underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-literal-underscore.rs?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn underscore_test(r#_: u32) {\n+    //~^ ERROR `r#_` is not currently supported.\n+}"}, {"sha": "8072eee4f0604f28995d34a56ae90f67b90bd030", "filename": "src/test/ui/raw-literal-underscore.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Fraw-literal-underscore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82bb41bdab6d6d5611573883bea5779ed43ca184/src%2Ftest%2Fui%2Fraw-literal-underscore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-literal-underscore.stderr?ref=82bb41bdab6d6d5611573883bea5779ed43ca184", "patch": "@@ -0,0 +1,8 @@\n+error: `r#_` is not currently supported.\n+  --> $DIR/raw-literal-underscore.rs:13:20\n+   |\n+LL | fn underscore_test(r#_: u32) {\n+   |                    ^^^\n+\n+error: aborting due to previous error\n+"}]}