{"sha": "a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0YjdjZTk0YmFjYmI4YTlkYTI4MTExZmJhMGFiZWIyYTY4ZTliYzI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-08-19T15:03:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-19T15:03:35Z"}, "message": "Merge #5817\n\n5817: Better API factoring around self access modes\n r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "1affb36a509f8f6460bf35a53a7f7937338ae805", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1affb36a509f8f6460bf35a53a7f7937338ae805"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfPT9HCRBK7hj4Ov3rIwAAdHIIAH+9lUfCRGrmj544c/eOB1tx\nfww1yLn2SAjBdOWwyT2/THmV7Kc9p52jd90SpW5X3uR1DsX5ZDKUCK170qEcH6Wt\nTVhXPMp0rbtH3yKOHLg3bGItLIowoEVNTxu+E3LAIkjA72Y7zq05/0hcHrJMic6r\nwXLvMeCTgyaMHxKCg15IekE91P5URk2j9i5yj8vzg9JDP2MezfdiQySxuhUjjyHm\nVT+cP9SWcqkPzl4ZLrNuttcs50qAjeciu5+2A3MePHaINk+vFu7lj4xCUNHd26QH\nj5NJchmMyDImtsIwcBD0g+Q+Ogyw6Ffb46rWzgfw2j5XwVoYXNtjtXOAjlesrHI=\n=t35/\n-----END PGP SIGNATURE-----\n", "payload": "tree 1affb36a509f8f6460bf35a53a7f7937338ae805\nparent 1d19084317fd183ca8a1632cbff1112e72e5969f\nparent 61754678fb4923738c91f2702bba6628230dff6e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1597849415 +0000\ncommitter GitHub <noreply@github.com> 1597849415 +0000\n\nMerge #5817\n\n5817: Better API factoring around self access modes\n r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2", "html_url": "https://github.com/rust-lang/rust/commit/a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d19084317fd183ca8a1632cbff1112e72e5969f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d19084317fd183ca8a1632cbff1112e72e5969f", "html_url": "https://github.com/rust-lang/rust/commit/1d19084317fd183ca8a1632cbff1112e72e5969f"}, {"sha": "61754678fb4923738c91f2702bba6628230dff6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/61754678fb4923738c91f2702bba6628230dff6e", "html_url": "https://github.com/rust-lang/rust/commit/61754678fb4923738c91f2702bba6628230dff6e"}], "stats": {"total": 86, "additions": 30, "deletions": 56}, "files": [{"sha": "3d92d0c0d19151ffe2d552d90d3753bbfbf136a3", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2", "patch": "@@ -12,6 +12,7 @@ use hir_def::{\n     docs::Documentation,\n     expr::{BindingAnnotation, Pat, PatId},\n     import_map,\n+    lang_item::LangItemTarget,\n     path::ModPath,\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n@@ -36,7 +37,7 @@ use rustc_hash::FxHashSet;\n use stdx::impl_from;\n use syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n-    AstNode,\n+    AstNode, SmolStr,\n };\n \n use crate::{\n@@ -1287,6 +1288,15 @@ impl Type {\n         db.trait_solve(self.krate, goal).is_some()\n     }\n \n+    pub fn is_copy(&self, db: &dyn HirDatabase) -> bool {\n+        let lang_item = db.lang_item(self.krate, SmolStr::new(\"copy\"));\n+        let copy_trait = match lang_item {\n+            Some(LangItemTarget::TraitId(it)) => it,\n+            _ => return false,\n+        };\n+        self.impls_trait(db, copy_trait.into(), &[])\n+    }\n+\n     pub fn as_callable(&self, db: &dyn HirDatabase) -> Option<Callable> {\n         let def = match self.ty.value {\n             Ty::Apply(ApplicationTy { ctor: TypeCtor::FnDef(def), parameters: _ }) => Some(def),"}, {"sha": "78d8651cba8ec838dbf42a46ae23fadf438feb00", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2", "patch": "@@ -38,7 +38,7 @@ pub use crate::{\n         ScopeDef, Static, Struct, Trait, Type, TypeAlias, TypeParam, Union, VariantDef, Visibility,\n     },\n     has_source::HasSource,\n-    semantics::{original_range, PathResolution, SelfKind, Semantics, SemanticsScope},\n+    semantics::{original_range, PathResolution, Semantics, SemanticsScope},\n };\n \n pub use hir_def::{"}, {"sha": "8c5f2ff98312788fd7fc3530fc7ec862eddf3bc6", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 44, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2", "patch": "@@ -6,18 +6,16 @@ use std::{cell::RefCell, fmt, iter::successors};\n \n use base_db::{FileId, FileRange};\n use hir_def::{\n-    lang_item::LangItemTarget,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n-    src::HasSource,\n-    AsMacroCall, FunctionId, Lookup, TraitId, VariantId,\n+    AsMacroCall, FunctionId, TraitId, VariantId,\n };\n use hir_expand::{hygiene::Hygiene, name::AsName, ExpansionInfo};\n use hir_ty::associated_type_shorthand_candidates;\n use itertools::Itertools;\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::{\n     algo::{find_node_at_offset, skip_trivia_token},\n-    ast, AstNode, Direction, SmolStr, SyntaxNode, SyntaxToken, TextRange, TextSize,\n+    ast, AstNode, Direction, SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::{\n@@ -81,13 +79,6 @@ impl PathResolution {\n     }\n }\n \n-pub enum SelfKind {\n-    Shared,\n-    Mutable,\n-    Consuming,\n-    Copied,\n-}\n-\n /// Primary API to get semantic information, like types, from syntax trees.\n pub struct Semantics<'db, DB> {\n     pub db: &'db DB,\n@@ -197,10 +188,6 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.type_of_self(param)\n     }\n \n-    pub fn method_reciever_kind(&self, call: &ast::MethodCallExpr) -> Option<SelfKind> {\n-        self.imp.method_receiver_kind(call)\n-    }\n-\n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n         self.imp.resolve_method_call(call).map(Function::from)\n     }\n@@ -423,35 +410,6 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(param.syntax()).type_of_self(self.db, &param)\n     }\n \n-    fn method_receiver_kind(&self, call: &ast::MethodCallExpr) -> Option<SelfKind> {\n-        self.resolve_method_call(call).and_then(|func| {\n-            let lookup = func.lookup(self.db.upcast());\n-            let src = lookup.source(self.db.upcast());\n-            let param_list = src.value.param_list()?;\n-            let self_param = param_list.self_param()?;\n-            if self_param.amp_token().is_some() {\n-                return Some(if self_param.mut_token().is_some() {\n-                    SelfKind::Mutable\n-                } else {\n-                    SelfKind::Shared\n-                });\n-            }\n-\n-            let ty = self.type_of_expr(&call.expr()?)?;\n-            let krate = Function::from(func).krate(self.db)?;\n-            let lang_item = self.db.lang_item(krate.id, SmolStr::new(\"copy\"));\n-            let copy_trait = match lang_item? {\n-                LangItemTarget::TraitId(copy_trait) => Trait::from(copy_trait),\n-                _ => return None,\n-            };\n-            Some(if ty.impls_trait(self.db, copy_trait, &[]) {\n-                SelfKind::Copied\n-            } else {\n-                SelfKind::Consuming\n-            })\n-        })\n-    }\n-\n     fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<FunctionId> {\n         self.analyze(call.syntax()).resolve_method_call(self.db, call)\n     }"}, {"sha": "5521fd2b14e31fb430223600beebcb7695ad6a7d", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=a4b7ce94bacbb8a9da28111fba0abeb2a68e9bc2", "patch": "@@ -4,7 +4,7 @@ mod injection;\n #[cfg(test)]\n mod tests;\n \n-use hir::{Name, SelfKind, Semantics, VariantDef};\n+use hir::{Name, Semantics, VariantDef};\n use ide_db::{\n     defs::{classify_name, classify_name_ref, Definition, NameClass, NameRefClass},\n     RootDatabase,\n@@ -720,15 +720,21 @@ fn highlight_method_call(\n     if func.is_unsafe(sema.db) || sema.is_unsafe_method_call(&method_call) {\n         h |= HighlightModifier::Unsafe;\n     }\n-\n-    sema.method_reciever_kind(&method_call)\n-        .map(|self_kind| match self_kind {\n-            SelfKind::Shared => h,\n-            SelfKind::Mutable => h | HighlightModifier::Mutable,\n-            SelfKind::Consuming => h | HighlightModifier::Consuming,\n-            SelfKind::Copied => h,\n-        })\n-        .or_else(|| Some(h))\n+    if let Some(self_param) = func.self_param(sema.db) {\n+        match self_param.access(sema.db) {\n+            hir::Access::Shared => (),\n+            hir::Access::Exclusive => h |= HighlightModifier::Mutable,\n+            hir::Access::Owned => {\n+                if let Some(receiver_ty) = method_call.expr().and_then(|it| sema.type_of_expr(&it))\n+                {\n+                    if !receiver_ty.is_copy(sema.db) {\n+                        h |= HighlightModifier::Consuming\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    Some(h)\n }\n \n fn highlight_name("}]}