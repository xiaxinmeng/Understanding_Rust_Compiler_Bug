{"sha": "5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2OTVjM2U5NDM1YTU4NzJlMjNhNmJiNjFjMWVhMGIzYWRhODNlZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-21T14:02:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-21T14:02:37Z"}, "message": "Auto merge of #41349 - eddyb:ty-contents, r=nikomatsakis\n\nrustc: replace TypeContents with two independent properties (is_freeze / needs_drop).\n\n`InteriorUnsafe` / `interior_unsafe` was replaced with a private lang-item `Freeze` auto trait in libcore.\n\n`OwnsDtor` / `needs_drop` was replaced with a specialized traversal that *doesn't* avoid caching results in case of a cycle, as the only cycles left can only occur in erroneous \"types with infinite sizes\", references and raw pointers not having destructors. Also, `Copy` is now checked at every step of the recursion.\n\nr? @nikomatsakis", "tree": {"sha": "8496a09a530afa6c2b2a5ead08b1d315abbbf590", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8496a09a530afa6c2b2a5ead08b1d315abbbf590"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "html_url": "https://github.com/rust-lang/rust/commit/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ed95009d8d5d50c4f7aee35ad89c30a2258ffa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ed95009d8d5d50c4f7aee35ad89c30a2258ffa9", "html_url": "https://github.com/rust-lang/rust/commit/4ed95009d8d5d50c4f7aee35ad89c30a2258ffa9"}, {"sha": "89bd3f39cadbbe0b361303ddbda2796ea7f39bb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/89bd3f39cadbbe0b361303ddbda2796ea7f39bb9", "html_url": "https://github.com/rust-lang/rust/commit/89bd3f39cadbbe0b361303ddbda2796ea7f39bb9"}], "stats": {"total": 540, "additions": 223, "deletions": 317}, "files": [{"sha": "cd87b27d4f1aa65650ce896b85ecf0411d4f0c08", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -151,6 +151,7 @@ pub fn build_startup_objects(build: &Build, for_compiler: &Compiler, target: &st\n         if !up_to_date(src_file, dst_file) {\n             let mut cmd = Command::new(&compiler_path);\n             build.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n+                        .arg(\"--cfg\").arg(format!(\"stage{}\", compiler.stage))\n                         .arg(\"--target\").arg(target)\n                         .arg(\"--emit=obj\")\n                         .arg(\"--out-dir\").arg(dst_dir)"}, {"sha": "c0aa650a1e854735b6aca0746e14bae1b65bd360", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -16,6 +16,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use cell::UnsafeCell;\n use cmp;\n use hash::Hash;\n use hash::Hasher;\n@@ -553,3 +554,19 @@ mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe impl<'a, T: Send + ?Sized> Send for &'a mut T {}\n }\n+\n+/// Compiler-internal trait used to determine whether a type contains\n+/// any `UnsafeCell` internally, but not through an indirection.\n+/// This affects, for example, whether a `static` of that type is\n+/// placed in read-only static memory or writable static memory.\n+#[cfg_attr(not(stage0), lang = \"freeze\")]\n+unsafe trait Freeze {}\n+\n+unsafe impl Freeze for .. {}\n+\n+impl<T: ?Sized> !Freeze for UnsafeCell<T> {}\n+unsafe impl<T: ?Sized> Freeze for PhantomData<T> {}\n+unsafe impl<T: ?Sized> Freeze for *const T {}\n+unsafe impl<T: ?Sized> Freeze for *mut T {}\n+unsafe impl<'a, T: ?Sized> Freeze for &'a T {}\n+unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}"}, {"sha": "32dfb63d6150a5933d13294120e30a459ed4487f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -274,6 +274,7 @@ language_item_table! {\n     UnsizeTraitLangItem,             \"unsize\",                  unsize_trait;\n     CopyTraitLangItem,               \"copy\",                    copy_trait;\n     SyncTraitLangItem,               \"sync\",                    sync_trait;\n+    FreezeTraitLangItem,             \"freeze\",                  freeze_trait;\n \n     DropTraitLangItem,               \"drop\",                    drop_trait;\n "}, {"sha": "e14295982916f44ad0578777db464581b6a4554d", "filename": "src/librustc/ty/contents.rs", "status": "removed", "additions": 0, "deletions": 255, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/4ed95009d8d5d50c4f7aee35ad89c30a2258ffa9/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed95009d8d5d50c4f7aee35ad89c30a2258ffa9/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=4ed95009d8d5d50c4f7aee35ad89c30a2258ffa9", "patch": "@@ -1,255 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use hir::def_id::{DefId};\n-use ty::{self, Ty, TyCtxt};\n-use util::common::MemoizationMap;\n-use util::nodemap::FxHashMap;\n-\n-use std::fmt;\n-use std::ops;\n-\n-use syntax::ast;\n-\n-/// Type contents is how the type checker reasons about kinds.\n-/// They track what kinds of things are found within a type.  You can\n-/// think of them as kind of an \"anti-kind\".  They track the kinds of values\n-/// and thinks that are contained in types.  Having a larger contents for\n-/// a type tends to rule that type *out* from various kinds.  For example,\n-/// a type that contains a reference is not sendable.\n-///\n-/// The reason we compute type contents and not kinds is that it is\n-/// easier for me (nmatsakis) to think about what is contained within\n-/// a type than to think about what is *not* contained within a type.\n-#[derive(Clone, Copy)]\n-pub struct TypeContents {\n-    pub bits: u64\n-}\n-\n-macro_rules! def_type_content_sets {\n-    (mod $mname:ident { $($name:ident = $bits:expr),+ }) => {\n-        #[allow(non_snake_case)]\n-        mod $mname {\n-            use super::TypeContents;\n-            $(\n-                #[allow(non_upper_case_globals)]\n-                pub const $name: TypeContents = TypeContents { bits: $bits };\n-             )+\n-        }\n-    }\n-}\n-\n-def_type_content_sets! {\n-    mod TC {\n-        None                                = 0b0000_0000__0000_0000__0000,\n-\n-        // Things that are interior to the value (first nibble):\n-        InteriorUnsafe                      = 0b0000_0000__0000_0000__0010,\n-        InteriorParam                       = 0b0000_0000__0000_0000__0100,\n-        // InteriorAll                         = 0b00000000__00000000__1111,\n-\n-        // Things that are owned by the value (second and third nibbles):\n-        OwnsDtor                            = 0b0000_0000__0000_0010__0000,\n-        // OwnsAll                             = 0b0000_0000__1111_1111__0000,\n-\n-        // All bits\n-        All                                 = 0b1111_1111__1111_1111__1111\n-    }\n-}\n-\n-impl TypeContents {\n-    pub fn when(&self, cond: bool) -> TypeContents {\n-        if cond {*self} else {TC::None}\n-    }\n-\n-    pub fn intersects(&self, tc: TypeContents) -> bool {\n-        (self.bits & tc.bits) != 0\n-    }\n-\n-    pub fn interior_param(&self) -> bool {\n-        self.intersects(TC::InteriorParam)\n-    }\n-\n-    pub fn interior_unsafe(&self) -> bool {\n-        self.intersects(TC::InteriorUnsafe)\n-    }\n-\n-    pub fn needs_drop(&self, _: TyCtxt) -> bool {\n-        self.intersects(TC::OwnsDtor)\n-    }\n-\n-    pub fn union<I, T, F>(v: I, mut f: F) -> TypeContents where\n-        I: IntoIterator<Item=T>,\n-        F: FnMut(T) -> TypeContents,\n-    {\n-        v.into_iter().fold(TC::None, |tc, ty| tc | f(ty))\n-    }\n-}\n-\n-impl ops::BitOr for TypeContents {\n-    type Output = TypeContents;\n-\n-    fn bitor(self, other: TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits | other.bits}\n-    }\n-}\n-\n-impl ops::BitAnd for TypeContents {\n-    type Output = TypeContents;\n-\n-    fn bitand(self, other: TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits & other.bits}\n-    }\n-}\n-\n-impl ops::Sub for TypeContents {\n-    type Output = TypeContents;\n-\n-    fn sub(self, other: TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits & !other.bits}\n-    }\n-}\n-\n-impl fmt::Debug for TypeContents {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TypeContents({:b})\", self.bits)\n-    }\n-}\n-\n-impl<'a, 'tcx> ty::TyS<'tcx> {\n-    pub fn type_contents(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> TypeContents {\n-        return tcx.tc_cache.memoize(self, || tc_ty(tcx, self, &mut FxHashMap()));\n-\n-        fn tc_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           ty: Ty<'tcx>,\n-                           cache: &mut FxHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n-        {\n-            // Subtle: Note that we are *not* using tcx.tc_cache here but rather a\n-            // private cache for this walk.  This is needed in the case of cyclic\n-            // types like:\n-            //\n-            //     struct List { next: Box<Option<List>>, ... }\n-            //\n-            // When computing the type contents of such a type, we wind up deeply\n-            // recursing as we go.  So when we encounter the recursive reference\n-            // to List, we temporarily use TC::None as its contents.  Later we'll\n-            // patch up the cache with the correct value, once we've computed it\n-            // (this is basically a co-inductive process, if that helps).  So in\n-            // the end we'll compute TC::OwnsOwned, in this case.\n-            //\n-            // The problem is, as we are doing the computation, we will also\n-            // compute an *intermediate* contents for, e.g., Option<List> of\n-            // TC::None.  This is ok during the computation of List itself, but if\n-            // we stored this intermediate value into tcx.tc_cache, then later\n-            // requests for the contents of Option<List> would also yield TC::None\n-            // which is incorrect.  This value was computed based on the crutch\n-            // value for the type contents of list.  The correct value is\n-            // TC::OwnsOwned.  This manifested as issue #4821.\n-            if let Some(tc) = cache.get(&ty) {\n-                return *tc;\n-            }\n-            // Must check both caches!\n-            if let Some(tc) = tcx.tc_cache.borrow().get(&ty) {\n-                return *tc;\n-            }\n-            cache.insert(ty, TC::None);\n-\n-            let result = match ty.sty {\n-                // usize and isize are ffi-unsafe\n-                ty::TyUint(ast::UintTy::Us) | ty::TyInt(ast::IntTy::Is) => {\n-                    TC::None\n-                }\n-\n-                // Scalar and unique types are sendable, and durable\n-                ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n-                ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n-                ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar => {\n-                    TC::None\n-                }\n-\n-                ty::TyDynamic(..) => {\n-                    TC::All - TC::InteriorParam\n-                }\n-\n-                ty::TyRawPtr(_) => {\n-                    TC::None\n-                }\n-\n-                ty::TyRef(..) => {\n-                    TC::None\n-                }\n-\n-                ty::TyArray(ty, _) => {\n-                    tc_ty(tcx, ty, cache)\n-                }\n-\n-                ty::TySlice(ty) => {\n-                    tc_ty(tcx, ty, cache)\n-                }\n-                ty::TyStr => TC::None,\n-\n-                ty::TyClosure(def_id, ref substs) => {\n-                    TypeContents::union(\n-                        substs.upvar_tys(def_id, tcx),\n-                        |ty| tc_ty(tcx, &ty, cache))\n-                }\n-\n-                ty::TyTuple(ref tys, _) => {\n-                    TypeContents::union(&tys[..],\n-                                        |ty| tc_ty(tcx, *ty, cache))\n-                }\n-\n-                ty::TyAdt(def, substs) => {\n-                    let mut res =\n-                        TypeContents::union(&def.variants, |v| {\n-                            TypeContents::union(&v.fields, |f| {\n-                                tc_ty(tcx, f.ty(tcx, substs), cache)\n-                            })\n-                        });\n-\n-                    if def.is_union() {\n-                        // unions don't have destructors regardless of the child types\n-                        res = res - TC::OwnsDtor;\n-                    }\n-\n-                    if def.has_dtor(tcx) {\n-                        res = res | TC::OwnsDtor;\n-                    }\n-\n-                    apply_lang_items(tcx, def.did, res)\n-                }\n-\n-                ty::TyProjection(..) |\n-                ty::TyParam(_) |\n-                ty::TyAnon(..) => {\n-                    TC::All\n-                }\n-\n-                ty::TyInfer(_) |\n-                ty::TyError => {\n-                    bug!(\"asked to compute contents of error type\");\n-                }\n-            };\n-\n-            cache.insert(ty, result);\n-            result\n-        }\n-\n-        fn apply_lang_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      did: DefId, tc: TypeContents)\n-                                      -> TypeContents {\n-            if Some(did) == tcx.lang_items.unsafe_cell_type() {\n-                tc | TC::InteriorUnsafe\n-            } else {\n-                tc\n-            }\n-        }\n-    }\n-}"}, {"sha": "a41629258716d51dc991639bc4654c129daaa48e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -436,9 +436,6 @@ pub struct GlobalCtxt<'tcx> {\n     // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n \n-    // Cache for the type-contents routine. FIXME -- track deps?\n-    pub tc_cache: RefCell<FxHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n-\n     // FIXME dep tracking -- should be harmless enough\n     pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n \n@@ -708,7 +705,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             freevars: RefCell::new(resolutions.freevars),\n             maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n             rcache: RefCell::new(FxHashMap()),\n-            tc_cache: RefCell::new(FxHashMap()),\n             normalized_cache: RefCell::new(FxHashMap()),\n             inhabitedness_cache: RefCell::new(FxHashMap()),\n             lang_items: lang_items,"}, {"sha": "5c0889976c21a7bd8f462030899ac58b51429368", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 36, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -71,7 +71,6 @@ pub use self::sty::InferTy::*;\n pub use self::sty::Region::*;\n pub use self::sty::TypeVariants::*;\n \n-pub use self::contents::TypeContents;\n pub use self::context::{TyCtxt, GlobalArenas, tls};\n pub use self::context::{Lift, TypeckTables};\n \n@@ -99,7 +98,6 @@ pub mod walk;\n pub mod wf;\n pub mod util;\n \n-mod contents;\n mod context;\n mod flags;\n mod instance;\n@@ -425,6 +423,10 @@ bitflags! {\n         const IS_SIZED          = 1 << 17,\n         const MOVENESS_CACHED   = 1 << 18,\n         const MOVES_BY_DEFAULT  = 1 << 19,\n+        const FREEZENESS_CACHED = 1 << 20,\n+        const IS_FREEZE         = 1 << 21,\n+        const NEEDS_DROP_CACHED = 1 << 22,\n+        const NEEDS_DROP        = 1 << 23,\n     }\n }\n \n@@ -1181,6 +1183,9 @@ pub struct ParameterEnvironment<'tcx> {\n \n     /// A cache for `type_is_sized`\n     pub is_sized_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n+\n+    /// A cache for `type_is_freeze`\n+    pub is_freeze_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n }\n \n impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n@@ -1195,6 +1200,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             free_id_outlive: self.free_id_outlive,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n+            is_freeze_cache: RefCell::new(FxHashMap()),\n         }\n     }\n \n@@ -2375,40 +2381,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         Some(self.item_mir(did))\n     }\n \n-    /// If `type_needs_drop` returns true, then `ty` is definitely\n-    /// non-copy and *might* have a destructor attached; if it returns\n-    /// false, then `ty` definitely has no destructor (i.e. no drop glue).\n-    ///\n-    /// (Note that this implies that if `ty` has a destructor attached,\n-    /// then `type_needs_drop` will definitely return `true` for `ty`.)\n-    pub fn type_needs_drop_given_env(self,\n-                                     ty: Ty<'gcx>,\n-                                     param_env: &ty::ParameterEnvironment<'gcx>) -> bool {\n-        // Issue #22536: We first query type_moves_by_default.  It sees a\n-        // normalized version of the type, and therefore will definitely\n-        // know whether the type implements Copy (and thus needs no\n-        // cleanup/drop/zeroing) ...\n-        let tcx = self.global_tcx();\n-        let implements_copy = !ty.moves_by_default(tcx, param_env, DUMMY_SP);\n-\n-        if implements_copy { return false; }\n-\n-        // ... (issue #22536 continued) but as an optimization, still use\n-        // prior logic of asking if the `needs_drop` bit is set; we need\n-        // not zero non-Copy types if they have no destructor.\n-\n-        // FIXME(#22815): Note that calling `ty::type_contents` is a\n-        // conservative heuristic; it may report that `needs_drop` is set\n-        // when actual type does not actually have a destructor associated\n-        // with it. But since `ty` absolutely did not have the `Copy`\n-        // bound attached (see above), it is sound to treat it as having a\n-        // destructor (e.g. zero its memory on move).\n-\n-        let contents = ty.type_contents(tcx);\n-        debug!(\"type_needs_drop ty={:?} contents={:?}\", ty, contents);\n-        contents.needs_drop(tcx)\n-    }\n-\n     /// Get the attributes of a definition.\n     pub fn get_attrs(self, did: DefId) -> Cow<'gcx, [ast::Attribute]> {\n         if let Some(id) = self.hir.as_local_node_id(did) {\n@@ -2531,6 +2503,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             free_id_outlive: free_id_outlive,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n+            is_freeze_cache: RefCell::new(FxHashMap()),\n         }\n     }\n \n@@ -2603,6 +2576,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             free_id_outlive: free_id_outlive,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n+            is_freeze_cache: RefCell::new(FxHashMap()),\n         };\n \n         let cause = traits::ObligationCause::misc(span, free_id_outlive.node_id(&self.region_maps));"}, {"sha": "49d79f6545e2dd682b3cb1ff55ac936f7fced871", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 160, "deletions": 1, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -21,7 +21,7 @@ use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n use ty::TypeVariants::*;\n use util::common::ErrorReported;\n-use util::nodemap::FxHashMap;\n+use util::nodemap::{FxHashMap, FxHashSet};\n use middle::lang_items;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n@@ -655,6 +655,165 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         result\n     }\n \n+    /// Returns `true` if and only if there are no `UnsafeCell`s\n+    /// nested within the type (ignoring `PhantomData` or pointers).\n+    #[inline]\n+    pub fn is_freeze(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                     param_env: &ParameterEnvironment<'tcx>,\n+                     span: Span) -> bool\n+    {\n+        if self.flags.get().intersects(TypeFlags::FREEZENESS_CACHED) {\n+            return self.flags.get().intersects(TypeFlags::IS_FREEZE);\n+        }\n+\n+        self.is_freeze_uncached(tcx, param_env, span)\n+    }\n+\n+    fn is_freeze_uncached(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          param_env: &ParameterEnvironment<'tcx>,\n+                          span: Span) -> bool {\n+        assert!(!self.needs_infer());\n+\n+        // Fast-path for primitive types\n+        let result = match self.sty {\n+            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n+            TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n+            TyStr | TyNever => Some(true),\n+\n+            TyArray(..) | TySlice(_) |\n+            TyTuple(..) | TyClosure(..) | TyAdt(..) |\n+            TyDynamic(..) | TyProjection(..) | TyParam(..) |\n+            TyInfer(..) | TyAnon(..) | TyError => None\n+        }.unwrap_or_else(|| {\n+            self.impls_bound(tcx, param_env, tcx.require_lang_item(lang_items::FreezeTraitLangItem),\n+                              &param_env.is_freeze_cache, span) });\n+\n+        if !self.has_param_types() && !self.has_self_ty() {\n+            self.flags.set(self.flags.get() | if result {\n+                TypeFlags::FREEZENESS_CACHED | TypeFlags::IS_FREEZE\n+            } else {\n+                TypeFlags::FREEZENESS_CACHED\n+            });\n+        }\n+\n+        result\n+    }\n+\n+    /// If `ty.needs_drop(...)` returns `true`, then `ty` is definitely\n+    /// non-copy and *might* have a destructor attached; if it returns\n+    /// `false`, then `ty` definitely has no destructor (i.e. no drop glue).\n+    ///\n+    /// (Note that this implies that if `ty` has a destructor attached,\n+    /// then `needs_drop` will definitely return `true` for `ty`.)\n+    #[inline]\n+    pub fn needs_drop(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    param_env: &ty::ParameterEnvironment<'tcx>) -> bool {\n+        if self.flags.get().intersects(TypeFlags::NEEDS_DROP_CACHED) {\n+            return self.flags.get().intersects(TypeFlags::NEEDS_DROP);\n+        }\n+\n+        self.needs_drop_uncached(tcx, param_env, &mut FxHashSet())\n+    }\n+\n+    fn needs_drop_inner(&'tcx self,\n+                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        param_env: &ty::ParameterEnvironment<'tcx>,\n+                        stack: &mut FxHashSet<Ty<'tcx>>)\n+                        -> bool {\n+        if self.flags.get().intersects(TypeFlags::NEEDS_DROP_CACHED) {\n+            return self.flags.get().intersects(TypeFlags::NEEDS_DROP);\n+        }\n+\n+        // This should be reported as an error by `check_representable`.\n+        //\n+        // Consider the type as not needing drop in the meanwhile to avoid\n+        // further errors.\n+        if let Some(_) = stack.replace(self) {\n+            return false;\n+        }\n+\n+        let needs_drop = self.needs_drop_uncached(tcx, param_env, stack);\n+\n+        // \"Pop\" the cycle detection \"stack\".\n+        stack.remove(self);\n+\n+        needs_drop\n+    }\n+\n+    fn needs_drop_uncached(&'tcx self,\n+                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           param_env: &ty::ParameterEnvironment<'tcx>,\n+                           stack: &mut FxHashSet<Ty<'tcx>>)\n+                           -> bool {\n+        assert!(!self.needs_infer());\n+\n+        let result = match self.sty {\n+            // Fast-path for primitive types\n+            ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n+            ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n+            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n+            ty::TyRawPtr(_) | ty::TyRef(..) | ty::TyStr => false,\n+\n+            // Issue #22536: We first query type_moves_by_default.  It sees a\n+            // normalized version of the type, and therefore will definitely\n+            // know whether the type implements Copy (and thus needs no\n+            // cleanup/drop/zeroing) ...\n+            _ if !self.moves_by_default(tcx, param_env, DUMMY_SP) => false,\n+\n+            // ... (issue #22536 continued) but as an optimization, still use\n+            // prior logic of asking for the structural \"may drop\".\n+\n+            // FIXME(#22815): Note that this is a conservative heuristic;\n+            // it may report that the type \"may drop\" when actual type does\n+            // not actually have a destructor associated with it. But since\n+            // the type absolutely did not have the `Copy` bound attached\n+            // (see above), it is sound to treat it as having a destructor.\n+\n+            // User destructors are the only way to have concrete drop types.\n+            ty::TyAdt(def, _) if def.has_dtor(tcx) => true,\n+\n+            // Can refer to a type which may drop.\n+            // FIXME(eddyb) check this against a ParameterEnvironment.\n+            ty::TyDynamic(..) | ty::TyProjection(..) | ty::TyParam(_) |\n+            ty::TyAnon(..) | ty::TyInfer(_) | ty::TyError => true,\n+\n+            // Structural recursion.\n+            ty::TyArray(ty, _) | ty::TySlice(ty) => {\n+                ty.needs_drop_inner(tcx, param_env, stack)\n+            }\n+\n+            ty::TyClosure(def_id, ref substs) => {\n+                substs.upvar_tys(def_id, tcx)\n+                    .any(|ty| ty.needs_drop_inner(tcx, param_env, stack))\n+            }\n+\n+            ty::TyTuple(ref tys, _) => {\n+                tys.iter().any(|ty| ty.needs_drop_inner(tcx, param_env, stack))\n+            }\n+\n+            // unions don't have destructors regardless of the child types\n+            ty::TyAdt(def, _) if def.is_union() => false,\n+\n+            ty::TyAdt(def, substs) => {\n+                def.variants.iter().any(|v| {\n+                    v.fields.iter().any(|f| {\n+                        f.ty(tcx, substs).needs_drop_inner(tcx, param_env, stack)\n+                    })\n+                })\n+            }\n+        };\n+\n+        if !self.has_param_types() && !self.has_self_ty() {\n+            self.flags.set(self.flags.get() | if result {\n+                TypeFlags::NEEDS_DROP_CACHED | TypeFlags::NEEDS_DROP\n+            } else {\n+                TypeFlags::NEEDS_DROP_CACHED\n+            });\n+        }\n+\n+        result\n+    }\n+\n     #[inline]\n     pub fn layout<'lcx>(&'tcx self, infcx: &InferCtxt<'a, 'tcx, 'lcx>)\n                         -> Result<&'tcx Layout, LayoutError<'tcx>> {"}, {"sha": "de5613dbfaa38b183c8d34d4584c233191501805", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -322,7 +322,7 @@ fn on_all_drop_children_bits<'a, 'tcx, F>(\n         let ty = lvalue.ty(mir, tcx).to_ty(tcx);\n         debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, lvalue, ty);\n \n-        if tcx.type_needs_drop_given_env(ty, &ctxt.param_env) {\n+        if ty.needs_drop(tcx, &ctxt.param_env) {\n             each_child(child);\n         } else {\n             debug!(\"on_all_drop_children_bits - skipping\")"}, {"sha": "1c69f3cff172a4321a49062bfcffcf3397e6c0fa", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -1152,7 +1152,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n             let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);\n             for field in vdata.fields() {\n                 let field_ty = ctx.tcx.item_type(ctx.tcx.hir.local_def_id(field.id));\n-                if ctx.tcx.type_needs_drop_given_env(field_ty, param_env) {\n+                if field_ty.needs_drop(ctx.tcx, param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,\n                                   \"union contains a field with possibly non-trivial drop code, \\"}, {"sha": "db9da2a280b94cc70af7e43645fef9e0e1b247bf", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                   type with inference types/regions\",\n                  ty);\n         });\n-        self.tcx.type_needs_drop_given_env(ty, &self.infcx.parameter_environment)\n+        ty.needs_drop(self.tcx.global_tcx(), &self.infcx.parameter_environment)\n     }\n \n     pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "892d67ac23725f2bd7015be805006a96bee95190", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -357,7 +357,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     // a regular goto.\n                     let ty = location.ty(&callee_mir, tcx).subst(tcx, callsite.substs);\n                     let ty = ty.to_ty(tcx);\n-                    if tcx.type_needs_drop_given_env(ty, &param_env) {\n+                    if ty.needs_drop(tcx, &param_env) {\n                         cost += CALL_PENALTY;\n                         if let Some(unwind) = unwind {\n                             work_list.push(unwind);"}, {"sha": "526c1488ab480e96fe6873c985548f3cb7d8b610", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -80,10 +80,10 @@ impl<'a, 'tcx> Qualif {\n     fn restrict(&mut self, ty: Ty<'tcx>,\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 param_env: &ty::ParameterEnvironment<'tcx>) {\n-        if !ty.type_contents(tcx).interior_unsafe() {\n+        if ty.is_freeze(tcx, param_env, DUMMY_SP) {\n             *self = *self - Qualif::MUTABLE_INTERIOR;\n         }\n-        if !tcx.type_needs_drop_given_env(ty, param_env) {\n+        if !ty.needs_drop(tcx, param_env) {\n             *self = *self - Qualif::NEEDS_DROP;\n         }\n     }"}, {"sha": "07025fcfdb944de518e3e1dff13abb71f1611a48", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -277,8 +277,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let mut fields = fields;\n         fields.retain(|&(ref lvalue, _)| {\n-            self.tcx().type_needs_drop_given_env(\n-                self.lvalue_ty(lvalue), self.elaborator.param_env())\n+            self.lvalue_ty(lvalue).needs_drop(self.tcx(), self.elaborator.param_env())\n         });\n \n         debug!(\"drop_ladder - fields needing drop: {:?}\", fields);"}, {"sha": "fdb67522133781f74b3c2430ab58bc3aec917006", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -46,7 +46,7 @@ use rustc::lint::builtin::CONST_ERR;\n \n use rustc::hir::{self, PatKind, RangeEnd};\n use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n use std::collections::hash_map::Entry;\n@@ -85,11 +85,11 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n     // Adds the worst effect out of all the values of one type.\n     fn add_type(&mut self, ty: Ty<'gcx>) {\n-        if ty.type_contents(self.tcx).interior_unsafe() {\n+        if !ty.is_freeze(self.tcx, &self.param_env, DUMMY_SP) {\n             self.promotable = false;\n         }\n \n-        if self.tcx.type_needs_drop_given_env(ty, &self.param_env) {\n+        if ty.needs_drop(self.tcx, &self.param_env) {\n             self.promotable = false;\n         }\n     }"}, {"sha": "e0a75f3caa7b36976e003b274603bc5749bdf513", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -746,13 +746,13 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as\n                 // both `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely\n                 // on memory dependencies rather than pointer equality\n-                let interior_unsafe = mt.ty.type_contents(ccx.tcx()).interior_unsafe();\n+                let is_freeze = ccx.shared().type_is_freeze(mt.ty);\n \n-                if mt.mutbl != hir::MutMutable && !interior_unsafe {\n+                if mt.mutbl != hir::MutMutable && is_freeze {\n                     arg.attrs.set(ArgAttribute::NoAlias);\n                 }\n \n-                if mt.mutbl == hir::MutImmutable && !interior_unsafe {\n+                if mt.mutbl == hir::MutImmutable && is_freeze {\n                     arg.attrs.set(ArgAttribute::ReadOnly);\n                 }\n "}, {"sha": "eb3ac309be16d252353b10468c59927b3dd4d133", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -261,8 +261,7 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n         if m != hir::MutMutable {\n-            let tcontents = ty.type_contents(ccx.tcx());\n-            if !tcontents.interior_unsafe() {\n+            if ccx.shared().type_is_freeze(ty) {\n                 llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }\n         }"}, {"sha": "1d1921bf7b96dd1ee62f1e146ad08cb0507d39a0", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -392,13 +392,17 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     }\n \n     pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        self.tcx.type_needs_drop_given_env(ty, &self.empty_param_env)\n+        ty.needs_drop(self.tcx, &self.empty_param_env)\n     }\n \n     pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n         ty.is_sized(self.tcx, &self.empty_param_env, DUMMY_SP)\n     }\n \n+    pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n+        ty.is_freeze(self.tcx, &self.empty_param_env, DUMMY_SP)\n+    }\n+\n     pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {\n         &self.exported_symbols\n     }"}, {"sha": "e8b92aab1da1e556f2518b9f7aac050ace6cd928", "filename": "src/rtstartup/rsbegin.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Frtstartup%2Frsbegin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Frtstartup%2Frsbegin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frtstartup%2Frsbegin.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -22,7 +22,7 @@\n // object (usually called `crtX.o), which then invokes initialization callbacks\n // of other runtime components (registered via yet another special image section).\n \n-#![feature(no_core, lang_items)]\n+#![feature(no_core, lang_items, optin_builtin_traits)]\n #![crate_type=\"rlib\"]\n #![no_core]\n #![allow(non_camel_case_types)]\n@@ -31,9 +31,12 @@\n trait Sized {}\n #[lang = \"sync\"]\n trait Sync {}\n+impl Sync for .. {}\n #[lang = \"copy\"]\n trait Copy {}\n-impl<T> Sync for T {}\n+#[cfg_attr(not(stage0), lang = \"freeze\")]\n+trait Freeze {}\n+impl Freeze for .. {}\n \n #[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n pub mod eh_frames {"}, {"sha": "8ab8f4715755ddbef149777ab726c29d023afe0f", "filename": "src/test/run-make/simd-ffi/simd.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -12,7 +12,7 @@\n #![crate_type = \"lib\"]\n // we can compile to a variety of platforms, because we don't need\n // cross-compiled standard libraries.\n-#![feature(no_core)]\n+#![feature(no_core, optin_builtin_traits)]\n #![no_core]\n \n #![feature(repr_simd, simd_ffi, link_llvm_intrinsics, lang_items)]\n@@ -78,3 +78,7 @@ pub trait Copy { }\n pub mod marker {\n     pub use Copy;\n }\n+\n+#[lang = \"freeze\"]\n+trait Freeze {}\n+impl Freeze for .. {}"}, {"sha": "af24c3b460b2e844d43123eb9aaf9f6725967996", "filename": "src/test/run-make/target-specs/foo.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5695c3e9435a5872e23a6bb61c1ea0b3ada83eef/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs?ref=5695c3e9435a5872e23a6bb61c1ea0b3ada83eef", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(lang_items, no_core)]\n+#![feature(lang_items, no_core, optin_builtin_traits)]\n #![no_core]\n \n #[lang=\"copy\"]\n@@ -17,6 +17,10 @@ trait Copy { }\n #[lang=\"sized\"]\n trait Sized { }\n \n+#[lang = \"freeze\"]\n+trait Freeze {}\n+impl Freeze for .. {}\n+\n #[lang=\"start\"]\n fn start(_main: *const u8, _argc: isize, _argv: *const *const u8) -> isize { 0 }\n "}]}