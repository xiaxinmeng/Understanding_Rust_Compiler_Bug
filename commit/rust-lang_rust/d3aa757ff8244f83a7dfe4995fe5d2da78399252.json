{"sha": "d3aa757ff8244f83a7dfe4995fe5d2da78399252", "node_id": "C_kwDOAAsO6NoAKGQzYWE3NTdmZjgyNDRmODNhN2RmZTQ5OTVmZTVkMmRhNzgzOTkyNTI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-04T20:25:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-04T20:25:01Z"}, "message": "Rollup merge of #100058 - TaKO8Ki:suggest-positional-formatting-argument-instead-of-format-args-capture, r=estebank\n\nSuggest a positional formatting argument instead of a captured argument\n\nThis patch fixes a part of #96999.\n\nfixes #98241\nfixes #97311\n\nr? `@estebank`", "tree": {"sha": "bf1b0bccfbbb7eb39b3a67a2b9a9f5a01dd08fc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf1b0bccfbbb7eb39b3a67a2b9a9f5a01dd08fc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3aa757ff8244f83a7dfe4995fe5d2da78399252", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi7CsdCRBK7hj4Ov3rIwAARVUIAF2iWTqouydSTb8y1Sd7oPbM\n8mhukQoB0jPnURHMIDLEfA3voDYp6Fj7o9HYekUktbc3oYMmQElUGMpmyuWJ2Mhr\nau/K54ADc/HN3YDrHTZZ93u547etcF+cbfhvVKj2Co2HLdDz4wdXHsgqrghkFLi0\n7vtl4ZiZKy7/B/8vz+2blRkJ9x2DSuh2zWmtuUokzeBGdx37vY+Ld3lD2L9GCx1N\nTKtR/LzB+sm7BxfR84NS3GkAIhS60p1dFWNc1MT6twSUeMMd56Ph76h4HQH4woNR\n/3gna0aS7rD8oXoUdCp9RBligfxyZpN7Rok5Dz8B3VsvUVAxicY2ZwhfAf03Kmo=\n=DEW9\n-----END PGP SIGNATURE-----\n", "payload": "tree bf1b0bccfbbb7eb39b3a67a2b9a9f5a01dd08fc6\nparent 87dd56f3d6546aba58c231d59cfc7c196e25b224\nparent 8c85c9936f6bc28b6e8e31bed8f4b1bd95c7e836\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1659644701 +0200\ncommitter GitHub <noreply@github.com> 1659644701 +0200\n\nRollup merge of #100058 - TaKO8Ki:suggest-positional-formatting-argument-instead-of-format-args-capture, r=estebank\n\nSuggest a positional formatting argument instead of a captured argument\n\nThis patch fixes a part of #96999.\n\nfixes #98241\nfixes #97311\n\nr? `@estebank`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3aa757ff8244f83a7dfe4995fe5d2da78399252", "html_url": "https://github.com/rust-lang/rust/commit/d3aa757ff8244f83a7dfe4995fe5d2da78399252", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3aa757ff8244f83a7dfe4995fe5d2da78399252/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87dd56f3d6546aba58c231d59cfc7c196e25b224", "url": "https://api.github.com/repos/rust-lang/rust/commits/87dd56f3d6546aba58c231d59cfc7c196e25b224", "html_url": "https://github.com/rust-lang/rust/commit/87dd56f3d6546aba58c231d59cfc7c196e25b224"}, {"sha": "8c85c9936f6bc28b6e8e31bed8f4b1bd95c7e836", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c85c9936f6bc28b6e8e31bed8f4b1bd95c7e836", "html_url": "https://github.com/rust-lang/rust/commit/8c85c9936f6bc28b6e8e31bed8f4b1bd95c7e836"}], "stats": {"total": 190, "additions": 182, "deletions": 8}, "files": [{"sha": "9eb96ec76800c8634355aae052d55bc7eca4450f", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d3aa757ff8244f83a7dfe4995fe5d2da78399252/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3aa757ff8244f83a7dfe4995fe5d2da78399252/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=d3aa757ff8244f83a7dfe4995fe5d2da78399252", "patch": "@@ -280,6 +280,11 @@ struct Context<'a, 'b> {\n     unused_names_lint: PositionalNamedArgsLint,\n }\n \n+pub struct FormatArg {\n+    expr: P<ast::Expr>,\n+    named: bool,\n+}\n+\n /// Parses the arguments from the given list of tokens, returning the diagnostic\n /// if there's a parse error so we can continue parsing other format!\n /// expressions.\n@@ -293,8 +298,8 @@ fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: TokenStream,\n-) -> PResult<'a, (P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<Symbol, (usize, Span)>)> {\n-    let mut args = Vec::<P<ast::Expr>>::new();\n+) -> PResult<'a, (P<ast::Expr>, Vec<FormatArg>, FxHashMap<Symbol, (usize, Span)>)> {\n+    let mut args = Vec::<FormatArg>::new();\n     let mut names = FxHashMap::<Symbol, (usize, Span)>::default();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n@@ -362,7 +367,7 @@ fn parse_args<'a>(\n                 let e = p.parse_expr()?;\n                 if let Some((prev, _)) = names.get(&ident.name) {\n                     ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", ident))\n-                        .span_label(args[*prev].span, \"previously here\")\n+                        .span_label(args[*prev].expr.span, \"previously here\")\n                         .span_label(e.span, \"duplicate argument\")\n                         .emit();\n                     continue;\n@@ -374,7 +379,7 @@ fn parse_args<'a>(\n                 // args. And remember the names.\n                 let slot = args.len();\n                 names.insert(ident.name, (slot, ident.span));\n-                args.push(e);\n+                args.push(FormatArg { expr: e, named: true });\n             }\n             _ => {\n                 let e = p.parse_expr()?;\n@@ -385,11 +390,11 @@ fn parse_args<'a>(\n                     );\n                     err.span_label(e.span, \"positional arguments must be before named arguments\");\n                     for pos in names.values() {\n-                        err.span_label(args[pos.0].span, \"named argument\");\n+                        err.span_label(args[pos.0].expr.span, \"named argument\");\n                     }\n                     err.emit();\n                 }\n-                args.push(e);\n+                args.push(FormatArg { expr: e, named: false });\n             }\n         }\n     }\n@@ -1214,7 +1219,7 @@ pub fn expand_preparsed_format_args(\n     ecx: &mut ExtCtxt<'_>,\n     sp: Span,\n     efmt: P<ast::Expr>,\n-    args: Vec<P<ast::Expr>>,\n+    args: Vec<FormatArg>,\n     names: FxHashMap<Symbol, (usize, Span)>,\n     append_newline: bool,\n ) -> P<ast::Expr> {\n@@ -1304,6 +1309,25 @@ pub fn expand_preparsed_format_args(\n                 e.span_label(fmt_span.from_inner(InnerSpan::new(span.start, span.end)), label);\n             }\n         }\n+        if err.should_be_replaced_with_positional_argument {\n+            let captured_arg_span =\n+                fmt_span.from_inner(InnerSpan::new(err.span.start, err.span.end));\n+            let positional_args = args.iter().filter(|arg| !arg.named).collect::<Vec<_>>();\n+            if let Ok(arg) = ecx.source_map().span_to_snippet(captured_arg_span) {\n+                let span = match positional_args.last() {\n+                    Some(arg) => arg.expr.span,\n+                    None => fmt_sp,\n+                };\n+                e.multipart_suggestion_verbose(\n+                    \"consider using a positional formatting argument instead\",\n+                    vec![\n+                        (captured_arg_span, positional_args.len().to_string()),\n+                        (span.shrink_to_hi(), format!(\", {}\", arg)),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n         e.emit();\n         return DummyResult::raw_expr(sp, true);\n     }\n@@ -1318,7 +1342,7 @@ pub fn expand_preparsed_format_args(\n \n     let mut cx = Context {\n         ecx,\n-        args,\n+        args: args.into_iter().map(|arg| arg.expr).collect(),\n         num_captured_args: 0,\n         arg_types,\n         arg_unique_types,"}, {"sha": "4890fade50faf8ef6ec57c673d82fd3ab3f80762", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d3aa757ff8244f83a7dfe4995fe5d2da78399252/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3aa757ff8244f83a7dfe4995fe5d2da78399252/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=d3aa757ff8244f83a7dfe4995fe5d2da78399252", "patch": "@@ -175,6 +175,7 @@ pub struct ParseError {\n     pub label: string::String,\n     pub span: InnerSpan,\n     pub secondary_label: Option<(string::String, InnerSpan)>,\n+    pub should_be_replaced_with_positional_argument: bool,\n }\n \n /// The parser structure for interpreting the input format string. This is\n@@ -236,6 +237,8 @@ impl<'a> Iterator for Parser<'a> {\n                                     lbrace_inner_offset.to(InnerOffset(rbrace_inner_offset.0 + 1)),\n                                 );\n                             }\n+                        } else {\n+                            self.suggest_positional_arg_instead_of_captured_arg(arg);\n                         }\n                         Some(NextArgument(arg))\n                     }\n@@ -313,6 +316,7 @@ impl<'a> Parser<'a> {\n             label: label.into(),\n             span,\n             secondary_label: None,\n+            should_be_replaced_with_positional_argument: false,\n         });\n     }\n \n@@ -336,6 +340,7 @@ impl<'a> Parser<'a> {\n             label: label.into(),\n             span,\n             secondary_label: None,\n+            should_be_replaced_with_positional_argument: false,\n         });\n     }\n \n@@ -407,6 +412,7 @@ impl<'a> Parser<'a> {\n                     label,\n                     span: pos.to(pos),\n                     secondary_label,\n+                    should_be_replaced_with_positional_argument: false,\n                 });\n                 None\n             }\n@@ -434,6 +440,7 @@ impl<'a> Parser<'a> {\n                     label,\n                     span: pos.to(pos),\n                     secondary_label,\n+                    should_be_replaced_with_positional_argument: false,\n                 });\n             } else {\n                 self.err(description, format!(\"expected `{:?}`\", c), pos.to(pos));\n@@ -750,6 +757,34 @@ impl<'a> Parser<'a> {\n         }\n         if found { Some(cur) } else { None }\n     }\n+\n+    fn suggest_positional_arg_instead_of_captured_arg(&mut self, arg: Argument<'a>) {\n+        if let Some(end) = self.consume_pos('.') {\n+            let byte_pos = self.to_span_index(end);\n+            let start = InnerOffset(byte_pos.0 + 1);\n+            let field = self.argument(start);\n+            // We can only parse `foo.bar` field access, any deeper nesting,\n+            // or another type of expression, like method calls, are not supported\n+            if !self.consume('}') {\n+                return;\n+            }\n+            if let ArgumentNamed(_) = arg.position {\n+                if let ArgumentNamed(_) = field.position {\n+                    self.errors.insert(\n+                        0,\n+                        ParseError {\n+                            description: \"field access isn't supported\".to_string(),\n+                            note: None,\n+                            label: \"not supported\".to_string(),\n+                            span: InnerSpan::new(arg.position_span.start, field.position_span.end),\n+                            secondary_label: None,\n+                            should_be_replaced_with_positional_argument: true,\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n }\n \n /// Finds the indices of all characters that have been processed and differ between the actual"}, {"sha": "f7244f6744f3a5a0ba657805966052f558d80e4a", "filename": "src/test/ui/fmt/struct-field-as-captured-argument.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3aa757ff8244f83a7dfe4995fe5d2da78399252/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d3aa757ff8244f83a7dfe4995fe5d2da78399252/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.fixed?ref=d3aa757ff8244f83a7dfe4995fe5d2da78399252", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#[derive(Debug)]\n+struct Foo {\n+    field: usize,\n+}\n+\n+fn main() {\n+    let foo = Foo { field: 0 };\n+    let bar = 3;\n+    format!(\"{0}\", foo.field); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{1} {} {bar}\", \"aa\", foo.field); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{2} {} {1} {bar}\", \"aa\", \"bb\", foo.field); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{1} {} {baz}\", \"aa\", foo.field, baz = 3); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{1:?} {} {baz}\", \"aa\", foo.field, baz = 3); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{1:#?} {} {baz}\", \"aa\", foo.field, baz = 3); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{1:.3} {} {baz}\", \"aa\", foo.field, baz = 3); //~ ERROR invalid format string: field access isn't supported\n+}"}, {"sha": "ab5f2552bd323c38a90555547ebd1f2822fc38ad", "filename": "src/test/ui/fmt/struct-field-as-captured-argument.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3aa757ff8244f83a7dfe4995fe5d2da78399252/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3aa757ff8244f83a7dfe4995fe5d2da78399252/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.rs?ref=d3aa757ff8244f83a7dfe4995fe5d2da78399252", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#[derive(Debug)]\n+struct Foo {\n+    field: usize,\n+}\n+\n+fn main() {\n+    let foo = Foo { field: 0 };\n+    let bar = 3;\n+    format!(\"{foo.field}\"); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field} {} {bar}\", \"aa\"); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field} {} {1} {bar}\", \"aa\", \"bb\"); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field} {} {baz}\", \"aa\", baz = 3); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field:?} {} {baz}\", \"aa\", baz = 3); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field:#?} {} {baz}\", \"aa\", baz = 3); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field:.3} {} {baz}\", \"aa\", baz = 3); //~ ERROR invalid format string: field access isn't supported\n+}"}, {"sha": "7ea8b4068f27283ddcb35d69d1f01676a8f7395f", "filename": "src/test/ui/fmt/struct-field-as-captured-argument.stderr", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d3aa757ff8244f83a7dfe4995fe5d2da78399252/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3aa757ff8244f83a7dfe4995fe5d2da78399252/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.stderr?ref=d3aa757ff8244f83a7dfe4995fe5d2da78399252", "patch": "@@ -0,0 +1,79 @@\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:11:15\n+   |\n+LL |     format!(\"{foo.field}\");\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{0}\", foo.field);\n+   |               ~  +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:12:15\n+   |\n+LL |     format!(\"{foo.field} {} {bar}\", \"aa\");\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{1} {} {bar}\", \"aa\", foo.field);\n+   |               ~                 +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:13:15\n+   |\n+LL |     format!(\"{foo.field} {} {1} {bar}\", \"aa\", \"bb\");\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{2} {} {1} {bar}\", \"aa\", \"bb\", foo.field);\n+   |               ~                           +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:14:15\n+   |\n+LL |     format!(\"{foo.field} {} {baz}\", \"aa\", baz = 3);\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{1} {} {baz}\", \"aa\", foo.field, baz = 3);\n+   |               ~                 +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:15:15\n+   |\n+LL |     format!(\"{foo.field:?} {} {baz}\", \"aa\", baz = 3);\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{1:?} {} {baz}\", \"aa\", foo.field, baz = 3);\n+   |               ~                   +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:16:15\n+   |\n+LL |     format!(\"{foo.field:#?} {} {baz}\", \"aa\", baz = 3);\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{1:#?} {} {baz}\", \"aa\", foo.field, baz = 3);\n+   |               ~                    +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:17:15\n+   |\n+LL |     format!(\"{foo.field:.3} {} {baz}\", \"aa\", baz = 3);\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{1:.3} {} {baz}\", \"aa\", foo.field, baz = 3);\n+   |               ~                    +++++++++++\n+\n+error: aborting due to 7 previous errors\n+"}]}