{"sha": "9ad3ef13ac6b9a1c73f1129f0925740607a0961a", "node_id": "C_kwDOAAsO6NoAKDlhZDNlZjEzYWM2YjlhMWM3M2YxMTI5ZjA5MjU3NDA2MDdhMDk2MWE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-07-04T21:11:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-04T21:11:11Z"}, "message": "Rollup merge of #98814 - fmease:minimal-fix-for-issue-97933, r=GuillaumeGomez\n\nrustdoc: Censor certain complex unevaluated const exprs\n\nFixes #97933.\n\nThis is more of a hotfix for the aforementioned issue. By that, I mean that my proposed patch is\nnot the best solution but one that does not change as much existing code.\nIt treats symptoms rather than the root cause.\n\nThis PR \u201ccensors\u201d certain complex unevaluated constant expressions like `match`es, blocks, function calls, struct literals etc. by pretty-printing them as `_` / `{ _ }` (number and string literals, paths and `()` are still printed as one would expect).\nResorting to this placeholder is preferable to printing the full expression verbatim since\nthey can be quite large and verbose resulting in an unreadable mess in the generated documentation.\nFurther, mindlessly printing the const would leak private and `doc(hidden)` struct fields (#97933), at least in the current\nstable & nightly implementations which rely on `span_to_snippet` (!) and `rustc_hir_pretty::id_to_string`.\n\nThe censoring of _verbose_ expressions is probably going to stay longer term.\nHowever, in regards to private and `doc(hidden)` struct fields, I have a more proper fix in mind\nwhich I have already partially implemented locally and for which I am going to open a separate PR sometime soon.\nFor that, I was already in contact with `@GuillaumeGomez.`\nThe proper fix involves rustdoc not falling back on pretty-printing unevaluated consts so easily (what this PR is concerned about)\nand instead preferring to print evaluated consts which contain more information allowing it to selectively hide private and `doc(hidden)` fields, create hyperlinks etc. generally making the output more granular and precise (compared to the brutal `_` placeholder).\n\nUnfortunately, I was a bit too late and the issue just hit stable (1.62).\nShould this be backported to beta or even a potential 1.62.1?\n\nr? `@GuillaumeGomez`", "tree": {"sha": "325730b5793966354be5d8d043acfbe2f39afe47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/325730b5793966354be5d8d043acfbe2f39afe47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ad3ef13ac6b9a1c73f1129f0925740607a0961a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiw1dwCRBK7hj4Ov3rIwAA26QIAIYz4JAP3yp14dIQNXhodk9Z\nb5mK62SGSUa6g1Hgzt1Bxs65u1+G57ON1ZoTfoD6VYhlLFvUHkQNp/JpPHvjEhBr\nmCIMF9CqY8j4nR/7oKBhULzyan2LJqStjgkMxrwFRH0H6iHlmDs63StnQITrAeJE\na1zDJ9gXd1upaq1l/CWJhaK9QEIpURmfVi/eLtLYncUY15Pydjr0sRy1GPWyfBjW\n3DttEZhS1y5cO/ktBfimyBtZQ8LEZxZB776NkLbJQTT6vIKbd09WDiERaQEl0IP4\nq4be/MQ50wIdy+7ByEjRCrZQQuZlotS7dt4w/f3ag+Xty8HcdHjjlms+5BFT/MM=\n=ho3f\n-----END PGP SIGNATURE-----\n", "payload": "tree 325730b5793966354be5d8d043acfbe2f39afe47\nparent 2a4091187a0e9e7d04340ab39053c56832141faa\nparent d3181a9a012805133d4b2808108c37cf4b23ea66\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1656969071 +0200\ncommitter GitHub <noreply@github.com> 1656969071 +0200\n\nRollup merge of #98814 - fmease:minimal-fix-for-issue-97933, r=GuillaumeGomez\n\nrustdoc: Censor certain complex unevaluated const exprs\n\nFixes #97933.\n\nThis is more of a hotfix for the aforementioned issue. By that, I mean that my proposed patch is\nnot the best solution but one that does not change as much existing code.\nIt treats symptoms rather than the root cause.\n\nThis PR \u201ccensors\u201d certain complex unevaluated constant expressions like `match`es, blocks, function calls, struct literals etc. by pretty-printing them as `_` / `{ _ }` (number and string literals, paths and `()` are still printed as one would expect).\nResorting to this placeholder is preferable to printing the full expression verbatim since\nthey can be quite large and verbose resulting in an unreadable mess in the generated documentation.\nFurther, mindlessly printing the const would leak private and `doc(hidden)` struct fields (#97933), at least in the current\nstable & nightly implementations which rely on `span_to_snippet` (!) and `rustc_hir_pretty::id_to_string`.\n\nThe censoring of _verbose_ expressions is probably going to stay longer term.\nHowever, in regards to private and `doc(hidden)` struct fields, I have a more proper fix in mind\nwhich I have already partially implemented locally and for which I am going to open a separate PR sometime soon.\nFor that, I was already in contact with `@GuillaumeGomez.`\nThe proper fix involves rustdoc not falling back on pretty-printing unevaluated consts so easily (what this PR is concerned about)\nand instead preferring to print evaluated consts which contain more information allowing it to selectively hide private and `doc(hidden)` fields, create hyperlinks etc. generally making the output more granular and precise (compared to the brutal `_` placeholder).\n\nUnfortunately, I was a bit too late and the issue just hit stable (1.62).\nShould this be backported to beta or even a potential 1.62.1?\n\nr? `@GuillaumeGomez`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad3ef13ac6b9a1c73f1129f0925740607a0961a", "html_url": "https://github.com/rust-lang/rust/commit/9ad3ef13ac6b9a1c73f1129f0925740607a0961a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a4091187a0e9e7d04340ab39053c56832141faa", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a4091187a0e9e7d04340ab39053c56832141faa", "html_url": "https://github.com/rust-lang/rust/commit/2a4091187a0e9e7d04340ab39053c56832141faa"}, {"sha": "d3181a9a012805133d4b2808108c37cf4b23ea66", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3181a9a012805133d4b2808108c37cf4b23ea66", "html_url": "https://github.com/rust-lang/rust/commit/d3181a9a012805133d4b2808108c37cf4b23ea66"}], "stats": {"total": 269, "additions": 259, "deletions": 10}, "files": [{"sha": "22b1e2335fd8486358971ec8dd2065773492fa83", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 87, "deletions": 6, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=9ad3ef13ac6b9a1c73f1129f0925740607a0961a", "patch": "@@ -340,17 +340,98 @@ pub(crate) fn is_literal_expr(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n     false\n }\n \n+/// Build a textual representation of an unevaluated constant expression.\n+///\n+/// If the const expression is too complex, an underscore `_` is returned.\n+/// For const arguments, it's `{ _ }` to be precise.\n+/// This means that the output is not necessarily valid Rust code.\n+///\n+/// Currently, only\n+///\n+/// * literals (optionally with a leading `-`)\n+/// * unit `()`\n+/// * blocks (`{ \u2026 }`) around simple expressions and\n+/// * paths without arguments\n+///\n+/// are considered simple enough. Simple blocks are included since they are\n+/// necessary to disambiguate unit from the unit type.\n+/// This list might get extended in the future.\n+///\n+/// Without this censoring, in a lot of cases the output would get too large\n+/// and verbose. Consider `match` expressions, blocks and deeply nested ADTs.\n+/// Further, private and `doc(hidden)` fields of structs would get leaked\n+/// since HIR datatypes like the `body` parameter do not contain enough\n+/// semantic information for this function to be able to hide them \u2013\n+/// at least not without significant performance overhead.\n+///\n+/// Whenever possible, prefer to evaluate the constant first and try to\n+/// use a different method for pretty-printing. Ideally this function\n+/// should only ever be used as a fallback.\n pub(crate) fn print_const_expr(tcx: TyCtxt<'_>, body: hir::BodyId) -> String {\n     let hir = tcx.hir();\n     let value = &hir.body(body).value;\n \n-    let snippet = if !value.span.from_expansion() {\n-        tcx.sess.source_map().span_to_snippet(value.span).ok()\n-    } else {\n-        None\n-    };\n+    #[derive(PartialEq, Eq)]\n+    enum Classification {\n+        Literal,\n+        Simple,\n+        Complex,\n+    }\n \n-    snippet.unwrap_or_else(|| rustc_hir_pretty::id_to_string(&hir, body.hir_id))\n+    use Classification::*;\n+\n+    fn classify(expr: &hir::Expr<'_>) -> Classification {\n+        match &expr.kind {\n+            hir::ExprKind::Unary(hir::UnOp::Neg, expr) => {\n+                if matches!(expr.kind, hir::ExprKind::Lit(_)) { Literal } else { Complex }\n+            }\n+            hir::ExprKind::Lit(_) => Literal,\n+            hir::ExprKind::Tup([]) => Simple,\n+            hir::ExprKind::Block(hir::Block { stmts: [], expr: Some(expr), .. }, _) => {\n+                if classify(expr) == Complex { Complex } else { Simple }\n+            }\n+            // Paths with a self-type or arguments are too \u201ccomplex\u201d following our measure since\n+            // they may leak private fields of structs (with feature `adt_const_params`).\n+            // Consider: `<Self as Trait<{ Struct { private: () } }>>::CONSTANT`.\n+            // Paths without arguments are definitely harmless though.\n+            hir::ExprKind::Path(hir::QPath::Resolved(_, hir::Path { segments, .. })) => {\n+                if segments.iter().all(|segment| segment.args.is_none()) { Simple } else { Complex }\n+            }\n+            // FIXME: Claiming that those kinds of QPaths are simple is probably not true if the Ty\n+            //        contains const arguments. Is there a *concise* way to check for this?\n+            hir::ExprKind::Path(hir::QPath::TypeRelative(..)) => Simple,\n+            // FIXME: Can they contain const arguments and thus leak private struct fields?\n+            hir::ExprKind::Path(hir::QPath::LangItem(..)) => Simple,\n+            _ => Complex,\n+        }\n+    }\n+\n+    let classification = classify(value);\n+\n+    if classification == Literal\n+    && !value.span.from_expansion()\n+    && let Ok(snippet) = tcx.sess.source_map().span_to_snippet(value.span) {\n+        // For literals, we avoid invoking the pretty-printer and use the source snippet instead to\n+        // preserve certain stylistic choices the user likely made for the sake legibility like\n+        //\n+        // * hexadecimal notation\n+        // * underscores\n+        // * character escapes\n+        //\n+        // FIXME: This passes through `-/*spacer*/0` verbatim.\n+        snippet\n+    } else if classification == Simple {\n+        // Otherwise we prefer pretty-printing to get rid of extraneous whitespace, comments and\n+        // other formatting artifacts.\n+        rustc_hir_pretty::id_to_string(&hir, body.hir_id)\n+    } else if tcx.def_kind(hir.body_owner_def_id(body).to_def_id()) == DefKind::AnonConst {\n+        // FIXME: Omit the curly braces if the enclosing expression is an array literal\n+        //        with a repeated element (an `ExprKind::Repeat`) as in such case it\n+        //        would not actually need any disambiguation.\n+        \"{ _ }\".to_owned()\n+    } else {\n+        \"_\".to_owned()\n+    }\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt"}, {"sha": "548f6c3a98729a13b908104272c8bfab0d30d981", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=9ad3ef13ac6b9a1c73f1129f0925740607a0961a", "patch": "@@ -716,12 +716,14 @@ fn assoc_const(\n         ty = ty.print(cx),\n     );\n     if let Some(default) = default {\n+        write!(w, \" = \");\n+\n         // FIXME: `.value()` uses `clean::utils::format_integer_with_underscore_sep` under the\n         //        hood which adds noisy underscores and a type suffix to number literals.\n         //        This hurts readability in this context especially when more complex expressions\n         //        are involved and it doesn't add much of value.\n         //        Find a way to print constants here without all that jazz.\n-        write!(w, \" = {}\", default.value(cx.tcx()).unwrap_or_else(|| default.expr(cx.tcx())));\n+        write!(w, \"{}\", Escape(&default.value(cx.tcx()).unwrap_or_else(|| default.expr(cx.tcx()))));\n     }\n }\n "}, {"sha": "fe00f952e043cda1e12b4698afda4e88983c627b", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=9ad3ef13ac6b9a1c73f1129f0925740607a0961a", "patch": "@@ -1360,6 +1360,15 @@ fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &cle\n                 typ = c.type_.print(cx),\n             );\n \n+            // FIXME: The code below now prints\n+            //            ` = _; // 100i32`\n+            //        if the expression is\n+            //            `50 + 50`\n+            //        which looks just wrong.\n+            //        Should we print\n+            //            ` = 100i32;`\n+            //        instead?\n+\n             let value = c.value(cx.tcx());\n             let is_literal = c.is_literal(cx.tcx());\n             let expr = c.expr(cx.tcx());"}, {"sha": "a79e93145ba7db99905043b11be0b3ab8b764a83", "filename": "src/test/rustdoc/assoc-consts.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-consts.rs?ref=9ad3ef13ac6b9a1c73f1129f0925740607a0961a", "patch": "@@ -27,6 +27,10 @@ impl Bar {\n     // @has assoc_consts/struct.Bar.html '//*[@id=\"associatedconstant.BAR\"]' \\\n     //      'const BAR: usize'\n     pub const BAR: usize = 3;\n+\n+    // @has - '//*[@id=\"associatedconstant.BAR_ESCAPED\"]' \\\n+    //      \"const BAR_ESCAPED: &'static str = \\\"<em>markup</em>\\\"\"\n+    pub const BAR_ESCAPED: &'static str = \"<em>markup</em>\";\n }\n \n pub struct Baz<'a, U: 'a, T>(T, &'a [U]);"}, {"sha": "5b2f3c48d57fa8a847024b3ad88397927c083ae8", "filename": "src/test/rustdoc/const-value-display.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Ftest%2Frustdoc%2Fconst-value-display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Ftest%2Frustdoc%2Fconst-value-display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-value-display.rs?ref=9ad3ef13ac6b9a1c73f1129f0925740607a0961a", "patch": "@@ -1,9 +1,9 @@\n #![crate_name = \"foo\"]\n \n // @has 'foo/constant.HOUR_IN_SECONDS.html'\n-// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const HOUR_IN_SECONDS: u64 = 60 * 60; // 3_600u64'\n+// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const HOUR_IN_SECONDS: u64 = _; // 3_600u64'\n pub const HOUR_IN_SECONDS: u64 = 60 * 60;\n \n // @has 'foo/constant.NEGATIVE.html'\n-// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const NEGATIVE: i64 = -60 * 60; // -3_600i64'\n+// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const NEGATIVE: i64 = _; // -3_600i64'\n pub const NEGATIVE: i64 = -60 * 60;"}, {"sha": "644a6e1cf33c52324035a5dd9d8beaaed3290d16", "filename": "src/test/rustdoc/hide-complex-unevaluated-const-arguments.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-const-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-const-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-const-arguments.rs?ref=9ad3ef13ac6b9a1c73f1129f0925740607a0961a", "patch": "@@ -0,0 +1,82 @@\n+// Test that certain unevaluated constant expression arguments that are\n+// deemed too verbose or complex and that may leak private or\n+// `doc(hidden)` struct fields are not displayed in the documentation.\n+//\n+// Read the documentation of `rustdoc::clean::utils::print_const_expr`\n+// for further details.\n+#![feature(const_trait_impl, generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+// @has hide_complex_unevaluated_const_arguments/trait.Stage.html\n+pub trait Stage {\n+    // A helper constant that prevents const expressions containing it\n+    // from getting fully evaluated since it doesn't have a body and\n+    // thus is non-reducible. This allows us to specifically test the\n+    // pretty-printing of *unevaluated* consts.\n+    const ABSTRACT: usize;\n+\n+    // Currently considered \"overly complex\" by the `generic_const_exprs`\n+    // feature. If / once this expression kind gets supported, this\n+    // unevaluated const expression could leak the private struct field.\n+    //\n+    // FIXME: Once the line below compiles, make this a test that\n+    //        ensures that the private field is not printed.\n+    //\n+    //const ARRAY0: [u8; Struct { private: () } + Self::ABSTRACT];\n+\n+    // This assoc. const could leak the private assoc. function `Struct::new`.\n+    // Ensure that this does not happen.\n+    //\n+    // @has - '//*[@id=\"associatedconstant.ARRAY1\"]' \\\n+    //        'const ARRAY1: [u8; { _ }]'\n+    const ARRAY1: [u8; Struct::new(/* ... */) + Self::ABSTRACT * 1_000];\n+\n+    // @has - '//*[@id=\"associatedconstant.VERBOSE\"]' \\\n+    //        'const VERBOSE: [u16; { _ }]'\n+    const VERBOSE: [u16; compute(\"thing\", 9 + 9) * Self::ABSTRACT];\n+\n+    // Check that we do not leak the private struct field contained within\n+    // the path. The output could definitely be improved upon\n+    // (e.g. printing sth. akin to `<Self as Helper<{ _ }>>::OUT`) but\n+    // right now \u201csafe is safe\u201d.\n+    //\n+    // @has - '//*[@id=\"associatedconstant.PATH\"]' \\\n+    //        'const PATH: usize = _'\n+    const PATH: usize = <Self as Helper<{ Struct { private: () } }>>::OUT;\n+}\n+\n+const fn compute(input: &str, extra: usize) -> usize {\n+    input.len() + extra\n+}\n+\n+pub trait Helper<const S: Struct> {\n+    const OUT: usize;\n+}\n+\n+impl<const S: Struct, St: Stage + ?Sized> Helper<S> for St {\n+    const OUT: usize = St::ABSTRACT;\n+}\n+\n+// Currently in rustdoc, const arguments are not evaluated in this position\n+// and therefore they fall under the realm of `print_const_expr`.\n+// If rustdoc gets patched to evaluate const arguments, it is fine to replace\n+// this test as long as one can ensure that private fields are not leaked!\n+//\n+// @has hide_complex_unevaluated_const_arguments/trait.Sub.html \\\n+//      '//*[@class=\"rust trait\"]' \\\n+//      'pub trait Sub: Sup<{ _ }, { _ }> { }'\n+pub trait Sub: Sup<{ 90 * 20 * 4 }, { Struct { private: () } }> {}\n+\n+pub trait Sup<const N: usize, const S: Struct> {}\n+\n+pub struct Struct { private: () }\n+\n+impl Struct {\n+    const fn new() -> Self { Self { private: () } }\n+}\n+\n+impl const std::ops::Add<usize> for Struct {\n+    type Output = usize;\n+\n+    fn add(self, _: usize) -> usize { 0 }\n+}"}, {"sha": "ba623246a01e0da1dea82303ed33a062b0c5ede2", "filename": "src/test/rustdoc/hide-complex-unevaluated-consts.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-consts.rs?ref=9ad3ef13ac6b9a1c73f1129f0925740607a0961a", "patch": "@@ -0,0 +1,71 @@\n+// Regression test for issue #97933.\n+//\n+// Test that certain unevaluated constant expressions that are\n+// deemed too verbose or complex and that may leak private or\n+// `doc(hidden)` struct fields are not displayed in the documentation.\n+//\n+// Read the documentation of `rustdoc::clean::utils::print_const_expr`\n+// for further details.\n+\n+// @has hide_complex_unevaluated_consts/trait.Container.html\n+pub trait Container {\n+    // A helper constant that prevents const expressions containing it\n+    // from getting fully evaluated since it doesn't have a body and\n+    // thus is non-reducible. This allows us to specifically test the\n+    // pretty-printing of *unevaluated* consts.\n+    const ABSTRACT: i32;\n+\n+    // Ensure that the private field does not get leaked:\n+    //\n+    // @has - '//*[@id=\"associatedconstant.STRUCT0\"]' \\\n+    //        'const STRUCT0: Struct = _'\n+    const STRUCT0: Struct = Struct { private: () };\n+\n+    // @has - '//*[@id=\"associatedconstant.STRUCT1\"]' \\\n+    //        'const STRUCT1: (Struct,) = _'\n+    const STRUCT1: (Struct,) = (Struct{private: /**/()},);\n+\n+    // Although the struct field is public here, check that it is not\n+    // displayed. In a future version of rustdoc, we definitely want to\n+    // show it. However for the time being, the printing logic is a bit\n+    // conservative.\n+    //\n+    // @has - '//*[@id=\"associatedconstant.STRUCT2\"]' \\\n+    //        'const STRUCT2: Record = _'\n+    const STRUCT2: Record = Record { public: 5 };\n+\n+    // Test that we do not show the incredibly verbose match expr:\n+    //\n+    // @has - '//*[@id=\"associatedconstant.MATCH0\"]' \\\n+    //        'const MATCH0: i32 = _'\n+    const MATCH0: i32 = match 234 {\n+        0 => 1,\n+        _ => Self::ABSTRACT,\n+    };\n+\n+    // @has - '//*[@id=\"associatedconstant.MATCH1\"]' \\\n+    //        'const MATCH1: bool = _'\n+    const MATCH1: bool = match Self::ABSTRACT {\n+        _ => true,\n+    };\n+\n+    // Check that we hide complex (arithmetic) operations.\n+    // In this case, it is a bit unfortunate since the expression\n+    // is not *that* verbose and it might be quite useful to the reader.\n+    //\n+    // However in general, the expression might be quite large and\n+    // contain match expressions and structs with private fields.\n+    // We would need to recurse over the whole expression and even more\n+    // importantly respect operator precedence when pretty-printing\n+    // the potentially partially censored expression.\n+    // For now, the implementation is quite simple and the choices\n+    // rather conservative.\n+    //\n+    // @has - '//*[@id=\"associatedconstant.ARITH_OPS\"]' \\\n+    //        'const ARITH_OPS: i32 = _'\n+    const ARITH_OPS: i32 = Self::ABSTRACT * 2 + 1;\n+}\n+\n+pub struct Struct { private: () }\n+\n+pub struct Record { pub public: i32 }"}, {"sha": "48b60885974afc7542ddcde7241d95f213f0c458", "filename": "src/test/rustdoc/show-const-contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad3ef13ac6b9a1c73f1129f0925740607a0961a/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs?ref=9ad3ef13ac6b9a1c73f1129f0925740607a0961a", "patch": "@@ -21,7 +21,7 @@ pub const CONST_NEG_I32: i32 = -42;\n // @!has show_const_contents/constant.CONST_EQ_TO_VALUE_I32.html '// 42i32'\n pub const CONST_EQ_TO_VALUE_I32: i32 = 42i32;\n \n-// @has show_const_contents/constant.CONST_CALC_I32.html '= 42 + 1; // 43i32'\n+// @has show_const_contents/constant.CONST_CALC_I32.html '= _; // 43i32'\n pub const CONST_CALC_I32: i32 = 42 + 1;\n \n // @!has show_const_contents/constant.CONST_REF_I32.html '= &42;'"}]}