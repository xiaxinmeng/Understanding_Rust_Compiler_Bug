{"sha": "53ea73a5cddd3b598751604e64dab39a7d6510c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZWE3M2E1Y2RkZDNiNTk4NzUxNjA0ZTY0ZGFiMzlhN2Q2NTEwYzE=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-05-17T19:51:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-05-17T19:51:28Z"}, "message": "Rollup merge of #50837 - steveklabnik:revert-49767, r=QuietMisdreavus\n\nRevert #49767\n\nThere was [some confusion](https://github.com/rust-lang/rust/pull/49767#issuecomment-389250815) and I accidentally merged a PR that wasn't ready.", "tree": {"sha": "771aa9b8fc67a2fe30f9ee5395012baed8b3f73c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/771aa9b8fc67a2fe30f9ee5395012baed8b3f73c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53ea73a5cddd3b598751604e64dab39a7d6510c1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJa/d1BCRBK7hj4Ov3rIwAAdHIIAJopcuZvAyKRcg+Gyl7Ds1JN\nCW0hu5/q5odMxxQ1qGnTrQH7H4ofZl0JfE+Eaxe1HH75WmISSOausk9Y3O/TIXTm\nToV5SFM+Oct0N0t+prDVJKMlnJnJrhUfgZ1yW4kyl23dm3fBqAh4yFmytv0boryN\nYmC6aN1iAlUd3iL1X5gmkbXDzgYIWR9G81xrFHPlheu9wiqdZQsDV4t8FxCogN39\n1D+MCePgGjwLYaoN1qNLpzPgjLZiLbCOPMqO3k3cj1Rn0yH0iB+Pr0nRbGonBbHC\ntbngBUccw/SOpwKauEbbIoxKgYRrfA9h1YAEXxC68SOl1lniiJcawMdB/RR+hwI=\n=/2l2\n-----END PGP SIGNATURE-----\n", "payload": "tree 771aa9b8fc67a2fe30f9ee5395012baed8b3f73c\nparent 54df1bf200754292b24ff8b70ab9dcc7d583bf4a\nparent eac94d105394a34f54beddfb77f1d4e7b18769e7\nauthor Mark Simulacrum <mark.simulacrum@gmail.com> 1526586688 -0600\ncommitter GitHub <noreply@github.com> 1526586688 -0600\n\nRollup merge of #50837 - steveklabnik:revert-49767, r=QuietMisdreavus\n\nRevert #49767\n\nThere was [some confusion](https://github.com/rust-lang/rust/pull/49767#issuecomment-389250815) and I accidentally merged a PR that wasn't ready.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53ea73a5cddd3b598751604e64dab39a7d6510c1", "html_url": "https://github.com/rust-lang/rust/commit/53ea73a5cddd3b598751604e64dab39a7d6510c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53ea73a5cddd3b598751604e64dab39a7d6510c1/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54df1bf200754292b24ff8b70ab9dcc7d583bf4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/54df1bf200754292b24ff8b70ab9dcc7d583bf4a", "html_url": "https://github.com/rust-lang/rust/commit/54df1bf200754292b24ff8b70ab9dcc7d583bf4a"}, {"sha": "eac94d105394a34f54beddfb77f1d4e7b18769e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/eac94d105394a34f54beddfb77f1d4e7b18769e7", "html_url": "https://github.com/rust-lang/rust/commit/eac94d105394a34f54beddfb77f1d4e7b18769e7"}], "stats": {"total": 531, "additions": 101, "deletions": 430}, "files": [{"sha": "0663409c992f42e064a40a2ec1451209691d305f", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 31, "deletions": 130, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/53ea73a5cddd3b598751604e64dab39a7d6510c1/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ea73a5cddd3b598751604e64dab39a7d6510c1/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=53ea73a5cddd3b598751604e64dab39a7d6510c1", "patch": "@@ -962,122 +962,59 @@ extern \"rust-intrinsic\" {\n     /// value is not necessarily valid to be used to actually access memory.\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n-    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n-    /// and destination must *not* overlap.\n+    /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n+    /// and destination may *not* overlap.\n     ///\n-    /// For regions of memory which might overlap, use [`copy`] instead.\n-    ///\n-    /// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`].\n-    ///\n-    /// [`copy`]: ./fn.copy.html\n-    /// [`memcpy`]: https://www.gnu.org/software/libc/manual/html_node/Copying-Strings-and-Arrays.html#index-memcpy\n+    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n     ///\n     /// # Safety\n     ///\n-    /// Behavior is undefined if any of the following conditions are violated:\n-    ///\n-    /// * The region of memory which begins at `src` and has a length of\n-    ///   `count * size_of::<T>()` bytes must be *both* valid and initialized.\n-    ///\n-    /// * The region of memory which begins at `dst` and has a length of\n-    ///   `count * size_of::<T>()` bytes must be valid (but may or may not be\n-    ///   initialized).\n-    ///\n-    /// * The two regions of memory must *not* overlap.\n-    ///\n-    /// * `src` must be properly aligned.\n-    ///\n-    /// * `dst` must be properly aligned.\n-    ///\n-    /// Additionally, if `T` is not [`Copy`], only the region at `src` *or* the\n-    /// region at `dst` can be used or dropped after calling\n-    /// `copy_nonoverlapping`.  `copy_nonoverlapping` creates bitwise copies of\n-    /// `T`, regardless of whether `T: Copy`, which can result in undefined\n-    /// behavior if both copies are used.\n-    ///\n-    /// [`Copy`]: ../marker/trait.Copy.html\n+    /// Beyond requiring that the program must be allowed to access both regions\n+    /// of memory, it is Undefined Behavior for source and destination to\n+    /// overlap. Care must also be taken with the ownership of `src` and\n+    /// `dst`. This method semantically moves the values of `src` into `dst`.\n+    /// However it does not drop the contents of `dst`, or prevent the contents\n+    /// of `src` from being dropped or used.\n     ///\n     /// # Examples\n     ///\n-    /// Manually implement [`Vec::append`]:\n+    /// A safe swap function:\n     ///\n     /// ```\n+    /// use std::mem;\n     /// use std::ptr;\n     ///\n-    /// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n-    /// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n-    ///     let src_len = src.len();\n-    ///     let dst_len = dst.len();\n-    ///\n-    ///     // Ensure that `dst` has enough capacity to hold all of `src`.\n-    ///     dst.reserve(src_len);\n-    ///\n+    /// # #[allow(dead_code)]\n+    /// fn swap<T>(x: &mut T, y: &mut T) {\n     ///     unsafe {\n-    ///         // The call to offset is always safe because `Vec` will never\n-    ///         // allocate more than `isize::MAX` bytes.\n-    ///         let dst = dst.as_mut_ptr().offset(dst_len as isize);\n-    ///         let src = src.as_ptr();\n-    ///\n-    ///         // The two regions cannot overlap becuase mutable references do\n-    ///         // not alias, and two different vectors cannot own the same\n-    ///         // memory.\n-    ///         ptr::copy_nonoverlapping(src, dst, src_len);\n-    ///     }\n+    ///         // Give ourselves some scratch space to work with\n+    ///         let mut t: T = mem::uninitialized();\n     ///\n-    ///     unsafe {\n-    ///         // Truncate `src` without dropping its contents.\n-    ///         src.set_len(0);\n+    ///         // Perform the swap, `&mut` pointers never alias\n+    ///         ptr::copy_nonoverlapping(x, &mut t, 1);\n+    ///         ptr::copy_nonoverlapping(y, x, 1);\n+    ///         ptr::copy_nonoverlapping(&t, y, 1);\n     ///\n-    ///         // Notify `dst` that it now holds the contents of `src`.\n-    ///         dst.set_len(dst_len + src_len);\n+    ///         // y and t now point to the same thing, but we need to completely forget `t`\n+    ///         // because it's no longer relevant.\n+    ///         mem::forget(t);\n     ///     }\n     /// }\n-    ///\n-    /// let mut a = vec!['r'];\n-    /// let mut b = vec!['u', 's', 't'];\n-    ///\n-    /// append(&mut a, &mut b);\n-    ///\n-    /// assert_eq!(a, &['r', 'u', 's', 't']);\n-    /// assert!(b.is_empty());\n     /// ```\n-    ///\n-    /// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n \n-    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+    /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n     /// and destination may overlap.\n     ///\n-    /// If the source and destination will *never* overlap,\n-    /// [`copy_nonoverlapping`] can be used instead.\n-    ///\n-    /// `copy` is semantically equivalent to C's [`memmove`].\n-    ///\n-    /// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n-    /// [`memmove`]: https://www.gnu.org/software/libc/manual/html_node/Copying-Strings-and-Arrays.html#index-memmove\n+    /// `copy` is semantically equivalent to C's `memmove`.\n     ///\n     /// # Safety\n     ///\n-    /// Behavior is undefined if any of the following conditions are violated:\n-    ///\n-    /// * The region of memory which begins at `src` and has a length of\n-    ///   `count * size_of::<T>()` bytes must be *both* valid and initialized.\n-    ///\n-    /// * The region of memory which begins at `dst` and has a length of\n-    ///   `count * size_of::<T>()` bytes must be valid (but may or may not be\n-    ///   initialized).\n-    ///\n-    /// * `src` must be properly aligned.\n-    ///\n-    /// * `dst` must be properly aligned.\n-    ///\n-    /// Additionally, if `T` is not [`Copy`], only the region at `src` *or* the\n-    /// region at `dst` can be used or dropped after calling `copy`. `copy`\n-    /// creates bitwise copies of `T`, regardless of whether `T: Copy`, which\n-    /// can result in undefined behavior if both copies are used.\n-    ///\n-    /// [`Copy`]: ../marker/trait.Copy.html\n+    /// Care must be taken with the ownership of `src` and `dst`.\n+    /// This method semantically moves the values of `src` into `dst`.\n+    /// However it does not drop the contents of `dst`, or prevent the contents of `src`\n+    /// from being dropped or used.\n     ///\n     /// # Examples\n     ///\n@@ -1094,34 +1031,15 @@ extern \"rust-intrinsic\" {\n     ///     dst\n     /// }\n     /// ```\n+    ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n \n-    /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n-    /// `val`.\n-    ///\n-    /// `write_bytes` is semantically equivalent to C's [`memset`].\n-    ///\n-    /// [`memset`]: https://www.gnu.org/software/libc/manual/html_node/Copying-Strings-and-Arrays.html#index-memset\n-    ///\n-    /// # Safety\n-    ///\n-    /// Behavior is undefined if any of the following conditions are violated:\n-    ///\n-    /// * The region of memory which begins at `dst` and has a length of\n-    ///   `count` bytes must be valid.\n-    ///\n-    /// * `dst` must be properly aligned.\n-    ///\n-    /// Additionally, the caller must ensure that writing `count` bytes to the\n-    /// given region of memory results in a valid value of `T`. Creating an\n-    /// invalid value of `T` can result in undefined behavior. An example is\n-    /// provided below.\n+    /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n+    /// bytes of memory starting at `dst` to `val`.\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n     /// use std::ptr;\n     ///\n@@ -1132,23 +1050,6 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// assert_eq!(vec, [b'a', b'a', 0, 0]);\n     /// ```\n-    ///\n-    /// Creating an invalid value:\n-    ///\n-    /// ```no_run\n-    /// use std::{mem, ptr};\n-    ///\n-    /// let mut v = Box::new(0i32);\n-    ///\n-    /// unsafe {\n-    ///     // Leaks the previously held value by overwriting the `Box<T>` with\n-    ///     // a null pointer.\n-    ///     ptr::write_bytes(&mut v, 0, mem::size_of::<Box<i32>>());\n-    /// }\n-    ///\n-    /// // At this point, using or dropping `v` results in undefined behavior.\n-    /// // v = Box::new(0i32); // ERROR\n-    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n "}, {"sha": "5f778482f42f2bc2fa9a87943712ffd3760b2d1f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 70, "deletions": 300, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/53ea73a5cddd3b598751604e64dab39a7d6510c1/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ea73a5cddd3b598751604e64dab39a7d6510c1/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=53ea73a5cddd3b598751604e64dab39a7d6510c1", "patch": "@@ -10,7 +10,7 @@\n \n // FIXME: talk about offset, copy_memory, copy_nonoverlapping_memory\n \n-//! Manually manage memory through raw pointers.\n+//! Raw, unsafe pointers, `*const T`, and `*mut T`.\n //!\n //! *[See also the pointer primitive types](../../std/primitive.pointer.html).*\n \n@@ -38,62 +38,21 @@ pub use intrinsics::write_bytes;\n \n /// Executes the destructor (if any) of the pointed-to value.\n ///\n-/// This is semantically equivalent to calling [`ptr::read`] and discarding\n-/// the result, but has the following advantages:\n+/// This has two use cases:\n ///\n /// * It is *required* to use `drop_in_place` to drop unsized types like\n ///   trait objects, because they can't be read out onto the stack and\n ///   dropped normally.\n ///\n-/// * It is friendlier to the optimizer to do this over [`ptr::read`] when\n+/// * It is friendlier to the optimizer to do this over `ptr::read` when\n ///   dropping manually allocated memory (e.g. when writing Box/Rc/Vec),\n ///   as the compiler doesn't need to prove that it's sound to elide the\n ///   copy.\n ///\n-/// [`ptr::read`]: ../ptr/fn.read.html\n-///\n /// # Safety\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `to_drop` must point to valid memory.\n-///\n-/// * `to_drop` must be properly aligned.\n-///\n-/// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n-/// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n-/// foo` counts as a use because it will cause the the value to be dropped\n-/// again. [`write`] can be used to overwrite data without causing it to be\n-/// dropped.\n-///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`write`]: ../ptr/fn.write.html\n-///\n-/// # Examples\n-///\n-/// Manually remove the last item from a vector:\n-///\n-/// ```\n-/// use std::ptr;\n-/// use std::rc::Rc;\n-///\n-/// let last = Rc::new(1);\n-/// let weak = Rc::downgrade(&last);\n-///\n-/// let mut v = vec![Rc::new(0), last];\n-///\n-/// unsafe {\n-///     // Without a call `drop_in_place`, the last item would never be dropped,\n-///     // and the memory it manages would be leaked.\n-///     ptr::drop_in_place(&mut v[1]);\n-///     v.set_len(1);\n-/// }\n-///\n-/// assert_eq!(v, &[0.into()]);\n-///\n-/// // Ensure that the last item was dropped.\n-/// assert!(weak.upgrade().is_none());\n-/// ```\n+/// This has all the same safety problems as `ptr::read` with respect to\n+/// invalid pointers, types, and double drops.\n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n #[lang = \"drop_in_place\"]\n #[allow(unconditional_recursion)]\n@@ -134,25 +93,17 @@ pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n /// Swaps the values at two mutable locations of the same type, without\n /// deinitializing either.\n ///\n-/// But for the following two exceptions, this function is semantically\n-/// equivalent to [`mem::swap`]:\n-///\n-/// * It operates on raw pointers instead of references. When references are\n-///   available, [`mem::swap`] should be preferred.\n-///\n-/// * The two pointed-to values may overlap. If the values do overlap, then the\n-///   overlapping region of memory from `x` will be used. This is demonstrated\n-///   in the examples below.\n-///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n+/// The values pointed at by `x` and `y` may overlap, unlike `mem::swap` which\n+/// is otherwise equivalent. If the values do overlap, then the overlapping\n+/// region of memory from `x` will be used. This is demonstrated in the\n+/// examples section below.\n ///\n /// # Safety\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n+/// This function copies the memory through the raw pointers passed to it\n+/// as arguments.\n ///\n-/// * `x` and `y` must point to valid, initialized memory.\n-///\n-/// * `x` and `y` must be properly aligned.\n+/// Ensure that these pointers are valid before calling `swap`.\n ///\n /// # Examples\n ///\n@@ -288,39 +239,13 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n     }\n }\n \n-/// Replaces the value at `dest` with `src`, returning the old value, without\n-/// dropping either.\n-///\n-/// This function is semantically equivalent to [`mem::replace`] except that it\n-/// operates on raw pointers instead of references. When references are\n-/// available, [`mem::replace`] should be preferred.\n-///\n-/// [`mem::replace`]: ../mem/fn.replace.html\n+/// Replaces the value at `dest` with `src`, returning the old\n+/// value, without dropping either.\n ///\n /// # Safety\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `dest` must point to valid, initialized memory.\n-///\n-/// * `dest` must be properly aligned.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::ptr;\n-///\n-/// let mut rust = vec!['b', 'u', 's', 't'];\n-///\n-/// // `mem::replace` would have the same effect without requiring the unsafe\n-/// // block.\n-/// let b = unsafe {\n-///     ptr::replace(&mut rust[0], 'r')\n-/// };\n-///\n-/// assert_eq!(b, 'b');\n-/// assert_eq!(rust, &['r', 'u', 's', 't']);\n-/// ```\n+/// This is only unsafe because it accepts a raw pointer.\n+/// Otherwise, this operation is identical to `mem::replace`.\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n@@ -333,23 +258,14 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n ///\n /// # Safety\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n+/// Beyond accepting a raw pointer, this is unsafe because it semantically\n+/// moves the value out of `src` without preventing further usage of `src`.\n+/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n+/// `src` is not used before the data is overwritten again (e.g. with `write`,\n+/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n+/// because it will attempt to drop the value previously at `*src`.\n ///\n-/// * `src` must point to valid, initialized memory.\n-///\n-/// * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n-///   case.\n-///\n-/// Additionally, if `T` is not [`Copy`], only the returned value *or* the\n-/// pointed-to value can be used or dropped after calling `read`. `read` creates\n-/// a bitwise copy of `T`, regardless of whether `T: Copy`, which can result\n-/// in undefined behavior if both copies are used. Note that `*src = foo` counts\n-/// as a use because it will attempt to drop the value previously at `*src`.\n-/// [`write`] can be used to overwrite data without causing it to be dropped.\n-///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read_unaligned`]: ./fn.read_unaligned.html\n-/// [`write`]: ./fn.write.html\n+/// The pointer must be aligned; use `read_unaligned` if that is not the case.\n ///\n /// # Examples\n ///\n@@ -363,44 +279,6 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n ///     assert_eq!(std::ptr::read(y), 12);\n /// }\n /// ```\n-///\n-/// Manually implement [`mem::swap`]:\n-///\n-/// ```\n-/// use std::ptr;\n-///\n-/// fn swap<T>(a: &mut T, b: &mut T) {\n-///     unsafe {\n-///         // Create a bitwise copy of the value at `a` in `tmp`.\n-///         let tmp = ptr::read(a);\n-///\n-///         // Exiting at this point (either by explicitly returning or by\n-///         // calling a function which panics) would cause the value in `tmp` to\n-///         // be dropped while the same value is still referenced by `a`. This\n-///         // could trigger undefined behavior if `T` is not `Copy`.\n-///\n-///         // Create a bitwise copy of the value at `b` in `a`.\n-///         // This is safe because mutable references cannot alias.\n-///         ptr::copy_nonoverlapping(b, a, 1);\n-///\n-///         // As above, exiting here could trigger undefined behavior because\n-///         // the same value is referenced by `a` and `b`.\n-///\n-///         // Move `tmp` into `b`.\n-///         ptr::write(b, tmp);\n-///     }\n-/// }\n-///\n-/// let mut foo = \"foo\".to_owned();\n-/// let mut bar = \"bar\".to_owned();\n-///\n-/// swap(&mut foo, &mut bar);\n-///\n-/// assert_eq!(foo, \"bar\");\n-/// assert_eq!(bar, \"foo\");\n-/// ```\n-///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n@@ -412,62 +290,28 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// Reads the value from `src` without moving it. This leaves the\n /// memory in `src` unchanged.\n ///\n-/// Unlike [`read`], `read_unaligned` works with unaligned pointers.\n-///\n-/// [`read`]: ./fn.read.html\n+/// Unlike `read`, the pointer may be unaligned.\n ///\n /// # Safety\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `src` must point to valid, initialized memory.\n-///\n-/// Additionally, if `T` is not [`Copy`], only the returned value *or* the\n-/// pointed-to value can be used or dropped after calling `read_unaligned`.\n-/// `read_unaligned` creates a bitwise copy of `T`, regardless of whether `T:\n-/// Copy`, and this can result in undefined behavior if both copies are used.\n-/// Note that `*src = foo` counts as a use because it will attempt to drop the\n-/// value previously at `*src`.  [`write_unaligned`] can be used to overwrite\n-/// data without causing it to be dropped.\n-///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`write_unaligned`]: ./fn.write_unaligned.html\n+/// Beyond accepting a raw pointer, this is unsafe because it semantically\n+/// moves the value out of `src` without preventing further usage of `src`.\n+/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n+/// `src` is not used before the data is overwritten again (e.g. with `write`,\n+/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n+/// because it will attempt to drop the value previously at `*src`.\n ///\n /// # Examples\n ///\n-/// Access members of a packed struct by reference:\n+/// Basic usage:\n ///\n /// ```\n-/// use std::ptr;\n+/// let x = 12;\n+/// let y = &x as *const i32;\n ///\n-/// #[repr(packed, C)]\n-/// #[derive(Default)]\n-/// struct Packed {\n-///     _padding: u8,\n-///     unaligned: u32,\n+/// unsafe {\n+///     assert_eq!(std::ptr::read_unaligned(y), 12);\n /// }\n-///\n-/// let x = Packed {\n-///     _padding: 0x00,\n-///     unaligned: 0x01020304,\n-/// };\n-///\n-/// let v = unsafe {\n-///     // Take a reference to a 32-bit integer which is not aligned.\n-///     let unaligned = &x.unaligned;\n-///\n-///     // Dereferencing normally will emit an unaligned load instruction,\n-///     // causing undefined behavior.\n-///     // let v = *unaligned; // ERROR\n-///\n-///     // Instead, use `read_unaligned` to read improperly aligned values.\n-///     let v = ptr::read_unaligned(unaligned);\n-///\n-///     v\n-/// };\n-///\n-/// // Accessing unaligned values directly is safe.\n-/// assert!(x.unaligned == v);\n /// ```\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n@@ -482,28 +326,21 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n-/// `write` does not drop the contents of `dst`. This is safe, but it could leak\n+/// # Safety\n+///\n+/// This operation is marked unsafe because it accepts a raw pointer.\n+///\n+/// It does not drop the contents of `dst`. This is safe, but it could leak\n /// allocations or resources, so care must be taken not to overwrite an object\n /// that should be dropped.\n ///\n /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n /// location pointed to by `dst`.\n ///\n /// This is appropriate for initializing uninitialized memory, or overwriting\n-/// memory that has previously been [`read`] from.\n-///\n-/// [`read`]: ./fn.read.html\n-///\n-/// # Safety\n+/// memory that has previously been `read` from.\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `dst` must point to valid memory.\n-///\n-/// * `dst` must be properly aligned. Use [`write_unaligned`] if this is not the\n-///   case.\n-///\n-/// [`write_unaligned`]: ./fn.write_unaligned.html\n+/// The pointer must be aligned; use `write_unaligned` if that is not the case.\n ///\n /// # Examples\n ///\n@@ -519,30 +356,6 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n ///     assert_eq!(std::ptr::read(y), 12);\n /// }\n /// ```\n-///\n-/// Manually implement [`mem::swap`]:\n-///\n-/// ```\n-/// use std::ptr;\n-///\n-/// fn swap<T>(a: &mut T, b: &mut T) {\n-///     unsafe {\n-///         let tmp = ptr::read(a);\n-///         ptr::copy_nonoverlapping(b, a, 1);\n-///         ptr::write(b, tmp);\n-///     }\n-/// }\n-///\n-/// let mut foo = \"foo\".to_owned();\n-/// let mut bar = \"bar\".to_owned();\n-///\n-/// swap(&mut foo, &mut bar);\n-///\n-/// assert_eq!(foo, \"bar\");\n-/// assert_eq!(bar, \"foo\");\n-/// ```\n-///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n@@ -552,58 +365,36 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n-/// Unlike [`write`], the pointer may be unaligned.\n+/// Unlike `write`, the pointer may be unaligned.\n+///\n+/// # Safety\n ///\n-/// `write_unaligned` does not drop the contents of `dst`. This is safe, but it\n-/// could leak allocations or resources, so care must be taken not to overwrite\n-/// an object that should be dropped.\n+/// This operation is marked unsafe because it accepts a raw pointer.\n+///\n+/// It does not drop the contents of `dst`. This is safe, but it could leak\n+/// allocations or resources, so care must be taken not to overwrite an object\n+/// that should be dropped.\n ///\n /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n /// location pointed to by `dst`.\n ///\n /// This is appropriate for initializing uninitialized memory, or overwriting\n-/// memory that has previously been read with [`read_unaligned`].\n-///\n-/// [`write`]: ./fn.write.html\n-/// [`read_unaligned`]: ./fn.read_unaligned.html\n-///\n-/// # Safety\n-///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `dst` must point to valid memory.\n+/// memory that has previously been `read` from.\n ///\n /// # Examples\n ///\n-/// Access fields in a packed struct:\n+/// Basic usage:\n ///\n /// ```\n-/// use std::{mem, ptr};\n-///\n-/// #[repr(packed, C)]\n-/// #[derive(Default)]\n-/// struct Packed {\n-///     _padding: u8,\n-///     unaligned: u32,\n-/// }\n-///\n-/// let v = 0x01020304;\n-/// let mut x: Packed = unsafe { mem::zeroed() };\n+/// let mut x = 0;\n+/// let y = &mut x as *mut i32;\n+/// let z = 12;\n ///\n /// unsafe {\n-///     // Take a reference to a 32-bit integer which is not aligned.\n-///     let unaligned = &mut x.unaligned;\n-///\n-///     // Dereferencing normally will emit an unaligned store instruction,\n-///     // causing undefined behavior.\n-///     // *unaligned = v; // ERROR\n-///\n-///     // Instead, use `write_unaligned` to write improperly aligned values.\n-///     ptr::write_unaligned(unaligned, v);\n+///     std::ptr::write_unaligned(y, z);\n+///     assert_eq!(std::ptr::read_unaligned(y), 12);\n /// }\n-///\n-/// // Accessing unaligned values directly is safe.\n-/// assert!(x.unaligned == v);\n+/// ```\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n@@ -620,11 +411,6 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// to not be elided or reordered by the compiler across other volatile\n /// operations.\n ///\n-/// Memory read with `read_volatile` should almost always be written to using\n-/// [`write_volatile`].\n-///\n-/// [`write_volatile`]: ./fn.write_volatile.html\n-///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -641,19 +427,12 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// # Safety\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `src` must point to valid, initialized memory.\n-///\n-/// * `src` must be properly aligned.\n-///\n-/// Like [`read`], `read_volatile` creates a bitwise copy of the pointed-to\n-/// object, regardless of whether `T` is [`Copy`]. Using both values can cause\n-/// undefined behavior. However, storing non-[`Copy`] data in I/O memory is\n-/// almost certainly incorrect.\n-///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read`]: ./fn.read.html\n+/// Beyond accepting a raw pointer, this is unsafe because it semantically\n+/// moves the value out of `src` without preventing further usage of `src`.\n+/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n+/// `src` is not used before the data is overwritten again (e.g. with `write`,\n+/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n+/// because it will attempt to drop the value previously at `*src`.\n ///\n /// # Examples\n ///\n@@ -680,18 +459,6 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// to not be elided or reordered by the compiler across other volatile\n /// operations.\n ///\n-/// Memory written with `write_volatile` should almost always be read from using\n-/// [`read_volatile`].\n-///\n-/// `write_volatile` does not drop the contents of `dst`. This is safe, but it\n-/// could leak allocations or resources, so care must be taken not to overwrite\n-/// an object that should be dropped.\n-///\n-/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n-/// location pointed to by `dst`.\n-///\n-/// [`read_volatile`]: ./fn.read_volatile.html\n-///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -708,11 +475,14 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// # Safety\n ///\n-/// Behavior is undefined if any of the following conditions are violated:\n+/// This operation is marked unsafe because it accepts a raw pointer.\n ///\n-/// * `dst` must point to valid memory.\n+/// It does not drop the contents of `dst`. This is safe, but it could leak\n+/// allocations or resources, so care must be taken not to overwrite an object\n+/// that should be dropped.\n ///\n-/// * `dst` must be properly aligned.\n+/// This is appropriate for initializing uninitialized memory, or overwriting\n+/// memory that has previously been `read` from.\n ///\n /// # Examples\n ///"}]}