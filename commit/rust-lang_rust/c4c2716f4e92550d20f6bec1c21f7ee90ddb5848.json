{"sha": "c4c2716f4e92550d20f6bec1c21f7ee90ddb5848", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0YzI3MTZmNGU5MjU1MGQyMGY2YmVjMWMyMWY3ZWU5MGRkYjU4NDg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-02T06:09:22Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-02T06:09:22Z"}, "message": "make reborrow shallow, and fix tests for that", "tree": {"sha": "cad19de9c4c42b8564c924e2e5bf169dc7b9cef5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cad19de9c4c42b8564c924e2e5bf169dc7b9cef5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848", "html_url": "https://github.com/rust-lang/rust/commit/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bbf6733ea3d253740f2b78360c20f05781cfa11", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bbf6733ea3d253740f2b78360c20f05781cfa11", "html_url": "https://github.com/rust-lang/rust/commit/5bbf6733ea3d253740f2b78360c20f05781cfa11"}], "stats": {"total": 77, "additions": 23, "deletions": 54}, "files": [{"sha": "4e2198a8cea07fdca173f79dab2b2aba919a5e6d", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 2, "deletions": 44, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=c4c2716f4e92550d20f6bec1c21f7ee90ddb5848", "patch": "@@ -12,7 +12,7 @@ use rustc::hir::{MutMutable, MutImmutable};\n use rustc::mir::RetagKind;\n \n use crate::{\n-    InterpResult, InterpError, MiriEvalContext, HelpersEvalContextExt, Evaluator, MutValueVisitor,\n+    InterpResult, InterpError, HelpersEvalContextExt,\n     MemoryKind, MiriMemoryKind, RangeMap, AllocId, Pointer, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n \n@@ -632,54 +632,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         }\n \n-        // We need a visitor to visit all references. However, that requires\n-        // a `MemPlace`, so we have a fast path for reference types that\n-        // avoids allocating.\n+        // We only reborrow \"bare\" references/boxes.\n         if let Some((mutbl, protector)) = qualify(place.layout.ty, kind) {\n             // Fast path.\n             let val = this.read_immediate(this.place_to_op(place)?)?;\n             let val = this.retag_reference(val, mutbl, protector)?;\n             this.write_immediate(val, place)?;\n-            return Ok(());\n-        }\n-        let place = this.force_allocation(place)?;\n-\n-        let mut visitor = RetagVisitor { ecx: this, kind };\n-        visitor.visit_value(place)?;\n-\n-        // The actual visitor.\n-        struct RetagVisitor<'ecx, 'mir, 'tcx> {\n-            ecx: &'ecx mut MiriEvalContext<'mir, 'tcx>,\n-            kind: RetagKind,\n-        }\n-        impl<'ecx, 'mir, 'tcx>\n-            MutValueVisitor<'mir, 'tcx, Evaluator<'tcx>>\n-        for\n-            RetagVisitor<'ecx, 'mir, 'tcx>\n-        {\n-            type V = MPlaceTy<'tcx, Tag>;\n-\n-            #[inline(always)]\n-            fn ecx(&mut self) -> &mut MiriEvalContext<'mir, 'tcx> {\n-                &mut self.ecx\n-            }\n-\n-            // Primitives of reference type, that is the one thing we are interested in.\n-            fn visit_primitive(&mut self, place: MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>\n-            {\n-                // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n-                // making it useless.\n-                if let Some((mutbl, protector)) = qualify(place.layout.ty, self.kind) {\n-                    let val = self.ecx.read_immediate(place.into())?;\n-                    let val = self.ecx.retag_reference(\n-                        val,\n-                        mutbl,\n-                        protector\n-                    )?;\n-                    self.ecx.write_immediate(val, place.into())?;\n-                }\n-                Ok(())\n-            }\n         }\n \n         Ok(())"}, {"sha": "798f68fa13cc948ac4e504976cd35b44804e4e6b", "filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=c4c2716f4e92550d20f6bec1c21f7ee90ddb5848", "patch": "@@ -9,7 +9,6 @@ mod safe {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n-            //~^ ERROR borrow stack\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n         }\n     }\n@@ -18,6 +17,7 @@ mod safe {\n fn main() {\n     let mut array = [1,2,3,4];\n     let (a, b) = safe::split_at_mut(&mut array, 0);\n+    //~^ ERROR borrow stack\n     a[1] = 5;\n     b[1] = 6;\n }"}, {"sha": "1cb3f3f920267f7c717d9f34cd5c3e678e5d2b9c", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut_option.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs?ref=c4c2716f4e92550d20f6bec1c21f7ee90ddb5848", "patch": "@@ -1,11 +1,16 @@\n // Make sure that we cannot return a `&mut` that got already invalidated, not even in an `Option`.\n+// Due to shallow reborrowing, the error only surfaces when we look into the `Option`.\n fn foo(x: &mut (i32, i32)) -> Option<&mut i32> {\n     let xraw = x as *mut (i32, i32);\n-    let ret = Some(unsafe { &mut (*xraw).1 });\n+    let ret = unsafe { &mut (*xraw).1 }; // let-bind to avoid 2phase\n+    let ret = Some(ret);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret //~ ERROR borrow stack\n+    ret\n }\n \n fn main() {\n-    foo(&mut (1, 2));\n+    match foo(&mut (1, 2)) {\n+        Some(_x) => {}, //~ ERROR borrow stack\n+        None => {},\n+    }\n }"}, {"sha": "fbd9a6e5d269221784acd4fc0b8bcf27bf8c7323", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut_tuple.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs?ref=c4c2716f4e92550d20f6bec1c21f7ee90ddb5848", "patch": "@@ -1,11 +1,12 @@\n // Make sure that we cannot return a `&mut` that got already invalidated, not even in a tuple.\n+// Due to shallow reborrowing, the error only surfaces when we look into the tuple.\n fn foo(x: &mut (i32, i32)) -> (&mut i32,) {\n     let xraw = x as *mut (i32, i32);\n     let ret = (unsafe { &mut (*xraw).1 },);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret //~ ERROR borrow stack\n+    ret\n }\n \n fn main() {\n-    foo(&mut (1, 2));\n+    foo(&mut (1, 2)).0; //~ ERROR: borrow stack\n }"}, {"sha": "2d8527fa3fb4f307ce824f9fb6c627a318460bbc", "filename": "tests/compile-fail/stacked_borrows/return_invalid_shr_option.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs?ref=c4c2716f4e92550d20f6bec1c21f7ee90ddb5848", "patch": "@@ -1,11 +1,15 @@\n // Make sure that we cannot return a `&` that got already invalidated, not even in an `Option`.\n+// Due to shallow reborrowing, the error only surfaces when we look into the `Option`.\n fn foo(x: &mut (i32, i32)) -> Option<&i32> {\n     let xraw = x as *mut (i32, i32);\n     let ret = Some(unsafe { &(*xraw).1 });\n     unsafe { *xraw = (42, 23) }; // unfreeze\n-    ret //~ ERROR borrow stack\n+    ret\n }\n \n fn main() {\n-    foo(&mut (1, 2));\n+    match foo(&mut (1, 2)) {\n+        Some(_x) => {}, //~ ERROR borrow stack\n+        None => {},\n+    }\n }"}, {"sha": "d7494d6ee653b5f1edf9debc34c12acb38a96169", "filename": "tests/compile-fail/stacked_borrows/return_invalid_shr_tuple.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c2716f4e92550d20f6bec1c21f7ee90ddb5848/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs?ref=c4c2716f4e92550d20f6bec1c21f7ee90ddb5848", "patch": "@@ -1,11 +1,12 @@\n // Make sure that we cannot return a `&` that got already invalidated, not even in a tuple.\n+// Due to shallow reborrowing, the error only surfaces when we look into the tuple.\n fn foo(x: &mut (i32, i32)) -> (&i32,) {\n     let xraw = x as *mut (i32, i32);\n     let ret = (unsafe { &(*xraw).1 },);\n     unsafe { *xraw = (42, 23) }; // unfreeze\n-    ret //~ ERROR borrow stack\n+    ret\n }\n \n fn main() {\n-    foo(&mut (1, 2));\n+    foo(&mut (1, 2)).0; //~ ERROR borrow stack\n }"}]}