{"sha": "7a1494ced5d762cdebf590619fc3326c4a876a7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMTQ5NGNlZDVkNzYyY2RlYmY1OTA2MTlmYzMzMjZjNGE4NzZhN2I=", "commit": {"author": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-01-28T14:12:07Z"}, "committer": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-01-30T20:31:29Z"}, "message": "Fix #667", "tree": {"sha": "3abf3b1a7e988a6ff75fcd9b29e0ad59a6d1eddd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3abf3b1a7e988a6ff75fcd9b29e0ad59a6d1eddd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a1494ced5d762cdebf590619fc3326c4a876a7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a1494ced5d762cdebf590619fc3326c4a876a7b", "html_url": "https://github.com/rust-lang/rust/commit/7a1494ced5d762cdebf590619fc3326c4a876a7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a1494ced5d762cdebf590619fc3326c4a876a7b/comments", "author": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48d2acb297459fb06cbb49bdce2eccb4c2591714", "url": "https://api.github.com/repos/rust-lang/rust/commits/48d2acb297459fb06cbb49bdce2eccb4c2591714", "html_url": "https://github.com/rust-lang/rust/commit/48d2acb297459fb06cbb49bdce2eccb4c2591714"}], "stats": {"total": 136, "additions": 125, "deletions": 11}, "files": [{"sha": "9035beba89d84fe0e1b1c666296fbf635f079d25", "filename": "crates/ra_ide_api_light/src/assists/introduce_variable.rs", "status": "modified", "additions": 125, "deletions": 11, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/7a1494ced5d762cdebf590619fc3326c4a876a7b/crates%2Fra_ide_api_light%2Fsrc%2Fassists%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1494ced5d762cdebf590619fc3326c4a876a7b/crates%2Fra_ide_api_light%2Fsrc%2Fassists%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fassists%2Fintroduce_variable.rs?ref=7a1494ced5d762cdebf590619fc3326c4a876a7b", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{\n     ast::{self, AstNode},\n-    SyntaxKind::WHITESPACE,\n+    SyntaxKind::WHITESPACE, SyntaxKind::MATCH_ARM, SyntaxKind::LAMBDA_EXPR,\n     SyntaxNode, TextUnit,\n };\n \n@@ -10,15 +10,22 @@ pub fn introduce_variable<'a>(ctx: AssistCtx) -> Option<Assist> {\n     let node = ctx.covering_node();\n     let expr = node.ancestors().filter_map(ast::Expr::cast).next()?;\n \n-    let anchor_stmt = anchor_stmt(expr)?;\n+    let (anchor_stmt, wrap_in_block) = anchor_stmt(expr)?;\n     let indent = anchor_stmt.prev_sibling()?;\n     if indent.kind() != WHITESPACE {\n         return None;\n     }\n     ctx.build(\"introduce variable\", move |edit| {\n         let mut buf = String::new();\n \n-        buf.push_str(\"let var_name = \");\n+        let cursor_offset = if wrap_in_block {\n+            buf.push_str(\"{ let var_name = \");\n+            TextUnit::of_str(\"{ let \")\n+        } else {\n+            buf.push_str(\"let var_name = \");\n+            TextUnit::of_str(\"let \")\n+        };\n+\n         expr.syntax().text().push_to(&mut buf);\n         let full_stmt = ast::ExprStmt::cast(anchor_stmt);\n         let is_full_stmt = if let Some(expr_stmt) = full_stmt {\n@@ -36,28 +43,44 @@ pub fn introduce_variable<'a>(ctx: AssistCtx) -> Option<Assist> {\n             indent.text().push_to(&mut buf);\n             edit.replace(expr.syntax().range(), \"var_name\".to_string());\n             edit.insert(anchor_stmt.range().start(), buf);\n+            if wrap_in_block {\n+                edit.insert(anchor_stmt.range().end(), \" }\");\n+            }\n         }\n-        edit.set_cursor(anchor_stmt.range().start() + TextUnit::of_str(\"let \"));\n+        edit.set_cursor(anchor_stmt.range().start() + cursor_offset);\n     })\n }\n \n-/// Statement or last in the block expression, which will follow\n-/// the freshly introduced var.\n-fn anchor_stmt(expr: &ast::Expr) -> Option<&SyntaxNode> {\n-    expr.syntax().ancestors().find(|&node| {\n+/// Returns the syntax node which will follow the freshly introduced var\n+/// and a boolean indicating whether we have to wrap it within a { } block\n+/// to produce correct code.\n+/// It can be a statement, the last in a block expression or a wanna be block\n+/// expression like a lamba or match arm.\n+fn anchor_stmt(expr: &ast::Expr) -> Option<(&SyntaxNode, bool)> {\n+    expr.syntax().ancestors().find_map(|node| {\n         if ast::Stmt::cast(node).is_some() {\n-            return true;\n+            return Some((node, false));\n         }\n+\n         if let Some(expr) = node\n             .parent()\n             .and_then(ast::Block::cast)\n             .and_then(|it| it.expr())\n         {\n             if expr.syntax() == node {\n-                return true;\n+                return Some((node, false));\n             }\n         }\n-        false\n+\n+        if let Some(parent) = node.parent() {\n+            if parent.kind() == MATCH_ARM\n+                || parent.kind() == LAMBDA_EXPR\n+            {\n+                return Some((node, true));\n+            }\n+        }\n+\n+        None\n     })\n }\n \n@@ -161,4 +184,95 @@ fn foo() {\n }\",\n         );\n     }\n+\n+    #[test]\n+    fn test_introduce_var_in_match_arm_no_block() {\n+        check_assist_range(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        true => (<|>2 + 2<|>, true)\n+        _ => (0, false)\n+    };\n+}\n+\",\n+            \"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        true => { let <|>var_name = 2 + 2; (var_name, true) }\n+        _ => (0, false)\n+    };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_in_match_arm_with_block() {\n+        check_assist_range(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        true => {\n+            let y = 1;\n+            (<|>2 + y<|>, true)\n+        }\n+        _ => (0, false)\n+    };\n+}\n+\",\n+            \"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        true => {\n+            let y = 1;\n+            let <|>var_name = 2 + y;\n+            (var_name, true)\n+        }\n+        _ => (0, false)\n+    };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_in_closure_no_block() {\n+        check_assist_range(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let lambda = |x: u32| <|>x * 2<|>;\n+}\n+\",\n+            \"\n+fn main() {\n+    let lambda = |x: u32| { let <|>var_name = x * 2; var_name };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_in_closure_with_block() {\n+        check_assist_range(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let lambda = |x: u32| { <|>x * 2<|> };\n+}\n+\",\n+            \"\n+fn main() {\n+    let lambda = |x: u32| { let <|>var_name = x * 2; var_name };\n+}\n+\",\n+        );\n+    }\n }"}]}