{"sha": "c30183873e2be5a23021adce01bacc901ccfff63", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMDE4Mzg3M2UyYmU1YTIzMDIxYWRjZTAxYmFjYzkwMWNjZmZmNjM=", "commit": {"author": {"name": "Sean Griffin", "email": "sean@seantheprogrammer.com", "date": "2018-01-29T20:46:52Z"}, "committer": {"name": "Sean Griffin", "email": "sean@seantheprogrammer.com", "date": "2018-03-01T15:04:26Z"}, "message": "Remove dead code\n\nThese modules were replaced with re-exports from ena", "tree": {"sha": "d2c07b22aeb7353d9fcc99e93038b6cc209d90b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2c07b22aeb7353d9fcc99e93038b6cc209d90b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c30183873e2be5a23021adce01bacc901ccfff63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c30183873e2be5a23021adce01bacc901ccfff63", "html_url": "https://github.com/rust-lang/rust/commit/c30183873e2be5a23021adce01bacc901ccfff63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c30183873e2be5a23021adce01bacc901ccfff63/comments", "author": {"login": "sgrif", "id": 1529387, "node_id": "MDQ6VXNlcjE1MjkzODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1529387?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgrif", "html_url": "https://github.com/sgrif", "followers_url": "https://api.github.com/users/sgrif/followers", "following_url": "https://api.github.com/users/sgrif/following{/other_user}", "gists_url": "https://api.github.com/users/sgrif/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgrif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgrif/subscriptions", "organizations_url": "https://api.github.com/users/sgrif/orgs", "repos_url": "https://api.github.com/users/sgrif/repos", "events_url": "https://api.github.com/users/sgrif/events{/privacy}", "received_events_url": "https://api.github.com/users/sgrif/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sgrif", "id": 1529387, "node_id": "MDQ6VXNlcjE1MjkzODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1529387?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgrif", "html_url": "https://github.com/sgrif", "followers_url": "https://api.github.com/users/sgrif/followers", "following_url": "https://api.github.com/users/sgrif/following{/other_user}", "gists_url": "https://api.github.com/users/sgrif/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgrif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgrif/subscriptions", "organizations_url": "https://api.github.com/users/sgrif/orgs", "repos_url": "https://api.github.com/users/sgrif/repos", "events_url": "https://api.github.com/users/sgrif/events{/privacy}", "received_events_url": "https://api.github.com/users/sgrif/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "755bdaa19084c3ae116ad8320b99a6932fa7f0b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/755bdaa19084c3ae116ad8320b99a6932fa7f0b1", "html_url": "https://github.com/rust-lang/rust/commit/755bdaa19084c3ae116ad8320b99a6932fa7f0b1"}], "stats": {"total": 798, "additions": 0, "deletions": 798}, "files": [{"sha": "2da91918288bab77ff8266086a662ea150fc4aad", "filename": "src/librustc_data_structures/snapshot_vec.rs", "status": "removed", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/755bdaa19084c3ae116ad8320b99a6932fa7f0b1/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755bdaa19084c3ae116ad8320b99a6932fa7f0b1/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs?ref=755bdaa19084c3ae116ad8320b99a6932fa7f0b1", "patch": "@@ -1,230 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A utility class for implementing \"snapshottable\" things; a snapshottable data structure permits\n-//! you to take a snapshot (via `start_snapshot`) and then, after making some changes, elect either\n-//! to rollback to the start of the snapshot or commit those changes.\n-//!\n-//! This vector is intended to be used as part of an abstraction, not serve as a complete\n-//! abstraction on its own. As such, while it will roll back most changes on its own, it also\n-//! supports a `get_mut` operation that gives you an arbitrary mutable pointer into the vector. To\n-//! ensure that any changes you make this with this pointer are rolled back, you must invoke\n-//! `record` to record any changes you make and also supplying a delegate capable of reversing\n-//! those changes.\n-use self::UndoLog::*;\n-\n-use std::mem;\n-use std::ops;\n-\n-pub enum UndoLog<D: SnapshotVecDelegate> {\n-    /// Indicates where a snapshot started.\n-    OpenSnapshot,\n-\n-    /// Indicates a snapshot that has been committed.\n-    CommittedSnapshot,\n-\n-    /// New variable with given index was created.\n-    NewElem(usize),\n-\n-    /// Variable with given index was changed *from* the given value.\n-    SetElem(usize, D::Value),\n-\n-    /// Extensible set of actions\n-    Other(D::Undo),\n-}\n-\n-pub struct SnapshotVec<D: SnapshotVecDelegate> {\n-    values: Vec<D::Value>,\n-    undo_log: Vec<UndoLog<D>>,\n-}\n-\n-// Snapshots are tokens that should be created/consumed linearly.\n-pub struct Snapshot {\n-    // Length of the undo log at the time the snapshot was taken.\n-    length: usize,\n-}\n-\n-pub trait SnapshotVecDelegate {\n-    type Value;\n-    type Undo;\n-\n-    fn reverse(values: &mut Vec<Self::Value>, action: Self::Undo);\n-}\n-\n-impl<D: SnapshotVecDelegate> SnapshotVec<D> {\n-    pub fn new() -> SnapshotVec<D> {\n-        SnapshotVec {\n-            values: Vec::new(),\n-            undo_log: Vec::new(),\n-        }\n-    }\n-\n-    pub fn with_capacity(n: usize) -> SnapshotVec<D> {\n-        SnapshotVec {\n-            values: Vec::with_capacity(n),\n-            undo_log: Vec::new(),\n-        }\n-    }\n-\n-    fn in_snapshot(&self) -> bool {\n-        !self.undo_log.is_empty()\n-    }\n-\n-    pub fn record(&mut self, action: D::Undo) {\n-        if self.in_snapshot() {\n-            self.undo_log.push(Other(action));\n-        }\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        self.values.len()\n-    }\n-\n-    pub fn push(&mut self, elem: D::Value) -> usize {\n-        let len = self.values.len();\n-        self.values.push(elem);\n-\n-        if self.in_snapshot() {\n-            self.undo_log.push(NewElem(len));\n-        }\n-\n-        len\n-    }\n-\n-    pub fn get(&self, index: usize) -> &D::Value {\n-        &self.values[index]\n-    }\n-\n-    /// Returns a mutable pointer into the vec; whatever changes you make here cannot be undone\n-    /// automatically, so you should be sure call `record()` with some sort of suitable undo\n-    /// action.\n-    pub fn get_mut(&mut self, index: usize) -> &mut D::Value {\n-        &mut self.values[index]\n-    }\n-\n-    /// Updates the element at the given index. The old value will saved (and perhaps restored) if\n-    /// a snapshot is active.\n-    pub fn set(&mut self, index: usize, new_elem: D::Value) {\n-        let old_elem = mem::replace(&mut self.values[index], new_elem);\n-        if self.in_snapshot() {\n-            self.undo_log.push(SetElem(index, old_elem));\n-        }\n-    }\n-\n-    pub fn start_snapshot(&mut self) -> Snapshot {\n-        let length = self.undo_log.len();\n-        self.undo_log.push(OpenSnapshot);\n-        Snapshot { length: length }\n-    }\n-\n-    pub fn actions_since_snapshot(&self, snapshot: &Snapshot) -> &[UndoLog<D>] {\n-        &self.undo_log[snapshot.length..]\n-    }\n-\n-    fn assert_open_snapshot(&self, snapshot: &Snapshot) {\n-        // Or else there was a failure to follow a stack discipline:\n-        assert!(self.undo_log.len() > snapshot.length);\n-\n-        // Invariant established by start_snapshot():\n-        assert!(match self.undo_log[snapshot.length] {\n-            OpenSnapshot => true,\n-            _ => false,\n-        });\n-    }\n-\n-    pub fn rollback_to(&mut self, snapshot: Snapshot) {\n-        debug!(\"rollback_to({})\", snapshot.length);\n-\n-        self.assert_open_snapshot(&snapshot);\n-\n-        while self.undo_log.len() > snapshot.length + 1 {\n-            match self.undo_log.pop().unwrap() {\n-                OpenSnapshot => {\n-                    // This indicates a failure to obey the stack discipline.\n-                    panic!(\"Cannot rollback an uncommitted snapshot\");\n-                }\n-\n-                CommittedSnapshot => {\n-                    // This occurs when there are nested snapshots and\n-                    // the inner is committed but outer is rolled back.\n-                }\n-\n-                NewElem(i) => {\n-                    self.values.pop();\n-                    assert!(self.values.len() == i);\n-                }\n-\n-                SetElem(i, v) => {\n-                    self.values[i] = v;\n-                }\n-\n-                Other(u) => {\n-                    D::reverse(&mut self.values, u);\n-                }\n-            }\n-        }\n-\n-        let v = self.undo_log.pop().unwrap();\n-        assert!(match v {\n-            OpenSnapshot => true,\n-            _ => false,\n-        });\n-        assert!(self.undo_log.len() == snapshot.length);\n-    }\n-\n-    /// Commits all changes since the last snapshot. Of course, they\n-    /// can still be undone if there is a snapshot further out.\n-    pub fn commit(&mut self, snapshot: Snapshot) {\n-        debug!(\"commit({})\", snapshot.length);\n-\n-        self.assert_open_snapshot(&snapshot);\n-\n-        if snapshot.length == 0 {\n-            // The root snapshot.\n-            self.undo_log.truncate(0);\n-        } else {\n-            self.undo_log[snapshot.length] = CommittedSnapshot;\n-        }\n-    }\n-}\n-\n-impl<D: SnapshotVecDelegate> ops::Deref for SnapshotVec<D> {\n-    type Target = [D::Value];\n-    fn deref(&self) -> &[D::Value] {\n-        &*self.values\n-    }\n-}\n-\n-impl<D: SnapshotVecDelegate> ops::DerefMut for SnapshotVec<D> {\n-    fn deref_mut(&mut self) -> &mut [D::Value] {\n-        &mut *self.values\n-    }\n-}\n-\n-impl<D: SnapshotVecDelegate> ops::Index<usize> for SnapshotVec<D> {\n-    type Output = D::Value;\n-    fn index(&self, index: usize) -> &D::Value {\n-        self.get(index)\n-    }\n-}\n-\n-impl<D: SnapshotVecDelegate> ops::IndexMut<usize> for SnapshotVec<D> {\n-    fn index_mut(&mut self, index: usize) -> &mut D::Value {\n-        self.get_mut(index)\n-    }\n-}\n-\n-impl<D: SnapshotVecDelegate> Extend<D::Value> for SnapshotVec<D> {\n-    fn extend<T>(&mut self, iterable: T) where T: IntoIterator<Item=D::Value> {\n-        for item in iterable {\n-            self.push(item);\n-        }\n-    }\n-}"}, {"sha": "5411ae0257a4b050be7a05cf9b0b19189808eb86", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "removed", "additions": 0, "deletions": 363, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/755bdaa19084c3ae116ad8320b99a6932fa7f0b1/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755bdaa19084c3ae116ad8320b99a6932fa7f0b1/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=755bdaa19084c3ae116ad8320b99a6932fa7f0b1", "patch": "@@ -1,363 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::marker;\n-use std::fmt::Debug;\n-use std::marker::PhantomData;\n-use snapshot_vec as sv;\n-\n-#[cfg(test)]\n-mod tests;\n-\n-/// This trait is implemented by any type that can serve as a type\n-/// variable. We call such variables *unification keys*. For example,\n-/// this trait is implemented by `IntVid`, which represents integral\n-/// variables.\n-///\n-/// Each key type has an associated value type `V`. For example, for\n-/// `IntVid`, this is `Option<IntVarValue>`, representing some\n-/// (possibly not yet known) sort of integer.\n-///\n-/// Clients are expected to provide implementations of this trait; you\n-/// can see some examples in the `test` module.\n-pub trait UnifyKey: Copy + Clone + Debug + PartialEq {\n-    type Value: Clone + PartialEq + Debug;\n-\n-    fn index(&self) -> u32;\n-\n-    fn from_index(u: u32) -> Self;\n-\n-    fn tag(k: Option<Self>) -> &'static str;\n-}\n-\n-/// This trait is implemented for unify values that can be\n-/// combined. This relation should be a monoid.\n-pub trait Combine {\n-    fn combine(&self, other: &Self) -> Self;\n-}\n-\n-impl Combine for () {\n-    fn combine(&self, _other: &()) {}\n-}\n-\n-/// Value of a unification key. We implement Tarjan's union-find\n-/// algorithm: when two keys are unified, one of them is converted\n-/// into a \"redirect\" pointing at the other. These redirects form a\n-/// DAG: the roots of the DAG (nodes that are not redirected) are each\n-/// associated with a value of type `V` and a rank. The rank is used\n-/// to keep the DAG relatively balanced, which helps keep the running\n-/// time of the algorithm under control. For more information, see\n-/// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n-#[derive(PartialEq,Clone,Debug)]\n-pub struct VarValue<K: UnifyKey> {\n-    parent: K, // if equal to self, this is a root\n-    value: K::Value, // value assigned (only relevant to root)\n-    rank: u32, // max depth (only relevant to root)\n-}\n-\n-/// Table of unification keys and their values.\n-pub struct UnificationTable<K: UnifyKey> {\n-    /// Indicates the current value of each key.\n-    values: sv::SnapshotVec<Delegate<K>>,\n-}\n-\n-/// At any time, users may snapshot a unification table.  The changes\n-/// made during the snapshot may either be *committed* or *rolled back*.\n-pub struct Snapshot<K: UnifyKey> {\n-    // Link snapshot to the key type `K` of the table.\n-    marker: marker::PhantomData<K>,\n-    snapshot: sv::Snapshot,\n-}\n-\n-#[derive(Copy, Clone)]\n-struct Delegate<K>(PhantomData<K>);\n-\n-impl<K: UnifyKey> VarValue<K> {\n-    fn new_var(key: K, value: K::Value) -> VarValue<K> {\n-        VarValue::new(key, value, 0)\n-    }\n-\n-    fn new(parent: K, value: K::Value, rank: u32) -> VarValue<K> {\n-        VarValue {\n-            parent: parent, // this is a root\n-            value,\n-            rank,\n-        }\n-    }\n-\n-    fn redirect(self, to: K) -> VarValue<K> {\n-        VarValue { parent: to, ..self }\n-    }\n-\n-    fn root(self, rank: u32, value: K::Value) -> VarValue<K> {\n-        VarValue {\n-            rank,\n-            value,\n-            ..self\n-        }\n-    }\n-\n-    /// Returns the key of this node. Only valid if this is a root\n-    /// node, which you yourself must ensure.\n-    fn key(&self) -> K {\n-        self.parent\n-    }\n-\n-    fn parent(&self, self_key: K) -> Option<K> {\n-        self.if_not_self(self.parent, self_key)\n-    }\n-\n-    fn if_not_self(&self, key: K, self_key: K) -> Option<K> {\n-        if key == self_key { None } else { Some(key) }\n-    }\n-}\n-\n-/// We can't use V:LatticeValue, much as I would like to,\n-/// because frequently the pattern is that V=Option<U> for some\n-/// other type parameter U, and we have no way to say\n-/// Option<U>:LatticeValue.\n-\n-impl<K: UnifyKey> UnificationTable<K> {\n-    pub fn new() -> UnificationTable<K> {\n-        UnificationTable { values: sv::SnapshotVec::new() }\n-    }\n-\n-    /// Starts a new snapshot. Each snapshot must be either\n-    /// rolled back or committed in a \"LIFO\" (stack) order.\n-    pub fn snapshot(&mut self) -> Snapshot<K> {\n-        Snapshot {\n-            marker: marker::PhantomData::<K>,\n-            snapshot: self.values.start_snapshot(),\n-        }\n-    }\n-\n-    /// Reverses all changes since the last snapshot. Also\n-    /// removes any keys that have been created since then.\n-    pub fn rollback_to(&mut self, snapshot: Snapshot<K>) {\n-        debug!(\"{}: rollback_to()\", UnifyKey::tag(None::<K>));\n-        self.values.rollback_to(snapshot.snapshot);\n-    }\n-\n-    /// Commits all changes since the last snapshot. Of course, they\n-    /// can still be undone if there is a snapshot further out.\n-    pub fn commit(&mut self, snapshot: Snapshot<K>) {\n-        debug!(\"{}: commit()\", UnifyKey::tag(None::<K>));\n-        self.values.commit(snapshot.snapshot);\n-    }\n-\n-    pub fn new_key(&mut self, value: K::Value) -> K {\n-        let len = self.values.len();\n-        let key: K = UnifyKey::from_index(len as u32);\n-        self.values.push(VarValue::new_var(key, value));\n-        debug!(\"{}: created new key: {:?}\", UnifyKey::tag(None::<K>), key);\n-        key\n-    }\n-\n-    /// Find the root node for `vid`. This uses the standard\n-    /// union-find algorithm with path compression:\n-    /// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n-    ///\n-    /// NB. This is a building-block operation and you would probably\n-    /// prefer to call `probe` below.\n-    fn get(&mut self, vid: K) -> VarValue<K> {\n-        let index = vid.index() as usize;\n-        let mut value: VarValue<K> = self.values.get(index).clone();\n-        match value.parent(vid) {\n-            Some(redirect) => {\n-                let root: VarValue<K> = self.get(redirect);\n-                if root.key() != redirect {\n-                    // Path compression\n-                    value.parent = root.key();\n-                    self.values.set(index, value);\n-                }\n-                root\n-            }\n-            None => value,\n-        }\n-    }\n-\n-    fn is_root(&self, key: K) -> bool {\n-        let index = key.index() as usize;\n-        self.values.get(index).parent(key).is_none()\n-    }\n-\n-    /// Sets the value for `vid` to `new_value`. `vid` MUST be a root\n-    /// node! This is an internal operation used to impl other things.\n-    fn set(&mut self, key: K, new_value: VarValue<K>) {\n-        assert!(self.is_root(key));\n-\n-        debug!(\"Updating variable {:?} to {:?}\", key, new_value);\n-\n-        let index = key.index() as usize;\n-        self.values.set(index, new_value);\n-    }\n-\n-    /// Either redirects `node_a` to `node_b` or vice versa, depending\n-    /// on the relative rank. The value associated with the new root\n-    /// will be `new_value`.\n-    ///\n-    /// NB: This is the \"union\" operation of \"union-find\". It is\n-    /// really more of a building block. If the values associated with\n-    /// your key are non-trivial, you would probably prefer to call\n-    /// `unify_var_var` below.\n-    fn unify(&mut self, root_a: VarValue<K>, root_b: VarValue<K>, new_value: K::Value) -> K {\n-        debug!(\"unify(root_a(id={:?}, rank={:?}), root_b(id={:?}, rank={:?}))\",\n-               root_a.key(),\n-               root_a.rank,\n-               root_b.key(),\n-               root_b.rank);\n-\n-        if root_a.rank > root_b.rank {\n-            // a has greater rank, so a should become b's parent,\n-            // i.e., b should redirect to a.\n-            self.redirect_root(root_a.rank, root_b, root_a, new_value)\n-        } else if root_a.rank < root_b.rank {\n-            // b has greater rank, so a should redirect to b.\n-            self.redirect_root(root_b.rank, root_a, root_b, new_value)\n-        } else {\n-            // If equal, redirect one to the other and increment the\n-            // other's rank.\n-            self.redirect_root(root_a.rank + 1, root_a, root_b, new_value)\n-        }\n-    }\n-\n-    fn redirect_root(&mut self,\n-                     new_rank: u32,\n-                     old_root: VarValue<K>,\n-                     new_root: VarValue<K>,\n-                     new_value: K::Value)\n-                     -> K {\n-        let old_root_key = old_root.key();\n-        let new_root_key = new_root.key();\n-        self.set(old_root_key, old_root.redirect(new_root_key));\n-        self.set(new_root_key, new_root.root(new_rank, new_value));\n-        new_root_key\n-    }\n-}\n-\n-impl<K: UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n-    type Value = VarValue<K>;\n-    type Undo = ();\n-\n-    fn reverse(_: &mut Vec<VarValue<K>>, _: ()) {}\n-}\n-\n-/// # Base union-find algorithm, where we are just making sets\n-\n-impl<'tcx, K: UnifyKey> UnificationTable<K>\n-    where K::Value: Combine\n-{\n-    pub fn union(&mut self, a_id: K, b_id: K) -> K {\n-        let node_a = self.get(a_id);\n-        let node_b = self.get(b_id);\n-        let a_id = node_a.key();\n-        let b_id = node_b.key();\n-        if a_id != b_id {\n-            let new_value = node_a.value.combine(&node_b.value);\n-            self.unify(node_a, node_b, new_value)\n-        } else {\n-            a_id\n-        }\n-    }\n-\n-    pub fn find(&mut self, id: K) -> K {\n-        self.get(id).key()\n-    }\n-\n-    pub fn find_value(&mut self, id: K) -> K::Value {\n-        self.get(id).value\n-    }\n-\n-    #[cfg(test)]\n-    fn unioned(&mut self, a_id: K, b_id: K) -> bool {\n-        self.find(a_id) == self.find(b_id)\n-    }\n-}\n-\n-/// # Non-subtyping unification\n-///\n-/// Code to handle keys which carry a value, like ints,\n-/// floats---anything that doesn't have a subtyping relationship we\n-/// need to worry about.\n-\n-impl<'tcx, K, V> UnificationTable<K>\n-    where K: UnifyKey<Value = Option<V>>,\n-          V: Clone + PartialEq + Debug\n-{\n-    pub fn unify_var_var(&mut self, a_id: K, b_id: K) -> Result<K, (V, V)> {\n-        let node_a = self.get(a_id);\n-        let node_b = self.get(b_id);\n-        let a_id = node_a.key();\n-        let b_id = node_b.key();\n-\n-        if a_id == b_id {\n-            return Ok(a_id);\n-        }\n-\n-        let combined = {\n-            match (&node_a.value, &node_b.value) {\n-                (&None, &None) => None,\n-                (&Some(ref v), &None) |\n-                (&None, &Some(ref v)) => Some(v.clone()),\n-                (&Some(ref v1), &Some(ref v2)) => {\n-                    if *v1 != *v2 {\n-                        return Err((v1.clone(), v2.clone()));\n-                    }\n-                    Some(v1.clone())\n-                }\n-            }\n-        };\n-\n-        Ok(self.unify(node_a, node_b, combined))\n-    }\n-\n-    /// Sets the value of the key `a_id` to `b`. Because simple keys do not have any subtyping\n-    /// relationships, if `a_id` already has a value, it must be the same as `b`.\n-    pub fn unify_var_value(&mut self, a_id: K, b: V) -> Result<(), (V, V)> {\n-        let mut node_a = self.get(a_id);\n-\n-        match node_a.value {\n-            None => {\n-                node_a.value = Some(b);\n-                self.set(node_a.key(), node_a);\n-                Ok(())\n-            }\n-\n-            Some(ref a_t) => {\n-                if *a_t == b {\n-                    Ok(())\n-                } else {\n-                    Err((a_t.clone(), b))\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn has_value(&mut self, id: K) -> bool {\n-        self.get(id).value.is_some()\n-    }\n-\n-    pub fn probe(&mut self, a_id: K) -> Option<V> {\n-        self.get(a_id).value\n-    }\n-\n-    pub fn unsolved_variables(&mut self) -> Vec<K> {\n-        self.values\n-            .iter()\n-            .filter_map(|vv| {\n-                if vv.value.is_some() {\n-                    None\n-                } else {\n-                    Some(vv.key())\n-                }\n-            })\n-            .collect()\n-    }\n-}"}, {"sha": "f29a7132e831b3f0e926968ce0d4fc6d843200fe", "filename": "src/librustc_data_structures/unify/tests.rs", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/755bdaa19084c3ae116ad8320b99a6932fa7f0b1/src%2Flibrustc_data_structures%2Funify%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755bdaa19084c3ae116ad8320b99a6932fa7f0b1/src%2Flibrustc_data_structures%2Funify%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Ftests.rs?ref=755bdaa19084c3ae116ad8320b99a6932fa7f0b1", "patch": "@@ -1,205 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(non_snake_case)]\n-\n-extern crate test;\n-use self::test::Bencher;\n-use unify::{UnifyKey, UnificationTable};\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-struct UnitKey(u32);\n-\n-impl UnifyKey for UnitKey {\n-    type Value = ();\n-    fn index(&self) -> u32 {\n-        self.0\n-    }\n-    fn from_index(u: u32) -> UnitKey {\n-        UnitKey(u)\n-    }\n-    fn tag(_: Option<UnitKey>) -> &'static str {\n-        \"UnitKey\"\n-    }\n-}\n-\n-#[test]\n-fn basic() {\n-    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n-    let k1 = ut.new_key(());\n-    let k2 = ut.new_key(());\n-    assert_eq!(ut.unioned(k1, k2), false);\n-    ut.union(k1, k2);\n-    assert_eq!(ut.unioned(k1, k2), true);\n-}\n-\n-#[test]\n-fn big_array() {\n-    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n-    let mut keys = Vec::new();\n-    const MAX: usize = 1 << 15;\n-\n-    for _ in 0..MAX {\n-        keys.push(ut.new_key(()));\n-    }\n-\n-    for i in 1..MAX {\n-        let l = keys[i - 1];\n-        let r = keys[i];\n-        ut.union(l, r);\n-    }\n-\n-    for i in 0..MAX {\n-        assert!(ut.unioned(keys[0], keys[i]));\n-    }\n-}\n-\n-#[bench]\n-fn big_array_bench(b: &mut Bencher) {\n-    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n-    let mut keys = Vec::new();\n-    const MAX: usize = 1 << 15;\n-\n-    for _ in 0..MAX {\n-        keys.push(ut.new_key(()));\n-    }\n-\n-\n-    b.iter(|| {\n-        for i in 1..MAX {\n-            let l = keys[i - 1];\n-            let r = keys[i];\n-            ut.union(l, r);\n-        }\n-\n-        for i in 0..MAX {\n-            assert!(ut.unioned(keys[0], keys[i]));\n-        }\n-    })\n-}\n-\n-#[test]\n-fn even_odd() {\n-    let mut ut: UnificationTable<UnitKey> = UnificationTable::new();\n-    let mut keys = Vec::new();\n-    const MAX: usize = 1 << 10;\n-\n-    for i in 0..MAX {\n-        let key = ut.new_key(());\n-        keys.push(key);\n-\n-        if i >= 2 {\n-            ut.union(key, keys[i - 2]);\n-        }\n-    }\n-\n-    for i in 1..MAX {\n-        assert!(!ut.unioned(keys[i - 1], keys[i]));\n-    }\n-\n-    for i in 2..MAX {\n-        assert!(ut.unioned(keys[i - 2], keys[i]));\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-struct IntKey(u32);\n-\n-impl UnifyKey for IntKey {\n-    type Value = Option<i32>;\n-    fn index(&self) -> u32 {\n-        self.0\n-    }\n-    fn from_index(u: u32) -> IntKey {\n-        IntKey(u)\n-    }\n-    fn tag(_: Option<IntKey>) -> &'static str {\n-        \"IntKey\"\n-    }\n-}\n-\n-/// Test unifying a key whose value is `Some(_)`  with a key whose value is `None`.\n-/// Afterwards both should be `Some(_)`.\n-#[test]\n-fn unify_key_Some_key_None() {\n-    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n-    let k1 = ut.new_key(Some(22));\n-    let k2 = ut.new_key(None);\n-    assert!(ut.unify_var_var(k1, k2).is_ok());\n-    assert_eq!(ut.probe(k2), Some(22));\n-    assert_eq!(ut.probe(k1), Some(22));\n-}\n-\n-/// Test unifying a key whose value is `None`  with a key whose value is `Some(_)`.\n-/// Afterwards both should be `Some(_)`.\n-#[test]\n-fn unify_key_None_key_Some() {\n-    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n-    let k1 = ut.new_key(Some(22));\n-    let k2 = ut.new_key(None);\n-    assert!(ut.unify_var_var(k2, k1).is_ok());\n-    assert_eq!(ut.probe(k2), Some(22));\n-    assert_eq!(ut.probe(k1), Some(22));\n-}\n-\n-/// Test unifying a key whose value is `Some(x)` with a key whose value is `Some(y)`.\n-/// This should yield an error.\n-#[test]\n-fn unify_key_Some_x_key_Some_y() {\n-    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n-    let k1 = ut.new_key(Some(22));\n-    let k2 = ut.new_key(Some(23));\n-    assert_eq!(ut.unify_var_var(k1, k2), Err((22, 23)));\n-    assert_eq!(ut.unify_var_var(k2, k1), Err((23, 22)));\n-    assert_eq!(ut.probe(k1), Some(22));\n-    assert_eq!(ut.probe(k2), Some(23));\n-}\n-\n-/// Test unifying a key whose value is `Some(x)` with a key whose value is `Some(x)`.\n-/// This should be ok.\n-#[test]\n-fn unify_key_Some_x_key_Some_x() {\n-    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n-    let k1 = ut.new_key(Some(22));\n-    let k2 = ut.new_key(Some(22));\n-    assert!(ut.unify_var_var(k1, k2).is_ok());\n-    assert_eq!(ut.probe(k1), Some(22));\n-    assert_eq!(ut.probe(k2), Some(22));\n-}\n-\n-/// Test unifying a key whose value is `None` with a value is `x`.\n-/// Afterwards key should be `x`.\n-#[test]\n-fn unify_key_None_val() {\n-    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n-    let k1 = ut.new_key(None);\n-    assert!(ut.unify_var_value(k1, 22).is_ok());\n-    assert_eq!(ut.probe(k1), Some(22));\n-}\n-\n-/// Test unifying a key whose value is `Some(x)` with the value `y`.\n-/// This should yield an error.\n-#[test]\n-fn unify_key_Some_x_val_y() {\n-    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n-    let k1 = ut.new_key(Some(22));\n-    assert_eq!(ut.unify_var_value(k1, 23), Err((22, 23)));\n-    assert_eq!(ut.probe(k1), Some(22));\n-}\n-\n-/// Test unifying a key whose value is `Some(x)` with the value `x`.\n-/// This should be ok.\n-#[test]\n-fn unify_key_Some_x_val_x() {\n-    let mut ut: UnificationTable<IntKey> = UnificationTable::new();\n-    let k1 = ut.new_key(Some(22));\n-    assert!(ut.unify_var_value(k1, 22).is_ok());\n-    assert_eq!(ut.probe(k1), Some(22));\n-}"}]}