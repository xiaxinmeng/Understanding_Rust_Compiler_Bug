{"sha": "c60b051bbb844dc06eace271372cbaf01ca6ca41", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MGIwNTFiYmI4NDRkYzA2ZWFjZTI3MTM3MmNiYWYwMWNhNmNhNDE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-17T00:09:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-17T00:09:01Z"}, "message": "Rollup merge of #74357 - nnethercote:symbol-related-improvements, r=oli-obk\n\nSome `Symbol` related improvements\n\nThese commits make things nicer and avoid some `Symbol::as_str()` calls.\n\nr? @oli-obk", "tree": {"sha": "e36ed78933f9aff841e43e9c8802b0bd6930e16c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e36ed78933f9aff841e43e9c8802b0bd6930e16c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c60b051bbb844dc06eace271372cbaf01ca6ca41", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfEOwdCRBK7hj4Ov3rIwAAdHIIAC0PaGZjurvKs11O86LVMX/y\nRKx6/kQz91/9nRPSZWllAGpz3NMxJCL08SMcHKvEPHDuXr67Kv+1Sdb/W0Vw0TyP\netouiHiU33kEkZikNCTTzSNjGOWiyQRCZd8KaIi8vltIysEua9ZoolLv6EuZ+Q7+\nemuI1lFVuZu+dbVwdPtB7ezhvXhr013ocUt34AsDpjR+x7AIw+xD2gbF+fiEr3wY\nUw+ZbrdZqxJjaLS/3DdOymMLrh2N6FLgjVcDVj5arMjkdrztU2NQIHLImt0MLI51\n3186aPyoGAmSIhaOaerQXc481Ej8/m4rRmQP0Xvx01kmnaSPBDBNWAcIOiR0oLw=\n=mjEh\n-----END PGP SIGNATURE-----\n", "payload": "tree e36ed78933f9aff841e43e9c8802b0bd6930e16c\nparent 0e70884083f8161e2abbb4a326a0dd0413e06f38\nparent a4ba18164a70d61eeed5b36a4cdcc6ed523a7d55\nauthor Manish Goregaokar <manishsmail@gmail.com> 1594944541 -0700\ncommitter GitHub <noreply@github.com> 1594944541 -0700\n\nRollup merge of #74357 - nnethercote:symbol-related-improvements, r=oli-obk\n\nSome `Symbol` related improvements\n\nThese commits make things nicer and avoid some `Symbol::as_str()` calls.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c60b051bbb844dc06eace271372cbaf01ca6ca41", "html_url": "https://github.com/rust-lang/rust/commit/c60b051bbb844dc06eace271372cbaf01ca6ca41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c60b051bbb844dc06eace271372cbaf01ca6ca41/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e70884083f8161e2abbb4a326a0dd0413e06f38", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e70884083f8161e2abbb4a326a0dd0413e06f38", "html_url": "https://github.com/rust-lang/rust/commit/0e70884083f8161e2abbb4a326a0dd0413e06f38"}, {"sha": "a4ba18164a70d61eeed5b36a4cdcc6ed523a7d55", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4ba18164a70d61eeed5b36a4cdcc6ed523a7d55", "html_url": "https://github.com/rust-lang/rust/commit/a4ba18164a70d61eeed5b36a4cdcc6ed523a7d55"}], "stats": {"total": 699, "additions": 396, "deletions": 303}, "files": [{"sha": "cef0da60a61c8c642693d930fc9079d9d9089e88", "filename": "src/librustc_builtin_macros/deriving/bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fbounds.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -16,9 +16,9 @@ pub fn expand_deriving_copy(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(cx, marker::Copy),\n+        path: path_std!(marker::Copy),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: true,\n         methods: Vec::new(),"}, {"sha": "b307ee26c91d518e513cc31379a77f69698e2573", "filename": "src/librustc_builtin_macros/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fclone.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -56,7 +56,7 @@ pub fn expand_deriving_clone(\n                 }\n             }\n             ItemKind::Union(..) => {\n-                bounds = vec![Literal(path_std!(cx, marker::Copy))];\n+                bounds = vec![Literal(path_std!(marker::Copy))];\n                 is_shallow = true;\n                 substructure = combine_substructure(Box::new(|c, s, sub| {\n                     cs_clone_shallow(\"Clone\", c, s, sub, true)\n@@ -78,14 +78,14 @@ pub fn expand_deriving_clone(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(cx, clone::Clone),\n+        path: path_std!(clone::Clone),\n         additional_bounds: bounds,\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: true,\n         methods: vec![MethodDef {\n             name: sym::clone,\n-            generics: LifetimeBounds::empty(),\n+            generics: Bounds::empty(),\n             explicit_self: borrowed_explicit_self(),\n             args: Vec::new(),\n             ret_ty: Self_,"}, {"sha": "d1b799cd6a112d841614ccba3f1d9731f70b76ef", "filename": "src/librustc_builtin_macros/deriving/cmp/eq.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Feq.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -22,14 +22,14 @@ pub fn expand_deriving_eq(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(cx, cmp::Eq),\n+        path: path_std!(cmp::Eq),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: true,\n         methods: vec![MethodDef {\n             name: sym::assert_receiver_is_total_eq,\n-            generics: LifetimeBounds::empty(),\n+            generics: Bounds::empty(),\n             explicit_self: borrowed_explicit_self(),\n             args: vec![],\n             ret_ty: nil_ty(),\n@@ -43,13 +43,7 @@ pub fn expand_deriving_eq(\n         associated_types: Vec::new(),\n     };\n \n-    super::inject_impl_of_structural_trait(\n-        cx,\n-        span,\n-        item,\n-        path_std!(cx, marker::StructuralEq),\n-        push,\n-    );\n+    super::inject_impl_of_structural_trait(cx, span, item, path_std!(marker::StructuralEq), push);\n \n     trait_def.expand_ext(cx, mitem, item, push, true)\n }"}, {"sha": "3bf3860d32307d52c3f53d07fccf571f58ddf346", "filename": "src/librustc_builtin_macros/deriving/cmp/ord.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -20,17 +20,17 @@ pub fn expand_deriving_ord(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(cx, cmp::Ord),\n+        path: path_std!(cmp::Ord),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::cmp,\n-            generics: LifetimeBounds::empty(),\n+            generics: Bounds::empty(),\n             explicit_self: borrowed_explicit_self(),\n-            args: vec![(borrowed_self(), \"other\")],\n-            ret_ty: Literal(path_std!(cx, cmp::Ordering)),\n+            args: vec![(borrowed_self(), sym::other)],\n+            ret_ty: Literal(path_std!(cmp::Ordering)),\n             attributes: attrs,\n             is_unsafe: false,\n             unify_fieldless_variants: true,"}, {"sha": "d8edd641acd52dd945f038f942d2ce7ed61877d6", "filename": "src/librustc_builtin_macros/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -69,9 +69,9 @@ pub fn expand_deriving_partial_eq(\n             let attrs = vec![cx.attribute(inline)];\n             MethodDef {\n                 name: $name,\n-                generics: LifetimeBounds::empty(),\n+                generics: Bounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec![(borrowed_self(), \"other\")],\n+                args: vec![(borrowed_self(), sym::other)],\n                 ret_ty: Literal(path_local!(bool)),\n                 attributes: attrs,\n                 is_unsafe: false,\n@@ -85,7 +85,7 @@ pub fn expand_deriving_partial_eq(\n         cx,\n         span,\n         item,\n-        path_std!(cx, marker::StructuralPartialEq),\n+        path_std!(marker::StructuralPartialEq),\n         push,\n     );\n \n@@ -100,9 +100,9 @@ pub fn expand_deriving_partial_eq(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(cx, cmp::PartialEq),\n+        path: path_std!(cmp::PartialEq),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods,"}, {"sha": "39a747c856839455077a808c190eb83224299072", "filename": "src/librustc_builtin_macros/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -23,9 +23,9 @@ pub fn expand_deriving_partial_ord(\n             let attrs = vec![cx.attribute(inline)];\n             MethodDef {\n                 name: $name,\n-                generics: LifetimeBounds::empty(),\n+                generics: Bounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec![(borrowed_self(), \"other\")],\n+                args: vec![(borrowed_self(), sym::other)],\n                 ret_ty: Literal(path_local!(bool)),\n                 attributes: attrs,\n                 is_unsafe: false,\n@@ -37,9 +37,9 @@ pub fn expand_deriving_partial_ord(\n         }};\n     }\n \n-    let ordering_ty = Literal(path_std!(cx, cmp::Ordering));\n+    let ordering_ty = Literal(path_std!(cmp::Ordering));\n     let ret_ty = Literal(Path::new_(\n-        pathvec_std!(cx, option::Option),\n+        pathvec_std!(option::Option),\n         None,\n         vec![Box::new(ordering_ty)],\n         PathKind::Std,\n@@ -50,9 +50,9 @@ pub fn expand_deriving_partial_ord(\n \n     let partial_cmp_def = MethodDef {\n         name: sym::partial_cmp,\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         explicit_self: borrowed_explicit_self(),\n-        args: vec![(borrowed_self(), \"other\")],\n+        args: vec![(borrowed_self(), sym::other)],\n         ret_ty,\n         attributes: attrs,\n         is_unsafe: false,\n@@ -80,9 +80,9 @@ pub fn expand_deriving_partial_ord(\n     let trait_def = TraitDef {\n         span,\n         attributes: vec![],\n-        path: path_std!(cx, cmp::PartialOrd),\n+        path: path_std!(cmp::PartialOrd),\n         additional_bounds: vec![],\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods,"}, {"sha": "76e21bc43c52d84ec614ded321737770031e515d", "filename": "src/librustc_builtin_macros/deriving/debug.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -18,22 +18,22 @@ pub fn expand_deriving_debug(\n ) {\n     // &mut ::std::fmt::Formatter\n     let fmtr =\n-        Ptr(Box::new(Literal(path_std!(cx, fmt::Formatter))), Borrowed(None, ast::Mutability::Mut));\n+        Ptr(Box::new(Literal(path_std!(fmt::Formatter))), Borrowed(None, ast::Mutability::Mut));\n \n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(cx, fmt::Debug),\n+        path: path_std!(fmt::Debug),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::fmt,\n-            generics: LifetimeBounds::empty(),\n+            generics: Bounds::empty(),\n             explicit_self: borrowed_explicit_self(),\n-            args: vec![(fmtr, \"f\")],\n-            ret_ty: Literal(path_std!(cx, fmt::Result)),\n+            args: vec![(fmtr, sym::f)],\n+            ret_ty: Literal(path_std!(fmt::Result)),\n             attributes: Vec::new(),\n             is_unsafe: false,\n             unify_fieldless_variants: false,\n@@ -62,7 +62,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // We want to make sure we have the ctxt set so that we can use unstable methods\n     let span = cx.with_def_site_ctxt(span);\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n-    let builder = cx.ident_of(\"debug_trait_builder\", span);\n+    let builder = Ident::new(sym::debug_trait_builder, span);\n     let builder_expr = cx.expr_ident(span, builder);\n \n     let fmt = substr.nonself_args[0].clone();\n@@ -71,7 +71,8 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     match vdata {\n         ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n             // tuple struct/\"normal\" variant\n-            let expr = cx.expr_method_call(span, fmt, cx.ident_of(\"debug_tuple\", span), vec![name]);\n+            let expr =\n+                cx.expr_method_call(span, fmt, Ident::new(sym::debug_tuple, span), vec![name]);\n             stmts.push(cx.stmt_let(span, true, builder, expr));\n \n             for field in fields {\n@@ -94,7 +95,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         ast::VariantData::Struct(..) => {\n             // normal struct/struct variant\n             let expr =\n-                cx.expr_method_call(span, fmt, cx.ident_of(\"debug_struct\", span), vec![name]);\n+                cx.expr_method_call(span, fmt, Ident::new(sym::debug_struct, span), vec![name]);\n             stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n             for field in fields {\n@@ -117,7 +118,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         }\n     }\n \n-    let expr = cx.expr_method_call(span, builder_expr, cx.ident_of(\"finish\", span), vec![]);\n+    let expr = cx.expr_method_call(span, builder_expr, Ident::new(sym::finish, span), vec![]);\n \n     stmts.push(cx.stmt_expr(expr));\n     let block = cx.block(span, stmts);"}, {"sha": "ce8c2dfe4d5a099ebc5890ab5b4ea9e40db82a4f", "filename": "src/librustc_builtin_macros/deriving/decodable.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::ast;\n use rustc_ast::ast::{Expr, MetaItem, Mutability};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n pub fn expand_deriving_rustc_decodable(\n@@ -18,38 +18,37 @@ pub fn expand_deriving_rustc_decodable(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let krate = \"rustc_serialize\";\n-    let typaram = \"__D\";\n+    let krate = sym::rustc_serialize;\n+    let typaram = sym::__D;\n \n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: Path::new_(vec![krate, \"Decodable\"], None, vec![], PathKind::Global),\n+        path: Path::new_(vec![krate, sym::Decodable], None, vec![], PathKind::Global),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::decode,\n-            generics: LifetimeBounds {\n-                lifetimes: Vec::new(),\n+            generics: Bounds {\n                 bounds: vec![(\n                     typaram,\n-                    vec![Path::new_(vec![krate, \"Decoder\"], None, vec![], PathKind::Global)],\n+                    vec![Path::new_(vec![krate, sym::Decoder], None, vec![], PathKind::Global)],\n                 )],\n             },\n             explicit_self: None,\n             args: vec![(\n                 Ptr(Box::new(Literal(Path::new_local(typaram))), Borrowed(None, Mutability::Mut)),\n-                \"d\",\n+                sym::d,\n             )],\n             ret_ty: Literal(Path::new_(\n-                pathvec_std!(cx, result::Result),\n+                pathvec_std!(result::Result),\n                 None,\n                 vec![\n                     Box::new(Self_),\n                     Box::new(Literal(Path::new_(\n-                        vec![typaram, \"Error\"],\n+                        vec![typaram, sym::Error],\n                         None,\n                         vec![],\n                         PathKind::Local,\n@@ -74,17 +73,17 @@ fn decodable_substructure(\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substr: &Substructure<'_>,\n-    krate: &str,\n+    krate: Symbol,\n ) -> P<Expr> {\n     let decoder = substr.nonself_args[0].clone();\n     let recurse = vec![\n-        cx.ident_of(krate, trait_span),\n-        cx.ident_of(\"Decodable\", trait_span),\n-        cx.ident_of(\"decode\", trait_span),\n+        Ident::new(krate, trait_span),\n+        Ident::new(sym::Decodable, trait_span),\n+        Ident::new(sym::decode, trait_span),\n     ];\n     let exprdecode = cx.expr_path(cx.path_global(trait_span, recurse));\n     // throw an underscore in front to suppress unused variable warnings\n-    let blkarg = cx.ident_of(\"_d\", trait_span);\n+    let blkarg = Ident::new(sym::_d, trait_span);\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n \n     match *substr.fields {\n@@ -93,7 +92,7 @@ fn decodable_substructure(\n                 Unnamed(ref fields, _) => fields.len(),\n                 Named(ref fields) => fields.len(),\n             };\n-            let read_struct_field = cx.ident_of(\"read_struct_field\", trait_span);\n+            let read_struct_field = Ident::new(sym::read_struct_field, trait_span);\n \n             let path = cx.path_ident(trait_span, substr.type_ident);\n             let result =\n@@ -116,7 +115,7 @@ fn decodable_substructure(\n             cx.expr_method_call(\n                 trait_span,\n                 decoder,\n-                cx.ident_of(\"read_struct\", trait_span),\n+                Ident::new(sym::read_struct, trait_span),\n                 vec![\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, nfields),\n@@ -125,11 +124,11 @@ fn decodable_substructure(\n             )\n         }\n         StaticEnum(_, ref fields) => {\n-            let variant = cx.ident_of(\"i\", trait_span);\n+            let variant = Ident::new(sym::i, trait_span);\n \n             let mut arms = Vec::with_capacity(fields.len() + 1);\n             let mut variants = Vec::with_capacity(fields.len());\n-            let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\", trait_span);\n+            let rvariant_arg = Ident::new(sym::read_enum_variant_arg, trait_span);\n \n             for (i, &(ident, v_span, ref parts)) in fields.iter().enumerate() {\n                 variants.push(cx.expr_str(v_span, ident.name));\n@@ -164,13 +163,13 @@ fn decodable_substructure(\n             let result = cx.expr_method_call(\n                 trait_span,\n                 blkdecoder,\n-                cx.ident_of(\"read_enum_variant\", trait_span),\n+                Ident::new(sym::read_enum_variant, trait_span),\n                 vec![variant_vec, lambda],\n             );\n             cx.expr_method_call(\n                 trait_span,\n                 decoder,\n-                cx.ident_of(\"read_enum\", trait_span),\n+                Ident::new(sym::read_enum, trait_span),\n                 vec![\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.lambda1(trait_span, result, blkarg),"}, {"sha": "8ca1be1efb635f7685382e853d35e7e57e34d55f", "filename": "src/librustc_builtin_macros/deriving/default.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -1,6 +1,5 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n-use crate::deriving::path_std;\n \n use rustc_ast::ast::{Expr, MetaItem};\n use rustc_ast::ptr::P;\n@@ -21,14 +20,14 @@ pub fn expand_deriving_default(\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: path_std!(cx, default::Default),\n+        path: Path::new(vec![kw::Default, sym::Default]),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: kw::Default,\n-            generics: LifetimeBounds::empty(),\n+            generics: Bounds::empty(),\n             explicit_self: None,\n             args: Vec::new(),\n             ret_ty: Self_,"}, {"sha": "7a880357a594740939a7fd55bfe129668047d994", "filename": "src/librustc_builtin_macros/deriving/encodable.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -92,7 +92,7 @@ use crate::deriving::pathvec_std;\n use rustc_ast::ast::{Expr, ExprKind, MetaItem, Mutability};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n pub fn expand_deriving_rustc_encodable(\n@@ -102,38 +102,42 @@ pub fn expand_deriving_rustc_encodable(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let krate = \"rustc_serialize\";\n-    let typaram = \"__S\";\n+    let krate = sym::rustc_serialize;\n+    let typaram = sym::__S;\n \n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n-        path: Path::new_(vec![krate, \"Encodable\"], None, vec![], PathKind::Global),\n+        path: Path::new_(vec![krate, sym::Encodable], None, vec![], PathKind::Global),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::encode,\n-            generics: LifetimeBounds {\n-                lifetimes: Vec::new(),\n+            generics: Bounds {\n                 bounds: vec![(\n                     typaram,\n-                    vec![Path::new_(vec![krate, \"Encoder\"], None, vec![], PathKind::Global)],\n+                    vec![Path::new_(vec![krate, sym::Encoder], None, vec![], PathKind::Global)],\n                 )],\n             },\n             explicit_self: borrowed_explicit_self(),\n             args: vec![(\n                 Ptr(Box::new(Literal(Path::new_local(typaram))), Borrowed(None, Mutability::Mut)),\n-                \"s\",\n+                // FIXME: we could use `sym::s` here, but making `s` a static\n+                // symbol changes the symbol index ordering in a way that makes\n+                // ui/lint/rfc-2457-non-ascii-idents/lint-confusable-idents.rs\n+                // fail. The linting code should be fixed so that its output\n+                // does not depend on the symbol index ordering.\n+                Symbol::intern(\"s\"),\n             )],\n             ret_ty: Literal(Path::new_(\n-                pathvec_std!(cx, result::Result),\n+                pathvec_std!(result::Result),\n                 None,\n                 vec![\n                     Box::new(Tuple(Vec::new())),\n                     Box::new(Literal(Path::new_(\n-                        vec![typaram, \"Error\"],\n+                        vec![typaram, sym::Error],\n                         None,\n                         vec![],\n                         PathKind::Local,\n@@ -158,24 +162,24 @@ fn encodable_substructure(\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substr: &Substructure<'_>,\n-    krate: &'static str,\n+    krate: Symbol,\n ) -> P<Expr> {\n     let encoder = substr.nonself_args[0].clone();\n     // throw an underscore in front to suppress unused variable warnings\n-    let blkarg = cx.ident_of(\"_e\", trait_span);\n+    let blkarg = Ident::new(sym::_e, trait_span);\n     let blkencoder = cx.expr_ident(trait_span, blkarg);\n     let fn_path = cx.expr_path(cx.path_global(\n         trait_span,\n         vec![\n-            cx.ident_of(krate, trait_span),\n-            cx.ident_of(\"Encodable\", trait_span),\n-            cx.ident_of(\"encode\", trait_span),\n+            Ident::new(krate, trait_span),\n+            Ident::new(sym::Encodable, trait_span),\n+            Ident::new(sym::encode, trait_span),\n         ],\n     ));\n \n     match *substr.fields {\n         Struct(_, ref fields) => {\n-            let emit_struct_field = cx.ident_of(\"emit_struct_field\", trait_span);\n+            let emit_struct_field = Ident::new(sym::emit_struct_field, trait_span);\n             let mut stmts = Vec::new();\n             for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n@@ -215,7 +219,7 @@ fn encodable_substructure(\n             cx.expr_method_call(\n                 trait_span,\n                 encoder,\n-                cx.ident_of(\"emit_struct\", trait_span),\n+                Ident::new(sym::emit_struct, trait_span),\n                 vec![\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, fields.len()),\n@@ -231,7 +235,7 @@ fn encodable_substructure(\n             // actually exist.\n             let me = cx.stmt_let(trait_span, false, blkarg, encoder);\n             let encoder = cx.expr_ident(trait_span, blkarg);\n-            let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\", trait_span);\n+            let emit_variant_arg = Ident::new(sym::emit_enum_variant_arg, trait_span);\n             let mut stmts = Vec::new();\n             if !fields.is_empty() {\n                 let last = fields.len() - 1;\n@@ -264,7 +268,7 @@ fn encodable_substructure(\n             let call = cx.expr_method_call(\n                 trait_span,\n                 blkencoder,\n-                cx.ident_of(\"emit_enum_variant\", trait_span),\n+                Ident::new(sym::emit_enum_variant, trait_span),\n                 vec![\n                     name,\n                     cx.expr_usize(trait_span, idx),\n@@ -276,7 +280,7 @@ fn encodable_substructure(\n             let ret = cx.expr_method_call(\n                 trait_span,\n                 encoder,\n-                cx.ident_of(\"emit_enum\", trait_span),\n+                Ident::new(sym::emit_enum, trait_span),\n                 vec![cx.expr_str(trait_span, substr.type_ident.name), blk],\n             );\n             cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))"}, {"sha": "c43d1cf1888c494a012873b554e5c6b1a004a9c4", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -191,7 +191,7 @@ use rustc_span::source_map::respan;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n \n-use ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};\n+use ty::{Bounds, Path, Ptr, PtrTy, Self_, Ty};\n \n use crate::deriving;\n \n@@ -204,14 +204,14 @@ pub struct TraitDef<'a> {\n     pub attributes: Vec<ast::Attribute>,\n \n     /// Path of the trait, including any type parameters\n-    pub path: Path<'a>,\n+    pub path: Path,\n \n     /// Additional bounds required of any type parameters of the type,\n     /// other than the current trait\n-    pub additional_bounds: Vec<Ty<'a>>,\n+    pub additional_bounds: Vec<Ty>,\n \n     /// Any extra lifetimes and/or bounds, e.g., `D: serialize::Decoder`\n-    pub generics: LifetimeBounds<'a>,\n+    pub generics: Bounds,\n \n     /// Is it an `unsafe` trait?\n     pub is_unsafe: bool,\n@@ -221,25 +221,25 @@ pub struct TraitDef<'a> {\n \n     pub methods: Vec<MethodDef<'a>>,\n \n-    pub associated_types: Vec<(Ident, Ty<'a>)>,\n+    pub associated_types: Vec<(Ident, Ty)>,\n }\n \n pub struct MethodDef<'a> {\n     /// name of the method\n     pub name: Symbol,\n     /// List of generics, e.g., `R: rand::Rng`\n-    pub generics: LifetimeBounds<'a>,\n+    pub generics: Bounds,\n \n     /// Whether there is a self argument (outer Option) i.e., whether\n     /// this is a static function, and whether it is a pointer (inner\n     /// Option)\n     pub explicit_self: Option<Option<PtrTy>>,\n \n     /// Arguments other than the self argument\n-    pub args: Vec<(Ty<'a>, &'a str)>,\n+    pub args: Vec<(Ty, Symbol)>,\n \n     /// Returns type\n-    pub ret_ty: Ty<'a>,\n+    pub ret_ty: Ty,\n \n     pub attributes: Vec<ast::Attribute>,\n \n@@ -865,7 +865,7 @@ impl<'a> MethodDef<'a> {\n \n         for (ty, name) in self.args.iter() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(name, trait_.span);\n+            let ident = Ident::new(*name, trait_.span);\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -1170,8 +1170,10 @@ impl<'a> MethodDef<'a> {\n             )\n             .collect::<Vec<String>>();\n \n-        let self_arg_idents =\n-            self_arg_names.iter().map(|name| cx.ident_of(name, sp)).collect::<Vec<Ident>>();\n+        let self_arg_idents = self_arg_names\n+            .iter()\n+            .map(|name| Ident::from_str_and_span(name, sp))\n+            .collect::<Vec<Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each self_arg to an int\n@@ -1180,7 +1182,7 @@ impl<'a> MethodDef<'a> {\n             .iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", &name[..]);\n-                cx.ident_of(&vi_suffix[..], trait_.span)\n+                Ident::from_str_and_span(&vi_suffix, trait_.span)\n             })\n             .collect::<Vec<Ident>>();\n \n@@ -1568,7 +1570,7 @@ impl<'a> TraitDef<'a> {\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n             let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-            let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i), self.span);\n+            let ident = Ident::from_str_and_span(&format!(\"{}_{}\", prefix, i), self.span);\n             paths.push(ident.with_span_pos(sp));\n             let val = cx.expr_path(cx.path_ident(sp, ident));\n             let val = if use_temporaries { val } else { cx.expr_deref(sp, val) };"}, {"sha": "51314dbcffc06e5d50358f6f846632f16a53d499", "filename": "src/librustc_builtin_macros/deriving/generic/ty.rs", "status": "modified", "additions": 32, "deletions": 39, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::ast::{self, Expr, GenericArg, GenericParamKind, Generics, SelfKin\n use rustc_ast::ptr::P;\n use rustc_expand::base::ExtCtxt;\n use rustc_span::source_map::{respan, DUMMY_SP};\n-use rustc_span::symbol::{kw, Ident};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n \n /// The types of pointers\n@@ -24,10 +24,10 @@ pub enum PtrTy {\n /// A path, e.g., `::std::option::Option::<i32>` (global). Has support\n /// for type parameters and a lifetime.\n #[derive(Clone)]\n-pub struct Path<'a> {\n-    path: Vec<&'a str>,\n+pub struct Path {\n+    path: Vec<Symbol>,\n     lifetime: Option<Ident>,\n-    params: Vec<Box<Ty<'a>>>,\n+    params: Vec<Box<Ty>>,\n     kind: PathKind,\n }\n \n@@ -38,19 +38,19 @@ pub enum PathKind {\n     Std,\n }\n \n-impl<'a> Path<'a> {\n-    pub fn new(path: Vec<&str>) -> Path<'_> {\n+impl Path {\n+    pub fn new(path: Vec<Symbol>) -> Path {\n         Path::new_(path, None, Vec::new(), PathKind::Std)\n     }\n-    pub fn new_local(path: &str) -> Path<'_> {\n+    pub fn new_local(path: Symbol) -> Path {\n         Path::new_(vec![path], None, Vec::new(), PathKind::Local)\n     }\n-    pub fn new_<'r>(\n-        path: Vec<&'r str>,\n+    pub fn new_(\n+        path: Vec<Symbol>,\n         lifetime: Option<Ident>,\n-        params: Vec<Box<Ty<'r>>>,\n+        params: Vec<Box<Ty>>,\n         kind: PathKind,\n-    ) -> Path<'r> {\n+    ) -> Path {\n         Path { path, lifetime, params, kind }\n     }\n \n@@ -70,7 +70,7 @@ impl<'a> Path<'a> {\n         self_ty: Ident,\n         self_generics: &Generics,\n     ) -> ast::Path {\n-        let mut idents = self.path.iter().map(|s| cx.ident_of(*s, span)).collect();\n+        let mut idents = self.path.iter().map(|s| Ident::new(*s, span)).collect();\n         let lt = mk_lifetimes(cx, span, &self.lifetime);\n         let tys: Vec<P<ast::Ty>> =\n             self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics)).collect();\n@@ -94,33 +94,33 @@ impl<'a> Path<'a> {\n \n /// A type. Supports pointers, Self, and literals.\n #[derive(Clone)]\n-pub enum Ty<'a> {\n+pub enum Ty {\n     Self_,\n     /// &/Box/ Ty\n-    Ptr(Box<Ty<'a>>, PtrTy),\n+    Ptr(Box<Ty>, PtrTy),\n     /// `mod::mod::Type<[lifetime], [Params...]>`, including a plain type\n     /// parameter, and things like `i32`\n-    Literal(Path<'a>),\n+    Literal(Path),\n     /// includes unit\n-    Tuple(Vec<Ty<'a>>),\n+    Tuple(Vec<Ty>),\n }\n \n pub fn borrowed_ptrty() -> PtrTy {\n     Borrowed(None, ast::Mutability::Not)\n }\n-pub fn borrowed(ty: Box<Ty<'_>>) -> Ty<'_> {\n+pub fn borrowed(ty: Box<Ty>) -> Ty {\n     Ptr(ty, borrowed_ptrty())\n }\n \n pub fn borrowed_explicit_self() -> Option<Option<PtrTy>> {\n     Some(Some(borrowed_ptrty()))\n }\n \n-pub fn borrowed_self<'r>() -> Ty<'r> {\n+pub fn borrowed_self() -> Ty {\n     borrowed(Box::new(Self_))\n }\n \n-pub fn nil_ty<'r>() -> Ty<'r> {\n+pub fn nil_ty() -> Ty {\n     Tuple(Vec::new())\n }\n \n@@ -132,7 +132,7 @@ fn mk_lifetimes(cx: &ExtCtxt<'_>, span: Span, lt: &Option<Ident>) -> Vec<ast::Li\n     mk_lifetime(cx, span, lt).into_iter().collect()\n }\n \n-impl<'a> Ty<'a> {\n+impl Ty {\n     pub fn to_ty(\n         &self,\n         cx: &ExtCtxt<'_>,\n@@ -199,9 +199,9 @@ impl<'a> Ty<'a> {\n fn mk_ty_param(\n     cx: &ExtCtxt<'_>,\n     span: Span,\n-    name: &str,\n+    name: Symbol,\n     attrs: &[ast::Attribute],\n-    bounds: &[Path<'_>],\n+    bounds: &[Path],\n     self_ident: Ident,\n     self_generics: &Generics,\n ) -> ast::GenericParam {\n@@ -212,7 +212,7 @@ fn mk_ty_param(\n             cx.trait_bound(path)\n         })\n         .collect();\n-    cx.typaram(span, cx.ident_of(name, span), attrs.to_owned(), bounds, None)\n+    cx.typaram(span, Ident::new(name, span), attrs.to_owned(), bounds, None)\n }\n \n fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {\n@@ -223,16 +223,15 @@ fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {\n     }\n }\n \n-/// Lifetimes and bounds on type parameters\n+/// Bounds on type parameters.\n #[derive(Clone)]\n-pub struct LifetimeBounds<'a> {\n-    pub lifetimes: Vec<(&'a str, Vec<&'a str>)>,\n-    pub bounds: Vec<(&'a str, Vec<Path<'a>>)>,\n+pub struct Bounds {\n+    pub bounds: Vec<(Symbol, Vec<Path>)>,\n }\n \n-impl<'a> LifetimeBounds<'a> {\n-    pub fn empty() -> LifetimeBounds<'a> {\n-        LifetimeBounds { lifetimes: Vec::new(), bounds: Vec::new() }\n+impl Bounds {\n+    pub fn empty() -> Bounds {\n+        Bounds { bounds: Vec::new() }\n     }\n     pub fn to_generics(\n         &self,\n@@ -242,18 +241,12 @@ impl<'a> LifetimeBounds<'a> {\n         self_generics: &Generics,\n     ) -> Generics {\n         let generic_params = self\n-            .lifetimes\n+            .bounds\n             .iter()\n-            .map(|&(lt, ref bounds)| {\n-                let bounds = bounds\n-                    .iter()\n-                    .map(|b| ast::GenericBound::Outlives(cx.lifetime(span, Ident::from_str(b))));\n-                cx.lifetime_def(span, Ident::from_str(lt), vec![], bounds.collect())\n-            })\n-            .chain(self.bounds.iter().map(|t| {\n+            .map(|t| {\n                 let (name, ref bounds) = *t;\n                 mk_ty_param(cx, span, name, &[], &bounds, self_ty, self_generics)\n-            }))\n+            })\n             .collect();\n \n         mk_generics(generic_params, span)"}, {"sha": "d7195188085f01fc3df926a2c77b92e42329fd44", "filename": "src/librustc_builtin_macros/deriving/hash.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fhash.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -15,27 +15,24 @@ pub fn expand_deriving_hash(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let path = Path::new_(pathvec_std!(cx, hash::Hash), None, vec![], PathKind::Std);\n+    let path = Path::new_(pathvec_std!(hash::Hash), None, vec![], PathKind::Std);\n \n-    let typaram = \"__H\";\n+    let typaram = sym::__H;\n \n     let arg = Path::new_local(typaram);\n     let hash_trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),\n         path,\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::hash,\n-            generics: LifetimeBounds {\n-                lifetimes: Vec::new(),\n-                bounds: vec![(typaram, vec![path_std!(cx, hash::Hasher)])],\n-            },\n+            generics: Bounds { bounds: vec![(typaram, vec![path_std!(hash::Hasher)])] },\n             explicit_self: borrowed_explicit_self(),\n-            args: vec![(Ptr(Box::new(Literal(arg)), Borrowed(None, Mutability::Mut)), \"state\")],\n+            args: vec![(Ptr(Box::new(Literal(arg)), Borrowed(None, Mutability::Mut)), sym::state)],\n             ret_ty: nil_ty(),\n             attributes: vec![],\n             is_unsafe: false,"}, {"sha": "33c0edde98f0ba91854e82dcffe64aa32090c9b0", "filename": "src/librustc_builtin_macros/deriving/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -7,11 +7,11 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n macro path_local($x:ident) {\n-    generic::ty::Path::new_local(stringify!($x))\n+    generic::ty::Path::new_local(sym::$x)\n }\n \n-macro pathvec_std($cx:expr, $($rest:ident)::+) {{\n-    vec![ $( stringify!($rest) ),+ ]\n+macro pathvec_std($($rest:ident)::+) {{\n+    vec![ $( sym::$rest ),+ ]\n }}\n \n macro path_std($($x:tt)*) {\n@@ -84,7 +84,7 @@ fn inject_impl_of_structural_trait(\n     cx: &mut ExtCtxt<'_>,\n     span: Span,\n     item: &Annotatable,\n-    structural_path: generic::ty::Path<'_>,\n+    structural_path: generic::ty::Path,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n     let item = match *item {"}, {"sha": "55eab24b8a5105def8d34e6bfc591bd39c721bff", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -578,31 +578,31 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.count_args_index_offset = sofar;\n     }\n \n-    fn rtpath(ecx: &ExtCtxt<'_>, s: &str) -> Vec<Ident> {\n-        ecx.std_path(&[sym::fmt, sym::rt, sym::v1, Symbol::intern(s)])\n+    fn rtpath(ecx: &ExtCtxt<'_>, s: Symbol) -> Vec<Ident> {\n+        ecx.std_path(&[sym::fmt, sym::rt, sym::v1, s])\n     }\n \n     fn build_count(&self, c: parse::Count) -> P<ast::Expr> {\n         let sp = self.macsp;\n         let count = |c, arg| {\n-            let mut path = Context::rtpath(self.ecx, \"Count\");\n-            path.push(self.ecx.ident_of(c, sp));\n+            let mut path = Context::rtpath(self.ecx, sym::Count);\n+            path.push(Ident::new(c, sp));\n             match arg {\n                 Some(arg) => self.ecx.expr_call_global(sp, path, vec![arg]),\n                 None => self.ecx.expr_path(self.ecx.path_global(sp, path)),\n             }\n         };\n         match c {\n-            parse::CountIs(i) => count(\"Is\", Some(self.ecx.expr_usize(sp, i))),\n+            parse::CountIs(i) => count(sym::Is, Some(self.ecx.expr_usize(sp, i))),\n             parse::CountIsParam(i) => {\n                 // This needs mapping too, as `i` is referring to a macro\n                 // argument. If `i` is not found in `count_positions` then\n                 // the error had already been emitted elsewhere.\n                 let i = self.count_positions.get(&i).cloned().unwrap_or(0)\n                     + self.count_args_index_offset;\n-                count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n+                count(sym::Param, Some(self.ecx.expr_usize(sp, i)))\n             }\n-            parse::CountImplied => count(\"Implied\", None),\n+            parse::CountImplied => count(sym::Implied, None),\n             // should never be the case, names are already resolved\n             parse::CountIsName(_) => panic!(\"should never happen\"),\n         }\n@@ -690,40 +690,40 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // Build the format\n                 let fill = self.ecx.expr_lit(sp, ast::LitKind::Char(fill));\n                 let align = |name| {\n-                    let mut p = Context::rtpath(self.ecx, \"Alignment\");\n-                    p.push(self.ecx.ident_of(name, sp));\n+                    let mut p = Context::rtpath(self.ecx, sym::Alignment);\n+                    p.push(Ident::new(name, sp));\n                     self.ecx.path_global(sp, p)\n                 };\n                 let align = match arg.format.align {\n-                    parse::AlignLeft => align(\"Left\"),\n-                    parse::AlignRight => align(\"Right\"),\n-                    parse::AlignCenter => align(\"Center\"),\n-                    parse::AlignUnknown => align(\"Unknown\"),\n+                    parse::AlignLeft => align(sym::Left),\n+                    parse::AlignRight => align(sym::Right),\n+                    parse::AlignCenter => align(sym::Center),\n+                    parse::AlignUnknown => align(sym::Unknown),\n                 };\n                 let align = self.ecx.expr_path(align);\n                 let flags = self.ecx.expr_u32(sp, arg.format.flags);\n                 let prec = self.build_count(arg.format.precision);\n                 let width = self.build_count(arg.format.width);\n-                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n+                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, sym::FormatSpec));\n                 let fmt = self.ecx.expr_struct(\n                     sp,\n                     path,\n                     vec![\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\", sp), fill),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"align\", sp), align),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\", sp), flags),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\", sp), prec),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"width\", sp), width),\n+                        self.ecx.field_imm(sp, Ident::new(sym::fill, sp), fill),\n+                        self.ecx.field_imm(sp, Ident::new(sym::align, sp), align),\n+                        self.ecx.field_imm(sp, Ident::new(sym::flags, sp), flags),\n+                        self.ecx.field_imm(sp, Ident::new(sym::precision, sp), prec),\n+                        self.ecx.field_imm(sp, Ident::new(sym::width, sp), width),\n                     ],\n                 );\n \n-                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"Argument\"));\n+                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, sym::Argument));\n                 Some(self.ecx.expr_struct(\n                     sp,\n                     path,\n                     vec![\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"position\", sp), pos),\n-                        self.ecx.field_imm(sp, self.ecx.ident_of(\"format\", sp), fmt),\n+                        self.ecx.field_imm(sp, Ident::new(sym::position, sp), pos),\n+                        self.ecx.field_imm(sp, Ident::new(sym::format, sp), fmt),\n                     ],\n                 ))\n             }\n@@ -740,7 +740,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let mut heads = Vec::with_capacity(self.args.len());\n \n         let names_pos: Vec<_> = (0..self.args.len())\n-            .map(|i| self.ecx.ident_of(&format!(\"arg{}\", i), self.macsp))\n+            .map(|i| Ident::from_str_and_span(&format!(\"arg{}\", i), self.macsp))\n             .collect();\n \n         // First, build up the static array which will become our precompiled"}, {"sha": "89446a1aa96f9a79346ef5421910b41154890f61", "filename": "src/librustc_builtin_macros/global_allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -58,7 +58,7 @@ impl AllocFnFactory<'_, '_> {\n         let mut abi_args = Vec::new();\n         let mut i = 0;\n         let mut mk = || {\n-            let name = self.cx.ident_of(&format!(\"arg{}\", i), self.span);\n+            let name = Ident::from_str_and_span(&format!(\"arg{}\", i), self.span);\n             i += 1;\n             name\n         };\n@@ -72,7 +72,7 @@ impl AllocFnFactory<'_, '_> {\n         let kind = ItemKind::Fn(ast::Defaultness::Final, sig, Generics::default(), block);\n         let item = self.cx.item(\n             self.span,\n-            self.cx.ident_of(&self.kind.fn_name(method.name), self.span),\n+            Ident::from_str_and_span(&self.kind.fn_name(method.name), self.span),\n             self.attrs(),\n             kind,\n         );"}, {"sha": "f044ce41e879ee8ff3782550c620f334beddcd9e", "filename": "src/librustc_builtin_macros/proc_macro_harness.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -384,12 +384,12 @@ fn mk_decls(\n     let proc_macro = Ident::new(sym::proc_macro, span);\n     let krate = cx.item(span, proc_macro, Vec::new(), ast::ItemKind::ExternCrate(None));\n \n-    let bridge = cx.ident_of(\"bridge\", span);\n-    let client = cx.ident_of(\"client\", span);\n-    let proc_macro_ty = cx.ident_of(\"ProcMacro\", span);\n-    let custom_derive = cx.ident_of(\"custom_derive\", span);\n-    let attr = cx.ident_of(\"attr\", span);\n-    let bang = cx.ident_of(\"bang\", span);\n+    let bridge = Ident::new(sym::bridge, span);\n+    let client = Ident::new(sym::client, span);\n+    let proc_macro_ty = Ident::new(sym::ProcMacro, span);\n+    let custom_derive = Ident::new(sym::custom_derive, span);\n+    let attr = Ident::new(sym::attr, span);\n+    let bang = Ident::new(sym::bang, span);\n \n     let krate_ref = RefCell::new(ast_krate);\n \n@@ -447,7 +447,7 @@ fn mk_decls(\n     let decls_static = cx\n         .item_static(\n             span,\n-            cx.ident_of(\"_DECLS\", span),\n+            Ident::new(sym::_DECLS, span),\n             cx.ty_rptr(\n                 span,\n                 cx.ty("}, {"sha": "460f947a792af5975b7627f6e7f003ec7b81d021", "filename": "src/librustc_builtin_macros/test.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -108,22 +108,38 @@ pub fn expand_test_or_bench(\n     let test_id = Ident::new(sym::test, attr_sp);\n \n     // creates test::$name\n-    let test_path = |name| cx.path(sp, vec![test_id, cx.ident_of(name, sp)]);\n+    let test_path = |name| cx.path(sp, vec![test_id, Ident::from_str_and_span(name, sp)]);\n \n     // creates test::ShouldPanic::$name\n-    let should_panic_path =\n-        |name| cx.path(sp, vec![test_id, cx.ident_of(\"ShouldPanic\", sp), cx.ident_of(name, sp)]);\n+    let should_panic_path = |name| {\n+        cx.path(\n+            sp,\n+            vec![\n+                test_id,\n+                Ident::from_str_and_span(\"ShouldPanic\", sp),\n+                Ident::from_str_and_span(name, sp),\n+            ],\n+        )\n+    };\n \n     // creates test::TestType::$name\n-    let test_type_path =\n-        |name| cx.path(sp, vec![test_id, cx.ident_of(\"TestType\", sp), cx.ident_of(name, sp)]);\n+    let test_type_path = |name| {\n+        cx.path(\n+            sp,\n+            vec![\n+                test_id,\n+                Ident::from_str_and_span(\"TestType\", sp),\n+                Ident::from_str_and_span(name, sp),\n+            ],\n+        )\n+    };\n \n     // creates $name: $expr\n-    let field = |name, expr| cx.field_imm(sp, cx.ident_of(name, sp), expr);\n+    let field = |name, expr| cx.field_imm(sp, Ident::from_str_and_span(name, sp), expr);\n \n     let test_fn = if is_bench {\n         // A simple ident for a lambda\n-        let b = cx.ident_of(\"b\", attr_sp);\n+        let b = Ident::from_str_and_span(\"b\", attr_sp);\n \n         cx.expr_call(\n             sp,"}, {"sha": "98c5c6936d779d07199d701029e647d529e8700f", "filename": "src/librustc_builtin_macros/test_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest_harness.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -270,7 +270,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     let mut test_runner = cx\n         .test_runner\n         .clone()\n-        .unwrap_or(ecx.path(sp, vec![test_id, ecx.ident_of(runner_name, sp)]));\n+        .unwrap_or(ecx.path(sp, vec![test_id, Ident::from_str_and_span(runner_name, sp)]));\n \n     test_runner.span = sp;\n "}, {"sha": "64e2d5b3a467c84fd18b28223e40141680d8431b", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -1061,9 +1061,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn set_trace_macros(&mut self, x: bool) {\n         self.ecfg.trace_mac = x\n     }\n-    pub fn ident_of(&self, st: &str, sp: Span) -> Ident {\n-        Ident::from_str_and_span(st, sp)\n-    }\n     pub fn std_path(&self, components: &[Symbol]) -> Vec<Ident> {\n         let def_site = self.with_def_site_ctxt(DUMMY_SP);\n         iter::once(Ident::new(kw::DollarCrate, def_site))"}, {"sha": "81ff4b3157845e94b65b29cf19aa757ba8265a92", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -368,7 +368,7 @@ impl<'a> ExtCtxt<'a> {\n         let err = self.std_path(&[sym::result, sym::Result, sym::Err]);\n         let err_path = self.path_global(sp, err);\n \n-        let binding_variable = self.ident_of(\"__try_var\", sp);\n+        let binding_variable = Ident::new(sym::__try_var, sp);\n         let binding_pat = self.pat_ident(sp, binding_variable);\n         let binding_expr = self.expr_ident(sp, binding_variable);\n "}, {"sha": "b311f8344bb6dc787f12a51db651f0489a8d8f24", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 88, "deletions": 4, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -8,7 +8,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::IndexVec;\n-use rustc_span::{Span, Symbol};\n+use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use smallvec::SmallVec;\n use std::cell::Cell;\n@@ -18,7 +18,7 @@ use super::{Field, SourceInfo};\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsafetyViolationKind {\n-    /// Only permitted in regular `fn`s, prohibitted in `const fn`s.\n+    /// Only permitted in regular `fn`s, prohibited in `const fn`s.\n     General,\n     /// Permitted both in `const fn`s and regular `fn`s.\n     GeneralAndConstFn,\n@@ -35,13 +35,97 @@ pub enum UnsafetyViolationKind {\n     UnsafeFnBorrowPacked,\n }\n \n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum UnsafetyViolationDetails {\n+    CallToUnsafeFunction,\n+    UseOfInlineAssembly,\n+    InitializingTypeWith,\n+    CastOfPointerToInt,\n+    BorrowOfPackedField,\n+    UseOfMutableStatic,\n+    UseOfExternStatic,\n+    DerefOfRawPointer,\n+    AssignToNonCopyUnionField,\n+    AccessToUnionField,\n+    MutationOfLayoutConstrainedField,\n+    BorrowOfLayoutConstrainedField,\n+    CallToFunctionWith,\n+}\n+\n+impl UnsafetyViolationDetails {\n+    pub fn description_and_note(&self) -> (&'static str, &'static str) {\n+        use UnsafetyViolationDetails::*;\n+        match self {\n+            CallToUnsafeFunction => (\n+                \"call to unsafe function\",\n+                \"consult the function's documentation for information on how to avoid undefined \\\n+                 behavior\",\n+            ),\n+            UseOfInlineAssembly => (\n+                \"use of inline assembly\",\n+                \"inline assembly is entirely unchecked and can cause undefined behavior\",\n+            ),\n+            InitializingTypeWith => (\n+                \"initializing type with `rustc_layout_scalar_valid_range` attr\",\n+                \"initializing a layout restricted type's field with a value outside the valid \\\n+                 range is undefined behavior\",\n+            ),\n+            CastOfPointerToInt => {\n+                (\"cast of pointer to int\", \"casting pointers to integers in constants\")\n+            }\n+            BorrowOfPackedField => (\n+                \"borrow of packed field\",\n+                \"fields of packed structs might be misaligned: dereferencing a misaligned pointer \\\n+                 or even just creating a misaligned reference is undefined behavior\",\n+            ),\n+            UseOfMutableStatic => (\n+                \"use of mutable static\",\n+                \"mutable statics can be mutated by multiple threads: aliasing violations or data \\\n+                 races will cause undefined behavior\",\n+            ),\n+            UseOfExternStatic => (\n+                \"use of extern static\",\n+                \"extern statics are not controlled by the Rust type system: invalid data, \\\n+                 aliasing violations or data races will cause undefined behavior\",\n+            ),\n+            DerefOfRawPointer => (\n+                \"dereference of raw pointer\",\n+                \"raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules \\\n+                 and cause data races: all of these are undefined behavior\",\n+            ),\n+            AssignToNonCopyUnionField => (\n+                \"assignment to non-`Copy` union field\",\n+                \"the previous content of the field will be dropped, which causes undefined \\\n+                 behavior if the field was not properly initialized\",\n+            ),\n+            AccessToUnionField => (\n+                \"access to union field\",\n+                \"the field may not be properly initialized: using uninitialized data will cause \\\n+                 undefined behavior\",\n+            ),\n+            MutationOfLayoutConstrainedField => (\n+                \"mutation of layout constrained field\",\n+                \"mutating layout constrained fields cannot statically be checked for valid values\",\n+            ),\n+            BorrowOfLayoutConstrainedField => (\n+                \"borrow of layout constrained field with interior mutability\",\n+                \"references to fields of layout constrained fields lose the constraints. Coupled \\\n+                 with interior mutability, the field can be changed to invalid values\",\n+            ),\n+            CallToFunctionWith => (\n+                \"call to function with `#[target_feature]`\",\n+                \"can only be called if the required target features are available\",\n+            ),\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyViolation {\n     pub source_info: SourceInfo,\n     pub lint_root: hir::HirId,\n-    pub description: Symbol,\n-    pub details: Symbol,\n     pub kind: UnsafetyViolationKind,\n+    pub details: UnsafetyViolationDetails,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]"}, {"sha": "043d85cb6efa632f7800517b8db3a03918ac5957", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -1440,12 +1440,12 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n         // FIXME(eddyb) `name` should never be empty, but it\n         // currently is for `extern { ... }` \"foreign modules\".\n-        let name = disambiguated_data.data.as_symbol().as_str();\n-        if !name.is_empty() {\n+        let name = disambiguated_data.data.as_symbol();\n+        if name != kw::Invalid {\n             if !self.empty_path {\n                 write!(self, \"::\")?;\n             }\n-            if Ident::from_str(&name).is_raw_guess() {\n+            if Ident::with_dummy_span(name).is_raw_guess() {\n                 write!(self, \"r#\")?;\n             }\n             write!(self, \"{}\", name)?;"}, {"sha": "0683dc0201129bddca91b54fc36d3a10b1df3c7f", "filename": "src/librustc_middle/ty/query/profiling_support.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fprofiling_support.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -60,12 +60,12 @@ impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n \n         match def_key.disambiguated_data.data {\n             DefPathData::CrateRoot => {\n-                name = self.tcx.original_crate_name(def_id.krate).as_str();\n+                name = self.tcx.original_crate_name(def_id.krate);\n                 dis = \"\";\n                 end_index = 3;\n             }\n             other => {\n-                name = other.as_symbol().as_str();\n+                name = other.as_symbol();\n                 if def_key.disambiguated_data.disambiguator == 0 {\n                     dis = \"\";\n                     end_index = 3;\n@@ -79,10 +79,11 @@ impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n             }\n         }\n \n+        let name = &*name.as_str();\n         let components = [\n             StringComponent::Ref(parent_string_id),\n             StringComponent::Value(\"::\"),\n-            StringComponent::Value(&name[..]),\n+            StringComponent::Value(name),\n             StringComponent::Value(dis),\n         ];\n "}, {"sha": "81d7ac089262206aa24957a226f5c50ea627701e", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 30, "deletions": 82, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::builtin::{SAFE_PACKED_BORROWS, UNSAFE_OP_IN_UNSAFE_FN, UNUSED_UNSAFE};\n use rustc_session::lint::Level;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::sym;\n \n use std::ops::Bound;\n \n@@ -86,10 +86,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 let sig = func_ty.fn_sig(self.tcx);\n                 if let hir::Unsafety::Unsafe = sig.unsafety() {\n                     self.require_unsafe(\n-                        \"call to unsafe function\",\n-                        \"consult the function's documentation for information on how to avoid \\\n-                         undefined behavior\",\n                         UnsafetyViolationKind::GeneralAndConstFn,\n+                        UnsafetyViolationDetails::CallToUnsafeFunction,\n                     )\n                 }\n \n@@ -99,9 +97,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n \n             TerminatorKind::InlineAsm { .. } => self.require_unsafe(\n-                \"use of inline assembly\",\n-                \"inline assembly is entirely unchecked and can cause undefined behavior\",\n                 UnsafetyViolationKind::General,\n+                UnsafetyViolationDetails::UseOfInlineAssembly,\n             ),\n         }\n         self.super_terminator(terminator, location);\n@@ -122,9 +119,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n \n             StatementKind::LlvmInlineAsm { .. } => self.require_unsafe(\n-                \"use of inline assembly\",\n-                \"inline assembly is entirely unchecked and can cause undefined behavior\",\n                 UnsafetyViolationKind::General,\n+                UnsafetyViolationDetails::UseOfInlineAssembly,\n             ),\n         }\n         self.super_statement(statement, location);\n@@ -138,10 +134,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     match self.tcx.layout_scalar_valid_range(def.did) {\n                         (Bound::Unbounded, Bound::Unbounded) => {}\n                         _ => self.require_unsafe(\n-                            \"initializing type with `rustc_layout_scalar_valid_range` attr\",\n-                            \"initializing a layout restricted type's field with a value \\\n-                                outside the valid range is undefined behavior\",\n                             UnsafetyViolationKind::GeneralAndConstFn,\n+                            UnsafetyViolationDetails::InitializingTypeWith,\n                         ),\n                     }\n                 }\n@@ -163,9 +157,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 match (cast_in, cast_out) {\n                     (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) => {\n                         self.require_unsafe(\n-                            \"cast of pointer to int\",\n-                            \"casting pointers to integers in constants\",\n                             UnsafetyViolationKind::General,\n+                            UnsafetyViolationDetails::CastOfPointerToInt,\n                         );\n                     }\n                     _ => {}\n@@ -190,11 +183,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n         if context.is_borrow() {\n             if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n                 self.require_unsafe(\n-                    \"borrow of packed field\",\n-                    \"fields of packed structs might be misaligned: dereferencing a \\\n-                    misaligned pointer or even just creating a misaligned reference \\\n-                    is undefined behavior\",\n                     UnsafetyViolationKind::BorrowPacked,\n+                    UnsafetyViolationDetails::BorrowOfPackedField,\n                 );\n             }\n         }\n@@ -204,11 +194,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             if context.is_borrow() {\n                 if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n                     self.require_unsafe(\n-                        \"borrow of packed field\",\n-                        \"fields of packed structs might be misaligned: dereferencing a \\\n-                        misaligned pointer or even just creating a misaligned reference \\\n-                        is undefined behavior\",\n                         UnsafetyViolationKind::BorrowPacked,\n+                        UnsafetyViolationDetails::BorrowOfPackedField,\n                     );\n                 }\n             }\n@@ -219,19 +206,14 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n                         if self.tcx.is_mutable_static(def_id) {\n                             self.require_unsafe(\n-                                \"use of mutable static\",\n-                                \"mutable statics can be mutated by multiple threads: aliasing \\\n-                            violations or data races will cause undefined behavior\",\n                                 UnsafetyViolationKind::General,\n+                                UnsafetyViolationDetails::UseOfMutableStatic,\n                             );\n                             return;\n                         } else if self.tcx.is_foreign_item(def_id) {\n                             self.require_unsafe(\n-                                \"use of extern static\",\n-                                \"extern statics are not controlled by the Rust type system: \\\n-                            invalid data, aliasing violations or data races will cause \\\n-                            undefined behavior\",\n                                 UnsafetyViolationKind::General,\n+                                UnsafetyViolationDetails::UseOfExternStatic,\n                             );\n                             return;\n                         }\n@@ -246,11 +228,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n             match base_ty.kind {\n                 ty::RawPtr(..) => self.require_unsafe(\n-                    \"dereference of raw pointer\",\n-                    \"raw pointers may be NULL, dangling or unaligned; they can violate \\\n-                         aliasing rules and cause data races: all of these are undefined \\\n-                         behavior\",\n                     UnsafetyViolationKind::General,\n+                    UnsafetyViolationDetails::DerefOfRawPointer,\n                 ),\n                 ty::Adt(adt, _) => {\n                     if adt.is_union() {\n@@ -271,21 +250,16 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                                 self.param_env,\n                             ) {\n                                 self.require_unsafe(\n-                                    \"assignment to non-`Copy` union field\",\n-                                    \"the previous content of the field will be dropped, which \\\n-                                     causes undefined behavior if the field was not properly \\\n-                                     initialized\",\n                                     UnsafetyViolationKind::GeneralAndConstFn,\n+                                    UnsafetyViolationDetails::AssignToNonCopyUnionField,\n                                 )\n                             } else {\n                                 // write to non-move union, safe\n                             }\n                         } else {\n                             self.require_unsafe(\n-                                \"access to union field\",\n-                                \"the field may not be properly initialized: using \\\n-                                 uninitialized data will cause undefined behavior\",\n                                 UnsafetyViolationKind::GeneralAndConstFn,\n+                                UnsafetyViolationDetails::AccessToUnionField,\n                             )\n                         }\n                     }\n@@ -298,26 +272,15 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n-    fn require_unsafe(\n-        &mut self,\n-        description: &'static str,\n-        details: &'static str,\n-        kind: UnsafetyViolationKind,\n-    ) {\n+    fn require_unsafe(&mut self, kind: UnsafetyViolationKind, details: UnsafetyViolationDetails) {\n         let source_info = self.source_info;\n         let lint_root = self.body.source_scopes[self.source_info.scope]\n             .local_data\n             .as_ref()\n             .assert_crate_local()\n             .lint_root;\n         self.register_violations(\n-            &[UnsafetyViolation {\n-                source_info,\n-                lint_root,\n-                description: Symbol::intern(description),\n-                details: Symbol::intern(details),\n-                kind,\n-            }],\n+            &[UnsafetyViolation { source_info, lint_root, kind, details }],\n             &[],\n         );\n     }\n@@ -434,12 +397,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                         if self.tcx.layout_scalar_valid_range(def.did)\n                             != (Bound::Unbounded, Bound::Unbounded)\n                         {\n-                            let (description, details) = if is_mut_use {\n-                                (\n-                                    \"mutation of layout constrained field\",\n-                                    \"mutating layout constrained fields cannot statically be \\\n-                                        checked for valid values\",\n-                                )\n+                            let details = if is_mut_use {\n+                                UnsafetyViolationDetails::MutationOfLayoutConstrainedField\n \n                             // Check `is_freeze` as late as possible to avoid cycle errors\n                             // with opaque types.\n@@ -448,21 +407,11 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                                 .ty\n                                 .is_freeze(self.tcx.at(self.source_info.span), self.param_env)\n                             {\n-                                (\n-                                    \"borrow of layout constrained field with interior \\\n-                                        mutability\",\n-                                    \"references to fields of layout constrained fields \\\n-                                        lose the constraints. Coupled with interior mutability, \\\n-                                        the field can be changed to invalid values\",\n-                                )\n+                                UnsafetyViolationDetails::BorrowOfLayoutConstrainedField\n                             } else {\n                                 continue;\n                             };\n-                            self.require_unsafe(\n-                                description,\n-                                details,\n-                                UnsafetyViolationKind::GeneralAndConstFn,\n-                            );\n+                            self.require_unsafe(UnsafetyViolationKind::GeneralAndConstFn, details);\n                         }\n                     }\n                 }\n@@ -480,9 +429,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         // Is `callee_features` a subset of `calling_features`?\n         if !callee_features.iter().all(|feature| self_features.contains(feature)) {\n             self.require_unsafe(\n-                \"call to function with `#[target_feature]`\",\n-                \"can only be called if the required target features are available\",\n                 UnsafetyViolationKind::GeneralAndConstFn,\n+                UnsafetyViolationDetails::CallToFunctionWith,\n             )\n         }\n     }\n@@ -675,9 +623,9 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n \n     let UnsafetyCheckResult { violations, unsafe_blocks } = tcx.unsafety_check_result(def_id);\n \n-    for &UnsafetyViolation { source_info, lint_root, description, details, kind } in\n-        violations.iter()\n-    {\n+    for &UnsafetyViolation { source_info, lint_root, kind, details } in violations.iter() {\n+        let (description, note) = details.description_and_note();\n+\n         // Report an error.\n         let unsafe_fn_msg =\n             if unsafe_op_in_unsafe_fn_allowed(tcx, lint_root) { \" function or\" } else { \"\" };\n@@ -693,8 +641,8 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                     description,\n                     unsafe_fn_msg,\n                 )\n-                .span_label(source_info.span, &*description.as_str())\n-                .note(&details.as_str())\n+                .span_label(source_info.span, description)\n+                .note(note)\n                 .emit();\n             }\n             UnsafetyViolationKind::BorrowPacked => {\n@@ -712,7 +660,7 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                                 \"{} is unsafe and requires unsafe{} block (error E0133)\",\n                                 description, unsafe_fn_msg,\n                             ))\n-                            .note(&details.as_str())\n+                            .note(note)\n                             .emit()\n                         },\n                     )\n@@ -727,8 +675,8 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                         \"{} is unsafe and requires unsafe block (error E0133)\",\n                         description,\n                     ))\n-                    .span_label(source_info.span, &*description.as_str())\n-                    .note(&details.as_str())\n+                    .span_label(source_info.span, description)\n+                    .note(note)\n                     .emit();\n                 },\n             ),\n@@ -756,8 +704,8 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                         \"{} is unsafe and requires unsafe block (error E0133)\",\n                         description,\n                     ))\n-                    .span_label(source_info.span, &*description.as_str())\n-                    .note(&details.as_str())\n+                    .span_label(source_info.span, description)\n+                    .note(note)\n                     .emit();\n                 })\n             }"}, {"sha": "5d332ddf5f3df1ccecf1165219bd67d875fdd1b9", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -122,19 +122,28 @@ symbols! {\n     // There is currently no checking that all symbols are used; that would be\n     // nice to have.\n     Symbols {\n+        Alignment,\n         Arc,\n+        Argument,\n         ArgumentV1,\n         Arguments,\n         C,\n+        Center,\n         Clone,\n         Copy,\n+        Count,\n         Debug,\n         Decodable,\n+        Decoder,\n         Default,\n         Encodable,\n+        Encoder,\n         Eq,\n         Equal,\n         Err,\n+        Error,\n+        FormatSpec,\n+        Formatter,\n         From,\n         Future,\n         FxHashMap,\n@@ -143,23 +152,29 @@ symbols! {\n         Hash,\n         HashMap,\n         HashSet,\n+        Hasher,\n+        Implied,\n         Input,\n         IntoIterator,\n+        Is,\n         ItemContext,\n         Iterator,\n         Layout,\n+        Left,\n         LintPass,\n         None,\n         Ok,\n         Option,\n         Ord,\n         Ordering,\n         Output,\n+        Param,\n         PartialEq,\n         PartialOrd,\n         Pending,\n         Pin,\n         Poll,\n+        ProcMacro,\n         ProcMacroHack,\n         ProceduralMasqueradeDummyType,\n         Range,\n@@ -172,20 +187,31 @@ symbols! {\n         Ready,\n         Result,\n         Return,\n+        Right,\n         RustcDecodable,\n         RustcEncodable,\n         Send,\n         Some,\n+        StructuralEq,\n+        StructuralPartialEq,\n         Sync,\n         Target,\n         Try,\n         Ty,\n         TyCtxt,\n         TyKind,\n+        Unknown,\n         Vec,\n         Yield,\n+        _DECLS,\n         _Self,\n+        __D,\n+        __H,\n+        __S,\n         __next,\n+        __try_var,\n+        _d,\n+        _e,\n         _task_context,\n         aarch64_target_feature,\n         abi,\n@@ -226,6 +252,7 @@ symbols! {\n         allowed,\n         always,\n         and,\n+        and_then,\n         any,\n         arbitrary_enum_discriminant,\n         arbitrary_self_types,\n@@ -256,6 +283,7 @@ symbols! {\n         automatically_derived,\n         avx512_target_feature,\n         await_macro,\n+        bang,\n         begin_panic,\n         bench,\n         bin,\n@@ -278,6 +306,7 @@ symbols! {\n         box_syntax,\n         braced_empty_structs,\n         breakpoint,\n+        bridge,\n         bswap,\n         c_variadic,\n         call,\n@@ -299,6 +328,7 @@ symbols! {\n         cfg_target_vendor,\n         cfg_version,\n         char,\n+        client,\n         clippy,\n         clone,\n         clone_closures,\n@@ -370,11 +400,15 @@ symbols! {\n         custom_derive,\n         custom_inner_attributes,\n         custom_test_frameworks,\n+        d,\n         dead_code,\n         dealloc,\n         debug,\n         debug_assertions,\n+        debug_struct,\n         debug_trait,\n+        debug_trait_builder,\n+        debug_tuple,\n         decl_macro,\n         declare_lint_pass,\n         decode,\n@@ -421,6 +455,11 @@ symbols! {\n         dyn_trait,\n         eh_catch_typeinfo,\n         eh_personality,\n+        emit_enum,\n+        emit_enum_variant,\n+        emit_enum_variant_arg,\n+        emit_struct,\n+        emit_struct_field,\n         enable,\n         enclosing_scope,\n         encode,\n@@ -448,6 +487,7 @@ symbols! {\n         extern_prelude,\n         extern_types,\n         external_doc,\n+        f,\n         f16c_target_feature,\n         f32,\n         f32_runtime,\n@@ -464,6 +504,9 @@ symbols! {\n         field,\n         field_init_shorthand,\n         file,\n+        fill,\n+        finish,\n+        flags,\n         float_to_int_unchecked,\n         floorf32,\n         floorf64,\n@@ -478,6 +521,7 @@ symbols! {\n         fn_once_output,\n         forbid,\n         forget,\n+        format,\n         format_args,\n         format_args_capture,\n         format_args_nl,\n@@ -519,6 +563,7 @@ symbols! {\n         html_no_source,\n         html_playground_url,\n         html_root_url,\n+        i,\n         i128,\n         i128_type,\n         i16,\n@@ -606,6 +651,7 @@ symbols! {\n         main,\n         managed_boxes,\n         manually_drop,\n+        map,\n         marker,\n         marker_trait_attr,\n         masked,\n@@ -708,6 +754,7 @@ symbols! {\n         options,\n         or,\n         or_patterns,\n+        other,\n         out,\n         overlapping_marker_traits,\n         owned_box,\n@@ -739,6 +786,7 @@ symbols! {\n         plugins,\n         pointer,\n         poll,\n+        position,\n         post_dash_lto: \"post-lto\",\n         powerpc_target_feature,\n         powf32,\n@@ -747,6 +795,7 @@ symbols! {\n         powif64,\n         pre_dash_lto: \"pre-lto\",\n         precise_pointer_size_matching,\n+        precision,\n         pref_align_of,\n         prefetch_read_data,\n         prefetch_read_instruction,\n@@ -783,6 +832,11 @@ symbols! {\n         raw_identifiers,\n         raw_ref_op,\n         re_rebalance_coherence,\n+        read_enum,\n+        read_enum_variant,\n+        read_enum_variant_arg,\n+        read_struct,\n+        read_struct_field,\n         readonly,\n         realloc,\n         reason,\n@@ -872,6 +926,7 @@ symbols! {\n         rustc_promotable,\n         rustc_regions,\n         rustc_reservation_impl,\n+        rustc_serialize,\n         rustc_specialization_trait,\n         rustc_stable,\n         rustc_std_internal_symbol,\n@@ -976,6 +1031,7 @@ symbols! {\n         stable,\n         staged_api,\n         start,\n+        state,\n         static_in_const,\n         static_nobundle,\n         static_recursion,\n@@ -1123,6 +1179,7 @@ symbols! {\n         wasm_import_module,\n         wasm_target_feature,\n         while_let,\n+        width,\n         windows,\n         windows_subsystem,\n         wrapping_add,"}, {"sha": "a9b045cee6087ce599742d817f77b58eb8532d57", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -26,7 +26,7 @@ use rustc_middle::ty::{\n     TypeFoldable, WithConstness,\n };\n use rustc_session::DiagnosticMessageId;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::{ExpnKind, MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n \n@@ -1524,7 +1524,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     (self.tcx.sess.source_map().span_to_snippet(span), &obligation.cause.code)\n                 {\n                     let generics = self.tcx.generics_of(*def_id);\n-                    if generics.params.iter().any(|p| p.name.as_str() != \"Self\")\n+                    if generics.params.iter().any(|p| p.name != kw::SelfUpper)\n                         && !snippet.ends_with('>')\n                     {\n                         // FIXME: To avoid spurious suggestions in functions where type arguments"}, {"sha": "f575548ddd6382bb7da09921310e6c286b22ceb6", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -322,12 +322,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let self_ty = self.tables.borrow().node_type(method_expr[0].hir_id);\n         let self_ty = format!(\"{:?}\", self_ty);\n-        let name = method_path.ident.as_str();\n+        let name = method_path.ident.name;\n         let is_as_ref_able = (self_ty.starts_with(\"&std::option::Option\")\n             || self_ty.starts_with(\"&std::result::Result\")\n             || self_ty.starts_with(\"std::option::Option\")\n             || self_ty.starts_with(\"std::result::Result\"))\n-            && (name == \"map\" || name == \"and_then\");\n+            && (name == sym::map || name == sym::and_then);\n         match (is_as_ref_able, self.sess().source_map().span_to_snippet(*method_span)) {\n             (true, Ok(src)) => {\n                 let suggestion = format!(\"as_ref().{}\", src);"}, {"sha": "1d4772bb3d606a41a5dd4af3d1b9d9d8dd332ee1", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -8,7 +8,7 @@ use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::{Ident, SymbolStr};\n+use rustc_span::symbol::{Ident, Symbol};\n use std::cmp::Ordering;\n \n declare_clippy_lint! {\n@@ -75,7 +75,7 @@ pub struct NonExpressiveNames {\n impl_lint_pass!(NonExpressiveNames => [SIMILAR_NAMES, MANY_SINGLE_CHAR_NAMES, JUST_UNDERSCORES_AND_DIGITS]);\n \n struct ExistingName {\n-    interned: SymbolStr,\n+    interned: Symbol,\n     span: Span,\n     len: usize,\n     exemptions: &'static [&'static str],\n@@ -218,18 +218,19 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n             let mut split_at = None;\n             match existing_name.len.cmp(&count) {\n                 Ordering::Greater => {\n-                    if existing_name.len - count != 1 || levenstein_not_1(&interned_name, &existing_name.interned) {\n+                    if existing_name.len - count != 1 || levenstein_not_1(&interned_name, &existing_name.interned.as_str()) {\n                         continue;\n                     }\n                 },\n                 Ordering::Less => {\n-                    if count - existing_name.len != 1 || levenstein_not_1(&existing_name.interned, &interned_name) {\n+                    if count - existing_name.len != 1 || levenstein_not_1(&existing_name.interned.as_str(), &interned_name) {\n                         continue;\n                     }\n                 },\n                 Ordering::Equal => {\n                     let mut interned_chars = interned_name.chars();\n-                    let mut existing_chars = existing_name.interned.chars();\n+                    let interned_str = existing_name.interned.as_str();\n+                    let mut existing_chars = interned_str.chars();\n                     let first_i = interned_chars.next().expect(\"we know we have at least one char\");\n                     let first_e = existing_chars.next().expect(\"we know we have at least one char\");\n                     let eq_or_numeric = |(a, b): (char, char)| a == b || a.is_numeric() && b.is_numeric();\n@@ -302,7 +303,7 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n         }\n         self.0.names.push(ExistingName {\n             exemptions: get_exemptions(&interned_name).unwrap_or(&[]),\n-            interned: interned_name,\n+            interned: ident.name,\n             span: ident.span,\n             len: count,\n         });"}, {"sha": "154082a0fdb530b8e81d1d4e47f3abced3f96b6b", "filename": "src/tools/clippy/clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60b051bbb844dc06eace271372cbaf01ca6ca41/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=c60b051bbb844dc06eace271372cbaf01ca6ca41", "patch": "@@ -3,7 +3,7 @@ use rustc_ast::ast::{Item, ItemKind, UseTree, UseTreeKind};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::{Ident, SymbolStr};\n+use rustc_span::symbol::Ident;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for imports that remove \"unsafe\" from an item's\n@@ -73,6 +73,6 @@ fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext<'_>,\n }\n \n #[must_use]\n-fn contains_unsafe(name: &SymbolStr) -> bool {\n+fn contains_unsafe(name: &str) -> bool {\n     name.contains(\"Unsafe\") || name.contains(\"unsafe\")\n }"}]}