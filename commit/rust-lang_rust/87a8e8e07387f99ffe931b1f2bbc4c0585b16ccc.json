{"sha": "87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YThlOGUwNzM4N2Y5OWZmZTkzMWIxZjJiYmM0YzA1ODViMTZjY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-20T14:33:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-20T14:33:43Z"}, "message": "Auto merge of #45359 - arielb1:escaping-borrow, r=eddyb\n\nFix a few bugs in drop generation\n\nThis fixes a few bugs in drop generation, one of which causes spurious MIR borrowck errors.\n\nFixes #44832.\n\nr? @eddyb", "tree": {"sha": "f15d49d70e3309f3a75430466d52cc400c2a8615", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f15d49d70e3309f3a75430466d52cc400c2a8615"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc", "html_url": "https://github.com/rust-lang/rust/commit/87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95272a07f1fe3a82497225a4cd0d67080b8ffebf", "url": "https://api.github.com/repos/rust-lang/rust/commits/95272a07f1fe3a82497225a4cd0d67080b8ffebf", "html_url": "https://github.com/rust-lang/rust/commit/95272a07f1fe3a82497225a4cd0d67080b8ffebf"}, {"sha": "0caba178dfd5983403564de82a7d11184c7964e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0caba178dfd5983403564de82a7d11184c7964e2", "html_url": "https://github.com/rust-lang/rust/commit/0caba178dfd5983403564de82a7d11184c7964e2"}], "stats": {"total": 182, "additions": 127, "deletions": 55}, "files": [{"sha": "c0d17a1590f84e01b0ca429ecb79124e14f5f3a5", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 86, "deletions": 53, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc", "patch": "@@ -131,6 +131,9 @@ pub struct Scope<'tcx> {\n \n     /// The cache for drop chain on \"generator drop\" exit.\n     cached_generator_drop: Option<BasicBlock>,\n+\n+    /// The cache for drop chain on \"unwind\" exit.\n+    cached_unwind: CachedBlock,\n }\n \n #[derive(Debug)]\n@@ -154,6 +157,11 @@ struct CachedBlock {\n     unwind: Option<BasicBlock>,\n \n     /// The cached block for unwinds during cleanups-on-generator-drop path\n+    ///\n+    /// This is split from the standard unwind path here to prevent drop\n+    /// elaboration from creating drop flags that would have to be captured\n+    /// by the generator. I'm not sure how important this optimization is,\n+    /// but it is here.\n     generator_drop: Option<BasicBlock>,\n }\n \n@@ -217,34 +225,29 @@ impl<'tcx> Scope<'tcx> {\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n     /// larger extent of code.\n     ///\n-    /// `unwind` controls whether caches for the unwind branch are also invalidated.\n-    fn invalidate_cache(&mut self, unwind: bool) {\n+    /// `storage_only` controls whether to invalidate only drop paths run `StorageDead`.\n+    /// `this_scope_only` controls whether to invalidate only drop paths that refer to the current\n+    /// top-of-scope (as opposed to dependent scopes).\n+    fn invalidate_cache(&mut self, storage_only: bool, this_scope_only: bool) {\n+        // FIXME: maybe do shared caching of `cached_exits` etc. to handle functions\n+        // with lots of `try!`?\n+\n+        // cached exits drop storage and refer to the top-of-scope\n         self.cached_exits.clear();\n-        if !unwind { return; }\n-        for dropdata in &mut self.drops {\n-            if let DropKind::Value { ref mut cached_block } = dropdata.kind {\n-                cached_block.invalidate();\n-            }\n+\n+        if !storage_only {\n+            // the current generator drop and unwind ignore\n+            // storage but refer to top-of-scope\n+            self.cached_generator_drop = None;\n+            self.cached_unwind.invalidate();\n         }\n-    }\n \n-    /// Returns the cached entrypoint for diverging exit from this scope.\n-    ///\n-    /// Precondition: the caches must be fully filled (i.e. diverge_cleanup is called) in order for\n-    /// this method to work correctly.\n-    fn cached_block(&self, generator_drop: bool) -> Option<BasicBlock> {\n-        let mut drops = self.drops.iter().rev().filter_map(|data| {\n-            match data.kind {\n-                DropKind::Value { cached_block } => {\n-                    Some(cached_block.get(generator_drop))\n+        if !storage_only && !this_scope_only {\n+            for dropdata in &mut self.drops {\n+                if let DropKind::Value { ref mut cached_block } = dropdata.kind {\n+                    cached_block.invalidate();\n                 }\n-                DropKind::Storage => None\n             }\n-        });\n-        if let Some(cached_block) = drops.next() {\n-            Some(cached_block.expect(\"drop cache is not filled\"))\n-        } else {\n-            None\n         }\n     }\n \n@@ -356,7 +359,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             needs_cleanup: false,\n             drops: vec![],\n             cached_generator_drop: None,\n-            cached_exits: FxHashMap()\n+            cached_exits: FxHashMap(),\n+            cached_unwind: CachedBlock::default(),\n         });\n     }\n \n@@ -482,15 +486,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                    TerminatorKind::Goto { target: b });\n                 b\n             };\n+\n+            // End all regions for scopes out of which we are breaking.\n+            self.cfg.push_end_region(self.hir.tcx(), block, src_info, scope.region_scope);\n+\n             unpack!(block = build_scope_drops(&mut self.cfg,\n                                               scope,\n                                               rest,\n                                               block,\n                                               self.arg_count,\n                                               true));\n-\n-            // End all regions for scopes out of which we are breaking.\n-            self.cfg.push_end_region(self.hir.tcx(), block, src_info, scope.region_scope);\n         }\n \n         self.cfg.terminate(block, src_info, TerminatorKind::GeneratorDrop);\n@@ -672,8 +677,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // invalidating caches of each scope visited. This way bare minimum of the\n             // caches gets invalidated. i.e. if a new drop is added into the middle scope, the\n             // cache of outer scpoe stays intact.\n-            let invalidate_unwind = needs_drop && !this_scope;\n-            scope.invalidate_cache(invalidate_unwind);\n+            scope.invalidate_cache(!needs_drop, this_scope);\n             if this_scope {\n                 if let DropKind::Value { .. } = drop_kind {\n                     scope.needs_cleanup = true;\n@@ -819,30 +823,50 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n                            generator_drop: bool)\n                            -> BlockAnd<()> {\n     debug!(\"build_scope_drops({:?} -> {:?})\", block, scope);\n-    let mut iter = scope.drops.iter().rev().peekable();\n+    let mut iter = scope.drops.iter().rev();\n     while let Some(drop_data) = iter.next() {\n         let source_info = scope.source_info(drop_data.span);\n         match drop_data.kind {\n             DropKind::Value { .. } => {\n-                // Try to find the next block with its cached block\n-                // for us to diverge into in case the drop panics.\n-                let on_diverge = iter.peek().iter().filter_map(|dd| {\n+                // Try to find the next block with its cached block for us to\n+                // diverge into, either a previous block in this current scope or\n+                // the top of the previous scope.\n+                //\n+                // If it wasn't for EndRegion, we could just chain all the DropData\n+                // together and pick the first DropKind::Value. Please do that\n+                // when we replace EndRegion with NLL.\n+                let on_diverge = iter.clone().filter_map(|dd| {\n                     match dd.kind {\n-                        DropKind::Value { cached_block } => {\n-                            let result = cached_block.get(generator_drop);\n-                            if result.is_none() {\n-                                span_bug!(drop_data.span, \"cached block not present?\")\n-                            }\n-                            result\n-                        },\n+                        DropKind::Value { cached_block } => Some(cached_block),\n                         DropKind::Storage => None\n                     }\n-                }).next();\n-                // If there\u2019s no `cached_block`s within current scope,\n-                // we must look for one in the enclosing scope.\n-                let on_diverge = on_diverge.or_else(|| {\n-                    earlier_scopes.iter().rev().flat_map(|s| s.cached_block(generator_drop)).next()\n+                }).next().or_else(|| {\n+                    if earlier_scopes.iter().any(|scope| scope.needs_cleanup) {\n+                        // If *any* scope requires cleanup code to be run,\n+                        // we must use the cached unwind from the *topmost*\n+                        // scope, to ensure all EndRegions from surrounding\n+                        // scopes are executed before the drop code runs.\n+                        Some(earlier_scopes.last().unwrap().cached_unwind)\n+                    } else {\n+                        // We don't need any further cleanup, so return None\n+                        // to avoid creating a landing pad. We can skip\n+                        // EndRegions because all local regions end anyway\n+                        // when the function unwinds.\n+                        //\n+                        // This is an important optimization because LLVM is\n+                        // terrible at optimizing landing pads. FIXME: I think\n+                        // it would be cleaner and better to do this optimization\n+                        // in SimplifyCfg instead of here.\n+                        None\n+                    }\n+                });\n+\n+                let on_diverge = on_diverge.map(|cached_block| {\n+                    cached_block.get(generator_drop).unwrap_or_else(|| {\n+                        span_bug!(drop_data.span, \"cached block not present?\")\n+                    })\n                 });\n+\n                 let next = cfg.start_new_block();\n                 cfg.terminate(block, source_info, TerminatorKind::Drop {\n                     location: drop_data.location.clone(),\n@@ -933,14 +957,23 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         };\n     }\n \n-    // Finally, push the EndRegion block, used by mir-borrowck. (Block\n-    // becomes trivial goto after pass that removes all EndRegions.)\n-    {\n-        let block = cfg.start_new_cleanup_block();\n-        cfg.push_end_region(tcx, block, source_info(span), scope.region_scope);\n-        cfg.terminate(block, source_info(span), TerminatorKind::Goto { target: target });\n-        target = block\n-    }\n+    // Finally, push the EndRegion block, used by mir-borrowck, and set\n+    // `cached_unwind` to point to it (Block becomes trivial goto after\n+    // pass that removes all EndRegions).\n+    target = {\n+        let cached_block = scope.cached_unwind.ref_mut(generator_drop);\n+        if let Some(cached_block) = *cached_block {\n+            cached_block\n+        } else {\n+            let block = cfg.start_new_cleanup_block();\n+            cfg.push_end_region(tcx, block, source_info(span), scope.region_scope);\n+            cfg.terminate(block, source_info(span), TerminatorKind::Goto { target: target });\n+            *cached_block = Some(block);\n+            block\n+        }\n+    };\n+\n+    debug!(\"build_diverge_scope({:?}, {:?}) = {:?}\", scope, span, target);\n \n     target\n }"}, {"sha": "6cab5a8bf6026d0d28aaa43ac38a027b7b35fb4e", "filename": "src/test/compile-fail/borrowck/borrowck-unary-move.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-unary-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-unary-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-unary-move.rs?ref=87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc", "patch": "@@ -8,10 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n \n fn foo(x: Box<isize>) -> isize {\n     let y = &*x;\n-    free(x); //~ ERROR cannot move out of `x` because it is borrowed\n+    free(x); //[ast]~ ERROR cannot move out of `x` because it is borrowed\n+    //[mir]~^ ERROR cannot move out of `x` because it is borrowed (Ast)\n+    //[mir]~| ERROR cannot move out of `x` because it is borrowed (Mir)\n     *y\n }\n "}, {"sha": "483dbb356ce6aaabc3601ae238fd12d65efe1414", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(untagged_unions)]\n+#![feature(generators, generator_trait, untagged_unions)]\n \n use std::cell::{Cell, RefCell};\n+use std::ops::Generator;\n use std::panic;\n use std::usize;\n \n@@ -161,6 +162,32 @@ fn vec_simple(a: &Allocator) {\n     let _x = vec![a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n }\n \n+fn generator(a: &Allocator, run_count: usize) {\n+    assert!(run_count < 4);\n+\n+    let mut gen = || {\n+        (a.alloc(),\n+         yield a.alloc(),\n+         a.alloc(),\n+         yield a.alloc()\n+         );\n+    };\n+    for _ in 0..run_count {\n+        gen.resume();\n+    }\n+}\n+\n+fn mixed_drop_and_nondrop(a: &Allocator) {\n+    // check that destructor panics handle drop\n+    // and non-drop blocks in the same scope correctly.\n+    //\n+    // Surprisingly enough, this used to not work.\n+    let (x, y, z);\n+    x = a.alloc();\n+    y = 5;\n+    z = a.alloc();\n+}\n+\n #[allow(unreachable_code)]\n fn vec_unreachable(a: &Allocator) {\n     let _x = vec![a.alloc(), a.alloc(), a.alloc(), return];\n@@ -228,5 +255,12 @@ fn main() {\n     run_test(|a| field_assignment(a, false));\n     run_test(|a| field_assignment(a, true));\n \n+    run_test(|a| generator(a, 0));\n+    run_test(|a| generator(a, 1));\n+    run_test(|a| generator(a, 2));\n+    run_test(|a| generator(a, 3));\n+\n+    run_test(|a| mixed_drop_and_nondrop(a));\n+\n     run_test_nopanic(|a| union1(a));\n }"}]}