{"sha": "4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZjJlNTEwZTBjYmQ5MWQ1MWJkYmUzMDgwYzc0OTFhNmE0YzY1Njc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-25T01:13:27Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:53:09Z"}, "message": "Convert std::getopts to istrs. Issue #855", "tree": {"sha": "7ff1fa400203a7faa8ec2e38cee9c7c7479aaa2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ff1fa400203a7faa8ec2e38cee9c7c7479aaa2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567", "html_url": "https://github.com/rust-lang/rust/commit/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a5f4e7a745f00e9d7154f325b17b431a04e13a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a5f4e7a745f00e9d7154f325b17b431a04e13a3", "html_url": "https://github.com/rust-lang/rust/commit/3a5f4e7a745f00e9d7154f325b17b431a04e13a3"}], "stats": {"total": 546, "additions": 287, "deletions": 259}, "files": [{"sha": "a045801322f4de7e2b24a414a28646405c4713a7", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 61, "deletions": 55, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567", "patch": "@@ -330,45 +330,47 @@ fn build_target_config() -> @session::config {\n     ret target_cfg;\n }\n \n-fn build_session_options(binary: str, match: getopts::match, binary_dir: str)\n+fn build_session_options(binary: str, match: &getopts::match, binary_dir: str)\n    -> @session::options {\n-    let library = opt_present(match, \"lib\");\n-    let static = opt_present(match, \"static\");\n+    let library = opt_present(match, ~\"lib\");\n+    let static = opt_present(match, ~\"static\");\n \n     let library_search_paths = [binary_dir + \"/lib\"];\n-    let lsp_vec = getopts::opt_strs(match, \"L\");\n-    for lsp: str in lsp_vec { library_search_paths += [lsp]; }\n+    let lsp_vec = getopts::opt_strs(match, ~\"L\");\n+    for lsp: istr in lsp_vec {\n+        library_search_paths += [istr::to_estr(lsp)];\n+    }\n \n-    let parse_only = opt_present(match, \"parse-only\");\n-    let no_trans = opt_present(match, \"no-trans\");\n+    let parse_only = opt_present(match, ~\"parse-only\");\n+    let no_trans = opt_present(match, ~\"no-trans\");\n \n     let output_type =\n         if parse_only || no_trans {\n             link::output_type_none\n-        } else if opt_present(match, \"S\") {\n+        } else if opt_present(match, ~\"S\") {\n             link::output_type_assembly\n-        } else if opt_present(match, \"c\") {\n+        } else if opt_present(match, ~\"c\") {\n             link::output_type_object\n-        } else if opt_present(match, \"emit-llvm\") {\n+        } else if opt_present(match, ~\"emit-llvm\") {\n             link::output_type_bitcode\n         } else { link::output_type_exe };\n-    let verify = !opt_present(match, \"noverify\");\n-    let save_temps = opt_present(match, \"save-temps\");\n-    let debuginfo = opt_present(match, \"g\");\n-    let stats = opt_present(match, \"stats\");\n-    let time_passes = opt_present(match, \"time-passes\");\n-    let time_llvm_passes = opt_present(match, \"time-llvm-passes\");\n-    let run_typestate = !opt_present(match, \"no-typestate\");\n-    let sysroot_opt = getopts::opt_maybe_str(match, \"sysroot\");\n+    let verify = !opt_present(match, ~\"noverify\");\n+    let save_temps = opt_present(match, ~\"save-temps\");\n+    let debuginfo = opt_present(match, ~\"g\");\n+    let stats = opt_present(match, ~\"stats\");\n+    let time_passes = opt_present(match, ~\"time-passes\");\n+    let time_llvm_passes = opt_present(match, ~\"time-llvm-passes\");\n+    let run_typestate = !opt_present(match, ~\"no-typestate\");\n+    let sysroot_opt = getopts::opt_maybe_str(match, ~\"sysroot\");\n     let opt_level: uint =\n-        if opt_present(match, \"O\") {\n-            if opt_present(match, \"OptLevel\") {\n+        if opt_present(match, ~\"O\") {\n+            if opt_present(match, ~\"OptLevel\") {\n                 log_err \"error: -O and --OptLevel both provided\";\n                 fail;\n             }\n             2u\n-        } else if opt_present(match, \"OptLevel\") {\n-            alt getopts::opt_str(match, \"OptLevel\") {\n+        } else if opt_present(match, ~\"OptLevel\") {\n+            alt istr::to_estr(getopts::opt_str(match, ~\"OptLevel\")) {\n               \"0\" { 0u }\n               \"1\" { 1u }\n               \"2\" { 2u }\n@@ -383,11 +385,12 @@ fn build_session_options(binary: str, match: getopts::match, binary_dir: str)\n     let sysroot =\n         alt sysroot_opt {\n           none. { get_default_sysroot(binary) }\n-          some(s) { s }\n+          some(s) { istr::to_estr(s) }\n         };\n-    let cfg = parse_cfgspecs(getopts::opt_strs(match, \"cfg\"));\n-    let test = opt_present(match, \"test\");\n-    let do_gc = opt_present(match, \"gc\");\n+    let cfg = parse_cfgspecs(\n+        istr::to_estrs(getopts::opt_strs(match, ~\"cfg\")));\n+    let test = opt_present(match, ~\"test\");\n+    let do_gc = opt_present(match, ~\"gc\");\n     let sopts: @session::options =\n         @{library: library,\n           static: static,\n@@ -418,60 +421,62 @@ fn build_session(sopts: @session::options) -> session::session {\n                          none, 0u);\n }\n \n-fn parse_pretty(sess: session::session, name: &str) -> pp_mode {\n-    if str::eq(name, \"normal\") {\n+fn parse_pretty(sess: session::session, name: &istr) -> pp_mode {\n+    if istr::eq(name, ~\"normal\") {\n         ret ppm_normal;\n-    } else if str::eq(name, \"expanded\") {\n+    } else if istr::eq(name, ~\"expanded\") {\n         ret ppm_expanded;\n-    } else if str::eq(name, \"typed\") {\n+    } else if istr::eq(name, ~\"typed\") {\n         ret ppm_typed;\n-    } else if str::eq(name, \"identified\") { ret ppm_identified; }\n+    } else if istr::eq(name, ~\"identified\") { ret ppm_identified; }\n     sess.fatal(\"argument to `pretty` must be one of `normal`, `typed`, or \"\n                + \"`identified`\");\n }\n \n fn opts() -> [getopts::opt] {\n-    ret [optflag(\"h\"), optflag(\"help\"), optflag(\"v\"), optflag(\"version\"),\n-         optflag(\"glue\"), optflag(\"emit-llvm\"), optflagopt(\"pretty\"),\n-         optflag(\"ls\"), optflag(\"parse-only\"), optflag(\"no-trans\"),\n-         optflag(\"O\"), optopt(\"OptLevel\"), optmulti(\"L\"),\n-         optflag(\"S\"), optflag(\"c\"), optopt(\"o\"), optflag(\"g\"),\n-         optflag(\"save-temps\"), optopt(\"sysroot\"), optflag(\"stats\"),\n-         optflag(\"time-passes\"), optflag(\"time-llvm-passes\"),\n-         optflag(\"no-typestate\"), optflag(\"noverify\"), optmulti(\"cfg\"),\n-         optflag(\"test\"), optflag(\"lib\"), optflag(\"static\"), optflag(\"gc\")];\n+    ret [optflag(~\"h\"), optflag(~\"help\"), optflag(~\"v\"), optflag(~\"version\"),\n+         optflag(~\"glue\"), optflag(~\"emit-llvm\"), optflagopt(~\"pretty\"),\n+         optflag(~\"ls\"), optflag(~\"parse-only\"), optflag(~\"no-trans\"),\n+         optflag(~\"O\"), optopt(~\"OptLevel\"), optmulti(~\"L\"),\n+         optflag(~\"S\"), optflag(~\"c\"), optopt(~\"o\"), optflag(~\"g\"),\n+         optflag(~\"save-temps\"), optopt(~\"sysroot\"), optflag(~\"stats\"),\n+         optflag(~\"time-passes\"), optflag(~\"time-llvm-passes\"),\n+         optflag(~\"no-typestate\"), optflag(~\"noverify\"), optmulti(~\"cfg\"),\n+         optflag(~\"test\"), optflag(~\"lib\"), optflag(~\"static\"),\n+         optflag(~\"gc\")];\n }\n \n fn main(args: [str]) {\n     let binary = vec::shift(args);\n     let binary_dir = istr::to_estr(\n         fs::dirname(istr::from_estr(binary)));\n     let match =\n-        alt getopts::getopts(args, opts()) {\n+        alt getopts::getopts(istr::from_estrs(args), opts()) {\n           getopts::success(m) { m }\n           getopts::failure(f) {\n-            log_err #fmt[\"error: %s\", getopts::fail_str(f)];\n+            log_err #fmt[\"error: %s\", istr::to_estr(getopts::fail_str(f))];\n             fail\n           }\n         };\n-    if opt_present(match, \"h\") || opt_present(match, \"help\") {\n+    if opt_present(match, ~\"h\") || opt_present(match, ~\"help\") {\n         usage(binary);\n         ret;\n     }\n-    if opt_present(match, \"v\") || opt_present(match, \"version\") {\n+    if opt_present(match, ~\"v\") || opt_present(match, ~\"version\") {\n         version(binary);\n         ret;\n     }\n     let sopts = build_session_options(binary, match, binary_dir);\n     let sess = build_session(sopts);\n-    let n_inputs = vec::len::<str>(match.free);\n-    let output_file = getopts::opt_maybe_str(match, \"o\");\n-    let glue = opt_present(match, \"glue\");\n+    let n_inputs = vec::len::<istr>(match.free);\n+    let output_file = getopts::opt_maybe_str(match, ~\"o\");\n+    let glue = opt_present(match, ~\"glue\");\n     if glue {\n         if n_inputs > 0u {\n             sess.fatal(\"No input files allowed with --glue.\");\n         }\n-        let out = option::from_maybe::<str>(\"glue.bc\", output_file);\n+        let out = option::from_maybe::<istr>(~\"glue.bc\", output_file);\n+        let out = istr::to_estr(out);\n         middle::trans::make_common_glue(sess, out);\n         ret;\n     }\n@@ -480,22 +485,22 @@ fn main(args: [str]) {\n     } else if n_inputs > 1u {\n         sess.fatal(\"Multiple input filenames provided.\");\n     }\n-    let ifile = match.free[0];\n+    let ifile = istr::to_estr(match.free[0]);\n     let saved_out_filename: str = \"\";\n     let cfg = build_configuration(sess, binary, ifile);\n     let pretty =\n-        option::map::<str,\n+        option::map::<istr,\n                       pp_mode>(bind parse_pretty(sess, _),\n-                               getopts::opt_default(match, \"pretty\",\n-                                                    \"normal\"));\n+                               getopts::opt_default(match, ~\"pretty\",\n+                                                    ~\"normal\"));\n     alt pretty {\n       some::<pp_mode>(ppm) {\n         pretty_print_input(sess, cfg, ifile, ppm);\n         ret;\n       }\n       none::<pp_mode>. {/* continue */ }\n     }\n-    let ls = opt_present(match, \"ls\");\n+    let ls = opt_present(match, ~\"ls\");\n     if ls { metadata::creader::list_file_metadata(ifile, io::stdout()); ret; }\n \n     let stop_after_codegen =\n@@ -528,6 +533,7 @@ fn main(args: [str]) {\n         compile_input(sess, cfg, ifile, ofile);\n       }\n       some(ofile) {\n+        let ofile = istr::to_estr(ofile);\n         // FIXME: what about windows? This will create a foo.exe.o.\n         saved_out_filename = ofile;\n         let temp_filename =\n@@ -634,7 +640,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let match =\n-            alt getopts::getopts([\"--test\"], opts()) {\n+            alt getopts::getopts([~\"--test\"], opts()) {\n               getopts::success(m) { m }\n             };\n         let sessopts = build_session_options(\"whatever\", match, \"whatever\");\n@@ -648,7 +654,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let match =\n-            alt getopts::getopts([\"--test\", \"--cfg=test\"], opts()) {\n+            alt getopts::getopts([~\"--test\", ~\"--cfg=test\"], opts()) {\n               getopts::success(m) { m }\n             };\n         let sessopts = build_session_options(\"whatever\", match, \"whatever\");"}, {"sha": "c38b93ee8b0322741d0b31510dbfabbd7ef42142", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567", "patch": "@@ -29,119 +29,121 @@ export opt_strs;\n export opt_maybe_str;\n export opt_default;\n \n-tag name { long(str); short(char); }\n+tag name { long(istr); short(char); }\n \n tag hasarg { yes; no; maybe; }\n \n tag occur { req; optional; multi; }\n \n type opt = {name: name, hasarg: hasarg, occur: occur};\n \n-fn mkname(nm: str) -> name {\n-    ret if str::char_len(nm) == 1u {\n-            short(str::char_at(nm, 0u))\n+fn mkname(nm: &istr) -> name {\n+    ret if istr::char_len(nm) == 1u {\n+            short(istr::char_at(nm, 0u))\n         } else { long(nm) };\n }\n \n-fn reqopt(name: str) -> opt {\n+fn reqopt(name: &istr) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: req};\n }\n \n-fn optopt(name: str) -> opt {\n+fn optopt(name: &istr) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: optional};\n }\n \n-fn optflag(name: str) -> opt {\n+fn optflag(name: &istr) -> opt {\n     ret {name: mkname(name), hasarg: no, occur: optional};\n }\n \n-fn optflagopt(name: str) -> opt {\n+fn optflagopt(name: &istr) -> opt {\n     ret {name: mkname(name), hasarg: maybe, occur: optional};\n }\n \n-fn optmulti(name: str) -> opt {\n+fn optmulti(name: &istr) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: multi};\n }\n \n-tag optval { val(str); given; }\n+tag optval { val(istr); given; }\n \n-type match = {opts: [opt], vals: [mutable [optval]], free: [str]};\n+type match = {opts: [opt], vals: [mutable [optval]], free: [istr]};\n \n-fn is_arg(arg: str) -> bool {\n-    ret str::byte_len(arg) > 1u && arg[0] == '-' as u8;\n+fn is_arg(arg: &istr) -> bool {\n+    ret istr::byte_len(arg) > 1u && arg[0] == '-' as u8;\n }\n \n-fn name_str(nm: name) -> str {\n-    ret alt nm { short(ch) { str::from_char(ch) } long(s) { s } };\n+fn name_str(nm: &name) -> istr {\n+    ret alt nm { short(ch) { istr::from_char(ch) } long(s) { s } };\n }\n \n-fn find_opt(opts: &[opt], nm: name) -> option::t<uint> {\n+fn find_opt(opts: &[opt], nm: &name) -> option::t<uint> {\n     let i = 0u;\n     let l = vec::len::<opt>(opts);\n     while i < l { if opts[i].name == nm { ret some::<uint>(i); } i += 1u; }\n     ret none::<uint>;\n }\n \n tag fail_ {\n-    argument_missing(str);\n-    unrecognized_option(str);\n-    option_missing(str);\n-    option_duplicated(str);\n-    unexpected_argument(str);\n+    argument_missing(istr);\n+    unrecognized_option(istr);\n+    option_missing(istr);\n+    option_duplicated(istr);\n+    unexpected_argument(istr);\n }\n \n-fn fail_str(f: fail_) -> str {\n+fn fail_str(f: &fail_) -> istr {\n     ret alt f {\n-          argument_missing(nm) { \"Argument to option '\" + nm + \"' missing.\" }\n-          unrecognized_option(nm) { \"Unrecognized option: '\" + nm + \"'.\" }\n-          option_missing(nm) { \"Required option '\" + nm + \"' missing.\" }\n+          argument_missing(nm) {\n+            ~\"Argument to option '\" + nm + ~\"' missing.\" }\n+          unrecognized_option(nm) {\n+            ~\"Unrecognized option: '\" + nm + ~\"'.\" }\n+          option_missing(nm) { ~\"Required option '\" + nm + ~\"' missing.\" }\n           option_duplicated(nm) {\n-            \"Option '\" + nm + \"' given more than once.\"\n+            ~\"Option '\" + nm + ~\"' given more than once.\"\n           }\n           unexpected_argument(nm) {\n-            \"Option \" + nm + \" does not take an argument.\"\n+            ~\"Option \" + nm + ~\" does not take an argument.\"\n           }\n         };\n }\n \n tag result { success(match); failure(fail_); }\n \n-fn getopts(args: &[str], opts: &[opt]) -> result {\n+fn getopts(args: &[istr], opts: &[opt]) -> result {\n     let n_opts = vec::len::<opt>(opts);\n     fn f(_x: uint) -> [optval] { ret []; }\n     let vals = vec::init_fn_mut::<[optval]>(f, n_opts);\n-    let free: [str] = [];\n-    let l = vec::len::<str>(args);\n+    let free: [istr] = [];\n+    let l = vec::len(args);\n     let i = 0u;\n     while i < l {\n         let cur = args[i];\n-        let curlen = str::byte_len(cur);\n+        let curlen = istr::byte_len(cur);\n         if !is_arg(cur) {\n             free += [cur];\n-        } else if str::eq(cur, \"--\") {\n+        } else if istr::eq(cur, ~\"--\") {\n             let j = i + 1u;\n             while j < l { free += [args[j]]; j += 1u; }\n             break;\n         } else {\n             let names;\n-            let i_arg = option::none::<str>;\n+            let i_arg = option::none::<istr>;\n             if cur[1] == '-' as u8 {\n-                let tail = str::slice(cur, 2u, curlen);\n-                let eq = str::index(tail, '=' as u8);\n+                let tail = istr::slice(cur, 2u, curlen);\n+                let eq = istr::index(tail, '=' as u8);\n                 if eq == -1 {\n                     names = [long(tail)];\n                 } else {\n-                    names = [long(str::slice(tail, 0u, eq as uint))];\n+                    names = [long(istr::slice(tail, 0u, eq as uint))];\n                     i_arg =\n-                        option::some::<str>(str::slice(tail,\n-                                                       (eq as uint) + 1u,\n-                                                       curlen - 2u));\n+                        option::some::<istr>(istr::slice(tail,\n+                                                        (eq as uint) + 1u,\n+                                                        curlen - 2u));\n                 }\n             } else {\n                 let j = 1u;\n                 names = [];\n                 while j < curlen {\n-                    let range = str::char_range_at(cur, j);\n+                    let range = istr::char_range_at(cur, j);\n                     names += [short(range.ch)];\n                     j = range.next;\n                 }\n@@ -156,22 +158,22 @@ fn getopts(args: &[str], opts: &[opt]) -> result {\n                 }\n                 alt opts[optid].hasarg {\n                   no. {\n-                    if !option::is_none::<str>(i_arg) {\n+                    if !option::is_none::<istr>(i_arg) {\n                         ret failure(unexpected_argument(name_str(nm)));\n                     }\n                     vals[optid] += [given];\n                   }\n                   maybe. {\n-                    if !option::is_none::<str>(i_arg) {\n+                    if !option::is_none::<istr>(i_arg) {\n                         vals[optid] += [val(option::get(i_arg))];\n                     } else if name_pos < vec::len::<name>(names) ||\n                                   i + 1u == l || is_arg(args[i + 1u]) {\n                         vals[optid] += [given];\n                     } else { i += 1u; vals[optid] += [val(args[i])]; }\n                   }\n                   yes. {\n-                    if !option::is_none::<str>(i_arg) {\n-                        vals[optid] += [val(option::get::<str>(i_arg))];\n+                    if !option::is_none::<istr>(i_arg) {\n+                        vals[optid] += [val(option::get::<istr>(i_arg))];\n                     } else if i + 1u == l {\n                         ret failure(argument_missing(name_str(nm)));\n                     } else { i += 1u; vals[optid] += [val(args[i])]; }\n@@ -200,45 +202,45 @@ fn getopts(args: &[str], opts: &[opt]) -> result {\n     ret success({opts: opts, vals: vals, free: free});\n }\n \n-fn opt_vals(m: &match, nm: str) -> [optval] {\n+fn opt_vals(m: &match, nm: &istr) -> [optval] {\n     ret alt find_opt(m.opts, mkname(nm)) {\n           some(id) { m.vals[id] }\n-          none. { log_err \"No option '\" + nm + \"' defined.\"; fail }\n+          none. { log_err ~\"No option '\" + nm + ~\"' defined.\"; fail }\n         };\n }\n \n-fn opt_val(m: &match, nm: str) -> optval { ret opt_vals(m, nm)[0]; }\n+fn opt_val(m: &match, nm: &istr) -> optval { ret opt_vals(m, nm)[0]; }\n \n-fn opt_present(m: &match, nm: str) -> bool {\n+fn opt_present(m: &match, nm: &istr) -> bool {\n     ret vec::len::<optval>(opt_vals(m, nm)) > 0u;\n }\n \n-fn opt_str(m: &match, nm: str) -> str {\n+fn opt_str(m: &match, nm: &istr) -> istr {\n     ret alt opt_val(m, nm) { val(s) { s } _ { fail } };\n }\n \n-fn opt_strs(m: &match, nm: str) -> [str] {\n-    let acc: [str] = [];\n+fn opt_strs(m: &match, nm: &istr) -> [istr] {\n+    let acc: [istr] = [];\n     for v: optval in opt_vals(m, nm) {\n         alt v { val(s) { acc += [s]; } _ { } }\n     }\n     ret acc;\n }\n \n-fn opt_maybe_str(m: &match, nm: str) -> option::t<str> {\n+fn opt_maybe_str(m: &match, nm: &istr) -> option::t<istr> {\n     let vals = opt_vals(m, nm);\n-    if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n-    ret alt vals[0] { val(s) { some::<str>(s) } _ { none::<str> } };\n+    if vec::len::<optval>(vals) == 0u { ret none::<istr>; }\n+    ret alt vals[0] { val(s) { some::<istr>(s) } _ { none::<istr> } };\n }\n \n \n /// Returns none if the option was not present, `def` if the option was\n /// present but no argument was provided, and the argument if the option was\n /// present and an argument was provided.\n-fn opt_default(m: &match, nm: str, def: str) -> option::t<str> {\n+fn opt_default(m: &match, nm: &istr, def: &istr) -> option::t<istr> {\n     let vals = opt_vals(m, nm);\n-    if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n-    ret alt vals[0] { val(s) { some::<str>(s) } _ { some::<str>(def) } }\n+    if vec::len::<optval>(vals) == 0u { ret none::<istr>; }\n+    ret alt vals[0] { val(s) { some::<istr>(s) } _ { some::<istr>(def) } }\n }\n // Local Variables:\n // mode: rust;"}, {"sha": "a15e32e51906a56095174cdbda6483d3d9e078be", "filename": "src/lib/istr.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/src%2Flib%2Fistr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/src%2Flib%2Fistr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fistr.rs?ref=4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567", "patch": "@@ -3,9 +3,9 @@ index, rindex, find, starts_with, ends_with, substr, slice, split,\n concat, connect, to_upper, replace, char_slice, trim_left, trim_right, trim,\n unshift_char, shift_char, pop_char, push_char, is_utf8, from_chars, to_chars,\n char_len, char_at, bytes, is_ascii, shift_byte, pop_byte, unsafe_from_byte,\n-unsafe_from_bytes, from_char;\n+unsafe_from_bytes, from_char, char_range_at;\n \n-export from_estr, to_estr;\n+export from_estr, to_estr, from_estrs, to_estrs;\n \n fn from_estr(s: &str) -> istr {\n     let s2 = ~\"\";\n@@ -23,6 +23,22 @@ fn to_estr(s: &istr) -> str {\n     ret s2;\n }\n \n+fn from_estrs(ss: &[str]) -> [istr] {\n+    let ss2 = [];\n+    for s in ss {\n+        ss2 += [from_estr(s)];\n+    }\n+    ret ss2;\n+}\n+\n+fn to_estrs(ss: &[istr]) -> [str] {\n+    let ss2 = [];\n+    for s in ss {\n+        ss2 += [to_estr(s)];\n+    }\n+    ret ss2;\n+}\n+\n fn eq(a: &istr, b: &istr) -> bool { a == b }\n \n fn lteq(a: &istr, b: &istr) -> bool { a <= b }"}, {"sha": "ef3348dc36b9d113317fe8795e8fcf76283d760a", "filename": "src/lib/test.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567", "patch": "@@ -66,20 +66,22 @@ type opt_res = either::t<test_opts, str>;\n // Parses command line arguments into test options\n fn parse_opts(args: &[str]) : vec::is_not_empty(args) -> opt_res {\n \n-    let args_ = vec::tail(args);\n-    let opts = [getopts::optflag(\"ignored\")];\n+    let args_ = istr::from_estrs(vec::tail(args));\n+    let opts = [getopts::optflag(~\"ignored\")];\n     let match =\n         alt getopts::getopts(args_, opts) {\n           getopts::success(m) { m }\n-          getopts::failure(f) { ret either::right(getopts::fail_str(f)) }\n+          getopts::failure(f) {\n+            ret either::right(istr::to_estr(getopts::fail_str(f)))\n+          }\n         };\n \n     let filter =\n         if vec::len(match.free) > 0u {\n-            option::some(match.free[0])\n+            option::some(istr::to_estr(match.free[0]))\n         } else { option::none };\n \n-    let run_ignored = getopts::opt_present(match, \"ignored\");\n+    let run_ignored = getopts::opt_present(match, ~\"ignored\");\n \n     let test_opts = {filter: filter, run_ignored: run_ignored};\n "}, {"sha": "c0710c9018c5ac8ebb25474542db39d19a32a1a5", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567", "patch": "@@ -51,13 +51,14 @@ fn fib(n: int) -> int {\n type config = {stress: bool};\n \n fn parse_opts(argv: [str]) -> config {\n-    let opts = [getopts::optflag(\"stress\")];\n+    let argv = istr::from_estrs(argv);\n+    let opts = [getopts::optflag(~\"stress\")];\n \n     let opt_args = vec::slice(argv, 1u, vec::len(argv));\n \n \n     alt getopts::getopts(opt_args, opts) {\n-      getopts::success(m) { ret {stress: getopts::opt_present(m, \"stress\")} }\n+      getopts::success(m) { ret {stress: getopts::opt_present(m, ~\"stress\")} }\n       getopts::failure(_) { fail; }\n     }\n }"}, {"sha": "05451f508e98fff7fb7fa60b51e812dd473da856", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567", "patch": "@@ -30,45 +30,45 @@ fn main(args: [str]) {\n }\n \n fn parse_config(args: &[str]) -> config {\n+    let args = istr::from_estrs(args);\n     let opts =\n-        [getopts::reqopt(\"compile-lib-path\"), getopts::reqopt(\"run-lib-path\"),\n-         getopts::reqopt(\"rustc-path\"), getopts::reqopt(\"src-base\"),\n-         getopts::reqopt(\"build-base\"), getopts::reqopt(\"stage-id\"),\n-         getopts::reqopt(\"mode\"), getopts::optflag(\"ignored\"),\n-         getopts::optopt(\"runtool\"), getopts::optopt(\"rustcflags\"),\n-         getopts::optflag(\"verbose\")];\n+        [getopts::reqopt(~\"compile-lib-path\"),\n+         getopts::reqopt(~\"run-lib-path\"),\n+         getopts::reqopt(~\"rustc-path\"),\n+         getopts::reqopt(~\"src-base\"),\n+         getopts::reqopt(~\"build-base\"),\n+         getopts::reqopt(~\"stage-id\"),\n+         getopts::reqopt(~\"mode\"),\n+         getopts::optflag(~\"ignored\"),\n+         getopts::optopt(~\"runtool\"),\n+         getopts::optopt(~\"rustcflags\"),\n+         getopts::optflag(~\"verbose\")];\n \n     check (vec::is_not_empty(args));\n     let args_ = vec::tail(args);\n     let match =\n         alt getopts::getopts(args_, opts) {\n           getopts::success(m) { m }\n-          getopts::failure(f) { fail getopts::fail_str(f) }\n+          getopts::failure(f) {\n+            fail istr::to_estr(getopts::fail_str(f))\n+          }\n         };\n \n-    let cnv = istr::from_estr;\n-    let cnvo = fn(o: &option::t<str>) -> option::t<istr> {\n-        alt o {\n-          option::some(s) { option::some(istr::from_estr(s)) }\n-          option::none. { option::none }\n-        }\n-    };\n-\n-    ret {compile_lib_path: cnv(getopts::opt_str(match, \"compile-lib-path\")),\n-         run_lib_path: cnv(getopts::opt_str(match, \"run-lib-path\")),\n-         rustc_path: cnv(getopts::opt_str(match, \"rustc-path\")),\n-         src_base: cnv(getopts::opt_str(match, \"src-base\")),\n-         build_base: cnv(getopts::opt_str(match, \"build-base\")),\n-         stage_id: cnv(getopts::opt_str(match, \"stage-id\")),\n-         mode: str_mode(getopts::opt_str(match, \"mode\")),\n-         run_ignored: getopts::opt_present(match, \"ignored\"),\n+    ret {compile_lib_path: getopts::opt_str(match, ~\"compile-lib-path\"),\n+         run_lib_path: getopts::opt_str(match, ~\"run-lib-path\"),\n+         rustc_path: getopts::opt_str(match, ~\"rustc-path\"),\n+         src_base: getopts::opt_str(match, ~\"src-base\"),\n+         build_base: getopts::opt_str(match, ~\"build-base\"),\n+         stage_id: getopts::opt_str(match, ~\"stage-id\"),\n+         mode: str_mode(istr::to_estr(getopts::opt_str(match, ~\"mode\"))),\n+         run_ignored: getopts::opt_present(match, ~\"ignored\"),\n          filter:\n              if vec::len(match.free) > 0u {\n-                 option::some(cnv(match.free[0]))\n+                 option::some(match.free[0])\n              } else { option::none },\n-         runtool: cnvo(getopts::opt_maybe_str(match, \"runtool\")),\n-         rustcflags: cnvo(getopts::opt_maybe_str(match, \"rustcflags\")),\n-         verbose: getopts::opt_present(match, \"verbose\")};\n+         runtool: getopts::opt_maybe_str(match, ~\"runtool\"),\n+         rustcflags: getopts::opt_maybe_str(match, ~\"rustcflags\"),\n+         verbose: getopts::opt_present(match, ~\"verbose\")};\n }\n \n fn log_config(config: &config) {"}, {"sha": "332ec484c95678fa4417d13e7800dd8901db1c42", "filename": "src/test/stdtest/getopts.rs", "status": "modified", "additions": 112, "deletions": 111, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/src%2Ftest%2Fstdtest%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567/src%2Ftest%2Fstdtest%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fgetopts.rs?ref=4cf2e510e0cbd91d51bdbe3080c7491a6a4c6567", "patch": "@@ -27,22 +27,22 @@ fn check_fail_type(f: opt::fail_, ft: fail_type) {\n // Tests for reqopt\n #[test]\n fn test_reqopt_long() {\n-    let args = [\"--test=20\"];\n-    let opts = [opt::reqopt(\"test\")];\n+    let args = [~\"--test=20\"];\n+    let opts = [opt::reqopt(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::success(m) {\n-        assert (opt::opt_present(m, \"test\"));\n-        assert (opt::opt_str(m, \"test\") == \"20\");\n+        assert (opt::opt_present(m, ~\"test\"));\n+        assert (opt::opt_str(m, ~\"test\") == ~\"20\");\n       }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_reqopt_long_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::reqopt(\"test\")];\n+    let args = [~\"blah\"];\n+    let opts = [opt::reqopt(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, option_missing); }\n@@ -52,8 +52,8 @@ fn test_reqopt_long_missing() {\n \n #[test]\n fn test_reqopt_long_no_arg() {\n-    let args = [\"--test\"];\n-    let opts = [opt::reqopt(\"test\")];\n+    let args = [~\"--test\"];\n+    let opts = [opt::reqopt(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, argument_missing); }\n@@ -63,8 +63,8 @@ fn test_reqopt_long_no_arg() {\n \n #[test]\n fn test_reqopt_long_multi() {\n-    let args = [\"--test=20\", \"--test=30\"];\n-    let opts = [opt::reqopt(\"test\")];\n+    let args = [~\"--test=20\", ~\"--test=30\"];\n+    let opts = [opt::reqopt(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, option_duplicated); }\n@@ -74,22 +74,22 @@ fn test_reqopt_long_multi() {\n \n #[test]\n fn test_reqopt_short() {\n-    let args = [\"-t\", \"20\"];\n-    let opts = [opt::reqopt(\"t\")];\n+    let args = [~\"-t\", ~\"20\"];\n+    let opts = [opt::reqopt(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::success(m) {\n-        assert (opt::opt_present(m, \"t\"));\n-        assert (opt::opt_str(m, \"t\") == \"20\");\n+        assert (opt::opt_present(m, ~\"t\"));\n+        assert (opt::opt_str(m, ~\"t\") == ~\"20\");\n       }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_reqopt_short_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::reqopt(\"t\")];\n+    let args = [~\"blah\"];\n+    let opts = [opt::reqopt(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, option_missing); }\n@@ -99,8 +99,8 @@ fn test_reqopt_short_missing() {\n \n #[test]\n fn test_reqopt_short_no_arg() {\n-    let args = [\"-t\"];\n-    let opts = [opt::reqopt(\"t\")];\n+    let args = [~\"-t\"];\n+    let opts = [opt::reqopt(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, argument_missing); }\n@@ -110,8 +110,8 @@ fn test_reqopt_short_no_arg() {\n \n #[test]\n fn test_reqopt_short_multi() {\n-    let args = [\"-t\", \"20\", \"-t\", \"30\"];\n-    let opts = [opt::reqopt(\"t\")];\n+    let args = [~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n+    let opts = [opt::reqopt(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, option_duplicated); }\n@@ -123,33 +123,33 @@ fn test_reqopt_short_multi() {\n // Tests for optopt\n #[test]\n fn test_optopt_long() {\n-    let args = [\"--test=20\"];\n-    let opts = [opt::optopt(\"test\")];\n+    let args = [~\"--test=20\"];\n+    let opts = [opt::optopt(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::success(m) {\n-        assert (opt::opt_present(m, \"test\"));\n-        assert (opt::opt_str(m, \"test\") == \"20\");\n+        assert (opt::opt_present(m, ~\"test\"));\n+        assert (opt::opt_str(m, ~\"test\") == ~\"20\");\n       }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_optopt_long_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::optopt(\"test\")];\n+    let args = [~\"blah\"];\n+    let opts = [opt::optopt(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n-      opt::success(m) { assert (!opt::opt_present(m, \"test\")); }\n+      opt::success(m) { assert (!opt::opt_present(m, ~\"test\")); }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_optopt_long_no_arg() {\n-    let args = [\"--test\"];\n-    let opts = [opt::optopt(\"test\")];\n+    let args = [~\"--test\"];\n+    let opts = [opt::optopt(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, argument_missing); }\n@@ -159,8 +159,8 @@ fn test_optopt_long_no_arg() {\n \n #[test]\n fn test_optopt_long_multi() {\n-    let args = [\"--test=20\", \"--test=30\"];\n-    let opts = [opt::optopt(\"test\")];\n+    let args = [~\"--test=20\", ~\"--test=30\"];\n+    let opts = [opt::optopt(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, option_duplicated); }\n@@ -170,33 +170,33 @@ fn test_optopt_long_multi() {\n \n #[test]\n fn test_optopt_short() {\n-    let args = [\"-t\", \"20\"];\n-    let opts = [opt::optopt(\"t\")];\n+    let args = [~\"-t\", ~\"20\"];\n+    let opts = [opt::optopt(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::success(m) {\n-        assert (opt::opt_present(m, \"t\"));\n-        assert (opt::opt_str(m, \"t\") == \"20\");\n+        assert (opt::opt_present(m, ~\"t\"));\n+        assert (opt::opt_str(m, ~\"t\") == ~\"20\");\n       }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_optopt_short_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::optopt(\"t\")];\n+    let args = [~\"blah\"];\n+    let opts = [opt::optopt(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n-      opt::success(m) { assert (!opt::opt_present(m, \"t\")); }\n+      opt::success(m) { assert (!opt::opt_present(m, ~\"t\")); }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_optopt_short_no_arg() {\n-    let args = [\"-t\"];\n-    let opts = [opt::optopt(\"t\")];\n+    let args = [~\"-t\"];\n+    let opts = [opt::optopt(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, argument_missing); }\n@@ -206,8 +206,8 @@ fn test_optopt_short_no_arg() {\n \n #[test]\n fn test_optopt_short_multi() {\n-    let args = [\"-t\", \"20\", \"-t\", \"30\"];\n-    let opts = [opt::optopt(\"t\")];\n+    let args = [~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n+    let opts = [opt::optopt(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, option_duplicated); }\n@@ -219,30 +219,30 @@ fn test_optopt_short_multi() {\n // Tests for optflag\n #[test]\n fn test_optflag_long() {\n-    let args = [\"--test\"];\n-    let opts = [opt::optflag(\"test\")];\n+    let args = [~\"--test\"];\n+    let opts = [opt::optflag(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n-      opt::success(m) { assert (opt::opt_present(m, \"test\")); }\n+      opt::success(m) { assert (opt::opt_present(m, ~\"test\")); }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_optflag_long_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::optflag(\"test\")];\n+    let args = [~\"blah\"];\n+    let opts = [opt::optflag(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n-      opt::success(m) { assert (!opt::opt_present(m, \"test\")); }\n+      opt::success(m) { assert (!opt::opt_present(m, ~\"test\")); }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_optflag_long_arg() {\n-    let args = [\"--test=20\"];\n-    let opts = [opt::optflag(\"test\")];\n+    let args = [~\"--test=20\"];\n+    let opts = [opt::optflag(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) {\n@@ -255,8 +255,8 @@ fn test_optflag_long_arg() {\n \n #[test]\n fn test_optflag_long_multi() {\n-    let args = [\"--test\", \"--test\"];\n-    let opts = [opt::optflag(\"test\")];\n+    let args = [~\"--test\", ~\"--test\"];\n+    let opts = [opt::optflag(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, option_duplicated); }\n@@ -266,45 +266,45 @@ fn test_optflag_long_multi() {\n \n #[test]\n fn test_optflag_short() {\n-    let args = [\"-t\"];\n-    let opts = [opt::optflag(\"t\")];\n+    let args = [~\"-t\"];\n+    let opts = [opt::optflag(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n-      opt::success(m) { assert (opt::opt_present(m, \"t\")); }\n+      opt::success(m) { assert (opt::opt_present(m, ~\"t\")); }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_optflag_short_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::optflag(\"t\")];\n+    let args = [~\"blah\"];\n+    let opts = [opt::optflag(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n-      opt::success(m) { assert (!opt::opt_present(m, \"t\")); }\n+      opt::success(m) { assert (!opt::opt_present(m, ~\"t\")); }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_optflag_short_arg() {\n-    let args = [\"-t\", \"20\"];\n-    let opts = [opt::optflag(\"t\")];\n+    let args = [~\"-t\", ~\"20\"];\n+    let opts = [opt::optflag(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::success(m) {\n         // The next variable after the flag is just a free argument\n \n-        assert (m.free[0] == \"20\");\n+        assert (m.free[0] == ~\"20\");\n       }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_optflag_short_multi() {\n-    let args = [\"-t\", \"-t\"];\n-    let opts = [opt::optflag(\"t\")];\n+    let args = [~\"-t\", ~\"-t\"];\n+    let opts = [opt::optflag(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, option_duplicated); }\n@@ -316,33 +316,33 @@ fn test_optflag_short_multi() {\n // Tests for optmulti\n #[test]\n fn test_optmulti_long() {\n-    let args = [\"--test=20\"];\n-    let opts = [opt::optmulti(\"test\")];\n+    let args = [~\"--test=20\"];\n+    let opts = [opt::optmulti(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::success(m) {\n-        assert (opt::opt_present(m, \"test\"));\n-        assert (opt::opt_str(m, \"test\") == \"20\");\n+        assert (opt::opt_present(m, ~\"test\"));\n+        assert (opt::opt_str(m, ~\"test\") == ~\"20\");\n       }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_optmulti_long_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::optmulti(\"test\")];\n+    let args = [~\"blah\"];\n+    let opts = [opt::optmulti(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n-      opt::success(m) { assert (!opt::opt_present(m, \"test\")); }\n+      opt::success(m) { assert (!opt::opt_present(m, ~\"test\")); }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_optmulti_long_no_arg() {\n-    let args = [\"--test\"];\n-    let opts = [opt::optmulti(\"test\")];\n+    let args = [~\"--test\"];\n+    let opts = [opt::optmulti(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, argument_missing); }\n@@ -352,49 +352,49 @@ fn test_optmulti_long_no_arg() {\n \n #[test]\n fn test_optmulti_long_multi() {\n-    let args = [\"--test=20\", \"--test=30\"];\n-    let opts = [opt::optmulti(\"test\")];\n+    let args = [~\"--test=20\", ~\"--test=30\"];\n+    let opts = [opt::optmulti(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::success(m) {\n-        assert (opt::opt_present(m, \"test\"));\n-        assert (opt::opt_str(m, \"test\") == \"20\");\n-        assert (opt::opt_strs(m, \"test\")[0] == \"20\");\n-        assert (opt::opt_strs(m, \"test\")[1] == \"30\");\n+        assert (opt::opt_present(m, ~\"test\"));\n+        assert (opt::opt_str(m, ~\"test\") == ~\"20\");\n+        assert (opt::opt_strs(m, ~\"test\")[0] == ~\"20\");\n+        assert (opt::opt_strs(m, ~\"test\")[1] == ~\"30\");\n       }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_optmulti_short() {\n-    let args = [\"-t\", \"20\"];\n-    let opts = [opt::optmulti(\"t\")];\n+    let args = [~\"-t\", ~\"20\"];\n+    let opts = [opt::optmulti(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::success(m) {\n-        assert (opt::opt_present(m, \"t\"));\n-        assert (opt::opt_str(m, \"t\") == \"20\");\n+        assert (opt::opt_present(m, ~\"t\"));\n+        assert (opt::opt_str(m, ~\"t\") == ~\"20\");\n       }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_optmulti_short_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::optmulti(\"t\")];\n+    let args = [~\"blah\"];\n+    let opts = [opt::optmulti(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n-      opt::success(m) { assert (!opt::opt_present(m, \"t\")); }\n+      opt::success(m) { assert (!opt::opt_present(m, ~\"t\")); }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_optmulti_short_no_arg() {\n-    let args = [\"-t\"];\n-    let opts = [opt::optmulti(\"t\")];\n+    let args = [~\"-t\"];\n+    let opts = [opt::optmulti(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, argument_missing); }\n@@ -404,24 +404,24 @@ fn test_optmulti_short_no_arg() {\n \n #[test]\n fn test_optmulti_short_multi() {\n-    let args = [\"-t\", \"20\", \"-t\", \"30\"];\n-    let opts = [opt::optmulti(\"t\")];\n+    let args = [~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n+    let opts = [opt::optmulti(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::success(m) {\n-        assert (opt::opt_present(m, \"t\"));\n-        assert (opt::opt_str(m, \"t\") == \"20\");\n-        assert (opt::opt_strs(m, \"t\")[0] == \"20\");\n-        assert (opt::opt_strs(m, \"t\")[1] == \"30\");\n+        assert (opt::opt_present(m, ~\"t\"));\n+        assert (opt::opt_str(m, ~\"t\") == ~\"20\");\n+        assert (opt::opt_strs(m, ~\"t\")[0] == ~\"20\");\n+        assert (opt::opt_strs(m, ~\"t\")[1] == ~\"30\");\n       }\n       _ { fail; }\n     }\n }\n \n #[test]\n fn test_unrecognized_option_long() {\n-    let args = [\"--untest\"];\n-    let opts = [opt::optmulti(\"t\")];\n+    let args = [~\"--untest\"];\n+    let opts = [opt::optmulti(~\"t\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, unrecognized_option); }\n@@ -431,8 +431,8 @@ fn test_unrecognized_option_long() {\n \n #[test]\n fn test_unrecognized_option_short() {\n-    let args = [\"-t\"];\n-    let opts = [opt::optmulti(\"test\")];\n+    let args = [~\"-t\"];\n+    let opts = [opt::optmulti(~\"test\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::failure(f) { check_fail_type(f, unrecognized_option); }\n@@ -443,24 +443,25 @@ fn test_unrecognized_option_short() {\n #[test]\n fn test_combined() {\n     let args =\n-        [\"prog\", \"free1\", \"-s\", \"20\", \"free2\", \"--flag\", \"--long=30\", \"-f\",\n-         \"-m\", \"40\", \"-m\", \"50\"];\n+        [~\"prog\", ~\"free1\", ~\"-s\", ~\"20\", ~\"free2\", ~\"--flag\",\n+         ~\"--long=30\", ~\"-f\", ~\"-m\", ~\"40\", ~\"-m\", ~\"50\"];\n     let opts =\n-        [opt::optopt(\"s\"), opt::optflag(\"flag\"), opt::reqopt(\"long\"),\n-         opt::optflag(\"f\"), opt::optmulti(\"m\"), opt::optopt(\"notpresent\")];\n+        [opt::optopt(~\"s\"), opt::optflag(~\"flag\"), opt::reqopt(~\"long\"),\n+         opt::optflag(~\"f\"), opt::optmulti(~\"m\"),\n+         opt::optopt(~\"notpresent\")];\n     let rs = opt::getopts(args, opts);\n     alt rs {\n       opt::success(m) {\n-        assert (m.free[0] == \"prog\");\n-        assert (m.free[1] == \"free1\");\n-        assert (opt::opt_str(m, \"s\") == \"20\");\n-        assert (m.free[2] == \"free2\");\n-        assert (opt::opt_present(m, \"flag\"));\n-        assert (opt::opt_str(m, \"long\") == \"30\");\n-        assert (opt::opt_present(m, \"f\"));\n-        assert (opt::opt_strs(m, \"m\")[0] == \"40\");\n-        assert (opt::opt_strs(m, \"m\")[1] == \"50\");\n-        assert (!opt::opt_present(m, \"notpresent\"));\n+        assert (m.free[0] == ~\"prog\");\n+        assert (m.free[1] == ~\"free1\");\n+        assert (opt::opt_str(m, ~\"s\") == ~\"20\");\n+        assert (m.free[2] == ~\"free2\");\n+        assert (opt::opt_present(m, ~\"flag\"));\n+        assert (opt::opt_str(m, ~\"long\") == ~\"30\");\n+        assert (opt::opt_present(m, ~\"f\"));\n+        assert (opt::opt_strs(m, ~\"m\")[0] == ~\"40\");\n+        assert (opt::opt_strs(m, ~\"m\")[1] == ~\"50\");\n+        assert (!opt::opt_present(m, ~\"notpresent\"));\n       }\n       _ { fail; }\n     }"}]}