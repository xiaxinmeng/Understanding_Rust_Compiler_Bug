{"sha": "651c42f11f6870dd2c23a1b33fed9ddefd043b76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MWM0MmYxMWY2ODcwZGQyYzIzYTFiMzNmZWQ5ZGRlZmQwNDNiNzY=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-08-24T04:59:07Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-08-27T06:23:57Z"}, "message": "Make iter::order functions into methods on Iterator\n\nThis does cause some breakage due to deficiencies in resolve -\n`path::Components` is both an `Iterator` and implements `Eq`, `Ord`,\netc. If one calls e.g. `partial_cmp` on a `Components` and passes a\n`&Components` intending to target the `PartialOrd` impl, the compiler\nwill select the `partial_cmp` from `Iterator` and then error out. I\ndoubt anyone will run into breakage from `Components` specifically, but\nwe should see if there are third party types that will run into issues.\n\n`iter::order::equals` wasn't moved to `Iterator` since it's exactly the\nsame as `iter::order::eq` but with an `Eq` instead of `PartialEq` bound,\nwhich doensn't seem very useful.\n\nI also updated `le`, `gt`, etc to use `partial_cmp` which lets us drop\nthe extra `PartialEq` bound.\n\ncc #27737", "tree": {"sha": "80884384f083c5f4118068944d3168bf86ae0a0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80884384f083c5f4118068944d3168bf86ae0a0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/651c42f11f6870dd2c23a1b33fed9ddefd043b76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/651c42f11f6870dd2c23a1b33fed9ddefd043b76", "html_url": "https://github.com/rust-lang/rust/commit/651c42f11f6870dd2c23a1b33fed9ddefd043b76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/651c42f11f6870dd2c23a1b33fed9ddefd043b76/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63ba780fd7ab506bfd0f92d34a39172b412cfbe1", "url": "https://api.github.com/repos/rust-lang/rust/commits/63ba780fd7ab506bfd0f92d34a39172b412cfbe1", "html_url": "https://github.com/rust-lang/rust/commit/63ba780fd7ab506bfd0f92d34a39172b412cfbe1"}], "stats": {"total": 353, "additions": 238, "deletions": 115}, "files": [{"sha": "11d389d85bad9e89092267e1e69404a6464edf86", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/651c42f11f6870dd2c23a1b33fed9ddefd043b76/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651c42f11f6870dd2c23a1b33fed9ddefd043b76/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=651c42f11f6870dd2c23a1b33fed9ddefd043b76", "patch": "@@ -22,7 +22,7 @@ use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{Map, FromIterator};\n use core::ops::Index;\n-use core::{iter, fmt, mem, usize};\n+use core::{fmt, mem, usize};\n use Bound::{self, Included, Excluded, Unbounded};\n \n use borrow::Borrow;\n@@ -915,15 +915,15 @@ impl<K: Eq, V: Eq> Eq for BTreeMap<K, V> {}\n impl<K: PartialOrd, V: PartialOrd> PartialOrd for BTreeMap<K, V> {\n     #[inline]\n     fn partial_cmp(&self, other: &BTreeMap<K, V>) -> Option<Ordering> {\n-        iter::order::partial_cmp(self.iter(), other.iter())\n+        self.iter().partial_cmp(other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n     #[inline]\n     fn cmp(&self, other: &BTreeMap<K, V>) -> Ordering {\n-        iter::order::cmp(self.iter(), other.iter())\n+        self.iter().cmp(other.iter())\n     }\n }\n "}, {"sha": "891e8b7b2c961c35aebb7083047d722cf3d86c5e", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/651c42f11f6870dd2c23a1b33fed9ddefd043b76/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651c42f11f6870dd2c23a1b33fed9ddefd043b76/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=651c42f11f6870dd2c23a1b33fed9ddefd043b76", "patch": "@@ -25,7 +25,7 @@ use alloc::boxed::Box;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n-use core::iter::{self, FromIterator};\n+use core::iter::FromIterator;\n use core::mem;\n use core::ptr;\n \n@@ -917,12 +917,12 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for LinkedList<T> {\n impl<A: PartialEq> PartialEq for LinkedList<A> {\n     fn eq(&self, other: &LinkedList<A>) -> bool {\n         self.len() == other.len() &&\n-            iter::order::eq(self.iter(), other.iter())\n+            self.iter().eq(other.iter())\n     }\n \n     fn ne(&self, other: &LinkedList<A>) -> bool {\n         self.len() != other.len() ||\n-            iter::order::ne(self.iter(), other.iter())\n+            self.iter().ne(other.iter())\n     }\n }\n \n@@ -932,15 +932,15 @@ impl<A: Eq> Eq for LinkedList<A> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialOrd> PartialOrd for LinkedList<A> {\n     fn partial_cmp(&self, other: &LinkedList<A>) -> Option<Ordering> {\n-        iter::order::partial_cmp(self.iter(), other.iter())\n+        self.iter().partial_cmp(other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Ord> Ord for LinkedList<A> {\n     #[inline]\n     fn cmp(&self, other: &LinkedList<A>) -> Ordering {\n-        iter::order::cmp(self.iter(), other.iter())\n+        self.iter().cmp(other.iter())\n     }\n }\n "}, {"sha": "79e8988679184912367057614b6da283b4486cea", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/651c42f11f6870dd2c23a1b33fed9ddefd043b76/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651c42f11f6870dd2c23a1b33fed9ddefd043b76/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=651c42f11f6870dd2c23a1b33fed9ddefd043b76", "patch": "@@ -20,7 +20,7 @@\n \n use core::cmp::Ordering;\n use core::fmt;\n-use core::iter::{self, repeat, FromIterator};\n+use core::iter::{repeat, FromIterator};\n use core::ops::{Index, IndexMut};\n use core::ptr;\n use core::slice;\n@@ -1676,15 +1676,15 @@ impl<A: Eq> Eq for VecDeque<A> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialOrd> PartialOrd for VecDeque<A> {\n     fn partial_cmp(&self, other: &VecDeque<A>) -> Option<Ordering> {\n-        iter::order::partial_cmp(self.iter(), other.iter())\n+        self.iter().partial_cmp(other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Ord> Ord for VecDeque<A> {\n     #[inline]\n     fn cmp(&self, other: &VecDeque<A>) -> Ordering {\n-        iter::order::cmp(self.iter(), other.iter())\n+        self.iter().cmp(other.iter())\n     }\n }\n "}, {"sha": "b54d8fceffdbfeb1ce13c3f959174e76601dff69", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 212, "deletions": 87, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/651c42f11f6870dd2c23a1b33fed9ddefd043b76/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651c42f11f6870dd2c23a1b33fed9ddefd043b76/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=651c42f11f6870dd2c23a1b33fed9ddefd043b76", "patch": "@@ -58,7 +58,7 @@\n \n use clone::Clone;\n use cmp;\n-use cmp::{Ord, PartialOrd, PartialEq};\n+use cmp::{Ord, PartialOrd, PartialEq, Ordering};\n use default::Default;\n use marker;\n use mem;\n@@ -1005,6 +1005,198 @@ pub trait Iterator {\n     {\n         self.fold(One::one(), |p, e| p * e)\n     }\n+\n+    /// Lexicographically compares the elements of this `Iterator` with those\n+    /// of another.\n+    #[unstable(feature = \"iter_order\", reason = \"needs review and revision\", issue = \"27737\")]\n+    fn cmp<I>(mut self, other: I) -> Ordering where\n+        I: IntoIterator<Item = Self::Item>,\n+        Self::Item: Ord,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return Ordering::Equal,\n+                (None, _   ) => return Ordering::Less,\n+                (_   , None) => return Ordering::Greater,\n+                (Some(x), Some(y)) => match x.cmp(&y) {\n+                    Ordering::Equal => (),\n+                    non_eq => return non_eq,\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Lexicographically compares the elements of this `Iterator` with those\n+    /// of another.\n+    #[unstable(feature = \"iter_order\", reason = \"needs review and revision\", issue = \"27737\")]\n+    fn partial_cmp<I>(mut self, other: I) -> Option<Ordering> where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return Some(Ordering::Equal),\n+                (None, _   ) => return Some(Ordering::Less),\n+                (_   , None) => return Some(Ordering::Greater),\n+                (Some(x), Some(y)) => match x.partial_cmp(&y) {\n+                    Some(Ordering::Equal) => (),\n+                    non_eq => return non_eq,\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are equal to those of\n+    /// another.\n+    #[unstable(feature = \"iter_order\", reason = \"needs review and revision\", issue = \"27737\")]\n+    fn eq<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialEq<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return true,\n+                (None, _) | (_, None) => return false,\n+                (Some(x), Some(y)) => if x != y { return false },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are unequal to those of\n+    /// another.\n+    #[unstable(feature = \"iter_order\", reason = \"needs review and revision\", issue = \"27737\")]\n+    fn ne<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialEq<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return false,\n+                (None, _) | (_, None) => return true,\n+                (Some(x), Some(y)) => if x.ne(&y) { return true },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are lexicographically\n+    /// less than those of another.\n+    #[unstable(feature = \"iter_order\", reason = \"needs review and revision\", issue = \"27737\")]\n+    fn lt<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return false,\n+                (None, _   ) => return true,\n+                (_   , None) => return false,\n+                (Some(x), Some(y)) => {\n+                    match x.partial_cmp(&y) {\n+                        Some(Ordering::Less) => return true,\n+                        Some(Ordering::Equal) => {}\n+                        Some(Ordering::Greater) => return false,\n+                        None => return false,\n+                    }\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are lexicographically\n+    /// less or equal to those of another.\n+    #[unstable(feature = \"iter_order\", reason = \"needs review and revision\", issue = \"27737\")]\n+    fn le<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return true,\n+                (None, _   ) => return true,\n+                (_   , None) => return false,\n+                (Some(x), Some(y)) => {\n+                    match x.partial_cmp(&y) {\n+                        Some(Ordering::Less) => return true,\n+                        Some(Ordering::Equal) => {}\n+                        Some(Ordering::Greater) => return false,\n+                        None => return false,\n+                    }\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are lexicographically\n+    /// greater than those of another.\n+    #[unstable(feature = \"iter_order\", reason = \"needs review and revision\", issue = \"27737\")]\n+    fn gt<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return false,\n+                (None, _   ) => return false,\n+                (_   , None) => return true,\n+                (Some(x), Some(y)) => {\n+                    match x.partial_cmp(&y) {\n+                        Some(Ordering::Less) => return false,\n+                        Some(Ordering::Equal) => {}\n+                        Some(Ordering::Greater) => return true,\n+                        None => return false,\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are lexicographically\n+    /// greater than or equal to those of another.\n+    #[unstable(feature = \"iter_order\", reason = \"needs review and revision\", issue = \"27737\")]\n+    fn ge<I>(mut self, other: I) -> bool where\n+        I: IntoIterator,\n+        Self::Item: PartialOrd<I::Item>,\n+        Self: Sized,\n+    {\n+        let mut other = other.into_iter();\n+\n+        loop {\n+            match (self.next(), other.next()) {\n+                (None, None) => return true,\n+                (None, _   ) => return false,\n+                (_   , None) => return true,\n+                (Some(x), Some(y)) => {\n+                    match x.partial_cmp(&y) {\n+                        Some(Ordering::Less) => return false,\n+                        Some(Ordering::Equal) => {}\n+                        Some(Ordering::Greater) => return true,\n+                        None => return false,\n+                    }\n+                },\n+            }\n+        }\n+    }\n }\n \n /// Select an element from an iterator based on the given projection\n@@ -2654,146 +2846,79 @@ pub fn once<T>(value: T) -> Once<T> {\n ///\n /// If two sequences are equal up until the point where one ends,\n /// the shorter sequence compares less.\n+#[deprecated(since = \"1.4.0\", reason = \"use the equivalent methods on `Iterator` instead\")]\n #[unstable(feature = \"iter_order\", reason = \"needs review and revision\",\n            issue = \"27737\")]\n pub mod order {\n     use cmp;\n     use cmp::{Eq, Ord, PartialOrd, PartialEq};\n-    use cmp::Ordering::{Equal, Less, Greater};\n     use option::Option;\n-    use option::Option::{Some, None};\n     use super::Iterator;\n \n     /// Compare `a` and `b` for equality using `Eq`\n-    pub fn equals<A, L, R>(mut a: L, mut b: R) -> bool where\n+    pub fn equals<A, L, R>(a: L, b: R) -> bool where\n         A: Eq,\n         L: Iterator<Item=A>,\n         R: Iterator<Item=A>,\n     {\n-        loop {\n-            match (a.next(), b.next()) {\n-                (None, None) => return true,\n-                (None, _) | (_, None) => return false,\n-                (Some(x), Some(y)) => if x != y { return false },\n-            }\n-        }\n+        a.eq(b)\n     }\n \n     /// Order `a` and `b` lexicographically using `Ord`\n-    pub fn cmp<A, L, R>(mut a: L, mut b: R) -> cmp::Ordering where\n+    pub fn cmp<A, L, R>(a: L, b: R) -> cmp::Ordering where\n         A: Ord,\n         L: Iterator<Item=A>,\n         R: Iterator<Item=A>,\n     {\n-        loop {\n-            match (a.next(), b.next()) {\n-                (None, None) => return Equal,\n-                (None, _   ) => return Less,\n-                (_   , None) => return Greater,\n-                (Some(x), Some(y)) => match x.cmp(&y) {\n-                    Equal => (),\n-                    non_eq => return non_eq,\n-                },\n-            }\n-        }\n+        a.cmp(b)\n     }\n \n     /// Order `a` and `b` lexicographically using `PartialOrd`\n-    pub fn partial_cmp<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> Option<cmp::Ordering> where\n+    pub fn partial_cmp<L: Iterator, R: Iterator>(a: L, b: R) -> Option<cmp::Ordering> where\n         L::Item: PartialOrd<R::Item>\n     {\n-        loop {\n-            match (a.next(), b.next()) {\n-                (None, None) => return Some(Equal),\n-                (None, _   ) => return Some(Less),\n-                (_   , None) => return Some(Greater),\n-                (Some(x), Some(y)) => match x.partial_cmp(&y) {\n-                    Some(Equal) => (),\n-                    non_eq => return non_eq,\n-                },\n-            }\n-        }\n+        a.partial_cmp(b)\n     }\n \n     /// Compare `a` and `b` for equality (Using partial equality, `PartialEq`)\n-    pub fn eq<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where\n+    pub fn eq<L: Iterator, R: Iterator>(a: L, b: R) -> bool where\n         L::Item: PartialEq<R::Item>,\n     {\n-        loop {\n-            match (a.next(), b.next()) {\n-                (None, None) => return true,\n-                (None, _) | (_, None) => return false,\n-                (Some(x), Some(y)) => if !x.eq(&y) { return false },\n-            }\n-        }\n+        a.eq(b)\n     }\n \n     /// Compares `a` and `b` for nonequality (Using partial equality, `PartialEq`)\n-    pub fn ne<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where\n+    pub fn ne<L: Iterator, R: Iterator>(a: L, b: R) -> bool where\n         L::Item: PartialEq<R::Item>,\n     {\n-        loop {\n-            match (a.next(), b.next()) {\n-                (None, None) => return false,\n-                (None, _) | (_, None) => return true,\n-                (Some(x), Some(y)) => if x.ne(&y) { return true },\n-            }\n-        }\n+        a.ne(b)\n     }\n \n     /// Returns `a` < `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn lt<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where\n+    pub fn lt<L: Iterator, R: Iterator>(a: L, b: R) -> bool where\n         L::Item: PartialOrd<R::Item>,\n     {\n-        loop {\n-            match (a.next(), b.next()) {\n-                (None, None) => return false,\n-                (None, _   ) => return true,\n-                (_   , None) => return false,\n-                (Some(x), Some(y)) => if x.ne(&y) { return x.lt(&y) },\n-            }\n-        }\n+        a.lt(b)\n     }\n \n     /// Returns `a` <= `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn le<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where\n+    pub fn le<L: Iterator, R: Iterator>(a: L, b: R) -> bool where\n         L::Item: PartialOrd<R::Item>,\n     {\n-        loop {\n-            match (a.next(), b.next()) {\n-                (None, None) => return true,\n-                (None, _   ) => return true,\n-                (_   , None) => return false,\n-                (Some(x), Some(y)) => if x.ne(&y) { return x.le(&y) },\n-            }\n-        }\n+        a.le(b)\n     }\n \n     /// Returns `a` > `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn gt<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where\n+    pub fn gt<L: Iterator, R: Iterator>(a: L, b: R) -> bool where\n         L::Item: PartialOrd<R::Item>,\n     {\n-        loop {\n-            match (a.next(), b.next()) {\n-                (None, None) => return false,\n-                (None, _   ) => return false,\n-                (_   , None) => return true,\n-                (Some(x), Some(y)) => if x.ne(&y) { return x.gt(&y) },\n-            }\n-        }\n+        a.gt(b)\n     }\n \n     /// Returns `a` >= `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn ge<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where\n+    pub fn ge<L: Iterator, R: Iterator>(a: L, b: R) -> bool where\n         L::Item: PartialOrd<R::Item>,\n     {\n-        loop {\n-            match (a.next(), b.next()) {\n-                (None, None) => return true,\n-                (None, _   ) => return false,\n-                (_   , None) => return true,\n-                (Some(x), Some(y)) => if x.ne(&y) { return x.ge(&y) },\n-            }\n-        }\n+        a.ge(b)\n     }\n }"}, {"sha": "ee2ffbffab6542597d69558f0c3cdefd4087d926", "filename": "src/libcore/num/flt2dec/bignum.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/651c42f11f6870dd2c23a1b33fed9ddefd043b76/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651c42f11f6870dd2c23a1b33fed9ddefd043b76/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs?ref=651c42f11f6870dd2c23a1b33fed9ddefd043b76", "patch": "@@ -448,12 +448,10 @@ macro_rules! define_bignum {\n         impl ::cmp::Ord for $name {\n             fn cmp(&self, other: &$name) -> ::cmp::Ordering {\n                 use cmp::max;\n-                use iter::order;\n-\n                 let sz = max(self.size, other.size);\n                 let lhs = self.base[..sz].iter().cloned().rev();\n                 let rhs = other.base[..sz].iter().cloned().rev();\n-                order::cmp(lhs, rhs)\n+                lhs.cmp(rhs)\n             }\n         }\n "}, {"sha": "fdd5e61c8f27be61fe69b50ed279efc7f5c34ff1", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/651c42f11f6870dd2c23a1b33fed9ddefd043b76/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651c42f11f6870dd2c23a1b33fed9ddefd043b76/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=651c42f11f6870dd2c23a1b33fed9ddefd043b76", "patch": "@@ -1557,30 +1557,30 @@ impl<T: Eq> Eq for [T] {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for [T] {\n     fn cmp(&self, other: &[T]) -> Ordering {\n-        order::cmp(self.iter(), other.iter())\n+        self.iter().cmp(other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for [T] {\n     #[inline]\n     fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n-        order::partial_cmp(self.iter(), other.iter())\n+        self.iter().partial_cmp(other.iter())\n     }\n     #[inline]\n     fn lt(&self, other: &[T]) -> bool {\n-        order::lt(self.iter(), other.iter())\n+        self.iter().lt(other.iter())\n     }\n     #[inline]\n     fn le(&self, other: &[T]) -> bool {\n-        order::le(self.iter(), other.iter())\n+        self.iter().le(other.iter())\n     }\n     #[inline]\n     fn ge(&self, other: &[T]) -> bool {\n-        order::ge(self.iter(), other.iter())\n+        self.iter().ge(other.iter())\n     }\n     #[inline]\n     fn gt(&self, other: &[T]) -> bool {\n-        order::gt(self.iter(), other.iter())\n+        self.iter().gt(other.iter())\n     }\n }"}, {"sha": "3ee4ce80bd53596fdffe1cf390d01550ca565151", "filename": "src/libstd/path.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/651c42f11f6870dd2c23a1b33fed9ddefd043b76/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651c42f11f6870dd2c23a1b33fed9ddefd043b76/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=651c42f11f6870dd2c23a1b33fed9ddefd043b76", "patch": "@@ -882,7 +882,7 @@ impl<'a> DoubleEndedIterator for Components<'a> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::PartialEq for Components<'a> {\n     fn eq(&self, other: &Components<'a>) -> bool {\n-        iter::order::eq(self.clone(), other.clone())\n+        Iterator::eq(self.clone(), other.clone())\n     }\n }\n \n@@ -892,14 +892,14 @@ impl<'a> cmp::Eq for Components<'a> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::PartialOrd for Components<'a> {\n     fn partial_cmp(&self, other: &Components<'a>) -> Option<cmp::Ordering> {\n-        iter::order::partial_cmp(self.clone(), other.clone())\n+        Iterator::partial_cmp(self.clone(), other.clone())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> cmp::Ord for Components<'a> {\n     fn cmp(&self, other: &Components<'a>) -> cmp::Ordering {\n-        iter::order::cmp(self.clone(), other.clone())\n+        Iterator::cmp(self.clone(), other.clone())\n     }\n }\n \n@@ -1162,14 +1162,14 @@ impl cmp::Eq for PathBuf {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialOrd for PathBuf {\n     fn partial_cmp(&self, other: &PathBuf) -> Option<cmp::Ordering> {\n-        self.components().partial_cmp(&other.components())\n+        self.components().partial_cmp(other.components())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Ord for PathBuf {\n     fn cmp(&self, other: &PathBuf) -> cmp::Ordering {\n-        self.components().cmp(&other.components())\n+        self.components().cmp(other.components())\n     }\n }\n \n@@ -1691,7 +1691,7 @@ impl<'a> fmt::Display for Display<'a> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialEq for Path {\n     fn eq(&self, other: &Path) -> bool {\n-        iter::order::eq(self.components(), other.components())\n+        self.components().eq(other.components())\n     }\n }\n \n@@ -1701,14 +1701,14 @@ impl cmp::Eq for Path {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialOrd for Path {\n     fn partial_cmp(&self, other: &Path) -> Option<cmp::Ordering> {\n-        self.components().partial_cmp(&other.components())\n+        self.components().partial_cmp(other.components())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::Ord for Path {\n     fn cmp(&self, other: &Path) -> cmp::Ordering {\n-        self.components().cmp(&other.components())\n+        self.components().cmp(other.components())\n     }\n }\n "}]}