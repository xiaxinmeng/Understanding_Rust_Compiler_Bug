{"sha": "7a82d478a3c9301eda4453ec222842f750e13630", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhODJkNDc4YTNjOTMwMWVkYTQ0NTNlYzIyMjg0MmY3NTBlMTM2MzA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-11T21:34:21Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-11T22:12:56Z"}, "message": "std: Fix iteration over vectors of 0-size values\n\nPreviously, all slices derived from a vector whose values were of size 0 had a\nnull pointer as the 'data' pointer on the slice. This caused first pointer to be\nyielded during iteration to always be the null pointer. Due to the null pointer\noptimization, this meant that the first return value was None, instead of\nSome(&T).\n\nThis commit changes slice construction from a Vec instance to use a base pointer\nof 1 if the values have zero size. This means that the iterator will never\nreturn null, and the iteration will proceed appropriately.\n\nCloses #13467", "tree": {"sha": "87675327dc77a289bfd699c5c12f546804fa56d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87675327dc77a289bfd699c5c12f546804fa56d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a82d478a3c9301eda4453ec222842f750e13630", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a82d478a3c9301eda4453ec222842f750e13630", "html_url": "https://github.com/rust-lang/rust/commit/7a82d478a3c9301eda4453ec222842f750e13630", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a82d478a3c9301eda4453ec222842f750e13630/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b6091e8f1f5531fe907f84b6a2b27af04a95e8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b6091e8f1f5531fe907f84b6a2b27af04a95e8f", "html_url": "https://github.com/rust-lang/rust/commit/8b6091e8f1f5531fe907f84b6a2b27af04a95e8f"}], "stats": {"total": 48, "additions": 46, "deletions": 2}, "files": [{"sha": "a69120de00f7d6dfc60c3660074c1d08143490aa", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7a82d478a3c9301eda4453ec222842f750e13630/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a82d478a3c9301eda4453ec222842f750e13630/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=7a82d478a3c9301eda4453ec222842f750e13630", "patch": "@@ -598,7 +598,12 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        let slice = Slice { data: self.ptr as *T, len: self.len };\n+        // See the comment in as_slice() for what's going on here.\n+        let slice = if mem::size_of::<T>() == 0 {\n+            Slice { data: 1 as *T, len: self.len }\n+        } else {\n+            Slice { data: self.ptr as *T, len: self.len }\n+        };\n         unsafe { transmute(slice) }\n     }\n \n@@ -1335,7 +1340,15 @@ impl<T> Vector<T> for Vec<T> {\n     /// ```\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n-        let slice = Slice { data: self.ptr as *T, len: self.len };\n+        // If we have a 0-sized vector, then the base pointer should not be NULL\n+        // because an iterator over the slice will attempt to yield the base\n+        // pointer as the first element in the vector, but this will end up\n+        // being Some(NULL) which is optimized to None.\n+        let slice = if mem::size_of::<T>() == 0 {\n+            Slice { data: 1 as *T, len: self.len }\n+        } else {\n+            Slice { data: self.ptr as *T, len: self.len }\n+        };\n         unsafe { transmute(slice) }\n     }\n }\n@@ -1588,4 +1601,35 @@ mod tests {\n         vec.retain(|x| x%2 == 0);\n         assert!(vec == Vec::from_slice([2u, 4]));\n     }\n+\n+    #[test]\n+    fn zero_sized_values() {\n+        let mut v = Vec::new();\n+        assert_eq!(v.len(), 0);\n+        v.push(());\n+        assert_eq!(v.len(), 1);\n+        v.push(());\n+        assert_eq!(v.len(), 2);\n+        assert_eq!(v.pop(), Some(()));\n+        assert_eq!(v.pop(), Some(()));\n+        assert_eq!(v.pop(), None);\n+\n+        assert_eq!(v.iter().len(), 0);\n+        v.push(());\n+        assert_eq!(v.iter().len(), 1);\n+        v.push(());\n+        assert_eq!(v.iter().len(), 2);\n+\n+        for &() in v.iter() {}\n+\n+        assert_eq!(v.mut_iter().len(), 2);\n+        v.push(());\n+        assert_eq!(v.mut_iter().len(), 3);\n+        v.push(());\n+        assert_eq!(v.mut_iter().len(), 4);\n+\n+        for &() in v.mut_iter() {}\n+        unsafe { v.set_len(0); }\n+        assert_eq!(v.mut_iter().len(), 0);\n+    }\n }"}]}