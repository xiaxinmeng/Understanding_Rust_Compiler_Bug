{"sha": "fe8955bd585b8e49b01697684becb6a353413fea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlODk1NWJkNTg1YjhlNDliMDE2OTc2ODRiZWNiNmEzNTM0MTNmZWE=", "commit": {"author": {"name": "csmoe", "email": "35686186+csmoe@users.noreply.github.com", "date": "2018-07-11T10:44:53Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-16T13:09:16Z"}, "message": "BinOpKind", "tree": {"sha": "54d04732e108f2914a4df20d3a29645df9261e9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54d04732e108f2914a4df20d3a29645df9261e9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe8955bd585b8e49b01697684becb6a353413fea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe8955bd585b8e49b01697684becb6a353413fea", "html_url": "https://github.com/rust-lang/rust/commit/fe8955bd585b8e49b01697684becb6a353413fea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe8955bd585b8e49b01697684becb6a353413fea/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d5753fda1ee8f729da1061e931e13b043f479a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d5753fda1ee8f729da1061e931e13b043f479a5", "html_url": "https://github.com/rust-lang/rust/commit/3d5753fda1ee8f729da1061e931e13b043f479a5"}], "stats": {"total": 590, "additions": 297, "deletions": 293}, "files": [{"sha": "86f6e08215e5219fcd520e29862ba121ca5bb3b4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=fe8955bd585b8e49b01697684becb6a353413fea", "patch": "@@ -3314,24 +3314,24 @@ impl<'a> LoweringContext<'a> {\n     fn lower_binop(&mut self, b: BinOp) -> hir::BinOp {\n         Spanned {\n             node: match b.node {\n-                BinOpKind::Add => hir::BiAdd,\n-                BinOpKind::Sub => hir::BiSub,\n-                BinOpKind::Mul => hir::BiMul,\n-                BinOpKind::Div => hir::BiDiv,\n-                BinOpKind::Rem => hir::BiRem,\n-                BinOpKind::And => hir::BiAnd,\n-                BinOpKind::Or => hir::BiOr,\n-                BinOpKind::BitXor => hir::BiBitXor,\n-                BinOpKind::BitAnd => hir::BiBitAnd,\n-                BinOpKind::BitOr => hir::BiBitOr,\n-                BinOpKind::Shl => hir::BiShl,\n-                BinOpKind::Shr => hir::BiShr,\n-                BinOpKind::Eq => hir::BiEq,\n-                BinOpKind::Lt => hir::BiLt,\n-                BinOpKind::Le => hir::BiLe,\n-                BinOpKind::Ne => hir::BiNe,\n-                BinOpKind::Ge => hir::BiGe,\n-                BinOpKind::Gt => hir::BiGt,\n+                BinOpKind::Add => hir::BinOpKind::Add,\n+                BinOpKind::Sub => hir::BinOpKind::Sub,\n+                BinOpKind::Mul => hir::BinOpKind::Mul,\n+                BinOpKind::Div => hir::BinOpKind::Div,\n+                BinOpKind::Rem => hir::BinOpKind::Rem,\n+                BinOpKind::And => hir::BinOpKind::And,\n+                BinOpKind::Or => hir::BinOpKind::Or,\n+                BinOpKind::BitXor => hir::BinOpKind::BitXor,\n+                BinOpKind::BitAnd => hir::BinOpKind::BitAnd,\n+                BinOpKind::BitOr => hir::BinOpKind::BitOr,\n+                BinOpKind::Shl => hir::BinOpKind::Shl,\n+                BinOpKind::Shr => hir::BinOpKind::Shr,\n+                BinOpKind::Eq => hir::BinOpKind::Eq,\n+                BinOpKind::Lt => hir::BinOpKind::Lt,\n+                BinOpKind::Le => hir::BinOpKind::Le,\n+                BinOpKind::Ne => hir::BinOpKind::Ne,\n+                BinOpKind::Ge => hir::BinOpKind::Ge,\n+                BinOpKind::Gt => hir::BinOpKind::Gt,\n             },\n             span: b.span,\n         }"}, {"sha": "594fae972b17375f6e83d759a7230c001a0c2cbe", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 78, "deletions": 74, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=fe8955bd585b8e49b01697684becb6a353413fea", "patch": "@@ -10,7 +10,6 @@\n \n // The Rust HIR.\n \n-pub use self::BinOp_::*;\n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n pub use self::Decl_::*;\n@@ -941,98 +940,103 @@ impl Mutability {\n }\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash)]\n-pub enum BinOp_ {\n+pub enum BinOpKind {\n     /// The `+` operator (addition)\n-    BiAdd,\n+    Add,\n     /// The `-` operator (subtraction)\n-    BiSub,\n+    Sub,\n     /// The `*` operator (multiplication)\n-    BiMul,\n+    Mul,\n     /// The `/` operator (division)\n-    BiDiv,\n+    Div,\n     /// The `%` operator (modulus)\n-    BiRem,\n+    Rem,\n     /// The `&&` operator (logical and)\n-    BiAnd,\n+    And,\n     /// The `||` operator (logical or)\n-    BiOr,\n+    Or,\n     /// The `^` operator (bitwise xor)\n-    BiBitXor,\n+    BitXor,\n     /// The `&` operator (bitwise and)\n-    BiBitAnd,\n+    BitAnd,\n     /// The `|` operator (bitwise or)\n-    BiBitOr,\n+    BitOr,\n     /// The `<<` operator (shift left)\n-    BiShl,\n+    Shl,\n     /// The `>>` operator (shift right)\n-    BiShr,\n+    Shr,\n     /// The `==` operator (equality)\n-    BiEq,\n+    Eq,\n     /// The `<` operator (less than)\n-    BiLt,\n+    Lt,\n     /// The `<=` operator (less than or equal to)\n-    BiLe,\n+    Le,\n     /// The `!=` operator (not equal to)\n-    BiNe,\n+    Ne,\n     /// The `>=` operator (greater than or equal to)\n-    BiGe,\n+    Ge,\n     /// The `>` operator (greater than)\n-    BiGt,\n+    Gt,\n }\n \n-impl BinOp_ {\n+impl BinOpKind {\n     pub fn as_str(self) -> &'static str {\n         match self {\n-            BiAdd => \"+\",\n-            BiSub => \"-\",\n-            BiMul => \"*\",\n-            BiDiv => \"/\",\n-            BiRem => \"%\",\n-            BiAnd => \"&&\",\n-            BiOr => \"||\",\n-            BiBitXor => \"^\",\n-            BiBitAnd => \"&\",\n-            BiBitOr => \"|\",\n-            BiShl => \"<<\",\n-            BiShr => \">>\",\n-            BiEq => \"==\",\n-            BiLt => \"<\",\n-            BiLe => \"<=\",\n-            BiNe => \"!=\",\n-            BiGe => \">=\",\n-            BiGt => \">\",\n+            BinOpKind::Add => \"+\",\n+            BinOpKind::Sub => \"-\",\n+            BinOpKind::Mul => \"*\",\n+            BinOpKind::Div => \"/\",\n+            BinOpKind::Rem => \"%\",\n+            BinOpKind::And => \"&&\",\n+            BinOpKind::Or => \"||\",\n+            BinOpKind::BitXor => \"^\",\n+            BinOpKind::BitAnd => \"&\",\n+            BinOpKind::BitOr => \"|\",\n+            BinOpKind::Shl => \"<<\",\n+            BinOpKind::Shr => \">>\",\n+            BinOpKind::Eq => \"==\",\n+            BinOpKind::Lt => \"<\",\n+            BinOpKind::Le => \"<=\",\n+            BinOpKind::Ne => \"!=\",\n+            BinOpKind::Ge => \">=\",\n+            BinOpKind::Gt => \">\",\n         }\n     }\n \n     pub fn is_lazy(self) -> bool {\n         match self {\n-            BiAnd | BiOr => true,\n+            BinOpKind::And | BinOpKind::Or => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_shift(self) -> bool {\n         match self {\n-            BiShl | BiShr => true,\n+            BinOpKind::Shl | BinOpKind::Shr => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_comparison(self) -> bool {\n         match self {\n-            BiEq | BiLt | BiLe | BiNe | BiGt | BiGe => true,\n-            BiAnd |\n-            BiOr |\n-            BiAdd |\n-            BiSub |\n-            BiMul |\n-            BiDiv |\n-            BiRem |\n-            BiBitXor |\n-            BiBitAnd |\n-            BiBitOr |\n-            BiShl |\n-            BiShr => false,\n+            BinOpKind::Eq |\n+            BinOpKind::Lt |\n+            BinOpKind::Le |\n+            BinOpKind::Ne |\n+            BinOpKind::Gt |\n+            BinOpKind::Ge => true,\n+            BinOpKind::And |\n+            BinOpKind::Or |\n+            BinOpKind::Add |\n+            BinOpKind::Sub |\n+            BinOpKind::Mul |\n+            BinOpKind::Div |\n+            BinOpKind::Rem |\n+            BinOpKind::BitXor |\n+            BinOpKind::BitAnd |\n+            BinOpKind::BitOr |\n+            BinOpKind::Shl |\n+            BinOpKind::Shr => false,\n         }\n     }\n \n@@ -1042,32 +1046,32 @@ impl BinOp_ {\n     }\n }\n \n-impl Into<ast::BinOpKind> for BinOp_ {\n+impl Into<ast::BinOpKind> for BinOpKind {\n     fn into(self) -> ast::BinOpKind {\n         match self {\n-            BiAdd => ast::BinOpKind::Add,\n-            BiSub => ast::BinOpKind::Sub,\n-            BiMul => ast::BinOpKind::Mul,\n-            BiDiv => ast::BinOpKind::Div,\n-            BiRem => ast::BinOpKind::Rem,\n-            BiAnd => ast::BinOpKind::And,\n-            BiOr => ast::BinOpKind::Or,\n-            BiBitXor => ast::BinOpKind::BitXor,\n-            BiBitAnd => ast::BinOpKind::BitAnd,\n-            BiBitOr => ast::BinOpKind::BitOr,\n-            BiShl => ast::BinOpKind::Shl,\n-            BiShr => ast::BinOpKind::Shr,\n-            BiEq => ast::BinOpKind::Eq,\n-            BiLt => ast::BinOpKind::Lt,\n-            BiLe => ast::BinOpKind::Le,\n-            BiNe => ast::BinOpKind::Ne,\n-            BiGe => ast::BinOpKind::Ge,\n-            BiGt => ast::BinOpKind::Gt,\n+            BinOpKind::Add => ast::BinOpKind::Add,\n+            BinOpKind::Sub => ast::BinOpKind::Sub,\n+            BinOpKind::Mul => ast::BinOpKind::Mul,\n+            BinOpKind::Div => ast::BinOpKind::Div,\n+            BinOpKind::Rem => ast::BinOpKind::Rem,\n+            BinOpKind::And => ast::BinOpKind::And,\n+            BinOpKind::Or => ast::BinOpKind::Or,\n+            BinOpKind::BitXor => ast::BinOpKind::BitXor,\n+            BinOpKind::BitAnd => ast::BinOpKind::BitAnd,\n+            BinOpKind::BitOr => ast::BinOpKind::BitOr,\n+            BinOpKind::Shl => ast::BinOpKind::Shl,\n+            BinOpKind::Shr => ast::BinOpKind::Shr,\n+            BinOpKind::Eq => ast::BinOpKind::Eq,\n+            BinOpKind::Lt => ast::BinOpKind::Lt,\n+            BinOpKind::Le => ast::BinOpKind::Le,\n+            BinOpKind::Ne => ast::BinOpKind::Ne,\n+            BinOpKind::Ge => ast::BinOpKind::Ge,\n+            BinOpKind::Gt => ast::BinOpKind::Gt,\n         }\n     }\n }\n \n-pub type BinOp = Spanned<BinOp_>;\n+pub type BinOp = Spanned<BinOpKind>;\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash)]\n pub enum UnOp {"}, {"sha": "3004c0d0224c0965cd67e9d61ae5ff235742a08c", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=fe8955bd585b8e49b01697684becb6a353413fea", "patch": "@@ -1292,8 +1292,8 @@ impl<'a> State<'a> {\n             // These cases need parens: `x as i32 < y` has the parser thinking that `i32 < y` is\n             // the beginning of a path type. It starts trying to parse `x as (i32 < y ...` instead\n             // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n-            (&hir::ExprCast { .. }, hir::BinOp_::BiLt) |\n-            (&hir::ExprCast { .. }, hir::BinOp_::BiShl) => parser::PREC_FORCE_PAREN,\n+            (&hir::ExprCast { .. }, hir::BinOpKind::Lt) |\n+            (&hir::ExprCast { .. }, hir::BinOpKind::Shl) => parser::PREC_FORCE_PAREN,\n             _ => left_prec,\n         };\n \n@@ -2413,30 +2413,30 @@ fn stmt_ends_with_semi(stmt: &hir::Stmt_) -> bool {\n     }\n }\n \n-fn bin_op_to_assoc_op(op: hir::BinOp_) -> AssocOp {\n-    use hir::BinOp_::*;\n+fn bin_op_to_assoc_op(op: hir::BinOpKind) -> AssocOp {\n+    use hir::BinOpKind::*;\n     match op {\n-        BiAdd => AssocOp::Add,\n-        BiSub => AssocOp::Subtract,\n-        BiMul => AssocOp::Multiply,\n-        BiDiv => AssocOp::Divide,\n-        BiRem => AssocOp::Modulus,\n-\n-        BiAnd => AssocOp::LAnd,\n-        BiOr => AssocOp::LOr,\n-\n-        BiBitXor => AssocOp::BitXor,\n-        BiBitAnd => AssocOp::BitAnd,\n-        BiBitOr => AssocOp::BitOr,\n-        BiShl => AssocOp::ShiftLeft,\n-        BiShr => AssocOp::ShiftRight,\n-\n-        BiEq => AssocOp::Equal,\n-        BiLt => AssocOp::Less,\n-        BiLe => AssocOp::LessEqual,\n-        BiNe => AssocOp::NotEqual,\n-        BiGe => AssocOp::GreaterEqual,\n-        BiGt => AssocOp::Greater,\n+        Add => AssocOp::Add,\n+        Sub => AssocOp::Subtract,\n+        Mul => AssocOp::Multiply,\n+        Div => AssocOp::Divide,\n+        Rem => AssocOp::Modulus,\n+\n+        And => AssocOp::LAnd,\n+        Or => AssocOp::LOr,\n+\n+        BitXor => AssocOp::BitXor,\n+        BitAnd => AssocOp::BitAnd,\n+        BitOr => AssocOp::BitOr,\n+        Shl => AssocOp::ShiftLeft,\n+        Shr => AssocOp::ShiftRight,\n+\n+        Eq => AssocOp::Equal,\n+        Lt => AssocOp::Less,\n+        Le => AssocOp::LessEqual,\n+        Ne => AssocOp::NotEqual,\n+        Ge => AssocOp::GreaterEqual,\n+        Gt => AssocOp::Greater,\n     }\n }\n "}, {"sha": "71a8d3ccdaf65a4fe4fba5e3182d3f83557b2ced", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=fe8955bd585b8e49b01697684becb6a353413fea", "patch": "@@ -437,28 +437,28 @@ impl_stable_hash_for!(enum hir::PatKind {\n     Slice(one, two, three)\n });\n \n-impl_stable_hash_for!(enum hir::BinOp_ {\n-    BiAdd,\n-    BiSub,\n-    BiMul,\n-    BiDiv,\n-    BiRem,\n-    BiAnd,\n-    BiOr,\n-    BiBitXor,\n-    BiBitAnd,\n-    BiBitOr,\n-    BiShl,\n-    BiShr,\n-    BiEq,\n-    BiLt,\n-    BiLe,\n-    BiNe,\n-    BiGe,\n-    BiGt\n-});\n-\n-impl_stable_hash_for_spanned!(hir::BinOp_);\n+impl_stable_hash_for!(enum hir::BinOpKind {\n+    Add,\n+    Sub,\n+    Mul,\n+    Div,\n+    Rem,\n+    And,\n+    Or,\n+    BitXor,\n+    BitAnd,\n+    BitOr,\n+    Shl,\n+    Shr,\n+    Eq,\n+    Lt,\n+    Le,\n+    Ne,\n+    Ge,\n+    Gt\n+});\n+\n+impl_stable_hash_for_spanned!(hir::BinOpKind);\n \n impl_stable_hash_for!(enum hir::UnOp {\n     UnDeref,"}, {"sha": "a196820fcf17d8a4f578cdc1432815bf22480cb6", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=fe8955bd585b8e49b01697684becb6a353413fea", "patch": "@@ -943,8 +943,8 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n             // scopes, meaning that temporaries cannot outlive them.\n             // This ensures fixed size stacks.\n \n-            hir::ExprBinary(codemap::Spanned { node: hir::BiAnd, .. }, _, ref r) |\n-            hir::ExprBinary(codemap::Spanned { node: hir::BiOr, .. }, _, ref r) => {\n+            hir::ExprKind::Binary(codemap::Spanned { node: hir::BinOpKind::And, .. }, _, ref r) |\n+            hir::ExprKind::Binary(codemap::Spanned { node: hir::BinOpKind::Or, .. }, _, ref r) => {\n                 // For shortcircuiting operators, mark the RHS as a terminating\n                 // scope since it only executes conditionally.\n                 terminating(r.hir_id.local_id);"}, {"sha": "6876b1490f376d52e826f67438a66a14374497ff", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=fe8955bd585b8e49b01697684becb6a353413fea", "patch": "@@ -256,24 +256,24 @@ impl BorrowKind {\n }\n \n impl BinOp {\n-    pub fn to_hir_binop(self) -> hir::BinOp_ {\n+    pub fn to_hir_binop(self) -> hir::BinOpKind {\n         match self {\n-            BinOp::Add => hir::BinOp_::BiAdd,\n-            BinOp::Sub => hir::BinOp_::BiSub,\n-            BinOp::Mul => hir::BinOp_::BiMul,\n-            BinOp::Div => hir::BinOp_::BiDiv,\n-            BinOp::Rem => hir::BinOp_::BiRem,\n-            BinOp::BitXor => hir::BinOp_::BiBitXor,\n-            BinOp::BitAnd => hir::BinOp_::BiBitAnd,\n-            BinOp::BitOr => hir::BinOp_::BiBitOr,\n-            BinOp::Shl => hir::BinOp_::BiShl,\n-            BinOp::Shr => hir::BinOp_::BiShr,\n-            BinOp::Eq => hir::BinOp_::BiEq,\n-            BinOp::Ne => hir::BinOp_::BiNe,\n-            BinOp::Lt => hir::BinOp_::BiLt,\n-            BinOp::Gt => hir::BinOp_::BiGt,\n-            BinOp::Le => hir::BinOp_::BiLe,\n-            BinOp::Ge => hir::BinOp_::BiGe,\n+            BinOp::Add => hir::BinOpKind::Add,\n+            BinOp::Sub => hir::BinOpKind::Sub,\n+            BinOp::Mul => hir::BinOpKind::Mul,\n+            BinOp::Div => hir::BinOpKind::Div,\n+            BinOp::Rem => hir::BinOpKind::Rem,\n+            BinOp::BitXor => hir::BinOpKind::BitXor,\n+            BinOp::BitAnd => hir::BinOpKind::BitAnd,\n+            BinOp::BitOr => hir::BinOpKind::BitOr,\n+            BinOp::Shl => hir::BinOpKind::Shl,\n+            BinOp::Shr => hir::BinOpKind::Shr,\n+            BinOp::Eq => hir::BinOpKind::Eq,\n+            BinOp::Ne => hir::BinOpKind::Ne,\n+            BinOp::Lt => hir::BinOpKind::Lt,\n+            BinOp::Gt => hir::BinOpKind::Gt,\n+            BinOp::Le => hir::BinOpKind::Le,\n+            BinOp::Ge => hir::BinOpKind::Ge,\n             BinOp::Offset => unreachable!()\n         }\n     }"}, {"sha": "d4d0b67523e11a24898f573bb915f9f101e04fa4", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=fe8955bd585b8e49b01697684becb6a353413fea", "patch": "@@ -124,16 +124,16 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     }\n }\n \n-pub fn bin_op_to_icmp_predicate(op: hir::BinOp_,\n+pub fn bin_op_to_icmp_predicate(op: hir::BinOpKind,\n                                 signed: bool)\n                                 -> llvm::IntPredicate {\n     match op {\n-        hir::BiEq => llvm::IntEQ,\n-        hir::BiNe => llvm::IntNE,\n-        hir::BiLt => if signed { llvm::IntSLT } else { llvm::IntULT },\n-        hir::BiLe => if signed { llvm::IntSLE } else { llvm::IntULE },\n-        hir::BiGt => if signed { llvm::IntSGT } else { llvm::IntUGT },\n-        hir::BiGe => if signed { llvm::IntSGE } else { llvm::IntUGE },\n+        hir::BinOpKind::Eq => llvm::IntEQ,\n+        hir::BinOpKind::Ne => llvm::IntNE,\n+        hir::BinOpKind::Lt => if signed { llvm::IntSLT } else { llvm::IntULT },\n+        hir::BinOpKind::Le => if signed { llvm::IntSLE } else { llvm::IntULE },\n+        hir::BinOpKind::Gt => if signed { llvm::IntSGT } else { llvm::IntUGT },\n+        hir::BinOpKind::Ge => if signed { llvm::IntSGE } else { llvm::IntUGE },\n         op => {\n             bug!(\"comparison_op_to_icmp_predicate: expected comparison operator, \\\n                   found {:?}\",\n@@ -142,14 +142,14 @@ pub fn bin_op_to_icmp_predicate(op: hir::BinOp_,\n     }\n }\n \n-pub fn bin_op_to_fcmp_predicate(op: hir::BinOp_) -> llvm::RealPredicate {\n+pub fn bin_op_to_fcmp_predicate(op: hir::BinOpKind) -> llvm::RealPredicate {\n     match op {\n-        hir::BiEq => llvm::RealOEQ,\n-        hir::BiNe => llvm::RealUNE,\n-        hir::BiLt => llvm::RealOLT,\n-        hir::BiLe => llvm::RealOLE,\n-        hir::BiGt => llvm::RealOGT,\n-        hir::BiGe => llvm::RealOGE,\n+        hir::BinOpKind::Eq => llvm::RealOEQ,\n+        hir::BinOpKind::Ne => llvm::RealUNE,\n+        hir::BinOpKind::Lt => llvm::RealOLT,\n+        hir::BinOpKind::Le => llvm::RealOLE,\n+        hir::BinOpKind::Gt => llvm::RealOGT,\n+        hir::BinOpKind::Ge => llvm::RealOGE,\n         op => {\n             bug!(\"comparison_op_to_fcmp_predicate: expected comparison operator, \\\n                   found {:?}\",\n@@ -164,7 +164,7 @@ pub fn compare_simd_types<'a, 'tcx>(\n     rhs: ValueRef,\n     t: Ty<'tcx>,\n     ret_ty: Type,\n-    op: hir::BinOp_\n+    op: hir::BinOpKind\n ) -> ValueRef {\n     let signed = match t.sty {\n         ty::TyFloat(_) => {\n@@ -332,12 +332,12 @@ pub fn coerce_unsized_into<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n }\n \n pub fn cast_shift_expr_rhs(\n-    cx: &Builder, op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef\n+    cx: &Builder, op: hir::BinOpKind, lhs: ValueRef, rhs: ValueRef\n ) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs, |a, b| cx.trunc(a, b), |a, b| cx.zext(a, b))\n }\n \n-fn cast_shift_rhs<F, G>(op: hir::BinOp_,\n+fn cast_shift_rhs<F, G>(op: hir::BinOpKind,\n                         lhs: ValueRef,\n                         rhs: ValueRef,\n                         trunc: F,"}, {"sha": "60bba635a7887bbe48fb81a5759eb8bca833fb13", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=fe8955bd585b8e49b01697684becb6a353413fea", "patch": "@@ -350,7 +350,7 @@ pub fn build_unchecked_lshift<'a, 'tcx>(\n     lhs: ValueRef,\n     rhs: ValueRef\n ) -> ValueRef {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOp_::BiShl, lhs, rhs);\n+    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shl, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     bx.shl(lhs, rhs)\n@@ -359,7 +359,7 @@ pub fn build_unchecked_lshift<'a, 'tcx>(\n pub fn build_unchecked_rshift<'a, 'tcx>(\n     bx: &Builder<'a, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n ) -> ValueRef {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOp_::BiShr, lhs, rhs);\n+    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     let is_signed = lhs_t.is_signed();"}, {"sha": "58a32ad9774f61c113d9a0df3a670540bfab3d4b", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=fe8955bd585b8e49b01697684becb6a353413fea", "patch": "@@ -1022,12 +1022,12 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n     let in_len = arg_tys[0].simd_size(tcx);\n \n     let comparison = match name {\n-        \"simd_eq\" => Some(hir::BiEq),\n-        \"simd_ne\" => Some(hir::BiNe),\n-        \"simd_lt\" => Some(hir::BiLt),\n-        \"simd_le\" => Some(hir::BiLe),\n-        \"simd_gt\" => Some(hir::BiGt),\n-        \"simd_ge\" => Some(hir::BiGe),\n+        \"simd_eq\" => Some(hir::BinOpKind::Eq),\n+        \"simd_ne\" => Some(hir::BinOpKind::Ne),\n+        \"simd_lt\" => Some(hir::BinOpKind::Lt),\n+        \"simd_le\" => Some(hir::BinOpKind::Le),\n+        \"simd_gt\" => Some(hir::BinOpKind::Gt),\n+        \"simd_ge\" => Some(hir::BinOpKind::Ge),\n         _ => None\n     };\n "}, {"sha": "65aa30ab3c0beb711094b5ddb19bf2ff978283dd", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=fe8955bd585b8e49b01697684becb6a353413fea", "patch": "@@ -194,22 +194,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n \n         fn is_valid<T: cmp::PartialOrd>(binop: hir::BinOp, v: T, min: T, max: T) -> bool {\n             match binop.node {\n-                hir::BiLt => v > min && v <= max,\n-                hir::BiLe => v >= min && v < max,\n-                hir::BiGt => v >= min && v < max,\n-                hir::BiGe => v > min && v <= max,\n-                hir::BiEq | hir::BiNe => v >= min && v <= max,\n+                hir::BinOpKind::Lt => v > min && v <= max,\n+                hir::BinOpKind::Le => v >= min && v < max,\n+                hir::BinOpKind::Gt => v >= min && v < max,\n+                hir::BinOpKind::Ge => v > min && v <= max,\n+                hir::BinOpKind::Eq | hir::BinOpKind::Ne => v >= min && v <= max,\n                 _ => bug!(),\n             }\n         }\n \n         fn rev_binop(binop: hir::BinOp) -> hir::BinOp {\n             codemap::respan(binop.span,\n                             match binop.node {\n-                                hir::BiLt => hir::BiGt,\n-                                hir::BiLe => hir::BiGe,\n-                                hir::BiGt => hir::BiLt,\n-                                hir::BiGe => hir::BiLe,\n+                                hir::BinOpKind::Lt => hir::BinOpKind::Gt,\n+                                hir::BinOpKind::Le => hir::BinOpKind::Ge,\n+                                hir::BinOpKind::Gt => hir::BinOpKind::Lt,\n+                                hir::BinOpKind::Ge => hir::BinOpKind::Le,\n                                 _ => return binop,\n                             })\n         }\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n \n         fn is_comparison(binop: hir::BinOp) -> bool {\n             match binop.node {\n-                hir::BiEq | hir::BiLt | hir::BiLe | hir::BiNe | hir::BiGe | hir::BiGt => true,\n+                hir::BinOpKind::Eq | hir::BinOpKind::Lt | hir::BinOpKind::Le | hir::BinOpKind::Ne | hir::BinOpKind::Ge | hir::BinOpKind::Gt => true,\n                 _ => false,\n             }\n         }"}, {"sha": "1ae6289e9399b221dafcf8d790a089b7843a91e5", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=fe8955bd585b8e49b01697684becb6a353413fea", "patch": "@@ -102,16 +102,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             // attribute which does exist on the comparison trait methods\n             hir::ExprBinary(bin_op, ..)  => {\n                 match bin_op.node {\n-                    hir::BiEq | hir::BiLt | hir::BiLe | hir::BiNe | hir::BiGe | hir::BiGt => {\n+                    hir::BinOpKind::Eq | hir::BinOpKind::Lt | hir::BinOpKind::Le | hir::BinOpKind::Ne | hir::BinOpKind::Ge | hir::BinOpKind::Gt => {\n                         Some(\"comparison\")\n                     },\n-                    hir::BiAdd | hir::BiSub | hir::BiDiv | hir::BiMul | hir::BiRem => {\n+                    hir::BinOpKind::Add | hir::BinOpKind::Sub | hir::BinOpKind::Div | hir::BinOpKind::Mul | hir::BinOpKind::Rem => {\n                         Some(\"arithmetic operation\")\n                     },\n-                    hir::BiAnd | hir::BiOr => {\n+                    hir::BinOpKind::And | hir::BinOpKind::Or => {\n                         Some(\"logical operation\")\n                     },\n-                    hir::BiBitXor | hir::BiBitAnd | hir::BiBitOr | hir::BiShl | hir::BiShr => {\n+                    hir::BinOpKind::BitXor | hir::BinOpKind::BitAnd | hir::BinOpKind::BitOr | hir::BinOpKind::Shl | hir::BinOpKind::Shr => {\n                         Some(\"bitwise operation\")\n                     },\n                 }"}, {"sha": "edbb6cb16131590fcec4eb9dd5ab12fcaf04b371", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=fe8955bd585b8e49b01697684becb6a353413fea", "patch": "@@ -325,29 +325,29 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 match (op.node, cx.constness) {\n                     // FIXME(eddyb) use logical ops in constants when\n                     // they can handle that kind of control-flow.\n-                    (hir::BinOp_::BiAnd, hir::Constness::Const) => {\n+                    (hir::BinOpKind::And, hir::Constness::Const) => {\n                         ExprKind::Binary {\n                             op: BinOp::BitAnd,\n                             lhs: lhs.to_ref(),\n                             rhs: rhs.to_ref(),\n                         }\n                     }\n-                    (hir::BinOp_::BiOr, hir::Constness::Const) => {\n+                    (hir::BinOpKind::Or, hir::Constness::Const) => {\n                         ExprKind::Binary {\n                             op: BinOp::BitOr,\n                             lhs: lhs.to_ref(),\n                             rhs: rhs.to_ref(),\n                         }\n                     }\n \n-                    (hir::BinOp_::BiAnd, hir::Constness::NotConst) => {\n+                    (hir::BinOpKind::And, hir::Constness::NotConst) => {\n                         ExprKind::LogicalOp {\n                             op: LogicalOp::And,\n                             lhs: lhs.to_ref(),\n                             rhs: rhs.to_ref(),\n                         }\n                     }\n-                    (hir::BinOp_::BiOr, hir::Constness::NotConst) => {\n+                    (hir::BinOpKind::Or, hir::Constness::NotConst) => {\n                         ExprKind::LogicalOp {\n                             op: LogicalOp::Or,\n                             lhs: lhs.to_ref(),\n@@ -930,24 +930,24 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n }\n \n \n-fn bin_op(op: hir::BinOp_) -> BinOp {\n+fn bin_op(op: hir::BinOpKind) -> BinOp {\n     match op {\n-        hir::BinOp_::BiAdd => BinOp::Add,\n-        hir::BinOp_::BiSub => BinOp::Sub,\n-        hir::BinOp_::BiMul => BinOp::Mul,\n-        hir::BinOp_::BiDiv => BinOp::Div,\n-        hir::BinOp_::BiRem => BinOp::Rem,\n-        hir::BinOp_::BiBitXor => BinOp::BitXor,\n-        hir::BinOp_::BiBitAnd => BinOp::BitAnd,\n-        hir::BinOp_::BiBitOr => BinOp::BitOr,\n-        hir::BinOp_::BiShl => BinOp::Shl,\n-        hir::BinOp_::BiShr => BinOp::Shr,\n-        hir::BinOp_::BiEq => BinOp::Eq,\n-        hir::BinOp_::BiLt => BinOp::Lt,\n-        hir::BinOp_::BiLe => BinOp::Le,\n-        hir::BinOp_::BiNe => BinOp::Ne,\n-        hir::BinOp_::BiGe => BinOp::Ge,\n-        hir::BinOp_::BiGt => BinOp::Gt,\n+        hir::BinOpKind::Add => BinOp::Add,\n+        hir::BinOpKind::Sub => BinOp::Sub,\n+        hir::BinOpKind::Mul => BinOp::Mul,\n+        hir::BinOpKind::Div => BinOp::Div,\n+        hir::BinOpKind::Rem => BinOp::Rem,\n+        hir::BinOpKind::BitXor => BinOp::BitXor,\n+        hir::BinOpKind::BitAnd => BinOp::BitAnd,\n+        hir::BinOpKind::BitOr => BinOp::BitOr,\n+        hir::BinOpKind::Shl => BinOp::Shl,\n+        hir::BinOpKind::Shr => BinOp::Shr,\n+        hir::BinOpKind::Eq => BinOp::Eq,\n+        hir::BinOpKind::Lt => BinOp::Lt,\n+        hir::BinOpKind::Le => BinOp::Le,\n+        hir::BinOpKind::Ne => BinOp::Ne,\n+        hir::BinOpKind::Ge => BinOp::Ge,\n+        hir::BinOpKind::Gt => BinOp::Gt,\n         _ => bug!(\"no equivalent for ast binop {:?}\", op),\n     }\n }"}, {"sha": "66633a0de70911f7471a09dbba802824b6728768", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=fe8955bd585b8e49b01697684becb6a353413fea", "patch": "@@ -356,9 +356,9 @@ fn check_expr_kind<'a, 'tcx>(\n             }\n             match v.tables.node_id_to_type(lhs.hir_id).sty {\n                 ty::TyRawPtr(_) => {\n-                    assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n-                        op.node == hir::BiLe || op.node == hir::BiLt ||\n-                        op.node == hir::BiGe || op.node == hir::BiGt);\n+                    assert!(op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne ||\n+                        op.node == hir::BinOpKind::Le || op.node == hir::BinOpKind::Lt ||\n+                        op.node == hir::BinOpKind::Ge || op.node == hir::BinOpKind::Gt);\n \n                     NotPromotable\n                 }"}, {"sha": "ba90f201b63dd61f08a4dae7d68758a685380285", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8955bd585b8e49b01697684becb6a353413fea/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=fe8955bd585b8e49b01697684becb6a353413fea", "patch": "@@ -285,20 +285,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 }\n                             }\n                             let missing_trait = match op.node {\n-                                hir::BiAdd    => Some(\"std::ops::AddAssign\"),\n-                                hir::BiSub    => Some(\"std::ops::SubAssign\"),\n-                                hir::BiMul    => Some(\"std::ops::MulAssign\"),\n-                                hir::BiDiv    => Some(\"std::ops::DivAssign\"),\n-                                hir::BiRem    => Some(\"std::ops::RemAssign\"),\n-                                hir::BiBitAnd => Some(\"std::ops::BitAndAssign\"),\n-                                hir::BiBitXor => Some(\"std::ops::BitXorAssign\"),\n-                                hir::BiBitOr  => Some(\"std::ops::BitOrAssign\"),\n-                                hir::BiShl    => Some(\"std::ops::ShlAssign\"),\n-                                hir::BiShr    => Some(\"std::ops::ShrAssign\"),\n+                                hir::BinOpKind::Add    => Some(\"std::ops::AddAssign\"),\n+                                hir::BinOpKind::Sub    => Some(\"std::ops::SubAssign\"),\n+                                hir::BinOpKind::Mul    => Some(\"std::ops::MulAssign\"),\n+                                hir::BinOpKind::Div    => Some(\"std::ops::DivAssign\"),\n+                                hir::BinOpKind::Rem    => Some(\"std::ops::RemAssign\"),\n+                                hir::BinOpKind::BitAnd => Some(\"std::ops::BitAndAssign\"),\n+                                hir::BinOpKind::BitXor => Some(\"std::ops::BitXorAssign\"),\n+                                hir::BinOpKind::BitOr  => Some(\"std::ops::BitOrAssign\"),\n+                                hir::BinOpKind::Shl    => Some(\"std::ops::ShlAssign\"),\n+                                hir::BinOpKind::Shr    => Some(\"std::ops::ShrAssign\"),\n                                 _             => None\n                             };\n                             if let Some(missing_trait) = missing_trait {\n-                                if op.node == hir::BiAdd &&\n+                                if op.node == hir::BinOpKind::Add &&\n                                     self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n                                                             rhs_ty, &mut err) {\n                                     // This has nothing here because it means we did string\n@@ -353,23 +353,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 }\n                             }\n                             let missing_trait = match op.node {\n-                                hir::BiAdd    => Some(\"std::ops::Add\"),\n-                                hir::BiSub    => Some(\"std::ops::Sub\"),\n-                                hir::BiMul    => Some(\"std::ops::Mul\"),\n-                                hir::BiDiv    => Some(\"std::ops::Div\"),\n-                                hir::BiRem    => Some(\"std::ops::Rem\"),\n-                                hir::BiBitAnd => Some(\"std::ops::BitAnd\"),\n-                                hir::BiBitXor => Some(\"std::ops::BitXor\"),\n-                                hir::BiBitOr  => Some(\"std::ops::BitOr\"),\n-                                hir::BiShl    => Some(\"std::ops::Shl\"),\n-                                hir::BiShr    => Some(\"std::ops::Shr\"),\n-                                hir::BiEq | hir::BiNe => Some(\"std::cmp::PartialEq\"),\n-                                hir::BiLt | hir::BiLe | hir::BiGt | hir::BiGe =>\n+                                hir::BinOpKind::Add    => Some(\"std::ops::Add\"),\n+                                hir::BinOpKind::Sub    => Some(\"std::ops::Sub\"),\n+                                hir::BinOpKind::Mul    => Some(\"std::ops::Mul\"),\n+                                hir::BinOpKind::Div    => Some(\"std::ops::Div\"),\n+                                hir::BinOpKind::Rem    => Some(\"std::ops::Rem\"),\n+                                hir::BinOpKind::BitAnd => Some(\"std::ops::BitAnd\"),\n+                                hir::BinOpKind::BitXor => Some(\"std::ops::BitXor\"),\n+                                hir::BinOpKind::BitOr  => Some(\"std::ops::BitOr\"),\n+                                hir::BinOpKind::Shl    => Some(\"std::ops::Shl\"),\n+                                hir::BinOpKind::Shr    => Some(\"std::ops::Shr\"),\n+                                hir::BinOpKind::Eq | hir::BinOpKind::Ne => Some(\"std::cmp::PartialEq\"),\n+                                hir::BinOpKind::Lt | hir::BinOpKind::Le | hir::BinOpKind::Gt | hir::BinOpKind::Ge =>\n                                     Some(\"std::cmp::PartialOrd\"),\n                                 _             => None\n                             };\n                             if let Some(missing_trait) = missing_trait {\n-                                if op.node == hir::BiAdd &&\n+                                if op.node == hir::BinOpKind::Add &&\n                                     self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n                                                             rhs_ty, &mut err) {\n                                     // This has nothing here because it means we did string\n@@ -508,44 +508,44 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n         let (opname, trait_did) = if let Op::Binary(op, IsAssign::Yes) = op {\n             match op.node {\n-                hir::BiAdd => (\"add_assign\", lang.add_assign_trait()),\n-                hir::BiSub => (\"sub_assign\", lang.sub_assign_trait()),\n-                hir::BiMul => (\"mul_assign\", lang.mul_assign_trait()),\n-                hir::BiDiv => (\"div_assign\", lang.div_assign_trait()),\n-                hir::BiRem => (\"rem_assign\", lang.rem_assign_trait()),\n-                hir::BiBitXor => (\"bitxor_assign\", lang.bitxor_assign_trait()),\n-                hir::BiBitAnd => (\"bitand_assign\", lang.bitand_assign_trait()),\n-                hir::BiBitOr => (\"bitor_assign\", lang.bitor_assign_trait()),\n-                hir::BiShl => (\"shl_assign\", lang.shl_assign_trait()),\n-                hir::BiShr => (\"shr_assign\", lang.shr_assign_trait()),\n-                hir::BiLt | hir::BiLe |\n-                hir::BiGe | hir::BiGt |\n-                hir::BiEq | hir::BiNe |\n-                hir::BiAnd | hir::BiOr => {\n+                hir::BinOpKind::Add => (\"add_assign\", lang.add_assign_trait()),\n+                hir::BinOpKind::Sub => (\"sub_assign\", lang.sub_assign_trait()),\n+                hir::BinOpKind::Mul => (\"mul_assign\", lang.mul_assign_trait()),\n+                hir::BinOpKind::Div => (\"div_assign\", lang.div_assign_trait()),\n+                hir::BinOpKind::Rem => (\"rem_assign\", lang.rem_assign_trait()),\n+                hir::BinOpKind::BitXor => (\"bitxor_assign\", lang.bitxor_assign_trait()),\n+                hir::BinOpKind::BitAnd => (\"bitand_assign\", lang.bitand_assign_trait()),\n+                hir::BinOpKind::BitOr => (\"bitor_assign\", lang.bitor_assign_trait()),\n+                hir::BinOpKind::Shl => (\"shl_assign\", lang.shl_assign_trait()),\n+                hir::BinOpKind::Shr => (\"shr_assign\", lang.shr_assign_trait()),\n+                hir::BinOpKind::Lt | hir::BinOpKind::Le |\n+                hir::BinOpKind::Ge | hir::BinOpKind::Gt |\n+                hir::BinOpKind::Eq | hir::BinOpKind::Ne |\n+                hir::BinOpKind::And | hir::BinOpKind::Or => {\n                     span_bug!(span,\n                               \"impossible assignment operation: {}=\",\n                               op.node.as_str())\n                 }\n             }\n         } else if let Op::Binary(op, IsAssign::No) = op {\n             match op.node {\n-                hir::BiAdd => (\"add\", lang.add_trait()),\n-                hir::BiSub => (\"sub\", lang.sub_trait()),\n-                hir::BiMul => (\"mul\", lang.mul_trait()),\n-                hir::BiDiv => (\"div\", lang.div_trait()),\n-                hir::BiRem => (\"rem\", lang.rem_trait()),\n-                hir::BiBitXor => (\"bitxor\", lang.bitxor_trait()),\n-                hir::BiBitAnd => (\"bitand\", lang.bitand_trait()),\n-                hir::BiBitOr => (\"bitor\", lang.bitor_trait()),\n-                hir::BiShl => (\"shl\", lang.shl_trait()),\n-                hir::BiShr => (\"shr\", lang.shr_trait()),\n-                hir::BiLt => (\"lt\", lang.partial_ord_trait()),\n-                hir::BiLe => (\"le\", lang.partial_ord_trait()),\n-                hir::BiGe => (\"ge\", lang.partial_ord_trait()),\n-                hir::BiGt => (\"gt\", lang.partial_ord_trait()),\n-                hir::BiEq => (\"eq\", lang.eq_trait()),\n-                hir::BiNe => (\"ne\", lang.eq_trait()),\n-                hir::BiAnd | hir::BiOr => {\n+                hir::BinOpKind::Add => (\"add\", lang.add_trait()),\n+                hir::BinOpKind::Sub => (\"sub\", lang.sub_trait()),\n+                hir::BinOpKind::Mul => (\"mul\", lang.mul_trait()),\n+                hir::BinOpKind::Div => (\"div\", lang.div_trait()),\n+                hir::BinOpKind::Rem => (\"rem\", lang.rem_trait()),\n+                hir::BinOpKind::BitXor => (\"bitxor\", lang.bitxor_trait()),\n+                hir::BinOpKind::BitAnd => (\"bitand\", lang.bitand_trait()),\n+                hir::BinOpKind::BitOr => (\"bitor\", lang.bitor_trait()),\n+                hir::BinOpKind::Shl => (\"shl\", lang.shl_trait()),\n+                hir::BinOpKind::Shr => (\"shr\", lang.shr_trait()),\n+                hir::BinOpKind::Lt => (\"lt\", lang.partial_ord_trait()),\n+                hir::BinOpKind::Le => (\"le\", lang.partial_ord_trait()),\n+                hir::BinOpKind::Ge => (\"ge\", lang.partial_ord_trait()),\n+                hir::BinOpKind::Gt => (\"gt\", lang.partial_ord_trait()),\n+                hir::BinOpKind::Eq => (\"eq\", lang.eq_trait()),\n+                hir::BinOpKind::Ne => (\"ne\", lang.eq_trait()),\n+                hir::BinOpKind::And | hir::BinOpKind::Or => {\n                     span_bug!(span, \"&& and || are not overloadable\")\n                 }\n             }\n@@ -608,31 +608,31 @@ enum BinOpCategory {\n impl BinOpCategory {\n     fn from(op: hir::BinOp) -> BinOpCategory {\n         match op.node {\n-            hir::BiShl | hir::BiShr =>\n+            hir::BinOpKind::Shl | hir::BinOpKind::Shr =>\n                 BinOpCategory::Shift,\n \n-            hir::BiAdd |\n-            hir::BiSub |\n-            hir::BiMul |\n-            hir::BiDiv |\n-            hir::BiRem =>\n+            hir::BinOpKind::Add |\n+            hir::BinOpKind::Sub |\n+            hir::BinOpKind::Mul |\n+            hir::BinOpKind::Div |\n+            hir::BinOpKind::Rem =>\n                 BinOpCategory::Math,\n \n-            hir::BiBitXor |\n-            hir::BiBitAnd |\n-            hir::BiBitOr =>\n+            hir::BinOpKind::BitXor |\n+            hir::BinOpKind::BitAnd |\n+            hir::BinOpKind::BitOr =>\n                 BinOpCategory::Bitwise,\n \n-            hir::BiEq |\n-            hir::BiNe |\n-            hir::BiLt |\n-            hir::BiLe |\n-            hir::BiGe |\n-            hir::BiGt =>\n+            hir::BinOpKind::Eq |\n+            hir::BinOpKind::Ne |\n+            hir::BinOpKind::Lt |\n+            hir::BinOpKind::Le |\n+            hir::BinOpKind::Ge |\n+            hir::BinOpKind::Gt =>\n                 BinOpCategory::Comparison,\n \n-            hir::BiAnd |\n-            hir::BiOr =>\n+            hir::BinOpKind::And |\n+            hir::BinOpKind::Or =>\n                 BinOpCategory::Shortcircuit,\n         }\n     }"}]}