{"sha": "a3770c2547dd163e0f5bfa07ec23b8b461fbe145", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNzcwYzI1NDdkZDE2M2UwZjViZmEwN2VjMjNiOGI0NjFmYmUxNDU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-12T10:22:18Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-15T09:59:39Z"}, "message": "do not accept out-of-bounds pointers in enum discriminants, they might be NULL", "tree": {"sha": "443dbaacb2e1f5fab6479d0958fbc1cef1d7027f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/443dbaacb2e1f5fab6479d0958fbc1cef1d7027f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3770c2547dd163e0f5bfa07ec23b8b461fbe145", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3770c2547dd163e0f5bfa07ec23b8b461fbe145", "html_url": "https://github.com/rust-lang/rust/commit/a3770c2547dd163e0f5bfa07ec23b8b461fbe145", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffb6ba082897db55f7ab4e576175b144597aa38f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffb6ba082897db55f7ab4e576175b144597aa38f", "html_url": "https://github.com/rust-lang/rust/commit/ffb6ba082897db55f7ab4e576175b144597aa38f"}], "stats": {"total": 134, "additions": 86, "deletions": 48}, "files": [{"sha": "9c1fb99cb73cca50755ab231e3bc8bde9c984f70", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=a3770c2547dd163e0f5bfa07ec23b8b461fbe145", "patch": "@@ -451,7 +451,7 @@ impl_stable_hash_for!(\n         FunctionRetMismatch(a, b),\n         NoMirFor(s),\n         UnterminatedCString(ptr),\n-        PointerOutOfBounds { ptr, access, allocation_size },\n+        PointerOutOfBounds { ptr, check, allocation_size },\n         InvalidBoolOp(bop),\n         Unimplemented(s),\n         BoundsCheck { len, index },\n@@ -471,6 +471,11 @@ impl_stable_hash_for!(\n     }\n );\n \n+impl_stable_hash_for!(enum mir::interpret::InboundsCheck {\n+    Live,\n+    MaybeDead\n+});\n+\n impl_stable_hash_for!(enum mir::interpret::Lock {\n     NoLock,\n     WriteLock(dl),"}, {"sha": "02c0ebcec4fefb64cc5d2175dd5b5b4d4af26e84", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=a3770c2547dd163e0f5bfa07ec23b8b461fbe145", "patch": "@@ -19,6 +19,14 @@ use mir;\n use std::ops::{Deref, DerefMut};\n use rustc_data_structures::sorted_map::SortedMap;\n \n+/// Used by `check_bounds` to indicate whether the pointer needs to be just inbounds\n+/// or also inbounds of a *live* allocation.\n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n+pub enum InboundsCheck {\n+    Live,\n+    MaybeDead,\n+}\n+\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Allocation<Tag=(),Extra=()> {\n     /// The actual bytes of the allocation."}, {"sha": "bf678db51c95286b4d7a8e6d270b7a76a32d4436", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=a3770c2547dd163e0f5bfa07ec23b8b461fbe145", "patch": "@@ -15,7 +15,7 @@ use ty::{Ty, layout};\n use ty::layout::{Size, Align, LayoutError};\n use rustc_target::spec::abi::Abi;\n \n-use super::{Pointer, ScalarMaybeUndef};\n+use super::{Pointer, InboundsCheck, ScalarMaybeUndef};\n \n use backtrace::Backtrace;\n \n@@ -243,7 +243,7 @@ pub enum EvalErrorKind<'tcx, O> {\n     InvalidDiscriminant(ScalarMaybeUndef),\n     PointerOutOfBounds {\n         ptr: Pointer,\n-        access: bool,\n+        check: InboundsCheck,\n         allocation_size: Size,\n     },\n     InvalidNullPointerUsage,\n@@ -457,9 +457,13 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use self::EvalErrorKind::*;\n         match *self {\n-            PointerOutOfBounds { ptr, access, allocation_size } => {\n-                write!(f, \"{} at offset {}, outside bounds of allocation {} which has size {}\",\n-                       if access { \"memory access\" } else { \"pointer computed\" },\n+            PointerOutOfBounds { ptr, check, allocation_size } => {\n+                write!(f, \"Pointer must be in-bounds{} at offset {}, but is outside bounds of \\\n+                           allocation {} which has size {}\",\n+                       match check {\n+                           InboundsCheck::Live => \" and live\",\n+                           InboundsCheck::MaybeDead => \"\",\n+                       },\n                        ptr.offset.bytes(), ptr.alloc_id, allocation_size.bytes())\n             },\n             ValidationFailure(ref err) => {"}, {"sha": "ec25431bd1ffe505ad1b40ea817cfe90a63af481", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=a3770c2547dd163e0f5bfa07ec23b8b461fbe145", "patch": "@@ -28,7 +28,7 @@ pub use self::error::{\n pub use self::value::{Scalar, ConstValue, ScalarMaybeUndef};\n \n pub use self::allocation::{\n-    Allocation, AllocationExtra,\n+    InboundsCheck, Allocation, AllocationExtra,\n     Relocations, UndefMask,\n };\n "}, {"sha": "c5a242f334c90ebedca7b1fc14bfcd7b150ace62", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=a3770c2547dd163e0f5bfa07ec23b8b461fbe145", "patch": "@@ -28,7 +28,7 @@ use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use syntax::ast::Mutability;\n \n use super::{\n-    Pointer, AllocId, Allocation, ConstValue, GlobalId, AllocationExtra,\n+    Pointer, AllocId, Allocation, ConstValue, GlobalId, AllocationExtra, InboundsCheck,\n     EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n     Machine, AllocMap, MayLeak, ScalarMaybeUndef, ErrorHandled,\n };\n@@ -249,17 +249,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // Check non-NULL/Undef, extract offset\n         let (offset, alloc_align) = match ptr {\n             Scalar::Ptr(ptr) => {\n-                let (size, align) = self.get_size_and_align(ptr.alloc_id);\n                 // check this is not NULL -- which we can ensure only if this is in-bounds\n                 // of some (potentially dead) allocation.\n-                if ptr.offset > size {\n-                    return err!(PointerOutOfBounds {\n-                        ptr: ptr.erase_tag(),\n-                        access: true,\n-                        allocation_size: size,\n-                    });\n-                };\n-                // keep data for alignment check\n+                self.check_bounds_ptr(ptr, InboundsCheck::MaybeDead)?;\n+                // data required for alignment check\n+                let (_, align) = self.get_size_and_align(ptr.alloc_id);\n                 (ptr.offset.bytes(), align)\n             }\n             Scalar::Bits { bits, size } => {\n@@ -293,18 +287,28 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n     /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n-    /// in-bounds!  This follows C's/LLVM's rules.  The `access` boolean is just used\n-    /// for the error message.\n-    /// If you want to check bounds before doing a memory access, be sure to\n-    /// check the pointer one past the end of your access, then everything will\n-    /// work out exactly.\n-    pub fn check_bounds_ptr(&self, ptr: Pointer<M::PointerTag>, access: bool) -> EvalResult<'tcx> {\n-        let alloc = self.get(ptr.alloc_id)?;\n-        let allocation_size = alloc.bytes.len() as u64;\n+    /// in-bounds!  This follows C's/LLVM's rules.  `check` indicates whether we\n+    /// additionally require the pointer to be pointing to a *live* (still allocated)\n+    /// allocation.\n+    /// If you want to check bounds before doing a memory access, better use `check_bounds`.\n+    pub fn check_bounds_ptr(\n+        &self,\n+        ptr: Pointer<M::PointerTag>,\n+        check: InboundsCheck,\n+    ) -> EvalResult<'tcx> {\n+        let allocation_size = match check {\n+            InboundsCheck::Live => {\n+                let alloc = self.get(ptr.alloc_id)?;\n+                alloc.bytes.len() as u64\n+            }\n+            InboundsCheck::MaybeDead => {\n+                self.get_size_and_align(ptr.alloc_id).0.bytes()\n+            }\n+        };\n         if ptr.offset.bytes() > allocation_size {\n             return err!(PointerOutOfBounds {\n                 ptr: ptr.erase_tag(),\n-                access,\n+                check,\n                 allocation_size: Size::from_bytes(allocation_size),\n             });\n         }\n@@ -317,10 +321,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<M::PointerTag>,\n         size: Size,\n-        access: bool\n+        check: InboundsCheck,\n     ) -> EvalResult<'tcx> {\n         // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds_ptr(ptr.offset(size, &*self)?, access)\n+        self.check_bounds_ptr(ptr.offset(size, &*self)?, check)\n     }\n }\n \n@@ -626,7 +630,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, &[u8]> {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_align(ptr.into(), align)?;\n-        self.check_bounds(ptr, size, true)?;\n+        self.check_bounds(ptr, size, InboundsCheck::Live)?;\n \n         if check_defined_and_ptr {\n             self.check_defined(ptr, size)?;\n@@ -677,7 +681,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_align(ptr.into(), align)?;\n-        self.check_bounds(ptr, size, true)?;\n+        self.check_bounds(ptr, size, InboundsCheck::Live)?;\n \n         self.mark_definedness(ptr, size, true)?;\n         self.clear_relocations(ptr, size)?;"}, {"sha": "b7910ad3bce9ed1adf8ece1a301320b9131c4942", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=a3770c2547dd163e0f5bfa07ec23b8b461fbe145", "patch": "@@ -19,7 +19,7 @@ use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerEx\n use rustc::mir::interpret::{\n     GlobalId, AllocId,\n     ConstValue, Pointer, Scalar,\n-    EvalResult, EvalErrorKind\n+    EvalResult, EvalErrorKind, InboundsCheck,\n };\n use super::{EvalContext, Machine, MemPlace, MPlaceTy, MemoryKind};\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n@@ -647,24 +647,27 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let variants_start = niche_variants.start().as_u32() as u128;\n                 let variants_end = niche_variants.end().as_u32() as u128;\n                 match raw_discr {\n-                    ScalarMaybeUndef::Scalar(Scalar::Ptr(_)) => {\n-                        // The niche must be just 0 (which a pointer value never is)\n-                        assert!(niche_start == 0);\n-                        assert!(variants_start == variants_end);\n+                    ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) => {\n+                        // The niche must be just 0 (which an inbounds pointer value never is)\n+                        let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n+                            self.memory.check_bounds_ptr(ptr, InboundsCheck::MaybeDead).is_ok();\n+                        if !ptr_valid {\n+                            return err!(InvalidDiscriminant(raw_discr.erase_tag()));\n+                        }\n                         (dataful_variant.as_u32() as u128, dataful_variant)\n                     },\n                     ScalarMaybeUndef::Scalar(Scalar::Bits { bits: raw_discr, size }) => {\n                         assert_eq!(size as u64, discr_val.layout.size.bytes());\n-                        let discr = raw_discr.wrapping_sub(niche_start)\n+                        let adjusted_discr = raw_discr.wrapping_sub(niche_start)\n                             .wrapping_add(variants_start);\n-                        if variants_start <= discr && discr <= variants_end {\n-                            let index = discr as usize;\n-                            assert_eq!(index as u128, discr);\n+                        if variants_start <= adjusted_discr && adjusted_discr <= variants_end {\n+                            let index = adjusted_discr as usize;\n+                            assert_eq!(index as u128, adjusted_discr);\n                             assert!(index < rval.layout.ty\n                                 .ty_adt_def()\n                                 .expect(\"tagged layout for non adt\")\n                                 .variants.len());\n-                            (discr, VariantIdx::from_usize(index))\n+                            (adjusted_discr, VariantIdx::from_usize(index))\n                         } else {\n                             (dataful_variant.as_u32() as u128, dataful_variant)\n                         }"}, {"sha": "5d5c25e66a2e00a686e72ad6414879cdc7f51614", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=a3770c2547dd163e0f5bfa07ec23b8b461fbe145", "patch": "@@ -17,7 +17,7 @@ use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n-    Scalar, AllocType, EvalResult, EvalErrorKind,\n+    Scalar, AllocType, EvalResult, EvalErrorKind, InboundsCheck,\n };\n \n use super::{\n@@ -394,7 +394,8 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                         }\n                         // Maintain the invariant that the place we are checking is\n                         // already verified to be in-bounds.\n-                        try_validation!(self.ecx.memory.check_bounds(ptr, size, false),\n+                        try_validation!(\n+                            self.ecx.memory.check_bounds(ptr, size, InboundsCheck::Live),\n                             \"dangling (not entirely in bounds) reference\", self.path);\n                     }\n                     // Check if we have encountered this pointer+layout combination"}, {"sha": "89b449464419e9a3f04295b012f3caf22c6372db", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=a3770c2547dd163e0f5bfa07ec23b8b461fbe145", "patch": "@@ -39,6 +39,7 @@ union TransmuteEnum2 {\n     in3: (),\n     out1: Enum2,\n     out2: Wrap<Enum2>, // something wrapping the enum so that we test layout first, not enum\n+    out3: Option<Enum2>,\n }\n const BAD_ENUM2: Enum2 = unsafe { TransmuteEnum2 { in1: 0 }.out1 };\n //~^ ERROR is undefined behavior\n@@ -51,6 +52,10 @@ const BAD_ENUM4: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n const BAD_ENUM_UNDEF: [Enum2; 2] = [unsafe { TransmuteEnum2 { in3: () }.out1 }; 2];\n //~^ ERROR is undefined behavior\n \n+// Pointer value in an enum with a niche that is not just 0.\n+const BAD_ENUM_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n+//~^ ERROR is undefined behavior\n+\n // Invalid enum field content (mostly to test printing of paths for enum tuple\n // variants and tuples).\n union TransmuteChar {"}, {"sha": "5aae3a2f35110528693dc8df9eef56917b3c1865", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3770c2547dd163e0f5bfa07ec23b8b461fbe145/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=a3770c2547dd163e0f5bfa07ec23b8b461fbe145", "patch": "@@ -7,45 +7,53 @@ LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { a: &1 }.out };\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:43:1\n+  --> $DIR/ub-enum.rs:44:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { TransmuteEnum2 { in1: 0 }.out1 };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:45:1\n+  --> $DIR/ub-enum.rs:46:1\n    |\n LL | const BAD_ENUM3: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:47:1\n+  --> $DIR/ub-enum.rs:48:1\n    |\n LL | const BAD_ENUM4: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected something that cannot possibly fail to be in the range 2..=2\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:51:1\n+  --> $DIR/ub-enum.rs:52:1\n    |\n LL | const BAD_ENUM_UNDEF: [Enum2; 2] = [unsafe { TransmuteEnum2 { in3: () }.out1 }; 2];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes at [0], but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:61:1\n+  --> $DIR/ub-enum.rs:56:1\n+   |\n+LL | const BAD_ENUM_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-enum.rs:66:1\n    |\n LL | const BAD_ENUM_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<downcast-variant(Some)>.0.1, but expected something less or equal to 1114111\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}]}