{"sha": "8356f4cc23ea4c2403011b6c2c619738fce7e32a", "node_id": "C_kwDOAAsO6NoAKDgzNTZmNGNjMjNlYTRjMjQwMzAxMWI2YzJjNjE5NzM4ZmNlN2UzMmE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-02T22:08:43Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-02T22:08:43Z"}, "message": "output realpath as a path, and remove a bogus test", "tree": {"sha": "0a1735cec3a8dbf4bfd5156ce5ea14e9c08f7523", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a1735cec3a8dbf4bfd5156ce5ea14e9c08f7523"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8356f4cc23ea4c2403011b6c2c619738fce7e32a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8356f4cc23ea4c2403011b6c2c619738fce7e32a", "html_url": "https://github.com/rust-lang/rust/commit/8356f4cc23ea4c2403011b6c2c619738fce7e32a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8356f4cc23ea4c2403011b6c2c619738fce7e32a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b43bede93826f459e210957c8fd12fc1dd77d678", "url": "https://api.github.com/repos/rust-lang/rust/commits/b43bede93826f459e210957c8fd12fc1dd77d678", "html_url": "https://github.com/rust-lang/rust/commit/b43bede93826f459e210957c8fd12fc1dd77d678"}], "stats": {"total": 64, "additions": 15, "deletions": 49}, "files": [{"sha": "acc2367afa28d9f82546e4a6f76ce24b9d495410", "filename": "src/helpers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8356f4cc23ea4c2403011b6c2c619738fce7e32a/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8356f4cc23ea4c2403011b6c2c619738fce7e32a/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=8356f4cc23ea4c2403011b6c2c619738fce7e32a", "patch": "@@ -42,6 +42,7 @@ const UNIX_IO_ERROR_TABLE: &[(std::io::ErrorKind, &str)] = {\n         (AlreadyExists, \"EEXIST\"),\n         (WouldBlock, \"EWOULDBLOCK\"),\n         (DirectoryNotEmpty, \"ENOTEMPTY\"),\n+        (FilesystemLoop, \"ELOOP\"),\n     ]\n };\n "}, {"sha": "b9f3a435ea429e0437cfa338c16b78b36ab61fb1", "filename": "src/shims/os_str.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8356f4cc23ea4c2403011b6c2c619738fce7e32a/src%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8356f4cc23ea4c2403011b6c2c619738fce7e32a/src%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fos_str.rs?ref=8356f4cc23ea4c2403011b6c2c619738fce7e32a", "patch": "@@ -250,6 +250,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.write_os_str_to_wide_str(&os_str, ptr, size)\n     }\n \n+    /// Allocate enough memory to store a Path as a null-terminated sequence of bytes,\n+    /// adjusting path separators if needed.\n+    fn alloc_path_as_c_str(\n+        &mut self,\n+        path: &Path,\n+        memkind: MemoryKind<MiriMemoryKind>,\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n+        let this = self.eval_context_mut();\n+        let os_str = this\n+            .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n+        this.alloc_os_str_as_c_str(&os_str, memkind)\n+    }\n+\n     fn convert_path_separator<'a>(\n         &self,\n         os_str: Cow<'a, OsStr>,"}, {"sha": "36be1ec4f6fa040ca76d9a3f9ed8abf9e32d1e06", "filename": "src/shims/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8356f4cc23ea4c2403011b6c2c619738fce7e32a/src%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8356f4cc23ea4c2403011b6c2c619738fce7e32a/src%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Ffs.rs?ref=8356f4cc23ea4c2403011b6c2c619738fce7e32a", "patch": "@@ -1700,7 +1700,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // the resolved pathname, and returns a pointer to this buffer.  The\n                     // caller should deallocate this buffer using free(3).\"\n                     // <https://man7.org/linux/man-pages/man3/realpath.3.html>\n-                    this.alloc_os_str_as_c_str(resolved.as_os_str(), MiriMemoryKind::C.into())?\n+                    this.alloc_path_as_c_str(&resolved, MiriMemoryKind::C.into())?\n                 } else {\n                     let (wrote_path, _) =\n                         this.write_path_to_c_str(&resolved, processed_ptr, path_max)?;"}, {"sha": "c7331b110e9ad3ab4b1cab4fe74e528f7aa48fb5", "filename": "tests/pass/libc.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8356f4cc23ea4c2403011b6c2c619738fce7e32a/tests%2Fpass%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8356f4cc23ea4c2403011b6c2c619738fce7e32a/tests%2Fpass%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flibc.rs?ref=8356f4cc23ea4c2403011b6c2c619738fce7e32a", "patch": "@@ -23,7 +23,6 @@ fn tmp() -> PathBuf {\n fn test_posix_realpath_alloc() {\n     use std::ffi::OsString;\n     use std::ffi::{CStr, CString};\n-    use std::fs::{remove_file, File};\n     use std::os::unix::ffi::OsStrExt;\n     use std::os::unix::ffi::OsStringExt;\n \n@@ -51,7 +50,6 @@ fn test_posix_realpath_alloc() {\n /// Test non-allocating variant of `realpath`.\n fn test_posix_realpath_noalloc() {\n     use std::ffi::{CStr, CString};\n-    use std::fs::{remove_file, File};\n     use std::os::unix::ffi::OsStrExt;\n \n     let path = tmp().join(\"miri_test_libc_posix_realpath_noalloc\");\n@@ -78,12 +76,8 @@ fn test_posix_realpath_noalloc() {\n \n /// Test failure cases for `realpath`.\n fn test_posix_realpath_errors() {\n-    use std::convert::TryInto;\n     use std::ffi::CString;\n-    use std::fs::{create_dir_all, remove_dir_all};\n     use std::io::ErrorKind;\n-    use std::os::unix::ffi::OsStrExt;\n-    use std::os::unix::fs::symlink;\n \n     // Test non-existent path returns an error.\n     let c_path = CString::new(\"./nothing_to_see_here\").expect(\"CString::new failed\");\n@@ -92,48 +86,6 @@ fn test_posix_realpath_errors() {\n     let e = std::io::Error::last_os_error();\n     assert_eq!(e.raw_os_error(), Some(libc::ENOENT));\n     assert_eq!(e.kind(), ErrorKind::NotFound);\n-\n-    // Test that a long path returns an error.\n-    //\n-    // Linux first checks if the path exists and macos does not.\n-    // Using an existing path ensures all platforms return `ENAMETOOLONG` given a long path.\n-    //\n-    // Rather than creating a bunch of directories, we create two directories containing symlinks.\n-    // Sadly we can't avoid creating directories and instead use a path like \"./././././\" or \"./../../\" as linux\n-    // appears to collapse \".\" and \"..\" before checking path length.\n-    let path = tmp().join(\"posix_realpath_errors\");\n-    // Cleanup before test.\n-    remove_dir_all(&path).ok();\n-\n-    // The directories we will put symlinks in.\n-    let x = path.join(\"x/\");\n-    let y = path.join(\"y/\");\n-\n-    // The symlinks in each directory pointing to each other.\n-    let yx_sym = y.join(\"x\");\n-    let xy_sym = x.join(\"y\");\n-\n-    // Create directories.\n-    create_dir_all(&x).expect(\"dir x\");\n-    create_dir_all(&y).expect(\"dir y\");\n-\n-    // Create symlinks between directories.\n-    symlink(&x, &yx_sym).expect(\"symlink x\");\n-    symlink(&y, &xy_sym).expect(\"symlink y \");\n-\n-    // This path exists due to the symlinks created above.\n-    let too_long = path.join(\"x/y/\".repeat(libc::PATH_MAX.try_into().unwrap()));\n-\n-    let c_path = CString::new(too_long.into_os_string().as_bytes()).expect(\"CString::new failed\");\n-    let r = unsafe { libc::realpath(c_path.as_ptr(), std::ptr::null_mut()) };\n-    let e = std::io::Error::last_os_error();\n-\n-    assert!(r.is_null());\n-    assert_eq!(e.raw_os_error(), Some(libc::ENAMETOOLONG));\n-    assert_eq!(e.kind(), ErrorKind::InvalidFilename);\n-\n-    // Cleanup after test.\n-    remove_dir_all(&path).ok();\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]"}]}