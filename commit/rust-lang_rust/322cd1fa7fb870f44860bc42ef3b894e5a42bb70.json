{"sha": "322cd1fa7fb870f44860bc42ef3b894e5a42bb70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMmNkMWZhN2ZiODcwZjQ0ODYwYmM0MmVmM2I4OTRlNWE0MmJiNzA=", "commit": {"author": {"name": "unexge", "email": "unexge@gmail.com", "date": "2021-04-21T13:42:47Z"}, "committer": {"name": "unexge", "email": "unexge@gmail.com", "date": "2021-04-21T13:42:47Z"}, "message": "Use multiple loops instead of `Iterator::chain` in `FindUsages`", "tree": {"sha": "a103767f932ae5b65383238acf73b765b7f11451", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a103767f932ae5b65383238acf73b765b7f11451"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/322cd1fa7fb870f44860bc42ef3b894e5a42bb70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/322cd1fa7fb870f44860bc42ef3b894e5a42bb70", "html_url": "https://github.com/rust-lang/rust/commit/322cd1fa7fb870f44860bc42ef3b894e5a42bb70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/322cd1fa7fb870f44860bc42ef3b894e5a42bb70/comments", "author": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6630266ce17112bb42f2fa62f975d53512ace682", "url": "https://api.github.com/repos/rust-lang/rust/commits/6630266ce17112bb42f2fa62f975d53512ace682", "html_url": "https://github.com/rust-lang/rust/commit/6630266ce17112bb42f2fa62f975d53512ace682"}], "stats": {"total": 35, "additions": 22, "deletions": 13}, "files": [{"sha": "8f899ea56b03e39b9a01d9a25251be627a32cad1", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/322cd1fa7fb870f44860bc42ef3b894e5a42bb70/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/322cd1fa7fb870f44860bc42ef3b894e5a42bb70/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=322cd1fa7fb870f44860bc42ef3b894e5a42bb70", "patch": "@@ -4,10 +4,9 @@\n //! get a super-set of matches. Then, we we confirm each match using precise\n //! name resolution.\n \n-use std::{convert::TryInto, iter, mem};\n+use std::{convert::TryInto, mem};\n \n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n-use either::Either;\n use hir::{\n     DefWithBody, HasAttrs, HasSource, InFile, ModuleDef, ModuleSource, Semantics, Visibility,\n };\n@@ -370,37 +369,47 @@ impl<'a> FindUsages<'a> {\n \n             let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n \n-            let matches = text.match_indices(pat).chain(if search_for_self {\n-                Either::Left(text.match_indices(\"Self\"))\n-            } else {\n-                Either::Right(iter::empty())\n-            });\n-\n-            for (idx, _) in matches {\n+            let mut handle_match = |idx: usize| -> bool {\n                 let offset: TextSize = idx.try_into().unwrap();\n                 if !search_range.contains_inclusive(offset) {\n-                    continue;\n+                    return false;\n                 }\n \n                 if let Some(name) = sema.find_node_at_offset_with_descend(&tree, offset) {\n                     match name {\n                         ast::NameLike::NameRef(name_ref) => {\n                             if self.found_name_ref(&name_ref, sink) {\n-                                return;\n+                                return true;\n                             }\n                         }\n                         ast::NameLike::Name(name) => {\n                             if self.found_name(&name, sink) {\n-                                return;\n+                                return true;\n                             }\n                         }\n                         ast::NameLike::Lifetime(lifetime) => {\n                             if self.found_lifetime(&lifetime, sink) {\n-                                return;\n+                                return true;\n                             }\n                         }\n                     }\n                 }\n+\n+                return false;\n+            };\n+\n+            for (idx, _) in text.match_indices(pat) {\n+                if handle_match(idx) {\n+                    return;\n+                }\n+            }\n+\n+            if search_for_self {\n+                for (idx, _) in text.match_indices(\"Self\") {\n+                    if handle_match(idx) {\n+                        return;\n+                    }\n+                }\n             }\n         }\n     }"}]}