{"sha": "2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiZDQ2ZTc2N2MwZmU1YjYxODhkZjYxY2I5ZGFmOGYyZTY1YTNlZDA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-24T01:31:43Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-28T01:47:59Z"}, "message": "librustc: Fix problem with cross-crate reexported static methods.", "tree": {"sha": "1de097b17cb353b0e9a8dad943c535c1c6905a8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1de097b17cb353b0e9a8dad943c535c1c6905a8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0", "html_url": "https://github.com/rust-lang/rust/commit/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c37e3b7f82b16229d7595b17cbefc5ed9339511", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c37e3b7f82b16229d7595b17cbefc5ed9339511", "html_url": "https://github.com/rust-lang/rust/commit/6c37e3b7f82b16229d7595b17cbefc5ed9339511"}], "stats": {"total": 120, "additions": 95, "deletions": 25}, "files": [{"sha": "2b6c53b3c86159987533f8a26f7586d7cb19d22b", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0", "patch": "@@ -368,7 +368,7 @@ pub fn write_boxplot(w: @io::Writer, s: &Summary, width_hint: uint) {\n /// Returns a HashMap with the number of occurrences of every element in the\n /// sequence that the iterator exposes.\n pub fn freq_count<T: Iterator<U>, U: Eq+Hash>(mut iter: T) -> hashmap::HashMap<U, uint> {\n-    let mut map = hashmap::HashMap::new::<U, uint>();\n+    let mut map: hashmap::HashMap<U,uint> = hashmap::HashMap::new();\n     for elem in iter {\n         map.insert_or_update_with(elem, 1, |_, count| *count += 1);\n     }"}, {"sha": "336c07c9d6e9cc8eedfc64a0de69b848e14bda11", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 50, "deletions": 6, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0", "patch": "@@ -733,6 +733,56 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                                                 child_def_id,\n                                                 cdata.cnum);\n                 callback(def_like, child_name);\n+\n+            }\n+        }\n+\n+        true\n+    };\n+\n+    // As a special case, iterate over all static methods of\n+    // associated implementations too. This is a bit of a botch.\n+    // --pcwalton\n+    let _ = do reader::tagged_docs(item_doc,\n+                                   tag_items_data_item_inherent_impl)\n+            |inherent_impl_def_id_doc| {\n+        let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc,\n+                                               cdata);\n+        let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n+        match maybe_find_item(inherent_impl_def_id.node, items) {\n+            None => {}\n+            Some(inherent_impl_doc) => {\n+                let _ = do reader::tagged_docs(inherent_impl_doc,\n+                                               tag_item_impl_method)\n+                        |impl_method_def_id_doc| {\n+                    let impl_method_def_id =\n+                        reader::with_doc_data(impl_method_def_id_doc,\n+                                              parse_def_id);\n+                    let impl_method_def_id =\n+                        translate_def_id(cdata, impl_method_def_id);\n+                    match maybe_find_item(impl_method_def_id.node, items) {\n+                        None => {}\n+                        Some(impl_method_doc) => {\n+                            match item_family(impl_method_doc) {\n+                                StaticMethod | UnsafeStaticMethod => {\n+                                    // Hand off the static method\n+                                    // to the callback.\n+                                    let static_method_name =\n+                                        item_name(intr, impl_method_doc);\n+                                    let static_method_def_like =\n+                                        item_to_def_like(impl_method_doc,\n+                                                         impl_method_def_id,\n+                                                         cdata.cnum);\n+                                    callback(static_method_def_like,\n+                                             static_method_name);\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                    }\n+\n+                    true\n+                };\n             }\n         }\n \n@@ -1403,15 +1453,9 @@ pub fn each_implementation_for_type(cdata: cmd,\n                                     id: ast::NodeId,\n                                     callback: &fn(ast::def_id)) {\n     let item_doc = lookup_item(id, cdata.data);\n-    /*println(fmt!(\">>> reading inherent impls from %s\",\n-                 token::ident_to_str(&item_name(token::get_ident_interner(),\n-                                                item_doc))));*/\n     do reader::tagged_docs(item_doc, tag_items_data_item_inherent_impl)\n             |impl_doc| {\n         let implementation_def_id = item_def_id(impl_doc, cdata);\n-        /*println(fmt!(\">>>>> read inherent impl: %d:%d\",\n-                     implementation_def_id.crate,\n-                     implementation_def_id.node));*/\n         callback(implementation_def_id);\n         true\n     };"}, {"sha": "790dff2886fa09f7e488f327efa93df1451e3548", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0", "patch": "@@ -513,8 +513,12 @@ fn encode_reexports(ecx: &EncodeContext,\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for %d\", id);\n             for exp in exports.iter() {\n-                debug!(\"(encoding info for module) reexport '%s' for %d\",\n-                       exp.name, id);\n+                debug!(\"(encoding info for module) reexport '%s' (%d/%d) for \\\n+                        %d\",\n+                       exp.name,\n+                       exp.def_id.crate,\n+                       exp.def_id.node,\n+                       id);\n                 ebml_w.start_tag(tag_items_data_item_reexport);\n                 ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n                 ebml_w.wr_str(def_to_str(exp.def_id));"}, {"sha": "2989f1047298ccace23c91427c3adab797062ffb", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0", "patch": "@@ -1658,7 +1658,8 @@ impl Resolver {\n                            new_parent: ReducedGraphParent) {\n         let privacy = visibility_to_privacy(visibility);\n         match def {\n-          def_mod(def_id) | def_foreign_mod(def_id) => {\n+          def_mod(def_id) | def_foreign_mod(def_id) | def_struct(def_id) |\n+          def_ty(def_id) => {\n             match child_name_bindings.type_def {\n               Some(TypeNsDef { module_def: Some(module_def), _ }) => {\n                 debug!(\"(building reduced graph for external crate) \\\n@@ -1680,6 +1681,11 @@ impl Resolver {\n               }\n             }\n           }\n+          _ => {}\n+        }\n+\n+        match def {\n+          def_mod(_) | def_foreign_mod(_) => {}\n           def_variant(*) => {\n             debug!(\"(building reduced graph for external crate) building \\\n                     variant %s\",\n@@ -1691,7 +1697,7 @@ impl Resolver {\n           }\n           def_fn(*) | def_static_method(*) | def_static(*) => {\n             debug!(\"(building reduced graph for external \\\n-                    crate) building value %s\", final_ident);\n+                    crate) building value (fn/static) %s\", final_ident);\n             child_name_bindings.define_value(privacy, def, dummy_sp());\n           }\n           def_trait(def_id) => {\n@@ -1903,13 +1909,21 @@ impl Resolver {\n \n     /// Builds the reduced graph rooted at the given external module.\n     fn populate_external_module(@mut self, module: @mut Module) {\n+        debug!(\"(populating external module) attempting to populate %s\",\n+               self.module_to_str(module));\n+\n         let def_id = match module.def_id {\n-            None => return,\n+            None => {\n+                debug!(\"(populating external module) ... no def ID!\");\n+                return\n+            }\n             Some(def_id) => def_id,\n         };\n \n         do csearch::each_child_of_item(self.session.cstore, def_id)\n                 |def_like, child_ident| {\n+            debug!(\"(populating external module) ... found ident: %s\",\n+                   token::ident_to_str(&child_ident));\n             self.build_reduced_graph_for_external_crate_def(module,\n                                                             def_like,\n                                                             child_ident)\n@@ -3871,7 +3885,7 @@ impl Resolver {\n                           generics: &Generics,\n                           fields: &[@struct_field],\n                           visitor: &mut ResolveVisitor) {\n-        let mut ident_map = HashMap::new::<ast::ident, @struct_field>();\n+        let mut ident_map: HashMap<ast::ident,@struct_field> = HashMap::new();\n         for &field in fields.iter() {\n             match field.node.kind {\n                 named_field(ident, _) => {"}, {"sha": "c2053b20983e3330dfb8b9eefecdf0afd54640d7", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0", "patch": "@@ -1303,15 +1303,17 @@ fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n         };\n \n         let test_function: ~fn() = || {\n-            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let io: *mut IoFactoryObject = unsafe {\n+                Local::unsafe_borrow()\n+            };\n             let addr = next_test_ip4();\n             let maybe_socket = unsafe { (*io).udp_bind(addr) };\n             // this socket is bound to this event loop\n             assert!(maybe_socket.is_ok());\n \n             // block self on sched1\n             do task::unkillable { // FIXME(#8674)\n-                let scheduler = Local::take::<Scheduler>();\n+                let scheduler: ~Scheduler = Local::take();\n                 do scheduler.deschedule_running_task_and_then |_, task| {\n                     // unblock task\n                     do task.wake().map_move |task| {\n@@ -1377,7 +1379,9 @@ fn test_simple_homed_udp_io_bind_then_move_handle_then_home_and_close() {\n         let chan = Cell::new(chan);\n \n         let body1: ~fn() = || {\n-            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let io: *mut IoFactoryObject = unsafe {\n+                Local::unsafe_borrow()\n+            };\n             let addr = next_test_ip4();\n             let socket = unsafe { (*io).udp_bind(addr) };\n             assert!(socket.is_ok());\n@@ -1489,7 +1493,9 @@ fn test_simple_tcp_server_and_client_on_diff_threads() {\n         };\n \n         let server_fn: ~fn() = || {\n-            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let io: *mut IoFactoryObject = unsafe {\n+                Local::unsafe_borrow()\n+            };\n             let mut listener = unsafe { (*io).tcp_bind(server_addr).unwrap() };\n             let mut stream = listener.accept().unwrap();\n             let mut buf = [0, .. 2048];\n@@ -1501,7 +1507,9 @@ fn test_simple_tcp_server_and_client_on_diff_threads() {\n         };\n \n         let client_fn: ~fn() = || {\n-            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let io: *mut IoFactoryObject = unsafe {\n+                Local::unsafe_borrow()\n+            };\n             let mut stream = unsafe { (*io).tcp_connect(client_addr) };\n             while stream.is_err() {\n                 stream = unsafe { (*io).tcp_connect(client_addr) };"}, {"sha": "c004b3d0e5498fb821eda257abf44e2beec7124c", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs?ref=2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0", "patch": "@@ -13,8 +13,7 @@\n use std::hashmap::HashMap;\n \n fn main() {\n-    let mut buggy_map :HashMap<uint, &uint> =\n-      HashMap::new::<uint, &uint>();\n+    let mut buggy_map: HashMap<uint, &uint> = HashMap::new();\n     buggy_map.insert(42, &*~1); //~ ERROR borrowed value does not live long enough\n \n     // but it is ok if we use a temporary"}, {"sha": "19423c6690f316a77aa1ae2192c5d7fef7797af4", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0", "patch": "@@ -14,8 +14,8 @@ use std::hashmap::HashMap;\n // Test that trait types printed in error msgs include the type arguments.\n \n fn main() {\n-    let x: @Map<~str, ~str> = @HashMap::new::<~str, ~str>() as\n-        @Map<~str, ~str>;\n+    let x: @HashMap<~str, ~str> = @HashMap::new();\n+    let x: @Map<~str, ~str> = x as @Map<~str, ~str>;\n     let y: @Map<uint, ~str> = @x;\n     //~^ ERROR expected trait std::container::Map but found @-ptr\n }"}, {"sha": "c3946b330103aa57ee361d81dd1349c6698f14da", "filename": "src/test/compile-fail/private-variant-xc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Ftest%2Fcompile-fail%2Fprivate-variant-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Ftest%2Fcompile-fail%2Fprivate-variant-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-variant-xc.rs?ref=2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0", "patch": "@@ -1,4 +1,5 @@\n // aux-build:private_variant_xc.rs\n+// xfail-test\n \n extern mod private_variant_xc;\n "}, {"sha": "371bac7a902feecd1470aa8d9fcd6bdbcaf202dc", "filename": "src/test/compile-fail/xc-private-method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxc-private-method.rs?ref=2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0", "patch": "@@ -7,10 +7,10 @@ fn main() {\n     // normal method on struct\n     let _ = xc_private_method_lib::Struct{ x: 10 }.meth_struct();  //~ ERROR method `meth_struct` is private\n     // static method on struct\n-    let _ = xc_private_method_lib::Struct::static_meth_struct();  //~ ERROR function `static_meth_struct` is private\n+    let _ = xc_private_method_lib::Struct::static_meth_struct();  //~ ERROR method `static_meth_struct` is private\n \n     // normal method on enum\n     let _ = xc_private_method_lib::Variant1(20).meth_enum();  //~ ERROR method `meth_enum` is private\n     // static method on enum\n-    let _ = xc_private_method_lib::Enum::static_meth_enum();  //~ ERROR function `static_meth_enum` is private\n+    let _ = xc_private_method_lib::Enum::static_meth_enum();  //~ ERROR method `static_meth_enum` is private\n }"}, {"sha": "ce471e5c827ecd6e1ac2f107fc86083c3d3307b5", "filename": "src/test/run-pass/issue-3026.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3026.rs?ref=2bd46e767c0fe5b6188df61cb9daf8f2e65a3ed0", "patch": "@@ -13,7 +13,7 @@\n use std::hashmap::HashMap;\n \n pub fn main() {\n-    let mut buggy_map: HashMap<uint, &uint> = HashMap::new::<uint, &uint>();\n+    let mut buggy_map: HashMap<uint, &uint> = HashMap::new();\n     let x = ~1;\n     buggy_map.insert(42, &*x);\n }"}]}