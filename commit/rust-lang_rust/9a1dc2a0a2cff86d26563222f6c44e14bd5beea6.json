{"sha": "9a1dc2a0a2cff86d26563222f6c44e14bd5beea6", "node_id": "C_kwDOAAsO6NoAKDlhMWRjMmEwYTJjZmY4NmQyNjU2MzIyMmY2YzQ0ZTE0YmQ1YmVlYTY", "commit": {"author": {"name": "Martin Geisler", "email": "mgeisler@google.com", "date": "2022-05-03T12:23:28Z"}, "committer": {"name": "Martin Geisler", "email": "mgeisler@google.com", "date": "2022-05-03T12:49:04Z"}, "message": "Remove hard links from `env::current_exe` security example\n\nThe security example shows that `env::current_exe` will return the\npath used when the program was started. This is not really surprising\nconsidering how hard links work: after `ln foo bar`, the two files are\n_equivalent_. It is _not_ the case that `bar` is a \u201clink\u201d to `foo`,\nnor is `foo` a link to `bar`. They are simply two names for the same\nunderlying data.\n\nThe security vulnerability linked to seems to be different: there an\nattacker would start a SUID binary from a directory under the control\nof the attacker. The binary would respawn itself by executing the\nprogram found at `/proc/self/exe` (which the attacker can control).\nThis is a real problem. In my opinion, the example given here doesn\u2019t\nreally show the same problem, it just shows a misunderstanding of what\nhard links are.\n\nI looked through the history a bit and found that the example was\nintroduced in #33526. That PR actually has two commits, and the\nfirst (8478d48dad949b3b1374569a5391089a49094eeb) explains the race\ncondition at the root of the linked security vulnerability. The second\ncommit proceeds to replace the explanation with the example we have\ntoday.\n\nThis commit reverts most of the second commit from #33526.", "tree": {"sha": "67322e9c40649df19b25c5c4253d9a36bf4ad438", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67322e9c40649df19b25c5c4253d9a36bf4ad438"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a1dc2a0a2cff86d26563222f6c44e14bd5beea6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a1dc2a0a2cff86d26563222f6c44e14bd5beea6", "html_url": "https://github.com/rust-lang/rust/commit/9a1dc2a0a2cff86d26563222f6c44e14bd5beea6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a1dc2a0a2cff86d26563222f6c44e14bd5beea6/comments", "author": {"login": "mgeisler", "id": 89623, "node_id": "MDQ6VXNlcjg5NjIz", "avatar_url": "https://avatars.githubusercontent.com/u/89623?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mgeisler", "html_url": "https://github.com/mgeisler", "followers_url": "https://api.github.com/users/mgeisler/followers", "following_url": "https://api.github.com/users/mgeisler/following{/other_user}", "gists_url": "https://api.github.com/users/mgeisler/gists{/gist_id}", "starred_url": "https://api.github.com/users/mgeisler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mgeisler/subscriptions", "organizations_url": "https://api.github.com/users/mgeisler/orgs", "repos_url": "https://api.github.com/users/mgeisler/repos", "events_url": "https://api.github.com/users/mgeisler/events{/privacy}", "received_events_url": "https://api.github.com/users/mgeisler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mgeisler", "id": 89623, "node_id": "MDQ6VXNlcjg5NjIz", "avatar_url": "https://avatars.githubusercontent.com/u/89623?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mgeisler", "html_url": "https://github.com/mgeisler", "followers_url": "https://api.github.com/users/mgeisler/followers", "following_url": "https://api.github.com/users/mgeisler/following{/other_user}", "gists_url": "https://api.github.com/users/mgeisler/gists{/gist_id}", "starred_url": "https://api.github.com/users/mgeisler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mgeisler/subscriptions", "organizations_url": "https://api.github.com/users/mgeisler/orgs", "repos_url": "https://api.github.com/users/mgeisler/repos", "events_url": "https://api.github.com/users/mgeisler/events{/privacy}", "received_events_url": "https://api.github.com/users/mgeisler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "468492c2af3993f18b1fe98052200575c4a2e678", "url": "https://api.github.com/repos/rust-lang/rust/commits/468492c2af3993f18b1fe98052200575c4a2e678", "html_url": "https://github.com/rust-lang/rust/commit/468492c2af3993f18b1fe98052200575c4a2e678"}], "stats": {"total": 47, "additions": 17, "deletions": 30}, "files": [{"sha": "e287a93da7b03ed837fd3cc7c09dbd5b6432dfdf", "filename": "library/std/src/env.rs", "status": "modified", "additions": 17, "deletions": 30, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9a1dc2a0a2cff86d26563222f6c44e14bd5beea6/library%2Fstd%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a1dc2a0a2cff86d26563222f6c44e14bd5beea6/library%2Fstd%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fenv.rs?ref=9a1dc2a0a2cff86d26563222f6c44e14bd5beea6", "patch": "@@ -644,36 +644,23 @@ pub fn temp_dir() -> PathBuf {\n ///\n /// # Security\n ///\n-/// The output of this function should not be used in anything that might have\n-/// security implications. For example:\n-///\n-/// ```\n-/// fn main() {\n-///     println!(\"{:?}\", std::env::current_exe());\n-/// }\n-/// ```\n-///\n-/// On Linux systems, if this is compiled as `foo`:\n-///\n-/// ```bash\n-/// $ rustc foo.rs\n-/// $ ./foo\n-/// Ok(\"/home/alex/foo\")\n-/// ```\n-///\n-/// And you make a hard link of the program:\n-///\n-/// ```bash\n-/// $ ln foo bar\n-/// ```\n-///\n-/// When you run it, you won\u2019t get the path of the original executable, you\u2019ll\n-/// get the path of the hard link:\n-///\n-/// ```bash\n-/// $ ./bar\n-/// Ok(\"/home/alex/bar\")\n-/// ```\n+/// The output of this function should not be trusted for anything\n+/// that might have security implications. Basically, if users can run\n+/// the executable, they can change the output arbitrarily.\n+///\n+/// As an example, you can easily introduce a race condition. It goes\n+/// like this:\n+///\n+/// 1. You get the path to the current executable using `current_exe()`, and\n+///    store it in a variable.\n+/// 2. Time passes. A malicious actor removes the current executable, and\n+///    replaces it with a malicious one.\n+/// 3. You then use the stored path to re-execute the current\n+///    executable.\n+///\n+/// You expected to safely execute the current executable, but you're\n+/// instead executing something completely different. The code you\n+/// just executed run with your privileges.\n ///\n /// This sort of behavior has been known to [lead to privilege escalation] when\n /// used incorrectly."}]}